{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload the video. If self.client.cache_enabled is True, then the disk cache is used. Returns: The path where the video has been saved. Raises: DownloadError: If the video cannot be downloaded.", "response": "def download_video(self):\n        \"\"\"Downloads the video.\n\n        If self.client.cache_enabled is True, then the disk cache is used.\n\n        Returns:\n            The path where the video has been saved.\n\n        Raises:\n            DownloadError: If the video cannot be downloaded.\n        \"\"\"\n        rvideo_path = self.presentation.metadata['video_path']\n\n        if self.presentation.client.cache:\n            video_path = self.presentation.client.cache.get_path(rvideo_path)\n            if not video_path:\n                video_path = self.download_video_no_cache()\n                self.presentation.client.cache.put_path(rvideo_path, video_path)\n        else:\n            video_path = self.download_video_no_cache()\n\n        return video_path"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading the video and saves it in the cache.", "response": "def download_video_no_cache(self):\n        \"\"\"Downloads the video.\n\n        Returns:\n            The path where the video has been saved.\n\n        Raises:\n            DownloadError: If the video cannot be downloaded.\n        \"\"\"\n        video_url = self.presentation.metadata['video_url']\n        video_path = self.presentation.metadata['video_path']\n\n        # After a while, when downloading a long video (> 1h), the RTMP server seems to reset the connection (rtmpdump\n        # returns exit code 2). The only way to get the full stream is to resume the download.\n        resume_download = True\n        while resume_download:\n            try:\n                cmd = [self.rtmpdump, '-q', '-e', '-r', video_url, '-y', video_path, \"-o\", self._video_path]\n                subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n                resume_download = False\n            except subprocess.CalledProcessError as e:\n                if e.returncode != 2:\n                    try:\n                        os.unlink(self._video_path)\n                    except OSError:\n                        pass\n\n                    raise client.DownloadError(\"Failed to download video at %s: rtmpdump exited with %s.\\n\\tOutput:\\n%s\"\n                                           % (video_url, e.returncode, e.output))\n\n        return self._video_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads all SWF slides.", "response": "def download_slides(self):\n        \"\"\" Download all SWF slides.\n\n        The location of the slides files are returned.\n\n        A DownloadError is raised if at least one of the slides cannot be download..\n        \"\"\"\n        return self.presentation.client.download_all(self.presentation.metadata['slides'], self.tmp_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef login(self, username, password):\n        url = get_url(\"/login.action\", scheme=\"https\")\n        params = {\n            'username': username,\n            'password': password,\n            'submit-login': '',\n        }\n        with contextlib.closing(self.opener.open(url, urllib.parse.urlencode(params))) as response:\n            if not \"loginAction.jsp\" in response.url:\n                raise AuthenticationError(\"Login failed. Unexpected redirection: %s\" % response.url)\n            if not \"resultMessage=success\" in response.url:\n                raise AuthenticationError(\"Login failed.\")\n\n        self.authenticated = True", "response": "Log in.\n\n        AuthenticationFailedException exception is raised if authentication fails."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches the resource specified and return its content.", "response": "def fetch_no_cache(self, url):\n        \"\"\" Fetch the resource specified and return its content.\n\n            DownloadError is raised if the resource cannot be fetched.\n        \"\"\"\n        try:\n\n            with contextlib.closing(self.opener.open(url)) as response:\n                # InfoQ does not send a 404 but a 302 redirecting to a valid URL...\n                if response.code != 200 or response.url == INFOQ_404_URL:\n                    raise DownloadError(\"%s not found\" % url)\n                return response.read()\n        except urllib.error.URLError as e:\n            raise DownloadError(\"Failed to get %s: %s\" % (url, e))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndownload the resources specified by url into dir_path.", "response": "def download(self, url, dir_path, filename=None):\n        \"\"\" Download the resources specified by url into dir_path. The resulting\n            file path is returned.\n\n            DownloadError is raised the resources cannot be downloaded.\n        \"\"\"\n        if not filename:\n            filename = url.rsplit('/', 1)[1]\n        path = os.path.join(dir_path, filename)\n\n        content = self.fetch(url)\n        with open(path, \"wb\") as f:\n            f.write(content)\n\n        return path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading all the resources specified by urls into dir_path.", "response": "def download_all(self, urls, dir_path):\n        \"\"\" Download all the resources specified by urls into dir_path. The resulting\n            file paths is returned.\n\n            DownloadError is raised if at least one of the resources cannot be downloaded.\n            In the case already downloaded resources are erased.\n        \"\"\"\n        # TODO: Implement parallel download\n        filenames = []\n\n        try:\n            for url in urls:\n                filenames.append(self.download(url, dir_path))\n        except DownloadError as e:\n            for filename in filenames:\n                os.remove(filename)\n            raise e\n\n        return filenames"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npushes a byte onto the stack.", "response": "def push_byte(self, stack_pointer, byte):\n        \"\"\" pushed a byte onto stack \"\"\"\n        # FIXME: self.system_stack_pointer -= 1\n        stack_pointer.decrement(1)\n        addr = stack_pointer.value\n\n#        log.info(\n#         log.error(\n#            \"%x|\\tpush $%x to %s stack at $%x\\t|%s\",\n#            self.last_op_address, byte, stack_pointer.name, addr,\n#            self.cfg.mem_info.get_shortest(self.last_op_address)\n#        )\n        self.memory.write_byte(addr, byte)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pull_byte(self, stack_pointer):\n        addr = stack_pointer.value\n        byte = self.memory.read_byte(addr)\n#        log.info(\n#         log.error(\n#            \"%x|\\tpull $%x from %s stack at $%x\\t|%s\",\n#            self.last_op_address, byte, stack_pointer.name, addr,\n#            self.cfg.mem_info.get_shortest(self.last_op_address)\n#        )\n\n        # FIXME: self.system_stack_pointer += 1\n        stack_pointer.increment(1)\n\n        return byte", "response": "pulls a byte from the stack"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfill in notebook context with default values.", "response": "def prepare_notebook_context(request, notebook_context):\n    \"\"\"Fill in notebook context with default values.\"\"\"\n\n    if not notebook_context:\n        notebook_context = {}\n\n    # Override notebook Jinja templates\n    if \"extra_template_paths\" not in notebook_context:\n        notebook_context[\"extra_template_paths\"] = [os.path.join(os.path.dirname(__file__), \"server\", \"templates\")]\n\n    # Furious invalid state follows if we let this slip through\n    assert type(notebook_context[\"extra_template_paths\"]) == list, \"Got bad extra_template_paths {}\".format(notebook_context[\"extra_template_paths\"])\n\n    # Jinja variables\n    notebook_context[\"jinja_environment_options\"] = notebook_context.get(\"jinja_environment_options\", {})\n\n    assert type(notebook_context[\"jinja_environment_options\"]) == dict\n\n    # XXX: Following passing of global variables to Jinja templates requires Jinja 2.8.0dev+ version and is not yet supported\n    # http://jinja.pocoo.org/docs/dev/api/#jinja2.Environment.globals\n\n    # notebook_context[\"jinja_environment_options\"][\"globals\"] = notebook_context[\"jinja_environment_options\"].get(\"globals\", {})\n    # globals_ = notebook_context[\"jinja_environment_options\"][\"globals\"]\n    #\n    # assert type(globals_) == dict\n    #\n    # if not \"home_url\" in globals_:\n    #     globals_[\"home_url\"] = request.host_url\n    #\n    # if not \"home_title\" in globals_:\n    #     globals_[\"home_title\"] = \"Back to site\"\n\n    # Tell notebook to correctly address WebSockets allow origin policy\n    notebook_context[\"allow_origin\"] = route_to_alt_domain(request, request.host_url)\n    notebook_context[\"notebook_path\"] = request.route_path(\"notebook_proxy\", remainder=\"\")\n\n    # Record the hash of the current parameters, so we know if this user accesses the notebook in this or different context\n    if \"context_hash\" not in notebook_context:\n        notebook_context[\"context_hash\"] = make_dict_hash(notebook_context)\n\n    print(notebook_context)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlaunching a new notebook on demand.", "response": "def launch_on_demand(request, username, notebook_context):\n    \"\"\"See if we have notebook already running this context and if not then launch new one.\"\"\"\n    security_check(request, username)\n\n    settings = request.registry.settings\n\n    notebook_folder = settings.get(\"pyramid_notebook.notebook_folder\", None)\n    if not notebook_folder:\n        raise RuntimeError(\"Setting missing: pyramid_notebook.notebook_folder\")\n\n    kill_timeout = settings.get(\"pyramid_notebook.kill_timeout\", None)\n    if not kill_timeout:\n        raise RuntimeError(\"Setting missing: pyramid_notebook.kill_timeout\")\n\n    kill_timeout = int(kill_timeout)\n\n    if not notebook_context:\n        notebook_context = {}\n\n    # Override notebook Jinja templates\n    if \"extra_template_paths\" not in notebook_context:\n        notebook_context[\"extra_template_paths\"] = [os.path.join(os.path.dirname(__file__), \"server\", \"templates\")]\n\n    # Furious invalid state follows if we let this slip through\n    assert type(notebook_context[\"extra_template_paths\"]) == list, \"Got bad extra_template_paths {}\".format(notebook_context[\"extra_template_paths\"])\n    notebook_folder = settings.get(\"pyramid_notebook.notebook_folder\", None)\n    if not notebook_folder:\n        raise RuntimeError(\"Setting missing: pyramid_notebook.notebook_folder\")\n\n    kill_timeout = settings.get(\"pyramid_notebook.kill_timeout\", None)\n    if not kill_timeout:\n        raise RuntimeError(\"Setting missing: pyramid_notebook.kill_timeout\")\n\n    kill_timeout = int(kill_timeout)\n\n    prepare_notebook_context(request, notebook_context)\n\n    # Configure websockets\n    # websocket_url = settings.get(\"pyramid_notebook.websocket_url\")\n    # assert websocket_url, \"pyramid_notebook.websocket_url setting missing\"\n    # assert websocket_url.startswith(\"ws:/\") or websocket_url.startswith(\"wss:/\")\n\n    if request.registry.settings.get(\"pyramid_notebook.websocket_proxy\", \"\"):\n        websocket_url = route_to_alt_domain(request, request.host_url)\n        websocket_url = websocket_url.replace(\"http://\", \"ws://\").replace(\"https://\", \"wss://\")\n        notebook_context[\"websocket_url\"] = websocket_url\n    else:\n        # Connect websockets directly to localhost notebook server, do not try to proxy them\n        websocket_url = \"ws://localhost:{port}/notebook/\"\n\n    # Record the hash of the current parameters, so we know if this user accesses the notebook in this or different context\n    if \"context_hash\" not in notebook_context:\n        notebook_context[\"context_hash\"] = make_dict_hash(notebook_context)\n\n    manager = NotebookManager(notebook_folder, kill_timeout=kill_timeout)\n    notebook_info, creates = manager.start_notebook_on_demand(username, notebook_context)\n    return notebook_info"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrendering a IPython Notebook frame wrapper.", "response": "def notebook_proxy(request, username):\n    \"\"\"Renders a IPython Notebook frame wrapper.\n\n    Starts or reattachs ot an existing Notebook session.\n    \"\"\"\n    security_check(request, username)\n\n    manager = get_notebook_manager(request)\n    notebook_info = manager.get_context(username)\n\n    if not notebook_info:\n        raise HTTPInternalServerError(\"Apparently IPython Notebook daemon process is not running for {}\".format(username))\n\n    if 'http_port' not in notebook_info:\n        raise RuntimeError(\"Notebook terminated prematurely before managed to tell us its HTTP port\")\n\n    return proxy_it(request, notebook_info[\"http_port\"])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlaunch a IPython Notebook frame wrapper.", "response": "def launch_notebook(request, username, notebook_context):\n    \"\"\"Renders a IPython Notebook frame wrapper.\n\n    Starts or reattachs ot an existing Notebook session.\n    \"\"\"\n    # The notebook manage now tries too hard to get the port allocated for the notebook user, making it slow\n    # TODO: Manage a proper state e.g. using Redis\n    notebook_info = launch_on_demand(request, username, notebook_context)\n\n    # Jump to the detault notebook\n    proxy_route = request.route_url(\"notebook_proxy\", remainder=\"notebooks/{}\".format(notebook_info[\"notebook_name\"]))\n    proxy_route = route_to_alt_domain(request, proxy_route)\n\n    return HTTPFound(proxy_route)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef shutdown_notebook(request, username):\n\n    manager = get_notebook_manager(request)\n    if manager.is_running(username):\n        manager.stop_notebook(username)", "response": "Stop any running notebook for a user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_dict_hash(o):\n    if isinstance(o, (set, tuple, list)):\n        return tuple([make_dict_hash(e) for e in o])\n    elif not isinstance(o, dict):\n        return hash(o)\n\n    new_o = copy.deepcopy(o)\n    for k, v in new_o.items():\n        new_o[k] = make_dict_hash(v)\n\n    return hash(tuple(frozenset(sorted(new_o.items()))))", "response": "Make a hash from a dictionary list tuple or set to any level containing\n    only other hashable types including any lists tuples sets and dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nroutes URL to a different domain.", "response": "def route_to_alt_domain(request, url):\n    \"\"\"Route URL to a different subdomain.\n\n    Used to rewrite URLs to point to websocket serving domain.\n    \"\"\"\n\n    # Do we need to route IPython Notebook request from a different location\n    alternative_domain = request.registry.settings.get(\"pyramid_notebook.alternative_domain\", \"\").strip()\n    if alternative_domain:\n        url = url.replace(request.host_url, alternative_domain)\n\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a QIndex to a buffer index", "response": "def qindex2index(index):\n        \"\"\" from a QIndex (row/column coordinate system), get the buffer index of the byte \"\"\"\n        r = index.row()\n        c = index.column()\n        if c > 0x10:\n            return (0x10 * r) + c - 0x11\n        else:\n            return (0x10 * r) + c"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the given buffer indices to the given QItemSelection both byte and char panes.", "response": "def _bselect(self, selection, start_bindex, end_bindex):\n        \"\"\" add the given buffer indices to the given QItemSelection, both byte and char panes \"\"\"\n        selection.select(self._model.index2qindexb(start_bindex), self._model.index2qindexb(end_bindex))\n        selection.select(self._model.index2qindexc(start_bindex), self._model.index2qindexc(end_bindex))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _do_select(self, start_bindex, end_bindex):\n        self.select(QItemSelection(), QItemSelectionModel.Clear)\n        if start_bindex > end_bindex:\n            start_bindex, end_bindex = end_bindex, start_bindex\n\n        selection = QItemSelection()\n        if row_number(end_bindex) - row_number(start_bindex) == 0:\n            # all on one line\n            self._bselect(selection, start_bindex, end_bindex)\n        elif row_number(end_bindex) - row_number(start_bindex) == 1:\n            # two lines\n            self._bselect(selection, start_bindex, row_end_index(start_bindex))\n            self._bselect(selection, row_start_index(end_bindex), end_bindex)\n        else:\n            # many lines\n            self._bselect(selection, start_bindex, row_end_index(start_bindex))\n            self._bselect(selection, row_start_index(start_bindex) + 0x10, row_end_index(end_bindex) - 0x10)\n            self._bselect(selection, row_start_index(end_bindex), end_bindex)\n\n        self.select(selection, QItemSelectionModel.SelectCurrent)\n        self.start = start_bindex\n        self.end = end_bindex\n        self.selectionRangeChanged.emit(end_bindex)", "response": "Select the given range by buffer indices."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _update_selection(self, qindex1, qindex2):\n        m = self.model()\n        self._do_select(m.qindex2index(qindex1), m.qindex2index(qindex2))", "response": "update the selection by qmodel indices"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_context_menu(self, qpoint):\n        menu = QMenu(self)\n        index = self.view.indexAt(qpoint)\n\n        def add_action(menu, text, handler, icon=None):\n            a = None\n            if icon is None:\n                a = QAction(text, self)\n            else:\n                a = QAction(icon, text, self)\n            a.triggered.connect(handler)\n            menu.addAction(a)\n\n        add_action(menu, \"Color selection\", self._handle_color_selection)\n\n        # duplication here with vstructui\n        color_menu = menu.addMenu(\"Color selection...\")\n\n        # need to escape the closure capture on the color loop variable below\n        # hint from: http://stackoverflow.com/a/6035865/87207\n        def make_color_selection_handler(color):\n            return lambda: self._handle_color_selection(color=color)\n\n        for color in QT_COLORS:\n            add_action(color_menu, \"{:s}\".format(color.name),\n                       make_color_selection_handler(color.qcolor), make_color_icon(color.qcolor))\n\n        start = self._hsm.start\n        end = self._hsm.end\n        cm = self.getColorModel()\n        if (start == end and cm.is_index_colored(start)) or cm.is_region_colored(start, end):\n            def make_remove_color_handler(r):\n                return lambda: self._handle_remove_color_range(r)\n\n            remove_color_menu = menu.addMenu(\"Remove color...\")\n            for cr in cm.get_region_colors(start, end):\n                pixmap = QPixmap(10, 10)\n                pixmap.fill(cr.color)\n                icon = QIcon(pixmap)\n                add_action(remove_color_menu,\n                       \"Remove color [{:s}, {:s}], len: {:s}\".format(h(cr.begin), h(cr.end), h(cr.end - cr.begin)),\n                       make_remove_color_handler(cr), make_color_icon(cr.color))\n\n        menu.addSeparator()  # -----------------------------------------------------------------\n\n        add_action(menu, \"Copy selection (binary)\", self._handle_copy_binary)\n        copy_menu = menu.addMenu(\"Copy...\")\n        add_action(copy_menu, \"Copy selection (binary)\", self._handle_copy_binary)\n        add_action(copy_menu, \"Copy selection (text)\", self._handle_copy_text)\n        add_action(copy_menu, \"Copy selection (hex)\", self._handle_copy_hex)\n        add_action(copy_menu, \"Copy selection (hexdump)\", self._handle_copy_hexdump)\n        add_action(copy_menu, \"Copy selection (base64)\", self._handle_copy_base64)\n\n        menu.addSeparator()  # -----------------------------------------------------------------\n\n        add_action(menu, \"Add origin\", lambda: self._handle_add_origin(index))\n        return menu", "response": "override this method to customize the context menu"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nactivate the user with the given activation key.", "response": "def activate(request, activation_key=None):\n    \"\"\"\n    Given an an activation key, look up and activate the user\n    account corresponding to that key (if possible).\n\n    \"\"\"\n    utils.activate_user(activation_key)\n    # if not activated\n    success_url = utils.get_settings('REGISTRATION_API_ACTIVATION_SUCCESS_URL')\n    if success_url is not None:\n        return HttpResponseRedirect(success_url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_state(self):\n        return {\n            REG_X: self.index_x.value,\n            REG_Y: self.index_y.value,\n\n            REG_U: self.user_stack_pointer.value,\n            REG_S: self.system_stack_pointer.value,\n\n            REG_PC: self.program_counter.value,\n\n            REG_A: self.accu_a.value,\n            REG_B: self.accu_b.value,\n\n            REG_DP: self.direct_page.value,\n            REG_CC: self.get_cc_value(),\n\n            \"cycles\": self.cycles,\n            \"RAM\": tuple(self.memory._mem) # copy of array.array() values,\n        }", "response": "Returns a dictionary of state values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_state(self, state):\n        self.index_x.set(state[REG_X])\n        self.index_y.set(state[REG_Y])\n\n        self.user_stack_pointer.set(state[REG_U])\n        self.system_stack_pointer.set(state[REG_S])\n\n        self.program_counter.set(state[REG_PC])\n\n        self.accu_a.set(state[REG_A])\n        self.accu_b.set(state[REG_B])\n\n        self.direct_page.set(state[REG_DP])\n        self.set_cc(state[REG_CC])\n\n        self.cycles = state[\"cycles\"]\n        self.memory.load(address=0x0000, data=state[\"RAM\"])", "response": "Sets the state of the current log entry."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a CPU cycle triggered callback.", "response": "def add_sync_callback(self, callback_cycles, callback):\n        \"\"\" Add a CPU cycle triggered callback \"\"\"\n        self.sync_callbacks_cyles[callback] = 0\n        self.sync_callbacks.append([callback_cycles, callback])\n        if self.quickest_sync_callback_cycles is None or \\\n                        self.quickest_sync_callback_cycles > callback_cycles:\n            self.quickest_sync_callback_cycles = callback_cycles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall every sync callback with CPU cycles trigger", "response": "def call_sync_callbacks(self):\n        \"\"\" Call every sync callback with CPU cycles trigger \"\"\"\n        current_cycles = self.cycles\n        for callback_cycles, callback in self.sync_callbacks:\n            # get the CPU cycles count of the last call\n            last_call_cycles = self.sync_callbacks_cyles[callback]\n\n            if current_cycles - last_call_cycles > callback_cycles:\n                # this callback should be called\n\n                # Save the current cycles, to trigger the next call\n                self.sync_callbacks_cyles[callback] = self.cycles\n\n                # Call the callback function\n                callback(current_cycles - last_call_cycles)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef burst_run(self):\n        # https://wiki.python.org/moin/PythonSpeed/PerformanceTips#Avoiding_dots...\n        get_and_call_next_op = self.get_and_call_next_op\n\n        for __ in range(self.outer_burst_op_count):\n            for __ in range(self.inner_burst_op_count):\n                get_and_call_next_op()\n\n            self.call_sync_callbacks()", "response": "Run CPU as fast as Python can..."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling page 2 or 3", "response": "def instruction_PAGE(self, opcode):\n        \"\"\" call op from page 2 or 3 \"\"\"\n        op_address, opcode2 = self.read_pc_byte()\n        paged_opcode = opcode * 256 + opcode2\n#        log.debug(\"$%x *** call paged opcode $%x\" % (\n#            self.program_counter, paged_opcode\n#        ))\n        self.call_instruction_func(op_address - 1, paged_opcode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds the contents of the C (carry) bit and the memory byte into an 8-bit accumulator. source code forms: ADCA P; ADCB P CC bits \"HNZVC\": aaaaa", "response": "def instruction_ADC(self, opcode, m, register):\n        \"\"\"\n        Adds the contents of the C (carry) bit and the memory byte into an 8-bit\n        accumulator.\n\n        source code forms: ADCA P; ADCB P\n\n        CC bits \"HNZVC\": aaaaa\n        \"\"\"\n        a = register.value\n        r = a + m + self.C\n        register.set(r)\n#        log.debug(\"$%x %02x ADC %s: %i + %i + %i = %i (=$%x)\" % (\n#            self.program_counter, opcode, register.name,\n#            a, m, self.C, r, r\n#        ))\n        self.clear_HNZVC()\n        self.update_HNZVC_8(a, m, r)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the 16 - bit memory value into the 16 - bit accumulator.", "response": "def instruction_ADD16(self, opcode, m, register):\n        \"\"\"\n        Adds the 16-bit memory value into the 16-bit accumulator\n\n        source code forms: ADDD P\n\n        CC bits \"HNZVC\": -aaaa\n        \"\"\"\n        assert register.WIDTH == 16\n        old = register.value\n        r = old + m\n        register.set(r)\n#        log.debug(\"$%x %02x %02x ADD16 %s: $%02x + $%02x = $%02x\" % (\n#            self.program_counter, opcode, m,\n#            register.name,\n#            old, m, r\n#        ))\n        self.clear_NZVC()\n        self.update_NZVC_16(old, m, r)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the memory byte into an 8-bit accumulator. source code forms: ADDA P; ADDB P CC bits \"HNZVC\": aaaaa", "response": "def instruction_ADD8(self, opcode, m, register):\n        \"\"\"\n        Adds the memory byte into an 8-bit accumulator.\n\n        source code forms: ADDA P; ADDB P\n\n        CC bits \"HNZVC\": aaaaa\n        \"\"\"\n        assert register.WIDTH == 8\n        old = register.value\n        r = old + m\n        register.set(r)\n#         log.debug(\"$%x %02x %02x ADD8 %s: $%02x + $%02x = $%02x\" % (\n#             self.program_counter, opcode, m,\n#             register.name,\n#             old, m, r\n#         ))\n        self.clear_HNZVC()\n        self.update_HNZVC_8(old, m, r)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef COM(self, value):\n        value = ~value # the bits of m inverted\n        self.clear_NZ()\n        self.update_NZ01_8(value)\n        return value", "response": "set the COM bits HNZVC bit"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef instruction_COM_memory(self, opcode, ea, m):\n        r = self.COM(value=m)\n#        log.debug(\"$%x COM memory $%x to $%x\" % (\n#            self.program_counter, m, r,\n#        ))\n        return ea, r & 0xff", "response": "Sets the contents of memory location M with its logical complement."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreplacing the contents of accumulator A or B with its logical complement.", "response": "def instruction_COM_register(self, opcode, register):\n        \"\"\"\n        Replaces the contents of accumulator A or B with its logical complement.\n        source code forms: COMA; COMB\n        \"\"\"\n        register.set(self.COM(value=register.value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef DEC(self, a):\n        r = a - 1\n        self.clear_NZV()\n        self.update_NZ_8(r)\n        if r == 0x7f:\n            self.V = 1\n        return r", "response": "Subtract one from the register and update the carry bit."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds to the register.", "response": "def instruction_INC_register(self, opcode, register):\n        \"\"\"\n        Adds to the register. The carry bit is not affected, thus allowing this\n        instruction to be used as a loop counter in multiple-precision\n        computations. When operating on unsigned values, only the BEQ and BNE\n        branches can be expected to behave consistently. When operating on twos\n        complement values, all signed branches are correctly available.\n\n        source code forms: INC Q; INCA; INCB\n\n        CC bits \"HNZVC\": -aaa-\n        \"\"\"\n        a = register.value\n        r = self.INC(a)\n        r = register.set(r)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nincrement the memory of the key - store entry for the specified memory location.", "response": "def instruction_INC_memory(self, opcode, ea, m):\n        \"\"\"\n        Adds to the register. The carry bit is not affected, thus allowing this\n        instruction to be used as a loop counter in multiple-precision\n        computations. When operating on unsigned values, only the BEQ and BNE\n        branches can be expected to behave consistently. When operating on twos\n        complement values, all signed branches are correctly available.\n\n        source code forms: INC Q; INCA; INCB\n\n        CC bits \"HNZVC\": -aaa-\n        \"\"\"\n        r = self.INC(m)\n        return ea, r & 0xff"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef instruction_LEA_register(self, opcode, ea, register):\n#         log.debug(\"$%04x LEA %s: Set %s to $%04x \\t| %s\" % (\n#             self.program_counter,\n#             register.name, register.name, ea,\n#             self.cfg.mem_info.get_shortest(ea)\n#         ))\n        register.set(ea)\n        self.Z = 0\n        self.set_Z16(ea)", "response": "Set the register value for the current LEA."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmultiplying the unsigned binary numbers in the accumulators and places the result in both accumulators and the most - significant byte of the result.", "response": "def instruction_MUL(self, opcode):\n        \"\"\"\n        Multiply the unsigned binary numbers in the accumulators and place the\n        result in both accumulators (ACCA contains the most-significant byte of\n        the result). Unsigned multiply allows multiple-precision operations.\n\n        The C (carry) bit allows rounding the most-significant byte through the\n        sequence: MUL, ADCA #0.\n\n        source code forms: MUL\n\n        CC bits \"HNZVC\": --a-a\n        \"\"\"\n        r = self.accu_a.value * self.accu_b.value\n        self.accu_d.set(r)\n        self.Z = 1 if r == 0 else 0\n        self.C = 1 if r & 0x80 else 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreplace the register with its twos complement. The C (carry) bit represents a borrow and is set to the inverse of the resulting binary carry. Note that 80 16 is replaced by itself and only in this case is the V (overflow) bit set. The value 00 16 is also replaced by itself, and only in this case is the C (carry) bit cleared. source code forms: NEG Q; NEGA; NEG B CC bits \"HNZVC\": uaaaa", "response": "def instruction_NEG_register(self, opcode, register):\n        \"\"\"\n        Replaces the register with its twos complement. The C (carry) bit\n        represents a borrow and is set to the inverse of the resulting binary\n        carry. Note that 80 16 is replaced by itself and only in this case is\n        the V (overflow) bit set. The value 00 16 is also replaced by itself,\n        and only in this case is the C (carry) bit cleared.\n\n        source code forms: NEG Q; NEGA; NEG B\n\n        CC bits \"HNZVC\": uaaaa\n        \"\"\"\n        x = register.value\n        r = x * -1 # same as: r = ~x + 1\n        register.set(r)\n#        log.debug(\"$%04x NEG %s $%02x to $%02x\" % (\n#            self.program_counter, register.name, x, r,\n#        ))\n        self.clear_NZVC()\n        self.update_NZVC_8(0, x, r)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsubtracting the contents of memory location M and the borrow bits and places the result in that register.", "response": "def instruction_SBC(self, opcode, m, register):\n        \"\"\"\n        Subtracts the contents of memory location M and the borrow (in the C\n        (carry) bit) from the contents of the designated 8-bit register, and\n        places the result in that register. The C bit represents a borrow and is\n        set to the inverse of the resulting binary carry.\n\n        source code forms: SBCA P; SBCB P\n\n        CC bits \"HNZVC\": uaaaa\n        \"\"\"\n        a = register.value\n        r = a - m - self.C\n        register.set(r)\n#        log.debug(\"$%x %02x SBC %s: %i - %i - %i = %i (=$%x)\" % (\n#            self.program_counter, opcode, register.name,\n#            a, m, self.C, r, r\n#        ))\n        self.clear_NZVC()\n        self.update_NZVC_8(a, m, r)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef instruction_SEX(self, opcode):\n        b = self.accu_b.value\n        if b & 0x80 == 0:\n            self.accu_a.set(0x00)\n\n        d = self.accu_d.value\n\n#        log.debug(\"SEX: b=$%x ; $%x&0x80=$%x ; d=$%x\", b, b, (b & 0x80), d)\n\n        self.clear_NZ()\n        self.update_NZ_16(d)", "response": "This instruction transforms a twos complement 8 - bit value in accumulator\n            B into a twos complement 16 - bit value in accumulator\n            D."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef instruction_SUB(self, opcode, m, register):\n        r = register.value\n        r_new = r - m\n        register.set(r_new)\n#        log.debug(\"$%x SUB8 %s: $%x - $%x = $%x (dez.: %i - %i = %i)\" % (\n#            self.program_counter, register.name,\n#            r, m, r_new,\n#            r, m, r_new,\n#        ))\n        self.clear_NZVC()\n        if register.WIDTH == 8:\n            self.update_NZVC_8(r, m, r_new)\n        else:\n            assert register.WIDTH == 16\n            self.update_NZVC_16(r, m, r_new)", "response": "Subtraction of the value in memory location M from the contents of a\n        register."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the value of the TFR register.", "response": "def instruction_TFR(self, opcode, m):\n        \"\"\"\n        source code forms: TFR R1, R2\n        CC bits \"HNZVC\": ccccc\n        \"\"\"\n        high, low = divmod(m, 16)\n        dst_reg = self._get_register_obj(low)\n        src_reg = self._get_register_obj(high)\n        src_value = convert_differend_width(src_reg, dst_reg)\n        dst_reg.set(src_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the value of the EXG register in the last two registers.", "response": "def instruction_EXG(self, opcode, m):\n        \"\"\"\n        source code forms: EXG R1,R2\n        CC bits \"HNZVC\": ccccc\n        \"\"\"\n        high, low = divmod(m, 0x10)\n        reg1 = self._get_register_obj(high)\n        reg2 = self._get_register_obj(low)\n\n        new_reg1_value = convert_differend_width(reg2, reg1)\n        new_reg2_value = convert_differend_width(reg1, reg2)\n\n        reg1.set(new_reg1_value)\n        reg2.set(new_reg2_value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts binary data to a Hex - Editor like format.", "response": "def bin2hexline(data, add_addr=True, width=16):\n    \"\"\"\n    Format binary data to a Hex-Editor like format...\n\n    e.g.:\n    with open(\"C:\\Python27\\python.exe\", \"rb\") as f:\n        data = f.read(150)\n\n    print(\"\\n\".join(bin2hexline(data, width=16)))\n\n    0000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 MZ..............\n    0016 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@.......\n    0032 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n    0048 00 00 00 00 00 00 00 00 00 00 00 00 e8 00 00 00 ................\n    0064 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 ........!..L.!Th\n    0080 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f is.program.canno\n    0096 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 t.be.run.in.DOS.\n    0112 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00 mode....$.......\n    0128 9d 68 ba 89 d9 09 d4 da d9 09 d4 da d9 09 d4 da .h..............\n    0144 d0 71 41 da d8 09                               .qA...\n    \"\"\"\n    assert isinstance(data, binary_type), (\n        \"is type: %s and not bytes/str: %s\" % (type(data), repr(data))\n    )\n\n    addr = 0\n    lines = []\n    run = True\n    line_width = 4 + (width * 3) + 1\n    while run:\n        if add_addr:\n            line = [\"%04i\" % addr]\n        else:\n            line = []\n\n        ascii_block = \"\"\n        for i in range(width):\n            b = data[addr]\n            if PY2:\n                b = ord(b)\n\n            if chr(b) in string.printable:\n                ascii_block += chr(b)\n            else:\n                ascii_block += \".\"\n\n            line.append(\"%02x\" % b)\n\n            addr += 1\n            if addr >= len(data):\n                run = False\n                break\n\n        line = \" \".join(line)\n        line = line.ljust(line_width)\n        line += ascii_block\n        lines.append(line)\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_0100(self):\n        self.N = 0\n        self.Z = 1\n        self.V = 0\n        self.C = 0", "response": "Update the internal state of the internal state to 0. 0100."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows nicely the generic object received.", "response": "def _str(obj):\n    \"\"\"Show nicely the generic object received.\"\"\"\n    values = []\n    for name in obj._attribs:\n        val = getattr(obj, name)\n        if isinstance(val, str):\n            val = repr(val)\n        val = str(val) if len(str(val)) < 10 else \"(...)\"\n        values.append((name, val))\n    values = \", \".join(\"{}={}\".format(k, v) for k, v in values)\n    return \"{}({})\".format(obj.__class__.__name__, values)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _repr(obj):\n    vals = \", \".join(\"{}={!r}\".format(\n        name, getattr(obj, name)) for name in obj._attribs)\n    if vals:\n        t = \"{}(name={}, {})\".format(obj.__class__.__name__, obj.name, vals)\n    else:\n        t = \"{}(name={})\".format(obj.__class__.__name__, obj.name)\n    return t", "response": "Show the received object as precise as possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a generic object for the tags.", "response": "def _make_object(name):\n    \"\"\"Create a generic object for the tags.\"\"\"\n    klass = type(name, (SWFObject,),\n                 {'__str__': _str, '__repr__': _repr, 'name': name})\n    return klass()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_header(self):\n        fh = self._src\n        obj = _make_object(\"Header\")\n\n        # first part of the header\n        obj.Signature = sign = \"\".join(chr(unpack_ui8(fh)) for _ in range(3))\n        obj.Version = self._version = unpack_ui8(fh)\n        obj.FileLength = file_length = unpack_ui32(fh)\n\n        # deal with compressed content\n        if sign[0] == 'C':\n            uncompressed = zlib.decompress(fh.read())\n            if len(uncompressed) + 8 != file_length:\n                raise ValueError(\"Problems dealing with compressed content\")\n            fh = self._src = io.BytesIO(uncompressed)\n\n        # second part of the header\n        obj.FrameSize = self._get_struct_rect()\n        obj.FrameRate = unpack_ui16(fh)\n        obj.FrameCount = unpack_ui16(fh)\n        return obj", "response": "Parse the SWF header."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a sequence of tags.", "response": "def _process_tags(self):\n        \"\"\"Get a sequence of tags.\"\"\"\n        tags = []\n\n        while True:\n            tag_bf = unpack_ui16(self._src)\n            tag_type = tag_bf >> 6   # upper 10 bits\n            if tag_type == 0:\n                # the end\n                break\n            tag_len = tag_bf & 0x3f  # last 6 bits\n            if tag_len == 0x3f:\n                # the length is the next four bytes!\n                tag_len = unpack_ui32(self._src)\n\n            try:\n                tag_name = TAG_NAMES[tag_type]\n            except KeyError:\n                # malformed SWF, create and unknown object with malformed tag\n                tag_payload = self._src.read(tag_len)\n                _dict = {\n                    '__str__': _repr,\n                    '__repr__': _repr,\n                    'name': 'UnspecifiedObject(tag={!r})'.format(tag_type),\n                }\n                tag = type(\"UnknownObject\", (SWFObject,), _dict)()\n                tag.raw_payload = tag_payload\n                tags.append(tag)\n                continue\n\n            try:\n                tag_meth = getattr(self, \"_handle_tag_\" + tag_name.lower())\n            except AttributeError:\n                if self.unknown_alert:\n                    raise ValueError(\"Unknown tag: \" + repr(tag_name))\n\n                tag_payload = self._src.read(tag_len)\n                _dict = {'__str__': _repr, '__repr__': _repr, 'name': tag_name}\n                tag = type(\"UnknownObject\", (SWFObject,), _dict)()\n                tag.raw_payload = tag_payload\n                tags.append(tag)\n                continue\n\n            # we know the tag type, and have the handler, let's process it\n            prev_pos = self._src.tell()\n            self._src.guard = tag_len\n            try:\n                with ReadQuantityController(self._src, tag_len):\n                    tag = tag_meth()\n                assert tag is not None, tag_name\n            except ValueError:\n                # an attempt to read too much happened; create a failing\n                # object with the raw payload\n                self._src.guard = None\n                self._src.seek(prev_pos)\n                tag_payload = self._src.read(tag_len)\n                _dict = {'__str__': _repr, '__repr__': _repr, 'name': tag_name}\n                tag = type(\"FailingObject\", (SWFObject,), _dict)()\n                tag.raw_payload = tag_payload\n            tags.append(tag)\n        return tags"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handle_tag_definetext(self):\n        obj = _make_object(\"DefineText\")\n        self._generic_definetext_parser(obj, self._get_struct_rgb)\n        return obj", "response": "Handle the DefineText tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle the DefineText2 tag.", "response": "def _handle_tag_definetext2(self):\n        \"\"\"Handle the DefineText2 tag.\"\"\"\n        obj = _make_object(\"DefineText2\")\n        self._generic_definetext_parser(obj, self._get_struct_rgba)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle the DefineEditText tag.", "response": "def _handle_tag_defineedittext(self):\n        \"\"\"Handle the DefineEditText tag.\"\"\"\n        obj = _make_object(\"DefineEditText\")\n        obj.CharacterID = unpack_ui16(self._src)\n        obj.Bounds = self._get_struct_rect()\n\n        bc = BitConsumer(self._src)\n        obj.HasText = bc.u_get(1)\n        obj.WordWrap = bc.u_get(1)\n        obj.Multiline = bc.u_get(1)\n        obj.Password = bc.u_get(1)\n        obj.ReadOnly = bc.u_get(1)\n        obj.HasTextColor = bc.u_get(1)\n        obj.HasMaxLength = bc.u_get(1)\n        obj.HasFont = bc.u_get(1)\n        obj.HasFontClass = bc.u_get(1)\n        obj.AutoSize = bc.u_get(1)\n        obj.HasLayout = bc.u_get(1)\n        obj.NoSelect = bc.u_get(1)\n        obj.Border = bc.u_get(1)\n        obj.WasStatic = bc.u_get(1)\n        obj.HTML = bc.u_get(1)\n        obj.UseOutlines = bc.u_get(1)\n\n        if obj.HasFont:\n            obj.FontID = unpack_ui16(self._src)\n        if obj.HasFontClass:\n            obj.FontClass = self._get_struct_string()\n        if obj.HasFont:\n            obj.FontHeight = unpack_ui16(self._src)\n        if obj.HasTextColor:\n            obj.TextColor = self._get_struct_rgba()\n        if obj.HasMaxLength:\n            obj.MaxLength = unpack_ui16(self._src)\n        if obj.HasLayout:\n            obj.Align = unpack_ui8(self._src)\n            obj.LeftMargin = unpack_ui16(self._src)\n            obj.RightMargin = unpack_ui16(self._src)\n            obj.Indent = unpack_ui16(self._src)\n            obj.Leading = unpack_ui16(self._src)\n\n        obj.VariableName = self._get_struct_string()\n        if obj.HasText:\n            obj.InitialText = self._get_struct_string()\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling the DefineSprite tag.", "response": "def _handle_tag_definesprite(self):\n        \"\"\"Handle the DefineSprite tag.\"\"\"\n        obj = _make_object(\"DefineSprite\")\n        obj.CharacterID = unpack_ui16(self._src)\n        obj.FrameCount = unpack_ui16(self._src)\n        tags = self._process_tags()\n        obj.ControlTags = tags\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _generic_action_parser(self):\n        actions = []\n        while True:\n            action_code = unpack_ui8(self._src)\n            if action_code == 0:\n                break\n\n            action_name = ACTION_NAMES[action_code]\n            if action_code > 128:\n                # have a payload!\n                action_len = unpack_ui16(self._src)\n                try:\n                    action_meth = getattr(\n                        self, \"_handle_\" + action_name.lower())\n                except AttributeError:\n                    if self.unknown_alert:\n                        raise ValueError(\n                            \"Unknown action: \" + repr(action_name))\n\n                    action_payload = self._src.read(action_len)\n                    _dict = {'__str__': _repr, '__repr__': _repr,\n                             'name': action_name}\n                    action = type(\"UnknownAction\", (SWFObject,), _dict)()\n                    action.raw_payload = action_payload\n                    actions.append(action)\n                else:\n                    prev_pos = self._src.tell()\n                    for action in action_meth(action_len):\n                        assert action is not None, action_name\n                        actions.append(action)\n\n                    quant_read = self._src.tell() - prev_pos\n                    if quant_read != action_len:\n                        raise RuntimeError(\n                            \"Bad bytes consumption by action {!r} handler \"\n                            \"(did {}, should {})\".format(\n                                action_name, quant_read, action_len))\n            else:\n                action = _make_object(action_name)\n                actions.append(action)\n        return actions", "response": "Generic parser for Actions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle the FileAttributes tag.", "response": "def _handle_tag_fileattributes(self):\n        \"\"\"Handle the FileAttributes tag.\"\"\"\n        obj = _make_object(\"FileAttributes\")\n        bc = BitConsumer(self._src)\n\n        bc.u_get(1)  # reserved\n        obj.UseDirectBlit = bc.u_get(1)\n        obj.UseGPU = bc.u_get(1)\n        obj.HasMetadata = bc.u_get(1)\n        obj.ActionScript3 = bc.u_get(1)\n        bc.u_get(2)  # reserved\n        obj.UseNetwork = bc.u_get(1)\n        bc.u_get(24)  # reserved\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles the DefineSceneAndFrameLabelData tag.", "response": "def _handle_tag_definesceneandframelabeldata(self):\n        \"\"\"Handle the DefineSceneAndFrameLabelData tag.\"\"\"\n        obj = _make_object(\"DefineSceneAndFrameLabelData\")\n        obj.SceneCount = self._get_struct_encodedu32()\n        for i in range(1, obj.SceneCount + 1):\n            setattr(obj, 'Offset{}'.format(i), self._get_struct_encodedu32())\n            setattr(obj, 'Name{}'.format(i), self._get_struct_string())\n        obj.FrameLabelCount = self._get_struct_encodedu32()\n        for i in range(1, obj.FrameLabelCount + 1):\n            setattr(obj, 'FrameNum{}'.format(i), self._get_struct_encodedu32())\n            setattr(obj, 'FrameLabel{}'.format(i), self._get_struct_string())\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _handle_tag_defineshape4(self):\n        obj = _make_object(\"DefineShape4\")\n        obj.ShapeId = unpack_ui16(self._src)\n        obj.ShapeBounds = self._get_struct_rect()\n        obj.EdgeBounds = self._get_struct_rect()\n\n        bc = BitConsumer(self._src)\n        bc.u_get(5)  # reserved\n        obj.UsesFillWindingRule = bc.u_get(1)\n        obj.UsesNonScalingStrokes = bc.u_get(1)\n        obj.UsesScalingStrokes = bc.u_get(1)\n        obj.Shapes = self._get_struct_shapewithstyle(4)\n        return obj", "response": "Handle the DefineShape4 tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the DefineMorphShape2 tag.", "response": "def _handle_tag_definemorphshape2(self):\n        \"\"\"Handle the DefineMorphShape2 tag.\"\"\"\n        obj = _make_object(\"DefineMorphShape2\")\n        obj.CharacterId = unpack_ui16(self._src)\n        obj.StartBounds = self._get_struct_rect()\n        obj.EndBounds = self._get_struct_rect()\n        obj.StartEdgeBounds = self._get_struct_rect()\n        obj.EndEdgeBounds = self._get_struct_rect()\n\n        bc = BitConsumer(self._src)\n        bc.u_get(6)  # reserved\n        obj.UsesNonScalingStrokes = bc.u_get(1)\n        obj.UsesScalingStrokes = bc.u_get(1)\n\n        obj.Offset = unpack_ui32(self._src)\n\n        # FIXME: this tag needs more work; I'm skipping some attributes here\n        self._src.read(obj.Offset)\n\n        obj.EndEdges = self._get_struct_shape()\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling the RemoveObject tag.", "response": "def _handle_tag_removeobject(self):\n        \"\"\"Handle the RemoveObject tag.\"\"\"\n        obj = _make_object(\"RemoveObject\")\n        obj.CharacterId = unpack_ui16(self._src)\n        obj.Depth = unpack_ui16(self._src)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the RemoveObject2 tag.", "response": "def _handle_tag_removeobject2(self):\n        \"\"\"Handle the RemoveObject2 tag.\"\"\"\n        obj = _make_object(\"RemoveObject2\")\n        obj.Depth = unpack_ui16(self._src)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _handle_tag_defineshape(self):\n        obj = _make_object(\"DefineShape\")\n        obj.ShapeId = unpack_ui16(self._src)\n        obj.ShapeBounds = self._get_struct_rect()\n        obj.Shapes = self._get_struct_shapewithstyle(1)\n        return obj", "response": "Handle the DefineShape tag."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle the DefineButton2 tag.", "response": "def _handle_tag_definebutton2(self):\n        \"\"\"Handle the DefineButton2 tag.\"\"\"\n        obj = _make_object(\"DefineButton2\")\n        obj.ButtonId = unpack_ui16(self._src)\n\n        bc = BitConsumer(self._src)\n        bc.ReservedFlags = bc.u_get(7)\n        bc.TrackAsMenu = bc.u_get(1)\n\n        obj.ActionOffset = unpack_ui16(self._src)\n\n        # characters\n        obj.Characters = characters = []\n        while True:\n            end_flag = unpack_ui8(self._src)\n            if end_flag == 0:\n                # all done\n                obj.CharacterEndFlag = 0\n                break\n\n            # we have a BUTTONRECORD, let's go back the 8 bits and set the obj\n            self._src.seek(-1, io.SEEK_CUR)\n            character = _make_object(\"ButtonRecord\")\n            characters.append(character)\n\n            bc = BitConsumer(self._src)\n            character.ButtonReserved = bc.u_get(2)\n            character.ButtonHasBlendMode = bc.u_get(1)\n            character.ButtonHasFilterList = bc.u_get(1)\n            character.ButtonStateHitTest = bc.u_get(1)\n            character.ButtonStateDown = bc.u_get(1)\n            character.ButtonStateOver = bc.u_get(1)\n            character.ButtonStateUp = bc.u_get(1)\n\n            character.CharacterId = unpack_ui16(self._src)\n            character.PlaceDepth = unpack_ui16(self._src)\n            character.PlaceMatrix = self._get_struct_matrix()\n            character.ColorTransform = self._get_struct_cxformwithalpha()\n            if character.ButtonHasFilterList:\n                character.FilterList = self._get_struct_filterlist()\n            if character.ButtonHasBlendMode:\n                character.BlendMode = unpack_ui8(self._src)\n\n        obj.Actions = actions = []\n        still_have_actions = True\n        while still_have_actions:\n            end_flag = unpack_ui16(self._src)\n            if end_flag == 0:\n                # this is the last action, parse it and then exit\n                still_have_actions = False\n\n            bca = _make_object(\"ButtonCondAction\")\n            actions.append(bca)\n            bca.CondActionSize = end_flag\n\n            bc = BitConsumer(self._src)\n            bca.CondIdleToOverDown = bc.u_get(1)\n            bca.CondOutDownToIdle = bc.u_get(1)\n            bca.CondOutDownToOverDown = bc.u_get(1)\n            bca.CondOverDownToOutDown = bc.u_get(1)\n            bca.CondOverDownToOverUp = bc.u_get(1)\n            bca.CondOverUpToOverDown = bc.u_get(1)\n            bca.CondOverUpToIdle = bc.u_get(1)\n            bca.CondIdleToOverUp = bc.u_get(1)\n\n            bca.CondKeyPress = bc.u_get(7)\n            bca.CondOverDownToIdle = bc.u_get(1)\n            bca.Actions = self._generic_action_parser()\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _handle_tag_enabledebugger2(self):\n        obj = _make_object(\"EnableDebugger2\")\n        obj.Reserved = unpack_ui16(self._src)\n        obj.Password = self._get_struct_string()\n        return obj", "response": "Handle the EnableDebugger2 tag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling the ScriptLimits tag.", "response": "def _handle_tag_scriptlimits(self):\n        \"\"\"Handle the ScriptLimits tag.\"\"\"\n        obj = _make_object(\"ScriptLimits\")\n        obj.MaxRecursionDepth = unpack_ui16(self._src)\n        obj.ScriptTimeoutSeconds = unpack_ui16(self._src)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _handle_tag_jpegtables(self):\n        obj = _make_object(\"JPEGTables\")\n        assert self._src.read(2) == b'\\xFF\\xD8'  # SOI marker\n        eoimark1 = eoimark2 = None\n        allbytes = [b'\\xFF\\xD8']\n        while not (eoimark1 == b'\\xFF' and eoimark2 == b'\\xD9'):\n            newbyte = self._src.read(1)\n            allbytes.append(newbyte)\n            eoimark1 = eoimark2\n            eoimark2 = newbyte\n\n        # concatenate everything, removing the end mark\n        obj.JPEGData = b\"\".join(allbytes[:-2])\n        return obj", "response": "Handle the JPEGTables tag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling the DefineFontAlignZones tag.", "response": "def _handle_tag_definefontalignzones(self):\n        \"\"\"Handle the DefineFontAlignZones tag.\"\"\"\n        obj = _make_object(\"DefineFontAlignZones\")\n        obj.FontId = unpack_ui16(self._src)\n        bc = BitConsumer(self._src)\n        obj.CSMTableHint = bc.u_get(2)\n        obj.Reserved = bc.u_get(6)\n\n        obj.ZoneTable = zone_records = []\n        glyph_count = self._last_defined_glyphs_quantity\n        self._last_defined_glyphs_quantity = None\n        for _ in range(glyph_count):\n            zone_record = _make_object(\"ZoneRecord\")\n            zone_records.append(zone_record)\n            zone_record.NumZoneData = unpack_ui8(self._src)\n            zone_record.ZoneData = zone_data = []\n            for _ in range(zone_record.NumZoneData):\n                zone_datum = _make_object(\"ZoneData\")\n                zone_data.append(zone_datum)\n                zone_datum.AlignmentCoordinate = unpack_float16(self._src)\n                zone_datum.Range = unpack_float16(self._src)\n            bc = BitConsumer(self._src)\n            zone_record.Reserved = bc.u_get(6)\n            zone_record.ZoneMaskY = bc.u_get(1)\n            zone_record.ZoneMaskX = bc.u_get(1)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _handle_tag_definefontname(self):\n        obj = _make_object(\"DefineFontName\")\n        obj.FontId = unpack_ui16(self._src)\n        obj.FontName = self._get_struct_string()\n        obj.FontCopyright = self._get_struct_string()\n        return obj", "response": "Handle the DefineFontName tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _handle_tag_csmtextsettings(self):\n        obj = _make_object(\"CSMTextSettings\")\n        obj.TextId = unpack_ui16(self._src)\n        bc = BitConsumer(self._src)\n        obj.UseFlashType = bc.u_get(2)\n        obj.GridFit = bc.u_get(3)\n        obj.Reserved1 = bc.u_get(3)\n        obj.Thickness = unpack_float(self._src)\n        obj.Sharpness = unpack_float(self._src)\n        obj.Reserved2 = unpack_ui8(self._src)\n        return obj", "response": "Handle the CSMTextSettings tag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the RECT structure.", "response": "def _get_struct_rect(self):\n        \"\"\"Get the RECT structure.\"\"\"\n        bc = BitConsumer(self._src)\n        nbits = bc.u_get(5)\n        if self._read_twips:\n            return tuple(bc.s_get(nbits) for _ in range(4))\n        else:\n            return tuple(bc.s_get(nbits) / 20.0 for _ in range(4))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_struct_kerningrecord(self, font_flags_wide_codes):\n        getter = unpack_ui16 if font_flags_wide_codes else unpack_ui8\n        data = {}\n        data['FontKerningCode1'] = getter(self._src)\n        data['FontKerningCode2'] = getter(self._src)\n        data['FontKerningAdjustment'] = unpack_si16(self._src)\n        return data", "response": "Get the KERNINGRECORD structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the several CLIPACTIONRECORDs.", "response": "def _get_struct_clipactions(self):\n        \"\"\"Get the several CLIPACTIONRECORDs.\"\"\"\n        obj = _make_object(\"ClipActions\")\n\n        # In SWF 5 and earlier, these are 2 bytes wide; in SWF 6\n        # and later 4 bytes\n        clipeventflags_size = 2 if self._version <= 5 else 4\n        clipactionend_size = 2 if self._version <= 5 else 4\n        all_zero = b\"\\x00\" * clipactionend_size\n\n        assert unpack_ui16(self._src) == 0  # reserved\n        obj.AllEventFlags = self._src.read(clipeventflags_size)\n\n        obj.ClipActionRecords = records = []\n        while True:\n            next_bytes = self._src.read(clipactionend_size)\n            if next_bytes == all_zero:\n                # was the ClipActionEndFlag\n                return\n\n            record = _make_object(\"ClipActionRecord\")\n            records.append(record)\n\n            # as event flags and end flag has same size, we can do this trick\n            record.EventFlags = next_bytes\n            record.ActionRecordSize = unpack_ui32(self._src)\n            record.TheRestTODO = self._src.read(record.ActionRecordSize)\n\n            # FIXME: this struct needs more work; the EventFlags should be\n            # expanded and each ActionRecord(s) should be detailed more\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_struct_string(self):\n        data = []\n        while True:\n            t = self._src.read(1)\n            if t == b'\\x00':\n                break\n            data.append(t)\n        val = b''.join(data)\n        return val.decode(\"utf8\")", "response": "Get the STRING structure."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the values for the MATRIX record.", "response": "def _get_struct_matrix(self):\n        \"\"\"Get the values for the MATRIX record.\"\"\"\n        obj = _make_object(\"Matrix\")\n        bc = BitConsumer(self._src)\n\n        # scale\n        obj.HasScale = bc.u_get(1)\n        if obj.HasScale:\n            obj.NScaleBits = n_scale_bits = bc.u_get(5)\n            obj.ScaleX = bc.fb_get(n_scale_bits)\n            obj.ScaleY = bc.fb_get(n_scale_bits)\n\n        # rotate\n        obj.HasRotate = bc.u_get(1)\n        if obj.HasRotate:\n            obj.NRotateBits = n_rotate_bits = bc.u_get(5)\n            obj.RotateSkew0 = bc.fb_get(n_rotate_bits)\n            obj.RotateSkew1 = bc.fb_get(n_rotate_bits)\n\n        # translate\n        obj.NTranslateBits = n_translate_bits = bc.u_get(5)\n        obj.TranslateX = bc.s_get(n_translate_bits)\n        obj.TranslateY = bc.s_get(n_translate_bits)\n        if not self._read_twips:\n            obj.TranslateX /= 20.0\n            obj.TranslateY /= 20.0\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_struct_cxformwithalpha(self):\n        obj = _make_object(\"CXformWithAlpha\")\n        bc = BitConsumer(self._src)\n\n        obj.HasAddTerms = bc.u_get(1)\n        obj.HasMultTerms = bc.u_get(1)\n        obj.NBits = nbits = bc.u_get(4)\n\n        if obj.HasMultTerms:\n            obj.RedMultTerm = bc.s_get(nbits)\n            obj.GreenMultTerm = bc.s_get(nbits)\n            obj.BlueMultTerm = bc.s_get(nbits)\n            obj.AlphaMultTerm = bc.s_get(nbits)\n\n        if obj.HasAddTerms:\n            obj.RedAddTerm = bc.s_get(nbits)\n            obj.GreenAddTerm = bc.s_get(nbits)\n            obj.BlueAddTerm = bc.s_get(nbits)\n            obj.AlphaAddTerm = bc.s_get(nbits)\n\n        return obj", "response": "Get the values for the CXFORMWITHALPHA record."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an array of SHAPERECORDS.", "response": "def _get_shaperecords(self, num_fill_bits,\n                          num_line_bits, shape_number):\n        \"\"\"Return an array of SHAPERECORDS.\"\"\"\n        shape_records = []\n        bc = BitConsumer(self._src)\n\n        while True:\n            type_flag = bc.u_get(1)\n            if type_flag:\n                # edge record\n                straight_flag = bc.u_get(1)\n                num_bits = bc.u_get(4)\n                if straight_flag:\n                    record = _make_object('StraightEdgeRecord')\n                    record.TypeFlag = 1\n                    record.StraightFlag = 1\n                    record.NumBits = num_bits\n                    record.GeneralLineFlag = general_line_flag = bc.u_get(1)\n                    if general_line_flag:\n                        record.DeltaX = bc.s_get(num_bits + 2)\n                        record.DeltaY = bc.s_get(num_bits + 2)\n                    else:\n                        record.VertLineFlag = vert_line_flag = bc.s_get(1)\n                        if vert_line_flag:\n                            record.DeltaY = bc.s_get(num_bits + 2)\n                        else:\n                            record.DeltaX = bc.s_get(num_bits + 2)\n                else:\n                    record = _make_object('CurvedEdgeRecord')\n                    record.TypeFlag = 1\n                    record.StraightFlag = 0\n                    record.NumBits = num_bits\n                    record.ControlDeltaX = bc.s_get(num_bits + 2)\n                    record.ControlDeltaY = bc.s_get(num_bits + 2)\n                    record.AnchorDeltaX = bc.s_get(num_bits + 2)\n                    record.AnchorDeltaY = bc.s_get(num_bits + 2)\n\n            else:\n                # non edge record\n                record = _make_object('StyleChangeRecord')\n                record.TypeFlag = 0\n\n                five_bits = [bc.u_get(1) for _ in range(5)]\n                if not any(five_bits):\n                    # the five bits are zero, this is an EndShapeRecord\n                    break\n\n                # we're not done, store the proper flags\n                (record.StateNewStyles, record.StateLineStyle,\n                    record.StateFillStyle1, record.StateFillStyle0,\n                    record.StateMoveTo) = five_bits\n\n                if record.StateMoveTo:\n                    record.MoveBits = move_bits = bc.u_get(5)\n                    record.MoveDeltaX = bc.s_get(move_bits)\n                    record.MoveDeltaY = bc.s_get(move_bits)\n                if record.StateFillStyle0:\n                    record.FillStyle0 = bc.u_get(num_fill_bits)\n                if record.StateFillStyle1:\n                    record.FillStyle1 = bc.u_get(num_fill_bits)\n                if record.StateLineStyle:\n                    record.LineStyle = bc.u_get(num_line_bits)\n\n                if record.StateNewStyles:\n                    record.FillStyles = self._get_struct_fillstylearray(\n                        shape_number)\n                    record.LineStyles = self._get_struct_linestylearray(\n                        shape_number)\n                    # these two not only belong to the record, but also\n                    # modifies the number of bits read in the future\n                    # if shape number bigs enough (didn't find this in the\n                    # spec, but works for now, maybe '2' is not the limit...)\n                    if shape_number > 2:\n                        record.NumFillBits = num_fill_bits = bc.u_get(4)\n                        record.NumLineBits = num_line_bits = bc.u_get(4)\n                    else:\n                        record.NumFillBits = bc.u_get(4)\n                        record.NumLineBits = bc.u_get(4)\n\n                    # reset the BC here, as the structures just read work at\n                    # byte level\n                    bc = BitConsumer(self._src)\n\n            shape_records.append(record)\n        return shape_records"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_struct_shape(self):\n        obj = _make_object(\"Shape\")\n        bc = BitConsumer(self._src)\n        obj.NumFillBits = n_fill_bits = bc.u_get(4)\n        obj.NumLineBits = n_line_bits = bc.u_get(4)\n        obj.ShapeRecords = self._get_shaperecords(\n            n_fill_bits, n_line_bits, 0)\n        return obj", "response": "Get the values for the SHAPE record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the values for the FILLSTYLE record.", "response": "def _get_struct_fillstyle(self, shape_number):\n        \"\"\"Get the values for the FILLSTYLE record.\"\"\"\n        obj = _make_object(\"FillStyle\")\n        obj.FillStyleType = style_type = unpack_ui8(self._src)\n\n        if style_type == 0x00:\n            if shape_number <= 2:\n                obj.Color = self._get_struct_rgb()\n            else:\n                obj.Color = self._get_struct_rgba()\n\n        if style_type in (0x10, 0x12, 0x13):\n            obj.GradientMatrix = self._get_struct_matrix()\n\n        if style_type in (0x10, 0x12):\n            obj.Gradient = self._get_struct_gradient(shape_number)\n        if style_type == 0x13:\n            obj.Gradient = self._get_struct_focalgradient(shape_number)\n\n        if style_type in (0x40, 0x41, 0x42, 0x43):\n            obj.BitmapId = unpack_ui16(self._src)\n            obj.BitmapMatrix = self._get_struct_matrix()\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the values for the FILLSTYLEARRAY record.", "response": "def _get_struct_fillstylearray(self, shape_number):\n        \"\"\"Get the values for the FILLSTYLEARRAY record.\"\"\"\n        obj = _make_object(\"FillStyleArray\")\n        obj.FillStyleCount = count = unpack_ui8(self._src)\n        if count == 0xFF:\n            obj.FillStyleCountExtended = count = unpack_ui16(self._src)\n        obj.FillStyles = [self._get_struct_fillstyle(shape_number)\n                          for _ in range(count)]\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_struct_linestylearray(self, shape_number):\n        obj = _make_object(\"LineStyleArray\")\n        obj.LineStyleCount = count = unpack_ui8(self._src)\n        if count == 0xFF:\n            obj.LineStyleCountExtended = count = unpack_ui16(self._src)\n        obj.LineStyles = line_styles = []\n\n        for _ in range(count):\n            if shape_number <= 3:\n                record = _make_object(\"LineStyle\")\n                record.Width = unpack_ui16(self._src)\n                if shape_number <= 2:\n                    record.Color = self._get_struct_rgb()\n                else:\n                    record.Color = self._get_struct_rgba()\n            else:\n                record = _make_object(\"LineStyle2\")\n                record.Width = unpack_ui16(self._src)\n\n                bc = BitConsumer(self._src)\n                record.StartCapStyle = bc.u_get(2)\n                record.JoinStyle = bc.u_get(2)\n                record.HasFillFlag = bc.u_get(1)\n                record.NoHScaleFlag = bc.u_get(1)\n                record.NoVScaleFlag = bc.u_get(1)\n                record.PixelHintingFlag = bc.u_get(1)\n\n                bc.u_get(5)  # reserved\n                record.NoClose = bc.u_get(1)\n                record.EndCapStyle = bc.u_get(2)\n\n                if record.JoinStyle == 2:\n                    record.MiterLimitFactor = unpack_ui16(self._src)\n                if record.HasFillFlag == 0:\n                    record.Color = self._get_struct_rgba()\n                else:\n                    record.Color = self._get_struct_fillstyle(shape_number)\n\n            line_styles.append(record)\n\n        return obj", "response": "Get the values for the LINESTYLEARRAY record."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a EncodedU32 number.", "response": "def _get_struct_encodedu32(self):\n        \"\"\"Get a EncodedU32 number.\"\"\"\n        useful = []\n        while True:\n            byte = ord(self._src.read(1))\n            useful.append(byte)\n            if byte < 127:\n                # got all the useful bytes\n                break\n\n        # transform into bits reordering the bytes\n        useful = ['00000000' + bin(b)[2:] for b in useful[::-1]]\n\n        # get the top 7 (*seven*, as the eight one is the flag) and convert\n        return int(''.join([b[-7:] for b in useful]), 2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_struct_shapewithstyle(self, shape_number):\n        obj = _make_object(\"ShapeWithStyle\")\n        obj.FillStyles = self._get_struct_fillstylearray(shape_number)\n        obj.LineStyles = self._get_struct_linestylearray(shape_number)\n        bc = BitConsumer(self._src)\n        obj.NumFillBits = n_fill_bits = bc.u_get(4)\n        obj.NumlineBits = n_line_bits = bc.u_get(4)\n        obj.ShapeRecords = self._get_shaperecords(\n            n_fill_bits, n_line_bits, shape_number)\n        return obj", "response": "Get the values for the SHAPEWITHSTYLE record."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the values for the GRADIENT record.", "response": "def _get_struct_gradient(self, shape_number):\n        \"\"\"Get the values for the GRADIENT record.\"\"\"\n        obj = _make_object(\"Gradient\")\n        bc = BitConsumer(self._src)\n        obj.SpreadMode = bc.u_get(2)\n        obj.InterpolationMode = bc.u_get(2)\n        obj.NumGradients = bc.u_get(4)\n        obj.GradientRecords = gradient_records = []\n\n        for _ in range(obj.NumGradients):\n            record = _make_object(\"GradRecord\")\n            gradient_records.append(record)\n            record.Ratio = unpack_ui8(self._src)\n            if shape_number <= 2:\n                record.Color = self._get_struct_rgb()\n            else:\n                record.Color = self._get_struct_rgba()\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the values for the FILTERLIST record.", "response": "def _get_struct_filterlist(self):\n        \"\"\"Get the values for the FILTERLIST record.\"\"\"\n        obj = _make_object(\"FilterList\")\n        obj.NumberOfFilters = unpack_ui8(self._src)\n        obj.Filter = filters = []\n        # how to decode each filter type (and name), according to the filter id\n        filter_type = [\n            (\"DropShadowFilter\", self._get_struct_dropshadowfilter),  # 0\n            (\"BlurFilter\", self._get_struct_blurfilter),  # 1\n            (\"GlowFilter\", self._get_struct_glowfilter),  # 2...\n            (\"BevelFilter\", self._get_struct_bevelfilter),\n            (\"GradientGlowFilter\", self._get_struct_gradientglowfilter),\n            (\"ConvolutionFilter\", self._get_struct_convolutionfilter),\n            (\"ColorMatrixFilter\", self._get_struct_colormatrixfilter),\n            (\"GradientBevelFilter\", self._get_struct_gradientbevelfilter),  # 7\n        ]\n\n        for _ in range(obj.NumberOfFilters):\n            _filter = _make_object(\"Filter\")\n            filters.append(_filter)\n\n            _filter.FilterId = unpack_ui8(self._src)\n            name, func = filter_type[_filter.FilterId]\n            setattr(_filter, name, func())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the values for the DROPSHADOWFILTER record.", "response": "def _get_struct_dropshadowfilter(self):\n        \"\"\"Get the values for the DROPSHADOWFILTER record.\"\"\"\n        obj = _make_object(\"DropShadowFilter\")\n        obj.DropShadowColor = self._get_struct_rgba()\n        obj.BlurX = unpack_fixed16(self._src)\n        obj.BlurY = unpack_fixed16(self._src)\n        obj.Angle = unpack_fixed16(self._src)\n        obj.Distance = unpack_fixed16(self._src)\n        obj.Strength = unpack_fixed8(self._src)\n        bc = BitConsumer(self._src)\n        obj.InnerShadow = bc.u_get(1)\n        obj.Knockout = bc.u_get(1)\n        obj.CompositeSource = bc.u_get(1)\n        obj.Passes = bc.u_get(5)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the values for the BLURFILTER record.", "response": "def _get_struct_blurfilter(self):\n        \"\"\"Get the values for the BLURFILTER record.\"\"\"\n        obj = _make_object(\"BlurFilter\")\n        obj.BlurX = unpack_fixed16(self._src)\n        obj.BlurY = unpack_fixed16(self._src)\n        bc = BitConsumer(self._src)\n        obj.Passes = bc.u_get(5)\n        obj.Reserved = bc.u_get(3)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the values for the GLOWFILTER record.", "response": "def _get_struct_glowfilter(self):\n        \"\"\"Get the values for the GLOWFILTER record.\"\"\"\n        obj = _make_object(\"GlowFilter\")\n        obj.GlowColor = self._get_struct_rgba()\n        obj.BlurX = unpack_fixed16(self._src)\n        obj.BlurY = unpack_fixed16(self._src)\n        obj.Strength = unpack_fixed8(self._src)\n        bc = BitConsumer(self._src)\n        obj.InnerGlow = bc.u_get(1)\n        obj.Knockout = bc.u_get(1)\n        obj.CompositeSource = bc.u_get(1)\n        obj.Passes = bc.u_get(5)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the values for the BEVELFILTER record.", "response": "def _get_struct_bevelfilter(self):\n        \"\"\"Get the values for the BEVELFILTER record.\"\"\"\n        obj = _make_object(\"BevelFilter\")\n        obj.ShadowColor = self._get_struct_rgba()\n        obj.HighlightColor = self._get_struct_rgba()\n        obj.BlurX = unpack_fixed16(self._src)\n        obj.BlurY = unpack_fixed16(self._src)\n        obj.Angle = unpack_fixed16(self._src)\n        obj.Distance = unpack_fixed16(self._src)\n        obj.Strength = unpack_fixed8(self._src)\n        bc = BitConsumer(self._src)\n        obj.InnerShadow = bc.u_get(1)\n        obj.Knockout = bc.u_get(1)\n        obj.CompositeSource = bc.u_get(1)\n        obj.OnTop = bc.u_get(1)\n        obj.Passes = bc.u_get(4)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_struct_convolutionfilter(self):\n        obj = _make_object(\"ConvolutionFilter\")\n        obj.MatrixX = unpack_ui8(self._src)\n        obj.MatrixY = unpack_ui8(self._src)\n        obj.Divisor = unpack_float(self._src)\n        obj.Bias = unpack_float(self._src)\n\n        _quant = obj.MatrixX * obj.MatrixY\n        obj.Matrix = [unpack_float(self._src) for _ in range(_quant)]\n\n        obj.DefaultColor = self._get_struct_rgba()\n        bc = BitConsumer(self._src)\n        obj.Reserved = bc.u_get(6)\n        obj.Clamp = bc.u_get(1)\n        obj.PreserveAlpha = bc.u_get(1)\n        return obj", "response": "Get the values for the CONVOLUTIONFILTER record."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_struct_colormatrixfilter(self):\n        obj = _make_object(\"ColorMatrixFilter\")\n        obj.Matrix = [unpack_float(self._src) for _ in range(20)]\n        return obj", "response": "Get the values for the COLORMATRIXFILTER record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the values for the GRADIENTBEVELFILTER record.", "response": "def _get_struct_gradientbevelfilter(self):\n        \"\"\"Get the values for the GRADIENTBEVELFILTER record.\"\"\"\n        obj = _make_object(\"GradientBevelFilter\")\n        obj.NumColors = num_colors = unpack_ui8(self._src)\n        obj.GradientColors = [self._get_struct_rgba()\n                              for _ in range(num_colors)]\n        obj.GradientRatio = [unpack_ui8(self._src)\n                             for _ in range(num_colors)]\n        obj.BlurX = unpack_fixed16(self._src)\n        obj.BlurY = unpack_fixed16(self._src)\n        obj.Angle = unpack_fixed16(self._src)\n        obj.Distance = unpack_fixed16(self._src)\n        obj.Strength = unpack_fixed8(self._src)\n        bc = BitConsumer(self._src)\n        obj.InnerShadow = bc.u_get(1)\n        obj.Knockout = bc.u_get(1)\n        obj.CompositeSource = bc.u_get(1)\n        obj.OnTop = bc.u_get(1)\n        obj.Passes = bc.u_get(4)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle the ActionConstantPool action.", "response": "def _handle_actionconstantpool(self, _):\n        \"\"\"Handle the ActionConstantPool action.\"\"\"\n        obj = _make_object(\"ActionConstantPool\")\n        obj.Count = count = unpack_ui16(self._src)\n        obj.ConstantPool = pool = []\n        for _ in range(count):\n            pool.append(self._get_struct_string())\n        yield obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _handle_actiongeturl(self, _):\n        obj = _make_object(\"ActionGetURL\")\n        obj.UrlString = self._get_struct_string()\n        obj.TargetString = self._get_struct_string()\n        yield obj", "response": "Handle the ActionGetURL action."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _handle_actionpush(self, length):\n        init_pos = self._src.tell()\n        while self._src.tell() < init_pos + length:\n            obj = _make_object(\"ActionPush\")\n            obj.Type = unpack_ui8(self._src)\n            # name and how to read each type\n            push_types = {\n                0: (\"String\", self._get_struct_string),\n                1: (\"Float\", lambda: unpack_float(self._src)),\n                2: (\"Null\", lambda: None),\n                4: (\"RegisterNumber\", lambda: unpack_ui8(self._src)),\n                5: (\"Boolean\", lambda: unpack_ui8(self._src)),\n                6: (\"Double\", lambda: unpack_double(self._src)),\n                7: (\"Integer\", lambda: unpack_ui32(self._src)),\n                8: (\"Constant8\", lambda: unpack_ui8(self._src)),\n                9: (\"Constant16\", lambda: unpack_ui16(self._src)),\n            }\n            name, func = push_types[obj.Type]\n            setattr(obj, name, func())\n            yield obj", "response": "Handle the ActionPush action."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling the ActionDefineFunction action.", "response": "def _handle_actiondefinefunction(self, _):\n        \"\"\"Handle the ActionDefineFunction action.\"\"\"\n        obj = _make_object(\"ActionDefineFunction\")\n        obj.FunctionName = self._get_struct_string()\n        obj.NumParams = unpack_ui16(self._src)\n        for i in range(1, obj.NumParams + 1):\n            setattr(obj, \"param\" + str(i), self._get_struct_string())\n        obj.CodeSize = unpack_ui16(self._src)\n        yield obj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _handle_actionif(self, _):\n        obj = _make_object(\"ActionIf\")\n        obj.BranchOffset = unpack_si16(self._src)\n        yield obj", "response": "Handle the ActionIf action."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_actiondefinefunction2(self, _):\n        obj = _make_object(\"ActionDefineFunction2\")\n        obj.FunctionName = self._get_struct_string()\n        obj.NumParams = unpack_ui16(self._src)\n        obj.RegisterCount = unpack_ui8(self._src)\n        bc = BitConsumer(self._src)\n        obj.PreloadParentFlag = bc.u_get(1)\n        obj.PreloadRootFlag = bc.u_get(1)\n        obj.SupressSuperFlag = bc.u_get(1)\n        obj.PreloadSuperFlag = bc.u_get(1)\n        obj.SupressArgumentsFlag = bc.u_get(1)\n        obj.PreloadArgumentsFlag = bc.u_get(1)\n        obj.SupressThisFlag = bc.u_get(1)\n        obj.PreloadThisFlag = bc.u_get(1)\n        obj.Reserved = bc.u_get(7)\n        obj.PreloadGlobalFlag = bc.u_get(1)\n        obj.Parameters = parameters = []\n        for _ in range(obj.NumParams):\n            parameter = _make_object(\"Parameter\")\n            parameters.append(parameter)\n            parameter.Register = unpack_ui8(self._src)\n            parameter.ParamName = self._get_struct_string()\n        obj.CodeSize = unpack_ui16(self._src)\n        yield obj", "response": "Handle the ActionDefineFunction2 action."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef coverage(self):\n        items_unk = collections.Counter()\n        items_ok = collections.Counter()\n\n        def _go_deep(obj):\n            \"\"\"Recursive function to find internal attributes.\"\"\"\n            if type(obj).__name__ in ('UnknownObject', 'UnknownAction'):\n                # blatantly unknown\n                items_unk[obj.name] += 1\n            elif obj.name in ('DefineMorphShape2', 'ClipActions'):\n                # these are incomplete, see FIXMEs in the code above\n                items_unk[obj.name] += 1\n            else:\n                # fully parsed\n                items_ok[obj.name] += 1\n\n            for name in obj._attribs:\n                attr = getattr(obj, name)\n                if isinstance(attr, SWFObject):\n                    _go_deep(attr)\n\n        for tag in self.tags:\n            _go_deep(tag)\n\n        full_count = sum(items_ok.values()) + sum(items_unk.values())\n        coverage = 100 * sum(items_ok.values()) / full_count\n        print(\"Coverage is {:.1f}% of {} total items\".format(coverage,\n                                                             full_count))\n        print(\"Most common parsed objects:\")\n        for k, v in items_ok.most_common(3):\n            print(\"{:5d} {}\".format(v, k))\n        if items_unk:\n            print(\"Most common Unknown objects\")\n            for k, v in items_unk.most_common(3):\n                print(\"{:5d} {}\".format(v, k))", "response": "Calculate the coverage of a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a Checkerboard from the given images and images.", "response": "def checkerboard(img_spec1=None,\n                 img_spec2=None,\n                 patch_size=10,\n                 view_set=(0, 1, 2),\n                 num_slices=(10,),\n                 num_rows=2,\n                 rescale_method='global',\n                 background_threshold=0.05,\n                 annot=None,\n                 padding=5,\n                 output_path=None,\n                 figsize=None, ):\n    \"\"\"\n    Checkerboard mixer.\n\n    Parameters\n    ----------\n    img_spec1 : str or nibabel image-like object\n        MR image (or path to one) to be visualized\n\n    img_spec2 : str or nibabel image-like object\n        MR image (or path to one) to be visualized\n\n    patch_size : int or list or (int, int) or None\n        size of checker patch (either square or rectangular)\n        If None, number of voxels/patch are chosen such that,\n            there will be 7 patches through the width/height.\n\n    view_set : iterable\n        Integers specifying the dimensions to be visualized.\n        Choices: one or more of (0, 1, 2) for a 3D image\n\n    num_slices : int or iterable of size as view_set\n        number of slices to be selected for each view\n        Must be of the same length as view_set,\n            each element specifying the number of slices for each dimension.\n            If only one number is given, same number will be chosen for all dimensions.\n\n    num_rows : int\n        number of rows (top to bottom) per each of 3 dimensions\n\n    rescale_method : bool or str or list or None\n        Range to rescale the intensity values to\n        Default: 'global', min and max values computed based on ranges from both images.\n        If false or None, no rescaling is done (does not work yet).\n\n    background_threshold : float or str\n        A threshold value below which all the background voxels will be set to zero.\n        Default : 0.05. Other option is a string specifying a percentile: '5%', '10%'.\n        Specify None if you don't want any thresholding.\n\n    annot : str\n        Text to display to annotate the visualization\n\n    padding : int\n        number of voxels to pad around each panel.\n\n    output_path : str\n        path to save the generate collage to.\n\n    figsize : list\n        Size of figure in inches to be passed on to plt.figure() e.g. [12, 12] or [20, 20]\n\n    Returns\n    -------\n    fig : figure handle\n        handle to the collage figure generated.\n\n    \"\"\"\n\n    img_one, img_two = _preprocess_images(img_spec1,\n                                          img_spec2,\n                                          rescale_method=rescale_method,\n                                          bkground_thresh=background_threshold,\n                                          padding=padding)\n\n    display_params = dict(interpolation='none', aspect='auto', origin='lower',\n                          cmap='gray', vmin=0.0, vmax=1.0)\n\n    mixer = partial(_checker_mixer, checker_size=patch_size)\n    collage = Collage(view_set=view_set, num_slices=num_slices, num_rows=num_rows,\n                      figsize=figsize, display_params=display_params)\n    collage.transform_and_attach((img_one, img_two), func=mixer)\n    collage.save(output_path=output_path, annot=annot)\n\n    return collage"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncoloring mixer for a composite image.", "response": "def color_mix(img_spec1=None,\n              img_spec2=None,\n              alpha_channels=None,\n              color_space='rgb',\n              view_set=(0, 1, 2),\n              num_slices=(10,),\n              num_rows=2,\n              rescale_method='global',\n              background_threshold=0.05,\n              annot=None,\n              padding=5,\n              output_path=None,\n              figsize=None, ):\n    \"\"\"\n    Color mixer, where each image is represented with a different color (default: red and green) in color channels.\n\n    Parameters\n    ----------\n    img_spec1 : str or nibabel image-like object\n        MR image (or path to one) to be visualized\n\n    img_spec2 : str or nibabel image-like object\n        MR image (or path to one) to be visualized\n\n    alpha_channels : (float, float)\n        weights for red and green channels in the composite image.\n        Default: [1, 1]\n\n    color_space : str\n        type of color space to mix the images in.\n        Currently supports 'rgb' only.\n        Support for 'hsv' coming later.\n\n    view_set : iterable\n        Integers specifying the dimensions to be visualized.\n        Choices: one or more of (0, 1, 2) for a 3D image\n\n    num_slices : int or iterable of size as view_set\n        number of slices to be selected for each view\n        Must be of the same length as view_set,\n            each element specifying the number of slices for each dimension.\n            If only one number is given, same number will be chosen for all dimensions.\n\n    num_rows : int\n        number of rows (top to bottom) per each of 3 dimensions\n\n    rescale_method : bool or str or list or None\n        Range to rescale the intensity values to\n        Default: 'global', min and max values computed based on ranges from both images.\n        If false or None, no rescaling is done (does not work yet).\n\n    background_threshold : float or str\n        A threshold value below which all the background voxels will be set to zero.\n        Default : 0.05. Other option is a string specifying a percentile: '5%', '10%'.\n        Specify None if you don't want any thresholding.\n\n    annot : str\n        Text to display to annotate the visualization\n\n    padding : int\n        number of voxels to pad around each panel.\n\n    output_path : str\n        path to save the generate collage to.\n\n    figsize : list\n        Size of figure in inches to be passed on to plt.figure() e.g. [12, 12] or [20, 20]\n\n    Returns\n    -------\n    fig : figure handle\n        handle to the collage figure generated.\n\n    \"\"\"\n\n    if alpha_channels is None:\n        alpha_channels = [1, 1]\n\n    if not len(alpha_channels) == 2:\n        # not sure if we should make them sum to 1:  or not np.isclose(sum(alpha_channels), 1.0)\n        raise ValueError('Alpha must be two elements')\n\n    mixer_params = dict(alpha_channels=alpha_channels,\n                        color_space=color_space)\n    fig = _compare(img_spec1,\n                   img_spec2,\n                   num_rows=num_rows,\n                   num_cols=num_slices,\n                   mixer='color_mix',\n                   annot=annot,\n                   padding=padding,\n                   rescale_method=rescale_method,\n                   bkground_thresh=background_threshold,\n                   output_path=output_path,\n                   figsize=figsize,\n                   **mixer_params)\n\n    return fig"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef voxelwise_diff(img_spec1=None,\n                   img_spec2=None,\n                   abs_value=True,\n                   cmap='gray',\n                   overlay_image=False,\n                   overlay_alpha=0.8,\n                   num_rows=2,\n                   num_cols=6,\n                   rescale_method='global',\n                   background_threshold=0.05,\n                   annot=None,\n                   padding=5,\n                   output_path=None,\n                   figsize=None):\n    \"\"\"\n    Voxel-wise difference map.\n\n    Parameters\n    ----------\n    img_spec1 : str or nibabel image-like object\n        MR image (or path to one) to be visualized\n\n    img_spec2 : str or nibabel image-like object\n        MR image (or path to one) to be visualized\n\n    abs_value : bool\n        Flag indicating whether to take the absolute value of the diffenence or not.\n        Default: True, display absolute differences only (so order of images does not matter)\n\n        Colormap to show the difference values.\n\n    overlay_image : bool\n        Flag to specify whether to overlay the difference values on the original image.\n        .. note: This feature is not reliable and supported well yet.\n\n    num_rows : int\n        number of rows (top to bottom) per each of 3 dimensions\n\n    num_cols : int\n        number of panels (left to right) per row of each dimension.\n\n    rescale_method : bool or str or list or None\n        Range to rescale the intensity values to\n        Default: 'global', min and max values computed based on ranges from both images.\n        If false or None, no rescaling is done (does not work yet).\n\n    background_threshold : float or str\n        A threshold value below which all the background voxels will be set to zero.\n        Default : 0.05. Other option is a string specifying a percentile: '5%', '10%'.\n        Specify None if you don't want any thresholding.\n\n    annot : str\n        Text to display to annotate the visualization\n\n    padding : int\n        number of voxels to pad around each panel.\n\n    output_path : str\n        path to save the generate collage to.\n\n    figsize : list\n        Size of figure in inches to be passed on to plt.figure() e.g. [12, 12] or [20, 20]\n\n    Returns\n    -------\n    fig : figure handle\n        handle to the collage figure generated.\n\n\n    \"\"\"\n\n    if not isinstance(abs_value, bool):\n        abs_value = bool(abs_value)\n\n    mixer_params = dict(abs_value=abs_value,\n                        cmap=cmap,\n                        overlay_image=overlay_image,\n                        overlay_alpha=overlay_alpha)\n    fig = _compare(img_spec1,\n                   img_spec2,\n                   num_rows=num_rows,\n                   num_cols=num_cols,\n                   mixer='voxelwise_diff',\n                   annot=annot,\n                   padding=padding,\n                   rescale_method=rescale_method,\n                   bkground_thresh=background_threshold,\n                   output_path=output_path,\n                   figsize=figsize,\n                   **mixer_params)\n\n    return fig", "response": "Returns a Voxel - wise difference map."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _compare(img_spec1,\n             img_spec2,\n             num_rows=2,\n             num_cols=6,\n             mixer='checker_board',\n             rescale_method='global',\n             annot=None,\n             padding=5,\n             bkground_thresh=0.05,\n             output_path=None,\n             figsize=None,\n             **kwargs):\n    \"\"\"\n    Produces checkerboard comparison plot of two 3D images.\n\n    Parameters\n    ----------\n    img_spec1 : str or nibabel image-like object\n        MR image (or path to one) to be visualized\n\n    img_spec2 : str or nibabel image-like object\n        MR image (or path to one) to be visualized\n\n    num_rows : int\n        number of rows (top to bottom) per each of 3 dimensions\n\n    num_cols : int\n        number of panels (left to right) per row of each dimension.\n\n    mixer : str\n        type of mixer to produce the comparison figure.\n        Options: checker_board, color_mix, diff_abs,\n\n    rescale_method : bool or str or list or None\n        Method to rescale the intensity values to.\n        Choices : 'global', 'each', False or None.\n\n        Default: 'global', min and max values computed based on ranges from both images.\n        If 'each', rescales each image separately to [0, 1].\n            This option is useful when overlaying images with very different intensity ranges e.g. from different modalities altogether.\n        If False or None, no rescaling is done (does not work yet).\n\n    annot : str\n        Text to display to annotate the visualization\n\n    padding : int\n        number of voxels to pad around each panel.\n\n    output_path : str\n        path to save the generate collage to.\n\n    figsize : list\n        Size of figure in inches to be passed on to plt.figure() e.g. [12, 12] or [20, 20]\n\n    kwargs : dict\n        Additional arguments specific to the particular mixer\n        e.g. alpha_channels = [1, 1] for the color_mix mixer\n\n    Returns\n    -------\n\n    \"\"\"\n\n    num_rows, num_cols, padding = check_params(num_rows, num_cols, padding)\n\n    img1, img2 = check_images(img_spec1, img_spec2, bkground_thresh=bkground_thresh)\n    img1, img2 = crop_to_extents(img1, img2, padding)\n\n    num_slices_per_view = num_rows * num_cols\n    slices = pick_slices(img2, num_slices_per_view)\n\n    rescale_images, img1, img2, min_value, max_value = check_rescaling(img1, img2, rescale_method)\n\n    plt.style.use('dark_background')\n\n    num_axes = 3\n    if figsize is None:\n        figsize = [3 * num_axes * num_rows, 3 * num_cols]\n    fig, ax = plt.subplots(num_axes * num_rows, num_cols, figsize=figsize)\n\n    # displaying some annotation text if provided\n    # good choice would be the location of the input images (for future refwhen image is shared or misplaced!)\n    if annot is not None:\n        fig.suptitle(annot, backgroundcolor='black', color='g')\n\n    display_params = dict(interpolation='none', aspect='equal', origin='lower')\n\n    ax = ax.flatten()\n    ax_counter = 0\n    for dim_index in range(3):\n        for slice_num in slices[dim_index]:\n            plt.sca(ax[ax_counter])\n            ax_counter = ax_counter + 1\n\n            slice1 = get_axis(img1, dim_index, slice_num)\n            slice2 = get_axis(img2, dim_index, slice_num)\n\n            mixed, mixer_spec_params = _generic_mixer(slice1, slice2, mixer, **kwargs)\n            display_params.update(mixer_spec_params)\n\n            plt.imshow(mixed, vmin=min_value, vmax=max_value, **display_params)\n\n            # adjustments for proper presentation\n            plt.axis('off')\n\n    fig.tight_layout()\n\n    if output_path is not None:\n        output_path = output_path.replace(' ', '_')\n        fig.savefig(output_path + '.png', bbox_inches='tight')\n\n    # plt.close()\n\n    return fig", "response": "Generates checkerboard comparison plot of two 3D images."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef collage(img_spec,\n            num_rows=2,\n            num_cols=6,\n            rescale_method='global',\n            cmap='gray',\n            annot=None,\n            padding=5,\n            bkground_thresh=None,\n            output_path=None,\n            figsize=None,\n            **kwargs):\n    \"Produces a collage of various slices from different orientations in the given 3D image\"\n\n    num_rows, num_cols, padding = check_params(num_rows, num_cols, padding)\n\n    img = read_image(img_spec, bkground_thresh=bkground_thresh)\n    img = crop_image(img, padding)\n\n    img, (min_value, max_value) = check_rescaling_collage(img, rescale_method,\n                                                          return_extrema=True)\n    num_slices_per_view = num_rows * num_cols\n    slices = pick_slices(img, num_slices_per_view)\n\n    plt.style.use('dark_background')\n\n    num_axes = 3\n    if figsize is None:\n        figsize = [3 * num_axes * num_rows, 3 * num_cols]\n    fig, ax = plt.subplots(num_axes * num_rows, num_cols, figsize=figsize)\n\n    # displaying some annotation text if provided\n    if annot is not None:\n        fig.suptitle(annot, backgroundcolor='black', color='g')\n\n    display_params = dict(interpolation='none', cmap=cmap,\n                          aspect='equal', origin='lower',\n                          vmin=min_value, vmax=max_value)\n\n    ax = ax.flatten()\n    ax_counter = 0\n    for dim_index in range(3):\n        for slice_num in slices[dim_index]:\n            plt.sca(ax[ax_counter])\n            ax_counter = ax_counter + 1\n            slice1 = get_axis(img, dim_index, slice_num)\n            # slice1 = crop_image(slice1, padding)\n            plt.imshow(slice1, **display_params)\n            plt.axis('off')\n\n    fig.tight_layout()\n\n    if output_path is not None:\n        output_path = output_path.replace(' ', '_')\n        fig.savefig(output_path + '.png', bbox_inches='tight')\n\n    # plt.close()\n\n    return fig", "response": "Produces a collage of various slices from different orientations in the given 3D image"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef aseg_on_mri(mri_spec,\n                aseg_spec,\n                alpha_mri=1.0,\n                alpha_seg=1.0,\n                num_rows=2,\n                num_cols=6,\n                rescale_method='global',\n                aseg_cmap='freesurfer',\n                sub_cortical=False,\n                annot=None,\n                padding=5,\n                bkground_thresh=0.05,\n                output_path=None,\n                figsize=None,\n                **kwargs):\n    \"Produces a collage of various slices from different orientations in the given 3D image\"\n\n    num_rows, num_cols, padding = check_params(num_rows, num_cols, padding)\n\n    mri = read_image(mri_spec, bkground_thresh=bkground_thresh)\n    seg = read_image(aseg_spec, bkground_thresh=0)\n    mri, seg = crop_to_seg_extents(mri, seg, padding)\n\n    num_slices_per_view = num_rows * num_cols\n    slices = pick_slices(seg, num_slices_per_view)\n\n    plt.style.use('dark_background')\n\n    num_axes = 3\n    if figsize is None:\n        figsize = [5 * num_axes * num_rows, 5 * num_cols]\n    fig, ax = plt.subplots(num_axes * num_rows, num_cols, figsize=figsize)\n\n    # displaying some annotation text if provided\n    if annot is not None:\n        fig.suptitle(annot, backgroundcolor='black', color='g')\n\n    display_params_mri = dict(interpolation='none', aspect='equal', origin='lower',\n                              cmap='gray', alpha=alpha_mri,\n                              vmin=mri.min(), vmax=mri.max())\n    display_params_seg = dict(interpolation='none', aspect='equal', origin='lower',\n                              alpha=alpha_seg)\n\n    normalize_labels = colors.Normalize(vmin=seg.min(), vmax=seg.max(), clip=True)\n    fs_cmap = get_freesurfer_cmap(sub_cortical)\n    label_mapper = cm.ScalarMappable(norm=normalize_labels, cmap=fs_cmap)\n\n    ax = ax.flatten()\n    ax_counter = 0\n    for dim_index in range(3):\n        for slice_num in slices[dim_index]:\n            plt.sca(ax[ax_counter])\n            ax_counter = ax_counter + 1\n\n            slice_mri = get_axis(mri, dim_index, slice_num)\n            slice_seg = get_axis(seg, dim_index, slice_num)\n\n            # # masking data to set no-value pixels to transparent\n            # seg_background = np.isclose(slice_seg, 0.0)\n            # slice_seg = np.ma.masked_where(seg_background, slice_seg)\n            # slice_mri = np.ma.masked_where(np.logical_not(seg_background), slice_mri)\n\n            seg_rgb = label_mapper.to_rgba(slice_seg)\n            plt.imshow(seg_rgb, **display_params_seg)\n            plt.imshow(slice_mri, **display_params_mri)\n            plt.axis('off')\n\n    # plt.subplots_adjust(wspace=0.0, hspace=0.0)\n    plt.subplots_adjust(left=0.01, right=0.99,\n                        bottom=0.01, top=0.99,\n                        wspace=0.05, hspace=0.02)\n    # fig.tight_layout()\n\n    if output_path is not None:\n        output_path = output_path.replace(' ', '_')\n        fig.savefig(output_path + '.png', bbox_inches='tight')\n\n    # plt.close()\n\n    return fig", "response": "Produces a collage of various slices from different orientations in the given 3D image"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _generic_mixer(slice1, slice2, mixer_name, **kwargs):\n\n    mixer_name = mixer_name.lower()\n    if mixer_name in ['color_mix', 'rgb']:\n        mixed = _mix_color(slice1, slice2, **kwargs)\n        cmap = None  # data is already RGB-ed\n    elif mixer_name in ['checkerboard', 'checker', 'cb', 'checker_board']:\n        checkers = _get_checkers(slice1.shape, **kwargs)\n        mixed = _checker_mixer(slice1, slice2, checkers)\n        cmap = 'gray'\n    elif mixer_name in ['diff', 'voxelwise_diff', 'vdiff']:\n\n        mixed, cmap = _diff_image(slice1, slice2, **kwargs)\n        # if kwargs['overlay_image'] is True:\n        #     diff_cmap = diff_colormap()\n        #     plt.imshow(slice1, alpha=kwargs['overlay_alpha'], **display_params)\n        #     plt.hold(True)\n        #     plt.imshow(mixed,\n        #                cmap=diff_cmap,\n        #                vmin=min_value, vmax=max_value,\n        #                **display_params)\n        # else:\n        #     plt.imshow(mixed, cmap=cmap,\n        #                vmin=min_value, vmax=max_value,\n        #                **display_params)\n\n    else:\n        raise ValueError('Invalid mixer name chosen.')\n\n    disp_params = dict(cmap=cmap)\n\n    return mixed, disp_params", "response": "Generic mixer to process two slices with appropriate mixer\n        and return the composite to be displayed."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_rescaling(img1, img2, rescale_method):\n\n    # estimating intensity ranges\n    if rescale_method is None:\n        # this section is to help user to avoid all intensity rescaling altogther!\n        # TODO bug does not work yet, as pyplot does not offer any easy way to control it\n        rescale_images = False\n        min_value = None\n        max_value = None\n        norm_image = None  # mpl.colors.NoNorm doesn't work yet. data is getting linearly normalized to [0, 1]\n    elif isinstance(rescale_method, str):\n        if rescale_method.lower() in ['global']:\n            # TODO need a way to alert the user if one of the distributions is too narrow\n            #  in which case that image will be collapsed to an uniform value\n            combined_distr = np.concatenate((img1.flatten(), img2.flatten()))\n            min_value = combined_distr.min()\n            max_value = combined_distr.max()\n        elif rescale_method.lower() in ['each']:\n            img1 = scale_0to1(img1)\n            img2 = scale_0to1(img2)\n            min_value = 0.0\n            max_value = 1.0\n        else:\n            raise ValueError('rescaling method can only be \"global\" or \"each\"')\n\n        rescale_images = True\n        norm_image = mpl.colors.Normalize\n    elif len(rescale_method) == 2:\n        min_value = min(rescale_method)\n        max_value = max(rescale_method)\n        rescale_images = True\n        norm_image = mpl.colors.Normalize\n    else:\n        raise ValueError('Invalid intensity range!. It must be either : '\n                         '1) a list/tuple of two distinct values or'\n                         '2) \"global\" indicating rescaling based on min/max values derived from both images or'\n                         '3) None, no rescaling or norming altogether. ')\n\n    return rescale_images, img1, img2, min_value, max_value", "response": "Estimates the intensity range to clip the visualizations to"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_images(img_spec1, img_spec2, bkground_thresh=0.05):\n\n    img1 = read_image(img_spec1, bkground_thresh)\n    img2 = read_image(img_spec2, bkground_thresh)\n\n    if img1.shape != img2.shape:\n        raise ValueError('size mismatch! First image: {} Second image: {}\\n'\n                         'Two images to be compared must be of the same size in all dimensions.'.format(\n            img1.shape,\n            img2.shape))\n\n    return img1, img2", "response": "Reads the two images and assers identical shape."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating checkerboard of a given tile size filling a given slice.", "response": "def _get_checkers(slice_shape, patch_size):\n    \"\"\"Creates checkerboard of a given tile size, filling a given slice.\"\"\"\n\n    if patch_size is not None:\n        patch_size = check_patch_size(patch_size)\n    else:\n        # 7 patches in each axis, min voxels/patch = 3\n        # TODO make 7 a user settable parameter\n        patch_size = np.round(np.array(slice_shape) / 7).astype('int16')\n        patch_size = np.maximum(patch_size, np.array([3, 3]))\n\n    black = np.zeros(patch_size)\n    white = np.ones(patch_size)\n    tile = np.vstack((np.hstack([black, white]), np.hstack([white, black])))\n\n    # using ceil so we can clip the extra portions\n    num_tiles = np.ceil(np.divide(slice_shape, tile.shape)).astype(int)\n    checkers = np.tile(tile, num_tiles)\n\n    # clipping any extra columns or rows\n    if any(np.greater(checkers.shape, slice_shape)):\n        if checkers.shape[0] > slice_shape[0]:\n            checkers = np.delete(checkers, np.s_[slice_shape[0]:], axis=0)\n        if checkers.shape[1] > slice_shape[1]:\n            checkers = np.delete(checkers, np.s_[slice_shape[1]:], axis=1)\n\n    return checkers"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmixes them as red green channels", "response": "def _mix_color(slice1, slice2, alpha_channels, color_space):\n    \"\"\"Mixing them as red and green channels\"\"\"\n\n    if slice1.shape != slice2.shape:\n        raise ValueError('size mismatch between cropped slices and checkers!!!')\n\n    alpha_channels = np.array(alpha_channels)\n    if len(alpha_channels) != 2:\n        raise ValueError('Alphas must be two value tuples.')\n\n    slice1, slice2 = scale_images_0to1(slice1, slice2)\n\n    # masking background\n    combined_distr = np.concatenate((slice1.flatten(), slice2.flatten()))\n    image_eps = np.percentile(combined_distr, 5)\n    background = np.logical_or(slice1 <= image_eps, slice2 <= image_eps)\n\n    if color_space.lower() in ['rgb']:\n\n        red = alpha_channels[0] * slice1\n        grn = alpha_channels[1] * slice2\n        blu = np.zeros_like(slice1)\n\n        # foreground = np.logical_not(background)\n        # blu[foreground] = 1.0\n\n        mixed = np.stack((red, grn, blu), axis=2)\n\n    elif color_space.lower() in ['hsv']:\n\n        raise NotImplementedError(\n            'This method (color_space=\"hsv\") is yet to fully conceptualized and implemented.')\n\n        # TODO other ideas: hue/saturation/intensity value driven by difference in intensity?\n        hue = alpha_channels[0] * slice1\n        sat = alpha_channels[1] * slice2\n        val = np.ones_like(slice1)\n\n        hue[background] = 1.0\n        sat[background] = 0.0\n        val[background] = 0.0\n\n        mixed = np.stack((hue, sat, val), axis=2)\n        # converting to RGB\n        mixed = mpl.colors.hsv_to_rgb(mixed)\n\n    # ensuring all values are clipped to [0, 1]\n    mixed[mixed <= 0.0] = 0.0\n    mixed[mixed >= 1.0] = 1.0\n\n    return mixed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _checker_mixer(slice1,\n                   slice2,\n                   checker_size=None):\n    \"\"\"Mixes the two slices in alternating areas specified by checkers\"\"\"\n\n    checkers = _get_checkers(slice1.shape, checker_size)\n    if slice1.shape != slice2.shape or slice2.shape != checkers.shape:\n        raise ValueError('size mismatch between cropped slices and checkers!!!')\n\n    mixed = slice1.copy()\n    mixed[checkers > 0] = slice2[checkers > 0]\n\n    return mixed", "response": "Mixes the two slices in alternating areas specified by checkers"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prettify(elem):\n    rough_string = E.tostring(elem, 'utf-8')\n    reparsed = minidom.parseString(rough_string)\n    return reparsed.toprettyxml(indent='  ').strip()", "response": "Return a pretty - printed XML string for the Element."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef filter(self):\n        argmap = {\n            filter.label or label: filter.field\n            for label, filter in self.filters.items()\n        }\n        args = self.opts.parser.parse(argmap)\n        query = self.query if self.query is not None else self.opts.query\n        for label, filter in self.filters.items():\n            value = args.get(filter.label or label)\n            if value is not None:\n                query = filter.filter(query, self.opts.model, label, value)\n        return query", "response": "Generate a filtered SQLALchemy query from request parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npicks the slices to display in each dimension and view.", "response": "def _pick_slices(self):\n        \"\"\"\n        Picks the slices to display in each dimension/view,\n            skipping any empty slices (without any data at all).\n        \"\"\"\n\n        self._slices = list()\n        self._slices_by_dim = list()\n        for view, ns_in_view in zip(self.view_set, self.num_slices):\n            # discarding completely empty or almost empty slices.\n            dim_size = self._image_shape[view]\n            non_empty_slices = np.array([sl for sl in range(dim_size) if self._not_empty(view, sl)])\n\n            # sampling according to the chosen strategy\n            slices_dim = self._sample_slices_in_dim(view, ns_in_view, non_empty_slices)\n            #  the following loop is needed to preserve order, while eliminating duplicates\n            # list comprehension over a set(slices_dim) wouldn't preserve order\n            uniq_slices = list()\n            for sn in slices_dim:\n                if (0 <= sn < dim_size) and sn not in uniq_slices:\n                    uniq_slices.append(sn)\n\n            self._slices_by_dim.append(slices_dim)\n            # adding view and slice # at the same time..\n            self._slices.extend([(view, sn) for sn in slices_dim])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the image is not empty.", "response": "def _not_empty(self, view, slice_):\n        \"\"\"Checks if the density is too low. \"\"\"\n\n        img2d = self._get_axis(self._image, view, slice_)\n        return (np.count_nonzero(img2d) / img2d.size) > self._min_density"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _sample_slices_in_dim(self, view, num_slices, non_empty_slices):\n\n        if self._sampling_method == 'linear':\n            return self._linear_selection(non_empty_slices=non_empty_slices, num_slices=num_slices)\n        elif self._sampling_method == 'percentage':\n            return self._percent_selection(non_empty_slices=non_empty_slices)\n        elif self._sampling_method == 'callable':\n            return self._selection_by_callable(view=view, non_empty_slices=non_empty_slices,\n                                               num_slices=num_slices)\n        else:\n            raise NotImplementedError('Invalid state for the class!')", "response": "Samples the slices in the given dimension according the chosen strategy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nselect linearly spaced slices in given", "response": "def _linear_selection(self, non_empty_slices, num_slices):\n        \"\"\"Selects linearly spaced slices in given\"\"\"\n\n        num_non_empty = len(non_empty_slices)\n\n        # # trying to skip 5% slices at the tails (bottom clipping at 0)\n        # skip_count = max(0, np.around(num_non_empty * 0.05).astype('int16'))\n        # # only when possible\n        # if skip_count > 0 and (num_non_empty - 2 * skip_count > num_slices):\n        #     non_empty_slices = non_empty_slices[skip_count: -skip_count]\n        #     num_non_empty = len(non_empty_slices)\n\n        sampled_indices = np.linspace(0, num_non_empty, num=min(num_non_empty, num_slices),\n                                      endpoint=False)\n        slices_in_dim = non_empty_slices[np.around(sampled_indices).astype('int64')]\n\n        return slices_in_dim"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _percent_selection(self, non_empty_slices):\n\n        return np.around(self._sampler * len(non_empty_slices) / 100).astype('int64')", "response": "Chooses slices at a given percentage between the first and last non - empty slice."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning all the slices selected by the given callable.", "response": "def _selection_by_callable(self, view, num_slices, non_empty_slices):\n        \"\"\"Returns all the slices selected by the given callable.\"\"\"\n\n        selected = [sl for sl in non_empty_slices\n                    if self._sampler(self._get_axis(self._image, view, sl))]\n\n        return selected[:num_slices]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a fixed axis", "response": "def _get_axis(self, array, axis, slice_num,\n                  extended=False,\n                  transpose=True):\n        \"\"\"Returns a fixed axis\"\"\"\n\n        slice_list = [slice(None)] * array.ndim\n        slice_list[axis] = slice_num\n        slice_data = array[tuple(slice_list)]\n        if transpose:  # for proper orientation\n            slice_data = slice_data.T\n\n        if not extended:\n            # return just the slice data\n            return slice_data\n        else:\n            # additionally include which dim and which slice num\n            return axis, slice_num, slice_data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the same cross - section from the multiple images supplied.", "response": "def get_slices_multi(self, image_list, extended=False):\n        \"\"\"Returns the same cross-section from the multiple images supplied.\n\n        All images must be of the same shape as the original image defining this object.\n\n        Parameters\n        ----------\n\n        image_list : Iterable\n            containing atleast 2 images\n\n        extended : bool\n            Flag to return just slice data (default, extended=False), or\n                return a tuple of axis, slice_num, slice_data (extended=True)\n\n        Returns\n        -------\n\n        tuple_slice_data : tuple of one slice from each image in the input image list\n                            Let's denote it by as TSL.\n                        if extended=True, returns tuple(axis, slice_num, TSL)\n\n        \"\"\"\n\n        # ensure all the images have the same shape\n        for img in image_list:\n            if img.shape != self._image.shape:\n                raise ValueError('Supplied images are not compatible with this class. '\n                                 'They must have the shape: {}'.format(self._image_shape))\n\n        for dim, slice_num in self._slices:\n            multiple_slices = (self._get_axis(img, dim, slice_num) for img in image_list)\n            if not extended:\n                # return just the slice data\n                yield multiple_slices\n            else:\n                # additionally include which dim and which slice num\n                # not using extended option in get_axis, to avoid complicating unpacking\n                yield dim, slice_num, multiple_slices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving the selected slices into a single GIF.", "response": "def save_as_gif(self, gif_path, duration=0.25):\n        \"\"\"Package the selected slices into a single GIF for easy sharing and display (on web etc).\n\n        You must install imageio module separately to use this feature.\n\n        Parameters\n        ----------\n        gif_path : str\n            Output path for the GIF image\n\n        duration : float\n            Duration of display of each frame in GIF, in sec.\n\n        \"\"\"\n\n        import imageio\n        gif_data = [img for img in self.get_slices()]\n        # using img.astype(np.uint32) is leaving noticable artefacts,\n        #   depending on imageio inner conversion, which is rescaling okay\n\n        # TODO deal with differing sizes of slices, padding with zeros or white??\n\n        with warnings.catch_warnings():\n            # ignoring the warning for conversion to uint8\n            warnings.simplefilter('ignore')\n            imageio.mimsave(gif_path, gif_data, duration=duration)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _make_grid_of_axes(self,\n                           bounding_rect=cfg.bounding_rect_default,\n                           num_rows=cfg.num_rows_per_view_default,\n                           num_cols=cfg.num_cols_grid_default,\n                           axis_pad=cfg.axis_pad_default,\n                           commn_annot=None,\n                           **axis_kwargs):\n        \"\"\"Creates a grid of axes bounded within a given rectangle.\"\"\"\n\n        axes_in_grid = list()\n        extents = self._compute_cell_extents_grid(bounding_rect=bounding_rect,\n                                                  num_cols=num_cols,\n                                                  num_rows=num_rows, axis_pad=axis_pad)\n        for cell_ext in extents:\n            ax_cell = self.fig.add_axes(cell_ext, frameon=False, visible=False,\n                                        **axis_kwargs)\n            if commn_annot is not None:\n                ax_cell.set_title(commn_annot)\n            ax_cell.set_axis_off()\n            axes_in_grid.append(ax_cell)\n\n        return axes_in_grid", "response": "Creates a grid of axes bounded within a given rectangle."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the rectangular extents of the corresponding cell in the grid.", "response": "def _compute_cell_extents_grid(bounding_rect=(0.03, 0.03, 0.97, 0.97),\n                                   num_rows=2, num_cols=6,\n                                   axis_pad=0.01):\n        \"\"\"\n        Produces array of num_rows*num_cols elements each containing the rectangular extents of\n        the corresponding cell the grid, whose position is within bounding_rect.\n        \"\"\"\n\n        left, bottom, width, height = bounding_rect\n        height_padding = axis_pad * (num_rows + 1)\n        width_padding = axis_pad * (num_cols + 1)\n        cell_height = float((height - height_padding) / num_rows)\n        cell_width = float((width - width_padding) / num_cols)\n\n        cell_height_padded = cell_height + axis_pad\n        cell_width_padded = cell_width + axis_pad\n\n        extents = list()\n        for row in range(num_rows - 1, -1, -1):\n            for col in range(num_cols):\n                extents.append((left + col * cell_width_padded,\n                                bottom + row * cell_height_padded,\n                                cell_width, cell_height))\n\n        return extents"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nturn off all the x and y axes in each Axis and creates the image objects for the object", "response": "def _create_imshow_objects(self):\n        \"\"\"Turns off all the x and y axes in each Axis\"\"\"\n\n        # uniform values for initial image can cause weird behaviour with normalization\n        #       as imshow.set_data() does not automatically update the normalization!!\n        # using random data is a better choice\n        random_image = np.random.rand(20, 20)\n        self.images = [None] * len(self.flat_grid)\n        for ix, ax in enumerate(self.flat_grid):\n            self.images[ix] = ax.imshow(random_image, **self.display_params)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nattach the relevant cross - sections to each axis.", "response": "def attach(self,\n               image_in,\n               sampler=None,\n               show=True):\n        \"\"\"Attaches the relevant cross-sections to each axis.\n\n        Parameters\n        ----------\n\n        attach_image : ndarray\n            The image to be attached to the collage, once it is created.\n            Must be atleast 3d.\n\n        sampler : str or list or callable\n            selection strategy: to identify the type of sampling done to select the slices to return.\n            All sampling is done between the first and last non-empty slice in that view/dimension.\n\n            - if 'linear' : linearly spaced slices\n            - if list, it is treated as set of percentages at which slices to be sampled\n                (must be in the range of [1-100], not [0-1]).\n                This could be used to more/all slices in the middle e.g. range(40, 60, 5)\n                    or at the end e.g. [ 5, 10, 15, 85, 90, 95]\n            - if callable, it must take a 2D image of arbitray size, return True/False\n                to indicate whether to select that slice or not.\n                Only non-empty slices (atleas one non-zero voxel) are provided as input.\n                Simple examples for callable could be based on\n                1) percentage of non-zero voxels > x etc\n                2) presence of desired texture ?\n                3) certain properties of distribution (skewe: dark/bright, energy etc) etc\n\n                If the sampler returns more than requested `num_slices`,\n                    only the first num_slices will be selected.\n\n        show : bool\n            Flag to request immediate display of collage\n\n        \"\"\"\n\n        if len(image_in.shape) < 3:\n            raise ValueError('Image must be atleast 3D')\n\n        # allowing the choice of new sampling for different invocations.\n        if sampler is None:\n            temp_sampler = self.sampler\n        else:\n            temp_sampler = sampler\n\n        slicer = SlicePicker(image_in=image_in,\n                             view_set=self.view_set,\n                             num_slices=self.num_slices,\n                             sampler=temp_sampler)\n\n        try:\n            for img_obj, slice_data in zip(self.images, slicer.get_slices()):\n                img_obj.set_data(slice_data)\n        except:\n            self._data_attached = False\n            raise ValueError('unable to attach the given image data to current collage')\n        else:\n            self._data_attached = True\n\n        # show all the axes\n        if show:\n            self.show()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndisplays the transformed (combined) version of the cross-sections from each image, (same slice and dimension). So if you input n>=1 images, n slices are obtained from each image, which are passed to the func (callable) provided, and the result will be displayed in the corresponding cell of the collage. Useful applications: - input two images, a function to overlay edges of one image on the other - input two images, a function to mix them in a checkerboard pattern - input one image, a function to saturate the upper half of intensities (to increase contrast and reveal any subtle ghosting in slices) func must be able to receive as many arguments as many elements in image_list. if your func needs additional parameters, make them keyword arguments, and use functools.partial to obtain a new callable that takes in just the slices. Parameters ----------- image_list : list or ndarray list of images or a single ndarray func : callable function to be applied on the input images (their slices) to produce a single slice to be displayed. show : bool flag to indicate whether make the collage visible.", "response": "def transform_and_attach(self,\n                             image_list,\n                             func,\n                             show=True):\n        \"\"\"\n        Displays the transformed (combined) version of the cross-sections from each image,\n            (same slice and dimension). So if you input n>=1 images, n slices are obtained\n            from each image, which are passed to the func (callable) provided, and the\n            result will be displayed in the corresponding cell of the collage.\n            Useful applications:\n            - input two images, a function to overlay edges of one image on the other\n            - input two images, a function to mix them in a checkerboard pattern\n            - input one image, a function to saturate the upper half of intensities\n                (to increase contrast and reveal any subtle ghosting in slices)\n\n        func must be able to receive as many arguments as many elements in image_list.\n            if your func needs additional parameters, make them keyword arguments, and\n            use functools.partial to obtain a new callable that takes in just the slices.\n\n        Parameters\n        -----------\n        image_list : list or ndarray\n            list of images or a single ndarray\n\n        func : callable\n            function to be applied on the input images (their slices)\n                to produce a single slice to be displayed.\n\n        show : bool\n            flag to indicate whether make the collage visible.\n\n        \"\"\"\n\n        if not callable(func):\n            raise TypeError('func must be callable!')\n\n        if not isinstance(image_list, (tuple, list)) and isinstance(image_list, np.ndarray):\n            image_list = [image_list, ]\n\n        if len(image_list) > 1:\n            shape1 = image_list[0].shape\n            for ii in range(1, len(image_list)):\n                if image_list[ii].shape != shape1:\n                    raise ValueError('All images must be of same shape!')\n                if len(image_list[ii].shape) < 3:\n                    raise ValueError('All images must be atleast 3D')\n\n        slicer = SlicePicker(image_in=image_list[0],\n                             view_set=self.view_set,\n                             num_slices=self.num_slices)\n\n        try:\n            for img_obj, slice_list in zip(self.images,\n                                           slicer.get_slices_multi(image_list)):\n                img_obj.set_data(func(*slice_list))\n        except:\n            self._data_attached = False\n            raise ValueError('unable to attach mix of given images to current collage')\n        else:\n            self._data_attached = True\n\n        # show all the axes\n        if show:\n            self.show()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_visible(self, visibility, grid_index=None):\n\n        if grid_index is None:\n            for ax in self.flat_grid:\n                ax.set_visible(visibility)\n        else:\n            if grid_index < 0 or grid_index >= len(self.grids):\n                raise IndexError('Valid indices : 0 to {}'.format(len(self.grids) - 1))\n            for ax in self.grids[grid_index]:\n                ax.set_visible(visibility)", "response": "Sets the visibility property of all axes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self, annot=None, output_path=None):\n\n        if annot is not None:\n            self.fig.suptitle(annot, backgroundcolor='black', color='g')\n\n        if output_path is not None:\n            output_path = output_path.replace(' ', '_')\n            # TODO improve bbox calculations to include ONLY the axes from collage\n            # and nothing else\n            self.fig.savefig(output_path + '.png', bbox_inches='tight', dpi=200,\n                             bbox_extra_artists=self.flat_grid)", "response": "Saves the collage to disk as an image."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear(self):\n\n        for ax in self.flat_grid:\n            for im_h in ax.findobj(AxesImage):\n                im_h.remove()", "response": "Clears all the axes to start fresh."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake note of which dimension needs to be fixed defaulting to last.", "response": "def _add_fixed_dim(self, fixed_dim=-1):\n        \"\"\"Makes note of which dimension needs to be fixed, defaulting to last.\"\"\"\n\n        if fixed_dim in [-1, None, 'last']:\n            fixed_dim = len(self.input_image.shape) - 1  # last dimension\n\n        if int(fixed_dim)!=fixed_dim or \\\n            fixed_dim > len(self.input_image.shape) or \\\n            fixed_dim < -1:\n            raise ValueError('invalid value for the dimension to be fixed!'\n                             'Must be an integer in range [0, {}] inclusive'\n                             ''.format(len(self.input_image.shape)))\n\n        if self.input_image.shape[fixed_dim] < 2:\n            raise ValueError('Input image must have atleast two samples '\n                             'in the fixed dimension. It has {}. '\n                             'Full image shape: {} '\n                             ''.format(self.input_image.shape[fixed_dim],\n                                       self.input_image.shape))\n\n        self.fixed_dim = int(fixed_dim)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconstruct the carpet from the input image.", "response": "def _make_carpet(self, rescale_data):\n        \"\"\"\n        Constructs the carpet from the input image.\n\n        Optional rescaling of the data.\n        \"\"\"\n\n        self.carpet = self._unroll_array(self.input_image, self.fixed_dim)\n        if rescale_data:\n            self.carpet = row_wise_rescale(self.carpet)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying the carpet in the given axis.", "response": "def show(self,\n             clustered=False,\n             ax_carpet=None,\n             label_x_axis='time point',\n             label_y_axis='voxels/ROI'):\n        \"\"\"\n        Displays the carpet in the given axis.\n\n        Parameters\n        ----------\n\n        clustered : bool, optional\n            Flag to indicate whether to show the clustered/reduced carpet or the original.\n            You must run .cluster_rows_in_roi() before trying to show clustered carpet.\n\n        ax_carpet : Axis, optional\n            handle to a valid matplotlib Axis\n\n        label_x_axis : str\n            String label for the x-axis of the carpet\n\n        label_y_axis : str\n            String label for the y-axis of the carpet\n\n        Returns\n        -------\n\n        ax_carpet : Axis\n            handle to axis where carpet is shown\n\n        \"\"\"\n\n        if clustered is True and self._carpet_clustered is False:\n            print('You must run .cluster_rows_in_roi() '\n                  'before being able to show clustered carpet!')\n            return\n\n        if ax_carpet is None:\n            self.ax_carpet = plt.gca()\n        else:\n            if not isinstance(ax_carpet, Axes):\n                raise ValueError('Input must be a valid matplotlib Axis!')\n            self.ax_carpet = ax_carpet\n\n        plt.sca(self.ax_carpet)\n        self.fig = plt.gcf()\n\n        #   vmin/vmax are controlled, because we rescale all to [0, 1]\n        self.imshow_params_carpet = dict(interpolation='none', cmap='gray',\n                                         aspect='auto', origin='lower', zorder=1)\n        # should we control vmin=0.0, vmax=1.0 ??\n\n        if not clustered:\n            self.carpet_handle = self.ax_carpet.imshow(self.carpet,\n                                                   **self.imshow_params_carpet)\n        else:\n            self.carpet_handle = self.ax_carpet.imshow(self.clustered_carpet,\n                                                       **self.imshow_params_carpet)\n\n        # TODO decorating axes with labels\n        self.ax_carpet.set(xlabel=label_x_axis, ylabel=label_y_axis,\n                           frame_on=False)\n        self.ax_carpet.set_ylim(auto=True)\n\n        return self.ax_carpet"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the current figure with carpet visualization to disk.", "response": "def save(self, output_path=None, title=None):\n        \"\"\"Saves the current figure with carpet visualization to disk.\n\n        Parameters\n        ----------\n\n        output_path : str\n            Path to where the figure needs to be saved to.\n\n        title : str\n            text to overlay and annotate the visualization (done via plt.suptitle())\n\n        \"\"\"\n\n        try:\n            save_figure(self.fig, output_path=output_path, annot=title)\n        except:\n            print('Unable to save the figure to disk! \\nException: ')\n            traceback.print_exc()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cluster_rows_in_roi(self,\n                            roi_mask=None,\n                            num_clusters_per_roi=5,\n                            metric='minkowski'):\n        \"\"\"Clusters the data within all the ROIs specified in a mask.\n\n        Parameters\n        ----------\n\n        roi_mask : ndarray or None\n            volumetric mask defining the list of ROIs, with a label for each voxel.\n            This must be the same size in all dimensions except the fixed_dim\n            i.e. if you were making a Carpet from an fMRI image of size 125x125x90x400\n            fixing the 4th dimension (of size 400), then roi_mask must be of size 125x125x90.\n\n        num_clusters_per_roi : int\n            number of clusters (n) to form each ROI specified in the roi_mask\n            if n (say 20) is less than number of voxels per a given ROI (say 2000),\n            then data from approx. 2000/20=100 voxels would summarized (averaged by default),\n            into a single cluster. So if the ROI mask had m ROIs (say 10), then the final clustered carpet\n            would have m*n rows (200), regardless of the number of voxels in the 3D image.\n\n        metric : str\n            distance metric for the hierarchical clustering algorithm;\n            default : 'minkowski'\n            Options: anything accepted by `scipy.spatial.distance.pdist`, which can be:\n            \u2018braycurtis\u2019, \u2018canberra\u2019, \u2018chebyshev\u2019, \u2018cityblock\u2019, \u2018correlation\u2019,\n            \u2018cosine\u2019, \u2018dice\u2019, \u2018euclidean\u2019, \u2018hamming\u2019, \u2018jaccard\u2019, \u2018kulsinski\u2019,\n            \u2018mahalanobis\u2019, \u2018matching\u2019, \u2018minkowski\u2019, \u2018rogerstanimoto\u2019, \u2018russellrao\u2019,\n            \u2018seuclidean\u2019, \u2018sokalmichener\u2019, \u2018sokalsneath\u2019, \u2018sqeuclidean\u2019, \u2018yule\u2019.\n\n\n        \"\"\"\n\n        self._set_roi_mask(roi_mask)\n\n        try:\n            clusters = [self._summarize_in_roi(self.roi_mask == label,\n                                               num_clusters_per_roi,\n                                               metric=metric) for label in self.roi_list]\n            self.clustered_carpet = np.vstack(clusters)\n        except:\n            print('unable to produce the clustered carpet - exception:')\n            traceback.print_exc()\n            self._carpet_clustered = False\n        else:\n            self._carpet_clustered = True", "response": "Cluster the data within all the ROIs specified in a mask."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _set_roi_mask(self, roi_mask):\n\n        if isinstance(roi_mask,\n                      np.ndarray):  # not (roi_mask is None or roi_mask=='auto'):\n            self._verify_shape_compatibility(roi_mask, 'ROI set')\n            self.roi_mask = roi_mask\n\n            self.roi_list = np.unique(roi_mask.flatten())\n            np.setdiff1d(self.roi_list, cfg.background_value)\n        else:\n            self.roi_mask = np.ones(self.carpet.shape[:-1]) # last dim is self.fixed_dim already\n            self.roi_list = [1, ]", "response": "Sets a new ROI mask."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a single row summarizing ( typically via mean all rows in an ROI.", "response": "def _summarize_in_roi(self, label_mask, num_clusters_per_roi=1, metric='minkowski'):\n        \"\"\"returns a single row summarizing (typically via mean) all rows in an ROI.\"\"\"\n\n        this_label = self.carpet[label_mask.flatten(), :]\n        if num_clusters_per_roi == 1:\n            out_matrix = self._summary_func(this_label, axis=0)\n        else:\n            out_matrix = self._make_clusters(this_label, num_clusters_per_roi, metric)\n\n        return out_matrix"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _make_clusters(self, matrix, num_clusters_per_roi, metric):\n\n        from scipy.cluster.hierarchy import fclusterdata\n\n        # maxclust needed to ensure t is interpreted as # clusters in heirarchical clustering\n        group_ids = fclusterdata(matrix, metric=metric, t=num_clusters_per_roi,\n                                 criterion='maxclust')\n        group_set = np.unique(group_ids)\n        clusters = [\n            self._summary_func(matrix[group_ids == group, :], axis=0, keepdims=True)\n            for group in group_set]\n\n        return np.vstack(clusters).squeeze()", "response": "clusters a given matrix by into specified number of clusters according to given metric"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove voxels outside the given ROI set.", "response": "def _apply_mask(self, roi_mask):\n        \"\"\"Removes voxels outside the given mask or ROI set.\"\"\"\n\n        # TODO ensure compatible with input image\n        #   - must have < N dim and same size in moving dims.\n        rows_to_delete = list() # to allow for additional masks to be applied in the future\n        if isinstance(roi_mask,\n                      np.ndarray):  # not (roi_mask is None or roi_mask=='auto'):\n            self._set_roi_mask(roi_mask)\n\n            rows_roi = np.where(self.roi_mask.flatten() == cfg.background_value)\n\n            # TODO below would cause differences in size/shape across mask and carpet!\n            self.carpet = np.delete(self.carpet, rows_roi, axis=0)\n\n        else:\n            self.roi_mask = np.ones(self.carpet.shape)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks mask shape against input image shape.", "response": "def _verify_shape_compatibility(self, img, img_type):\n        \"\"\"Checks mask shape against input image shape.\"\"\"\n\n        if self.input_image.shape[:-1] != img.shape:\n            raise ValueError('Shape of the {} ({}) is not compatible '\n                             'with input image shape: {} '\n                             ''.format(img_type, img.shape, self.input_image.shape[:-1]))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nverify an activation code a user received by e - mail.", "response": "def verify_email(request, code, redirect_to=None):\n    \"\"\"Verifies an account activation code a user received by e-mail.\n\n    Requires Messages Django Contrib.\n\n    :param Requset request:\n    :param str code:\n    :param str redirect_to:\n    :return:\n    \"\"\"\n    success = False\n\n    valid_code = EmailConfirmation.is_valid(code)\n    if valid_code:\n        valid_code.activate()\n        success = True\n\n    if success:\n        messages.success(request, SIGNUP_VERIFY_EMAIL_SUCCESS_TEXT, 'success')\n    else:\n        messages.error(request, SIGNUP_VERIFY_EMAIL_ERROR_TEXT, 'danger error')\n\n    if redirect_to is None:\n        redirect_to = '/'\n\n    return redirect(redirect_to)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a FIXED8 value.", "response": "def unpack_fixed8(src):\n    \"\"\"Get a FIXED8 value.\"\"\"\n    dec_part = unpack_ui8(src)\n    int_part = unpack_ui8(src)\n    return int_part + dec_part / 256"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unpack_fixed16(src):\n    dec_part = unpack_ui16(src)\n    int_part = unpack_ui16(src)\n    return int_part + dec_part / 65536", "response": "Get a FIXED16 value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading and unpack a 16b float.", "response": "def unpack_float16(src):\n    \"\"\"Read and unpack a 16b float.\n\n    The structure is:\n    - 1 bit for the sign\n    . 5 bits for the exponent, with an exponent bias of 16\n    - 10 bits for the mantissa\n    \"\"\"\n    bc = BitConsumer(src)\n    sign = bc.u_get(1)\n    exponent = bc.u_get(5)\n    mantissa = bc.u_get(10)\n    exponent -= 16\n    mantissa /= 2 ** 10\n    num = (-1 ** sign) * mantissa * (10 ** exponent)\n    return num"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a number using the given quantity of unsigned bits.", "response": "def u_get(self, quant):\n        \"\"\"Return a number using the given quantity of unsigned bits.\"\"\"\n        if not quant:\n            return\n        bits = []\n        while quant:\n            if self._count == 0:\n                byte = self.src.read(1)\n                number = struct.unpack(\"<B\", byte)[0]\n                self._bits = bin(number)[2:].zfill(8)\n                self._count = 8\n            if quant > self._count:\n                self._count, quant, toget = 0, quant - self._count, self._count\n            else:\n                self._count, quant, toget = self._count - quant, 0, quant\n            read, self._bits = self._bits[:toget], self._bits[toget:]\n            bits.append(read)\n        data = int(\"\".join(bits), 2)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a number using the given quantity of signed bits.", "response": "def s_get(self, quant):\n        \"\"\"Return a number using the given quantity of signed bits.\"\"\"\n        if quant < 2:\n            # special case, just return that unsigned value\n            # quant can also be 0\n            return self.u_get(quant)\n\n        sign = self.u_get(1)\n        raw_number = self.u_get(quant - 1)\n        if sign == 0:\n            # positive, simplest case\n            number = raw_number\n        else:\n            # negative, complemento a 2\n            complement = 2 ** (quant - 1) - 1\n            number = -1 * ((raw_number ^ complement) + 1)\n        return number"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a fixed bit number of the number of the output in the specified bit frequency", "response": "def fb_get(self, quant, fb=16):\n        \"\"\"Return a fixed bit number\n\n        quant: number of bits to read\n        fb: number of bits in the integer and decimal part of the output\n            default is 16, resulting in a 16.16 fixed bit\"\"\"\n\n        raw_number = self.s_get(quant)\n\n        if quant == 1:\n            # special case, just return that unsigned value\n            return raw_number\n\n        return raw_number / (1 << fb)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprovide different colormaps for different visualization types.", "response": "def get_freesurfer_cmap(vis_type):\n    \"\"\"Provides different colormaps for different visualization types.\"\"\"\n\n    if vis_type in ('cortical_volumetric', 'cortical_contour'):\n            LUT = get_freesurfer_cortical_LUT()\n            cmap = ListedColormap(LUT)\n    elif vis_type in ('labels_volumetric', 'labels_contour'):\n        black = np.array([0, 0, 0, 1])\n        cmap = plt.get_cmap('hsv')\n        # TODO using more than 20 labels might be a problem?\n        cmap = cmap(np.linspace(0, 1, 20))\n        # prepending black to paint background as black\n        colors = np.vstack((black, cmap))\n        cmap = ListedColormap(colors, 'my_colormap')\n    else:\n        raise NotImplementedError('color map for the visualization type {} has not been implemented!'.format(vis_type))\n\n    return cmap"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a new RSA private key.", "response": "def create_rsa_key(bits=2048,\n                   keyfile=None,\n                   format='PEM',\n                   passphrase=None):\n    \"\"\"\n    Generate a new RSA key with the specified key size.\n\n    :param int bits:\n        bit size of the key modulus\n\n    :param str keyfile:\n        file the key should be written to\n\n    :param str format:\n        format for the key file, either PEM or DER\n\n    :param str passphrase:\n        pass phrase for encrypting the key file. If pass phrase is a callable\n        its return value will be used.\n\n    :return:\n        RSA private key instance\n    \"\"\"\n    if passphrase and format != 'PEM':\n        raise Exception(\n            \"passphrase is only supported for PEM encoded private keys\")\n    rsakey = RSA.generate(bits)\n    if passphrase and isinstance(passphrase, collections.Callable):\n        passphrase = passphrase()\n    output = rsakey.exportKey(format=format, passphrase=passphrase)\n    if keyfile:\n        with open(keyfile, 'w') as outputfile:\n            outputfile.write(output)\n    log.info(\"generated private key:\\n\\n%s\", output)\n    return rsakey"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a certificate signing request for a given key.", "response": "def create_csr(key, dn, csrfilename=None, attributes=None):\n    \"\"\"\n    Generates a Certificate Signing Request for a given key.\n\n    :param Crypto.PublicKey.RSA._RSAobj key:\n        a key\n\n    :param dn:\n        a distinguished name as dictionary or string with key=value pairs\n        separated by slashes like ``/CN=test.example.org/C=DE/O=Test\n        organisation/``\n\n    :param str csrfilename:\n        name of a file to write the CSR to\n\n    :param tuple attributes:\n        a tuple describing attributes to be included in the CSR\n\n    :return:\n        a certificate signing request\n\n    \"\"\"\n    certreqInfo = rfc2314.CertificationRequestInfo()\n    certreqInfo.setComponentByName('version', rfc2314.Version(0))\n    certreqInfo.setComponentByName('subject', _build_dn(dn))\n    certreqInfo.setComponentByName('subjectPublicKeyInfo',\n                                   _build_subject_publickey_info(key))\n    attrpos = certreqInfo.componentType.getPositionByName('attributes')\n    attrtype = certreqInfo.componentType.getTypeByPosition(attrpos)\n    certreqInfo.setComponentByName('attributes', _build_attributes(\n        attributes, attrtype))\n\n    certreq = rfc2314.CertificationRequest()\n    certreq.setComponentByName('certificationRequestInfo', certreqInfo)\n\n    sigAlgIdentifier = rfc2314.SignatureAlgorithmIdentifier()\n    sigAlgIdentifier.setComponentByName(\n        'algorithm', univ.ObjectIdentifier('1.2.840.113549.1.1.11'))\n    certreq.setComponentByName(\n        'signatureAlgorithm',\n        sigAlgIdentifier)\n    certreq.setComponentByName(\n        'signature', _build_signature(key, certreqInfo))\n\n    output = _der_to_pem(encoder.encode(certreq), 'CERTIFICATE REQUEST')\n\n    if csrfilename:\n        with open(csrfilename, 'w') as csrfile:\n            csrfile.write(output)\n    log.info(\"generated certification request:\\n\\n%s\", output)\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_template_name(self, template_name):\n        if template_name is None:\n            # Build default template path.\n            template_name = self.default_form_template\n        if '.html' not in template_name:  # Shortcut, e.g.: .\n            template_name = '%s%s.html' % ('sitegate/%s/', template_name)\n        if '%s' in template_name:  # Fill in the flow type placeholder.\n            template_name = template_name % self.flow_type\n        return template_name", "response": "Returns the name of the template that should be used for the form as a template."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef respond_for(self, view_function, args, kwargs):\n\n        request = args[0]\n        form = self.get_requested_form(request)\n        if form.is_valid():\n            result = self.handle_form_valid(request, form)\n            if result:\n                return result\n\n        self.update_request(request, form)\n        return view_function(*args, **kwargs)", "response": "Returns a response for the given view & args."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_request(self, request, form):\n        forms_key = '%s_forms' % self.flow_type\n\n        # Use ordered forms dict in case _formNode wants to fetch the first defined.\n        flow_dict = OrderedDict()\n        try:\n            flow_dict = request.sitegate[forms_key]\n        except AttributeError:\n            request.sitegate = {}\n        except KeyError:\n            pass\n\n        flow_dict[self.get_flow_name()] = form\n        request.sitegate[forms_key] = flow_dict", "response": "Updates the request object with flows forms."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef login_generic(request, username, password):\n        user = authenticate(username=username, password=password)\n        if user is not None and user.is_active:\n            login(request, user)\n            return True\n        return False", "response": "Generic login with username and password."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning flow argument as provided with sitegate decorators or attribute set as a flow class attribute or default.", "response": "def get_arg_or_attr(self, name, default=None):\n        \"\"\"Returns flow argument, as provided with sitegate decorators\n           or attribute set as a flow class attribute or default.\"\"\"\n        if name in self.flow_args:\n            return self.flow_args[name]\n        try:\n            return getattr(self, name)\n        except AttributeError:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an instance of a form requested by the user.", "response": "def get_requested_form(self, request):\n        \"\"\"Returns an instance of a form requested.\"\"\"\n        flow_name = self.get_flow_name()\n        flow_key = '%s_flow' % self.flow_type\n        flow_enabled = self.enabled\n        form_data = None\n\n        if (flow_enabled and\n            request.method == 'POST' and\n            request.POST.get(flow_key, False) and\n            request.POST[flow_key] == flow_name):\n\n            form_data = request.POST\n\n        form = self.init_form(\n            form_data,\n            widget_attrs=self.flow_args.get('widget_attrs', None),\n            template=self.get_template_name(self.flow_args.get('template', None))\n        )\n\n        # Attach flow identifying field to differentiate among several possible forms.\n        form.fields[flow_key] = forms.CharField(required=True, initial=flow_name, widget=forms.HiddenInput)\n        form.flow_enabled = flow_enabled\n        form.flow_disabled_text = self.disabled_text\n        return form"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_form(self, form_data, widget_attrs=None, template=None):\n        form = self.form(data=form_data)\n        form.template = template\n        # Attach flow attribute to have access from flow forms (usually to call get_arg_or_attr())\n        form.flow = self\n        if widget_attrs is not None:\n            set_form_widgets_attrs(form, widget_attrs)\n        return form", "response": "Constructs populates and returns a form."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine the path to the JSON log file.", "response": "def log_path(scraper):\n    \"\"\" Determine the file name for the JSON log. \"\"\"\n    return os.path.join(scraper.config.data_path,\n                        '%s.jsonlog' % scraper.name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a logger for the scraper.", "response": "def make_logger(scraper):\n    \"\"\" Create two log handlers, one to output info-level ouput to the\n    console, the other to store all logging in a JSON file which will\n    later be used to generate reports. \"\"\"\n\n    logger = logging.getLogger('')\n    logger.setLevel(logging.DEBUG)\n\n    requests_log = logging.getLogger(\"requests\")\n    requests_log.setLevel(logging.WARNING)\n\n    json_handler = logging.FileHandler(log_path(scraper))\n    json_handler.setLevel(logging.DEBUG)\n    json_formatter = jsonlogger.JsonFormatter(make_json_format())\n    json_handler.setFormatter(json_formatter)\n    logger.addHandler(json_handler)\n\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    fmt = '%(name)s [%(levelname)-8s]: %(message)s'\n    formatter = logging.Formatter(fmt)\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n\n    logger = logging.getLogger(scraper.name)\n    logger = TaskAdapter(logger, scraper)\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef command(self, command, arg=None):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n        try:\n            sock.connect((self.host, self.port))\n            payload = {\"command\": command}\n            if arg is not None:\n                # Parameter must be converted to basestring (no int)\n                payload.update({'parameter': unicode(arg)})\n\n            sock.send(json.dumps(payload))\n            received = self._receive(sock)\n        finally:\n            sock.shutdown(socket.SHUT_RDWR)\n            sock.close()\n\n        return json.loads(received[:-1])", "response": "Send a command to the Asterisk Manager and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initiate(self, sa):\n        response = self.handler.streamed_request(\"initiate\", \"control-log\", sa)\n        return self._result(*response)", "response": "Initiate an SA.\n\n        :param sa: the SA to initiate\n        :type sa: dict\n        :return: logs emitted by command, with `errmsg` given on failure\n        :rtype: :py:class:`vici.session.CommandResult`"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef terminate(self, sa):\n        response = self.handler.streamed_request(\"terminate\", \"control-log\", sa)\n        return self._result(*response)", "response": "Terminate an SA.\n\n        :param sa: the SA to terminate\n        :type sa: dict\n        :return: logs emitted by command, with `errmsg` given on failure\n        :rtype: :py:class:`vici.session.CommandResult`"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_sas(self, filters=None):\n        _, sa_list = self.handler.streamed_request(\"list-sas\",\n                                                   \"list-sa\", filters)\n        return sa_list", "response": "Retrieve active IKE_SAs and associated CHILD_SAs."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_policies(self, filters=None):\n        _, policy_list = self.handler.streamed_request(\"list-policies\",\n                                                       \"list-policy\", filters)\n        return policy_list", "response": "Retrieve installed trap drop and bypass policies."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_conns(self, filters=None):\n        _, connection_list = self.handler.streamed_request(\"list-conns\",\n                                                           \"list-conn\", filters)\n        return connection_list", "response": "Retrieve loaded connections.\n\n        :param filters: retrieve only matching configuration names (optional)\n        :type filters: dict\n        :return: list of connections\n        :rtype: list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_certs(self, filters=None):\n        _, cert_list = self.handler.streamed_request(\"list-certs\",\n                                                     \"list-cert\", filters)\n        return cert_list", "response": "Retrieve loaded certificates.\n\n        :param filters: retrieve only matching certificates (optional)\n        :type filters: dict\n        :return: list of installed trap, drop and bypass policies\n        :rtype: list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a CommandResult for a request response.", "response": "def _result(self, command_response, log=None):\n        \"\"\"Create a CommandResult for a request response.\n\n        :param command_response: command request response\n        :type command_response: dict\n        :param log: list of log messages (optional)\n        :type log: list\n        :return: a CommandResult containing any given log messages\n        :rtype: :py:class:`vici.session.CommandResult`\n        \"\"\"\n        if command_response[\"success\"] == \"yes\":\n            return CommandResult(True, None, log)\n        else:\n            return CommandResult(False, command_response[\"errmsg\"], log)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef request(self, command, message=None):\n        if message is not None:\n            message = Message.serialize(message)\n        packet = Packet.request(command, message)\n        response = self._communicate(packet)\n\n        if response.response_type != Packet.CMD_RESPONSE:\n            raise SessionException(\n                \"Unexpected response type {type}, \"\n                \"expected '{response}' (CMD_RESPONSE)\".format(\n                    type=response.response_type,\n                    response=Packet.CMD_RESPONSE\n                )\n            )\n\n        return Message.deserialize(response.payload)", "response": "Send command request with an optional message."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef streamed_request(self, command, event_stream_type, message=None):\n        result = []\n\n        if message is not None:\n            message = Message.serialize(message)\n\n        # subscribe to event stream\n        packet = Packet.register_event(event_stream_type)\n        response = self._communicate(packet)\n\n        if response.response_type != Packet.EVENT_CONFIRM:\n            raise SessionException(\n                \"Unexpected response type {type}, \"\n                \"expected '{confirm}' (EVENT_CONFIRM)\".format(\n                    type=response.response_type,\n                    confirm=Packet.EVENT_CONFIRM,\n                )\n            )\n\n        # issue command, and read any event messages\n        packet = Packet.request(command, message)\n        self.transport.send(packet)\n        response = self._read()\n        while response.response_type == Packet.EVENT:\n            result.append(Message.deserialize(response.payload))\n            response = self._read()\n\n        if response.response_type == Packet.CMD_RESPONSE:\n            response_message = Message.deserialize(response.payload)\n        else:\n            raise SessionException(\n                \"Unexpected response type {type}, \"\n                \"expected '{response}' (CMD_RESPONSE)\".format(\n                    type=response.response_type,\n                    response=Packet.CMD_RESPONSE\n                )\n            )\n\n        # unsubscribe from event stream\n        packet = Packet.unregister_event(event_stream_type)\n        response = self._communicate(packet)\n        if response.response_type != Packet.EVENT_CONFIRM:\n            raise SessionException(\n                \"Unexpected response type {type}, \"\n                \"expected '{confirm}' (EVENT_CONFIRM)\".format(\n                    type=response.response_type,\n                    confirm=Packet.EVENT_CONFIRM,\n                )\n            )\n\n        return (response_message, result)", "response": "Send command request and collect and return all emitted events."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _read(self):\n        raw_response = self.transport.receive()\n        response = Packet.parse(raw_response)\n\n        # FIXME\n        if response.response_type == Packet.EVENT and response.event_type == \"log\":\n            # queue up any debug log messages, and get next\n            self.log_events.append(response)\n            # do something?\n            self._read()\n        else:\n            return response", "response": "Get next packet from transport."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of all the entries in the recurring calendar.", "response": "def list(self, params={}):\n        \"\"\"\n        Required Parameters:\n          * searchType (str)\n           - cardExpiringThisMonth\n           - subscriptionActive\n           - subscriptionInactive\n           - subscriptionExpiringThisMonth\n\n        Optional Parameters:\n          * sorting\n            * orderBy (string)\n             - id\n             - name\n             - status\n             - createTimeStampUTC\n             - lastName\n             - firstName\n             - accountNumber (ordered by last 4 digits only)\n             - amount\n             - pastOccurrences\n            * orderDescending (bool)\n          * paging\n            * limit (int) (1-1000)\n            * offset (int) (1-100000)\n        \"\"\"\n        paging = self._deserialize(ListRecurringSchema().bind(), params)\n        return self.api._make_call(self._list_request(paging))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _diff_image(slice1, slice2,\n                abs_value=True,\n                cmap='gray',\n                **kwargs):\n    \"\"\"Computes the difference image\"\"\"\n\n    diff = slice1 - slice2\n\n    if abs_value:\n        diff = np.abs(diff)\n\n    return diff, cmap", "response": "Computes the difference image between two slices"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_axis(array, axis, slice_num):\n\n    slice_list = [slice(None)] * array.ndim\n    slice_list[axis] = slice_num\n    slice_data = array[tuple(slice_list)].T  # transpose for proper orientation\n\n    return slice_data", "response": "Returns a fixed axis"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_bounding_rect(rect_pos):\n\n    if not isinstance(rect_pos, Iterable):\n        raise ValueError('rectangle spect must be a tuple of floats '\n                         'specifying (left, right, width, height)')\n\n    left, bottom, width, height = rect_pos\n    for val, name in zip((left, bottom, width, height),\n                         ('left', 'bottom', 'width', 'height')):\n        if val < 0.0 or val > 1.0:\n            raise ValueError(\"{}'s value must be >=0 and <= 1.0. \"\n                             \"It is now {}\".format(name, val))\n\n    if left + width > 1.0:\n        print('rect would extend beyond the width of figure/axis by {}'.format(left + width - 1.0))\n\n    if bottom + height > 1.0:\n        print('rect would extend beyond the height of figure/axis by {}'.format(\n            bottom + height - 1.0))\n\n    return rect_pos", "response": "Ensure the rect spec is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nensures valid view and dimensions are selected.", "response": "def check_views(view_set, max_views=3):\n    \"\"\"Ensures valid view/dimensions are selected.\"\"\"\n\n    if not isinstance(view_set, Iterable):\n        view_set = tuple([view_set, ])\n\n    if len(view_set) > max_views:\n        raise ValueError('Can only have {} views'.format(max_views))\n\n    return [check_int(view, 'view', min_value=0, max_value=max_views - 1) for view in view_set]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_num_slices(num_slices, img_shape=None, num_dims=3):\n\n    if not isinstance(num_slices, Iterable) or len(num_slices) == 1:\n        num_slices = np.repeat(num_slices, num_dims)\n\n    if img_shape is not None:\n        if len(num_slices) != len(img_shape):\n            raise ValueError('The number of dimensions requested is different from image.'\n                             ' Must be either 1 or equal to {}'.format(len(img_shape) + 1))\n        # upper bounding them to image shape\n        num_slices = np.minimum(img_shape, num_slices)\n\n    # lower bounding it to 1\n    return np.maximum(1, num_slices)", "response": "Ensures requested number of slices is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_image(img_spec, bkground_thresh, ensure_num_dim=3):\n\n    img = load_image_from_disk(img_spec)\n\n    if not np.issubdtype(img.dtype, np.floating):\n        img = img.astype('float32')\n\n    if ensure_num_dim == 3:\n        img = check_image_is_3d(img)\n    elif ensure_num_dim == 4:\n        img = check_image_is_4d(img)\n\n    return threshold_image(img, bkground_thresh)", "response": "Image reader with additional checks on size."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nensure the image loaded is 3d and nothing else.", "response": "def check_image_is_3d(img):\n    \"\"\"Ensures the image loaded is 3d and nothing else.\"\"\"\n\n    if len(img.shape) < 3:\n        raise ValueError('Input volume must be atleast 3D!')\n    elif len(img.shape) == 3:\n        for dim_size in img.shape:\n            if dim_size < 1:\n                raise ValueError('Atleast one slice must exist in each dimension')\n    elif len(img.shape) == 4:\n        if img.shape[3] != 1:\n            raise ValueError('Input volume is 4D with more than one volume!')\n        else:\n            img = np.squeeze(img, axis=3)\n    elif len(img.shape) > 4:\n        raise ValueError('Invalid shape of image : {}'.format(img.shape))\n\n    return img"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nensure the image loaded is 3d and nothing else.", "response": "def check_image_is_4d(img, min_num_volumes=2):\n    \"\"\"Ensures the image loaded is 3d and nothing else.\"\"\"\n\n    if len(img.shape) < 4:\n        raise ValueError('Input volume must be 4D!')\n    elif len(img.shape) == 4:\n        for dim_size in img.shape[:3]:\n            if dim_size < 1:\n                raise ValueError('Atleast one slice must exist in each dimension')\n        if img.shape[3] < min_num_volumes:\n            raise ValueError('Input volume is 4D '\n                             'with less than {} volumes!'.format(min_num_volumes))\n    elif len(img.shape) > 4:\n        raise ValueError('Too many dimensions : more than 4.\\n'\n                         'Invalid shape of image : {}'.format(img.shape))\n\n    return img"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef threshold_image(img, bkground_thresh, bkground_value=0.0):\n\n    if bkground_thresh is None:\n        return img\n\n    if isinstance(bkground_thresh, str):\n        try:\n            thresh_perc = float(bkground_thresh.replace('%', ''))\n        except:\n            raise ValueError(\n                'percentile specified could not be parsed correctly '\n                ' - must be a string of the form \"5%\", \"10%\" etc')\n        else:\n            thresh_value = np.percentile(img, thresh_perc)\n    elif isinstance(bkground_thresh, (float, int)):\n        thresh_value = bkground_thresh\n    else:\n        raise ValueError('Invalid specification for background threshold.')\n\n    img[img < thresh_value] = bkground_value\n\n    return img", "response": "Thresholds an image at a given value or percentile."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nscales the two images to [ 0 1 ) based on min max and upper limit.", "response": "def scale_0to1(image_in,\n               exclude_outliers_below=False,\n               exclude_outliers_above=False):\n    \"\"\"Scale the two images to [0, 1] based on min/max from both.\n\n    Parameters\n    -----------\n    image_in : ndarray\n        Input image\n\n    exclude_outliers_{below,above} : float\n        Lower/upper limit, a value between 0 and 100.\n\n    Returns\n    -------\n\n    scaled_image : ndarray\n        clipped and/or scaled image\n\n    \"\"\"\n\n    min_value = image_in.min()\n    max_value = image_in.max()\n    # making a copy to ensure no side-effects\n    image = image_in.copy()\n    if exclude_outliers_below:\n        perctl = float(exclude_outliers_below)\n        image[image < np.percentile(image, perctl)] = min_value\n\n    if exclude_outliers_above:\n        perctl = float(exclude_outliers_above)\n        image[image > np.percentile(image, 100.0 - perctl)] = max_value\n\n    image = (image - min_value) / (max_value - min_value)\n\n    return image"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef row_wise_rescale(matrix):\n\n    if matrix.shape[0] <= matrix.shape[1]:\n        raise ValueError('Number of voxels is less than the number of time points!! '\n                      'Are you sure data is reshaped correctly?')\n\n    min_ = matrix.min(axis=1)\n    range_ = matrix.ptp(axis=1)  # ptp : peak to peak, max-min\n    min_tile = np.tile(min_, (matrix.shape[1], 1)).T\n    range_tile = np.tile(range_, (matrix.shape[1], 1)).T\n    # avoiding any numerical difficulties\n    range_tile[range_tile < np.finfo(np.float).eps] = 1.0\n\n    normed = (matrix - min_tile) / range_tile\n\n    del min_, range_, min_tile, range_tile\n\n    return normed", "response": "Rescale a given matrix to a single voxel."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef crop_to_seg_extents(img, seg, padding):\n\n    beg_coords, end_coords = crop_coords(seg, padding)\n\n    img = crop_3dimage(img, beg_coords, end_coords)\n    seg = crop_3dimage(seg, beg_coords, end_coords)\n\n    return img, seg", "response": "Crop the image to fit within the bounding box of a segmentation or set of seg."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncropping the images to ensure both fit within the bounding box", "response": "def crop_to_extents(img1, img2, padding):\n    \"\"\"Crop the images to ensure both fit within the bounding box\"\"\"\n\n    beg_coords1, end_coords1 = crop_coords(img1, padding)\n    beg_coords2, end_coords2 = crop_coords(img2, padding)\n\n    beg_coords = np.fmin(beg_coords1, beg_coords2)\n    end_coords = np.fmax(end_coords1, end_coords2)\n\n    img1 = crop_3dimage(img1, beg_coords, end_coords)\n    img2 = crop_3dimage(img2, beg_coords, end_coords)\n\n    return img1, img2"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncrop an image or slice to its extents", "response": "def crop_image(img, padding=5):\n    \"Crops an image or slice to its extents\"\n\n    if padding < 1:\n        return img\n\n    beg_coords, end_coords = crop_coords(img, padding)\n\n    if len(img.shape) == 3:\n        img = crop_3dimage(img, beg_coords, end_coords)\n    elif len(img.shape) == 2:\n        img = crop_2dimage(img, beg_coords, end_coords)\n    else:\n        raise ValueError('Can only crop 2D or 3D images!')\n\n    return img"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef crop_coords(img, padding):\n\n    coords = np.nonzero(img)\n    empty_axis_exists = np.any([len(arr) == 0 for arr in coords])\n    if empty_axis_exists:\n        end_coords = img.shape\n        beg_coords = np.zeros((1, img.ndim)).astype(int).flatten()\n    else:\n        min_coords = np.array([arr.min() for arr in coords])\n        max_coords = np.array([arr.max() for arr in coords])\n        beg_coords = np.fmax(0, min_coords - padding)\n        end_coords = np.fmin(img.shape, max_coords + padding)\n\n    return beg_coords, end_coords", "response": "Find coordinates describing extent of non - zero portion of image padded"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncrops a 3d image to the bounding box specified.", "response": "def crop_3dimage(img, beg_coords, end_coords):\n    \"\"\"Crops a 3d image to the bounding box specified.\"\"\"\n\n    cropped_img = img[\n                  beg_coords[0]:end_coords[0],\n                  beg_coords[1]:end_coords[1],\n                  beg_coords[2]:end_coords[2]\n                  ]\n\n    return cropped_img"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef crop_2dimage(img, beg_coords, end_coords):\n\n    cropped_img = img[\n                  beg_coords[0]:end_coords[0],\n                  beg_coords[1]:end_coords[1],\n                  ]\n\n    return cropped_img", "response": "Crops a 3d image to the bounding box specified."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npick the slices to display in each dimension skipping any empty slices at the bottom.", "response": "def pick_slices(img, num_slices_per_view):\n    \"\"\"\n    Picks the slices to display in each dimension,\n        skipping any empty slices (without any segmentation at all).\n\n    \"\"\"\n\n    slices = list()\n    for view in range(len(img.shape)):\n        dim_size = img.shape[view]\n        non_empty_slices = np.array(\n            [sl for sl in range(dim_size) if np.count_nonzero(get_axis(img, view, sl)) > 0])\n        num_non_empty = len(non_empty_slices)\n\n        # trying to 5% slices at the tails (bottom clipping at 0)\n        skip_count = max(0, np.around(num_non_empty * 0.05).astype('int16'))\n        # only when possible\n        if skip_count > 0 and (num_non_empty - 2 * skip_count >= num_slices_per_view):\n            non_empty_slices = non_empty_slices[skip_count: -skip_count]\n            num_non_empty = len(non_empty_slices)\n\n        # sampling non-empty slices only\n        sampled_indices = np.linspace(0, num_non_empty, num=min(num_non_empty, num_slices_per_view),\n                                      endpoint=False)\n        slices_in_dim = non_empty_slices[np.around(sampled_indices).astype('int64')]\n\n        # ensure you do not overshoot\n        slices_in_dim = [sn for sn in slices_in_dim if sn >= 0 or sn <= num_non_empty]\n\n        slices.append(slices_in_dim)\n\n    return slices"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nscales the two images to [ 0 1 ) based on min / max from both.", "response": "def scale_images_0to1(slice1, slice2):\n    \"\"\"Scale the two images to [0, 1] based on min/max from both.\"\"\"\n\n    min_value = max(slice1.min(), slice2.min())\n    max_value = max(slice1.max(), slice2.max())\n\n    slice1 = (slice1 - min_value) / max_value\n    slice2 = (slice2 - min_value) / max_value\n\n    return slice1, slice2"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nverifies the sampler requested is valid.", "response": "def verify_sampler(sampler, image, image_shape, view_set, num_slices):\n    \"\"\"verifies the sampler requested is valid.\"\"\"\n\n    if isinstance(sampler, str):\n        sampler = sampler.lower()\n        if sampler not in ['linear', ]:\n            raise ValueError('Sampling strategy: {} not implemented.'.format(sampler))\n        out_sampler = sampler\n        out_sampling_method = 'linear'\n    elif isinstance(sampler, Iterable):\n        if any([index < 0 or index > 100 for index in sampler]):\n            raise ValueError('sampling percentages must be in  [0-100]% range')\n        if len(sampler) > min(num_slices):\n            num_slices = np.maximum(num_slices, len(sampler))\n        out_sampler = np.array(sampler)\n        out_sampling_method = 'percentage'\n    elif callable(sampler):\n        # checking if the callable returns a bool\n        for view in view_set:\n            middle_slice = int(image_shape[view] / 2)\n            if not isinstance(sampler(get_axis(image, view, middle_slice)), bool):\n                raise ValueError('sampler callable must return a boolean value (True/False)')\n\n        out_sampler = sampler\n        out_sampling_method = 'callable'\n    else:\n        raise NotImplementedError('Invalid choice for sampler! Choose one of: '\n                                  'linear, percentage or callable')\n\n    return out_sampler, out_sampling_method, num_slices"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning username maximum length as supported by Django.", "response": "def get_username_max_len():\n    \"\"\"Returns username maximum length as supported by Django.\n\n    :rtype: int\n    \"\"\"\n    fields = [field for field in USER._meta.fields if field.name == 'username']\n    try:\n        length = fields[0].max_length\n    except IndexError:\n        length = 30\n    return length"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_env(self, config):\n        for option, value in config.items():\n            env_name = 'SCRAPEKIT_%s' % option.upper()\n            value = os.environ.get(env_name, value)\n            config[option] = value\n        return config", "response": "Read environment variables based on the settings defined in\n        and return the config dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_file(self, config):\n        config_file = SafeConfigParser()\n        config_file.read([os.path.expanduser('~/.scrapekit.ini')])\n        if config_file.has_section('scrapekit'):\n            config.update(dict(config_file.items('scrapekit')))\n        if config_file.has_section(self.scraper.name):\n            config.update(dict(config_file.items(self.scraper.name)))\n        return config", "response": "Read a per - user. ini file and update the given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the queue and the threads.", "response": "def _spawn(self):\n        \"\"\" Initialize the queue and the threads. \"\"\"\n        self.queue = Queue(maxsize=self.num_threads * 10)\n        for i in range(self.num_threads):\n            t = Thread(target=self._consume)\n            t.daemon = True\n            t.start()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _consume(self):\n        while True:\n            try:\n                task, args, kwargs = self.queue.get(True)\n                task(*args, **kwargs)\n            finally:\n                self.queue.task_done()", "response": "This method is called by the thread that handles processing tasks off the queue and notifying the queue that they are done."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put(self, task, args, kwargs):\n        if self.num_threads == 0:\n            return task(*args, **kwargs)\n        if self.queue is None:\n            self._spawn()\n        self.queue.put((task, args, kwargs))", "response": "Add a new item to the queue."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef queue(self, *args, **kwargs):\n        self.scraper.task_manager.put(self, args, kwargs)\n        return self", "response": "Schedule a task for execution."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self, *args, **kwargs):\n        if self._source is not None:\n            return self._source.run(*args, **kwargs)\n        else:\n            self.queue(*args, **kwargs)\n            return self.wait()", "response": "Queue a first item to execute then wait for the queue to be empty before returning."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a chain listener to the execution of this task.", "response": "def chain(self, other_task):\n        \"\"\" Add a chain listener to the execution of this task. Whenever\n        an item has been processed by the task, the registered listener\n        task will be queued to be executed with the output of this task.\n\n        Can also be written as::\n\n            pipeline = task1 > task2\n        \"\"\"\n        other_task._source = self\n        self._listeners.append(ChainListener(other_task))\n        return other_task"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a pipe listener to the execution of this task.", "response": "def pipe(self, other_task):\n        \"\"\" Add a pipe listener to the execution of this task. The\n        output of this task is required to be an iterable. Each item in\n        the iterable will be queued as the sole argument to an execution\n        of the listener task.\n\n        Can also be written as::\n\n            pipeline = task1 | task2\n        \"\"\"\n        other_task._source = self\n        self._listeners.append(PipeListener(other_task))\n        return other_task"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate an XML element with client auth data populated.", "response": "def client_auth(self):\n        \"\"\"Generate an XML element with client auth data populated.\"\"\"\n        if not self._client_auth:\n            self._client_auth = E.Element('merchantAuthentication')\n            E.SubElement(self._client_auth, 'name').text = self.config.login_id\n            E.SubElement(self._client_auth, 'transactionKey').text = self.config.transaction_key\n        return self._client_auth"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _base_request(self, method):\n        request = E.Element(method)\n        request.set('xmlns', 'AnetApi/xml/v1/schema/AnetApiSchema.xsd')\n        request.append(self.client_auth)\n        return request", "response": "Factory method for generating the base XML requests."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _make_call(self, call):\n        try:\n            request = urllib2.Request(self.config.environment, E.tostring(call))\n            request.add_header('Content-Type', 'text/xml')\n            response = urllib2.urlopen(request).read()\n            response = E.fromstring(response)\n            response_json = parse_response(response)\n        except urllib2.HTTPError:\n            raise AuthorizeConnectionError('Error processing XML request.')\n\n        # Exception handling for transaction response errors.\n        try:\n            error = response_json.transaction_response.errors[0]\n            raise AuthorizeResponseError(error.error_code, error.error_text, response_json)\n        except (KeyError, AttributeError):  # Attempt to access transaction response errors\n            pass\n\n        # Throw an exception for invalid calls. This makes error handling easier.\n        if response_json.messages[0].result_code != 'Ok':\n            error = response_json.messages[0].message\n            raise AuthorizeResponseError(error.code, error.text, response_json)\n\n        return response_json", "response": "Make a call to the Authorize. net server with the XML."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tag_builder(parser, token, cls, flow_type):\n    tokens = token.split_contents()\n    tokens_num = len(tokens)\n\n    if tokens_num == 1 or (tokens_num == 3 and tokens[1] == 'for'):\n        flow_name = None\n        if tokens_num == 3:\n            flow_name = tokens[2]\n        return cls(flow_name)\n    else:\n        raise template.TemplateSyntaxError(\n            '\"sitegate_%(type)s_form\" tag requires zero or two arguments. '\n            'E.g. {%% sitegate_%(type)s_form %%} or '\n            '{%% sitegate_%(type)s_form for ClassicSignup %%}.' % {'type': flow_type})", "response": "Helper function handling flow form tags."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sitegate_view(*args_dec, **kwargs_dec):\n    if len(args_dec):  # simple decoration w/o parameters\n        return signup_view(signin_view(redirect_signedin(*args_dec, **kwargs_dec)))\n\n    signin = signin_view(**kwargs_dec)\n    signup = signup_view(**kwargs_dec)\n    return lambda *args, **kwargs: signup(signin(redirect_signedin(*args, **kwargs)))", "response": "Decorator to mark views used both for signup & sign in."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding 16 binary bytes into a 26 - character long base32 string.", "response": "def encode_ulid_base32(binary):\n    \"\"\"\n    Encode 16 binary bytes into a 26-character long base32 string.\n    :param binary: Bytestring or list of bytes\n    :return: ASCII string of 26 characters\n    :rtype: str\n    \"\"\"\n    assert len(binary) == 16\n\n    if not py3 and isinstance(binary, str):\n        binary = [ord(b) for b in binary]\n\n    symbols = _symbols\n    return ''.join([\n        symbols[(binary[0] & 224) >> 5],\n        symbols[binary[0] & 31],\n        symbols[(binary[1] & 248) >> 3],\n        symbols[((binary[1] & 7) << 2) | ((binary[2] & 192) >> 6)],\n        symbols[(binary[2] & 62) >> 1],\n        symbols[((binary[2] & 1) << 4) | ((binary[3] & 240) >> 4)],\n        symbols[((binary[3] & 15) << 1) | ((binary[4] & 128) >> 7)],\n        symbols[(binary[4] & 124) >> 2],\n        symbols[((binary[4] & 3) << 3) | ((binary[5] & 224) >> 5)],\n        symbols[binary[5] & 31],\n        symbols[(binary[6] & 248) >> 3],\n        symbols[((binary[6] & 7) << 2) | ((binary[7] & 192) >> 6)],\n        symbols[(binary[7] & 62) >> 1],\n        symbols[((binary[7] & 1) << 4) | ((binary[8] & 240) >> 4)],\n        symbols[((binary[8] & 15) << 1) | ((binary[9] & 128) >> 7)],\n        symbols[(binary[9] & 124) >> 2],\n        symbols[((binary[9] & 3) << 3) | ((binary[10] & 224) >> 5)],\n        symbols[binary[10] & 31],\n        symbols[(binary[11] & 248) >> 3],\n        symbols[((binary[11] & 7) << 2) | ((binary[12] & 192) >> 6)],\n        symbols[(binary[12] & 62) >> 1],\n        symbols[((binary[12] & 1) << 4) | ((binary[13] & 240) >> 4)],\n        symbols[((binary[13] & 15) << 1) | ((binary[14] & 128) >> 7)],\n        symbols[(binary[14] & 124) >> 2],\n        symbols[((binary[14] & 3) << 3) | ((binary[15] & 224) >> 5)],\n        symbols[binary[15] & 31],\n    ])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decode_ulid_base32(encoded):\n    if len(encoded) != 26:\n        raise InvalidULID('base32 ulid is %d characters long, expected 26' % len(encoded))\n\n    if not all(c in _symbols for c in encoded):\n        raise InvalidULID('invalid characters in base32 ulid')\n\n    b = [ord(c) for c in encoded]\n\n    if b[0] < 48 or b[0] > 55:\n        # See https://github.com/oklog/ulid/issues/9:\n        #   Technically, a 26-character Base32 encoded string can contain 130 bits of information,\n        #   whereas a ULID must only contain 128 bits.\n        #   Therefore, the largest valid ULID encoded in Base32 is 7ZZZZZZZZZZZZZZZZZZZZZZZZZ,\n        #   which corresponds to an epoch time of 281474976710655 or 2 ^ 48 - 1.\n        raise InvalidULID('base32 ulid is out of range (starts with %s; accepted are 01234567)' % encoded[0])\n\n    tab = _decode_table\n    binary = [(c & 0xFF) for c in [\n        ((tab[b[0]] << 5) | tab[b[1]]),\n        ((tab[b[2]] << 3) | (tab[b[3]] >> 2)),\n        ((tab[b[3]] << 6) | (tab[b[4]] << 1) | (tab[b[5]] >> 4)),\n        ((tab[b[5]] << 4) | (tab[b[6]] >> 1)),\n        ((tab[b[6]] << 7) | (tab[b[7]] << 2) | (tab[b[8]] >> 3)),\n        ((tab[b[8]] << 5) | tab[b[9]]),\n        ((tab[b[10]] << 3) | (tab[b[11]] >> 2)),\n        ((tab[b[11]] << 6) | (tab[b[12]] << 1) | (tab[b[13]] >> 4)),\n        ((tab[b[13]] << 4) | (tab[b[14]] >> 1)),\n        ((tab[b[14]] << 7) | (tab[b[15]] << 2) | (tab[b[16]] >> 3)),\n        ((tab[b[16]] << 5) | tab[b[17]]),\n        ((tab[b[18]] << 3) | tab[b[19]] >> 2),\n        ((tab[b[19]] << 6) | (tab[b[20]] << 1) | (tab[b[21]] >> 4)),\n        ((tab[b[21]] << 4) | (tab[b[22]] >> 1)),\n        ((tab[b[22]] << 7) | (tab[b[23]] << 2) | (tab[b[24]] >> 3)),\n        ((tab[b[24]] << 5) | tab[b[25]]),\n    ]]\n    return _to_binary(binary)", "response": "Decode a 26 - character long base32 encoded string into the original 16 bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_ulid_timestamp(ulid):\n    ts_bytes = ulid_to_binary(ulid)[:6]\n    ts_bytes = b'\\0\\0' + ts_bytes\n    assert len(ts_bytes) == 8\n    return (struct.unpack(b'!Q', ts_bytes)[0] / 1000.)", "response": "Get the time from an ULID as an UNIX timestamp."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_binary_ulid(timestamp=None, monotonic=False):\n    global _last_entropy, _last_timestamp\n    if timestamp is None:\n        timestamp = time.time()\n    elif isinstance(timestamp, datetime.datetime):\n        timestamp = calendar.timegm(timestamp.utctimetuple())\n\n    ts = int(timestamp * 1000.0)\n    ts_bytes = _to_binary(\n        (ts >> shift) & 0xFF for shift in (40, 32, 24, 16, 8, 0)\n    )\n    entropy = os.urandom(10)\n    if monotonic and _last_timestamp == ts and _last_entropy is not None:\n        while entropy < _last_entropy:\n            entropy = os.urandom(10)\n    _last_entropy = entropy\n    _last_timestamp = ts\n    return ts_bytes + entropy", "response": "Generates the bytes for an ULID."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates an ULID but expressed as an UUID.", "response": "def generate_ulid_as_uuid(timestamp=None, monotonic=False):\n    \"\"\"\n    Generate an ULID, but expressed as an UUID.\n\n    :param timestamp: An optional timestamp override.\n                      If `None`, the current time is used.\n    :type timestamp: int|float|datetime.datetime|None\n    :param monotonic: Attempt to ensure ULIDs are monotonically increasing.\n                      Monotonic behavior is not guaranteed when used from multiple threads.\n    :type monotonic: bool\n    :return: UUID containing ULID data.\n    :rtype: uuid.UUID\n    \"\"\"\n    return uuid.UUID(bytes=generate_binary_ulid(timestamp, monotonic=monotonic))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts an ULID to its binary representation.", "response": "def ulid_to_binary(ulid):\n    \"\"\"\n    Convert an ULID to its binary representation.\n\n    :param ulid: An ULID (either as UUID, base32 ULID or binary)\n    :return: Bytestring of length 16\n    :rtype: bytes\n    \"\"\"\n    if isinstance(ulid, uuid.UUID):\n        return ulid.bytes\n    if isinstance(ulid, (text_type, bytes)) and len(ulid) == 26:\n        return decode_ulid_base32(ulid)\n    if isinstance(ulid, (bytes, bytearray)) and len(ulid) == 16:\n        return ulid\n    raise InvalidULID('can not convert ulid %r to binary' % ulid)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_session(scraper):\n    cache_path = os.path.join(scraper.config.data_path, 'cache')\n    cache_policy = scraper.config.cache_policy\n    cache_policy = cache_policy.lower().strip()\n    session = ScraperSession()\n    session.scraper = scraper\n    session.cache_policy = cache_policy\n\n    adapter = CacheControlAdapter(\n        FileCache(cache_path),\n        cache_etags=True,\n        controller_class=PolicyCacheController\n    )\n    session.mount('http://', adapter)\n    session.mount('https://', adapter)\n    return session", "response": "Instantiate a session with the desired configuration parameters and cache policy."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef html(self):\n        try:\n            from lxml import html\n            return html.fromstring(self.content)\n        except ImportError as ie:\n            raise DependencyException(ie)", "response": "Create an lxml - based HTML DOM from the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef xml(self):\n        try:\n            from lxml import etree\n            return etree.fromstring(self.content)\n        except ImportError as ie:\n            raise DependencyException(ie)", "response": "Create an lxml - based XML DOM from the response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate JSON object out of the response.", "response": "def json(self, **kwargs):\n        \"\"\" Create JSON object out of the response. \"\"\"\n        try:\n            return super(ScraperResponse, self).json(**kwargs)\n        except ValueError as ve:\n            raise ParseException(ve)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_sitegate_urls():\n    url_verify = url(r'^verify_email/(?P<code>\\S+)/$', verify_email, name='verify_email')\n\n    if VERSION >= (1, 9):\n        return [url_verify]\n\n    from django.conf.urls import patterns\n    return patterns('', url_verify)", "response": "Returns sitegate urlpatterns that can be attached to urlpatterns of a project"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncollapsing all consecutive whitespace newlines tabs in a string into single whitespaces and strip the outer whitespace.", "response": "def collapse_whitespace(text):\n    \"\"\" Collapse all consecutive whitespace, newlines and tabs\n    in a string into single whitespaces, and strip the outer\n    whitespace. This will also accept an ``lxml`` element and\n    extract all text. \"\"\"\n    if text is None:\n        return None\n    if hasattr(text, 'xpath'):\n        text = text.xpath('string()')\n    text = re.sub('\\s+', ' ', text)\n    return text.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup_regex(self):\n        #Regex for matching the entire body of the type and getting top-level modifiers.\n        self._RX_TYPE = r\"\\n\\s*type(?P<modifiers>,\\s+(public|private))?(\\s*::)?\\s+(?P<name>[A-Za-z0-9_]+)\" + \\\n                        r\"(?P<contents>.+?)end\\s*type(\\s+(?P=name))?\"\n        self.RE_TYPE = re.compile(self._RX_TYPE, re.DOTALL | re.I)\n        #This regex is the same as RE_TYPE, only the contents are removed from the definition.\n        self._RX_SIG =  r\"type(?P<modifiers>,\\s+(public|private))?(\\s+::)?\\s+(?P<name>[A-Za-z0-9_]+)\"\n        self.RE_SIG = re.compile(self._RX_SIG, re.I)\n\n        #Regex for finding if the type is private\n        self._RX_PRIV = \"private.+?(contains)?\"\n        self.RE_PRIV = re.compile(self._RX_PRIV, re.DOTALL | re.I)\n        #Regex for finding methods buried in a type declaration.\n        self._RX_EXEC = r\"^\\s*(?P<modifiers>[^:]+)\\s+::\\s+(?P<name>[A-Za-z0-9_]+)\" + \\\n                        r\"(\\s+=>\\s+(?P<points>[A-Za-z0-9_]+))?$\"\n        self.RE_EXEC = re.compile(self._RX_EXEC, re.M | re.I)\n        #Regex for getting text after contains statement\n        self._RX_CONTAINS = \"\\n\\s*contains(?P<remainder>.+)\"\n        self.RE_CONTAINS = re.compile(self._RX_CONTAINS, re.DOTALL | re.I)", "response": "Sets up the patterns and compiled regex objects for parsing types."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the specified line as a new version of the signature for element.", "response": "def parse_signature(self, statement, element, module=None):\n        \"\"\"Parses the specified line as a new version of the signature for 'element'.\n\n        :arg statement: the string that has the new signature.\n        :arg element: the code element whose signature will be changed.\n        :arg module: for real-time module update, the module who the new element\n          will be child to.\n        \"\"\"\n        #Types don't have their signatures updated in any way that affects\n        #the intellisense other than a name change.\n        tmatch = self.RE_SIG.match(statement)\n        result = (None, None, None)\n\n        if tmatch is not None:\n            name = tmatch.group(\"name\")\n\n            #We also need to overwrite the modifiers list with the new signature\n            modifiers = tmatch.group(\"modifiers\")\n            if modifiers is not None:\n                cleanmods = re.split(\"[\\s,]+\", modifiers.strip())\n            else:\n                cleanmods = []\n            if module is None:\n                element.update_name(name)\n                element.modifiers.extend(cleanmods)\n            else:\n                result = (CustomType(name, modifiers, {}, module), \n                          tmatch.start(), tmatch.end())\n                                  \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _rt_members_add(self, element, statement):\n        members = self.vparser.parse(statement, None)\n        for member in members:\n            single = members[member]\n            single.parent = element\n            element.members[member] = single", "response": "Finds all the member declarations in statement and adds the\n            corresponding instances to element. members."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _rt_members_delete(self, element, statement):\n        removals = self.vparser.parse(statement, None)\n        for member in removals:\n            if member in element.members:\n                del element.members[member]", "response": "Removes all the member declarations in statement and removes the corresponding instances from element. members."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self, module):\n        matches = self.RE_TYPE.finditer(module.contents)\n        result = {}\n\n        for match in matches:\n            name = match.group(\"name\")\n            modifiers = match.group(\"modifiers\")\n            if modifiers is not None:\n                cleanmods = re.split(\"[\\s,]+\", modifiers.strip())\n            else:\n                cleanmods = []\n\n            contents = match.group(\"contents\")\n            result[name.lower()] = self._process_type(name, cleanmods, contents, module, match)\n            if \"public\" in result[name.lower()].modifiers:\n                module.publics[name.lower()] = 1\n\n        #Set the types we found in the module and then move the embedded\n        #ones into their correct parent executables.\n        module.types = result\n        module.update_embedded(\"types\")", "response": "Extracts all the types from the specified module body."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses a regex match of a type s contents.", "response": "def _process_type(self, name, modifiers, contents, module, match):\n        \"\"\"Processes a regex match of a type's contents.\"\"\"\n        #First, we need to see if the types children are private.\n        if self.RE_PRIV.search(contents):\n            modifiers.append(\"private contents\")\n\n        #Next, we need to parse out all the members of the type and their docstrings\n        members = self.vparser.parse(contents, None)\n        \n        #Now we can create the type code element and handle the member docstrings\n        t = CustomType(name, modifiers, members, module)\n        #parse out all the executables including the finalizer\n        execs = self._process_execs(contents, module.name, t)\n\n        #Set the regex start and end char indices\n        t.start, t.end = module.absolute_charindex(match.string, match.start(),\n                                                             match.end())\n\n        #Update the parent for embedded members and executables\n        for key in list(t.members.keys()):\n            t.members[key].parent = t\n        for key in list(t.executables.keys()):\n            t.executables[key].parent = t\n\n        #Extract the docstrings from the type body and associate them with their members\n        memdocs = self.docparser.parse_docs(contents, t)\n        if name in memdocs:\n            docs = self.docparser.to_doc(memdocs[name][0], name)\n            self.docparser.process_memberdocs(docs, t)\n\n        return t"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_docs(self, t, module):\n        #We need to look in the parent module docstrings for this types decorating tags.\n        key = \"{}.{}\".format(module.name, t.name)\n        if key in module.predocs:\n            t.docstring = self.docparser.to_doc(module.predocs[key][0], t.name)\n            t.docstart, t.docend = (module.predocs[key][1], module.predocs[key][2])", "response": "Updates the documentation for the specified type using the module predocs."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract all the executable methods that belong to the type.", "response": "def _process_execs(self, contents, modulename, atype, mode=\"insert\"):\n        \"\"\"Extracts all the executable methods that belong to the type.\"\"\"\n        #We only want to look at text after the contains statement\n        match = self.RE_CONTAINS.search(contents)\n\n        #It is possible for the type to not have any executables\n        if match is not None:\n            exectext = match.group(\"remainder\")\n            self._process_execs_contents(exectext, modulename, atype, mode)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck the logged - in status of the current session.", "response": "def logged_in(self):\n    \"\"\"Checks the logged-in status of the current session. \n    Expensive (requests a page), so use sparingly! Best practice is to try a request and catch an UnauthorizedError.\n\n    :rtype: bool\n    :return: Whether or not the current session is logged-in.\n\n    \"\"\"\n    if self.session is None:\n      return False\n\n    panel_url = u'http://myanimelist.net/panel.php'\n    panel = self.session.get(panel_url)\n\n    if 'Logout' in panel.content:\n      return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlogs into MAL and sets cookies appropriately.", "response": "def login(self):\n    \"\"\"Logs into MAL and sets cookies appropriately.\n\n    :rtype: :class:`.Session`\n    :return: The current session.\n\n    \"\"\"\n    # POSTS a login to mal.\n    mal_headers = {\n      'Host': 'myanimelist.net',\n    }\n    mal_payload = {\n      'username': self.username,\n      'password': self.password,\n      'cookie': 1,\n      'sublogin': 'Login'\n    }\n    self.session.headers.update(mal_headers)\n    r = self.session.post(u'http://myanimelist.net/login.php', data=mal_payload)\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef increase_indent(func):\n    def wrapper(*args, **kwargs):\n        global _debug_indent\n        _debug_indent += 1\n        result = func(*args, **kwargs)\n        _debug_indent -= 1\n        return result\n    return wrapper", "response": "Decorator for makin to increase the indentation of the log entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint a debug message.", "response": "def dbg(message, *args):\n    \"\"\" Looks at the stack, to see if a debug message should be printed. \"\"\"\n    if debug_function and enable_notice:\n        frm = inspect.stack()[1]\n        mod = inspect.getmodule(frm[0])\n        if not (mod.__name__ in ignored_modules):\n            i = ' ' * _debug_indent\n            debug_function(NOTICE, i + 'dbg: ' + message % args)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef print_to_stdout(level, str_out):\n    if level == NOTICE:\n        col = Fore.GREEN\n    elif level == WARNING:\n        col = Fore.RED\n    else:\n        col = Fore.YELLOW\n    if not is_py3:\n        str_out = str_out.encode(encoding, 'replace')\n    print((col + str_out + Fore.RESET))", "response": "The default debug function"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef count_dimensions(entry):\n    result = 0\n    for e in entry:\n        if isinstance(e, str):\n            sliced = e.strip(\",\").split(\",\")\n            result += 0 if len(sliced) == 1 and sliced[0] == \"\" else len(sliced)\n    return result", "response": "Counts the number of dimensions from a nested list of dimension assignments."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self, string, parent):\n        result = {}\n        for member in self.RE_MEMBERS.finditer(string):\n            mems = self._process_member(member, parent, string)\n            #The regex match could contain multiple members that were defined\n            #on the same line in the code file.\n            for onemem in mems:\n                result[onemem.name.lower()] = onemem\n                \n        return result", "response": "Parses all the value code elements from the specified string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting all the member info from the regex match ; returns a ValueElements.", "response": "def _process_member(self, member, parent, string):\n        \"\"\"Extracts all the member info from the regex match; returns a ValueElements.\"\"\"\n        #The modifiers regex is very greedy so we have some cleaning up to do\n        #to extract the mods.\n        modifiers = member.group(\"modifiers\")\n        dimension = None\n        \n        if modifiers is not None:\n            #Unfortunately, the dimension can also be specified as a modifier and\n            #the dimensions can include variable names and functions. This introduces\n            #the possibility of nested lists.\n            modifiers = modifiers.lower()\n            if \"dimension\" in modifiers:\n                start, end = self._get_dim_modifier(modifiers)\n                dimension = modifiers[start+1:end]\n                dimtext = modifiers[modifiers.index(\"dimension\"):end+1]\n                modifiers = re.split(\",\\s*\", modifiers.replace(dimtext, \"\").strip())\n                #modifiers.append(\"dimension\")\n            else:\n                modifiers = re.split(\"[,\\s]+\", modifiers.strip())\n\n            if \"\" in modifiers:\n                modifiers.remove(\"\")\n\n        dtype = member.group(\"type\")\n        kind = member.group(\"kind\")\n        names = member.group(\"names\")\n\n        #If there are multiple vars defined on this line we need to return\n        #a list of all of them.\n        result = []\n\n        #They might have defined multiple vars on the same line\n        refstring = string[member.start():member.end()].strip()\n        if parent is not None:\n            refline = parent.module.linenum(member.start())\n        else:\n            refline = \"?\"\n        ready = self._separate_multiple_def(re.sub(\",\\s*\", \", \", names.strip()), parent, refstring, refline)\n        \n        for name, ldimension, default, D in self._clean_multiple_def(ready):\n            #Now construct the element and set all the values, then add it in the results list.\n            udim = ldimension if ldimension is not None else dimension\n            uD = D if ldimension is not None else count_dimensions([dimension])\n            result.append(ValueElement(name, modifiers, dtype, kind, default, udim, parent, uD))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nseparating the text after '::' in a variable definition to extract all the variables their dimensions and default values.", "response": "def _separate_multiple_def(self, defstring, parent, refstring, refline):\n        \"\"\"Separates the text after '::' in a variable definition to extract all the variables,\n        their dimensions and default values.\n        \"\"\"\n        import pyparsing\n        nester = pyparsing.nestedExpr('(', ')')\n        try:\n            parsed = nester.parseString(\"(\" + re.sub(\"=(>?)\", \" =\\\\1 \", defstring) + \")\").asList()[0]\n        except pyparsing.ParseException as err:\n            from fortpy import msg\n            repl = (parent.name, refline[0], refstring,\n                    defstring, ''.join(['-']*(err.loc-1))+'^', err.msg)\n            msg.err(\"parsing variable from '{}:{} >> {}': \\n'{}'\\n{} {}.\".format(*repl))\n            raise\n        \n        i = 0\n        clean = []\n        while i < len(parsed):\n            if (isinstance(parsed[i], str) and not re.match(\"=>?\", parsed[i]) and \n                i+1 < len(parsed) and isinstance(parsed[i+1], list)):\n                clean.append((parsed[i], parsed[i+1]))\n                i += 2\n            elif isinstance(parsed[i], str) and parsed[i] == \",\":\n                i += 1\n            else:\n                clean.append(parsed[i])\n                i += 1\n\n        #Now pass through again to handle the default values.\n        i = 0\n        ready = []\n        while i < len(clean):\n            if isinstance(clean[i], str) and re.match(\"=>?\", clean[i]):\n                ready.pop()\n                if \">\" in clean[i]:\n                    ready.append([clean[i-1], (\"> \" + clean[i+1][0], clean[i+1][1])])\n                else:\n                    ready.append([clean[i-1], clean[i+1]])\n                i += 2\n            else:\n                ready.append(clean[i])\n                i += 1\n\n        return ready"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncollapses the list structure in entry to a single string representing the default value assigned to a variable or its dimensions.", "response": "def _collapse_default(self, entry):\n        \"\"\"Collapses the list structure in entry to a single string representing the default\n        value assigned to a variable or its dimensions.\n        \"\"\"\n        if isinstance(entry, tuple) or isinstance(entry, list):\n            sets = []\n            i = 0\n            while i < len(entry):\n                if isinstance(entry[i], str) and i+1 < len(entry) and isinstance(entry[i+1], list):\n                    sets.append((entry[i], entry[i+1]))\n                    i += 2\n                elif isinstance(entry[i], str) and entry[i] == \",\":\n                    i += 1\n                else:\n                    sets.append((entry[i],))\n                    i += 1\n\n            result = []\n            for s in sets:\n                if isinstance(s[0], str):\n                    name = s[0].strip(\",\")\n                elif len(s) == 1:\n                    name = self._collapse_default(s[0])\n                    \n                if len(s) > 1:\n                    args = self._collapse_default(s[1])\n                else:\n                    args = []\n                if len(args) > 0:\n                    result.append(\"{}({})\".format(name, args))\n                else:\n                    result.append(name)\n\n            return ', '.join(result)\n        else:\n            if \",\" in entry:\n                return entry.split(\",\")[0].strip()\n            else:\n                return entry.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclean the list of variable definitions extracted from the definition text to get hold of the dimensions and default values.", "response": "def _clean_multiple_def(self, ready):\n        \"\"\"Cleans the list of variable definitions extracted from the definition text to\n        get hold of the dimensions and default values.\n        \"\"\"\n        result = []\n        for entry in ready:\n            if isinstance(entry, list):\n                #This variable declaration has a default value specified, which is in the\n                #second slot of the list.\n                default = self._collapse_default(entry[1])\n                #For hard-coded array defaults, add the parenthesis back in.\n                if default[0] == \"/\":\n                    default = \"({})\".format(default)\n                namedim = entry[0]\n            else:\n                default = None\n                namedim = entry\n\n            if isinstance(namedim, str):\n                name = namedim.strip().strip(\",\")\n                dimension = None\n                D = 0\n            else:\n                #Namedim is a tuple of (name, dimension)\n                name = namedim[0].strip()\n                D = count_dimensions(namedim[1])\n                dimension = self._collapse_default(namedim[1])\n\n            result.append((name, dimension, default, D))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_dim_modifier(self, modifiers, dimstring=None):\n        if dimstring is None:\n            suffix = modifiers.split(\"dimension\")[1]\n            start = modifiers.index(\"dimension\") + len(\"dimension\")\n        else:\n            suffix = dimstring\n            start = 0\n        \n        #We use a stack to monitor how many parenthesis we have traversed in the string.\n        #Once we reach the closing parenthesis, we know that we have the dimension info.\n        stack = []\n        args = []\n        for i in range(len(suffix)):\n            if suffix[i] == '(':\n                stack.append(i + start)\n            elif suffix[i] == ')':\n                args.append((stack.pop(), i + start))\n                if len(stack) == 0:\n                    #The last entry in args should be the indices of the entire\n                    #dimension expression once the very first '(' has its twin found.\n                    return args[-1]", "response": "Extracts the dimension information from the string of modifiers extracted by the regex."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef char_range(starting_char, ending_char):\n    assert isinstance(starting_char, str), 'char_range: Wrong argument/s type'\n    assert isinstance(ending_char, str), 'char_range: Wrong argument/s type'\n\n    for char in range(ord(starting_char), ord(ending_char) + 1):\n        yield chr(char)", "response": "Generate a range of characters in the alphabet."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a charset into a charset string", "response": "def parse_charset(charset):\n    \"\"\"\n    Finds out whether there are intervals to expand and\n    creates the charset\n    \"\"\"\n    import re\n    regex = r'(\\w-\\w)'\n    pat = re.compile(regex)\n    found = pat.findall(charset)\n    result = ''\n    if found:\n        for element in found:\n            for char in char_range(element[0], element[-1]):\n                result += char\n        return result\n    return charset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef size(self):\n        width = max(\n            map(lambda x: x.size()[0], self.sections.itervalues()))\n\n        height = sum(\n            map(lambda x: x.size()[1], self.sections.itervalues()))\n\n        return width, height", "response": "Return the viewable size of the Table as a tuple"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess footer and return the processed string", "response": "def get_ftr(self):\n        \"\"\"\n        Process footer and return the processed string\n        \"\"\"\n        if not self.ftr:\n            return self.ftr\n\n        width = self.size()[0]\n        return re.sub(\n            \"%time\", \"%s\\n\" % time.strftime(\"%H:%M:%S\"), self.ftr).rjust(width)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhelping for each command.", "response": "def do_help(self, arg):\n        \"\"\"Sets up the header for the help command that explains the background on how to use\n        the script generally. Help for each command then stands alone in the context of this\n        documentation. Although we could have documented this on the wiki, it is better served\n        when shipped with the shell.\n        \"\"\"\n        if arg == \"\":\n            lines = [(\"The fortpy unit testing analysis shell makes it easy to analyze the results \"\n                      \"of multiple test cases, make plots of trends and tabulate values for use in \"\n                      \"other applications. This documentation will provide an overview of the basics. \"\n                      \"Use 'help <command>' to get specific command help.\"),\n                     (\"Each fortpy shell session can hold the results of multiple unit tests. You can \"\n                      \"load a unit test's results into the session using one of the 'parse' commands. \"\n                      \"Once the test is loaded you can tabulate and plot results by setting test case \"\n                      \"filters ('filter'), and independent and dependent variables ('indep', 'dep').\"\n                      \"Switch between different unit tests loaded into the session using 'set'.\"),\n                     (\"To make multiple plots/tables for the same unit test, create new analysis \"\n                      \"groups ('group'). \"\n                      \"Each group has its own set of properties that can be set (e.g. variables, plot \"\n                      \"labels for axes, filters for test cases, etc.) The possible properties that affect \"\n                      \"each command are listed in the specific help for that command.\"),\n                     (\"You can save the state of a shell session using 'save' and then recover it at \"\n                      \"a later time using 'load'. When a session is re-loaded, all the variables and \"\n                      \"properties/settings for plots/tables are maintained and the latest state of the \"\n                      \"unit test's results are used. A console history is also maintained with bash-like \"\n                      \"commands (e.g. Ctrl-R for reverse history search, etc.) across sessions. You can \"\n                      \"manipulate its behavior with 'history'.\")]\n            \n            self._fixed_width_info(lines)\n        cmd.Cmd.do_help(self, arg)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting the specified string as information with fixed width of 80 chars.", "response": "def _fixed_width_info(self, lines):\n        \"\"\"Prints the specified string as information with fixed width of 80 chars.\"\"\"\n        for string in lines:\n            for line in [string[i:i+80] for i in range(0, len(string), 80)]:\n                msg.info(line)\n            msg.blank()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the dictionary of arguments for plotting or tabulating of the active unit test and analysis group.", "response": "def curargs(self):\n        \"\"\"Returns the dictionary of arguments for plotting/tabulating of the active\n        unit test and analysis group.\n        \"\"\"\n        #This is where we update the arguments to new dictionary versions when the code\n        #is updated with new features etc. so that the older, serialized sessions don't\n        #break.\n        if (self.active not in self._version_check or \n            self.group not in self._version_check[self.active]):\n            if (\"version\" not in self.args[self.active][self.group] or\n                self.args[self.active][self.group][\"version\"] < self._template_args[\"version\"]):\n                for key in self._template_args:\n                    if key not in self.args[self.active][self.group]:\n                        self.args[self.active][self.group][key] = self._template_args[key]\n                self.args[self.active][self.group][\"version\"] = self._template_args[\"version\"]\n\n            if self.active not in self._version_check:\n                self._version_check[self.active] = [self.group]\n            else:\n                self._version_check[self.active].append(self.group)\n\n        return self.args[self.active][self.group]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine whether the specified shell args have a redirect specification for the output. Returns a tuple of ( usable args filename append ).", "response": "def _redirect_split(self, args):\n        \"\"\"Determines whether the specified shell args have a redirect specification for\n        the output. Returns a tuple of (usable args, filename, append).\n        \"\"\"\n        if \">>\" in args:\n            append = True\n            usable, filename = args.split(\">>\")\n        elif \">\" in args:\n            append = False\n            usable, filename = args.split(\">\")\n        else:\n            append = filename = None\n            usable = args\n\n        if filename is not None:\n            return (usable, filename.strip(), append)\n        else:\n            return (usable, filename, append)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _redirect_output(self, value, filename=None, append=None, printfun=None):\n        if filename is None:\n            if printfun is None:\n                print(value)\n            else:\n                printfun(value)\n        else:\n            if append:\n                mode = 'a'\n            else:\n                mode = 'w'\n\n            from os import path\n            fullpath = path.abspath(filename)\n            with open(filename, mode) as f:\n                f.write(value + '\\n')", "response": "Outputs the specified value to the console or a file depending on the redirect\nAttributeNames behavior specified."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _print_dict_files(self, case, target):\n        if case in self.live and target in self.live[case]:\n            lines = []\n            data = self.live[case][target]\n            skeys = list(sorted(data.keys()))\n            for key in skeys:\n                props = \", \".join(sorted(data[key].keys()))\n                lines.append(\"'{}': {}\".format(key, props))\n            return '\\n'.join(lines)\n        else:\n            msg.err(\"Can't find the result set {} in {}\".format(target, case))", "response": "Prints the file names and available properties in the specified test case s target dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the completion list of possible test cases for the active unit test.", "response": "def _complete_cases(self, text, line, istart, iend):\n        \"\"\"Returns the completion list of possible test cases for the active unit test.\"\"\"\n        if text == \"\":\n            return list(self.live.keys())\n        else:\n            return [c for c in self.live if c.startswith(text)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the value of the argument with the specified id using the passed in argument passed in from the shell session.", "response": "def _set_arg_generic(self, argid, arg, cast=str):\n        \"\"\"Sets the value of the argument with the specified id using the argument passed\n        in from the shell session.\n        \"\"\"\n        usable, filename, append = self._redirect_split(arg)\n        if usable != \"\":\n            self.curargs[argid] = cast(usable)\n        if argid in self.curargs:\n            result = \"{}: '{}'\".format(argid.upper(), self.curargs[argid])\n            self._redirect_output(result, filename, append, msg.info)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_filter(self, arg):\n        if arg == \"list\":\n            msg.info(\"TEST CASE FILTERS\")\n            for f in self.curargs[\"tfilter\"]:\n                if f == \"*\":\n                    msg.info(\"  * (default, matches all)\")\n                else:\n                    msg.info(\"  \" + f)\n        elif arg not in self.curargs[\"tfilter\"]:\n            self.curargs[\"tfilter\"].append(arg)\n            self.do_filter(\"list\")", "response": "Sets the filter for the test cases to include in the plot or table by name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the test case filter that limits which results are included in plots / tables.", "response": "def do_rmfilter(self, arg):\n        \"\"\"Removes the test case filter that limits which results are included in plots/tables.\n        \"\"\"\n        if arg in self.curargs[\"tfilter\"]:\n            if arg == \"*\":\n                msg.warn(\"The default filter cannot be removed.\")\n            else:\n                self.curargs[\"tfilter\"].remove(arg)\n                self.do_filter(\"list\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate the only of the specified variable.", "response": "def _validate_var(self, var):\n        \"\"\"Validates the *form* only of the specified variable.\"\"\"\n        if \"/\" in var:\n            filt, rest = var.split(\"/\")\n            if \"|\" in rest:\n                varname, prop = rest.split(\"|\")\n                return prop != \"\"\n            elif rest == \"timing\":\n                return True\n            else:\n                return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the name and attribute of the independent variable for plotting / tabulating functions.", "response": "def do_indep(self, arg):\n        \"\"\"Sets the name and attribute of the independent variable for plotting/tabulating functions.\"\"\"\n        if not self._validate_var(arg):\n            msg.err(\"Variable {} is not a valid file name and property combination.\".format(arg))\n        else:\n            self.curargs[\"independent\"] = arg"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the name and attribute of a dependent variable to the list for plotting and tabulating functions.", "response": "def do_dep(self, args):\n        \"\"\"Adds the name and attribute of a dependent variable to the list \n        for plotting/tabulating functions.\"\"\"\n        vals = args.split()\n        twin = None\n        if len(vals) > 1:\n            if len(vals) == 2:\n                var, plot = vals\n            elif len(vals) == 3:\n                var, plot, twin = vals\n        else:\n            var = vals[0]\n            plot = None\n\n        if not self._validate_var(var):\n            msg.err(\"Variable {} is not a valid file name and property combination.\".format(var))\n        else:\n            if var in self.curargs[\"dependents\"]:\n                self.curargs[\"dependents\"].remove(var)\n            self.curargs[\"dependents\"].append(var)\n            if plot is not None:\n                self.curargs[\"plottypes\"][var] = plot\n            if twin is not None:\n                self.curargs[\"twinplots\"][var] = twin"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving dependent variables currently set for plotting or tabulating etc.", "response": "def do_rmdep(self, args):\n        \"\"\"Removes dependent variables currently set for plotting/tabulating etc.\"\"\"\n        for arg in args.split():\n            if arg in self.curargs[\"dependents\"]:\n                self.curargs[\"dependents\"].remove(arg)\n            if arg in self.curargs[\"plottypes\"]:\n                del self.curargs[\"plottypes\"][arg]\n            if arg in self.curargs[\"twinplots\"]:\n                del self.curargs[\"twinplots\"][arg]\n            if arg in self.curargs[\"colors\"]:\n                del self.curargs[\"colors\"][arg]\n            if arg in self.curargs[\"labels\"]:\n                del self.curargs[\"labels\"][arg]\n            if arg in self.curargs[\"markers\"]:\n                del self.curargs[\"markers\"][arg]\n            if arg in self.curargs[\"lines\"]:\n                del self.curargs[\"lines\"][arg]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting a dictionary that has variable => value mappings.", "response": "def _print_map_dict(self, argkey, filename, append):\n        \"\"\"Prints a dictionary that has variable => value mappings.\"\"\"\n        result = []\n        skeys = list(sorted(self.curargs[argkey].keys()))\n        for key in skeys:\n            result.append(\"'{}' => {}\".format(key, self.curargs[argkey][key]))\n        self._redirect_output('\\n'.join(result), filename, append, msg.info)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the function to apply to the values of a specific variable before plotting or tabulating values.", "response": "def do_postfix(self, arg):\n        \"\"\"Sets the function to apply to the values of a specific variable before plotting\n        or tabulating values.\n        \"\"\"\n        usable, filename, append = self._redirect_split(arg)\n        sargs = usable.split()\n        if len(sargs) == 1 and sargs[0] == \"list\":\n            self._print_map_dict(\"functions\", filename, append)\n        elif len(sargs) >= 2:\n            defvars = self._postfix_varlist(\"postfix \" + arg)\n            for var in defvars.values():\n                if not self._validate_var(var):\n                    msg.err(\"Variable '{}' is not a valid variable|property combination.\")\n                    return\n\n            fxn = arg.split()[-1]\n            if \":\" not in fxn:\n                msg.err(\"{} is not a valid postfix function expression.\")\n                self.help_postfix()\n                return\n\n            modvar = fxn.split(\":\")[0]\n            if modvar not in defvars:\n                msg.err(\"Invalid postfix function: variable '{}' not defined.\".format(modvar))\n                return\n            \n            defvars[\"lambda\"] = fxn\n            self.curargs[\"functions\"][defvars[modvar]] = defvars\n            #Give the user some feedback so that they know it was successful.\n            self.do_postfix(\"list\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _postfix_varlist(self, line):\n        els = line.split()\n        result = {}\n        if len(els) >= 2:\n            defvars = [v for v in els if \"=\" in v]\n            varlist = []\n            for dvar in defvars:\n                gvar, lvar = dvar.split(\"=\")\n                if lvar != \"\":\n                    result[lvar] = gvar\n        return result", "response": "Returns a dictionary of the global variable names ( keys ) and their local \n        name for the lambda function."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_rmpostfix(self, arg):\n        altered = False\n        if arg in self.curargs[\"functions\"]:\n            del self.curargs[\"functions\"][arg]\n            altered = True\n        elif arg == \"*\":\n            for varname in list(self.curargs[\"functions\"].keys()):\n                del self.curargs[\"functions\"][varname]\n            altered = True\n        if altered:\n            self.do_postfix(\"list\")", "response": "Removes a postfix function from a variable. See postfix."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_rmfit(self, arg):\n        if arg in self.curargs[\"fits\"]:\n            del self.curargs[\"fits\"][arg]        \n        #We also need to remove the variable entry if it exists.\n        if \"timing\" in arg:\n            fitvar = \"{}|fit\".format(arg)\n        else:\n            fitvar = \"{}.fit\".format(arg)\n        if fitvar in self.curargs[\"dependents\"]:\n            self.curargs[\"dependents\"].remove(fitvar)", "response": "Removes a fit function from a variable. See fit."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_matplot_dict(self, option, prop, defdict):\n        cargs = self.curargs[option]\n        result = cargs.copy()\n        for varname in cargs:\n            if prop in cargs[varname]:\n                name = cargs[varname][prop]\n                for key, val in list(defdict.items()):\n                    if val == name:\n                        cargs[varname][prop] = key\n                        break\n\n        return result", "response": "Returns a copy of the settings dictionary for the specified option in \n        curargs with update values where the value is replaced by the key from \n        the relevant default dictionary whose keys should be used when values match."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nplotting the current state of the shell saving the value to the specified file.", "response": "def _plot_generic(self, filename=None):\n        \"\"\"Plots the current state of the shell, saving the value to the specified file\n        if specified.\n        \"\"\"\n        #Since the filename is being passed directly from the argument, check its validity.\n        if filename == \"\":\n            filename = None\n\n        if \"x\" not in self.curargs[\"labels\"]:\n            #Set a default x-label since we know what variable is being plotted.\n            self.curargs[\"labels\"][\"x\"] = \"Value of '{}' (unknown units)\".format(self.curargs[\"independent\"])\n        args = self.curargs\n        a = self.tests[self.active]\n        self._make_fits()\n        \n        #Before we can pass the markers in, we need to translate from keys to values so\n        #that matplotlib understands.\n        markdict = self._get_matplot_dict(\"markers\", \"marker\", self._possible_markers)\n        linedict = self._get_matplot_dict(\"lines\", \"style\", self._possible_linestyles)\n\n        #Set the remaining arguments to have the right keyword name.\n        args[\"savefile\"] = filename\n        args[\"markers\"] = markdict\n        args[\"lines\"] = linedict\n        \n        a.plot(**args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the current state of the shell s independent vs. dependent variables on the same set of axes. Give filename to save to as argument.", "response": "def do_plot(self, arg):\n        \"\"\"Plots the current state of the shell's independent vs. dependent variables on the\n        same set of axes. Give filename to save to as argument or leave blank to show.\n        \"\"\"\n        usable, filename, append = self._redirect_split(arg)\n        self.curargs[\"xscale\"] = None\n        self.curargs[\"yscale\"] = None\n        self._plot_generic(filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the default prompt to match the currently active unit test.", "response": "def _set_def_prompt(self):\n        \"\"\"Sets the default prompt to match the currently active unit test.\"\"\"\n        if len(self.active) > 15:\n            ids = self.active.split(\".\")\n            if len(ids) > 2:\n                module, executable, compiler = ids\n            else:\n                module, executable = ids\n                compiler = \"g\"\n            self.prompt = \"({}*.{}*.{}:{})\".format(module[0:6], executable[0:6], compiler, self.group)\n        else:\n            self.prompt = \"({}:{})\".format(self.active, self.group)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the specified module. executable to be the active test result to interact with.", "response": "def do_set(self, arg):\n        \"\"\"Sets the specified 'module.executable' to be the active test result to interact with.\n        \"\"\"\n        if arg in self.tests:\n            self.active = arg\n            #Create a default argument set and analysis group for the current plotting\n            if arg not in self.args:\n                self.args[arg] = {\"default\": dict(self._template_args)}\n                self.group = \"default\"\n            else:\n                self.group = list(self.curargs.keys())[0]\n                \n            #Change the prompt so that they know which unit test is being edited.\n            self._set_def_prompt()\n        else:\n            msg.err(\"The test case '{}' is not valid.\".format(arg))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef do_save(self, arg):\n        #We need to save the full paths to the staging directories for the tests that are loaded\n        #so far; then when the session is restored, we can reparse the results.\n        from os import path\n        import json\n        fullpath = path.expanduser(arg)\n\n        data = {\n            \"tests\": [path.abspath(a.stagedir) for a in list(self.tests.values())],\n            \"args\": self.args\n        }\n\n        with open(fullpath, 'w') as f:\n            json.dump(data, f)\n        msg.okay(\"Saved current session to {}\".format(fullpath))", "response": "Saves the current session variables to a file so that the same analysis can be continued later."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a saved session variables settings and test results to the shell.", "response": "def do_load(self, arg):\n        \"\"\"Loads a saved session variables, settings and test results to the shell.\"\"\"\n        from os import path\n        import json\n        fullpath = path.expanduser(arg)\n        if path.isfile(fullpath):\n            with open(fullpath) as f:\n                data = json.load(f)\n\n            #Now, reparse the staging directories that were present in the saved session.\n            for stagepath in data[\"tests\"]:\n                self.do_parse(stagepath)\n            self.args = data[\"args\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_parse(self, arg, fullparse=False):\n        from os import path\n        fullpath = path.abspath(path.expanduser(arg))\n        if path.isdir(fullpath):\n            if fullpath[-1] == \"/\":\n                end = -2\n            else:\n                end = -1\n            case = fullpath.split(\"/\")[end]\n            self.tests[case] = Analysis(fullpath, fullparse)\n            self.do_set(case)\n        else:\n            msg.err(\"The folder {} does not exist.\".format(fullpath))", "response": "Parse the test results from the specified directory and load them under the name\n        of module. executable that they were created with the parse method."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_group(self, arg):\n        from copy import deepcopy\n        vals = arg.split()\n        if len(vals) == 0 or vals[0] not in [\"list\", \"duplicate\", \"add\", \"switch\", \"remove\"]:\n            self.help_group()\n            return\n\n        if vals[0] == \"add\":\n            if vals[1] not in self.args[self.active]:\n                self.args[self.active][vals[1]] = self._template_args.copy()\n                msg.okay(\"Created analysis group '{}'.\".format(vals[1]))\n                self.do_group(\"switch {}\".format(vals[1]))\n            else:\n                msg.info(\"Group '{}' already exists. Switching to it.\".format(vals[1]))\n                self.do_group(\"switch {}\".format(vals[1]))\n        elif vals[0] == \"switch\":\n            if vals[1] in self.args[self.active]:\n                self.group = vals[1]\n                self._set_def_prompt()\n            else:\n                msg.warn(\"The group '{}' does not exist.\".format(vals[1]))\n        elif vals[0] == \"duplicate\" and len(vals) == 3 and vals[1] in self.args[self.active]:\n            self.args[self.active][vals[2]] = deepcopy(self.args[self.active][vals[1]])\n            msg.okay(\"Duplicated analysis group '{}' into '{}'.\".format(vals[1], vals[2]))\n            self.do_group(\"switch {}\".format(vals[2]))\n        elif vals[0] == \"list\":\n            for key in self.args[self.active]:\n                msg.info(key)\n        elif vals[0] == \"remove\" and vals[1] in self.args[self.active]:\n            del self.args[self.active][vals[1]]\n            self.do_group(\"list\")", "response": "Creates a new analysis group with unique settings for plotting or tabulating etc."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate the data fits for any variables set for fitting in the shell.", "response": "def _make_fits(self):\n        \"\"\"Generates the data fits for any variables set for fitting in the shell.\"\"\"\n        a = self.tests[self.active]\n        args = self.curargs\n        #We need to generate a fit for the data if there are any fits specified.\n        if len(args[\"fits\"]) > 0:\n            for fit in list(args[\"fits\"].keys()):\n                a.fit(args[\"independent\"], fit, args[\"fits\"][fit], args[\"threshold\"], args[\"functions\"])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting the set of values for the independent vs. dependent variables in the active unit test and analysis group as a table.", "response": "def do_table(self, arg):\n        \"\"\"Prints the set of values for the independent vs. dependent variables in the\n        active unit test and analysis group as a table.\n        \"\"\"\n        usable, filename, append = self._redirect_split(arg)\n        a = self.tests[self.active]\n        args = self.curargs\n        self._make_fits()\n        result = a.table(args[\"independent\"], args[\"dependents\"], args[\"threshold\"],\n                         args[\"headings\"], args[\"functions\"])\n        if result is not None:\n            self._redirect_output(result, filename, append, msg.info)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_failures(self, arg):\n        usable, filename, append = self._redirect_split(arg)\n        a = self.tests[self.active]\n        args = self.curargs\n        splitargs = usable.split()\n        if len(splitargs) > 0:\n            tfilter = splitargs[0]\n        else:\n            tfilter = \"*\"\n\n        outfiles = None\n        if len(splitargs) > 1:\n            outfiles = splitargs[1:len(splitargs)]\n\n        result = a.failures(outfiles, args[\"threshold\"], tfilter)\n        self._redirect_output(result, filename, append, msg.info)", "response": "Prints a list of test cases that failed for the current unit test and analysis\n        group settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nopens a unit test case s. out. compare file to examine the verbose comparison report across values.", "response": "def do_examine(self, arg):\n        \"\"\"Opens a unit test case's .out.compare file to examine the verbose comparison\n        report across values.\n        \"\"\"\n        #We use their default editor (if it has been set); otherwise we can't do much of\n        #anything and issue a warning.\n        from os import getenv, path, system\n        testcase, output = arg.split()\n        target = path.join(self.tests[self.active].stagedir, \"tests\", testcase, \n                           \"{}.compare\".format(output))\n        if getenv(\"EDITOR\") is not None:\n            system(\"`$EDITOR {}`\".format(target))\n        else:\n            msg.warn(\"$EDITOR not set in environment. Can't open {}\".format(target))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the full path to the console history file.", "response": "def histpath(self):\n        \"\"\"Returns the full path to the console history file.\"\"\"\n        from os import path\n        from fortpy import settings\n        return path.join(settings.cache_directory, \"history\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstores the information about the last unhandled exception.", "response": "def _store_lasterr(self):\n        \"\"\"Stores the information about the last unhandled exception.\"\"\"\n        from sys import exc_info\n        from traceback import format_exception\n        e = exc_info()\n        self.lasterr = '\\n'.join(format_exception(e[0], e[1], e[2]))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking sure that the command specified in the line is valid given the current status of loaded unit tests and analysis group.", "response": "def precmd(self, line):\n        \"\"\"Makes sure that the command specified in the line is valid given the current\n        status of loaded unit tests and analysis group.\n        \"\"\"\n        if line == \"\":\n            return \"\"\n        command = line.split()[0]\n        if \"!\" in command:\n            value = command.split(\"!\")[1]\n            try:\n                ihist = int(value)\n                import readline\n                if ihist <= readline.get_current_history_length():\n                    return readline.get_history_item(ihist)\n                else:\n                    msg.warn(\"The specified history item {} \".format(ihist) + \n                             \"does not exist in the history.\")\n                    return \"\"\n            except ValueError:\n                #This clearly isn't a bash style recursion of a past history item.\n                #Just run the command as it was originally entered.\n                return line\n        else:\n            if command in self._test_cmds or command in self._group_cmds:\n                #We have to test the active unit test for both the test commands and the\n                #group commands, since the group commands rely on the active unit test.\n                if self.active is None or self.active not in self.tests:\n                    msg.err(\"The specified command '{}' requires an \".format(command) + \n                            \"active unit test to be loaded. Use 'parse' or 'load'.\")\n                    return \"\"\n                elif (command in self._group_cmds and (self.group is None or \n                                                       self.group not in self.args[self.active])):\n                    msg.err(\"No valid analysis group is active. Use 'group' to create \" \n                            \"one or mark an existing one as active.\")\n                    return \"\"\n                else:\n                    return line\n\n            if command in self._var_cmds:\n                #We need to make sure that we have variables set.\n                if self.curargs[\"independent\"] is None or len(self.curargs[\"dependents\"]) == 0:\n                    msg.err(\"This command requires an independent variable to be set and \"\n                            \"at least one dependent variable.\\n See 'dep' and 'indep' commands.\")\n                    return \"\"\n                else:\n                    return line\n            else:\n                return line"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_cd(self, arg):\n        from os import chdir, path\n        fullpath = path.abspath(path.expanduser(arg))\n        if path.isdir(fullpath):\n            chdir(fullpath)\n        else:\n            msg.err(\"'{}' is not a valid directory.\".format(arg))", "response": "Imitates the bash shell cd command."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_fontsave(self, arg):\n        #We need to save the full paths to the staging directories for the tests that are loaded\n        #so far; then when the session is restored, we can reparse the results.\n        from os import path\n        import json\n        fullpath = path.expanduser(arg)\n        data = {\n            \"fonts\": self.curargs[\"fonts\"],\n            \"ticks\": self.curargs[\"ticks\"]\n        }\n        with open(fullpath, 'w') as f:\n            json.dump(data, f)\n        msg.okay(\"Saved current font settings to {}\".format(fullpath))", "response": "Saves the current font settings to a file so that the same analysis can be continued later."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates branches with alternative system.", "response": "def generate_branches(scales=None, angles=None, shift_angle=0):\n    \"\"\"Generates branches with alternative system.\n\n    Args:\n        scales (tuple/array): Indicating how the branch/es length/es develop/s from age to age.\n        angles (tuple/array): Holding the branch and shift angle in radians.\n        shift_angle (float): Holding the rotation angle for all branches.\n\n    Returns:\n        branches (2d-array): A array constits of arrays holding scale and angle for every branch.\n    \"\"\"\n    branches = []\n    for pos, scale in enumerate(scales):\n        angle = -sum(angles)/2 + sum(angles[:pos]) + shift_angle\n        branches.append([scale, angle])\n    return branches"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_rectangle(self):\n        rec = [self.pos[0], self.pos[1]]*2\n        for age in self.nodes:\n            for node in age:\n                # Check max/min for x/y coords\n                for i in range(2):\n                    if rec[0+i] > node.pos[i]:\n                        rec[0+i] = node.pos[i]\n                    elif rec[2+i] < node.pos[i]:\n                        rec[2+i] = node.pos[i]\n        return tuple(rec)", "response": "Gets the coordinates of the rectangle in which the tree can be put."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the size of the tree.", "response": "def get_size(self):\n        \"\"\"Get the size of the tree.\n\n        Returns:\n            tupel: (width, height)\n        \"\"\"\n        rec = self.get_rectangle()\n        return (int(rec[2]-rec[0]), int(rec[3]-rec[1]))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_branch_length(self, age=None, pos=0):\n        if age is None:\n            age = self.age\n\n        return self.length * pow(self.branches[pos][0], age)", "response": "This method calculates the length of a branch in specific age."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets how much steps needed for a given branch length.", "response": "def get_steps_branch_len(self, length):\n        \"\"\"Get, how much steps will needed for a given branch length.\n\n        Returns:\n            float: The age the tree must achieve to reach the given branch length.\n        \"\"\"\n        return log(length/self.length, min(self.branches[0][0]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the sum of all branches in the tree.", "response": "def get_node_sum(self, age=None):\n        \"\"\"Get sum of all branches in the tree.\n\n        Returns:\n            int: The sum of all nodes grown until the age.\n        \"\"\"\n        if age is None:\n            age = self.age\n\n        return age if self.comp == 1 else int((pow(self.comp, age+1) - 1) / (self.comp - 1))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the sum of branches grown in a specific age.", "response": "def get_node_age_sum(self, age=None):\n        \"\"\"Get the sum of branches grown in an specific age.\n\n        Returns:\n            int: The sum of all nodes grown in an age.\n        \"\"\"\n        if age is None:\n            age = self.age\n\n        return pow(self.comp, age)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_nodes(self):\n        nodes = []\n        for age, level in enumerate(self.nodes):\n            nodes.append([])\n            for node in level:\n                nodes[age].append(node.get_tuple())\n        return nodes", "response": "Get the tree nodes as list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_branches(self):\n        branches = []\n        for age, level in enumerate(self.nodes):\n            branches.append([])\n            for n, node in enumerate(level):\n                if age == 0:\n                    p_node = Node(self.pos[:2])\n                else:\n                    p_node = self._get_node_parent(age-1, n)\n                branches[age].append(p_node.get_tuple() + node.get_tuple())\n\n        return branches", "response": "Get the tree branches as list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef move(self, delta):\n        pos = self.pos\n        self.pos = (pos[0]+delta[0], pos[1]+delta[1], pos[2]+delta[0], pos[3]+delta[1])\n\n        # Move all nodes\n        for age in self.nodes:\n            for node in age:\n                node.move(delta)", "response": "Move the tree.\n\n        Args:\n            delta (tupel): The adjustment of the position."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nletting the tree grow. Args: times (integer): Indicate how many times the tree will grow.", "response": "def grow(self, times=1):\n        \"\"\"Let the tree grow.\n\n        Args:\n            times (integer): Indicate how many times the tree will grow.\n        \"\"\"\n        self.nodes.append([])\n\n        for n, node in enumerate(self.nodes[self.age]):\n            if self.age == 0:\n                p_node = Node(self.pos[:2])\n            else:\n                p_node = self._get_node_parent(self.age-1, n)\n            angle = node.get_node_angle(p_node)\n            for i in range(self.comp):\n                tot_angle = self.__get_total_angle(angle, i)\n                length = self.__get_total_length(self.age+1, i)\n                self.nodes[self.age+1].append(node.make_new_node(length, tot_angle))\n\n        self.age += 1\n\n        if times > 1:\n            self.grow(times-1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndraws the tree on a canvas.", "response": "def draw_on(self, canvas, stem_color, leaf_color, thickness, ages=None):\n        \"\"\"Draw the tree on a canvas.\n\n        Args:\n            canvas (object): The canvas, you want to draw the tree on. Supported canvases: svgwrite.Drawing and PIL.Image (You can also add your custom libraries.)\n            stem_color (tupel): Color or gradient for the stem of the tree.\n            leaf_color (tupel): Color for the leaf (= the color for last iteration).\n            thickness (int): The start thickness of the tree.\n        \"\"\"\n        if canvas.__module__ in SUPPORTED_CANVAS:\n            drawer = SUPPORTED_CANVAS[canvas.__module__]\n            drawer(self, canvas, stem_color, leaf_color, thickness, ages).draw()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __get_total_angle(self, angle, pos):\n        tot_angle = angle - self.branches[pos][1]\n        if self.sigma[1] != 0:\n            tot_angle += gauss(0, self.sigma[1]) * pi\n        return tot_angle", "response": "Get the total angle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the parent node of node whch is located in tree s node list.", "response": "def _get_node_parent(self, age, pos):\n        \"\"\"Get the parent node of node, whch is located in tree's node list.\n\n        Returns:\n            object: The parent node.\n        \"\"\"\n        return self.nodes[age][int(pos / self.comp)]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _field_lookups(model, status=None):\n    # Import models here to avoid circular import fail.\n    from faq.models import Topic, Question\n\n    field_lookups = {}\n\n    if model == Topic:\n        field_lookups['sites__pk'] = settings.SITE_ID\n\n    if model == Question:\n        field_lookups['topic__sites__pk'] = settings.SITE_ID\n        if status:\n            field_lookups['topic__status'] = status\n\n    # Both Topic & Question have a status field.\n    if status:\n        field_lookups['status'] = status\n\n    return field_lookups", "response": "Returns a dictionary of field lookups for a given model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the static symbol for the specified module and method.", "response": "def static_symbol(module, method, lib, bindc=False):\n    \"\"\"Returns the symbol for the specified *fortran* module and subroutine/function\n    that has been compiled into a shared library.\n\n    :arg lib: the full path to the shared library *.so file.\n    \"\"\"\n    from os import path\n    from numpy.ctypeslib import load_library\n    libpath = path.abspath(lib)\n    libkey = libpath.lower()\n\n    if libkey not in compilers:\n        compilers[libkey] = detect_compiler(libpath)\n        if compilers[libkey] == False:\n            raise ValueError(\"Couldn't auto-detect the compiler for {}\".format(libpath))\n    compiler = compilers[libkey]\n\n    if libkey not in libs:\n        libs[libkey] = load_library(libpath, \"\")\n        if not libs[libkey]:\n            raise ValueError(\"Couldn't auto-load the shared library with ctypes.\")\n    slib = libs[libkey]\n    \n    identifier = \"{}.{}\".format(module, method)\n    if bindc:\n        symbol = method\n    elif compiler == \"gfortran\":\n        symbol = \"__\" + identifier.lower().replace(\".\", \"_MOD_\")\n    else:\n        #We assume the only other option is ifort.\n        symbol = identifier.lower().replace(\".\", \"_mp_\") + \"_\"\n\n    if hasattr(slib, symbol):\n        return getattr(slib, symbol)\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef detect_compiler(libpath):\n    from os import waitpid, path\n    from subprocess import Popen, PIPE\n    command = \"nm {0}\".format(path.abspath(libpath))\n    child = Popen(command, shell=True, executable=\"/bin/bash\", stdout=PIPE)\n    # Need to do this so that we are sure the process is done before moving on\n    waitpid(child.pid, 0)\n    contents = child.stdout.readlines()\n    i = 0\n    found = False\n    while i < len(contents) and found == False:\n        if \"_MOD_\" in contents[i]:\n            found = \"gfortran\"\n        elif \"_mp_\" in contents[i]:\n            found = \"ifort\"\n        i += 1\n\n    return found", "response": "Determines the compiler used to compile the specified shared library by using the system utilities."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean(self):\n        if not self.deallocated:\n            #Release/deallocate the pointer in fortran.\n            method = self._deallocator()\n            if method is not None:\n                dealloc = static_symbol(\"ftypes_dealloc\", method, self.libpath, True)\n                if dealloc is None:\n                    return\n                arrtype = ndpointer(dtype=int, ndim=1, shape=(len(self.indices),), flags=\"F\")\n                dealloc.argtypes = [c_void_p, c_int_p, arrtype]\n                nindices = require(array([i.value for i in self.indices]), int, \"F\")\n                dealloc(byref(self.pointer), c_int(len(self.indices)), nindices)\n\n        self.deallocated = True", "response": "Deallocates the fortran - managed memory that this ctype references."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the name of the subroutine in ftypes_dealloc. f90 that can deallocate the array for this Ftype s pointer.", "response": "def _deallocator(self):\n        \"\"\"Returns the name of the subroutine in ftypes_dealloc.f90 that can\n        deallocate the array for this Ftype's pointer.\n\n        :arg ctype: the string c-type of the variable.\n        \"\"\"\n        lookup = {\n            \"c_bool\": \"logical\",\n            \"c_double\": \"double\",\n            \"c_double_complex\": \"complex\",\n            \"c_char\": \"char\",\n            \"c_int\": \"int\",\n            \"c_float\": \"float\",\n            \"c_short\": \"short\",\n            \"c_long\": \"long\"            \n        }\n        ctype = type(self.pointer).__name__.replace(\"LP_\", \"\").lower()\n        if ctype in lookup:\n            return \"dealloc_{0}_{1:d}d\".format(lookup[ctype], len(self.indices))\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cleanup(self):\n        #First we *copy* the arrays that we currently have pointers to. This is not\n        #the optimal solution; however, because of limitations in ctypes, we don't\n        #know anything better at the moment.\n        for key in self.result:\n            self.result[key] = self.result[key].copy()\n\n        #Now deallocate the pointers managed by Fortran in the shared library so that\n        #any subsequent calls to the executable that generated this result creates\n        #new instances in memory.\n        for key in list(self._finalizers.keys()):\n            self._finalizers[key].clean()", "response": "Cleans up this result so that all its pointers reference memory controlled\n        and the associated Fortran executable loaded with ctypes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the specified python - typed result and an optional Ftype pointer to use when cleaning up this object.", "response": "def add(self, varname, result, pointer=None):\n        \"\"\"Adds the specified python-typed result and an optional Ftype pointer\n        to use when cleaning up this object.\n\n        :arg result: a python-typed representation of the result.\n        :arg pointer: an instance of Ftype with pointer information for deallocating\n          the c-pointer.\n        \"\"\"\n        self.result[varname] = result\n        setattr(self, varname, result)\n        if pointer is not None:\n            self._finalizers[varname] = pointer"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_entry_media_attributes(self, soup):\n    row_info = {}\n\n    try:\n      start = utilities.parse_profile_date(soup.find('series_start').text)\n    except ValueError:\n      start = None\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    if start is not None:\n      try:\n        row_info['aired'] = (start, utilities.parse_profile_date(soup.find('series_end').text))\n      except ValueError:\n        row_info['aired'] = (start, None)\n      except:\n        if not self.session.suppress_parse_exceptions:\n          raise\n\n    # look up the given media type's status terms.\n    status_terms = getattr(self.session, self.type)(1)._status_terms\n\n    try:\n      row_info['id'] = int(soup.find('series_' + self.type + 'db_id').text)\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      row_info['title'] = soup.find('series_title').text\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      row_info['status'] = status_terms[int(soup.find('series_status').text)]\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      row_info['picture'] = soup.find('series_image').text\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return row_info", "response": "Parses the media list row from the given soup and returns a dict of attributes of the media list row."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a single entry from the current media list and returns a tuple containing the media object and the dictionary of attributes of this row.", "response": "def parse_entry(self, soup):\n    \"\"\"\n      Given:\n        soup: a bs4 element containing a row from the current media list\n\n      Return a tuple:\n        (media object, dict of this row's parseable attributes)\n    \"\"\"\n    # parse the media object first.\n    media_attrs = self.parse_entry_media_attributes(soup)\n    media_id = media_attrs[u'id']\n    del media_attrs[u'id']\n    media = getattr(self.session, self.type)(media_id).set(media_attrs)\n\n    entry_info = {}\n    try:\n      entry_info[u'started'] = utilities.parse_profile_date(soup.find(u'my_start_date').text)\n    except ValueError:\n      entry_info[u'started'] = None\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      entry_info[u'finished'] = utilities.parse_profile_date(soup.find(u'my_finish_date').text)\n    except ValueError:\n      entry_info[u'finished'] = None\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      entry_info[u'status'] = self.user_status_terms[int(soup.find(u'my_status').text)]\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      entry_info[u'score'] = int(soup.find(u'my_score').text)\n      # if user hasn't set a score, set it to None to indicate as such.\n      if entry_info[u'score'] == 0:\n        entry_info[u'score'] = None\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      entry_info[u'last_updated'] = datetime.datetime.fromtimestamp(int(soup.find(u'my_last_updated').text))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return media,entry_info"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the stats of the current media list.", "response": "def parse_stats(self, soup):\n    \"\"\"\n      Given:\n        soup: a bs4 element containing the current media list's stats\n        \n      Return a dict of this media list's stats.\n    \"\"\"\n    stats = {}\n    for row in soup.children:\n      try:\n        key = row.name.replace(u'user_', u'')\n        if key == u'id':\n          stats[key] = int(row.text)\n        elif key == u'name':\n          stats[key] = row.text\n        elif key == self.verb + u'ing':\n          try:\n            stats[key] = int(row.text)\n          except ValueError:\n            stats[key] = 0\n        elif key == u'completed':\n          try:\n            stats[key] = int(row.text)\n          except ValueError:\n            stats[key] = 0\n        elif key == u'onhold':\n          try:\n            stats['on_hold'] = int(row.text)\n          except ValueError:\n            stats[key] = 0\n        elif key == u'dropped':\n          try:\n            stats[key] = int(row.text)\n          except ValueError:\n            stats[key] = 0\n        elif key == u'planto' + self.verb:\n          try:\n            stats[u'plan_to_' + self.verb] = int(row.text)\n          except ValueError:\n            stats[key] = 0\n        # for some reason, MAL doesn't substitute 'read' in for manga for the verb here\n        elif key == u'days_spent_watching':\n          try:\n            stats[u'days_spent'] = decimal.Decimal(row.text)\n          except decimal.InvalidOperation:\n            stats[key] = decimal.Decimal(0)\n      except:\n        if not self.session.suppress_parse_exceptions:\n          raise\n    return stats"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a python module from string", "response": "def load_python_object(name):\n    \"\"\"\n    Loads a python module from string\n    \"\"\"\n    logger = getLoggerWithNullHandler('commando.load_python_object')\n    (module_name, _, object_name) = name.rpartition(\".\")\n    if module_name == '':\n        (module_name, object_name) = (object_name, module_name)\n    try:\n        logger.debug('Loading module [%s]' % module_name)\n        module = __import__(module_name)\n    except ImportError:\n        raise CommandoLoaderException(\n                \"Module [%s] cannot be loaded.\" % module_name)\n\n    if object_name == '':\n        return module\n\n    try:\n        module = sys.modules[module_name]\n    except KeyError:\n        raise CommandoLoaderException(\n                \"Error occured when loading module [%s]\" % module_name)\n\n    try:\n        logger.debug('Getting object [%s] from module [%s]' %\n                     (object_name, module_name))\n        return getattr(module, object_name)\n    except AttributeError:\n        raise CommandoLoaderException(\n                \"Cannot load object [%s]. \"\n                \"Module [%s] does not contain object [%s]. \"\n                \"Please fix the configuration or \"\n                \"ensure that the module is installed properly\" % (\n                    name,\n                    module_name,\n                    object_name))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a logger object with a pre - initialized console handler.", "response": "def getLoggerWithConsoleHandler(logger_name=None):\n    \"\"\"\n    Gets a logger object with a pre-initialized console handler.\n    \"\"\"\n    logger = logging.getLogger(logger_name)\n    logger.setLevel(logging.INFO)\n    if not logger.handlers:\n        handler = logging.StreamHandler(sys.stdout)\n        if sys.platform == 'win32':\n            formatter = logging.Formatter(\n                            fmt=\"%(asctime)s %(name)s %(message)s\",\n                            datefmt='%H:%M:%S')\n        else:\n            formatter = ColorFormatter(fmt=\"$RESET %(asctime)s \"\n                                       \"$BOLD$COLOR%(name)s$RESET \"\n                                       \"%(message)s\", datefmt='%H:%M:%S')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getLoggerWithNullHandler(logger_name):\n    logger = logging.getLogger(logger_name)\n    if not logger.handlers:\n        logger.addHandler(NullHandler())\n    return logger", "response": "Gets the logger initialized with the logger_name and a NullHandler."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelegate to subprocess. check_call.", "response": "def call(self, *args, **kwargs):\n        \"\"\"\n        Delegates to `subprocess.check_call`.\n        \"\"\"\n        args, kwargs = self.__process__(*args, **kwargs)\n        return check_call(args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, *args, **kwargs):\n        args, kwargs = self.__process__(*args, **kwargs)\n        return check_output(args, **kwargs)", "response": "Delegates to subprocess. check_output."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelegate to subprocess. Popen.", "response": "def open(self, *args, **kwargs):\n        \"\"\"\n        Delegates to `subprocess.Popen`.\n        \"\"\"\n        args, kwargs = self.__process__(*args, **kwargs)\n        return Popen(args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a view used to render a tag after the page has loaded.", "response": "def tag(request, tag_id=None):\n    \"\"\"\n    The view used to render a tag after the page has loaded.\n    \"\"\"\n    html = get_tag_html(tag_id)\n    t = template.Template(html)\n    c = template.RequestContext(request)\n\n    return HttpResponse(t.render(c))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_color(self, age):\n        if age == self.tree.age:\n            return self.leaf_color\n        color = self.stem_color\n        tree = self.tree\n\n        if len(color) == 3:\n            return color\n\n        diff = [color[i+3]-color[i] for i in range(3)]\n        per_age = [diff[i]/(tree.age-1) for i in range(3)]\n\n        return tuple([int(color[i]+per_age[i]*age) for i in range(3)])", "response": "Get the fill color depending on age."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndraw the tree. Args: ages (array): Contains the ages you want to draw.", "response": "def draw(self):\n        \"\"\"Draws the tree.\n\n        Args:\n            ages (array): Contains the ages you want to draw.\n        \"\"\"\n        for age, level in enumerate(self.tree.get_branches()):\n            if age in self.ages:\n                thickness = self._get_thickness(age)\n                color = self._get_color(age)\n                for branch in level:\n                    self._draw_branch(branch, color, thickness, age)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cmd_create(self):\n        assert self._message, \"need to supply a message for the \\\"create\\\" command\"\n        if not self._revisions:\n            self._revisions.append(\"1\")\n\n        # get the migration folder\n        rev_folder = self._revisions[-1]\n        full_rev_path = os.path.join(self._migration_path, rev_folder)\n        if not os.path.exists(full_rev_path):\n            os.mkdir(full_rev_path)\n        else:\n            count = len(glob.glob(os.path.join(full_rev_path, \"*\")))\n            # create next revision folder if needed\n            if count and self._rev and int(self._rev) == 0:\n                rev_folder = str(int(rev_folder) + 1)\n                full_rev_path = os.path.join(self._migration_path, rev_folder)\n                os.mkdir(full_rev_path)\n                self._revisions.append(rev_folder)\n\n        # format file name\n        filename = '_'.join([s.lower() for s in self._message.split(' ') if s.strip()])\n        for p in string.punctuation:\n            if p in filename:\n                filename = filename.replace(p, '_')\n        filename = \"%s_%s\" % (datetime.utcnow().strftime(\"%Y%m%d%H%M%S\"), filename.replace('__', '_'))\n\n        # create the migration files\n        self._log(0, \"creating files: \")\n        for s in ('up', 'down'):\n            file_path = os.path.join(full_rev_path, \"%s.%s.sql\" % (filename, s))\n            with open(file_path, 'a+') as w:\n                w.write('\\n'.join([\n                    '-- *** %s ***' % s.upper(),\n                    '-- file: %s' % os.path.join(rev_folder, filename),\n                    '-- comment: %s' % self._message]))\n                self._log(0, file_path)", "response": "Create a new migration in the current or new revision folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cmd_up(self):\n        revision = self._get_revision()\n        if not self._rev:\n            self._log(0, \"upgrading current revision\")\n        else:\n            self._log(0, \"upgrading from revision %s\" % revision)\n        for rev in self._revisions[int(revision) - 1:]:\n            sql_files = glob.glob(os.path.join(self._migration_path, rev, \"*.up.sql\"))\n            sql_files.sort()\n            self._exec(sql_files, rev)\n        self._log(0, \"done: upgraded revision to %s\\n\" % rev)", "response": "Upgrade to a revision"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _cmd_down(self):\n        revision = self._get_revision()\n        if not self._rev:\n            self._log(0, \"downgrading current revision\")\n        else:\n            self._log(0, \"downgrading to revision %s\" % revision)\n        # execute from latest to oldest revision\n        for rev in reversed(self._revisions[int(revision) - 1:]):\n            sql_files = glob.glob(os.path.join(self._migration_path, rev, \"*.down.sql\"))\n            sql_files.sort(reverse=True)\n            self._exec(sql_files, rev)\n        self._log(0, \"done: downgraded revision to %s\" % rev)", "response": "Downgrade to a revision"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_revision(self):\n        assert self._revisions, \"no migration revision exist\"\n        revision = self._rev or self._revisions[-1]\n        # revision count must be less or equal since revisions are ordered\n        assert revision in self._revisions, \"invalid revision specified\"\n        return revision", "response": "Validate and return the revision to use for current command\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef newest(cls, session):\n    media_type = cls.__name__.lower()\n    p = session.session.get(u'http://myanimelist.net/' + media_type + '.php?o=9&c[]=a&c[]=d&cv=2&w=1').text\n    soup = utilities.get_clean_dom(p)\n    latest_entry = soup.find(u\"div\", {u\"class\": u\"hoverinfo\"})\n    if not latest_entry:\n      raise MalformedMediaPageError(0, p, u\"No media entries found on recently-added page\")\n    latest_id = int(latest_entry[u'rel'][1:])\n    return getattr(session, media_type)(latest_id)", "response": "Fetches the newest media added to MAL."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the DOM and returns the media attributes in the sidebar.", "response": "def parse_sidebar(self, media_page):\n    \"\"\"Parses the DOM and returns media attributes in the sidebar.\n\n    :type media_page: :class:`bs4.BeautifulSoup`\n    :param media_page: MAL media page's DOM\n\n    :rtype: dict\n    :return: media attributes.\n\n    :raises: InvalidMediaError, MalformedMediaPageError\n\n    \"\"\"\n    media_info = {}\n\n    # if MAL says the series doesn't exist, raise an InvalidMediaError.\n    error_tag = media_page.find(u'div', {'class': 'badresult'})\n    if error_tag:\n        raise InvalidMediaError(self.id)\n\n    try:\n      title_tag = media_page.find(u'div', {'id': 'contentWrapper'}).find(u'h1')\n      if not title_tag.find(u'div'):\n        # otherwise, raise a MalformedMediaPageError.\n        raise MalformedMediaPageError(self.id, media_page, message=\"Could not find title div\")\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      utilities.extract_tags(title_tag.find_all())\n      media_info[u'title'] = title_tag.text.strip()\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    info_panel_first = media_page.find(u'div', {'id': 'content'}).find(u'table').find(u'td')\n\n    try:\n      picture_tag = info_panel_first.find(u'img')\n      media_info[u'picture'] = picture_tag.get(u'src').decode('utf-8')\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      # assemble alternative titles for this series.\n      media_info[u'alternative_titles'] = {}\n      alt_titles_header = info_panel_first.find(u'h2', text=u'Alternative Titles')\n      if alt_titles_header:\n        next_tag = alt_titles_header.find_next_sibling(u'div', {'class': 'spaceit_pad'})\n        while True:\n          if next_tag is None or not next_tag.find(u'span', {'class': 'dark_text'}):\n            # not a language node, break.\n            break\n          # get language and remove the node.\n          language = next_tag.find(u'span').text[:-1]\n          utilities.extract_tags(next_tag.find_all(u'span', {'class': 'dark_text'}))\n          names = next_tag.text.strip().split(u', ')\n          media_info[u'alternative_titles'][language] = names\n          next_tag = next_tag.find_next_sibling(u'div', {'class': 'spaceit_pad'})\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      type_tag = info_panel_first.find(text=u'Type:').parent.parent\n      utilities.extract_tags(type_tag.find_all(u'span', {'class': 'dark_text'}))\n      media_info[u'type'] = type_tag.text.strip()\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      status_tag = info_panel_first.find(text=u'Status:').parent.parent\n      utilities.extract_tags(status_tag.find_all(u'span', {'class': 'dark_text'}))\n      media_info[u'status'] = status_tag.text.strip()\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      genres_tag = info_panel_first.find(text=u'Genres:').parent.parent\n      utilities.extract_tags(genres_tag.find_all(u'span', {'class': 'dark_text'}))\n      media_info[u'genres'] = []\n      for genre_link in genres_tag.find_all('a'):\n        link_parts = genre_link.get('href').split('[]=')\n        # of the form /anime|manga.php?genre[]=1\n        genre = self.session.genre(int(link_parts[1])).set({'name': genre_link.text})\n        media_info[u'genres'].append(genre)\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      # grab statistics for this media.\n      score_tag = info_panel_first.find(text=u'Score:').parent.parent\n      # get score and number of users.\n      users_node = [x for x in score_tag.find_all(u'small') if u'scored by' in x.text][0]\n      num_users = int(users_node.text.split(u'scored by ')[-1].split(u' users')[0])\n      utilities.extract_tags(score_tag.find_all())\n      media_info[u'score'] = (decimal.Decimal(score_tag.text.strip()), num_users)\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      rank_tag = info_panel_first.find(text=u'Ranked:').parent.parent\n      utilities.extract_tags(rank_tag.find_all())\n      media_info[u'rank'] = int(rank_tag.text.strip()[1:].replace(u',', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      popularity_tag = info_panel_first.find(text=u'Popularity:').parent.parent\n      utilities.extract_tags(popularity_tag.find_all())\n      media_info[u'popularity'] = int(popularity_tag.text.strip()[1:].replace(u',', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      members_tag = info_panel_first.find(text=u'Members:').parent.parent\n      utilities.extract_tags(members_tag.find_all())\n      media_info[u'members'] = int(members_tag.text.strip().replace(u',', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      favorites_tag = info_panel_first.find(text=u'Favorites:').parent.parent\n      utilities.extract_tags(favorites_tag.find_all())\n      media_info[u'favorites'] = int(favorites_tag.text.strip().replace(u',', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      # get popular tags.\n      tags_header = media_page.find(u'h2', text=u'Popular Tags')\n      tags_tag = tags_header.find_next_sibling(u'span')\n      media_info[u'popular_tags'] = {}\n      for tag_link in tags_tag.find_all('a'):\n        tag = self.session.tag(tag_link.text)\n        num_people = int(re.match(r'(?P<people>[0-9]+) people', tag_link.get('title')).group('people'))\n        media_info[u'popular_tags'][tag] = num_people\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return media_info"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(self, media_page):\n    media_info = self.parse_sidebar(media_page)\n\n    try:\n      synopsis_elt = media_page.find(u'h2', text=u'Synopsis').parent\n      utilities.extract_tags(synopsis_elt.find_all(u'h2'))\n      media_info[u'synopsis'] = synopsis_elt.text.strip()\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      related_title = media_page.find(u'h2', text=u'Related ' + self.__class__.__name__)\n      if related_title:\n        related_elt = related_title.parent\n        utilities.extract_tags(related_elt.find_all(u'h2'))\n        related = {}\n        for link in related_elt.find_all(u'a'):\n          href = link.get(u'href').replace(u'http://myanimelist.net', '')\n          if not re.match(r'/(anime|manga)', href):\n            break\n          curr_elt = link.previous_sibling\n          if curr_elt is None:\n            # we've reached the end of the list.\n            break\n          related_type = None\n          while True:\n            if not curr_elt:\n              raise MalformedAnimePageError(self.id, related_elt, message=\"Prematurely reached end of related anime listing\")\n            if isinstance(curr_elt, bs4.NavigableString):\n              type_match = re.match(u'(?P<type>[a-zA-Z\\ \\-]+):', curr_elt)\n              if type_match:\n                related_type = type_match.group(u'type')\n                break\n            curr_elt = curr_elt.previous_sibling\n          title = link.text\n          # parse link: may be manga or anime.\n          href_parts = href.split(u'/')\n          # sometimes links on MAL are broken, of the form /anime//\n          if href_parts[2] == '':\n            continue\n          # of the form: /(anime|manga)/1/Cowboy_Bebop\n          obj_id = int(href_parts[2])\n          new_obj = getattr(self.session, href_parts[1])(obj_id).set({'title': title})\n          if related_type not in related:\n            related[related_type] = [new_obj]\n          else:\n            related[related_type].append(new_obj)\n        media_info[u'related'] = related\n      else:\n        media_info[u'related'] = None\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return media_info", "response": "Parses the DOM and returns the media attributes in the main - content area."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_stats(self, media_page):\n    media_info = self.parse_sidebar(media_page)\n    verb_progressive = self.consuming_verb + u'ing'\n    status_stats = {\n      verb_progressive: 0,\n      'completed': 0,\n      'on_hold': 0,\n      'dropped': 0,\n      'plan_to_' + self.consuming_verb: 0\n    }\n    try:\n      consuming_elt = media_page.find(u'span', {'class': 'dark_text'}, text=verb_progressive.capitalize())\n      if consuming_elt:\n        status_stats[verb_progressive] = int(consuming_elt.nextSibling.strip().replace(u',', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      completed_elt = media_page.find(u'span', {'class': 'dark_text'}, text=\"Completed:\")\n      if completed_elt:\n        status_stats[u'completed'] = int(completed_elt.nextSibling.strip().replace(u',', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      on_hold_elt = media_page.find(u'span', {'class': 'dark_text'}, text=\"On-Hold:\")\n      if on_hold_elt:\n        status_stats[u'on_hold'] = int(on_hold_elt.nextSibling.strip().replace(u',', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      dropped_elt = media_page.find(u'span', {'class': 'dark_text'}, text=\"Dropped:\")\n      if dropped_elt:\n        status_stats[u'dropped'] = int(dropped_elt.nextSibling.strip().replace(u',', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      planning_elt = media_page.find(u'span', {'class': 'dark_text'}, text=\"Plan to \" + self.consuming_verb.capitalize() + \":\")\n      if planning_elt:\n        status_stats[u'plan_to_' + self.consuming_verb] = int(planning_elt.nextSibling.strip().replace(u',', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    media_info[u'status_stats'] = status_stats\n\n    score_stats = {\n      1: 0,\n      2: 0,\n      3: 0,\n      4: 0,\n      5: 0,\n      6: 0,\n      7: 0,\n      8: 0,\n      9: 0,\n      10: 0\n    }\n    try:\n      score_stats_header = media_page.find(u'h2', text='Score Stats')\n      if score_stats_header:\n        score_stats_table = score_stats_header.find_next_sibling(u'table')\n        if score_stats_table:\n          score_stats = {}\n          score_rows = score_stats_table.find_all(u'tr')\n          for i in xrange(len(score_rows)):\n            score_value = int(score_rows[i].find(u'td').text)\n            score_stats[score_value] = int(score_rows[i].find(u'small').text.replace(u'(u', '').replace(u' votes)', ''))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    media_info[u'score_stats'] = score_stats\n\n    return media_info", "response": "Parses the DOM and returns the media statistics attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the DOM and returns media character attributes in the sidebar.", "response": "def parse_characters(self, character_page):\n    \"\"\"Parses the DOM and returns media character attributes in the sidebar.\n\n    :type character_page: :class:`bs4.BeautifulSoup`\n    :param character_page: MAL character page's DOM\n\n    :rtype: dict\n    :return: character attributes.\n\n    \"\"\"\n    media_info = self.parse_sidebar(character_page)\n\n    try:\n      character_title = filter(lambda x: u'Characters' in x.text, character_page.find_all(u'h2'))\n      media_info[u'characters'] = {}\n      if character_title:\n        character_title = character_title[0]\n        curr_elt = character_title.find_next_sibling(u'table')\n        while curr_elt:\n          curr_row = curr_elt.find(u'tr')\n          # character in second col.\n          character_col = curr_row.find_all(u'td', recursive=False)[1]\n          character_link = character_col.find(u'a')\n          character_name = ' '.join(reversed(character_link.text.split(u', ')))\n          link_parts = character_link.get(u'href').split(u'/')\n          # of the form /character/7373/Holo\n          character = self.session.character(int(link_parts[2])).set({'name': character_name})\n          role = character_col.find(u'small').text\n          media_info[u'characters'][character] = {'role': role}\n          curr_elt = curr_elt.find_next_sibling(u'table')\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return media_info"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(self):\n    media_page = self.session.session.get(u'http://myanimelist.net/' + self.__class__.__name__.lower() + u'/' + str(self.id)).text\n    self.set(self.parse(utilities.get_clean_dom(media_page)))\n    return self", "response": "Fetches the MAL media page and sets the current media s attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_stats(self):\n    stats_page = self.session.session.get(u'http://myanimelist.net/' + self.__class__.__name__.lower() + u'/' + str(self.id) + u'/' + utilities.urlencode(self.title) + u'/stats').text\n    self.set(self.parse_stats(utilities.get_clean_dom(stats_page)))\n    return self", "response": "Fetches the MAL media statistics page and sets the current media s statistics attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_characters(self):\n    characters_page = self.session.session.get(u'http://myanimelist.net/' + self.__class__.__name__.lower() + u'/' + str(self.id) + u'/' + utilities.urlencode(self.title) + u'/characters').text\n    self.set(self.parse_characters(utilities.get_clean_dom(characters_page)))\n    return self", "response": "Fetches the MAL media characters page and sets the current media s character attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(parser, serializer):\n    fortdir = os.path.dirname(fortpy.__file__)\n    xmlpath = os.path.join(fortdir, \"isense\", \"builtin.xml\")\n    if not os.path.isfile(xmlpath):\n        return {}\n\n    changed_time = os.path.getmtime(xmlpath)\n    cached = serializer.load_module(\"builtin.xml\", changed_time)\n    if cached is None:\n        result = _load_builtin_xml(xmlpath, parser)\n        serializer.save_module(\"builtin.xml\", result, changed_time)\n    else:\n        result = cached\n\n    return result", "response": "Loads a dictionary of builtin functions for Fortran."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _isense_builtin_symbol(symbol):\n    if \"builtin\" in config.isense and \"uppercase\" in config.isense[\"builtin\"]:\n        if config.isense[\"builtin\"][\"uppercase\"] == \"true\":\n            return symbol.upper()\n        else:\n            return symbol.lower()\n    else:\n        #Make it lowercase by default\n        return symbol.lower()", "response": "Returns the symbol with modifications according to settings in the isense section."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the builtin function specifications from the builtin. xml file.", "response": "def _load_builtin_xml(xmlpath, parser):\n    \"\"\"Loads the builtin function specifications from the builtin.xml file.\n\n    :arg parser: the DocParser instance for parsing the XML tags.\n    \"\"\"\n    #First we need to get hold of the fortpy directory so we can locate\n    #the isense/builtin.xml file.\n    result = {}\n\n    el = ET.parse(xmlpath).getroot()\n    if el.tag == \"builtin\":\n        for child in el:\n            anexec = _parse_xml(child, parser)\n            result[anexec.name.lower()] = anexec\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_xml(child, parser):\n    name, modifiers, dtype, kind = _parse_common(child)\n\n    #Handle the symbol modification according to the isense settings.\n    name = _isense_builtin_symbol(name)\n\n    if child.tag == \"subroutine\":\n        parent = Subroutine(name, modifiers, None)\n    elif child.tag == \"function\":\n        parent = Function(name, modifiers, dtype, kind, None)\n\n    if parent is not None:\n        for kid in child:\n            if kid.tag == \"parameter\":\n                _parse_parameter(kid, parser, parent)\n            elif kid.tag == \"summary\":\n                _parse_summary(kid, parser, parent)\n            elif kid.tag == \"usage\":\n                _parse_usage(kid, parser, parent)\n\n    return parent", "response": "Parses the specified child XML tag and creates a Subroutine or\n    Function object out of it."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a summary tag and adds it to the Executable parent instance.", "response": "def _parse_summary(tag, parser, parent):\n    \"\"\"Parses a <summary> tag and adds it the Executable parent instance.\n    \n    :arg parser: an instance of DocParser to create the DocElement with.\n    \"\"\"\n    summary = DocElement(tag, parser, parent)\n    parent.docstring.append(summary)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a usage tag and adds it to the Executable parent instance.", "response": "def _parse_usage(tag, parser, parent):\n    \"\"\"Parses a <usage> tag and adds it the Executable parent instance.\n    \n    :arg parser: an instance of DocParser to create the DocElement with.\n    \"\"\"\n    usage = DocElement(tag, parser, parent)\n    parent.docstring.append(usage)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_parameter(tag, parser, parent):\n    name, modifiers, dtype, kind = _parse_common(tag)\n    if \"default\" in tag.attrib:\n        default = tag.attrib[\"default\"]\n    else:\n        default = None\n    if \"dimension\" in tag.attrib:\n        dimension = tag.attrib[\"dimension\"]\n    else:\n        dimension = None\n\n    result = ValueElement(name, modifiers, dtype, kind, default, dimension, parent)\n    doc = DocElement(tag, parser, result)\n    result.docstring.append(doc)\n    parent.add_parameter(result)", "response": "Creates a ValueElement instance from the specified XML tag."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the common attributes of the specified tag.", "response": "def _parse_common(tag):\n    \"\"\"Returns a tuple of (name, modifiers, dtype, kind)\n    for the specified tag. Any missing attributes will have values of None.\n    \"\"\"\n    if \"modifiers\" in tag.attrib:\n        modifiers = re.split(\",\\s*\", tag.attrib[\"modifiers\"].strip())\n        if \"\" in modifiers:\n            modifiers.remove(\"\")\n    else:\n        modifiers = None\n\n    if \"name\" in tag.attrib:\n        name = tag.attrib[\"name\"]\n    if \"type\" in tag.attrib:\n        dtype = tag.attrib[\"type\"]\n    else:\n        dtype = None\n    if \"kind\" in tag.attrib:\n        kind = tag.attrib[\"kind\"]\n    else:\n        kind = None\n\n    return (name, modifiers, dtype, kind)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lazy_tag(tag, *args, **kwargs):\n    tag_id = get_tag_id()\n    set_lazy_tag_data(tag_id, tag, args, kwargs)\n\n    return render_to_string('lazy_tags/lazy_tag.html', {\n        'tag_id': tag_id,\n        'STATIC_URL': settings.STATIC_URL,\n    })", "response": "Lazily loads a template tag after the page has loaded. Requires jQuery\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_request(self, url, params, auth=None):\n        req = urllib2.Request(url + urllib.urlencode(params))\n\n        if auth:\n            req.add_header('AUTHORIZATION', 'Basic ' + auth)\n\n        return urllib2.urlopen(req)", "response": "Makes a request to a url with the given parameters and optionally authentication."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fpy_read(D, dtype, kind, suffix=None):\n    modifiers = {\n        None: \", allocatable\",\n        \"_p\": \", pointer\",\n        \"_f\": \"\"\n    }\n    common = {\n        \"dtype\": dtype,\n        \"D\": D,\n        \"modify\": modifiers[suffix] if D > 0 else \"\",\n        \"Dx\": \"({})\".format(','.join([\":\"]*D)) if D >0 else \"\",\n        \"maxlen\": linemax,\n        \"suffix\": xsuffix[suffix],\n        \"skind\": kind if kind is not None else \"\",\n        \"fmtstr\": \"\" if dtype != \"complex\" else \"character(:), allocatable :: FMT\"\n    }\n    if dtype == \"complex\":\n        rfmt = \"2E22.12\" if kind == \"dp\" else \"2E19.9\"\n    else:\n        rfmt = \"\"\n    if dtype == \"complex\":\n        readfmt = prec[dtype][kind]\n        \n    if dtype in defaults:\n        common[\"default\"] = defaults[dtype]\n    else:\n        common[\"default\"] = \"0\"\n        \n    if kind is not None and dtype in kmap:\n        common[\"kind\"] = \"({})\".format(kmap[dtype][kind])\n    else:\n        common[\"kind\"] = \"\"\n    \n    #Add the specific sections for each of the dimensionalities that we read.\n    if D==0:\n        common[\"vars\"] = \"integer :: nlines, nvalues\"\n    elif D in [1, 2]:\n        common[\"vars\"] = \"integer :: nlines, nvalues, i\"\n    else:\n        fmtstr = \"integer :: dims({0:d}), {1}, indices({0:d})\"\n        common[\"vars\"] = fmtstr.format(D, ', '.join([\"i{}\".format(i+1) for i in range(D)]))\n\n    if suffix == \"_p\":\n        common[\"dealloc\"] = \"    if (associated(variable)) variable => null()\\n\"\n    elif D > 0 and suffix is None:\n        common[\"dealloc\"] = \"    if (allocated(variable)) deallocate(variable)\\n\"\n    else:\n        common[\"dealloc\"] = \"\"\n        \n    if D in [0,1,2]:\n        if dtype == \"character\":\n            common[\"analyze\"] = \"    call fpy_linevalue_count(filename, commentchar, nlines, nvalues, .true.)\\n\"\n        else:\n            common[\"analyze\"] = \"    call fpy_linevalue_count(filename, commentchar, nlines, nvalues)\\n\"\n    else:\n        common[\"analyze\"] = \"\"\n\n    if D==0:\n        if dtype == \"complex\":\n            lines = [\"if ((nvalues .gt. 2) .or. (nlines /= 1)) then\"]\n        else:\n            lines = [\"if ((nvalues .gt. 1) .or. (nlines /= 1)) then\"]\n        lines.extend([\"  write(*,*) \\\"Cannot read a single value from \\\", filename\",\n                      \"  write(*,*) \\\"Found \\\", nlines, \\\" lines and \\\", nvalues, \\\" values\\\"\",\n                      \"  if (present(success_)) success_ = .false.\",\n                      \"  if (strict) stop\",\n                      \"end if\\n\"])\n        common[\"warning\"] = '    '+'\\n    '.join(lines)\n    elif D==1:\n        if dtype == \"complex\":\n            lines = [\"if ((nlines .gt. 2 .and. nvalues .gt. 2) .or. (nlines .eq. 0 .or. nvalues .eq. 0)) then\"]\n        else:\n            lines = [\"if ((nlines .gt. 1 .and. nvalues .gt. 1) .or. (nlines .eq. 0 .or. nvalues .eq. 0)) then\"]\n        lines.extend(['  write(*,*) \"Cannot read a vector value from \", filename',\n                      '  write(*,*) \"Found \", nlines, \" lines and \", nvalues, \" values\"',\n                      \"  if (present(success_)) success_ = .false.\",\n                      \"  if (strict) stop\",\n                      \"end if\\n\"])\n        if suffix == \"_f\":\n            lines = [\"\"]\n            if dtype == \"complex\":\n                lines.append(\"if ((nlines/2 .ne. size(variable, 1)) .and. (nvalues/2 .ne. size(variable, 1))) then\")\n            else:\n                lines.append(\"if ((nlines .ne. size(variable, 1)) .and. (nvalues .ne. size(variable, 1))) then\")\n            lines.extend([\"  write(*,*) \\\"File data dimensions don't match fixed variable shape \\\", shape(variable)\",\n                          \"  write(*,*) \\\"Fortpy sees data dimensions in '\\\", filename, \\\"' as \\\", nlines, nvalues\",\n                          \"  if (present(success_)) success_ = .false.\",\n                          \"  if (strict) stop\",\n                          \"end if\\n\"])\n        common[\"warning\"] = '    '+'\\n    '.join(lines)\n    elif D==2 and suffix == \"_f\":\n        if dtype == \"complex\":\n            lines = [\"if ((nlines .ne. size(variable, 1)) .and. (nvalues .ne. size(variable, 2))) then\",\n                     \"  write(*,*) \\\"File data dimensions don't match fixed variable shape \\\", shape(variable)\",\n                     \"  write(*,*) \\\"Fortpy sees data dimensions in '\\\", filename, \\\"' as \\\", nlines, nvalues/2\"]\n        else:\n            lines = [\"if ((nlines .ne. size(variable, 1)) .and. (nvalues .ne. size(variable, 2))) then\",\n                     \"  write(*,*) \\\"File data dimensions don't match fixed variable shape \\\", shape(variable)\",\n                     \"  write(*,*) \\\"Fortpy sees data dimensions in '\\\", filename, \\\"' as \\\", nlines, nvalues\"]\n        lines.extend([\"  if (present(success_)) success_ = .false.\",\n                      \"  if (strict) stop\",\n                      \"end if\\n\"])\n        common[\"warning\"] = '    '+'\\n    '.join(lines)\n    else:\n        common[\"warning\"] = \"\"\n\n    if D==1 and suffix in [None, \"_p\"]:\n        if dtype == \"complex\":\n            lines = [\"if (nlines .gt. 2) then\",\n                     \"  FMT = '{}'\".format(rfmt)]\n        else:\n            lines = [\"if (nlines .gt. 1) then\"]\n        lines.extend([\"  allocate(variable(nlines))\",\n                      \"else\"])\n        if dtype == \"complex\":\n            lines.extend([\"  FMT = '{}'\".format(rfmt),\n                          \"  do ifmt=2,nvalues/2; FMT = FMT//',1X,{}';  end do\".format(rfmt),\n                          \"  allocate(variable(nvalues/2))\"])\n        else:\n            lines.append(\"  allocate(variable(nvalues))\")\n        lines.extend([\"end if\",\n                      \"variable = {default}\\n\".format(**common)])\n        common[\"allocate\"] = '    '+'\\n    '.join(lines)\n    elif D==2 and suffix in [None, \"_p\"]:\n        if dtype==\"complex\":\n            common[\"allocate\"] = (\"    allocate(variable(nlines, nvalues/2))\\n\"\n                                  \"    FMT = '{0}'\\n\"\n                                  \"    do ifmt=2,nvalues/2; FMT = FMT//',1X,{0}';  end do\\n\"\n                                  \"    variable = {default}\\n\".format(rfmt, **common))\n        else:\n            common[\"allocate\"] = (\"    allocate(variable(nlines, nvalues))\\n\"\n                                  \"    variable = {default}\\n\".format(**common))\n    elif D==0:\n        if dtype == \"complex\":\n            common[\"allocate\"] = (\"    write(FMT, *) 1\\n\"\n                                  \"    variable = {}\\n\".format(common[\"default\"]))\n        else:\n            common[\"allocate\"] = \"    variable = {}\\n\".format(common[\"default\"])\n    else:\n        common[\"allocate\"] = \"\"\n\n    if D==0:\n        common[\"initial\"] = \"\"    \n    elif D in [1,2]:\n        common[\"initial\"] = \"\\n      i=1\"\n    else:\n        lines = [\"\\n      do\",\n                 '  read(funit, \"(A)\", iostat=ioerr) line',\n                 \"  if (ioerr == 0) then\",\n                 \"    cleaned = trim(adjustl(line))\",\n                 \"    if (len(cleaned) .gt. 1) then\",\n                 \"      if (cleaned(1:2) .eq. '##') then\",\n                 \"        read(cleaned(3:) ,*) dims\",\n                 \"        exit\",\n                 \"      end if\",\n                 \"    end if\",\n                 \"  else\",\n                 \"    write(*,*) \\\"No shape information found for {0}D data file '\\\", filename, \\\"'\\\"\",\n                 \"    stop\",\n                 \"  end if\",\n                 \"end do\",\n                 \"\"]\n        if suffix in [None, \"_p\"]:\n            dims = ', '.join([\"dims({})\".format(i+1) for i in range(D)])\n            lines.append(\"allocate(variable({}))\".format(dims))\n        if dtype == \"complex\":\n            lines.append(\"FMT = '{0}'\".format(rfmt))\n            fmtloop = \"do ifmt=2,dims({0}); FMT = FMT//',1X,{1}';  end do\"\n            lines.append(fmtloop.format(D, rfmt))\n        lines.append(\"variable = {default}\".format(**common))\n        lines.append(\"\")\n\n        common[\"initial\"] = '\\n      '.join(lines).format(D)\n\n    if D==0:\n        lines = [\"if (cleaned(1:1) /= commentchar) then\"]\n        if dtype == \"complex\":\n            lines.append(\"  read(line, {}) variable\".format(readfmt))\n        else:\n            lines.append(\"  read(line, *) variable\")\n        lines.append(\"end if\")\n        common[\"readvar\"] = '\\n            '.join(lines)\n    elif D==1:\n        lines = [\"if (cleaned(1:1) /= commentchar) then\"]                         \n        if dtype == \"complex\":\n            lines.append(\"  if (nvalues == 2) then\")\n            lines.append(\"    read(line, {}) variable(i)\".format(readfmt))\n        else:\n            lines.append(\"  if (nlines .gt. 1) then\")\n            lines.append(\"    read(line, *) variable(i)\")\n        lines.extend([\"    i = i+1\",\n                      \"  else\"])\n        if dtype == \"complex\":\n            lines.append(\"    read(line, {}) variable\".format(readfmt))\n        else:\n            lines.append(\"    read(line, *) variable\")\n        lines.extend([\"  end if\",\n                      \"end if\"])\n        common[\"readvar\"] = '\\n            '.join(lines)\n    elif D==2:\n        lines = [\"if (cleaned(1:1) /= commentchar) then\"]\n        if dtype == \"complex\":\n            lines.append(\"  read(line, {}) variable(i,:)\".format(readfmt))\n        else:\n            lines.append(\"  read(line, *) variable(i,:)\")\n        lines.extend([\"  i = i+1\",\n                      \"end if\"])\n        common[\"readvar\"] = '\\n            '.join(lines)\n    else:\n        lines = [\"if (cleaned(1:2) .eq. '##') then\",\n                 \"  read(cleaned(3:), *) indices\"]\n        ivars = [\"i{}\".format(i+1) for i in range(D-1)]\n        for i in range(D-2):\n            lines.append(\"  i{0} = indices({0})\".format(i+1))\n        lines.append(\"  i{} = 1\".format(D-1))\n        \n        lines.append(\"elseif (cleaned(1:1) /= commentchar) then\")\n        if dtype == \"complex\":\n            lines.append(\"  read(line, {}) variable({{0}},:)\".format(readfmt))\n        else:\n            lines.append(\"  read(line, *) variable({0},:)\")\n        lines.extend([\"  i{1} = i{1}+1\",\n                      \"end if\"])\n        common[\"readvar\"] = '\\n            '.join(lines).format(','.join(ivars), D-1)\n\n    if dtype==\"character\":\n        common[\"xname\"] = \"fpy_read_{dtype}_{D}d{suffix}\".format(**common)\n    else:\n        common[\"xname\"] = \"fpy_read_{dtype}{skind}_{D}d{suffix}\".format(**common)\n\n    if suffix is None:\n        common[\"noexist\"] = \"return\"\n    elif suffix == \"_p\":\n        #Set pointers to null if they weren't set on construction in their definition.\n        common[\"noexist\"] = \"variable => null()\\n      return\"\n    else:\n        common[\"noexist\"] = \"variable = {}\\n      return\".format(common[\"default\"])\n        \n    template = \"\"\"  subroutine {xname}(filename, commentchar, variable, success_, strict_)\n    character(len=*), intent(in) :: filename\n    character(1), intent(in) :: commentchar\n    logical, optional, intent(out) :: success_\n    logical, optional, intent(in) :: strict_\n    {dtype}{kind}{modify}, intent(inout) :: variable{Dx}\n\n    character(len=:), allocatable :: cleaned\n    integer :: ioerr, funit, ifmt\n    logical :: exists, strict\n    {vars}\n    character({maxlen:d}) :: line\n    {fmtstr}\n\n    if (present(strict_)) then\n      strict = strict_\n    else\n      strict = .false.\n    end if\n\n    inquire(file=filename, exist=exists)\n    if (present(success_)) success_ = exists .or. .false.\n    if (.not. exists) then\n      if (fpy_verbose > 0) write (*,*) \"Target file '\", filename, \"' does not exist.\"\n      {noexist}\n    end if\n\n{dealloc}{analyze}{warning}{allocate}\n\n    open(fpy_newunit(funit), file=filename, iostat=ioerr)\n    if (ioerr == 0) then{initial}\n      do\n        read(funit, \"(A)\", iostat=ioerr) line\n        if (ioerr == 0) then\n          cleaned = trim(adjustl(line))\n          if (len(cleaned) .gt. 0) then\n            {readvar}\n          end if\n        else\n          exit\n        end if\n      end do\n    end if\n    close(funit)    \n    if (present(success_)) success_ = .true.\n  end subroutine {xname}\n    \"\"\"\n    return (common[\"xname\"], template.format(**common))", "response": "Generates the fortran code for the fpy_read interface module procedure for the specified type and dimensionality."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate the interface for reading and writing values for variables of the specified suffix.", "response": "def fpy_interface_sub(fpy, dtype, kind, suffix=None):\n    \"\"\"Generates the interface for reading/writing values for variables of the specified suffix\n    for dimensions 0 through 7.\n\n    :arg fpy: the generating function that accepts the dimension and type information\n      and returns the (xnames, subtext).\n    :arg suffix: one of [None, \"_f\", \"_p\"] corresponding to \"allocatable\", fixed dimension,\n      and \"pointer\" type variables.\n    \"\"\"\n    allsubs = []\n    xnames = []\n    drange = list(range(8)) if suffix is None else list(range(1,8))\n    for D in drange:\n        xname, sub = fpy(D, dtype, kind, suffix)\n        xnames.append(xname)\n        allsubs.append(sub)\n\n    return (xnames, '\\n'.join(allsubs))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsplicing the full list of subroutines and the module procedures of the given interface into the static. f90 file.", "response": "def fpy_interface(fpy, static, interface, typedict):\n    \"\"\"Splices the full list of subroutines and the module procedure list\n    into the static.f90 file.\n\n    :arg static: the string contents of the static.f90 file.\n    :arg interface: the name of the interface *field* being replaced.\n    :arg typedict: the dictionary of dtypes and their kind and suffix combos. \n    \"\"\"\n    modprocs = []\n    subtext = []\n    for dtype, combos in list(typedict.items()):\n        for tcombo in combos:\n            kind, suffix = tcombo\n            xnames, sub = fpy_interface_sub(fpy, dtype, kind, suffix)\n            modprocs.extend(xnames)\n            subtext.append(sub)\n        subtext.append(\"\\n\")\n\n    #Next, chunk the names of the module procedures into blocks of five\n    #so that they display nicely for human readability.\n    from fortpy.printing.formatting import present_params\n    splice = static.replace(interface, present_params(modprocs, 21))\n    return splice.replace(interface.replace(\"py\", \"xpy\"), ''.join(subtext))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pysave(D, dtype, kind, suffix=None):\n    common = {\n        \"dtype\": dtype,\n        \"D\": D,\n        \"Dx\": \"({})\".format(','.join([\":\"]*D)) if D >0 else \"\",\n        \"suffix\": xsuffix[suffix],\n        \"skind\": kind if kind is not None else \"\",\n        \"fmtvar\": (\"character(20) :: FMT\" if dtype != \"complex\"\n                   else \"character(:), allocatable :: FMT\")\n    }\n\n    #For character, we use the auto-length arrays.\n    if dtype in prec and kind in prec[dtype]:\n        common[\"fmt\"] = prec[dtype][kind]\n    else:\n        common[\"fmt\"] = \"*\"\n\n    if kind is not None and dtype in kmap:\n        common[\"kind\"] = \"({})\".format(kmap[dtype][kind])\n    else:\n        common[\"kind\"] = \"\"\n\n    if D > 0:\n        inds = ', '.join([\"i{}\".format(i+1) for i in range(D-1)])\n        if D > 1:\n            inds = ', ' + inds\n        common[\"vars\"] = \"integer :: dims({}){}\\n\".format(D, inds)\n    else:\n        common[\"vars\"] = \"\"\n\n    if D > 0:\n        lines = [\"dims = shape(variable)\",\n                 \"if (dims({}) .eq. 0) return\".format(D)]\n        if dtype == \"complex\":\n            rfmt = \"2E22.12\" if kind == \"dp\" else \"2E19.9\"\n            lines.append(\"FMT = '{0}'\".format(rfmt))\n            fmtloop = \"do ifmt=2,dims({0}); FMT = FMT//',1X,{1}';  end do\"\n            lines.append(fmtloop.format(D, rfmt))\n        else:\n            lines.append(\"write(FMT, *) dims({})\".format(D))\n        common[\"initial\"] = '\\n    '.join(lines)\n    else:\n        common[\"initial\"] = \"write(FMT, *) 1\"\n        \n    if D==0:\n        if dtype==\"character\":\n            common[\"write\"] = \"write(fileunit, {fmt}) trim(adjustl(variable))\".format(**common)\n        else:\n            common[\"write\"] = \"write(fileunit, {fmt}) variable\".format(**common)\n    else:\n        lines = []\n        if D > 2:\n            #Add the shape declaration at the top of the file.\n            lines.append(\"write(fileunit, \\\"(A, {}i15)\\\") \\\"## \\\", dims\".format(D))\n        #Next, we make a do loop for each of the dimensions except the last and then\n        #write the lines of the last 2D array for each slice.\n        for i in range(D-1):\n            lines.append(\"{0}do i{1}=1, dims({1})\".format(spacer(2*i), i+1))\n            if i == D-3 and D > 2:\n                inds = ', '.join([\"i{}\".format(j+1) for j in range(D-2)])\n                fmtstr = \"{}write(fileunit, \\\"(A, {}i15)\\\") \\\"## \\\", {}, 0, 0\"\n                lines.append(fmtstr.format(spacer(2*(i+1)), D, inds))\n\n        sinds = ', '.join([\"i{}\".format(j+1) for j in range(D-1)])\n        if D > 1:\n            sinds = sinds + ', '\n        if dtype==\"character\":\n            fmtstr = \"{0}call char_write_trimmed(variable({2}:))\"\n        else:\n            fmtstr = \"{}write(fileunit, {}) variable({}:)\"\n        lines.append(fmtstr.format(spacer(2*(D-1)), common[\"fmt\"], sinds))\n\n        #Finally, add the 'end do' statements to close the loops. \n        for i in range(D-2,-1,-1):\n            lines.append(\"{0}end do\".format(spacer(2*i), i+1))\n\n        common[\"write\"] = '\\n    '.join(lines)\n\n    if dtype==\"character\":\n        common[\"xname\"] = \"pysave_{dtype}_{D}d{suffix}\".format(**common)\n    else:\n        common[\"xname\"] = \"pysave_{dtype}{skind}_{D}d{suffix}\".format(**common)\n    \n    template = \"\"\"  subroutine {xname}(variable, filename)\n    character(len=*), intent(in) :: filename\n    {dtype}{kind}, intent(in) :: variable{Dx}\n    {fmtvar}\n    {vars}\n    integer :: ifmt\n    {initial}\n\n    call file_open(filename, len(filename), '{dtype}')\n    {write}\n    call file_close()\n  end subroutine {xname}\n    \"\"\"\n    return (common[\"xname\"], template.format(**common))", "response": "Generates the fortran code for the pysave interface module."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the specified Fortran source file and returns a ctypes. nparray. CodeParser object.", "response": "def _parse():\n    \"\"\"Parses the specified Fortran source file from which the wrappers will\n    be constructed for ctypes.\n    \"\"\"\n    if not args[\"reparse\"]:\n        settings.use_filesystem_cache = False\n\n    c = CodeParser()    \n    if args[\"verbose\"]:\n        c.verbose = True\n\n    if args[\"reparse\"]:\n        c.reparse(args[\"source\"])\n    else:\n        c.parse(args[\"source\"])\n\n    return c"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites the F90 module file from the specified code parser for all the modules inside of it.", "response": "def writef90():\n    \"\"\"Writes the F90 module file from the specified code parser for *all* the modules\n    inside of it.\n    \"\"\"\n    cparser = _parse()\n    dependencies = [\"{}_c\".format(m) for m in cparser.modules]\n    originals = list(cparser.modules.keys())\n    writers = {}\n    for modname, module in list(cparser.modules.items()):\n        msg.info(\"Writing wrapper module for {}\".format(modname))\n        fwriter = f90.WrapperModule(module, args[\"library\"], args[\"f90\"], args[\"link\"])\n        writers[modname] = fwriter\n        fwriter.write_f90()\n        msg.okay(\"Finished writing {}_c.f90\".format(modname))\n        \n    #We can compile all these modules together into a single shared library.\n    writer = list(writers.values())[0]\n    code = writer.make(remake=args[\"remake\"], dependencies=dependencies, compiler=args[\"compiler\"],\n                       debug=args[\"debug\"], profile=args[\"profile\"])\n    if code == 0:\n        for modname in originals:\n            msg.info(\"Writing python wrapper module {}.py\".format(modname))\n            writers[modname].write_py()\n            msg.okay(\"Finished writing {}.py\".format(modname))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_regex(self):\n        #Regex for extracting modules from the code\n        self._RX_MODULE = r\"(\\n|^)\\s*module\\s+(?P<name>[a-z0-9_]+)(?P<contents>.+?)end\\s*module\"\n        self.RE_MODULE = re.compile(self._RX_MODULE, re.I | re.DOTALL)\n        self._RX_PROGRAM = r\"(\\n|^)\\s*program\\s+(?P<name>[a-z0-9_]+)(?P<contents>.+?)end\\s*program\"\n        self.RE_PROGRAM = re.compile(self._RX_PROGRAM, re.I | re.DOTALL)\n\n        #Regex for use statements in a module\n        self._RX_USE = r\"^\\s*use\\s+(?P<name>[^,]+?)(\\s*,\\s+only\\s*:(?P<only>[A-Za-z0-9_\\s,]+?))?$\"\n        self.RE_USE = re.compile(self._RX_USE, re.I | re.M)\n        #Regex for finding if the module is private\n        self._RX_PRIV = \"private.+?(type|contains)\"\n        self.RE_PRIV = re.compile(self._RX_PRIV, re.DOTALL | re.I)\n        #Regex for finding publcily labeled members declared using public keyword.\n        self._RX_PUBLIC = r\"\\n\\s*public\\s+(?P<methods>[A-Za-z0-9_,\\s&\\n]+)\"\n        self.RE_PUBLIC = re.compile(self._RX_PUBLIC, re.I)\n        #Regex for finding text before type or contains declarations that may contian members.\n        self._RX_MEMBERS = \"(?P<preamble>.+?)(\\s+type[,\\s]|contains)\"\n        self.RE_MEMBERS = re.compile(self._RX_MEMBERS, re.DOTALL | re.I)\n\n        self._RX_PRECOMP = r\"#endif\"\n        self.RE_PRECOMP = re.compile(self._RX_PRECOMP, re.I)", "response": "Sets up compiled regex objects for parsing code elements."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform a real - time update of the specified statement that is in the body of the specified element.", "response": "def rt_update(self, statement, element, mode, linenum, lineparser):\n        \"\"\"Performs a real-time update of the specified statement that is in the body of the\n        module.\n        \n        :arg statement: the lines of code that was added/removed/changed on the \n          element after it had alread been parsed. The lines together form a single\n          continuous code statement.\n        :arg element: the Module instance to update.\n        :arg mode: 'insert', 'replace', or 'delete'.\n        \"\"\"\n        #First find out if we are passed the CONTAINS section separating executables from\n        #the type and member definitions. In order for this code to be reached, the lines\n        #that are being changed are *between* definitions that already exist. The likelihood\n        #is that they are *new* definitions of members, types or executables.\n        if linenum <= element.contains_index:\n            #we only have to look for type and member definitions.\n            self._rt_parse_members(statement, element, mode)\n            self._rt_parse_types(statement, element, mode, lineparser)\n        else:\n            #we only have to deal with executables.\n            self._rt_parse_execs(statement, element, mode, lineparser)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self, string, parent, module=True, filepath=None):\n        if module:\n            result = self._parse_modules(string, parent, filepath)\n        else:\n            result = self._parse_programs(string, parent, filepath)\n        return result", "response": "Extracts modules and programs from a fortran code file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_programs(self, string, parent, filepath=None):\n        #First, get hold of the docstrings  for all the modules so that we can\n        #attach them as we parse them.\n        moddocs = self.docparser.parse_docs(string)\n        #Now look for modules in the file and then match them to their decorators.\n        matches = self.RE_PROGRAM.finditer(string)\n        result = []\n        for rmodule in matches:\n            name = rmodule.group(\"name\").lower()\n            contents = re.sub(\"&[ ]*\\n\", \"\", rmodule.group(\"contents\"))\n            module = self._process_module(name, contents, parent, rmodule, filepath)\n            #Check whether the docparser found docstrings for the module.\n            if name in moddocs:                \n                module.docstring = self.docparser.to_doc(moddocs[name][0], name)\n                module.docstart, module.docend = module.absolute_charindex(string, moddocs[name][1],\n                                                                           moddocs[name][2])\n            result.append(module)\n        return result", "response": "Extracts a PROGRAM from the specified fortran code file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _process_publics(self, contents):\n        matches = self.RE_PUBLIC.finditer(contents)\n        result = {}\n        start = 0\n        for public in matches:\n            methods = public.group(\"methods\")\n            #We need to keep track of where the public declarations start so that the unit\n            #testing framework can insert public statements for those procedures being tested\n            #who are not marked as public\n            if start == 0:\n                start = public.start(\"methods\")\n            for item in re.split(r\"[\\s&\\n,]+\", methods.strip()):\n                if item.lower() in [\"interface\", \"type\", \"use\"]:\n                    #We have obviously reached the end of the actual public\n                    #declaration in this regex match.\n                    break\n                self._dict_increment(result, item.lower())\n        return (result, start)", "response": "Extracts a list of public members types and executables that were declared using\n        the public keyword instead of a decoration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing a regex match for a module to create a CodeElement.", "response": "def _process_module(self, name, contents, parent, match, filepath=None):\n        \"\"\"Processes a regex match for a module to create a CodeElement.\"\"\"\n        #First, get hold of the name and contents of the module so that we can process the other\n        #parts of the module.\n        modifiers = []\n\n        #We need to check for the private keyword before any type or contains declarations\n        if self.RE_PRIV.search(contents):\n            modifiers.append(\"private\")\n        #The only other modifier for modules ought to be implicit none\n        if re.search(\"implicit\\s+none\", contents):\n            modifiers.append(\"implicit none\")\n\n        #Next, parse out the dependencies of the module on other modules\n        dependencies = self._parse_use(contents)\n        publics, pubstart = self._process_publics(match.string)\n\n        #We can now create the CodeElement\n        result = Module(name, modifiers, dependencies, publics, contents, parent)\n        if filepath is not None:\n            result.filepath = filepath.lower()\n        result.start = match.start()\n        result.end = match.end()\n        result.refstring = match.string\n        result.set_public_start(pubstart)\n        if self.RE_PRECOMP.search(contents):\n            result.precompile = True\n\n        self.xparser.parse(result)\n        self.tparser.parse(result)\n\n        #It is possible for the module to have members, parse those\n        self._parse_members(contents, result)\n        self.iparser.parse(result)\n\n        #Now we can update the docstrings for the types. They rely on data\n        #extracted during parse_members() which is why they have to run\n        #separately over here.\n        for t in result.types:\n            self.tparser.update_docs(result.types[t], result)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting use dependencies from the innertext of a module.", "response": "def _parse_use(self, string):\n        \"\"\"Extracts use dependencies from the innertext of a module.\"\"\"\n        result = {}\n        for ruse in self.RE_USE.finditer(string):\n            #We also handle comments for individual use cases, the \"only\" section\n            #won't pick up any comments.\n            name = ruse.group(\"name\").split(\"!\")[0].strip()\n            if name.lower() == \"mpi\":\n                continue\n            \n            if ruse.group(\"only\"):\n                only = ruse.group(\"only\").split(\",\")\n                for method in only:\n                    key = \"{}.{}\".format(name, method.strip())\n                    self._dict_increment(result, key)\n            else:\n                self._dict_increment(result, name)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _dict_increment(self, dictionary, key):\n        if key in dictionary:\n            dictionary[key] += 1\n        else:\n            dictionary[key] = 1", "response": "Increments the value of the dictionary at the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_members(self, contents, module):\n        #We need to get hold of the text before the module's main CONTAINS keyword\n        #so that we don't find variables from executables and claim them as\n        #belonging to the module.\n        icontains = module.contains_index\n        ichar = module.charindex(icontains, 0)\n        module.preamble = module.refstring[:ichar]\n\n        #Get a dictionary of all the members in this module body\n        #We only want to look at variable definitions before the first type\n        lowest = ichar\n        remove = [] #Will use later below, see next comment\n        for t in module.types:\n            remove.append((module.types[t].start, module.types[t].end))\n            if module.types[t].start < lowest:\n                lowest = module.types[t].start\n\n        module.members.update(self.vparser.parse(contents[:lowest-(module.start + 10 + len(module.name))], module))\n\n        #The docstrings for these members will appear as member tags in the same\n        #preamble text. We can't use the entire preamble for this because member\n        #docs inside of a type declaration will show up as belonging to the\n        #module, when in fact, they don't.\n        remove.sort(key=lambda tup: tup[0])\n        retain = []\n        cur_end = 0\n        for rem in remove:\n            signature = module.refstring[rem[0]+1:rem[1]].index(\"\\n\") + 2\n            keep = module.refstring[cur_end:rem[0] + signature]\n            cur_end = rem[1]\n            retain.append(keep)\n\n        #If there weren't any types in the module, we still want to get at the docs in\n        #the preamble.\n        if len(remove) == 0:\n            retain = module.preamble\n\n        docsearch = \"\".join(retain)\n        module.predocs = self.docparser.parse_docs(docsearch, module)\n        if module.name in module.predocs:\n            #We can only do member docstrings if the module had internal docstrings\n            #that may  to members.\n            memdocs = self.docparser.to_doc(module.predocs[module.name][0], module.name)\n            remainingdocs = self.docparser.process_memberdocs(memdocs, module)\n            module.predocs[module.name] = remainingdocs", "response": "Extracts any module - level members from the code."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_regex(self):\n        self._RX_CONTAINS = r\"^\\s*contains[^\\n]*?$\"\n        self.RE_CONTAINS = re.compile(self._RX_CONTAINS, re.M | re.I)\n\n        #Setup a regex that can extract information about both functions and subroutines\n        self._RX_EXEC = r\"\\n[ \\t]*((?P<type>character|real|type|logical|integer|complex)?\" + \\\n                        r\"(?P<kind>\\([a-z0-9_]+\\))?)?((?P<modifiers>[\\w, \\t]+?))?[ \\t]*\" + \\\n                        r\"(?P<codetype>subroutine|function)\\s+(?P<name>[^(]+)\" + \\\n                        r\"\\s*\\((?P<parameters>[^)]*)\\)(?P<result>\\sresult\\([a-z0-9_]+\\))?\" + \\\n                        r\"(?P<contents>.+?)end\\s*(?P=codetype)\\s+(?P=name)\"\n        self.RE_EXEC = re.compile(self._RX_EXEC, re.DOTALL | re.I)\n        #Regex for the signature is almost identical to the full executable, but it doesn't\n        #look for any contents after the parameter list.\n        self._RX_SIG =  r\"((?P<type>character|real|type|logical|integer|complex)?\" + \\\n                        r\"(?P<kind>\\([a-z0-9_]+\\))?)?(,?(?P<modifiers>[^\\n]+?))?\\s*\" + \\\n                        r\"(?P<codetype>subroutine|function)\\s+(?P<name>[^(]+)\" + \\\n                        r\"\\s*\\((?P<parameters>[^)]*)\\)\"\n        self.RE_SIG = re.compile(self._RX_SIG, re.I)\n\n        #The contents of the executable already have any & line continuations\n        #removed, so we can use a simple multiline regex.\n        self._RX_ASSIGN = r\"^(?P<assignee>[^!<=\\n/]+?)=[^\\n]+?$\"\n        self.RE_ASSIGN = re.compile(self._RX_ASSIGN, re.M)\n\n        self._RX_DEPEND = r\"^\\s*(?P<sub>call\\s+)?(?P<exec>[a-z0-9_%]+\\s*\\([^\\n]+)$\"\n        self.RE_DEPEND = re.compile(self._RX_DEPEND, re.M | re. I)\n\n        self._RX_DEPCLEAN = r\"(?P<key>[a-z0-9_%]+)\\(\"\n        self.RE_DEPCLEAN = re.compile(self._RX_DEPCLEAN, re.I)\n\n        self._RX_CONST = '[^\"\\']+(?P<const>[\"\\'][^\\'\"]+[\"\\'])'\n        self.RE_CONST = re.compile(self._RX_CONST)\n\n        self._RX_COMMENTS = r'\\s*![^\\n\"]+?\\n'\n        self.RE_COMMENTS = re.compile(self._RX_COMMENTS)", "response": "Sets up compiled regex objects for parsing the executables from a module."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the specified line as a new version of the signature for element.", "response": "def parse_signature(self, statement, element, module=None):\n        \"\"\"Parses the specified line as a new version of the signature for 'element'.\n\n        :arg statement: the string that has the new signature.\n        :arg element: the code element whose signature will be changed.\n        \"\"\"\n        #If the signature changes, the user might not have had a chance to add the\n        #detailed member information for it yet. Here\n        #we will just update the modifiers and attributes. Also, since all the mods\n        #etc. will be overwritten, we don't need to handle replace separately.\n        smatch = self.RE_SIG.match(statement)\n        result = (None, None, None)\n        eresult = None\n\n        if smatch is not None:\n            name = smatch.group(\"name\").strip()\n            modifiers = smatch.group(\"modifiers\") or []\n            codetype = smatch.group(\"codetype\")\n\n            #If the exec is a function, we also may have a type and kind specified.\n            if codetype.lower() == \"function\":\n                dtype = smatch.group(\"type\")\n                kind = smatch.group(\"kind\")\n                if module is None:\n                    element.update(name, modifiers, dtype, kind)\n                else:\n                    eresult = Function(name, modifiers, dtype, kind, module)\n            else:\n                if module is None:\n                    element.update(name, modifiers)\n                else:\n                    eresult = Subroutine(name, modifiers, module)\n\n            #The parameter sets are actually driven by the body of the executable \n            #rather than the call signature. However, the declarations will be\n            #interpreted as members if we don't add the parameters to the ordered\n            #list of parameter names. Overwrite that list with the new names.\n            params = re.split(\"[\\s,]+\", smatch.group(\"parameters\").lower())\n            if eresult is None:\n                element.paramorder = params\n            else:\n                eresult.paramorder = params\n\n            result = (eresult, smatch.start(), smatch.end())\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_line(self, statement, element, mode):\n        if element.incomplete:\n            #We need to check for the end_token so we can close up the incomplete\n            #status for the instance.\n            if element.end_token in statement:\n                element.incomplete = False\n                return\n\n        #The line can either be related to an assignment or a dependency since\n        #those are the only relevant contents that aren't local variable definitions\n        #However if it is a local var definition, we need to process it with any\n        #doctags etc that it used. NOTE: doctags are parsed separately by the line\n        #parser at a higher level because of the XML.\n        self._process_assignments(element, statement, mode)\n        self._process_dependencies(element, statement, mode)\n        self._parse_members(statement, element, element.paramorder, mode)", "response": "Parses the contents of the specified line and adds its representation\n        to the specified element."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts all the subroutine and function definitions from the specified module.", "response": "def parse(self, module):\n        \"\"\"Extracts all the subroutine and function definitions from the specified module.\"\"\"\n        #Because of embedded types, we have to examine the entire module for\n        #executable definitions.\n        self.parse_block(module.refstring, module, module, 0)\n\n        #Now we can set the value of module.contains as the text after the start of\n        #the *first* non-embedded executable.\n        min_start = len(module.refstring)\n        for x in module.executables:\n            if module.executables[x].start < min_start:\n                min_start = module.executables[x].start\n\n        module.contains = module.refstring[min_start::]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting all executable definitions from the specified string and adds them to the specified parent.", "response": "def parse_block(self, contents, parent, module, depth):\n        \"\"\"Extracts all executable definitions from the specified string and adds\n        them to the specified parent.\"\"\"\n        for anexec in self.RE_EXEC.finditer(contents):\n            x = self._process_execs(anexec, parent, module)\n            parent.executables[x.name.lower()] = x\n            if  isinstance(parent, Module) and \"public\" in x.modifiers:\n                parent.publics[x.name.lower()] = 1\n            \n            #To handle the embedded executables, run this method recursively\n            self.parse_block(x.contents, x, module, depth + 1)\n\n        #Now that we have the executables, we can use them to compile a string\n        #that includes only documentation *external* to the executable definitions\n        #Because we enforce adding the name to 'end subroutine' statements etc.\n        #all the embedded executables haven't been parsed yet.\n        if len(parent.executables) > 0:\n            remove = []\n            for x in parent.executables:\n                remove.append((parent.executables[x].start, parent.executables[x].end))\n\n            remove.sort(key=lambda tup: tup[0])\n            retain = []\n            cur_end = 0\n            for rem in remove:\n                if \"\\n\" in contents[rem[0]+1:rem[1]]:\n                    signature = contents[rem[0]+1:rem[1]].index(\"\\n\") + 2\n                    keep = contents[cur_end:rem[0] + signature]\n                    cur_end = rem[1]\n                    retain.append(keep)\n\n            #Now we have a string of documentation segments and the signatures they\n            #decorate that only applies to the non-embedded subroutines\n            docsearch = \"\".join(retain)\n            docblocks = self.docparser.parse_docs(docsearch, parent)\n\n            #Process the decorating documentation for the executables including the\n            #parameter definitions.\n            for x in parent.executables:\n                self._process_docs(parent.executables[x], docblocks, \n                                   parent, module, docsearch)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _process_execs(self, execmatch, parent, module):\n        #Get the matches that must be present for every executable.\n        name = execmatch.group(\"name\").strip()\n        modifiers = execmatch.group(\"modifiers\")\n        if modifiers is None:\n            modifiers = []\n        else:\n            modifiers = re.split(\",[ \\t]*\", modifiers)\n        codetype = execmatch.group(\"codetype\")\n        params = re.split(\"[\\s,]+\", execmatch.group(\"parameters\"))\n        contents = execmatch.group(\"contents\")\n\n        #If the exec is a function, we also may have a type and kind specified.\n        if codetype.lower() == \"function\":\n            dtype = execmatch.group(\"type\")\n            kind = execmatch.group(\"kind\")\n            result = Function(name, modifiers, dtype, kind, parent)\n        else:\n            result = Subroutine(name, modifiers, parent)\n\n        #Set the regex start and end char indices\n        result.start, result.end = module.absolute_charindex(execmatch.string, execmatch.start(),\n                                                             execmatch.end())\n        result.contents = contents\n\n        #Now we can handle the rest which is common to both types of executable\n        #Extract a list of local variables\n        self._parse_members(contents, result, params)\n        if isinstance(result, Function):\n            #We need to handle the syntax for defining a function with result(variable)\n            #to specify the return type of the function.\n            if execmatch.group(\"result\") is not None:\n                resvar = execmatch.group(\"result\").lower().split(\"result(\")[1].replace(\")\", \"\")\n            else:\n                resvar = None\n            result.update_dtype(resvar)\n        \n        #Fortran allows lines to be continued using &. The easiest way\n        #to deal with this is to remove all of those before processing\n        #any of the regular expressions\n        decommented = \"\\n\".join([ self._depend_exec_clean(l) for l in contents.split(\"\\n\") ])\n        cleaned = re.sub(\"&\\s*\", \"\", decommented)\n\n        #Finally, process the dependencies. These are calls to functions and\n        #subroutines from within the executable body\n        self._process_dependencies(result, cleaned)\n        self._process_assignments(result, cleaned)\n        \n        return result", "response": "Processes the regex match of an executable from the match object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract all variable assignments from the body of the executable.", "response": "def _process_assignments(self, anexec, contents, mode=\"insert\"):\n        \"\"\"Extracts all variable assignments from the body of the executable.\n\n        :arg mode: for real-time update; either 'insert', 'delete' or 'replace'.\n        \"\"\"\n        for assign in self.RE_ASSIGN.finditer(contents):\n            assignee = assign.group(\"assignee\").strip()\n            target = re.split(r\"[(%\\s]\", assignee)[0].lower()\n\n            #We only want to include variables that we know are in the scope of the\n            #current executable. This excludes function calls etc. with optional params.\n            if target in self._intrinsic:\n                continue\n\n            if target in anexec.members or \\\n               target in anexec.parameters or \\\n               (isinstance(anexec, Function) and target.lower() == anexec.name.lower()):\n                if mode == \"insert\":\n                    anexec.add_assignment(re.split(r\"[(\\s]\", assignee)[0])\n                elif mode == \"delete\":\n                    #Remove the first instance of this assignment from the list\n                    try:\n                        index = element.assignments.index(assign)\n                        del element.assignments[index]\n                    except ValueError:\n                        #We didn't have anything to remove, but python\n                        pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts a list of subroutines and functions that are called from within this executable.", "response": "def _process_dependencies(self, anexec, contents, mode=\"insert\"):\n        \"\"\"Extracts a list of subroutines and functions that are called from\n        within this executable.\n\n        :arg mode: specifies whether the matches should be added, removed\n          or merged into the specified executable.\n        \"\"\"\n        #At this point we don't necessarily know which module the executables are\n        #in, so we just extract the names. Once all the modules in the library\n        #have been parsed, we can do the associations at that level for linking.\n        for dmatch in self.RE_DEPEND.finditer(contents):\n            isSubroutine = dmatch.group(\"sub\") is not None\n            if \"!\" in dmatch.group(\"exec\"):\n                execline = self._depend_exec_clean(dmatch.group(\"exec\"))\n            else:\n                execline = \"(\" + dmatch.group(\"exec\").split(\"!\")[0].replace(\",\", \", \") + \")\"\n\n            if not \"::\" in execline:\n                try:\n                    dependent = self.nester.parseString(execline).asList()[0]\n                except:\n                    msg.err(\"parsing executable dependency call {}\".format(anexec.name))\n                    msg.gen(\"\\t\" + execline)\n            \n                #Sometimes the parameter passed to a subroutine or function is \n                #itself a function call. These are always the first elements in\n                #their nested lists.\n                self._process_dependlist(dependent, anexec, isSubroutine, mode)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclean any string constants in the specified dependency text to remove any embedded! etc. that break the parsing.", "response": "def _depend_exec_clean(self, text):\n        \"\"\"Cleans any string constants in the specified dependency text to remove\n        embedded ! etc. that break the parsing.\n        \"\"\"\n        #First remove the escaped quotes, we will add them back at the end.\n        unquoted = text.replace('\"\"', \"_FORTPYDQ_\").replace(\"''\", \"_FORTPYSQ_\")\n        for cmatch in self.RE_CONST.finditer(unquoted):\n            string = cmatch.string[cmatch.start():cmatch.end()]\n            newstr = string.replace(\"!\", \"_FORTPYEX_\")\n            unquoted = unquoted.replace(string, newstr)\n\n        requote = unquoted.split(\"!\")[0].replace(\"_FORTPYDQ_\", '\"\"').replace(\"_FORTPYSQ_\", \"''\")\n        result = \"(\" + requote.replace(\"_FORTPYEX_\", \"!\").replace(\",\", \", \") + \")\"\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses a list of nested dependencies recursively.", "response": "def _process_dependlist(self, dependlist, anexec, isSubroutine, mode=\"insert\"):\n        \"\"\"Processes a list of nested dependencies recursively.\"\"\"\n        for i in range(len(dependlist)):\n            #Since we are looping over all the elements and some will\n            #be lists of parameters, we need to skip any items that are lists.\n            if isinstance(dependlist[i], list):\n                continue\n\n            key = dependlist[i].lower()\n            if len(dependlist) > i + 1:\n                has_params = isinstance(dependlist[i + 1], list)\n            else:\n                has_params = False\n\n            #Clean the dependency key to make sure we are only considering valid\n            #executable symbols.\n            cleanmatch = self.RE_DEPCLEAN.match(key + \"(\")\n            if not cleanmatch:\n                continue\n            else:\n                key = cleanmatch.group(\"key\")\n\n            #We need to handle if and do constructs etc. separately\n            if key not in [\"then\", \",\", \"\", \"elseif\"] and has_params \\\n               and not \"=\" in key and not \">\" in key:\n                if key in [\"if\", \"do\"]:\n                    self._process_dependlist(dependlist[i + 1], anexec, False, mode)\n                else:\n                    #This must be valid call to an executable, add it to the list\n                    #with its parameters and then process its parameters list\n                    #to see if there are more nested executables\n                    if mode == \"insert\":\n                        self._add_dependency(key, dependlist, i, isSubroutine, anexec)\n                    elif mode == \"delete\":\n                        #Try and find a dependency already in the executable that \n                        #has the same call signature; then remove it.\n                        self._remove_dependency(dependlist, i, isSubroutine, anexec)\n\n                    self._process_dependlist(dependlist[i + 1], anexec, False, mode)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the specified dependency from the executable if it exists and matches the call signature.", "response": "def _remove_dependency(self, dependlist, i, isSubroutine, anexec):\n        \"\"\"Removes the specified dependency from the executable if it exists\n        and matches the call signature.\"\"\"\n        if dependlist[i] in anexec.dependencies:\n            all_depends = anexec.dependencies[dependlist[i]]\n            if len(all_depends) > 0:\n                clean_args = all_depends[0].clean(dependlist[i + 1])\n                for idepend in range(len(all_depends)):\n                    #Make sure we match across all relevant parameters\n                    if (all_depends[idepend].argslist == clean_args\n                        and all_depends[idepend].isSubroutine == isSubroutine):\n                        del anexec.dependencies[dependlist[i]][idepend]\n                        #We only need to delete one, even if there are multiple\n                        #identical calls from elsewhere in the body.\n                        break"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _add_dependency(self, key, dependlist, i, isSubroutine, anexec):\n        #First determine if the reference is to a derived type variable\n        lkey = key.lower()\n        if \"%\" in key:\n            #Find the type of the base variable and then perform a tree\n            #search at the module level to determine if the final reference\n            #is a valid executable\n            base = key.split(\"%\")[0]\n            ftype = None\n            if base in anexec.members and anexec.members[base].is_custom:\n                ftype = anexec.members[base].kind\n            elif base in anexec.parameters and anexec.parameters[base].is_custom:\n                ftype = anexec.parameters[base].kind\n\n            if ftype is not None:\n                end = anexec.module.type_search(ftype, key)\n                if end is not None and isinstance(end, TypeExecutable):\n                    #We have to overwrite the key to include the actual name of the type\n                    #that is being referenced instead of the local name of its variable.\n                    tname = \"{}%{}\".format(ftype, '%'.join(key.split('%')[1:]))\n                    d = Dependency(tname, dependlist[i + 1], isSubroutine, anexec)\n                    anexec.add_dependency(d)\n                    \n        elif lkey not in [\"for\", \"forall\", \"do\"]:\n            #This is a straight forward function/subroutine call, make sure that\n            #the symbol is not a local variable or parameter, then add it\n            if not lkey in anexec.members and not lkey in anexec.parameters \\\n               and not lkey in self._intrinsic:                \n                #One issue with the logic until now is that some one-line statements\n                #like \"if (cond) call subroutine\" don't trigger the subroutine flag\n                #of the dependency.\n                if dependlist[i-1] == \"call\":\n                    isSubroutine = True\n                d = Dependency(dependlist[i], dependlist[i + 1], isSubroutine, anexec)\n                anexec.add_dependency(d)", "response": "Adds a dependency to the list of dependencies that are not in the list of dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing the docstrings from the docblocks with their parameters.", "response": "def _process_docs(self, anexec, docblocks, parent, module, docsearch):\n        \"\"\"Associates the docstrings from the docblocks with their parameters.\"\"\"\n        #The documentation for the parameters is stored outside of the executable\n        #We need to get hold of them from docblocks from the parent text\n        key = \"{}.{}\".format(parent.name, anexec.name)\n        if key in docblocks:\n            docs = self.docparser.to_doc(docblocks[key][0], anexec.name)\n            anexec.docstart, anexec.docend = (docblocks[key][1], docblocks[key][2])\n            self.docparser.process_execdocs(docs, anexec, key)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_members(self, contents, anexec, params, mode=\"insert\"):\n        #First get the variables declared in the body of the executable, these can\n        #be either locals or parameter declarations.\n        members = self.vparser.parse(contents, anexec)\n\n        #If the name matches one in the parameter list, we can connect them\n        for param in list(params):\n            lparam = param.lower()\n            if lparam in members:\n                if mode == \"insert\" and not lparam in anexec.parameters:\n                    anexec.add_parameter(members[lparam])\n                elif mode == \"delete\":\n                    anexec.remove_parameter(members[lparam])\n            \n        #The remaining members that aren't in parameters are the local variables\n        for key in members:\n            if mode == \"insert\":\n                if not key.lower() in anexec.parameters:\n                    anexec.members[key] = members[key]\n            elif mode == \"delete\" and key in anexec.members:\n                del anexec.members[key]\n\n        #Next we need to get hold of the docstrings for these members\n        if mode == \"insert\":\n            memdocs = self.docparser.parse_docs(contents, anexec)\n            if anexec.name in memdocs:\n                docs = self.docparser.to_doc(memdocs[anexec.name][0], anexec.name)\n                self.docparser.process_memberdocs(docs, anexec)\n\n            #Also process the embedded types and executables who may have\n            #docstrings just like regular executables/types do.\n            self.docparser.process_embedded(memdocs, anexec)", "response": "Parses the members of the specified executable and adds them to the executable object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_sidebar(self, character_page):\n    character_info = {}\n\n    error_tag = character_page.find(u'div', {'class': 'badresult'})\n    if error_tag:\n      # MAL says the character does not exist.\n      raise InvalidCharacterError(self.id)\n\n    try:\n      full_name_tag = character_page.find(u'div', {'id': 'contentWrapper'}).find(u'h1')\n      if not full_name_tag:\n        # Page is malformed.\n        raise MalformedCharacterPageError(self.id, html, message=\"Could not find title div\")\n      character_info[u'full_name'] = full_name_tag.text.strip()\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    info_panel_first = character_page.find(u'div', {'id': 'content'}).find(u'table').find(u'td')\n\n    try:\n      picture_tag = info_panel_first.find(u'img')\n      character_info[u'picture'] = picture_tag.get(u'src').decode('utf-8')\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      # assemble animeography for this character.\n      character_info[u'animeography'] = {}\n      animeography_header = info_panel_first.find(u'div', text=u'Animeography')\n      if animeography_header:\n        animeography_table = animeography_header.find_next_sibling(u'table')\n        for row in animeography_table.find_all(u'tr'):\n          # second column has anime info.\n          info_col = row.find_all(u'td')[1]\n          anime_link = info_col.find(u'a')\n          link_parts = anime_link.get(u'href').split(u'/')\n          # of the form: /anime/1/Cowboy_Bebop\n          anime = self.session.anime(int(link_parts[2])).set({'title': anime_link.text})\n          role = info_col.find(u'small').text\n          character_info[u'animeography'][anime] = role\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      # assemble mangaography for this character.\n      character_info[u'mangaography'] = {}\n      mangaography_header = info_panel_first.find(u'div', text=u'Mangaography')\n      if mangaography_header:\n        mangaography_table = mangaography_header.find_next_sibling(u'table')\n        for row in mangaography_table.find_all(u'tr'):\n          # second column has manga info.\n          info_col = row.find_all(u'td')[1]\n          manga_link = info_col.find(u'a')\n          link_parts = manga_link.get(u'href').split(u'/')\n          # of the form: /manga/1/Cowboy_Bebop\n          manga = self.session.manga(int(link_parts[2])).set({'title': manga_link.text})\n          role = info_col.find(u'small').text\n          character_info[u'mangaography'][manga] = role\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      num_favorites_node = info_panel_first.find(text=re.compile(u'Member Favorites: '))\n      character_info[u'num_favorites'] = int(num_favorites_node.strip().split(u': ')[1])\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return character_info", "response": "Parses the DOM and returns character attributes in the sidebar."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(self, character_page):\n    character_info = self.parse_sidebar(character_page)\n\n    second_col = character_page.find(u'div', {'id': 'content'}).find(u'table').find(u'tr').find_all(u'td', recursive=False)[1]\n    name_elt = second_col.find(u'div', {'class': 'normal_header'})\n\n    try:\n      name_jpn_node = name_elt.find(u'small')\n      if name_jpn_node:\n        character_info[u'name_jpn'] = name_jpn_node.text[1:-1]\n      else:\n        character_info[u'name_jpn'] = None\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      name_elt.find(u'span').extract()\n      character_info[u'name'] = name_elt.text.rstrip()\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      description_elts = []\n      curr_elt = name_elt.nextSibling\n      while True:\n        if curr_elt.name not in [None, u'br']:\n          break\n        description_elts.append(unicode(curr_elt))\n        curr_elt = curr_elt.nextSibling\n      character_info[u'description'] = ''.join(description_elts)\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      character_info[u'voice_actors'] = {}\n      voice_actors_header = second_col.find(u'div', text=u'Voice Actors')\n      if voice_actors_header:\n        voice_actors_table = voice_actors_header.find_next_sibling(u'table')\n        for row in voice_actors_table.find_all(u'tr'):\n          # second column has va info.\n          info_col = row.find_all(u'td')[1]\n          voice_actor_link = info_col.find(u'a')\n          name = ' '.join(reversed(voice_actor_link.text.split(u', ')))\n          link_parts = voice_actor_link.get(u'href').split(u'/')\n          # of the form: /people/82/Romi_Park\n          person = self.session.person(int(link_parts[2])).set({'name': name})\n          language = info_col.find(u'small').text\n          character_info[u'voice_actors'][person] = language\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return character_info", "response": "Parses the DOM and returns the character attributes in the main - content area."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_favorites(self, favorites_page):\n    character_info = self.parse_sidebar(favorites_page)\n    second_col = favorites_page.find(u'div', {'id': 'content'}).find(u'table').find(u'tr').find_all(u'td', recursive=False)[1]\n\n    try:\n      character_info[u'favorites'] = []\n      favorite_links = second_col.find_all('a', recursive=False)\n      for link in favorite_links:\n        # of the form /profile/shaldengeki\n        character_info[u'favorites'].append(self.session.user(username=link.text))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return character_info", "response": "Parses the DOM and returns character favorites attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_pictures(self, picture_page):\n    character_info = self.parse_sidebar(picture_page)\n    second_col = picture_page.find(u'div', {'id': 'content'}).find(u'table').find(u'tr').find_all(u'td', recursive=False)[1]\n\n    try:\n      picture_table = second_col.find(u'table', recursive=False)\n      character_info[u'pictures'] = []\n      if picture_table:\n        character_info[u'pictures'] = map(lambda img: img.get(u'src').decode('utf-8'), picture_table.find_all(u'img'))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return character_info", "response": "Parses the DOM and returns character pictures attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_clubs(self, clubs_page):\n    character_info = self.parse_sidebar(clubs_page)\n    second_col = clubs_page.find(u'div', {'id': 'content'}).find(u'table').find(u'tr').find_all(u'td', recursive=False)[1]\n\n    try:\n      clubs_header = second_col.find(u'div', text=u'Related Clubs')\n      character_info[u'clubs'] = []\n      if clubs_header:\n        curr_elt = clubs_header.nextSibling\n        while curr_elt is not None:\n          if curr_elt.name == u'div':\n            link = curr_elt.find(u'a')\n            club_id = int(re.match(r'/clubs\\.php\\?cid=(?P<id>[0-9]+)', link.get(u'href')).group(u'id'))\n            num_members = int(re.match(r'(?P<num>[0-9]+) members', curr_elt.find(u'small').text).group(u'num'))\n            character_info[u'clubs'].append(self.session.club(club_id).set({'name': link.text, 'num_members': num_members}))\n          curr_elt = curr_elt.nextSibling\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return character_info", "response": "Parses the DOM and returns character clubs attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self):\n    character = self.session.session.get(u'http://myanimelist.net/character/' + str(self.id)).text\n    self.set(self.parse(utilities.get_clean_dom(character)))\n    return self", "response": "Fetches the MAL character page and sets the current character s attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_favorites(self):\n    character = self.session.session.get(u'http://myanimelist.net/character/' + str(self.id) + u'/' + utilities.urlencode(self.name) + u'/favorites').text\n    self.set(self.parse_favorites(utilities.get_clean_dom(character)))\n    return self", "response": "Fetches the MAL character favorites page and sets the current character s favorites attributes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_pictures(self):\n    character = self.session.session.get(u'http://myanimelist.net/character/' + str(self.id) + u'/' + utilities.urlencode(self.name) + u'/pictures').text\n    self.set(self.parse_pictures(utilities.get_clean_dom(character)))\n    return self", "response": "Fetches the MAL character pictures page and sets the current character s pictures attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch the MAL character clubs page and sets the current character s clubs attributes.", "response": "def load_clubs(self):\n    \"\"\"Fetches the MAL character clubs page and sets the current character's clubs attributes.\n\n    :rtype: :class:`.Character`\n    :return: Current character object.\n\n    \"\"\"\n    character = self.session.session.get(u'http://myanimelist.net/character/' + str(self.id) + u'/' + utilities.urlencode(self.name) + u'/clubs').text\n    self.set(self.parse_clubs(utilities.get_clean_dom(character)))\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate words of different length without storing them into memory.", "response": "def generate(self, minlen, maxlen):\n        \"\"\"\n        Generates words of different length without storing\n        them into memory, enforced by itertools.product\n        \"\"\"\n        if minlen < 1 or maxlen < minlen:\n            raise ValueError()\n\n        for cur in range(minlen, maxlen + 1):\n            # string product generator\n            str_generator = product(self.charset, repeat=cur)\n            for each in str_generator:\n                # yield the produced word\n                yield ''.join(each)+self.delimiter"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate the list of all the available user - specified entries based on a given pattern", "response": "def generate_with_pattern(self, pattern=None):\n        \"\"\"\n        Algorithm that creates the list\n        based on a given pattern\n        The pattern must be like string format patter:\n        e.g: a@b will match an 'a' follow by any character follow by a 'b'\n        \"\"\"\n\n        curlen = utils.get_pattern_length(pattern)\n        if curlen > 0:\n            str_generator = product(self.charset, repeat=curlen)\n            pattern = pattern + self.delimiter\n            fstring = utils.pattern_to_fstring(pattern)\n            for each in str_generator:\n                yield fstring.format(*each)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_username_from_user_id(session, user_id):\n    comments_page = session.session.get(u'http://myanimelist.net/comments.php?' + urllib.urlencode({'id': int(user_id)})).text\n    comments_page = bs4.BeautifulSoup(comments_page)\n    username_elt = comments_page.find('h1')\n    if \"'s Comments\" not in username_elt.text:\n      raise InvalidUserError(user_id, message=\"Invalid user ID given when looking up username\")\n    return username_elt.text.replace(\"'s Comments\", \"\")", "response": "Look up a MAL username s user ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the DOM and returns the user attributes in the MAL user page s sidebar.", "response": "def parse_sidebar(self, user_page):\n    \"\"\"Parses the DOM and returns user attributes in the sidebar.\n\n    :type user_page: :class:`bs4.BeautifulSoup`\n    :param user_page: MAL user page's DOM\n\n    :rtype: dict\n    :return: User attributes\n\n    :raises: :class:`.InvalidUserError`, :class:`.MalformedUserPageError`\n    \"\"\"\n    user_info = {}\n    # if MAL says the series doesn't exist, raise an InvalidUserError.\n    error_tag = user_page.find(u'div', {u'class': u'badresult'})\n    if error_tag:\n        raise InvalidUserError(self.username)\n\n    try:\n      username_tag = user_page.find(u'div', {u'id': u'contentWrapper'}).find(u'h1')\n      if not username_tag.find(u'div'):\n        # otherwise, raise a MalformedUserPageError.\n        raise MalformedUserPageError(self.username, user_page, message=u\"Could not find title div\")\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    info_panel_first = user_page.find(u'div', {u'id': u'content'}).find(u'table').find(u'td')\n\n    try:\n      picture_tag = info_panel_first.find(u'img')\n      user_info[u'picture'] = picture_tag.get(u'src').decode('utf-8')\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      # the user ID is always present in the blogfeed link.\n      all_comments_link = info_panel_first.find(u'a', text=u'Blog Feed')\n      user_info[u'id'] = int(all_comments_link.get(u'href').split(u'&id=')[1])\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    infobar_headers = info_panel_first.find_all(u'div', {u'class': u'normal_header'})\n    if infobar_headers:\n      try:\n        favorite_anime_header = infobar_headers[0]\n        if u'Favorite Anime' in favorite_anime_header.text:\n          user_info[u'favorite_anime'] = []\n          favorite_anime_table = favorite_anime_header.nextSibling.nextSibling\n          if favorite_anime_table.name == u'table':\n            for row in favorite_anime_table.find_all(u'tr'):\n              cols = row.find_all(u'td')\n              anime_link = cols[1].find(u'a')\n              link_parts = anime_link.get(u'href').split(u'/')\n              # of the form /anime/467/Ghost_in_the_Shell:_Stand_Alone_Complex\n              user_info[u'favorite_anime'].append(self.session.anime(int(link_parts[2])).set({u'title': anime_link.text}))\n      except:\n        if not self.session.suppress_parse_exceptions:\n          raise\n\n      try:\n        favorite_manga_header = infobar_headers[1]\n        if u'Favorite Manga' in favorite_manga_header.text:\n          user_info[u'favorite_manga'] = []\n          favorite_manga_table = favorite_manga_header.nextSibling.nextSibling\n          if favorite_manga_table.name == u'table':\n            for row in favorite_manga_table.find_all(u'tr'):\n              cols = row.find_all(u'td')\n              manga_link = cols[1].find(u'a')\n              link_parts = manga_link.get(u'href').split(u'/')\n              # of the form /manga/467/Ghost_in_the_Shell:_Stand_Alone_Complex\n              user_info[u'favorite_manga'].append(self.session.manga(int(link_parts[2])).set({u'title': manga_link.text}))\n      except:\n        if not self.session.suppress_parse_exceptions:\n          raise\n\n      try:\n        favorite_character_header = infobar_headers[2]\n        if u'Favorite Characters' in favorite_character_header.text:\n          user_info[u'favorite_characters'] = {}\n          favorite_character_table = favorite_character_header.nextSibling.nextSibling\n          if favorite_character_table.name == u'table':\n            for row in favorite_character_table.find_all(u'tr'):\n              cols = row.find_all(u'td')\n              character_link = cols[1].find(u'a')\n              link_parts = character_link.get(u'href').split(u'/')\n              # of the form /character/467/Ghost_in_the_Shell:_Stand_Alone_Complex\n              character = self.session.character(int(link_parts[2])).set({u'title': character_link.text})\n\n              media_link = cols[1].find(u'div').find(u'a')\n              link_parts = media_link.get(u'href').split(u'/')\n              # of the form /anime|manga/467\n              anime = getattr(self.session, link_parts[1])(int(link_parts[2])).set({u'title': media_link.text})\n\n              user_info[u'favorite_characters'][character] = anime\n      except:\n        if not self.session.suppress_parse_exceptions:\n          raise\n\n      try:\n        favorite_people_header = infobar_headers[3]\n        if u'Favorite People' in favorite_people_header.text:\n          user_info[u'favorite_people'] = []\n          favorite_person_table = favorite_people_header.nextSibling.nextSibling\n          if favorite_person_table.name == u'table':\n            for row in favorite_person_table.find_all(u'tr'):\n              cols = row.find_all(u'td')\n              person_link = cols[1].find(u'a')\n              link_parts = person_link.get(u'href').split(u'/')\n              # of the form /person/467/Ghost_in_the_Shell:_Stand_Alone_Complex\n              user_info[u'favorite_people'].append(self.session.person(int(link_parts[2])).set({u'title': person_link.text}))\n      except:\n        if not self.session.suppress_parse_exceptions:\n          raise\n    return user_info"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing the DOM and returns the user attributes in the main - content area.", "response": "def parse(self, user_page):\n    \"\"\"Parses the DOM and returns user attributes in the main-content area.\n\n    :type user_page: :class:`bs4.BeautifulSoup`\n    :param user_page: MAL user page's DOM\n\n    :rtype: dict\n    :return: User attributes.\n\n    \"\"\"\n    user_info = self.parse_sidebar(user_page)\n\n    section_headings = user_page.find_all(u'div', {u'class': u'normal_header'})\n\n    # parse general details.\n    # we have to work from the bottom up, since there's broken HTML after every header.\n    last_online_elt = user_page.find(u'td', text=u'Last Online')\n    if last_online_elt:\n      try:\n        general_table = last_online_elt.parent.parent\n      except:\n        if not self.session.suppress_parse_exceptions:\n          raise\n\n      if general_table and general_table.name == u'table':\n        try:\n          last_online_elt = general_table.find(u'td', text=u'Last Online')\n          if last_online_elt:\n            user_info[u'last_online'] = utilities.parse_profile_date(last_online_elt.findNext(u'td').text)\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          gender = general_table.find(u'td', text=u'Gender')\n          if gender:\n            user_info[u'gender'] = gender.findNext(u'td').text\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          birthday = general_table.find(u'td', text=u'Birthday')\n          if birthday:\n            user_info[u'birthday'] = utilities.parse_profile_date(birthday.findNext(u'td').text)\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          location = general_table.find(u'td', text=u'Location')\n          if location:\n            user_info[u'location'] = location.findNext(u'td').text\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          website = general_table.find(u'td', text=u'Website')\n          if website:\n            user_info[u'website'] = website.findNext(u'td').text\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          join_date = general_table.find(u'td', text=u'Join Date')\n          if join_date:\n            user_info[u'join_date'] = utilities.parse_profile_date(join_date.findNext(u'td').text)\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          access_rank = general_table.find(u'td', text=u'Access Rank')\n          if access_rank:\n            user_info[u'access_rank'] = access_rank.findNext(u'td').text\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          anime_list_views = general_table.find(u'td', text=u'Anime List Views')\n          if anime_list_views:\n            user_info[u'anime_list_views'] = int(anime_list_views.findNext(u'td').text.replace(',', ''))\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          manga_list_views = general_table.find(u'td', text=u'Manga List Views')\n          if manga_list_views:\n            user_info[u'manga_list_views'] = int(manga_list_views.findNext(u'td').text.replace(',', ''))\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          num_comments = general_table.find(u'td', text=u'Comments')\n          if num_comments:\n            user_info[u'num_comments'] = int(num_comments.findNext(u'td').text.replace(',', ''))\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n        try:\n          num_forum_posts = general_table.find(u'td', text=u'Forum Posts')\n          if num_forum_posts:\n            user_info[u'num_forum_posts'] = int(num_forum_posts.findNext(u'td').text.replace(\" (Find All)\", \"\").replace(',', ''))\n        except:\n          if not self.session.suppress_parse_exceptions:\n            raise\n\n    try:\n      # last list updates.\n      list_updates_header = filter(lambda x: u'Last List Updates' in x.text, section_headings)\n      if list_updates_header:\n        list_updates_header = list_updates_header[0]\n        list_updates_table = list_updates_header.findNext(u'table')\n        if list_updates_table:\n          user_info[u'last_list_updates'] = {}\n          for row in list_updates_table.find_all(u'tr'):\n            cols = row.find_all(u'td')\n            info_col = cols[1]\n            media_link = info_col.find(u'a')\n            link_parts = media_link.get(u'href').split(u'/')\n            # of the form /(anime|manga)/10087/Fate/Zero\n            if link_parts[1] == u'anime':\n              media = self.session.anime(int(link_parts[2])).set({u'title': media_link.text})\n            else:\n              media = self.session.manga(int(link_parts[2])).set({u'title': media_link.text})\n            list_update = {}\n            progress_div = info_col.find(u'div', {u'class': u'spaceit_pad'})\n            if progress_div:\n              progress_match = re.match(r'(?P<status>[A-Za-z]+)(  at (?P<episodes>[0-9]+) of (?P<total_episodes>[0-9]+))?', progress_div.text).groupdict()\n              list_update[u'status'] = progress_match[u'status']\n              if progress_match[u'episodes'] is None:\n                list_update[u'episodes'] = None\n              else:\n                list_update[u'episodes'] = int(progress_match[u'episodes'])\n              if progress_match[u'total_episodes'] is None:\n                list_update[u'total_episodes'] = None\n              else:\n                list_update[u'total_episodes'] = int(progress_match[u'total_episodes'])\n            time_div = info_col.find(u'div', {u'class': u'lightLink'})\n            if time_div:\n              list_update[u'time'] = utilities.parse_profile_date(time_div.text)\n            user_info[u'last_list_updates'][media] = list_update\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    lower_section_headings = user_page.find_all(u'h2')\n    # anime stats.\n    try:\n      anime_stats_header = filter(lambda x: u'Anime Stats' in x.text, lower_section_headings)\n      if anime_stats_header:\n        anime_stats_header = anime_stats_header[0]\n        anime_stats_table = anime_stats_header.findNext(u'table')\n        if anime_stats_table:\n          user_info[u'anime_stats'] = {}\n          for row in anime_stats_table.find_all(u'tr'):\n            cols = row.find_all(u'td')\n            value = cols[1].text\n            if cols[1].find(u'span', {u'title': u'Days'}):\n              value = round(float(value), 1)\n            else:\n              value = int(value)\n            user_info[u'anime_stats'][cols[0].text] = value\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      # manga stats.\n      manga_stats_header = filter(lambda x: u'Manga Stats' in x.text, lower_section_headings)\n      if manga_stats_header:\n        manga_stats_header = manga_stats_header[0]\n        manga_stats_table = manga_stats_header.findNext(u'table')\n        if manga_stats_table:\n          user_info[u'manga_stats'] = {}\n          for row in manga_stats_table.find_all(u'tr'):\n            cols = row.find_all(u'td')\n            value = cols[1].text\n            if cols[1].find(u'span', {u'title': u'Days'}):\n              value = round(float(value), 1)\n            else:\n              value = int(value)\n            user_info[u'manga_stats'][cols[0].text] = value\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      about_header = filter(lambda x: u'About' in x.text, section_headings)\n      if about_header:\n        about_header = about_header[0]\n        user_info[u'about'] = about_header.findNext(u'div').text.strip()\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return user_info"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_reviews(self, reviews_page):\n    user_info = self.parse_sidebar(reviews_page)\n    second_col = reviews_page.find(u'div', {u'id': u'content'}).find(u'table').find(u'tr').find_all(u'td', recursive=False)[1]\n\n    try:\n      user_info[u'reviews'] = {}\n      reviews = second_col.find_all(u'div', {u'class': u'borderDark'}, recursive=False)\n      if reviews:\n        for row in reviews:\n          review_info = {}\n          try:\n            (meta_elt, review_elt) = row.find_all(u'div', recursive=False)[0:2]\n          except ValueError:\n            raise\n          meta_rows = meta_elt.find_all(u'div', recursive=False)\n          review_info[u'date'] = utilities.parse_profile_date(meta_rows[0].find(u'div').text)\n          media_link = meta_rows[0].find(u'a')\n          link_parts = media_link.get(u'href').split(u'/')\n          # of the form /(anime|manga)/9760/Hoshi_wo_Ou_Kodomo\n          media = getattr(self.session, link_parts[1])(int(link_parts[2])).set({u'title': media_link.text})\n\n          helpfuls = meta_rows[1].find(u'span', recursive=False)\n          helpful_match = re.match(r'(?P<people_helped>[0-9]+) of (?P<people_total>[0-9]+)', helpfuls.text).groupdict()\n          review_info[u'people_helped'] = int(helpful_match[u'people_helped'])\n          review_info[u'people_total'] = int(helpful_match[u'people_total'])\n\n          consumption_match = re.match(r'(?P<media_consumed>[0-9]+) of (?P<media_total>[0-9?]+)', meta_rows[2].text).groupdict()\n          review_info[u'media_consumed'] = int(consumption_match[u'media_consumed'])\n          if consumption_match[u'media_total'] == u'?':\n            review_info[u'media_total'] = None\n          else:\n            review_info[u'media_total'] = int(consumption_match[u'media_total'])\n\n          review_info[u'rating'] = int(meta_rows[3].find(u'div').text.replace(u'Overall Rating: ', ''))\n\n          for x in review_elt.find_all([u'div', 'a']):\n            x.extract()\n          review_info[u'text'] = review_elt.text.strip()\n          user_info[u'reviews'][media] = review_info\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return user_info", "response": "Parses the DOM and returns user reviews attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_recommendations(self, recommendations_page):\n    user_info = self.parse_sidebar(recommendations_page)\n    second_col = recommendations_page.find(u'div', {u'id': u'content'}).find(u'table').find(u'tr').find_all(u'td', recursive=False)[1]\n\n    try:\n      recommendations = second_col.find_all(u\"div\", {u\"class\": u\"spaceit borderClass\"})\n      if recommendations:\n        user_info[u'recommendations'] = {}\n        for row in recommendations[1:]:\n          anime_table = row.find(u'table')\n          animes = anime_table.find_all(u'td')\n          liked_media_link = animes[0].find(u'a', recursive=False)\n          link_parts = liked_media_link.get(u'href').split(u'/')\n          # of the form /anime|manga/64/Rozen_Maiden\n          liked_media = getattr(self.session, link_parts[1])(int(link_parts[2])).set({u'title': liked_media_link.text})\n\n          recommended_media_link = animes[1].find(u'a', recursive=False)\n          link_parts = recommended_media_link.get(u'href').split(u'/')\n          # of the form /anime|manga/64/Rozen_Maiden\n          recommended_media = getattr(self.session, link_parts[1])(int(link_parts[2])).set({u'title': recommended_media_link.text})\n\n          recommendation_text = row.find(u'p').text\n\n          recommendation_menu = row.find(u'div', recursive=False)\n          utilities.extract_tags(recommendation_menu)\n          recommendation_date = utilities.parse_profile_date(recommendation_menu.text.split(u' - ')[1])\n\n          user_info[u'recommendations'][liked_media] = {link_parts[1]: recommended_media, 'text': recommendation_text, 'date': recommendation_date}\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return user_info", "response": "Parses the DOM and returns user recommendations attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_clubs(self, clubs_page):\n    user_info = self.parse_sidebar(clubs_page)\n    second_col = clubs_page.find(u'div', {u'id': u'content'}).find(u'table').find(u'tr').find_all(u'td', recursive=False)[1]\n\n    try:\n      user_info[u'clubs'] = []\n\n      club_list = second_col.find(u'ol')\n      if club_list:\n        clubs = club_list.find_all(u'li')\n        for row in clubs:\n          club_link = row.find(u'a')\n          link_parts = club_link.get(u'href').split(u'?cid=')\n          # of the form /clubs.php?cid=10178\n          user_info[u'clubs'].append(self.session.club(int(link_parts[1])).set({u'name': club_link.text}))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n    return user_info", "response": "Parses the DOM and returns user clubs attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the DOM and returns user friends attributes.", "response": "def parse_friends(self, friends_page):\n    \"\"\"Parses the DOM and returns user friends attributes.\n\n    :type friends_page: :class:`bs4.BeautifulSoup`\n    :param friends_page: MAL user friends page's DOM\n\n    :rtype: dict\n    :return: User friends attributes.\n\n    \"\"\"\n    user_info = self.parse_sidebar(friends_page)\n    second_col = friends_page.find(u'div', {u'id': u'content'}).find(u'table').find(u'tr').find_all(u'td', recursive=False)[1]\n\n    try:\n      user_info[u'friends'] = {}\n\n      friends = second_col.find_all(u'div', {u'class': u'friendHolder'})\n      if friends:\n        for row in friends:\n          block = row.find(u'div', {u'class': u'friendBlock'})\n          cols = block.find_all(u'div')\n\n          friend_link = cols[1].find(u'a')\n          friend = self.session.user(friend_link.text)\n\n          friend_info = {}\n          if len(cols) > 2 and cols[2].text != u'':\n            friend_info[u'last_active'] = utilities.parse_profile_date(cols[2].text.strip())\n\n          if len(cols) > 3 and cols[3].text != u'':\n            friend_info[u'since'] = utilities.parse_profile_date(cols[3].text.replace(u'Friends since', '').strip())\n          user_info[u'friends'][friend] = friend_info\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return user_info"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching the MAL user page and sets the current user s attributes.", "response": "def load(self):\n    \"\"\"Fetches the MAL user page and sets the current user's attributes.\n\n    :rtype: :class:`.User`\n    :return: Current user object.\n\n    \"\"\"\n    user_profile = self.session.session.get(u'http://myanimelist.net/profile/' + utilities.urlencode(self.username)).text\n    self.set(self.parse(utilities.get_clean_dom(user_profile)))\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching the MAL user reviews page and sets the current user s reviews attributes.", "response": "def load_reviews(self):\n    \"\"\"Fetches the MAL user reviews page and sets the current user's reviews attributes.\n\n    :rtype: :class:`.User`\n    :return: Current user object.\n\n    \"\"\"\n    page = 0\n    # collect all reviews over all pages.\n    review_collection = []\n    while True:\n      user_reviews = self.session.session.get(u'http://myanimelist.net/profile/' + utilities.urlencode(self.username) + u'/reviews&' + urllib.urlencode({u'p': page})).text\n      parse_result = self.parse_reviews(utilities.get_clean_dom(user_reviews))\n      if page == 0:\n        # only set attributes once the first time around.\n        self.set(parse_result)\n      if len(parse_result[u'reviews']) == 0:\n        break\n      review_collection.append(parse_result[u'reviews'])\n      page += 1\n\n    # merge the review collections into one review dict, and set it.\n    self.set({\n      'reviews': {k: v for d in review_collection for k,v in d.iteritems()}\n    })\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch the MAL user recommendations page and sets the current user s recommendations attributes.", "response": "def load_recommendations(self):\n    \"\"\"Fetches the MAL user recommendations page and sets the current user's recommendations attributes.\n\n    :rtype: :class:`.User`\n    :return: Current user object.\n\n    \"\"\"\n    user_recommendations = self.session.session.get(u'http://myanimelist.net/profile/' + utilities.urlencode(self.username) + u'/recommendations').text\n    self.set(self.parse_recommendations(utilities.get_clean_dom(user_recommendations)))\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_clubs(self):\n    user_clubs = self.session.session.get(u'http://myanimelist.net/profile/' + utilities.urlencode(self.username) + u'/clubs').text\n    self.set(self.parse_clubs(utilities.get_clean_dom(user_clubs)))\n    return self", "response": "Fetches the MAL user clubs page and sets the current user s clubs attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_friends(self):\n    user_friends = self.session.session.get(u'http://myanimelist.net/profile/' + utilities.urlencode(self.username) + u'/friends').text\n    self.set(self.parse_friends(utilities.get_clean_dom(user_friends)))\n    return self", "response": "Fetches the MAL user friends page and sets the current user s friends attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint text using color or standard print depending on the value of nocolor.", "response": "def printer(text, color=None, **kwargs):\n    \"\"\"Prints using color or standard print() depending on the value\n    of 'nocolor'.\n    \"\"\"\n    if nocolor:\n        # import sys\n        # sys.stdout.write(text + \"\" if (\"end\" in kwargs and kwargs[\"end\"] == \"\") else '\\n')\n        # sys.stdout.flush()\n        print(text, **kwargs)\n    else:\n        if color is None:\n            cprint(text, **kwargs)\n        else:\n            cprint(text, color, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting a line of text in arbitrary colors specified by the numeric values contained in msg. cenum dictionary.", "response": "def arb(text, cols, split):\n    \"\"\"Prints a line of text in arbitrary colors specified by the numeric\n    values contained in msg.cenum dictionary.\n    \"\"\"\n    stext = text if text[-1] != split else text[0:-1]\n    words = stext.split(split)\n    for i, word in enumerate(words):\n        col = icols[cols[i]]\n        printer(word, col, end=\"\")\n        if i < len(words)-1:\n            printer(split, end=\"\")\n        else:\n            printer(split)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef will_print(level=1):\n    if level == 1:\n        #We only affect printability using the quiet setting.\n        return quiet is None or quiet == False\n    else:\n        return ((isinstance(verbosity, int) and level <= verbosity) or\n                (isinstance(verbosity, bool) and verbosity == True))", "response": "Returns True if the current global status of messaging will print a\n    message using any of the printing functions in this module."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints a message as a warning ; prepends the WARNING message to the current base node.", "response": "def warn(msg, level=0, prefix=True):\n    \"\"\"Prints the specified message as a warning; prepends \"WARNING\" to\n    the message, so that can be left off.\n    \"\"\"\n    if will_print(level):\n        printer((\"WARNING: \" if prefix else \"\") + msg, \"yellow\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting the specified message as an error ; prepends ERROR to if the verbosity is not None", "response": "def err(msg, level=-1, prefix=True):\n    \"\"\"Prints the specified message as an error; prepends \"ERROR\" to\n    the message, so that can be left off.\n    \"\"\"\n    if will_print(level) or verbosity is None:\n        printer((\"ERROR: \" if prefix else \"\") + msg, \"red\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getenvar(self, envar):\n        from os import getenv\n        \"\"\"Retrieves the value of an environment variable if it exists.\"\"\"\n        if getenv(envar) is not None:\n            self._vardict[envar] = getenv(envar)", "response": "Retrieves the value of an environment variable if it exists."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the values of the configuration variables from an XML file.", "response": "def load_xml(self, filepath):\n        \"\"\"Loads the values of the configuration variables from an XML path.\"\"\"\n        from os import path\n        import xml.etree.ElementTree as ET\n        #Make sure the file exists and then import it as XML and read the values out.\n        uxpath = path.expanduser(filepath)\n        if path.isfile(uxpath):\n            tree = ET.parse(uxpath)\n            root = tree.getroot()\n            if \"symlink\" in root.attrib:\n                self._vardict[\"symlink\"] = root.attrib.lower() == \"true\"\n                \n            for child in root:\n                if child.tag == \"codes\":\n                    self._load_codes(child)\n                elif child.tag == \"mappings\":\n                    self._load_mapping(child)\n                elif child.tag == \"ssh\":\n                    self._load_ssh(child)\n                elif child.tag == \"isense\":\n                    self._load_isense(child)\n                elif child.tag == \"libraries\":\n                    self._load_includes(child)\n                elif child.tag == \"compilers\":\n                    self._vardict[\"compilers\"] = child.text"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_isense(self, tag):\n        isense = {}\n        for child in tag:\n            if child.tag in isense:\n                isense[child.tag].update(child.attrib)\n            else:\n                isense[child.tag] = child.attrib\n\n        self._vardict[\"isense\"] = isense", "response": "Loads the isense configuration as a dict of dicts into vardict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload the SSH configuration into the vardict.", "response": "def _load_ssh(self, tag):\n        \"\"\"Loads the SSH configuration into the vardict.\"\"\"\n        for child in tag:\n            if child.tag == \"server\":\n                self._vardict[\"server\"] = child.attrib\n            elif child.tag == \"codes\":\n                self._load_codes(child, True)\n            elif child.tag == \"mappings\":\n                self._load_mapping(child, True)\n            elif child.tag == \"libraries\":\n                self._load_includes(child, True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting all additional libraries that should be included when linking the unit testing executables.", "response": "def _load_includes(self, tag, ssh=False):\n        \"\"\"Extracts all additional libraries that should be included when linking\n        the unit testing executables.\n        \"\"\"\n        import re\n        includes = []\n        for child in tag:\n            if child.tag == \"include\" and \"path\" in child.attrib:\n                incl = { \"path\": child.attrib[\"path\"] }\n                if \"modules\" in child.attrib:\n                    incl[\"modules\"] = re.split(\",\\s*\", child.attrib[\"modules\"].lower())\n                includes.append(incl)\n\n        if ssh == False:\n            self._vardict[\"includes\"] = includes\n        else:\n            self._vardict[\"ssh.includes\"] = includes"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts all the paths to additional code directories to be considered.", "response": "def _load_codes(self, tag, ssh=False):\n        \"\"\"Extracts all the paths to additional code directories to \n        be considered.\n\n        :arg tag: the ET tag for the <codes> element.\"\"\"\n        codes = []\n        for code in tag:\n            if code.tag == \"trunk\":\n                codes.append(code.attrib[\"value\"])\n        \n        if ssh == False:\n            self._vardict[\"codes\"] = codes\n        else:\n            self._vardict[\"ssh.codes\"] = codes"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts all the alternate module name mappings to be considered.", "response": "def _load_mapping(self, tag, ssh=False):\n        \"\"\"Extracts all the alternate module name mappings to \n        be considered.\n\n        :arg tag: the ET tag for the <mappings> element.\"\"\"\n        mappings = {}\n        for mapping in tag:\n            if mapping.tag == \"map\":\n                mappings[mapping.attrib[\"module\"]] = mapping.attrib[\"file\"]\n\n        if ssh == False:\n            self._vardict[\"mappings\"] = mappings\n        else:\n            self._vardict[\"ssh.mappings\"] = mappings"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the specified attribute from the XML element.", "response": "def get_attrib(xml, name, tag=None, cast=str, default=None):\n    \"\"\"Returns the specified attribute from the XML element, raising a ValueError\n    if it is not availaible.\n    \n    :arg xml: the XMLElement instance to get the attribute from.\n    :arg name: the name of the attribute in xml.attrib dictionary.\n    :arg tag: the name of the tag to display with the ValueError if the attribute is missing.\n    \"\"\"\n    if name in xml.attrib:\n        return cast(xml.attrib[name])\n    elif default is not None:\n        return default\n    elif tag is not None:\n        raise ValueError(\"'{}' is a required attribute of <{}> tag.\".format(name, tag))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef symlink(source, target, isfile=True):\n    from fortpy.code import config\n    from os import path\n    if config.symlink:\n        from os import symlink, remove\n        if path.isfile(target) or path.islink(target):\n            remove(target)\n        elif path.isdir(target):\n            msg.warn(\"Cannot auto-delete directory '{}' for symlinking.\".format(target))\n            return\n        symlink(source, target)\n    else:\n        msg.info(\"   COPY: {}\".format(source))\n        if isfile:\n            copyfile(source, target)\n        else:\n            copy(source, target)", "response": "Creates a symlink at target pointing to source."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef copytree(src, dst):\n    from os import path, waitpid\n    from subprocess import Popen, PIPE\n\n    #Append any trailing / that we need to get rsync to work correctly.\n    source = path.join(src, \"\")\n    desti = path.join(dst, \"\")\n    if not path.isdir(desti):\n        from os import mkdir\n        mkdir(desti)\n    \n    prsync = Popen(\"rsync -t -u -r {} {}\".format(source, desti), close_fds=True,\n                    shell=True, executable=\"/bin/bash\", stdout=PIPE, stderr=PIPE)\n    waitpid(prsync.pid, 0)\n    #Redirect the output and errors so that we don't pollute stdout.\n    #output = prsync.stdout.readlines()\n    error = prsync.stderr.readlines()\n    prsync.stderr.close()\n    prsync.stdout.close()\n\n    if len(error) > 0:\n        from fortpy.msg import warn\n        warn(\"Error while copying {} using rsync.\\n\\n{}\".format(source, '\\n'.join(error)))", "response": "Recursively copies the source directory to the destination directory if the files are newer or modified by using rsync."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_fortpy_templates_dir():\n    import fortpy\n    from os import path\n    fortdir = path.dirname(fortpy.__file__)\n    return path.join(fortdir, \"templates\")", "response": "Gets the templates directory from the fortpy package."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the directory path for the fortpy templates.", "response": "def set_fortpy_templates(obj, fortpy_templates=None):\n    \"\"\"Sets the directory path for the fortpy templates. If no directory\n    is specified, use the default one that shipped with the package.\n    \"\"\"\n    #If they didn't specify a custom templates directory, use the default\n    #one that shipped with the package.\n    from os import path\n    if fortpy_templates is not None:\n        obj.fortpy_templates = path.abspath(path.expanduser(fortpy_templates))\n    else:\n        from fortpy.utility import get_fortpy_templates_dir\n        obj.fortpy_templates = get_fortpy_templates_dir()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the absolute path to the relpath taken relative to the base directory.", "response": "def get_dir_relpath(base, relpath):\n    \"\"\"Returns the absolute path to the 'relpath' taken relative to the base\n    directory.\n\n    :arg base: the base directory to take the path relative to.\n    :arg relpath: the path relative to 'base' in terms of '.' and '..'.\n    \"\"\"\n    from os import path\n    xbase = path.abspath(path.expanduser(base))\n    if not path.isdir(xbase):\n        return path.join(xbase, relpath)\n    \n    if relpath[0:2] == \"./\":\n        return path.join(xbase, relpath[2::])\n    else:\n        from os import chdir, getcwd\n        cd = getcwd()\n        chdir(xbase)\n        result = path.abspath(relpath)\n        chdir(cd)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap the specified line of text on whitespace to make sure that none of the ArcGIS words exceeds chars characters.", "response": "def wrap_line(line, limit=None, chars=80):\n    \"\"\"Wraps the specified line of text on whitespace to make sure that none of the\n    lines' lengths exceeds 'chars' characters.\n    \"\"\"\n    result = []\n    builder = []\n    length = 0\n    if limit is not None:\n        sline = line[0:limit]\n    else:\n        sline = line\n        \n    for word in sline.split():\n        if length <= chars:\n            builder.append(word)\n            length += len(word) + 1\n        else:\n            result.append(' '.join(builder))\n            builder = [word]\n            length = 0\n\n    result.append(' '.join(builder))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexplaining the specified ParseError instance to show the user where the error happened in their XML.", "response": "def x_parse_error(err, content, source):\n    \"\"\"Explains the specified ParseError instance to show the user where the error\n    happened in their XML.\n    \"\"\"\n    lineno, column = err.position\n    if \"<doc>\" in content:\n        #Adjust the position since we are taking the <doc> part out of the tags\n        #since we may have put that in ourselves.\n        column -= 5\n    start = lineno - (1 if lineno == 1 else 2)\n    lines = []\n    tcontent = content.replace(\"<doc>\", \"\").replace(\"</doc>\", \"\").split('\\n')\n    for context in IT.islice(tcontent, start, lineno):\n        lines.append(context.strip())\n    last = wrap_line(lines.pop(), column)\n    lines.extend(last)\n    \n    caret = '{:=>{}}'.format('^', len(last[-1]))\n    if source is not None:\n        err.msg = '\\nIn: {}\\n{}\\n{}\\n{}'.format(source, err, '\\n'.join(lines), caret)\n    else:\n        err.msg = '{}\\n{}\\n{}'.format(err, '\\n'.join(lines), caret)\n\n    raise err"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the XML text using the ET. XML function.", "response": "def XML(content, source=None):\n    \"\"\"Parses the XML text using the ET.XML function, but handling the ParseError in\n    a user-friendly way.\n    \"\"\"\n    try:\n        tree = ET.XML(content)\n    except ET.ParseError as err:\n        x_parse_error(err, content, source)\n    return tree"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef XML_fromstring(content, source=None):\n    try:\n        tree = ET.fromstring(content)\n    except ET.ParseError as err:\n        x_parse_error(err, content, source)\n    return tree", "response": "Parses the XML string into a node tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting all of the docstrings in the specified element and its children into a user - friendly paragraph format for printing.", "response": "def format(element):\n    \"\"\"Formats all of the docstrings in the specified element and its\n    children into a user-friendly paragraph format for printing.\n\n    :arg element: an instance of fortpy.element.CodeElement.\n    \"\"\"\n    result = []\n    if type(element).__name__ in [\"Subroutine\", \"Function\"]:\n        _format_executable(result, element)\n    elif type(element).__name__ == \"CustomType\":\n        _format_type(result, element)\n    elif isinstance(element, ValueElement):\n        _format_value_element(result, element)\n\n    return '\\n'.join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _format_executable(lines, element, spacer=\"\"):\n    rlines = []\n    rlines.append(element.signature)\n    _format_summary(rlines, element)\n\n    rlines.append(\"\")\n    rlines.append(\"PARAMETERS\")\n    for p in element.ordered_parameters:\n        _format_value_element(rlines, p)\n\n    rlines.append(\"\")\n    _format_generic(rlines, element, [\"summary\"])\n\n    #Subroutines can have embedded types and functions which need to be handled.\n    if len(element.types) > 0:\n        rlines.append(\"\\nEMBEDDED TYPES\")\n        for key, value in list(element.types.items()):\n            _format_type(rlines, value, \"  \")\n\n    if len(element.executables) > 0:\n        rlines.append(\"\\nEMBEDDED EXECUTABLES\")\n        for key, value in list(element.executables.items()):\n            _format_executable(rlines, value, \"  \")\n\n    lines.extend([spacer + l for l in rlines])", "response": "Formats the executable code for a Subroutine or Function code element."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _format_type(lines, element, spacer=\"\"):\n    rlines = []\n    rlines.append(element.signature)\n    _format_summary(rlines, element)\n\n    rlines.append(\"\")\n    _format_generic(rlines, element, [\"summary\"])\n\n    if len(element.executables) > 0:\n        rlines.append(\"\\nEMBEDDED PROCEDURES\")\n        for key, value in list(element.executables.items()):\n            rlines.append(\"  {}\".format(value.__str__()))\n            target = value.target\n            if target is not None:\n                _format_executable(rlines, target, \"  \")\n\n    if len(element.members) > 0:\n        rlines.append(\"\\nEMBEDDED MEMBERS\")\n        for key, value in list(element.members.items()):\n            _format_value_element(rlines, value, \"  \")\n\n    lines.extend([spacer + l for l in rlines])", "response": "Formats a derived type for full documentation output."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats a member or parameter for full documentation output.", "response": "def _format_value_element(lines, element, spacer=\"\"):\n    \"\"\"Formats a member or parameter for full documentation output.\"\"\"\n    lines.append(spacer + element.definition())\n    _format_summary(lines, element)\n    _format_generic(lines, element, [\"summary\"])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding the element s summary tag to the lines.", "response": "def _format_summary(lines, element, spacer=\"  \"):\n    \"\"\"Adds the element's summary tag to the lines if it exists.\"\"\"\n    summary = spacer + element.summary\n    if element.summary == \"\":\n        summary = spacer + \"No description given in XML documentation for this element.\"\n    lines.append(summary)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _format_generic(lines, element, printed, spacer=\"\"):\n    for doc in element.docstring:\n        if doc.doctype.lower() not in printed:\n            lines.append(spacer + doc.__str__())", "response": "Generically formats all remaining docstrings and custom XML\n    tags that don t appear in the list of printed documentation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the code to create the argtype to assign to the methods argtypes attribute.", "response": "def _py_ex_argtype(executable):\n    \"\"\"Returns the code to create the argtype to assign to the methods argtypes\n    attribute.\n    \"\"\"\n    result = []\n    for p in executable.ordered_parameters:\n        atypes = p.argtypes\n        if atypes is not None:\n            result.extend(p.argtypes)\n        else:\n            print((\"No argtypes for: {}\".format(p.definition())))\n\n    if type(executable).__name__ == \"Function\":\n        result.extend(executable.argtypes)        \n            \n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _py_ctype(parameter):\n    ctype = parameter.ctype\n    if ctype is None:\n        raise ValueError(\"Can't bind ctypes py_parameter for parameter\"\n                         \" {}\".format(parameter.definition()))\n    return ctype.lower()", "response": "Returns the ctypes type name for the specified fortran parameter."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the name of the python type for the fortran parameter.", "response": "def _py_pytype(parameter):\n    \"\"\"Returns the name of the *python* type for the fortran parameter.\n    \"\"\"\n    pytype = parameter.pytype\n    if pytype is None:\n        raise ValueError(\"Can't pre-determine type for parameter: {}\".format(parameter.definition()))\n    return pytype"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _py_code_clean(lines, tab, executable):\n    count = 0\n    allparams = executable.ordered_parameters\n    if type(executable).__name__ == \"Function\":\n        allparams = allparams + [executable]\n        \n    for p in allparams:\n        value = _py_clean(p, tab)\n        if value is not None:\n            count += 1\n            lines.append(value)\n            \n    return count", "response": "Appends all the code lines needed to create the result class instance and populate\n    its keys with all output variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _py_ftype(parameter, tab):\n    splice = ', '.join([\"{0}_{1:d}\".format(parameter.lname, i)\n                        for i in range(parameter.D)])       \n    return \"{2}{0}_ft = Ftype({0}_o, [{1}], libpath)\".format(parameter.lname, splice, tab)", "response": "Returns the code to declare an Ftype object that handles memory\n    deallocation for Fortran return arrays that were allocated by ctypes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _py_clean(parameter, tab):\n    if \"out\" in parameter.direction:\n        if parameter.D > 0:\n            if \":\" in parameter.dimension and (\"allocatable\" in parameter.modifiers or\n                                               \"pointer\" in parameter.modifiers):\n                if parameter.D == 1:\n                    clarray = \"as_array({0}_o, ({0}_0.value,))\".format(parameter.lname)\n                else:\n                    #We have to reverse the order of the indices because of the way that\n                    #fortran orders the array elements. We undo this using a transpose in\n                    #the ftypes.as_array() so that the elements are ordered correctly.\n                    splice = ', '.join(reversed([\"{0}_{1:d}.value\".format(parameter.lname, i)\n                                                 for i in range(parameter.D)]))       \n                    clarray = \"as_array({0}_o, ({1}))\".format(parameter.lname, splice)\n\n                assign = '{0}result.add(\"{1}\", {2}, {1}_ft)'.format(tab, parameter.lname, clarray)\n                fstr = _py_ftype(parameter, tab)\n                    \n                #For optional out parameters, we won't necessarily have anything to report.\n                return _py_check_optional(parameter, tab, [fstr, assign])\n            else:\n                return '{1}result.add(\"{0}\", {0}_a)'.format(parameter.lname, tab)\n        else: #This handles scalar (inout) and (out) variables.\n            return '{1}result.add(\"{0}\", {0}_c.value)'.format(parameter.lname, tab)", "response": "Returns the code line to clean the output value of the specified parameter."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _py_check_optional(parameter, tab, assign):\n    if parameter.direction == \"(out)\":\n        result = []\n        checks = [\"{0}_{1:d}.value==0\".format(parameter.lname, i) for i in range(parameter.D)]\n        spacing = len(tab) + 2 + 3 + 3 + 2\n        result.append(\"{}if not all([{}]):\".format(tab, present_params(checks, spacing, linecont=\", \")))\n        for line in assign:\n            if assign is not None:\n                result.append(\"{0}{1}\".format(tab, line))\n        result.append(\"{}else:\".format(tab))\n        result.append('{0}{0}result.add(\"{1}\", None)'.format(tab, parameter.lname))\n        return '\\n'.join(result)\n    else:\n        return '\\n'.join(assign)", "response": "Returns the code to check for actual values when an out parameter is pure \n    out or optional and doesn t have anything changed."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _py_code_variables(lines, executable, lparams, tab):\n    allparams = executable.ordered_parameters\n    if type(executable).__name__ == \"Function\":\n        allparams = allparams + [executable]\n\n    for p in allparams:\n        _py_code_parameter(lines, p, \"invar\", lparams, tab)\n        if p.direction == \"(out)\":\n            #We need to reverse the order of the indices to match the fortran code\n            #generation of the wrapper.\n            _py_code_parameter(lines, p, \"outvar\", lparams, tab)\n            _py_code_parameter(lines, p, \"indices\", lparams, tab)\n        else:\n            _py_code_parameter(lines, p, \"indices\", lparams, tab)\n            _py_code_parameter(lines, p, \"outvar\", lparams, tab)", "response": "Adds the variable code lines for all the parameters in the executable."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _py_code_parameter(lines, parameter, position, lparams, tab):\n    mdict = {\n        \"invar\": _py_invar,\n        \"outvar\": _py_outvar,\n        \"indices\": _py_indices\n    }\n    line = mdict[position](parameter, lparams, tab)\n    if line is not None:\n        value, blank = line\n        lines.append(tab + value)\n        if blank:\n            lines.append(\"\")", "response": "Appends the code to produce the parameter at the specified position in the executable."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _py_invar(parameter, lparams, tab):\n    if (\"in\" in parameter.direction and parameter.D > 0):\n        if parameter.direction == \"(inout)\" and \":\" not in parameter.dimension:\n            wstr = \", writeable\"\n        else:\n            wstr = \"\"\n        pytype = _py_pytype(parameter)\n        lparams.append(\"{}_a\".format(parameter.lname))\n        return ('{0}_a = require({0}, {1}, \"F{2}\")'.format(parameter.lname, pytype, wstr), False)\n    elif parameter.D == 0:\n        #Even for scalar outvars, we need to initialize a variable to pass by reference.\n        lparams.append(\"byref({}_c)\".format(parameter.lname))\n        if parameter.direction == \"(out)\":\n            initval = parameter.py_initval\n            return (\"{0}_c = {1}({2})\".format(parameter.lname, _py_ctype(parameter), initval), False)\n        else:\n            return (\"{0}_c = {1}({0})\".format(parameter.lname, _py_ctype(parameter)), False)", "response": "Returns the code to create the local input parameter that is coerced to have the correct type for ctypes interaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the code to produce a ctypes output variable for interacting with fortran.", "response": "def _py_outvar(parameter, lparams, tab):\n    \"\"\"Returns the code to produce a ctypes output variable for interacting with fortran.\n    \"\"\"\n    if (\"out\" in parameter.direction and parameter.D > 0 and \":\" in parameter.dimension and\n        (\"allocatable\" in parameter.modifiers or \"pointer\" in parameter.modifiers)):\n        lparams.append(\"byref({}_o)\".format(parameter.lname))\n        blank = True if parameter.direction == \"(inout)\" else False\n        return (\"{0}_o = POINTER({1})()\".format(parameter.lname, _py_ctype(parameter)), blank)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _py_indices(parameter, lparams, tab):\n    if parameter.D > 0 and \":\" in parameter.dimension:\n        if \"in\" in parameter.direction:\n            indexstr = \"{0}_{1:d} = c_int({0}_a.shape[{1:d}])\"\n        else:\n            indexstr = \"{0}_{1:d} = c_int(0)\"\n        lparams.extend([\"byref({}_{})\".format(parameter.lname, i) for i in range(parameter.D)])\n        joinstr = \"\\n\" + tab\n        blank = True if parameter.direction == \"(out)\" else False\n        return (joinstr.join([indexstr.format(parameter.lname, i)\n                              for i in range(parameter.D)]), blank)", "response": "Returns the code to produce py ctypes for the indices of the specified parameter."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ctypes_code_parameter(lines, parameter, position):\n    mdict = {\n        'indices': _ctypes_indices,\n        'variable': _ctypes_variables,\n        'out': _ctypes_out,\n        'regular': _ctypes_regular,\n        'saved': _ctypes_saved,\n        'assign': _ctypes_assign,\n        'clean': _ctypes_clean\n    }\n    line = mdict[position](parameter)\n    if line is not None:\n        value, blank = line\n        lines.append(value)\n        if blank:\n            lines.append(\"\")", "response": "Returns the code for the specified parameter being written into a subroutine wrapper."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine the ISO_C data type to use for describing the specified parameter.", "response": "def _ctypes_dtype(parameter):\n    \"\"\"Determines the ISO_C data type to use for describing the specified parameter.\n    \"\"\"\n    ctype = parameter.ctype\n    if ctype is None:\n        if parameter.kind is not None:\n            return \"{}({})\".format(parameter.dtype, parameter.kind)\n        else:\n            return parameter.dtype\n    else:\n        return\"{}({})\".format(parameter.dtype, ctype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of variable names that define the size of each dimension.", "response": "def _ctypes_splice(parameter):\n    \"\"\"Returns a list of variable names that define the size of each dimension.\n    \"\"\"\n    params = parameter.ctypes_parameter()\n    if parameter.direction == \"(inout)\" and (\"allocatable\" in parameter.modifiers or\n                                             \"pointer\" in parameter.modifiers):\n        return ', '.join(params[1:-1])\n    else:\n        return ', '.join(params[1::])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn code for parameter variable declarations specifying the size of each dimension in the specified parameter.", "response": "def _ctypes_indices(parameter):\n    \"\"\"Returns code for parameter variable declarations specifying the size of each\n    dimension in the specified parameter.\n    \"\"\"\n    if (parameter.dimension is not None and \":\" in parameter.dimension):\n        splice = _ctypes_splice(parameter)\n        if \"out\" in parameter.direction:\n            #Even for pure out variables, the ctypes pointer is passed in and will\n            #have a value already.\n            return (\"integer, intent(inout) :: {}\".format(splice), False)\n        else:\n            return (\"integer, intent(in) :: {}\".format(splice), False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the local parameter definition for implementing a Fortran wrapper subroutine for this parameter s parent executable.", "response": "def _ctypes_variables(parameter):\n    \"\"\"Returns the local parameter definition for implementing a Fortran wrapper subroutine\n    for this parameter's parent executable.\n    \"\"\"\n    if parameter.dimension is not None and \":\" in parameter.dimension:\n        #For arrays that provide input (including 'inout'), we pass the output separately\n        #through a c-pointer. They will always be input arrays. For pure (out) parameters\n        #we use *only* a c-ptr, but it needs intent (inout) since it is created by ctypes.\n        if \"in\" in parameter.direction or parameter.direction == \"\":\n            #We have to get the ctypes-compatible data type for the parameters.\n            #stype = _ctypes_dtype(parameter)\n            splice = _ctypes_splice(parameter)\n            name = parameter.ctypes_parameter()[0]\n            if parameter.direction == \"(inout)\" and not (\"allocatable\" in parameter.modifiers or\n                                                         \"pointer\" in parameter.modifiers):\n                return (parameter.definition(optionals=False, customdim=splice), False)\n            else:\n                return (\"{}, intent(in) :: {}({})\".format(parameter.strtype, name, splice), False)\n    else:\n        if parameter.dtype == \"logical\":\n            stype = _ctypes_dtype(parameter)\n            suffix = \"_c\"\n            modifiers = None\n        elif hasattr(parameter, \"parameters\"):\n            stype = None\n            suffix = \"_f\"\n            modifiers = [\"intent(out)\"]\n        else:\n            stype = None\n            suffix = \"\"\n            modifiers = None\n            \n        return (parameter.definition(ctype=stype, optionals=False, suffix=suffix,\n                                     modifiers=modifiers), False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _ctypes_out(parameter):\n    if (parameter.dimension is not None and \":\" in parameter.dimension\n        and \"out\" in parameter.direction and (\"allocatable\" in parameter.modifiers or\n                                              \"pointer\" in parameter.modifiers)):\n        if parameter.direction == \"(inout)\":\n            return (\"type(C_PTR), intent(inout) :: {}_o\".format(parameter.name), True)\n        else: #self.direction == \"(out)\" since that is the only other option.\n            return (\"type(C_PTR), intent(inout) :: {}_c\".format(parameter.name), True)", "response": "Returns a parameter variable declaration for an output variable for the specified parameter."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the code lines to define a local variable with the fortran types that has a matching signature to the wrapped executable.", "response": "def _ctypes_regular(parameter):\n    \"\"\"Returns the code lines to define a *local* variable with the fortran types\n    that has a matching signature to the wrapped executable.\n    \"\"\"\n    if (\"pointer\" in parameter.modifiers or \"allocatable\" in parameter.modifiers\n        or \"target\" in parameter.modifiers or parameter.dtype == \"logical\"):\n        return (parameter.definition(local=True), False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _ctypes_saved(parameter):\n    if (\"out\" in parameter.direction and parameter.dimension is not None and\n        \":\" in parameter.dimension and (\"allocatable\" in parameter.modifiers or\n                                        \"pointer\" in parameter.modifiers)):\n        stype = _ctypes_dtype(parameter)\n        name = \"{}_t({})\".format(parameter.name, parameter.dimension)\n        return (\"{}, allocatable, target, save :: {}\".format(stype, name), True)", "response": "Returns local variable declarations that create allocatable variables that can persist their value through ctypes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the Fortran code lines to allocate and assign values to the original * parameter ValueElement that exists now only as a local variable so that the corresponding Fortran code line is generated.", "response": "def _ctypes_assign(parameter):\n    \"\"\"Returns the Fortran code lines to allocate and assign values to the *original*\n    parameter ValueElement that exists now only as a local variable so that the\n    signatures match for the compiler.\n    \"\"\"\n    #If the array is set to only have intent(out), we don't want to allocate or assign\n    #a value to it; otherwise we do.\n    if (parameter.direction != \"(out)\" and (\"allocate\" in parameter.modifiers\n                                            or \"pointer\" in parameter.modifiers\n                                            or \"target\" in parameter.modifiers)):\n        if \"in\" in parameter.direction:\n            splice = _ctypes_splice(parameter)\n            result = []\n            result.append(\"    allocate({}({}))\".format(parameter.name, splice))\n            result.append(\"    {0} = {0}_c\".format(parameter.name))\n            return ('\\n'.join(result), True)\n    elif parameter.dtype == \"logical\" and \"in\" in parameter.direction:\n        return (\"    {0} = {0}_c\".format(parameter.name), False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _ctypes_clean(parameter):\n    if (\"out\" in parameter.direction and parameter.dimension is not None\n        and \":\" in parameter.dimension and (\"pointer\" in parameter.modifiers or\n                                            \"allocatable\" in parameter.modifiers)):\n        params = parameter.ctypes_parameter()\n        result = []\n        spacer = \"    \"\n        #We get segfaults if we try to assign c-pointers to unallocated pointers or arrays.\n        if \"optional\" in parameter.modifiers:\n            if \"pointer\" in parameter.modifiers:\n                result.append(\"{}if (associated({})) then\".format(spacer, parameter.name))\n                spacer += \"  \"\n            elif \"allocatable\" in parameter.modifiers:\n                result.append(\"{}if (allocated({})) then\".format(spacer, parameter.name))\n                spacer += \"  \"\n\n        #We have to copy the values or at least update the pointer to access the\n        #variables with 'target' and 'save' attributes.\n        result.append(\"{0}{1}_t = {1}\".format(spacer, parameter.name))\n            \n        if parameter.direction == \"(inout)\":\n            result.append(\"{1}{0}_o = C_LOC({0}_t)\".format(parameter.name, spacer))\n            #Update the index variables for the dimensions of the output variable.\n            for i, p in enumerate(params[1:-1]):\n                result.append(\"{}{} = size({}, {})\".format(spacer, p, parameter.name, i+1))\n        else:\n            #This is the case for intent(out)\n            result.append(\"{1}{0}_c = C_LOC({0}_t)\".format(parameter.name, spacer))\n            for i, p in enumerate(params[1::]):\n                result.append(\"{}{} = size({}, {})\".format(spacer, p, parameter.name, i+1))\n\n        if (\"optional\" in parameter.modifiers and\n            (\"pointer\" in parameter.modifiers or \"allocatable\" in parameter.modifiers)):\n            result.append(\"    end if\")\n\n        return ('\\n'.join(result), True)\n    elif parameter.dtype == \"logical\" and \"out\" in parameter.direction:\n        return (\"    {0}_c = {0}\".format(parameter.name), False)", "response": "Returns the lines of code required to assign the correct values to the integers\n    representing the indices of the output arrays in the ctypes wrapper subroutine."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _ctypes_ex_parameters(executable):\n    result = []\n    for p in executable.ordered_parameters:\n        result.extend(p.ctypes_parameter())\n\n    if type(executable).__name__ == \"Function\":\n        result.extend(executable.ctypes_parameter()) #This method inherits from ValueElement.\n        \n    return result", "response": "Returns a list of the parameters to form the wrapper executable to interact\n    with ctypes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of the local variable definitions required to construct the ctypes interop wrapper.", "response": "def _ctypes_ex_variables(executable):\n    \"\"\"Returns a list of the local variable definitions required to construct the\n    ctypes interop wrapper.\n    \"\"\"\n    result = []\n    for p in executable.ordered_parameters:\n        _ctypes_code_parameter(result, p, \"indices\")\n        _ctypes_code_parameter(result, p, \"variable\")\n        _ctypes_code_parameter(result, p, \"out\")\n\n    if type(executable).__name__ == \"Function\":\n        #For functions, we still create a subroutine-type interface and then just add an extra\n        #output-type parameter for the function's return type.\n        _ctypes_code_parameter(result, executable, \"indices\")\n        _ctypes_code_parameter(result, executable, \"variable\")\n        _ctypes_code_parameter(result, executable, \"out\")\n        \n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ctypes_ex_compatvars(executable):\n    result = []\n    for p in executable.ordered_parameters:\n        _ctypes_code_parameter(result, p, \"regular\")\n        _ctypes_code_parameter(result, p, \"saved\")\n\n    if type(executable).__name__ == \"Function\":\n        _ctypes_code_parameter(result, executable, \"regular\")\n        _ctypes_code_parameter(result, executable, \"saved\")\n\n    return result", "response": "Returns a list of code lines for signature matching variables and \n    pointer saving variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of code lines to allocate and assign the local parameter definitions that match those in the signature of the wrapped executable.", "response": "def _ctypes_ex_assign(executable):\n    \"\"\"Return a list of code lines to allocate and assign the local parameter definitions\n    that match those in the signature of the wrapped executable.\n    \"\"\"\n    result = []\n    for p in executable.ordered_parameters:\n        _ctypes_code_parameter(result, p, \"assign\")\n\n    if type(executable).__name__ == \"Function\":\n        _ctypes_code_parameter(result, executable, \"assign\")\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of code lines to take care of assigning pointers for output variables interacting with ctypes.", "response": "def _ctypes_ex_clean(executable):\n    \"\"\"Return a list of code lines to take care of assigning pointers for output variables\n    interacting with ctypes.\n    \"\"\"\n    result = []\n    for p in executable.ordered_parameters:\n        _ctypes_code_parameter(result, p, \"clean\")\n        \n    if type(executable).__name__ == \"Function\":\n        _ctypes_code_parameter(result, executable, \"clean\")\n        \n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef libname(self):\n        if self.library is not None:\n            return \"ftypes.{}.so\".format(self.library)\n        else:\n            return \"{}.so\".format(self.name)", "response": "Returns the name of the shared library file compiled for the wrapper\n            subroutines coded in fortran."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef libpath(self):\n        from os import path\n        return path.join(self.dirpath, self.libname)", "response": "Returns the full path to the shared wrapper library created for the\n        module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake sure that the linked library with the original code exists.", "response": "def _check_lib(self, remake, compiler, debug, profile):\n        \"\"\"Makes sure that the linked library with the original code exists. If it doesn't\n        the library is compiled from scratch.\n        \"\"\"\n        from os import path\n        if self.link is None or not path.isfile(self.link):\n            self.makelib(remake, True, compiler, debug, profile)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a makefile that can be used to link the module with the shared library.", "response": "def make(self, remake=False, dependencies=None,\n             compiler=\"gfortran\", debug=False, profile=False):\n        \"\"\"Generates a makefile to compile the wrapper module and link it with the shared\n        library that can be compiled with self.makelib().\n        \"\"\"\n        self._check_lib(remake, compiler, debug, profile)\n        \n        from os import path\n        if self.link is None or not path.isfile(self.link):\n            msg.err(\"Can't create shared library; missing compiled original code: {}\".format(self.link))\n            exit(0)\n        \n        if remake or not path.isfile(self.libpath):\n            if dependencies is None:\n                dependencies = [\"{}_c\".format(self.module.name)]\n                identifier = self.name\n            else:\n                identifier = \"ftypes.{}\".format(self.library)\n                #We don't need to reorder these *wrapper* modules before compilation because each of\n                #them should be independent of all the others.\n                #dependencies = self._process_module_needs(dependencies)\n\n            #append the dependency for the deallocation module to be included in the shared lib.\n            dependencies.append(\"ftypes_dealloc\")\n                \n            makename = \"Makefile.{}\".format(self.library if self.library else self.name)\n            makepath = path.join(self.f90path, makename)\n            extralinks = list(self.dependencies.values())\n            extralinks.append(self.link)\n            makefile(identifier, dependencies, makepath, \"ftypes.{}\".format(self.name),\n                     False, False, self.module.parent, \"so\", extralinks)\n            code = self._compile(self.f90path, makename, compiler, debug, profile)\n            if code == 0:\n                #Copy the shared library to the main directory out of the f90 directory\n                from shutil import copy\n                copy(path.join(self.f90path, \"{}.so\".format(identifier)), self.dirpath)\n            return code\n        else:\n            return 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompile the makefile at the specified location with the specified compiler.", "response": "def _compile(self, dirpath, makename, compiler, debug, profile):\n        \"\"\"Compiles the makefile at the specified location with 'compiler'.\n\n        :arg dirpath: the full path to the directory where the makefile lives.\n        :arg compiler: one of ['ifort', 'gfortran'].\n        :arg makename: the name of the make file to compile.\n        \"\"\"\n        from os import path\n        options = \"\"\n        if debug:\n            options += \" DEBUG=true\"\n        if profile:\n            options += \" GPROF=true\"\n\n        from os import system\n        codestr = \"cd {}; make -f '{}' F90={} FAM={}\" + options\n        code = system(codestr.format(dirpath, makename, compiler, compiler[0]))\n\n        #It turns out that the compiler still returns a code of zero, even if the compile\n        #failed because the actual compiler didn't fail; it did its job properly. We need to\n        #check for the existence of errors in the 'compile.log' file.\n        lcount = 0\n        errors = []\n        log = path.join(dirpath, \"compile.log\")\n        with open(log) as f:\n            for line in f:\n                lcount += 1\n                if lcount > 21 and lcount < 32:\n                    errors.append(line)\n                elif lcount > 21:\n                    break\n\n        if len(errors) > 0:\n            #There are 21 lines in the compile.log file when everything runs correctly\n            #Overwrite code with a bad exit value since we have some other problems.\n            code = 1\n            #We want to write the first couple of errors to the console and give them the\n            #option to still execute if the compile only generated warnings.\n            msg.warn(\"compile generated some errors or warnings:\")\n            msg.blank()\n            msg.info(''.join(errors))\n\n        return code"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef makelib(self, remake=False, full=True, compiler=\"gfortran\", debug=False, profile=False):\n        if self.link is None or remake:\n            from os import path\n            if self.library is not None:\n                outpath = path.join(self.dirpath, \"{}.a\".format(self.library))\n            else:\n                outpath = path.join(self.dirpath, \"{}.a\".format(self.name))\n\n            if not remake and path.isfile(outpath): #No need to recompile\n                self.link = outpath\n                return\n                \n            dependencies = self._get_lib_modules(full)\n            makepath = path.join(path.dirname(self.module.filepath), \"Makefile.ftypes\")\n            if full:\n                compileid = \"ftypes.all_libs\"\n                identifier = self.library\n            else:\n                compileid = \"ftypes.{}_c\".format(self.module.name)\n                identifier = self.module.name\n                \n            makefile(identifier, dependencies, makepath, compileid,\n                     self.module.precompile, False, self.module.parent, \"a\")\n            code = self._compile(path.dirname(self.module.filepath), \"Makefile.ftypes\",\n                                 compiler, debug, profile)\n            if code == 0:\n                self.link = path.join(path.dirname(self.module.filepath), \"{}.a\".format(identifier))\n                self._copy_so(outpath)\n                self.link = outpath\n        else:\n            #Just make sure it is copied over into the directory where we want to compile the wrapper\n            #module for ftypes.\n            self._copy_so(self.dirpath)", "response": "Generates a makefile for the shared library that is used by the source module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _copy_so(self, outpath):\n        from os import path\n        if not path.isfile(outpath) and path.isfile(self.link):\n            from shutil import copy\n            copy(self.link, outpath)", "response": "Copies the shared library in self. so into the working directory for the wrapper\n        module if it doesn t already exist."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_lib_modules(self, full):\n        #The only complication with the whole process is that we need to get the list of\n        #dependencies for the current module. For full lib, we compile *all* the files in\n        #the directory, otherwise only those that are explicitly required.\n        result = []\n        if full:\n            found = {}\n            from os import path\n            mypath = path.dirname(self.module.filepath)\n            self.module.parent.scan_path(mypath, found)\n            for codefile in found:\n                self.module.parent.load_dependency(codefile.replace(\".f90\", \"\"), True, True, False)\n                \n            for modname, module in list(self.module.parent.modules.items()):\n                if path.dirname(module.filepath).lower() == mypath.lower():\n                    result.append(modname)\n        else:\n            result.extend(self.module.search_dependencies())\n\n        return self._process_module_needs(result)", "response": "Returns a list of the modules in the same folder as the one being wrapped for\n ArcGIS."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_dependencies(self):\n        #The only complication with the whole process is that we need to get the list of\n        #dependencies for the current module. For full lib, we compile *all* the files in\n        #the directory, otherwise only those that are explicitly required.\n        from os import path\n        modules = self.module.search_dependencies()\n        result = {}\n        for module in modules:\n            self.module.parent.load_dependency(module, True, True, False)\n            \n        for modname, module in list(self.module.parent.modules.items()):\n            pathkey = path.dirname(module.filepath).lower()\n            if pathkey not in result:\n                result[pathkey] = path.dirname(module.filepath)\n\n        return result", "response": "Returns a list of the module names that should be included in the shared lib compile\n        as dependencies for the current wrapper module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding the list of executables that pass the requirements required to have a wrapper created for them.", "response": "def _find_executables(self):\n        \"\"\"Finds the list of executables that pass the requirements necessary to have\n        a wrapper created for them.\n        \"\"\"\n        if len(self.needs) > 0:\n            return\n        \n        for execname, executable in list(self.module.executables.items()):\n            skip = False\n            #At the moment we can't handle executables that use special derived types.\n            if not execname in self.module.publics or not executable.primitive:\n                msg.info(\"Skipping {}.{} because it is not public.\".format(self.module.name, execname))\n                skip = True\n            #Check that all the parameters have intent specified, otherwise we won't handle them well.ha\n            if any([p.direction == \"\" for p in executable.ordered_parameters]):\n                msg.warn(\"Some parameters in {}.{} have no intent\".format(self.module.name, execname) +\n                         \" specified. Can't wrap that executable.\")\n                skip = True\n    \n            if not skip:\n                self.uses.append(execname)\n                for depmod in executable.search_dependencies():\n                    if depmod not in self.needs:\n                        self.needs.append(depmod)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_dir(self):\n        from os import path, mkdir\n        if not path.isdir(self.dirpath):\n            mkdir(self.dirpath)\n            #Copy the ftypes.py module shipped with fortpy to the local directory.\n            ftypes = path.join(get_fortpy_templates(), \"ftypes.py\")\n            from shutil import copy\n            copy(ftypes, self.dirpath)\n            #Create the __init__.py file so that the library becomes a package for\n            #its module contents.\n            with open(path.join(self.dirpath, \"__init__.py\"), 'w') as f:\n                f.write(\"# Auto-generated for package structure by fortpy.\")\n\n        #We also need to make sure that the fortpy deallocator module is present for\n        #compilation in the shared library.\n        if not path.isdir(self.f90path):\n            mkdir(self.f90path)\n            #Copy the ftypes.py module shipped with fortpy to the local directory.\n            ftypes = path.join(get_fortpy_templates(), \"ftypes_dealloc.f90\")\n            from shutil import copy\n            copy(ftypes, self.f90path)", "response": "Makes sure that the working directory for the wrapper modules exists."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_py(self):\n        self._check_dir()\n        #We make it so that the write py method can be called independently (as opposed\n        #to first needing the F90 write method to be called).\n        self._find_executables()\n        \n        lines = []\n        lines.append('\"\"\"Auto-generated python module for interaction with Fortran shared library\\n'\n                     'via ctypes. Generated for module {}.\\n'.format(self.module.name) +\n                     '\"\"\"')\n        lines.append(\"from ctypes import *\")\n        lines.append(\"from ftypes import *\")\n        lines.append(\"from numpy.ctypeslib import load_library, ndpointer\")\n        lines.append(\"from numpy import require\")\n        lines.append(\"from os import path\")\n        lines.append(\"\")\n        \n        for execkey in self.uses:\n            self._write_executable_py(execkey, lines)\n\n        from os import path\n        pypath = path.join(self.dirpath, \"{}.py\".format(self.module.name.lower()))\n        with open(pypath, 'w') as f:\n            f.write('\\n'.join(lines))", "response": "Writes a python module file to the current working directory for the library."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites the python executable definition for interacting with ctypes.", "response": "def _write_executable_py(self, execname, lines):\n        \"\"\"Writes the python executable definition for interacting with ctypes.\n\n        :arg execname: the name of the executable to write.\n        :arg lines: the lines of python code are appended to this list.\n        \"\"\"\n        executable = self.module.executables[execname]\n            \n        #The 5 in the formatting indent comes from 1 space, 3 from the 'def'\n        #and 1 from '('.\n        inparams = []\n        for p in executable.ordered_parameters:\n            if \"in\" in p.direction:\n                inparams.append(p.lname)\n        pyparams = present_params(inparams, len(execname) + 5, linecont=\", \")\n        lines.append(\"def {}({}):\".format(execname.lower(), pyparams))\n        tab = \"    \"\n\n        #Next, we want to append the docstring information from the XML tags\n        #that were parsed by fortpy.\n        docs = ['\"\"\"']\n        summary = self._format_docstring(executable.summary)\n        if len(summary) > 0:\n            docs[0] += summary[0]\n            docs.extend(summary[1::])\n            docs.append(\"\")\n        else:\n            docs[0] += \"No XML documentation summary.\"\n        for p in executable.ordered_parameters:\n            doc = \":arg {}: {}; {}\".format(p.name, p.strtype, p.summary)\n            docs.extend(self._format_docstring(doc))\n\n        lines.extend([tab + l for l in docs])\n        lines.append(tab + '\"\"\"')\n\n        pathstr = '{}libpath = path.join(path.dirname(__file__), \"{}\")'\n        lines.append(pathstr.format(tab, self.libname))\n        methparams = '\"{}_c\", \"{}_c\", libpath, True'.format(self.module.name, execname)\n        lines.append(\"{}method = static_symbol({})\".format(tab, methparams))\n        argtypes = _py_ex_argtype(executable)\n        spacing = len(tab) + 6 + 8 + 3\n        lines.append(\"{}method.argtypes = [{}]\".format(tab, present_params(argtypes, spacing,\n                                                                           linecont=\", \")))\n        lines.append(\"\")\n        lparams = []\n        _py_code_variables(lines, executable, lparams, tab)\n        #This is the line that calls the shared library executable.\n        methparams = present_params(lparams, len(tab) + 5, linecont=\", \")\n        lines.append(\"{}method({})\\n\".format(tab, methparams))\n\n        #Now we clean up the output variables to turn them into numpy arrays etc.\n        constructor = '{}result = FtypesResult(\"{}\", \"{}\", \"{}\")'\n        lines.append(constructor.format(tab, self.module.name, execname, type(executable).__name__))\n        count = _py_code_clean(lines, tab, executable)\n        \n        if count > 0:\n            lines.append(\"\")\n            lines.append(\"{}return result\\n\".format(tab))\n        else:\n            lines.append(\"{}return None\\n\".format(tab))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting the specified text for display within 90 characters. Returns a list of un - joined lines.", "response": "def _format_docstring(self, text):\n        \"\"\"Formats the specified text for display within 90 characters. Returns a list\n        of *un-joined* lines.\n\n        :arg text: the text to format.\n        \"\"\"\n        #The only complication we have here is that we don't want to break words up.\n        words = text.split()\n        result = []\n        line = []\n        cumline = 0\n        for word in words:\n            if len(word) + 1 + cumline < 90:\n                line.append(word)\n                cumline += len(word) + 1\n            else:\n                result.append(' '.join(line))\n                cumline = len(word) + 1\n                line = [word]\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the F90 module file to the specified directory.", "response": "def write_f90(self):\n        \"\"\"Writes the F90 module file to the specified directory.\n        \"\"\"\n        from os import path\n        self._check_dir()\n        #Find the list of executables that we actually need to write wrappers for.\n        self._find_executables()\n        \n        lines = []\n        lines.append(\"!!<summary>Auto-generated Fortran module for interaction with ctypes\\n\"\n                     \"!!through python. Generated for module {}.</summary>\".format(self.module.name))\n        lines.append(\"MODULE {}_c\".format(self.module.name))\n        #Some of the variables and parameters will have special kinds that need to be imported.\n        #Check each of the executables to find additional dependencies.\n        lines.append(\"  use {}\".format(self.module.name))\n        lines.append(\"  use ISO_C_BINDING\")\n        for modname in self.needs:\n            lines.append(\"  use {}\".format(modname))        \n        lines.append(\"  implicit none\")\n        lines.append(\"CONTAINS\")\n        #We want everything in these wrapper modules to be public, so we just exclude the 'private'.\n\n        for execkey in self.uses:\n            self._write_executable_f90(execkey, lines)\n\n        lines.append(\"END MODULE {}_c\".format(self.module.name))\n\n        fullpath = path.join(self.f90path, \"{}_c.f90\".format(self.module.name))\n        with open(fullpath, 'w') as f:\n            f.write('\\n'.join(lines))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _write_executable_f90(self, execname, lines):\n        executable = self.module.executables[execname]\n            \n        #The 14 in the formatting indent comes from 4 spaces, 2 from \"_c\", 1 from the spacing\n        #between 'subroutine' and name of the executable, 10 from subroutine, 1 from the (\"\n        cparams = present_params(_ctypes_ex_parameters(executable), len(execname) + 14)\n        lines.append(\"  subroutine {}_c({}) BIND(C)\".format(execname, cparams))\n        #Next, we add the variables declarations, the call to the original executable and then\n        #the handling of the output variables.\n        lines.append(\"    \" + \"\\n    \".join(_ctypes_ex_variables(executable)))\n        lines.append(\"    \" + \"\\n    \".join(_ctypes_ex_compatvars(executable)))\n\n        #Add assignment/allocate statements for the intent(in*) paramaters *local* variable\n        #declarations so that we can match the signature exactly.\n        lines.extend(_ctypes_ex_assign(executable))\n                \n        if type(executable).__name__  == \"Subroutine\":\n            prefix = \"call \"\n        else:\n            prefix = \"{}_f = \".format(execname)\n            \n        spacing = len(list(prefix)) + len(list(execname)) + 4\n        lines.append(\"    {}{}({})\".format(prefix, execname,\n                                           present_params(executable.paramorder, spacing, 90)))\n        lines.append(\"\")\n        lines.extend(_ctypes_ex_clean(executable))\n\n        lines.append(\"  end subroutine {}_c\\n\".format(execname))", "response": "Appends the Fortran code to write the wrapper executable to the specified lines list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the module and its dependencies to the result list in dependency order.", "response": "def _process_module_needs(self, modules):\n        \"\"\"Adds the module and its dependencies to the result list in dependency order.\"\"\"\n        result = list(modules)\n        for i, module in enumerate(modules):\n            #It is possible that the parser couldn't find it, if so\n            #we can't create the executable!\n            if module in self.module.parent.modules:\n                modneeds = self.module.parent.modules[module].needs\n                for modn in modneeds:\n                    if modn not in result:\n                        #Since this module depends on the other, insert the other\n                        #above it in the list.\n                        result.insert(i, modn)\n                    else:\n                        x = result.index(modn)\n                        if x > i:\n                            #We need to move this module higher up in the food chain\n                            #because it is needed sooner.\n                            result.remove(modn)\n                            result.insert(i, modn)\n\n                    newi = result.index(modn)\n            else:\n                raise ValueError(\"Unable to find module {}.\".format(module))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef coderelpath(coderoot, relpath):\n    from os import chdir, getcwd, path\n    cd = getcwd()\n    chdir(coderoot)\n    result = path.abspath(relpath)\n    chdir(cd)\n    return result", "response": "Returns the absolute path of the relpath relative to the specified code directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _setup_ssh(self):\n        global paramiko\n        if paramiko is none:\n            import paramiko\n\n        self.ssh = paramiko.SSHClient()\n        self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        self.ssh.connect(self.server, username=self.user, pkey=self.pkey)", "response": "Initializes the connection to the server via SSH."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the full path to the parent directory of the specified file path.", "response": "def dirname(self, path):\n        \"\"\"Returns the full path to the parent directory of the specified\n        file path.\"\"\"\n        if self.is_ssh(path):\n            remotepath = self._get_remote(path)\n            remotedir = os.path.dirname(remotepath)\n            return self._get_tramp_path(remotedir)\n        else:\n            return os.path.dirname(path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntouches the specified file so that its modified time changes.", "response": "def touch(self, filepath):\n        \"\"\"Touches the specified file so that its modified time changes.\"\"\"\n        if self.is_ssh(filepath):\n            self._check_ssh()\n            remotepath = self._get_remote(filepath)\n            stdin, stdout, stderr = self.ssh.exec_command(\"touch {}\".format(remotepath))\n            stdin.close()\n        else:\n            os.system(\"touch {}\".format(filepath))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreplacing the user root ~ with the full path on the file system.", "response": "def expanduser(self, filepath, ssh=False):\n        \"\"\"Replaces the user root ~ with the full path on the file system.\n        Works for local disks and remote servers. For remote servers, set\n        ssh=True.\"\"\"\n        if ssh:\n            self._check_ssh()\n            stdin, stdout, stderr = self.ssh.exec_command(\"cd; pwd\")\n            stdin.close()\n            remotepath = filepath.replace(\"~\", stdout.read().split()[0])\n            return self._get_tramp_path(remotepath)\n        else:\n            return os.path.expanduser(filepath)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndetermine if the specified file or folder exists even if it is on a remote server.", "response": "def exists(self, filepath):\n        \"\"\"Determines if the specified file/folder exists, even if it\n        is on a remote server.\"\"\"\n        if self.is_ssh(filepath):\n            self._check_ftp()\n            remotepath = self._get_remote(filepath)\n            try:\n                self.ftp.stat(remotepath)\n            except IOError as e:\n                if e.errno == errno.ENOENT:\n                    return False\n            else:\n                return True\n        else:\n            return os.path.exists(filepath)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getmtime(self, filepath):\n        if self.is_ssh(filepath):\n            self._check_ftp()\n            source = self._get_remote(filepath)\n            mtime = self.ftp.stat(source).st_mtime\n        else:\n            mtime = os.path.getmtime(filepath)\n\n        return mtime", "response": "Gets the last time that the file was modified."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the entire file as a string even if it is on a remote node.", "response": "def read(self, filepath):\n        \"\"\"Returns the entire file as a string even if it is on a remote\n        server.\"\"\"\n        target = self._read_check(filepath)\n\n        if os.path.isfile(target):\n            with open(target) as f:\n                string = f.read()\n\n            #If we got this file via SSH, delete it from the temp folder\n            if self.is_ssh(filepath):\n                os.remove(target)\n        else:\n            string = \"\"\n\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the file at filepath and returns a list of strings extracted from the file.", "response": "def readlines(self, filepath):\n        \"\"\"Returns the list of strings extracted from the file using either\n        open() if it is a local file, or by copying over the network using\n        sftp over SSH.\"\"\"\n        target = self._read_check(filepath)\n\n        if os.path.isfile(target):\n            with open(target) as f:\n                lines = f.readlines()\n\n            #If we got this file via SSH, delete it from the temp folder\n            if self.is_ssh(filepath):\n                os.remove(target)\n        else:\n            lines = []\n\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the path of a file on the local system that can be read from.", "response": "def _read_check(self, filepath):\n        \"\"\"Returns the path of a file on the *local* system that can be read\n        from. If the filepath is on a remote server, the file is first copied\n        locally.\"\"\"\n        if self.is_ssh(filepath):\n            self._check_ftp()\n            #First we need to generate a file path on the local system to\n            #copy the file to.\n            source = self._get_remote(filepath)\n            target = self._get_hashed_path(filepath)\n            self.ftp.get(source, target)\n            #Now we can just read it with the normal python commands.\n        else:\n            target = filepath\n        \n        return target"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef walk(self, dirpath):\n        if self.is_ssh(dirpath):\n            self._check_ftp()\n            remotepath = self._get_remote(dirpath)\n            return self._sftp_walk(remotepath)\n        else:\n            return os.walk(dirpath)", "response": "Performs an os. walk on a local or SSH filepath."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nperform the same function as os.walk but over the SSH channel.", "response": "def _sftp_walk(self, remotepath):\n        \"\"\"Performs the same function as os.walk but over the SSH channel.\"\"\"\n        #Get all the files and folders in the current directory over SFTP.\n        path = remotepath # We need this instance of path for the yield to work.\n        files=[]\n        folders=[]\n        for f in self.ftp.listdir_attr(remotepath):\n            if S_ISDIR(f.st_mode):\n                folders.append(self._get_tramp_path(f.filename))\n            else:\n                files.append(f.filename)\n        #We use yield so that if there are really large folders with \n        #complicated structures, we don't wait forever while the SFTP\n        #keeps traversing down the tree.\n        yield path, folders, files\n\n        #Now call this method recursively for each of sub-directories.\n        for folder in folders:\n            new_path = os.path.join(remotepath, folder)\n            for x in self._sftp_walk(new_path):\n                yield x"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an md5 hash for the specified file path.", "response": "def _get_hashed_path(self, path):\n        \"\"\"Returns an md5 hash for the specified file path.\"\"\"\n        return self._get_path('%s.pkl' % hashlib.md5(path.encode(\"utf-8\")).hexdigest())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating the cache directory if it doesn t exist. Returns the full path to the specified file inside the cache directory.", "response": "def _get_path(self, filename):\n        \"\"\"Creates the cache directory if it doesn't already exist. Returns the\n        full path to the specified file inside the cache directory.\"\"\"\n        tempdir = settings._temp_directory\n        if not os.path.exists(tempdir):\n            os.makedirs(tempdir)\n        return os.path.join(tempdir, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_pkey(self):\n        keypath = self.config.server[\"pkey\"]\n        with open(os.path.expanduser(keypath)) as f:\n            pkey = paramiko.RSAKey.from_private_key(f)\n\n        return pkey", "response": "Gets an RSAKey object for the private key file so that we can copy files without logging in with user password."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pkey(self):\n        if self._pkey is None:\n            self._pkey = self._get_pkey()\n\n        return self._pkey", "response": "Returns the private key for quick authentication on the SSH server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef present_params(paramlist, spacing = 0, maxchars=90, linecont=\", &\"):\n    #The +2 is spacing is for the tab indent at the start of the line.\n    #The +3 is for indent and the extra parenthesis at the start of the call.\n    line = []\n    length = 0\n    result = []\n\n    for param in paramlist:\n        extra = len(list(param))\n        if length + extra + 2 + spacing > maxchars:\n            result.append(\", \".join(line) + linecont)\n            line = [ param ]\n            length = extra + 2\n        else:\n            line.append(param)\n            length += extra + 2\n\n    #Add on the remaining bits of the line\n    result.append(\", \".join(line))\n\n    return \"\\n{}\".format(\" \".join([ \"\" for i in range(spacing + 3)])).join(result)", "response": "Creates the ( paramlist ) for a method call formatted nicely for calls\n    with lots of parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef metarate(self, func, name='values'):\n        setattr(func, name, self.values)\n        return func", "response": "Set the values object to the function s namespace\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef exit(self, status=0, message=None):\n        if status:\n            self.logger.error(message)\n        if self.__parser__:  # pylint: disable-msg=E1101\n            self.__parser__.exit(status, message)  # pylint: disable-msg=E1101\n        else:\n            sys.exit(status)", "response": "Delegates to ArgumentParser. exit and logs the exit message."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndelegates to ArgumentParser. error and exits with 2 exit code.", "response": "def error(self, message=None):\n        \"\"\"\n        Delegates to `ArgumentParser.error`\n        \"\"\"\n        if self.__parser__:  # pylint: disable-msg=E1101\n            self.__parser__.error(message)  # pylint: disable-msg=E1101\n        else:\n            self.logger.error(message)\n            sys.exit(2)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning the main command or sub command based on user input", "response": "def run(self, args=None):\n        \"\"\"\n        Runs the main command or sub command based on user input\n        \"\"\"\n\n        if not args:\n            args = self.parse(sys.argv[1:])\n\n        if getattr(args, 'verbose', False):\n            self.logger.setLevel(logging.DEBUG)\n\n        try:\n            if hasattr(args, 'run'):\n                args.run(self, args)\n            else:\n                self.__main__(args)  # pylint: disable-msg=E1101\n        except Exception as e:  # pylint: disable-msg=W0703\n            import traceback\n            self.logger.debug(traceback.format_exc())\n            self.logger.error(str(e))\n            if self.raise_exceptions:\n                raise\n            sys.exit(2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting a list of versions that an xml element references. Returns a [ 1 ] list if there isn t a versions attribute. Returns a [ 1 ] list if there isn t a versions attribute.", "response": "def _get_xml_version(element):\n    \"\"\"Extracts a list of versions that an xml element references. Returns\n    a [ 1 ] list if there isn't a versions attribute.\"\"\"\n    if \"versions\" in element.attrib:\n        result = [ int(v) for v in re.split(\",\\s*\", element.attrib[\"versions\"]) ]\n    else:\n        result = [ 1 ]\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the number of values recorded on this single line.", "response": "def nvalues(self):\n        \"\"\"Returns the number of values recorded on this single line. If the\n        number is variable, it returns -1.\"\"\"\n        if self._nvalues is None:\n            self._nvalues = 0\n            for val in self.values:\n                if type(val) == type(int):\n                    self._nvalues += val\n                else:\n                    self._nvalues = -1\n                    break\n\n        return self._nvalues"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the lines that this template line should add to the input file.", "response": "def write(self, valuedict):\n        \"\"\"Returns the lines that this template line should add to the input file.\"\"\"\n        if self.identifier in valuedict:\n            value = valuedict[self.identifier]\n        elif self.default is not None:\n            value = self.default\n        elif self.fromtag is not None and self.fromtag in valuedict:\n            if self.operator == \"count\":\n                value = len(valuedict[self.fromtag])\n            else:\n                msg.err(\"referenced 'from' attribute/operator {} not in xml dictionary.\".format(self.fromtag))\n                exit(1)\n        else:\n            msg.err(\"a required line {} had no value or default specified.\".format(self.identifier))\n            exit(1)            \n\n        #Before we generate the result, validate the choices if they exist\n        if len(self.choices) > 0:\n            for single in value:\n                if str(single) not in self.choices:\n                    msg.warn(\"failed choices validation for {} in {} (line {})\".format(\n                        single, self.choices, self.identifier))\n\n        result = []\n        #Get the string representation of the value\n        if isinstance(value, list):\n            sval = \" \".join([ str(val) for val in value])\n        else:\n            sval = str(value)\n\n        if self.comment != \"\" and (self.nvalues < 0 or self.nvalues > 5):\n            #We will put the comments on a separate line from the actual values.\n            result.append(self.comment)\n            result.append(sval)\n        else:\n            result.append(\"{} {}\".format(sval, self.comment))\n                    \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(self, element):\n        result = []\n        if element.text is not None and element.tag == self.identifier:\n            l, k = (0, 0)\n            raw = element.text.split()\n            while k < len(self.values):\n                dtype = self.dtype[k]\n                if isinstance(self.values[k], int):\n                    for i in range(self.values[k]):\n                        result.append(self._caster[dtype](raw[i + l]))\n                    l += self.values[k]\n                    k += 1\n                else:\n                    #This is a variable argument line, just use up the rest\n                    #of them as the type of the current line\n                    rest = [ self._caster[dtype](val) for val in raw[l::] ]\n                    result.extend(rest)\n                    break\n        else:\n            msg.warn(\"no results for parsing {} using line {}\".format(element.tag, self.identifier))\n\n        return result", "response": "Parses the contents of the specified XML element using template info."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _cast_int(self, value):\n        try:\n            return int(value)\n        except ValueError:\n            msg.err(\"Cannot convert {} to int for line {}.\".format(value, self.identifier))\n            exit(1)", "response": "Returns the specified value as int if possible."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _cast_float(self, value):\n        try:\n            return float(value)\n        except ValueError:\n            msg.err(\"Cannot convert {} to float for line {}.\".format(value, self.identifier))\n            exit(1)", "response": "Returns the specified value as float if possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _load(self, element, commentchar):\n        for child in element:            \n            if \"id\" in child.attrib:\n                tline = TemplateLine(child, self, commentchar)\n                self.order.append(tline.identifier)\n                self.lines[tline.identifier] = tline\n            else:\n                msg.warn(\"no id element in {}. Ignored. (group._load)\".format(child))", "response": "Loads all the child line elements from the XML group element."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse(self, element):\n        #All the children of this element are what we are trying to parse.\n        result = []\n        for child in element:\n            if child.tag in self.lines:\n                values = { child.tag: self.lines[child.tag].parse(child) }\n                result.append(values)\n\n        return result", "response": "Extracts the values from the specified XML element that is being converted."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating the lines for the converted input file using the specified value dictionary.", "response": "def write(self, valuedict):\n        \"\"\"Generates the lines for the converted input file using the specified\n        value dictionary.\"\"\"\n        result = []\n        if self.identifier in valuedict:\n            values = valuedict[self.identifier]\n        else:\n            return result\n\n        if self.comment != \"\":\n            result.append(self.comment)\n\n        if self.repeat is not None and type(values) == type([]):\n            if self.repeat.isdigit():\n                for i in range(int(self.repeat)):  \n                    result.extend(self._write_iterate(values[i]))\n            else:\n                #We are repeating for as many values as we have in the value\n                #entry for the group in the dictionary.\n                for value in values:\n                    result.extend(self._write_iterate(value))\n        elif type(values) == type({}):\n            #This group doesn't get repeated, so the values variable must\n            #be a dictionary, just run it once.\n            result = self._write_iterate(values)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the lines for a single pass through the group.", "response": "def _write_iterate(self, values):\n        \"\"\"Generates the lines for a single pass through the group.\"\"\"\n        result = []\n        for key in self.order:\n            result.append(self.lines[key].write(values))\n\n        if len(result) > 1:\n            return result\n        else:\n            return result[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting the XML template data from the file.", "response": "def _load(self):\n        \"\"\"Extracts the XML template data from the file.\"\"\"\n        if os.path.exists(self.path):\n            root = ET.parse(self.path).getroot()\n            if (root.tag == \"fortpy\" and \"mode\" in root.attrib and\n                root.attrib[\"mode\"] == \"template\" and \"direction\" in root.attrib and\n                root.attrib[\"direction\"] == self.direction):\n                #First, we need instances of the template contents for each of the\n                #versions listed in the fortpy tag.\n                for v in _get_xml_version(root):\n                    self.versions[v] = TemplateContents()\n                #Now we can update the contents objects using the XML data.\n                self._load_entries(root)\n\n                #See if a custom name was specified for the auto-converted\n                #files.\n                if \"autoname\" in root.attrib:\n                    self.name = root.attrib[\"autoname\"]\n            else:\n                msg.err(\"the specified template {} \".format(self.path) + \n                        \"is missing the mode and direction attributes.\")\n                exit(1)\n        else:\n            msg.err(\"could not find the template {}.\".format(self.path))\n            exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the XML file root of the available version numbers and returns a dictionary of values extracted from the root of the available version numbers.", "response": "def parse(self, root):\n        \"\"\"Returns a dictionary of values extracted from the root of the\n        specified XML file. It is assumed that the file is an input/output\n        file to be converted into plaintext. As such the file should only\n        specify a single version number.\"\"\"\n        #Use the first element in the versions list since there should only be one.\n        v = _get_xml_version(root)[0]\n        result = {}\n\n        for child in root:         \n            if child.tag in self.versions[v].entries:\n                entry = self.versions[v].entries[child.tag]\n                #Entry can be either a line or a group. Both objects have a parse\n                #method that returns a list of values. In the line's case, the\n                #list is the values from that line. For the group, it is a list\n                #of dictionaries, a dictionary for each tag name.\n                result[child.tag] = entry.parse(child)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating the lines for the converted input file from the valuedict.", "response": "def write(self, valuedict, version):\n        \"\"\"Generates the lines for the converted input file from the valuedict.\n\n        :arg valuedict: a dictionary of values where the keys are ids in the\n          template and the values obey their template rules.\n        :arg version: the target version of the output file.\n        \"\"\"\n        result = []\n\n        if version in self.versions:\n            for tag in self.versions[version].order:\n                entry = self.versions[version].entries[tag]\n                result.extend(entry.write(valuedict))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_entries(self, root):\n        mdict = {\n            \"comments\": self._comment,\n            \"line\": self._line,\n            \"group\": self._group\n        }\n        for entry in root:\n            mdict[entry.tag](entry)", "response": "Loads all the child entries of the input template from the \n        specified root element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract the character to use for comments in the input file.", "response": "def _comment(self, element):\n        \"\"\"Extracts the character to use for comments in the input file.\"\"\"\n        for v in _get_xml_version(element):\n            self.versions[v].comment = element.text"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the XML element as a single line entry in the input file.", "response": "def _line(self, element):\n        \"\"\"Parses the XML element as a single line entry in the input file.\"\"\"\n        for v in _get_xml_version(element):\n            if \"id\" in element.attrib:\n                tline = TemplateLine(element, None, self.versions[v].comment)\n                self.versions[v].entries[tline.identifier] = tline\n                self.versions[v].order.append(tline.identifier)\n            else:\n                msg.warn(\"no id element in {}. Ignored. (_line)\".format(element))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the XML element as a group of unknown number of lines.", "response": "def _group(self, element):\n        \"\"\"Parses the XML element as a group of [unknown] number of lines.\"\"\"\n        for v in _get_xml_version(element):\n            if \"name\" in element.attrib:\n                g = TemplateGroup(element, self.versions[v].comment)\n                self.versions[v].entries[g.identifier] = g\n                self.versions[v].order.append(g.identifier)\n            else:\n                msg.warn(\"no name element in {}. Ignored. (_group)\".format(element))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the specified file using the relevant template.", "response": "def convert(self, path, version, target = None):\n        \"\"\"Converts the specified file using the relevant template.\n\n        :arg path: the full path to the file to convert.\n        :arg version: the new version of the file.\n        :arg target: the optional path to save the file under. If not\n          specified, the file is saved based on the template file name.\n        \"\"\"\n        #Get the template and values out of the XML input file and\n        #write them in the format of the keywordless file.\n        values, template = self.parse(path)\n        lines = template.write(values, version)\n\n        #Finally, write the lines to the correct path.\n        if target is None:\n            target = os.path.join(os.path.dirname(path), template.name)\n\n        with open(os.path.expanduser(target), 'w') as f:\n            f.write(\"\\n\".join(lines))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts a dictionary of values from the XML file at the specified path.", "response": "def parse(self, path):\n        \"\"\"Extracts a dictionary of values from the XML file at the specified path.\"\"\"\n        #Load the template that will be used for parsing the values.\n        expath, template, root = self._load_template(path)\n        if expath is not None:\n            values = template.parse(root)\n\n        return (values, template)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert(self, path, version, target):\n        source = self.comparer.get_representation(path)\n        lines = [ '# <fortpy version=\"{}\"></fortpy>\\n'.format(version) ]\n\n        for line in self.comparer.template.contents[version].preamble:\n            lines.append(line.write(source.preamble, source.version, source.stored) + \"\\n\")\n\n        for line in self.comparer.template.contents[version].body:\n            for valueset in source.body:\n                lines.append(line.write(valueset, source.version, source.stored) + \"\\n\")\n\n        with open(os.path.expanduser(target), 'w') as f:\n            f.writelines(lines)", "response": "Converts the specified source file to a new version number."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cachedstr(self):\n        if self._cachedstr is None:\n            if self.module is not None:\n                refstring = self.module.refstring\n                self._cachedstr = refstring.splitlines()\n            else:\n                self._cachedstr = []\n\n        return self._cachedstr", "response": "Returns the full string of the file contents from the cache for\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef exact_match(self):\n        #We don't have to worry about grouping or anything else fancy. Just\n        #loop through forward and back until we hit a character that can't be\n        #part of a variable or function name.\n        if self._exact_match is None:\n            i = self.pos[1] - 1\n            start = None\n            end = None\n            line = self.current_line\n            terminators = ['(', ')', '\\n', ' ', '=', '%', ',']\n            while i >= 0 and start is None:\n                if line[i] in terminators:\n                    start = i + 1\n                i -= 1\n\n            i = self.pos[1]\n            while i < len(line) and end is None:\n                if line[i] in terminators:\n                    end = i\n                i += 1\n\n            self._exact_match = line[start:end].lower()\n\n        return self._exact_match", "response": "Returns the symbol under the cursor looking both directions as part\n        of a definition lookup for an exact match."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef short_symbol(self):\n        if self._short_symbol is None:\n            self._short_symbol = self._symbol_extract(cache.RE_CURSOR, False)\n\n        return self._short_symbol", "response": "Gets the short symbol for the current cursor excluding the\n            last character under the cursor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef short_full_symbol(self):\n        if self._short_full_symbol is None:\n            self._short_full_symbol = self._symbol_extract(cache.RE_FULL_CURSOR,\n                                                           False, True)\n\n        return self._short_full_symbol", "response": "Gets the full symbol excluding the character under the cursor."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the symbol under the current cursor.", "response": "def symbol(self):\n        \"\"\"Gets the symbol under the current cursor.\"\"\"\n        if self._symbol is None:\n            self._symbol = self._symbol_extract(cache.RE_CURSOR)\n            \n        return self._symbol"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the symbol under the cursor AND additional contextual symbols in the case of % - separated lists of type members.", "response": "def full_symbol(self):\n        \"\"\"Returns the symbol under the cursor AND additional contextual\n        symbols in the case of %-separated lists of type members.\"\"\"\n        if self._full_symbol is None:\n            self._full_symbol = self._symbol_extract(cache.RE_FULL_CURSOR, brackets=True)\n\n        return self._full_symbol"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts a symbol or full symbol from the current line.", "response": "def _symbol_extract(self, regex, plus = True, brackets=False):\n        \"\"\"Extracts a symbol or full symbol from the current line, \n        optionally including the character under the cursor.\n\n        :arg regex: the compiled regular expression to use for extraction.\n        :arg plus: when true, the character under the cursor *is* included.\n        :arg brackets: when true, matching pairs of brackets are first removed\n          before the regex is run.\n        \"\"\"\n        charplus = self.pos[1] + (1 if plus else -1)\n        consider = self.current_line[:charplus][::-1]\n\n        #We want to remove matching pairs of brackets so that derived types\n        #that have arrays still get intellisense.\n        if brackets==True:\n            #The string has already been reversed, just run through it.\n            rightb = []\n            lastchar = None\n            for i in range(len(consider)):\n                if consider[i] == \")\":\n                    rightb.append(i)\n                elif consider[i] == \"(\" and len(rightb) > 0:\n                    lastchar = i\n                    rightb.pop()\n\n            if lastchar is not None:\n                consider = '%' + consider[lastchar+1:]\n\n        rematch = regex.match(consider)\n        if rematch is not None:\n            return rematch.group(\"symbol\")[::-1]\n        else:\n            return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef call_arg_index(self):\n        #The function name we are calling should be in el_name by now\n        if self._call_index is None:\n            if (self.el_section == \"body\" and\n                self.el_call in [ \"sub\", \"fun\" ]):\n                #Get hold of the element instance of the function being called so\n                #we can examine its parameters.\n                fncall = self.el_name\n                if fncall in self.current_line[:self.pos[1]]:\n                    args = self.current_line[:self.pos[1]].split(fncall)[1]\n                else:\n                    args = \"\"\n\n                #This handles the case of the bracket-complete.\n                if args == \"\":\n                    return 0\n                #The nester requires each start bracket to have an end bracket\n                if args[-1] != \")\":\n                    args += \")\"\n\n                #Pyparsing handles calls where functions are being called as\n                #the values for parameters like function(a, fun(c,d), r).\n                try:\n                    nl = cache.nester.parseString(args).asList()[0]\n                    clean = [n for n in nl if not isinstance(n, list) and n != \",\"]\n                    #We need to specially handle the case where they have started typing the\n                    #name of the first parameter but haven't put a ',' in yet. In that case, \n                    #we are still on the first argument.\n                    if clean[-1][-1] != ',':\n                        self._call_index = len(clean) - 1\n                    else:\n                        self._call_index = len(clean)\n                except:\n                    msg.warn(\"ARG INDEX: lookup failed on bracket parsing.\")\n            \n        return self._call_index", "response": "Determines the index of the parameter in a call list using the string manipulation and context information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _setup_regex(self):\n        self.RE_COMMENTS = cache.RE_COMMENTS\n        self.RE_MODULE = cache.RE_MODULE\n        self.RE_TYPE = cache.RE_TYPE\n        self.RE_EXEC = cache.RE_EXEC\n        self.RE_MEMBERS = cache.RE_MEMBERS\n        self.RE_DEPEND = cache.RE_DEPEND", "response": "Sets up the constant regex strings that can be used to parse the strings for determining context."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds all the important attributes that determine the user s context.", "response": "def _contextualize(self):\n        \"\"\"Finds values for all the important attributes that determine the \n        user's context.\"\"\"\n        line, column = self.pos\n        #Get the module top-level information\n        self._get_module(line)\n        if self.module is None:\n            return\n        \n        #Use the position of the cursor in the file to decide which\n        #element we are working on.\n        self.element = self.module.get_element(line, column)\n\n        #Now all that's left is to contextualize the line that the\n        #cursor is on.\n        self._deep_match(line, column)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_module(self, line):\n        #Finding the module name is trivial; start at the beginning of\n        #the module and iterate lines until we find the module.\n        for sline in self._source:\n            if len(sline) > 0 and sline[0] != \"!\":\n                rmatch = self.RE_MODULE.match(sline)\n                if rmatch is not None:\n                    self.modulename = rmatch.group(\"name\")\n                    break\n        else:\n            #We don't even have the start of a module in this code file\n            return\n            \n        #Before we carry on with the rest of the context, find the separating\n        #CONTAINS keyword so we know whether to look for types or subs/funcs.\n        #If the code parser hasn't ever parsed this module, parse it now.\n        self.parser.isense_parse(self._orig_path, self.modulename)\n        self.module = self.parser.modules[self.modulename]\n\n        if line > self.module.contains_index:\n            self.section = \"contains\"", "response": "Finds the name of the module and retrieves it from the parser cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _deep_match(self, line, column):\n        #Now we just try each of the possibilities for the current line\n        if self._match_member(line, column):\n            self.el_section = \"vars\"\n            self.el_type = ValueElement\n            self.el_name = self.col_match.group(\"names\")\n            return\n             \n        if isinstance(self.element, Executable) or isinstance(self.element, Module):\n            #We are inside of a subroutine or function definition\n            #It is either params, vars or body. We already tested for variable\n            #declarations in the match_member test. Check now to see if we are\n            #on the line that defines the function\n            self._match_exec(line)\n            if self.col_match:\n                self.el_section = \"params\"\n                self.el_call = \"assign\"\n                return\n\n            #This regex incorrectly grabbing things like 'if' is functions because\n            #they do actually like like functions... We need to filter the list \n            #with special keywords before we claim victory. TODO\n            self.col_match = self.RE_DEPEND.match(self._source[line])\n            if self.col_match:\n                self.el_section = \"body\"\n                self.el_name = self.col_match.group(\"exec\")\n                if self.col_match.group(\"sub\") and \"call\" in self.col_match.group(\"sub\"):\n                    self.el_call = \"sub\"\n                    self.el_type = Subroutine\n                else:\n                    self.el_call = \"fun\"\n                    self.el_type = Function\n\n                return\n        #If we are inside a type, we either got the member variable declaration\n        #already, or it is a pointer to a method inside of the module. Add the\n        #test for that later. TODO\n#        if isinstance(self.element, CustomType):\n            \n        self.el_section = \"body\"\n        self.el_type = None\n        #We just need to figure out what kind of a call is being made\n        #at this column position, the only thing left is\n        if \" = \" in self._source[line]:\n            eqi = self._source[line].index(\"=\")\n            if column < eqi:\n                self.el_call = \"name\"\n            else:\n                self.el_call = \"assign\"\n            self.el_name = self._source[line].split(\"=\")[0].strip()\n        elif re.match(\"\\s*call\\s+\", self._source[line]):\n            self.el_call = \"sub\"\n            self.el_name = self._source[line].split(\"call \")[1]\n        else:\n            #The only thing left (and the hardest to nail down) is\n            #the arithmetic catch all type.\n            self.el_call = \"arith\"\n            self.el_name = \"[arith]\"", "response": "Checks the contents of executables types and modules for member variable declaration and updates the context."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _match_exec(self, i):\n        self.col_match = self.RE_EXEC.match(self._source[i])\n        if self.col_match is not None:\n            if self.col_match.group(\"codetype\") == \"function\":\n                self.el_type = Function\n            else:\n                self.el_type = Subroutine\n            self.el_name = self.col_match.group(\"name\")\n        \n            return True\n        else:\n            return False", "response": "Looks at line i for a subroutine or function definition. Returns True if the line is a subroutine or function definition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlooking at line i to see if the line matches a module member def.", "response": "def _match_member(self, i, column):\n        \"\"\"Looks at line 'i' to see if the line matches a module member def.\"\"\"\n        self.col_match = self.RE_MEMBERS.match(self._source[i])\n        if self.col_match is not None:\n            if column < self._source[i].index(\":\"):\n                self.el_call = \"name\"\n            else:\n                self.el_call = \"assign\"\n            \n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlooking at line i to see if the line matches a module user type def.", "response": "def _match_type(self, i):\n        \"\"\"Looks at line 'i' to see if the line matches a module user type def.\"\"\"\n        self.col_match = self.RE_TYPE.match(self._source[i])\n        if self.col_match is not None:\n            self.section = \"types\"\n            self.el_type = CustomType\n            self.el_name = self.col_match.group(\"name\")\n           \n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_geoserver(options):\n    fast = options.get('fast', False)\n    download_dir = path('downloaded')\n    if not download_dir.exists():\n        download_dir.makedirs()\n\n    geoserver_dir = path('geoserver')\n    geoserver_bin = path('geoserver_ext/target/geoserver.war')\n\n    if not geoserver_bin.exists():\n        geoserver_bin = download_dir / os.path.basename(ROGUE_GEOSERVER_URL)\n        grab(ROGUE_GEOSERVER_URL, geoserver_bin, \"geoserver binary\")\n\n    jetty_runner = download_dir / os.path.basename(JETTY_RUNNER_URL)\n    grab(JETTY_RUNNER_URL, jetty_runner, \"jetty runner\")\n\n    data_dir = download_dir / os.path.basename(DATA_DIR_URL)\n    grab(DATA_DIR_URL, data_dir, \"data dir\")\n\n    if not geoserver_dir.exists():\n        geoserver_dir.makedirs()\n\n        webapp_dir = geoserver_dir\n        if not webapp_dir:\n            webapp_dir.makedirs()\n\n        print 'extracting geoserver'\n        z = zipfile.ZipFile(geoserver_bin, \"r\")\n        z.extractall(webapp_dir)\n\n        # Set the geonode auth config to dev port 8000\n        sh(\"perl -pi.back -e 's/localhost/localhost:8000/g;' geoserver/data/security/auth/geonodeAuthProvider/config.xml\")", "response": "Prepare a testing instance of GeoServer."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds fake data migrations for existing tables from legacy GeoNode versions", "response": "def upgradedb(options):\n    \"\"\"\n    Add 'fake' data migrations for existing tables from legacy GeoNode versions\n    \"\"\"\n    version = options.get('version')\n    if version in ['1.1', '1.2']:\n        sh(\"python manage.py migrate maps 0001 --fake\")\n        sh(\"python manage.py migrate avatar 0001 --fake\")\n    elif version is None:\n        print \"Please specify your GeoNode version\"\n    else:\n        print \"Upgrades from version %s are not yet supported.\" % version"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef package(options):\n    import pkg_resources\n    import tarfile\n    import geonode\n\n    version = geonode.get_version()\n    # Use GeoNode's version for the package name.\n    pkgname = 'GeoNode-%s-all' % version\n\n    # Create the output directory.\n    out_pkg = path(pkgname)\n    out_pkg_tar = path(\"%s.tar.gz\" % pkgname)\n\n    # Create a distribution in zip format for the geonode python package.\n    dist_dir = path('dist')\n    dist_dir.rmtree()\n    sh('python setup.py sdist --formats=zip')\n\n    with pushd('package'):\n\n        #Delete old tar files in that directory\n        for f in glob.glob('GeoNode*.tar.gz'):\n            old_package = path(f)\n            if old_package != out_pkg_tar:\n                old_package.remove()\n\n        if out_pkg_tar.exists():\n            info('There is already a package for version %s' % version)\n            return\n\n        # Clean anything that is in the oupout package tree.\n        out_pkg.rmtree()\n        out_pkg.makedirs()\n\n        support_folder = path('support')\n        install_file = path('install.sh')\n\n        # And copy the default files from the package folder.\n        justcopy(support_folder, out_pkg / 'support')\n        justcopy(install_file, out_pkg)\n\n        geonode_dist = path('..') / 'dist' / 'GeoNode-%s.zip' % version\n        justcopy(geonode_dist, out_pkg)\n\n        rogue_dist = path('../..') / 'dist' / 'geoshape-0.1.zip'\n        justcopy(rogue_dist, out_pkg)\n\n        # Create a tar file with all files in the output package folder.\n        tar = tarfile.open(out_pkg_tar, \"w:gz\")\n        for file in out_pkg.walkfiles():\n            tar.add(file)\n\n        # Add the README with the license and important links to documentation.\n        tar.add('README', arcname=('%s/README.md' % out_pkg))\n        tar.close()\n\n        # Remove all the files in the temporary output package directory.\n        out_pkg.rmtree()\n\n    # Report the info about the new package.\n    info(\"%s created\" % out_pkg_tar.abspath())", "response": "Creates a tarball to use for building the system elsewhere."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start_geoserver(options):\n\n    from geonode.settings import OGC_SERVER \n    GEOSERVER_BASE_URL = OGC_SERVER['default']['LOCATION']\n\n    url = \"http://localhost:8080/geoserver/\"\n    if GEOSERVER_BASE_URL != url:\n        print 'your GEOSERVER_BASE_URL does not match %s' % url\n        sys.exit(1)\n\n    download_dir = path('downloaded').abspath()\n    jetty_runner = download_dir / os.path.basename(JETTY_RUNNER_URL)\n    data_dir = path('geoserver/data').abspath()\n    web_app = path('geoserver').abspath()\n    log_file = path('geoserver/jetty.log').abspath()\n\n    # @todo - we should not have set workdir to the datadir but a bug in geoserver\n    # prevents geonode security from initializing correctly otherwise\n    with pushd(data_dir):\n        sh(('java -Xmx512m -XX:MaxPermSize=256m'\n            ' -DGEOSERVER_DATA_DIR=%(data_dir)s'\n            # workaround for JAI sealed jar issue and jetty classloader\n            ' -Dorg.eclipse.jetty.server.webapp.parentLoaderPriority=true'\n            ' -jar %(jetty_runner)s'\n            ' --log %(log_file)s'\n            ' --path /geoserver %(web_app)s'\n            ' > /dev/null &' % locals()\n          ))\n\n    info('Starting GeoServer on %s' % url)\n\n    # wait for GeoServer to start\n    started = waitfor(url)\n    info('The logs are available at %s' % log_file)\n\n    if not started:\n        # If applications did not start in time we will give the user a chance\n        # to inspect them and stop them manually.\n        info(('GeoServer never started properly or timed out.'\n              'It may still be running in the background.'))\n        sys.exit(1)", "response": "Start the GeoServer with the specified options"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimports sample data (from gisdata package) into GeoNode", "response": "def setup_data():\n    \"\"\"\n    Import sample data (from gisdata package) into GeoNode\n    \"\"\"\n    import gisdata\n\n    ctype = options.get('type', None)\n\n    data_dir = gisdata.GOOD_DATA\n\n    if ctype in ['vector', 'raster', 'time']:\n        data_dir = os.path.join(gisdata.GOOD_DATA, ctype)\n\n    sh(\"python manage.py importlayers %s -v2\" % data_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a debian package for a GeoNode version", "response": "def deb(options):\n    \"\"\"\n    Creates debian packages.\n\n    Example uses:\n        paver deb\n        paver deb -k 12345\n        paver deb -k 12345 -p geonode/testing\n    \"\"\"\n    key = options.get('key', None)\n    ppa = options.get('ppa', None)\n\n    version, simple_version = versions()\n\n    info('Creating package for GeoNode version %s' % version)\n\n    with pushd('package'):\n        # Get rid of any uncommitted changes to debian/changelog\n        info('Getting rid of any uncommitted changes in debian/changelog')\n        sh('git checkout debian/changelog')\n\n        # Workaround for git-dch bug\n        # http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=594580\n        path('.git').makedirs()\n\n        # Install requirements\n        #sh('sudo apt-get -y install debhelper devscripts git-buildpackage')\n\n        sh(('git-dch --spawn-editor=snapshot --git-author --new-version=%s'\n            ' --id-length=6 --ignore-branch --release' % (\n            simple_version)))\n\n        deb_changelog = path('debian') / 'changelog'\n        for line in fileinput.input([deb_changelog], inplace = True):\n            print line.replace(\"urgency=low\", \"urgency=high\"),\n\n        ## Revert workaround for git-dhc bug\n        path('.git').rmtree()\n\n        if key is None and ppa is None:\n            # A local installable package\n            sh('debuild -uc -us -A')\n        elif key is None and ppa is not None:\n                # A sources package, signed by daemon\n                sh('debuild -S')\n        elif key is not None and ppa is None:\n                # A signed installable package\n                sh('debuild -k%s -A' % key)\n        elif key is not None and ppa is not None:\n                # A signed, source package\n                sh('debuild -k%s -S' % key)\n\n    if ppa is not None:\n        sh('dput ppa:%s geonode_%s_source.changes' % (ppa, simple_version))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _char2int(char):\n    if char.isdigit():\n        return int(float(char))\n    if char.isupper():\n        return int(char, 36)\n    else:\n        return 26 + int(char, 36)", "response": "translate characters to integer values"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the targeted name as if it was a comet.", "response": "def parse_comet(self):\n        \"\"\"Parse `targetname` as if it were a comet.\n\n        :return: (string or None, int or None, string or None);\n          The designation, number and prefix, and name of the comet as derived\n          from `self.targetname` are extracted into a tuple; each element that\n          does not exist is set to `None`. Parenthesis in `self.targetname`\n          will be ignored.\n        :example: the following table shows the result of the parsing:\n\n        +--------------------------------+--------------------------------+\n        |targetname                      |(desig, prefixnumber, name)     |\n        +================================+================================+\n        |1P/Halley                       |(None, '1P', 'Halley')          |\n        +--------------------------------+--------------------------------+\n        |3D/Biela                        |(None, '3D', 'Biela')           |\n        +--------------------------------+--------------------------------+\n        |9P/Tempel 1                     |(None, '9P', 'Tempel 1')        |\n        +--------------------------------+--------------------------------+\n        |73P/Schwassmann Wachmann 3 C    |(None, '73P',                   |\n        |                                |'Schwassmann Wachmann 3 C')     |\n        +--------------------------------+--------------------------------+\n        |73P-C/Schwassmann Wachmann 3 C  |(None, '73P-C',                 |\n        |                                |'Schwassmann Wachmann 3 C')     |\n        +--------------------------------+--------------------------------+\n        |73P-BB                          |(None, '73P-BB', None)          |\n        +--------------------------------+--------------------------------+\n        |322P                            |(None, '322P', None)            |\n        +--------------------------------+--------------------------------+\n        |X/1106 C1                       |('1166 C1', 'X', None)          |\n        +--------------------------------+--------------------------------+\n        |P/1994 N2 (McNaught-Hartley)    |('1994 N2', 'P',                |\n        |                                |'McNaught-Hartley')             |\n        +--------------------------------+--------------------------------+\n        |P/2001 YX127 (LINEAR)           |('2001 YX127', 'P', 'LINEAR')   |\n        +--------------------------------+--------------------------------+\n        |C/-146 P1                       |('-146 P1', 'C', None)          |\n        +--------------------------------+--------------------------------+\n        |C/2001 A2-A (LINEAR)            |('2001 A2-A', 'C', 'LINEAR')    |\n        +--------------------------------+--------------------------------+\n        |C/2013 US10                     |('2013 US10', 'C', None)        |\n        +--------------------------------+--------------------------------+\n        |C/2015 V2 (Johnson)             |('2015 V2', 'C', 'Johnson')     |\n        +--------------------------------+--------------------------------+\n        |C/2016 KA (Catalina)            |('2016 KA', 'C', 'Catalina')    |\n        +--------------------------------+--------------------------------+\n        \"\"\"\n\n        import re\n\n        pat = ('^(([1-9]+[PDCXAI](-[A-Z]{1,2})?)|[PDCXAI]/)' +  # prefix [0,1,2]\n               '|([-]?[0-9]{3,4}[ _][A-Z]{1,2}([0-9]{1,3})?(-[1-9A-Z]{0,2})?)' +\n               # designation [3,4]\n               ('|(([A-Z][a-z]?[A-Z]*[a-z]*[ -]?[A-Z]?[1-9]*[a-z]*)' +\n                '( [1-9A-Z]{1,2})*)')  # name [5,6]\n               )\n\n        m = re.findall(pat, self.targetname.strip())\n\n        # print(m)\n\n        prefixnumber = None\n        desig = None\n        name = None\n\n        if len(m) > 0:\n            for el in m:\n                # prefix/number\n                if len(el[0]) > 0:\n                    prefixnumber = el[0].replace('/', '')\n                # designation\n                if len(el[3]) > 0:\n                    desig = el[3].replace('_', ' ')\n                # name\n                if len(el[5]) > 0:\n                    if len(el[5]) > 1:\n                        name = el[5]\n\n        return (desig, prefixnumber, name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_asteroid(self):\n\n        pat = ('(([1-2][0-9]{0,3}[ _][A-Z]{2}[0-9]{0,3})'  # designation [0,1]\n               '|([1-9][0-9]{3}[ _](P-L|T-[1-3])))'  # Palomar-Leiden  [0,2,3]\n               '|([IJKL][0-9]{2}[A-Z][0-9a-z][0-9][A-Z])'  # packed desig [4]\n               '|([A-Za-z][0-9]{4})'  # packed number [5]\n               '|([A-Z][A-Z]*[a-z][a-z]*[^0-9]*'\n               '[ -]?[A-Z]?[a-z]*[^0-9]*)'  # name [6]\n               '|([1-9][0-9]*(\\b|$))')  # number [7,8]\n\n        # regex patterns that will be ignored as they might cause\n        # confusion\n        non_pat = ('([1-2][0-9]{0,3}[ _][A-Z][0-9]*(\\b|$))')  # comet desig\n\n        if sys.version_info > (3, 0):\n            raw = self.targetname.translate(str.maketrans('()', '  ')).strip()\n        else:\n            import string\n            raw = self.targetname.translate(string.maketrans('()',\n                                                             '  ')).strip()\n\n        # reject non_pat patterns\n        non_m = re.findall(non_pat, raw)\n        # print('reject', raw, non_m)\n        if len(non_m) > 0:\n            for ps in non_m:\n                for p in ps:\n                    if p == '':\n                        continue\n                    raw = raw[:raw.find(p)] + raw[raw.find(p)+len(p):]\n\n        # match target patterns\n        m = re.findall(pat, raw)\n\n        # print(raw, m)\n\n        desig = None\n        number = None\n        name = None\n\n        if len(m) > 0:\n            for el in m:\n                # designation\n                if len(el[0]) > 0:\n                    desig = el[0]\n                # packed designation (unpack here)\n                elif len(el[4]) > 0:\n                    ident = el[4]\n                # old designation style, e.g.: 1989AB\n                    if (len(ident.strip()) < 7 and ident[:4].isdigit() and\n                            ident[4:6].isalpha()):\n                        desig = ident[:4]+' '+ident[4:6]\n                        # Palomar Survey\n                    elif ident.find(\"PLS\") == 0:\n                        desig = ident[3:] + \" P-L\"\n                        # Trojan Surveys\n                    elif ident.find(\"T1S\") == 0:\n                        desig = ident[3:] + \" T-1\"\n                    elif ident.find(\"T2S\") == 0:\n                        desig = ident[3:] + \" T-2\"\n                    elif ident.find(\"T3S\") == 0:\n                        desig = ident[3:] + \" T-3\"\n                    # insert blank in designations\n                    elif (ident[0:4].isdigit() and ident[4:6].isalpha() and\n                          ident[4] != ' '):\n                        desig = ident[:4]+\" \"+ident[4:]\n                    # MPC packed 7-digit designation\n                    elif (ident[0].isalpha() and ident[1:3].isdigit() and\n                          ident[-1].isalpha() and ident[-2].isdigit()):\n                        yr = str(_char2int(ident[0]))+ident[1:3]\n                        let = ident[3]+ident[-1]\n                        num = str(_char2int(ident[4]))+ident[5]\n                        num = num.lstrip(\"0\")\n                        desig = yr+' '+let+num\n                    # nothing to do\n                    else:\n                        desig = ident\n                # packed number (unpack here)\n                elif len(el[5]) > 0:\n                    ident = el[5]\n                    number = ident = int(str(_char2int(ident[0]))+ident[1:])\n                # number\n                elif len(el[7]) > 0:\n                    if sys.version_info > (3, 0):\n                        number = int(float(el[7].translate(str.maketrans('()',\n                                                                         '  '))))\n                    else:\n                        import string\n                        number = int(float(el[7].translate(string.maketrans('()',\n                                                                            '  '))))\n\n                # name (strip here)\n                elif len(el[6]) > 0:\n                    if len(el[6].strip()) > 1:\n                        name = el[6].strip()\n\n        return (desig, number, name)", "response": "Parse the targeted asteroid."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntrue if the targetname appears to be a comet orbit record number.", "response": "def isorbit_record(self):\n        \"\"\"`True` if `targetname` appears to be a comet orbit record number.\n\n        NAIF record numbers are 6 digits, begin with a '9' and can\n        change at any time.\n\n        \"\"\"\n\n        import re\n        test = re.match('^9[0-9]{5}$', self.targetname.strip()) is not None\n        return test"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iscomet(self):\n\n        # treat this object as comet if there is a prefix/number\n        if self.comet is not None:\n            return self.comet\n        elif self.asteroid is not None:\n            return not self.asteroid\n        else:\n            return (self.parse_comet()[0] is not None or\n                    self.parse_comet()[1] is not None)", "response": "True if the name of the object is a comet."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isasteroid(self):\n        if self.asteroid is not None:\n            return self.asteroid\n        elif self.comet is not None:\n            return not self.comet\n        else:\n            return any(self.parse_asteroid()) is not None", "response": "True if the targeted name appears to be an asteroid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_epochrange(self, start_epoch, stop_epoch, step_size):\n        self.start_epoch = start_epoch\n        self.stop_epoch = stop_epoch\n        self.step_size = step_size\n\n        return None", "response": "Set a range of epochs for all times are UT\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset a list of discrete epochs for the current entry in the log", "response": "def set_discreteepochs(self, discreteepochs):\n        \"\"\"Set a list of discrete epochs, epochs have to be given as Julian\n        Dates\n\n        :param discreteepochs: array_like\n           list or 1D array of floats or strings\n        :return: None\n        :example: >>> import callhorizons\n                  >>> ceres = callhorizons.query('Ceres')\n                  >>> ceres.set_discreteepochs([2457446.177083, 2457446.182343])\n        \"\"\"\n        if not isinstance(discreteepochs, (list, np.ndarray)):\n            discreteepochs = [discreteepochs]\n\n        self.discreteepochs = list(discreteepochs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_ephemerides(self, observatory_code,\n                        airmass_lessthan=99,\n                        solar_elongation=(0, 180),\n                        skip_daylight=False):\n        \"\"\"Call JPL HORIZONS website to obtain ephemerides based on the\n        provided targetname, epochs, and observatory_code. For a list\n        of valid observatory codes, refer to\n        http://minorplanetcenter.net/iau/lists/ObsCodesF.html\n\n        :param observatory_code: str/int;\n           observer's location code according to Minor Planet Center\n        :param airmass_lessthan: float;\n           maximum airmass (optional, default: 99)\n        :param solar_elongation: tuple;\n           permissible solar elongation range (optional, deg)\n        :param skip_daylight: boolean;\n           crop daylight epoch during query (optional)\n        :result: int; number of epochs queried\n        :example: >>> ceres = callhorizons.query('Ceres')\n                  >>> ceres.set_epochrange('2016-02-23 00:00', '2016-02-24 00:00', '1h')\n                  >>> print (ceres.get_ephemerides(568), 'epochs queried')\n\n        The queried properties and their definitions are:\n           +------------------+-----------------------------------------------+\n           | Property         | Definition                                    |\n           +==================+===============================================+\n           | targetname       | official number, name, designation [string]   |\n           +------------------+-----------------------------------------------+\n           | H                | absolute magnitude in V band (float, mag)     |\n           +------------------+-----------------------------------------------+\n           | G                | photometric slope parameter (float)           |\n           +------------------+-----------------------------------------------+\n           | datetime         | epoch date and time (str, YYYY-MM-DD HH:MM:SS)|\n           +------------------+-----------------------------------------------+\n           | datetime_jd      | epoch Julian Date (float)                     |\n           +------------------+-----------------------------------------------+\n           | solar_presence   | information on Sun's presence (str)           |\n           +------------------+-----------------------------------------------+\n           | lunar_presence   | information on Moon's presence (str)          |\n           +------------------+-----------------------------------------------+\n           | RA               | target RA (float, J2000.0)                    |\n           +------------------+-----------------------------------------------+\n           | DEC              | target DEC (float, J2000.0)                   |\n           +------------------+-----------------------------------------------+\n           | RA_rate          | target rate RA (float, arcsec/s)              |\n           +------------------+-----------------------------------------------+\n           | DEC_rate         | target RA (float, arcsec/s, includes cos(DEC))|\n           +------------------+-----------------------------------------------+\n           | AZ               | Azimuth meas East(90) of North(0) (float, deg)|\n           +------------------+-----------------------------------------------+\n           | EL               | Elevation (float, deg)                        |\n           +------------------+-----------------------------------------------+\n           | airmass          | target optical airmass (float)                |\n           +------------------+-----------------------------------------------+\n           | magextinct       | V-mag extinction due airmass (float, mag)     |\n           +------------------+-----------------------------------------------+\n           | V                | V magnitude (comets: total mag) (float, mag)  |\n           +------------------+-----------------------------------------------+\n           | illumination     | fraction of illuminated disk (float)          |\n           +------------------+-----------------------------------------------+\n           | EclLon           | heliocentr. ecl. long. (float, deg, J2000.0)  |\n           +------------------+-----------------------------------------------+\n           | EclLat           | heliocentr. ecl. lat. (float, deg, J2000.0)   |\n           +------------------+-----------------------------------------------+\n           | ObsEclLon        | obscentr. ecl. long. (float, deg, J2000.0)    |\n           +------------------+-----------------------------------------------+\n           | ObsEclLat        | obscentr. ecl. lat. (float, deg, J2000.0)     |\n           +------------------+-----------------------------------------------+\n           | r                | heliocentric distance (float, au)             |\n           +------------------+-----------------------------------------------+\n           | r_rate           | heliocentric radial rate  (float, km/s)       |\n           +------------------+-----------------------------------------------+\n           | delta            | distance from the observer (float, au)        |\n           +------------------+-----------------------------------------------+\n           | delta_rate       | obs-centric radial rate (float, km/s)         |\n           +------------------+-----------------------------------------------+\n           | lighttime        | one-way light time (float, s)                 |\n           +------------------+-----------------------------------------------+\n           | elong            | solar elongation (float, deg)                 |\n           +------------------+-----------------------------------------------+\n           | elongFlag        | app. position relative to Sun (str)           |\n           +------------------+-----------------------------------------------+\n           | alpha            | solar phase angle (float, deg)                |\n           +------------------+-----------------------------------------------+\n           | sunTargetPA      | PA of Sun->target vector (float, deg, EoN)    |\n           +------------------+-----------------------------------------------+\n           | velocityPA       | PA of velocity vector (float, deg, EoN)       |\n           +------------------+-----------------------------------------------+\n           | GlxLon           | galactic longitude (float, deg)               |\n           +------------------+-----------------------------------------------+\n           | GlxLat           | galactic latitude  (float, deg)               |\n           +------------------+-----------------------------------------------+\n           | RA_3sigma        | 3sigma pos. unc. in RA (float, arcsec)        |\n           +------------------+-----------------------------------------------+\n           | DEC_3sigma       | 3sigma pos. unc. in DEC (float, arcsec)       |\n           +------------------+-----------------------------------------------+\n        \"\"\"\n\n        # queried fields (see HORIZONS website for details)\n        # if fields are added here, also update the field identification below\n        quantities = '1,3,4,8,9,10,18,19,20,21,23,24,27,31,33,36'\n\n        # encode objectname for use in URL\n        objectname = urllib.quote(self.targetname.encode(\"utf8\"))\n\n        # construct URL for HORIZONS query\n        url = \"https://ssd.jpl.nasa.gov/horizons_batch.cgi?batch=l\" \\\n            + \"&TABLE_TYPE='OBSERVER'\" \\\n            + \"&QUANTITIES='\" + str(quantities) + \"'\" \\\n              + \"&CSV_FORMAT='YES'\" \\\n              + \"&ANG_FORMAT='DEG'\" \\\n              + \"&CAL_FORMAT='BOTH'\" \\\n              + \"&SOLAR_ELONG='\" + str(solar_elongation[0]) + \",\" \\\n              + str(solar_elongation[1]) + \"'\" \\\n              + \"&CENTER='\"+str(observatory_code)+\"'\"\n\n        if self.not_smallbody:\n            url += \"&COMMAND='\" + \\\n                   urllib.quote(self.targetname.encode(\"utf8\")) + \"'\"\n        elif self.cap and self.comet:\n            for ident in self.parse_comet():\n                if ident is not None:\n                    break\n            if ident is None:\n                ident = self.targetname\n            url += \"&COMMAND='DES=\" + \\\n                   urllib.quote(ident.encode(\"utf8\")) + \"%3B\" + \\\n                   (\"CAP'\" if self.cap else \"'\")\n        elif self.isorbit_record():\n            # Comet orbit record. Do not use DES, CAP. This test must\n            # occur before asteroid test.\n            url += \"&COMMAND='\" + \\\n                   urllib.quote(self.targetname.encode(\"utf8\")) + \"%3B'\"\n        elif self.isasteroid() and not self.comet:\n            # for asteroids, use 'DES=\"designation\";'\n            for ident in self.parse_asteroid():\n                if ident is not None:\n                    break\n            if ident is None:\n                ident = self.targetname\n            url += \"&COMMAND='\" + \\\n                   urllib.quote(str(ident).encode(\"utf8\")) + \"%3B'\"\n        elif self.iscomet() and not self.asteroid:\n            # for comets, potentially append the current apparition\n            # (CAP) parameter, or the fragmentation flag (NOFRAG)\n            for ident in self.parse_comet():\n                if ident is not None:\n                    break\n            if ident is None:\n                ident = self.targetname\n            url += \"&COMMAND='DES=\" + \\\n                   urllib.quote(ident.encode(\"utf8\")) + \"%3B\" + \\\n                   (\"NOFRAG%3B\" if self.nofrag else \"\") + \\\n                   (\"CAP'\" if self.cap else \"'\")\n        # elif (not self.targetname.replace(' ', '').isalpha() and not\n        #      self.targetname.isdigit() and not\n        #      self.targetname.islower() and not\n        #      self.targetname.isupper()):\n        #     # lower case + upper case + numbers = pot. case sensitive designation\n        #     url += \"&COMMAND='DES=\" + \\\n        #            urllib.quote(self.targetname.encode(\"utf8\")) + \"%3B'\"\n        else:\n            url += \"&COMMAND='\" + \\\n                   urllib.quote(self.targetname.encode(\"utf8\")) + \"%3B'\"\n\n        if self.discreteepochs is not None:\n            url += \"&TLIST=\"\n            for date in self.discreteepochs:\n                url += \"'\" + str(date) + \"'\"\n        elif (self.start_epoch is not None and self.stop_epoch is not None and\n              self.step_size is not None):\n            url += \"&START_TIME='\" \\\n                + urllib.quote(self.start_epoch.encode(\"utf8\")) + \"'\" \\\n                + \"&STOP_TIME='\" \\\n                + urllib.quote(self.stop_epoch.encode(\"utf8\")) + \"'\" \\\n                + \"&STEP_SIZE='\" + str(self.step_size) + \"'\"\n        else:\n            raise IOError('no epoch information given')\n\n        if airmass_lessthan < 99:\n            url += \"&AIRMASS='\" + str(airmass_lessthan) + \"'\"\n\n        if skip_daylight:\n            url += \"&SKIP_DAYLT='YES'\"\n        else:\n            url += \"&SKIP_DAYLT='NO'\"\n\n        self.url = url\n\n        # print (url)\n\n        # call HORIZONS\n        i = 0  # count number of connection tries\n        while True:\n            try:\n                src = urllib.urlopen(url).readlines()\n                break\n            except urllib.URLError:\n                time.sleep(0.1)\n                # in case the HORIZONS website is blocked (due to another query)\n                # wait 0.1 second and try again\n            i += 1\n            if i > 50:\n                return 0  # website could not be reached\n\n        # disseminate website source code\n        # identify header line and extract data block (ephemerides data)\n        # also extract targetname, absolute mag. (H), and slope parameter (G)\n        headerline = []\n        datablock = []\n        in_datablock = False\n        H, G = np.nan, np.nan\n        for idx, line in enumerate(src):\n            line = line.decode('UTF-8')\n\n            if \"Date__(UT)__HR:MN\" in line:\n                headerline = line.split(',')\n            if \"$$EOE\\n\" in line:\n                in_datablock = False\n            if in_datablock:\n                datablock.append(line)\n            if \"$$SOE\\n\" in line:\n                in_datablock = True\n            if \"Target body name\" in line:\n                targetname = line[18:50].strip()\n            if (\"rotational period in hours)\" in\n                    src[idx].decode('UTF-8')):\n                HGline = src[idx+2].decode('UTF-8').split('=')\n                if 'B-V' in HGline[2] and 'G' in HGline[1]:\n                    try:\n                        H = float(HGline[1].rstrip('G'))\n                    except ValueError:\n                        pass\n                    try:\n                        G = float(HGline[2].rstrip('B-V'))\n                    except ValueError:\n                        pass\n            if (\"Multiple major-bodies match string\" in\n                src[idx].decode('UTF-8') or\n                (\"Matching small-bodies\" in src[idx].decode('UTF-8') and not\n                    \"No matches found\" in src[idx+1].decode('UTF-8'))):\n                raise ValueError('Ambiguous target name; check URL: %s' %\n                                 url)\n            if (\"Matching small-bodies\" in src[idx].decode('UTF-8') and\n                    \"No matches found\" in src[idx+1].decode('UTF-8')):\n                raise ValueError('Unknown target; check URL: %s' % url)\n\n        # field identification for each line\n        ephemerides = []\n        for line in datablock:\n            line = line.split(',')\n\n            # ignore line that don't hold any data\n            if len(line) < len(quantities.split(',')):\n                continue\n\n            this_eph = []\n            fieldnames = []\n            datatypes = []\n\n            # create a dictionary for each date (each line)\n            for idx, item in enumerate(headerline):\n\n                if ('Date__(UT)__HR:MN' in item):\n                    this_eph.append(line[idx].strip())\n                    fieldnames.append('datetime')\n                    datatypes.append(object)\n                if ('Date_________JDUT' in item):\n                    this_eph.append(np.float64(line[idx]))\n                    fieldnames.append('datetime_jd')\n                    datatypes.append(np.float64)\n                    # read out and convert solar presence\n                    try:\n                        this_eph.append({'*': 'daylight', 'C': 'civil twilight',\n                                         'N': 'nautical twilight',\n                                         'A': 'astronomical twilight',\n                                         ' ': 'dark',\n                                         't': 'transiting'}[line[idx+1]])\n                    except KeyError:\n                        this_eph.append('n.a.')\n                    fieldnames.append('solar_presence')\n                    datatypes.append(object)\n                    # read out and convert lunar presence\n                    try:\n                        this_eph.append({'m': 'moonlight',\n                                         ' ': 'dark'}[line[idx+2]])\n                    except KeyError:\n                        this_eph.append('n.a.')\n                    fieldnames.append('lunar_presence')\n                    datatypes.append(object)\n                if (item.find('R.A._(ICRF/J2000.0)') > -1):\n                    this_eph.append(np.float64(line[idx]))\n                    fieldnames.append('RA')\n                    datatypes.append(np.float64)\n                if (item.find('DEC_(ICRF/J2000.0)') > -1):\n                    this_eph.append(np.float64(line[idx]))\n                    fieldnames.append('DEC')\n                    datatypes.append(np.float64)\n                if (item.find('dRA*cosD') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx])/3600.)  # \"/s\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('RA_rate')\n                    datatypes.append(np.float64)\n                if (item.find('d(DEC)/dt') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx])/3600.)  # \"/s\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('DEC_rate')\n                    datatypes.append(np.float64)\n                if (item.find('Azi_(a-app)') > -1):\n                    try:  # if AZ not given, e.g. for space telescopes\n                        this_eph.append(np.float64(line[idx]))\n                        fieldnames.append('AZ')\n                        datatypes.append(np.float64)\n                    except ValueError:\n                        pass\n                if (item.find('Elev_(a-app)') > -1):\n                    try:  # if EL not given, e.g. for space telescopes\n                        this_eph.append(np.float64(line[idx]))\n                        fieldnames.append('EL')\n                        datatypes.append(np.float64)\n                    except ValueError:\n                        pass\n                if (item.find('a-mass') > -1):\n                    try:  # if airmass not given, e.g. for space telescopes\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('airmass')\n                    datatypes.append(np.float64)\n                if (item.find('mag_ex') > -1):\n                    try:  # if mag_ex not given, e.g. for space telescopes\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('magextinct')\n                    datatypes.append(np.float64)\n                if (item.find('APmag') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('V')\n                    datatypes.append(np.float64)\n                if (item.find('Illu%') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('illumination')\n                    datatypes.append(np.float64)\n                if (item.find('hEcl-Lon') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('EclLon')\n                    datatypes.append(np.float64)\n                if (item.find('hEcl-Lat') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('EclLat')\n                    datatypes.append(np.float64)\n                if (item.find('ObsEcLon') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('ObsEclLon')\n                    datatypes.append(np.float64)\n                if (item.find('ObsEcLat') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('ObsEclLat')\n                    datatypes.append(np.float64)\n                if (item.find('  r') > -1) and \\\n                   (headerline[idx+1].find(\"rdot\") > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('r')\n                    datatypes.append(np.float64)\n                if (item.find('rdot') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('r_rate')\n                    datatypes.append(np.float64)\n                if (item.find('delta') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('delta')\n                    datatypes.append(np.float64)\n                if (item.find('deldot') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('delta_rate')\n                    datatypes.append(np.float64)\n                if (item.find('1-way_LT') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx])*60.)  # seconds\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('lighttime')\n                    datatypes.append(np.float64)\n                if (item.find('S-O-T') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('elong')\n                    datatypes.append(np.float64)\n                # in the case of space telescopes, '/r     S-T-O' is used;\n                # ground-based telescopes have both parameters in separate\n                # columns\n                if (item.find('/r    S-T-O') > -1):\n                    this_eph.append({'/L': 'leading', '/T': 'trailing'}\n                                    [line[idx].split()[0]])\n                    fieldnames.append('elongFlag')\n                    datatypes.append(object)\n                    try:\n                        this_eph.append(np.float64(line[idx].split()[1]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('alpha')\n                    datatypes.append(np.float64)\n                elif (item.find('S-T-O') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('alpha')\n                    datatypes.append(np.float64)\n                elif (item.find('/r') > -1):\n                    this_eph.append({'/L': 'leading', '/T': 'trailing',\n                                     '/?': 'not defined'}\n                                    [line[idx]])\n                    fieldnames.append('elongFlag')\n                    datatypes.append(object)\n                if (item.find('PsAng') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('sunTargetPA')\n                    datatypes.append(np.float64)\n                if (item.find('PsAMV') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('velocityPA')\n                    datatypes.append(np.float64)\n                if (item.find('GlxLon') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('GlxLon')\n                    datatypes.append(np.float64)\n                if (item.find('GlxLat') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('GlxLat')\n                    datatypes.append(np.float64)\n                if (item.find('RA_3sigma') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('RA_3sigma')\n                    datatypes.append(np.float64)\n                if (item.find('DEC_3sigma') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('DEC_3sigma')\n                    datatypes.append(np.float64)\n                # in the case of a comet, use total mag for V\n                if (item.find('T-mag') > -1):\n                    try:\n                        this_eph.append(np.float64(line[idx]))\n                    except ValueError:\n                        this_eph.append(np.nan)\n                    fieldnames.append('V')\n                    datatypes.append(np.float64)\n\n            # append target name\n            this_eph.append(targetname)\n            fieldnames.append('targetname')\n            datatypes.append(object)\n\n            # append H\n            this_eph.append(H)\n            fieldnames.append('H')\n            datatypes.append(np.float64)\n\n            # append G\n            this_eph.append(G)\n            fieldnames.append('G')\n            datatypes.append(np.float64)\n\n            if len(this_eph) > 0:\n                ephemerides.append(tuple(this_eph))\n\n        if len(ephemerides) == 0:\n            return 0\n\n        # combine ephemerides with column names and data types into ndarray\n        assert len(ephemerides[0]) == len(fieldnames) == len(datatypes)\n        self.data = np.array(ephemerides,\n                             dtype=[(str(fieldnames[i]), datatypes[i]) for i\n                                    in range(len(fieldnames))])\n\n        return len(self)", "response": "This method returns the ephemerides of the given targetname epochs and airmass_lessthan solar_elongation and solar presence of the given airmass."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling JPL HORIZONS website to obtain orbital elements based on the provided targetname, epochs, and center code. For valid center codes, please refer to http://ssd.jpl.nasa.gov/horizons.cgi :param center: str; center body (default: 500@10 = Sun) :result: int; number of epochs queried :example: >>> ceres = callhorizons.query('Ceres') >>> ceres.set_epochrange('2016-02-23 00:00', '2016-02-24 00:00', '1h') >>> print (ceres.get_elements(), 'epochs queried') The queried properties and their definitions are: +------------------+-----------------------------------------------+ | Property | Definition | +==================+===============================================+ | targetname | official number, name, designation [string] | +------------------+-----------------------------------------------+ | H | absolute magnitude in V band (float, mag) | +------------------+-----------------------------------------------+ | G | photometric slope parameter (float) | +------------------+-----------------------------------------------+ | datetime_jd | epoch Julian Date (float) | +------------------+-----------------------------------------------+ | e | eccentricity (float) | +------------------+-----------------------------------------------+ | p | periapsis distance (float, au) | +------------------+-----------------------------------------------+ | a | semi-major axis (float, au) | +------------------+-----------------------------------------------+ | incl | inclination (float, deg) | +------------------+-----------------------------------------------+ | node | longitude of Asc. Node (float, deg) | +------------------+-----------------------------------------------+ | argper | argument of the perifocus (float, deg) | +------------------+-----------------------------------------------+ | Tp | time of periapsis (float, Julian Date) | +------------------+-----------------------------------------------+ | meananomaly | mean anomaly (float, deg) | +------------------+-----------------------------------------------+ | trueanomaly | true anomaly (float, deg) | +------------------+-----------------------------------------------+ | period | orbital period (float, Earth yr) | +------------------+-----------------------------------------------+ | Q | apoapsis distance (float, au) | +------------------+-----------------------------------------------+", "response": "def get_elements(self, center='500@10', asteroid=False, comet=False):\n        \"\"\"Call JPL HORIZONS website to obtain orbital elements based on the\n        provided targetname, epochs, and center code. For valid center\n        codes, please refer to http://ssd.jpl.nasa.gov/horizons.cgi\n\n        :param center:  str;\n           center body (default: 500@10 = Sun)\n        :result: int; number of epochs queried\n        :example: >>> ceres = callhorizons.query('Ceres')\n                  >>> ceres.set_epochrange('2016-02-23 00:00', '2016-02-24 00:00', '1h')\n                  >>> print (ceres.get_elements(), 'epochs queried')\n\n        The queried properties and their definitions are:\n           +------------------+-----------------------------------------------+\n           | Property         | Definition                                    |\n           +==================+===============================================+\n           | targetname       | official number, name, designation [string]   |\n           +------------------+-----------------------------------------------+\n           | H                | absolute magnitude in V band (float, mag)     |\n           +------------------+-----------------------------------------------+\n           | G                | photometric slope parameter (float)           |\n           +------------------+-----------------------------------------------+\n           | datetime_jd      | epoch Julian Date (float)                     |\n           +------------------+-----------------------------------------------+\n           | e                | eccentricity (float)                          |\n           +------------------+-----------------------------------------------+\n           | p                | periapsis distance (float, au)                |\n           +------------------+-----------------------------------------------+\n           | a                | semi-major axis (float, au)                   |\n           +------------------+-----------------------------------------------+\n           | incl             | inclination (float, deg)                      |\n           +------------------+-----------------------------------------------+\n           | node             | longitude of Asc. Node (float, deg)           |\n           +------------------+-----------------------------------------------+\n           | argper           | argument of the perifocus (float, deg)        |\n           +------------------+-----------------------------------------------+\n           | Tp               | time of periapsis (float, Julian Date)        |\n           +------------------+-----------------------------------------------+\n           | meananomaly      | mean anomaly (float, deg)                     |\n           +------------------+-----------------------------------------------+\n           | trueanomaly      | true anomaly (float, deg)                     |\n           +------------------+-----------------------------------------------+\n           | period           | orbital period (float, Earth yr)              |\n           +------------------+-----------------------------------------------+\n           | Q                | apoapsis distance (float, au)                 |\n           +------------------+-----------------------------------------------+\n        \"\"\"\n\n        # encode objectname for use in URL\n        objectname = urllib.quote(self.targetname.encode(\"utf8\"))\n\n        # call Horizons website and extract data\n        url = \"https://ssd.jpl.nasa.gov/horizons_batch.cgi?batch=l\" \\\n            + \"&TABLE_TYPE='ELEMENTS'\" \\\n            + \"&CSV_FORMAT='YES'\" \\\n              + \"&CENTER='\" + str(center) + \"'\" \\\n              + \"&OUT_UNITS='AU-D'\" \\\n              + \"&REF_PLANE='ECLIPTIC'\" \\\n              + \"REF_SYSTEM='J2000'\" \\\n              + \"&TP_TYPE='ABSOLUTE'\" \\\n              + \"&ELEM_LABELS='YES'\" \\\n              + \"CSV_FORMAT='YES'\" \\\n              + \"&OBJ_DATA='YES'\"\n\n        # check if self.targetname is a designation\n        # lower case + upper case + numbers = pot. case sensitive designation\n        if self.not_smallbody:\n            url += \"&COMMAND='\" + \\\n                   urllib.quote(self.targetname.encode(\"utf8\")) + \"'\"\n        elif self.isorbit_record():\n            # Comet orbit record. Do not use DES, CAP. This test must\n            # occur before asteroid test.\n            url += \"&COMMAND='\" + \\\n                   urllib.quote(self.targetname.encode(\"utf8\")) + \"%3B'\"\n        elif self.isasteroid() and not self.comet:\n            # for asteroids, use 'DES=\"designation\";'\n            for ident in self.parse_asteroid():\n                if ident is not None:\n                    break\n            if ident is None:\n                ident = self.targetname\n            url += \"&COMMAND='\" + \\\n                   urllib.quote(str(ident).encode(\"utf8\")) + \"%3B'\"\n        elif self.iscomet() and not self.asteroid:\n            # for comets, potentially append the current apparition\n            # (CAP) parameter, or the fragmentation flag (NOFRAG)\n            for ident in self.parse_comet():\n                if ident is not None:\n                    break\n            if ident is None:\n                ident = self.targetname\n            url += \"&COMMAND='DES=\" + \\\n                   urllib.quote(ident.encode(\"utf8\")) + \"%3B\" + \\\n                   (\"NOFRAG%3B\" if self.nofrag else \"\") + \\\n                   (\"CAP'\" if self.cap else \"'\")\n        # elif (not self.targetname.replace(' ', '').isalpha() and not\n        #      self.targetname.isdigit() and not\n        #      self.targetname.islower() and not\n        #      self.targetname.isupper()):\n        #     url += \"&COMMAND='DES=\" + str(objectname) + \"%3B'\"\n        else:\n            url += \"&COMMAND='\" + str(objectname) + \"%3B'\"\n\n        if self.discreteepochs is not None:\n            url += \"&TLIST=\"\n            for date in self.discreteepochs:\n                url += \"'\" + str(date) + \"'\"\n        elif (self.start_epoch is not None and self.stop_epoch is not None and\n              self.step_size is not None):\n            url += \"&START_TIME='\" \\\n                + urllib.quote(self.start_epoch.encode(\"utf8\")) + \"'\" \\\n                + \"&STOP_TIME='\" \\\n                + urllib.quote(self.stop_epoch.encode(\"utf8\")) + \"'\" \\\n                + \"&STEP_SIZE='\" + str(self.step_size) + \"'\"\n        else:\n            raise IOError('no epoch information given')\n\n        self.url = url\n\n        i = 0  # count number of connection tries\n        while True:\n            try:\n                src = urllib.urlopen(url).readlines()\n                break\n            except urllib.URLError:\n                time.sleep(0.1)\n                # in case the HORIZONS website is blocked (due to another query)\n                # wait 1 second and try again\n            i += 1\n            if i > 50:\n                return 0  # website could not be reached\n\n        # disseminate website source code\n        # identify header line and extract data block (elements data)\n        # also extract targetname, abs. magnitude (H), and slope parameter (G)\n        headerline = []\n        datablock = []\n        in_datablock = False\n        H, G = np.nan, np.nan\n        for idx, line in enumerate(src):\n            line = line.decode('UTF-8')\n\n            if 'JDTDB,' in line:\n                headerline = line.split(',')\n            if \"$$EOE\\n\" in line:\n                in_datablock = False\n            if in_datablock:\n                datablock.append(line)\n            if \"$$SOE\\n\" in line:\n                in_datablock = True\n            if \"Target body name\" in line:\n                targetname = line[18:50].strip()\n            if \"rotational period in hours)\" in src[idx].decode('UTF-8'):\n                HGline = src[idx+2].decode('UTF-8').split('=')\n                if 'B-V' in HGline[2] and 'G' in HGline[1]:\n                    try:\n                        H = float(HGline[1].rstrip('G'))\n                    except ValueError:\n                        pass\n                    try:\n                        G = float(HGline[2].rstrip('B-V'))\n                    except ValueError:\n                        pass\n            if (\"Multiple major-bodies match string\" in src[idx].decode('UTF-8') or\n                (\"Matching small-bodies\" in src[idx].decode('UTF-8') and not\n                    \"No matches found\" in src[idx+1].decode('UTF-8'))):\n                raise ValueError('Ambiguous target name; check URL: %s' %\n                                 url)\n            if (\"Matching small-bodies\" in src[idx].decode('UTF-8') and\n                    \"No matches found\" in src[idx+1].decode('UTF-8')):\n                raise ValueError('Unknown target; check URL: %s' % url)\n\n        # field identification for each line in\n        elements = []\n        for line in datablock:\n            line = line.split(',')\n\n            this_el = []\n            fieldnames = []\n            datatypes = []\n\n            # create a dictionary for each date (each line)\n            for idx, item in enumerate(headerline):\n                if (item.find('JDTDB') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('datetime_jd')\n                    datatypes.append(np.float64)\n                if (item.find('EC') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('e')\n                    datatypes.append(np.float64)\n                if (item.find('QR') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('p')\n                    datatypes.append(np.float64)\n                if (item.find('A') > -1) and len(item.strip()) == 1:\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('a')\n                    datatypes.append(np.float64)\n                if (item.find('IN') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('incl')\n                    datatypes.append(np.float64)\n                if (item.find('OM') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('node')\n                    datatypes.append(np.float64)\n                if (item.find('W') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('argper')\n                    datatypes.append(np.float64)\n                if (item.find('Tp') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('Tp')\n                    datatypes.append(np.float64)\n                if (item.find('MA') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('meananomaly')\n                    datatypes.append(np.float64)\n                if (item.find('TA') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('trueanomaly')\n                    datatypes.append(np.float64)\n                if (item.find('PR') > -1):\n                    # Earth years\n                    this_el.append(np.float64(line[idx])/(365.256))\n                    fieldnames.append('period')\n                    datatypes.append(np.float64)\n                if (item.find('AD') > -1):\n                    this_el.append(np.float64(line[idx]))\n                    fieldnames.append('Q')\n                    datatypes.append(np.float64)\n\n            # append targetname\n            this_el.append(targetname)\n            fieldnames.append('targetname')\n            datatypes.append(object)\n\n            # append H\n            this_el.append(H)\n            fieldnames.append('H')\n            datatypes.append(np.float64)\n\n            # append G\n            this_el.append(G)\n            fieldnames.append('G')\n            datatypes.append(np.float64)\n\n            if len(this_el) > 0:\n                elements.append(tuple(this_el))\n\n        if len(elements) == 0:\n            return 0\n\n        # combine elements with column names and data types into ndarray\n        assert len(elements[0]) == len(fieldnames) == len(datatypes)\n        self.data = np.array(elements,\n                             dtype=[(str(fieldnames[i]), datatypes[i]) for i\n                                    in range(len(fieldnames))])\n\n        return len(self)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling JPL HORIZONS website to obtain orbital elements based on the provided targetname, epochs, and center code and create a PyEphem (http://rhodesmill.org/pyephem/) object. This function requires PyEphem to be installed. :param center: str; center body (default: 500@10 = Sun) :param equinox: float; equinox (default: 2000.0) :result: list; list of PyEphem objects, one per epoch :example: >>> import callhorizons >>> import numpy >>> import ephem >>> >>> ceres = callhorizons.query('Ceres') >>> ceres.set_epochrange('2016-02-23 00:00', '2016-02-24 00:00', '1h') >>> ceres_pyephem = ceres.export2pyephem() >>> >>> nau = ephem.Observer() # setup observer site >>> nau.lon = -111.653152/180.*numpy.pi >>> nau.lat = 35.184108/180.*numpy.pi >>> nau.elevation = 2100 # m >>> nau.date = '2015/10/5 01:23' # UT >>> print ('next rising: %s' % nau.next_rising(ceres_pyephem[0])) >>> print ('next transit: %s' % nau.next_transit(ceres_pyephem[0])) >>> print ('next setting: %s' % nau.next_setting(ceres_pyephem[0]))", "response": "def export2pyephem(self, center='500@10', equinox=2000.):\n        \"\"\"Call JPL HORIZONS website to obtain orbital elements based on the\n        provided targetname, epochs, and center code and create a\n        PyEphem (http://rhodesmill.org/pyephem/) object. This function\n        requires PyEphem to be installed.\n\n        :param center: str;\n           center body (default: 500@10 = Sun)\n        :param equinox: float;\n           equinox (default: 2000.0)\n        :result: list;\n           list of PyEphem objects, one per epoch\n        :example: >>> import callhorizons\n                  >>> import numpy\n                  >>> import ephem\n                  >>>\n                  >>> ceres = callhorizons.query('Ceres')\n                  >>> ceres.set_epochrange('2016-02-23 00:00', '2016-02-24 00:00', '1h')\n                  >>> ceres_pyephem = ceres.export2pyephem()\n                  >>>\n                  >>> nau = ephem.Observer() # setup observer site\n                  >>> nau.lon = -111.653152/180.*numpy.pi\n                  >>> nau.lat = 35.184108/180.*numpy.pi\n                  >>> nau.elevation = 2100 # m\n                  >>> nau.date = '2015/10/5 01:23' # UT\n                  >>> print ('next rising: %s' % nau.next_rising(ceres_pyephem[0]))\n                  >>> print ('next transit: %s' % nau.next_transit(ceres_pyephem[0]))\n                  >>> print ('next setting: %s' % nau.next_setting(ceres_pyephem[0]))\n        \"\"\"\n\n        try:\n            import ephem\n        except ImportError:\n            raise ImportError(\n                'export2pyephem requires PyEphem to be installed')\n\n        # obtain orbital elements\n        self.get_elements(center)\n\n        objects = []\n        for el in self.data:\n            n = 0.9856076686/np.sqrt(el['a']**3)  # mean daily motion\n            epoch_djd = el['datetime_jd']-2415020.0  # Dublin Julian date\n            epoch = ephem.date(epoch_djd)\n            epoch_str = \"%d/%f/%d\" % (epoch.triple()[1], epoch.triple()[2],\n                                      epoch.triple()[0])\n\n            # export to PyEphem\n            objects.append(ephem.readdb(\"%s,e,%f,%f,%f,%f,%f,%f,%f,%s,%i,%f,%f\" %\n                                        (el['targetname'], el['incl'], el['node'],\n                                         el['argper'], el['a'], n, el['e'],\n                                            el['meananomaly'], epoch_str, equinox,\n                                            el['H'], el['G'])))\n\n        return objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds the following array of urls to the resource base urls", "response": "def prepend_urls(self):\n        \"\"\" Add the following array of urls to the resource base urls \"\"\"\n        return [\n            url(r\"^(?P<resource_name>%s)/view/(?P<name>[\\w\\d_.-]+)%s$\" % (self._meta.resource_name, trailing_slash()),\n                self.wrap_view('view'), name=\"api_fileitem_view\"),\n            url(r\"^(?P<resource_name>%s)/download/(?P<name>[\\w\\d_.-]+)%s$\" % (\n            self._meta.resource_name, trailing_slash()), self.wrap_view('download'), name=\"api_fileitem_download\"),\n            url(r\"^(?P<resource_name>%s)/(?P<pk>\\w[\\w/-]*)/download%s$\" % (self._meta.resource_name, trailing_slash()),\n                self.wrap_view('download'), name=\"api_fileitem_download\"),\n            url(r\"^(?P<resource_name>%s)/(?P<name>[\\w\\d_.-]+)/download%s$\"\n                % (self._meta.resource_name, trailing_slash()), self.wrap_view('download'),\n                name=\"api_fileitem_download\"),\n            url(r\"^(?P<resource_name>%s)/(?P<pk>\\w[\\w/-]*)/view%s$\"\n                % (self._meta.resource_name, trailing_slash()), self.wrap_view('view'), name=\"api_fileitem_view\"),\n            url(r\"^(?P<resource_name>%s)/(?P<name>[\\w\\d_.-]+)/view%s$\"\n                % (self._meta.resource_name, trailing_slash()), self.wrap_view('view'), name=\"api_fileitem_view\"),\n            url(r\"^(?P<resource_name>%s)/(?P<name>[\\w\\d_.-]+)/$\"\n                % self._meta.resource_name, self.wrap_view('dispatch_detail'), name=\"api_dispatch_detail_name\"),\n            url(r\"^(?P<resource_name>%s)/(?P<id>[\\d]+)/$\"\n                % self._meta.resource_name, self.wrap_view('dispatch_detail'), name=\"api_dispatch_detail\"),\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef view(self, request, **kwargs):\n        '''\n        allow a file to be viewed as opposed to download. This is particularly needed when a video file is stored\n        in the fileservice and user wants to be able to use a view the video as opposed to having to download it\n        first. It passes the serving of the file to nginx/apache which will return all the proper headers allowing,\n        say, html5's video viewer's 'seek' indicator/knob to work. Otherwise the video is only played sequentially\n\n        Note that nginx/apache need to be configured accordingly. nginx for example:\n        location /var/lib/geoserver_data/file-service-store/ {\n           # forces requests to be authorized\n           internal;\n           alias   /var/lib/geoserver_data/file-service-store/;\n        }\n\n        for apache, need to install xsendfile module, enable it, set the path and then\n        XSendFile on\n        XSendFilePath /var/lib/geoserver_data/file-service-store\n\n        example use:\n        /fileservice/view/med.mp4\n        or\n        /fileservice/med.mp4/view\n\n        Note that media players tend to require the route to end with the filename like /fileservice/view/med.mp4\n        '''\n        # method check to avoid bad requests\n        self.method_check(request, allowed=['get'])\n        # Must be done otherwise endpoint will be wide open\n        self.is_authenticated(request)\n\n        response = None\n        file_item_name = kwargs.get('name', None)\n        if file_item_name:\n            mime = MimeTypes()\n            url = urllib.pathname2url(file_item_name)\n            mime_type = mime.guess_type(url)\n            response = HttpResponse(content_type=mime_type[0])\n            file_with_route = smart_str('{}{}'.format(helpers.get_fileservice_dir(), file_item_name))\n            # apache header\n            response['X-Sendfile'] = file_with_route\n            # nginx header\n            response['X-Accel-Redirect'] = file_with_route\n\n        if not response:\n            response = self.create_response(request, {'status': 'filename not specified'})\n\n        return response", "response": "This method returns a response that contains the file that is viewed as opposed to download."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef loadable(func_name):\n  def inner(func):\n    cached_name = '_' + func.__name__\n    @functools.wraps(func)\n    def _decorator(self, *args, **kwargs):\n      if getattr(self, cached_name) is None:\n        getattr(self, func_name)()\n      return func(self, *args, **kwargs)\n    return _decorator\n  return inner", "response": "Decorator for getters that require a load() upon first access."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set(self, attr_dict):\n    for key in attr_dict:\n      if key == self._id_attribute:\n        setattr(self, self._id_attribute, attr_dict[key])\n      else:\n        setattr(self, u\"_\" + key, attr_dict[key])\n    return self", "response": "Sets attributes of this user object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef security_warnings(request, PROXY_ALLOWED_HOSTS=()):\n\n    warnings = []\n\n    PROXY_ALLOWED_HOSTS = PROXY_ALLOWED_HOSTS or getattr(settings, 'PROXY_ALLOWED_HOSTS', ())\n\n    if PROXY_ALLOWED_HOSTS and '*' in PROXY_ALLOWED_HOSTS:\n        warnings.append(dict(title=_('Insecure setting detected.'),\n                             description=_('A wildcard is included in the PROXY_ALLOWED_HOSTS setting.')))\n\n    return dict(warnings=warnings)", "response": "Detects insecure settings and reports them to the client - side context."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nformat and convert units to be more human readable", "response": "def conv_units(val, meta):\n    \"\"\"\n    Format and convert units to be more human readable\n\n    @return new val with converted units\n    \"\"\"\n    if not val or not meta:\n        return val\n\n    try:\n        val = float(val)\n    except ValueError:\n        logging.error(\"unable to apply convert units for %s\" % val)\n        return val\n\n    suf = 0\n    while val > 1024 and suf < 4:\n        val /= 1024\n        suf += 1\n\n    return \"%.2f%s\" % (val, UNITS_SUFFIX[suf])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\naligning columns including column headers including column headers and including data.", "response": "def align(self, arr):\n        \"\"\"\n        Align columns, including column headers\n        \"\"\"\n        if arr is None:\n            return arr\n\n        c_hdrs = self._get_col_hdrs()\n\n        if self.show_col_hdr_in_cell:\n            for hdr in c_hdrs:\n                arr[hdr] = map(lambda col: \":\".join([hdr, str(col)]), arr[hdr])\n\n        if self.show_col_hdrs:\n            widths = [max(len(str(col))\n                      for col in arr[hdr].tolist() + [hdr]) for hdr in c_hdrs]\n        else:\n            widths = [max(len(str(col))\n                      for col in arr[hdr].tolist()) for hdr in c_hdrs]\n\n        # align column headers\n        c_hdrs = map(lambda (c_hdr, width): c_hdr.ljust(width),\n                     zip(c_hdrs, widths))\n\n        # align data\n        for n_row in range(len(arr)):\n            arr[n_row] = tuple(map(lambda (col, width): col.ljust(width),\n                                   zip(arr[n_row], widths)))\n\n        return arr, c_hdrs, widths"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wrap(self, string, width):\n        if not string or width <= 0:\n            logging.error(\"invalid string: %s or width: %s\" % (string, width))\n            return False\n\n        tmp = \"\"\n        for line in string.splitlines():\n            if len(line) <= width:\n                tmp += line + \"\\n\"\n                continue\n\n            cur = 0\n            length = len(line)\n            while cur + width < length:\n                cur = line[:cur+width].rfind(self.sep) + len(self.sep) - 1\n                line = line[:cur] + \"\\n\" + line[cur+1:]\n\n            tmp += line + \"\\n\\n\"\n\n        return tmp", "response": "Wrap lines according to width"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply_meta(self, arr, funcs):\n        if arr is None:\n            logging.error(\"unable to convert data: emtpy section\")\n            return None\n\n        tmp = np.copy(arr)\n        for col in arr.dtype.names:\n            for row in self._get_row_hdrs():\n                meta = self._get_meta(row, col)\n                for mk, mv in sorted(meta.iteritems()):\n                    if mk in funcs.iterkeys():\n                        tmp[col][self.irt[row]] = \\\n                            funcs[mk](tmp[col][self.irt[row]], mv)\n        return tmp", "response": "Apply metadata to help formatting the output"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\noverride the in - class params.", "response": "def config(self, show_row_hdrs=True, show_col_hdrs=True,\n                show_col_hdr_in_cell=False, auto_resize=True):\n        \"\"\"\n        Override the in-class params:\n\n        @param show_row_hdrs : show row headers\n        @param show_col_hdrs : show column headers\n        @param show_col_hdr_in_cell : embed column header in each cell\n        @param auto_resize : auto resize according to the size of terminal\n        \"\"\"\n        self.show_row_hdrs = show_row_hdrs\n        self.show_col_hdrs = show_col_hdrs\n        self.show_col_hdr_in_cell = show_col_hdr_in_cell"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_cell(self, row=\"unknown\", col=\"unknown\",\n                 val=\"unknown\", type=\"int32\", meta=\"\"):\n        \"\"\"\n        Add/update a val on cell [row, col]\n\n        Create new rows or columns accordingly\n\n        @param row : row header name\n        @param col : column header name\n        @param meta: meta data to control data display\n        \"\"\"\n        if self.arr is None:\n            self.arr = np.array(\n                [(row, val)], dtype=[ (self.name, \"S50\"), (col, type)])\n            self.meta = np.array(\n                [(row, val)], dtype=[ (self.name, TYPE_META), (col, type)])\n            self.irt[row] = 0\n\n        if not row in self._get_row_hdrs():\n            self._expand_row(row)\n\n        if not col in self._get_col_hdrs():\n            self._expand_col(col, type)\n\n        try:\n            self._add_cell(val, row, col, meta)\n        except ValueError:\n            logging.error(\"unable to add val %s to [%s,%s]: \"\n                          \"not a compatible data type\" % (val, row, col))\n            return False\n\n        return True", "response": "Add a val on a cell [ row col type meta data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_meta(self, row, col):\n        if self.meta is None:\n            logging.error(\"unable to get meta: empty section\")\n            return {}\n\n        if not row in self._get_row_hdrs() or\\\n            not col in self._get_col_hdrs():\n            logging.error(\"unable to get meta: cell [%s,%s] does not exist\"\n                          % (row, col))\n            return {}\n\n        meta_str = self.meta[col][self.irt[row]]\n        try:\n            meta = ast.literal_eval(meta_str)\n            if isinstance(meta, dict):\n                return meta\n        except (SyntaxError, ValueError), e:\n            logging.error(\"unable to parse meta string - %s: %s\"\n                          % (meta_str, e))\n\n        return {}", "response": "Get metadata for a particular cell"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns either completion information or a call signature for the function definition that we are currently on currently.", "response": "def in_function_call(self):\n        \"\"\"Return either completion information or a call signature for\n        the function definition that we are on currently.\"\"\"\n        #The last thing to do before we can form completions etc. is perform\n        #a real-time update of the in-memory versions of the modules.\n        if settings.real_time_update:\n            cache.rt.update(self._user_context)\n\n        return self._evaluator.in_function_call()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef completions(self):\n        debug.speed('completions start')\n        comps = self._evaluator.complete()\n        debug.speed('completions end')\n\n        return sorted(comps, key=lambda x: (x.name.lower()))", "response": "Return a list of all completions in the current context."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngo to the next definition of a symbol under the cursor.", "response": "def goto_definitions(self):\n        \"\"\"\n        Return the definition of a the symbol under the cursor via exact match.\n        Goes to that definition with a buffer.\n        \"\"\"\n        element = self._evaluator.get_definition()\n        if element is not None:\n            return BaseDefinition(self._user_context, element)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef order_module_dependencies(modules, parser):\n    result = []        \n    for modk in modules:\n        if modk not in result:\n            result.append(modk)\n\n    #We also need to look up the dependencies of each of these modules\n    recursed = list(result)\n    for i in range(len(result)):\n        module = result[i]\n        _process_module_order(parser, module, i, recursed)\n\n    return recursed", "response": "Orders the specified list of modules based on their inter - dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _process_module_order(parser, module, i, result):\n    #Some code might decide to use the fortpy module methods for general\n    #development, ignore it since we know it will be present in the end.\n    if module == \"fortpy\" or module == \"fpy_auxiliary\":\n        return\n\n    #See if the parser has alread loaded this module.\n    if module not in parser.modules:\n        parser.load_dependency(module, True, True, False)\n\n    #It is possible that the parser couldn't find it, if so\n    #we can't get a self-consistent ordering.\n    if module in parser.modules:\n        modneeds = parser.modules[module].needs\n        for modn in modneeds:\n            if modn not in result:\n                #Since this module depends on the other, insert the other\n                #above it in the list.\n                result.insert(i, modn)\n            else:\n                x = result.index(modn)\n                if x > i:\n                    #We need to move this module higher up in the food chain\n                    #because it is needed sooner.\n                    result.remove(modn)\n                    result.insert(i, modn)\n\n            newi = result.index(modn)\n            _process_module_order(parser, modn, newi, result)\n    else:\n        raise ValueError(\"unable to find module {}.\".format(module))", "response": "Adds the module and its dependencies to the result list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist the names of all the modules that the specified module depends on.", "response": "def list_dependencies(self, module, result):\n        \"\"\"Lists the names of all the modules that the specified module depends\n        on.\"\"\"\n        if result is None:\n            result = {}\n        #We will try at least once to load each module that we don't have\n        if module not in self.modules:\n            self.load_dependency(module, True, True, False)\n\n        if module in self.modules and module not in result:\n            result[module] = self.modules[module].filepath\n            for depend in self.modules[module].dependencies:\n                name = depend.split(\".\")[0].lower()\n                if name not in result:\n                    self.list_dependencies(name, result)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the dependencies of the modules in the list pmodules.", "response": "def _parse_dependencies(self, pmodules, dependencies, recursive, greedy):\n        \"\"\"Parses the dependencies of the modules in the list pmodules.\n\n        :arg pmodules: a list of modules that were parsed from a *.f90 file.\n        :arg dependencies: when true, the dependency's dependencies will be loaded.\n        :arg recursive: specifies whether to continue loading dependencies to\n           completion; i.e. up the chain until we have every module that any\n           module needs to run.\n        :arg greedy: when true, \n        \"\"\"\n        #See if we need to also load dependencies for the modules\n        if dependencies:\n            allkeys = [ module.name.lower() for module in pmodules ]\n            for key in allkeys:\n                for depend in self.modules[key].collection(\"dependencies\"):\n                    base = depend.split(\".\")[0]\n                    if self.verbose and base.lower() not in self.modules:\n                        msg.info(\"DEPENDENCY: {}\".format(base), 2)\n                    self.load_dependency(base, dependencies and recursive, recursive, greedy)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlooks for additional docstring specifications in the correctly named XML files in the same directory as the module.", "response": "def _parse_docstrings(self, filepath):\n        \"\"\"Looks for additional docstring specifications in the correctly named\n        XML files in the same directory as the module.\"\"\"        \n        xmlpath = self.get_xmldoc_path(filepath)\n        if self.tramp.exists(xmlpath):\n            xmlstring = self.tramp.read(xmlpath)\n            self.modulep.docparser.parsexml(xmlstring, self.modules, xmlpath)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_xmldoc_path(self, filepath):\n        segs = filepath.split(\".\")\n        segs.pop()\n        return \".\".join(segs) + \".xml\"", "response": "Returns the full path to a possible XML documentation file for the specified code filepath."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_mod_mtime(self, filepath):\n        file_mtime = self.tramp.getmtime(filepath)        \n        xmlpath = self.get_xmldoc_path(filepath)\n        if self.tramp.exists(xmlpath):\n            xml_mtime = self.tramp.getmtime(xmlpath)\n            if xml_mtime > file_mtime:\n                file_mtime = xml_mtime\n\n        return file_mtime", "response": "Gets the modified time of the file or its accompanying XML file whichever is greater."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_from_file(self, filepath, fname,\n                         dependencies, recursive, greedy):\n        \"\"\"Parses the specified string to load the modules *from scratch* as\n        opposed to loading pickled versions from the file cache.\"\"\"\n        #Now that we have the file contents, we can parse them using the parsers\n        string = self.tramp.read(filepath)\n        pmodules = self.modulep.parse(string, self, filepath=filepath)\n        file_mtime = self._get_mod_mtime(filepath)\n\n        for module in pmodules:\n            module.change_time = file_mtime\n            self.modules[module.name.lower()] = module\n            self._modulefiles[fname].append(module.name.lower())\n\n        pprograms = self.modulep.parse(string, self, False)\n        for program in pprograms:\n            program.change_time = file_mtime\n            self.programs[program.name.lower()] = program\n            self._programfiles[fname].append(program.name.lower())\n\n        #There may be xml files for the docstrings that also need to be parsed.\n        self._parse_docstrings(filepath)\n        \n        return (pmodules, pprograms)", "response": "Parses the specified string to load the modules from scratch as\n        opposed to loading the pickled versions from the file cache as\n        opposed to loading the pickled versions from the file cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _check_parse_modtime(self, filepath, fname):\n        #We also want to perform a reparse if the XML documentation file for the\n        #module changed, since the docs are also cached.\n        file_mtime = self._get_mod_mtime(filepath)\n        \n        #If we have parsed this file and have its modules in memory, its\n        #filepath will be in self._parsed. Otherwise we can load it from\n        #file or from a cached pickle version.\n        if filepath.lower() in self._parsed: \n            #Get the name of the first module in that file from the modulefiles\n            #list. Find out when it was last modified.\n            module_mtime = None\n            if fname in self._modulefiles:\n                if len(self._modulefiles[fname]) == 0:\n                    msg.warn(\"Module file {} has no modules defined inside of it!\".format(fname))\n                    return None\n                \n                modulename = self._modulefiles[fname][0]\n                if modulename in self.modules:\n                    #Make sure that if there are modules with the same name but different\n                    #files, that we are working with the correct one.\n                    if filepath.lower() != self.modules[modulename].filepath:\n                        msg.warn(\"module {} parsed \".format(modulename) + \n                                 \"from {}, not {}\".format(self.modules[modulename].filepath,\n                                                          filepath))\n                    module_mtime = self.modules[modulename].change_time\n\n            if module_mtime is not None:\n                if module_mtime < file_mtime:\n                    #The file has been modified since we reloaded the module.\n                    #Return the two times we used for the comparison so the\n                    #module file can be reloaded.\n                    return [module_mtime, file_mtime]\n                else:\n                    return None\n        else:\n            #The file has never been parsed by this CodeParser. We can\n            #either do a full parse or a pickle load.\n            return [file_mtime]", "response": "Checks whether the modules in the specified file path need to be reparsed because the file was changed since it was last loaded."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds the directory of the file at the specified path as a base path to find other files in.", "response": "def _add_current_codedir(self, path):\n        \"\"\"Adds the directory of the file at the specified path as a base\n        path to find other files in.\n        \"\"\"\n        dirpath = self.tramp.dirname(path)\n        if dirpath not in self.basepaths:\n            self.basepaths.append(dirpath)\n            self.rescan()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef isense_parse(self, filepath, modulename):\n        #We only want to check whether the file has been modified for reload\n        from datetime import datetime\n        if modulename not in self._last_isense_check:\n            self._last_isense_check[modulename] = datetime.utcnow()\n            self.parse(filepath, True)\n        else:\n            elapsed = (datetime.utcnow() - self._last_isense_check[modulename]).seconds\n            if elapsed > 60:\n                self.parse(filepath, True)\n                self._last_isense_check[modulename] = datetime.utcnow()", "response": "Parses the specified file from memory cached disk or full disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(self, filepath, dependencies=False, recursive=False, greedy=False):\n        #If we have already parsed this file path, we should check to see if the\n        #module file has changed and needs to be reparsed.\n        abspath = self.tramp.abspath(filepath)\n        self._add_current_codedir(abspath)\n        fname = filepath.split(\"/\")[-1].lower()\n        mtime_check = self._check_parse_modtime(abspath, fname)\n\n        if mtime_check is None:\n            return\n\n        #Keep track of parsing times if we are running in verbose mode.\n        if self.verbose:\n            start_time = clock()\n            msg.okay(\"WORKING on {0}\".format(abspath), 2)\n\n        if fname not in self._modulefiles:\n            self._modulefiles[fname] = []\n        if fname not in self._programfiles:\n            self._programfiles[fname] = []\n\n        #Check if we can load the file from a pickle instead of doing a time\n        #consuming file system parse.\n        pickle_load = False\n        pprograms = []\n        if len(mtime_check) == 1 and settings.use_filesystem_cache:\n            #We use the pickler to load the file since a cached version might\n            #be good enough.\n            pmodules = self.serialize.load_module(abspath, mtime_check[0], self)\n            if pmodules is not None:\n                for module in pmodules:\n                    self.modules[module.name.lower()] = module\n                    self._modulefiles[fname].append(module.name.lower())\n                pickle_load = True\n            else:\n                #We have to do a full load from the file system.\n                pmodules, pprograms = self._parse_from_file(abspath, fname,\n                                                            dependencies, recursive, greedy)\n        else:\n            #We have to do a full load from the file system.\n            pmodules, pprograms = self._parse_from_file(abspath, fname,\n                                                        dependencies, recursive, greedy)\n\n        #Add the filename to the list of files that have been parsed.\n        self._parsed.append(abspath.lower())\n        if not pickle_load and len(pmodules) > 0 and settings.use_filesystem_cache:\n            self.serialize.save_module(abspath, pmodules)\n\n        if self.verbose:\n            msg.info(\"PARSED: {} modules and {} \".format(len(pmodules), len(pprograms)) + \n                     \"programs in {} in {}\".format(fname, secondsToStr(clock() - start_time)), 2)\n            for module in pmodules:\n                msg.gen(\"\\tMODULE {}\".format(module.name), 2)\n            for program in pprograms:\n                msg.gen(\"\\tPROGRAM {}\".format(program.name), 2)\n            if len(pmodules) > 0 or len(pprograms) > 0:\n                msg.blank()\n\n        self._parse_dependencies(pmodules, dependencies, recursive, greedy)", "response": "Parses the fortran code in the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the module with the specified name if it isn t already loaded.", "response": "def load_dependency(self, module_name, dependencies, recursive, greedy, ismapping = False):\n        \"\"\"Loads the module with the specified name if it isn't already loaded.\"\"\"\n        key = module_name.lower()\n        if key not in self.modules:\n            if key == \"fortpy\":\n                #Manually specify the correct path to the fortpy.f90 that shipped with\n                #the distribution\n                from fortpy.utility import get_fortpy_templates_dir\n                from os import path\n                fpy_path = path.join(get_fortpy_templates_dir(), \"fortpy.f90\")\n                self.parse(fpy_path, False, False)\n                return\n            \n            fkey = key + \".f90\"\n            if fkey in self._pathfiles:\n                self.parse(self._pathfiles[fkey], dependencies, recursive)\n            elif greedy:\n                #The default naming doesn't match for this module\n                #we will load all modules until we find the right\n                #one\n                self._load_greedy(key, dependencies, recursive)\n            elif key in self.mappings and self.mappings[key] in self._pathfiles:\n                #See if they have a mapping specified to a code file for this module name.\n                if self.verbose:\n                    msg.info(\"MAPPING: using {} as the file\".format(self.mappings[key]) + \n                             \" name for module {}\".format(key))\n                self.parse(self._pathfiles[self.mappings[key]], dependencies, recursive)\n            elif key not in [\"mkl_vsl_type\", \"mkl_vsl\", \"iso_c_binding\"]:\n                #The parsing can't continue without the necessary dependency modules.\n                msg.err((\"could not find module {}. Enable greedy search or\"\n                       \" add a module filename mapping.\".format(key)))\n                if self.austere:\n                    exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_greedy(self, module_name, dependencies, recursive):\n        found = module_name in self.modules\n        allmodules = list(self._pathfiles.keys())\n        i = 0\n\n        while not found and i < len(allmodules):\n            current = allmodules[i]\n            if not current in self._modulefiles:\n                #We haven't tried to parse this file yet\n                self.parse(self._pathfiles[current], dependencies and recursive)                \n                found = module_name in self.modules\n            i += 1", "response": "Keeps loading modules in the filepaths dictionary until all have\n        been loaded."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scan_path(self, path, result = None):\n        files = []\n        \n        #Find all the files in the directory\n        for (dirpath, dirnames, filenames) in self.tramp.walk(path):\n            files.extend(filenames)\n            break\n\n        #Check if the .fpyignore file exists in the folder.\n        patterns = [\".#*\"]\n        if \".fpyignore\" in files:\n            for line in self.tramp.read(os.path.join(path, \".fpyignore\")).split('\\n'):\n                sline = line.strip()\n                if len(sline) > 0 and sline[0] != '#':\n                    patterns.append(sline)\n                    \n        #Filter them to find the fortran code files\n        from fnmatch import fnmatch\n        for fname in files:\n            if fnmatch(fname, \"*.f90\"):\n                if all([not fnmatch(fname, p) for p in patterns]):\n                    self._pathfiles[fname.lower()] = os.path.join(path, fname)\n                    if result is not None:\n                        result[fname.lower()] = os.path.join(path, fname)", "response": "Scan the path for fortran files in the base path and populate the dictionary with the private member dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef type_search(self, basetype, symbolstr, origin):\n        symbols = symbolstr.split(\"%\")\n        base, basemod = self.tree_find(basetype, origin, \"types\")\n        \n        #As long as we keep finding child objects, we can continue\n        #until we run out of symbols in the list\n        i = 1\n        while isinstance(base, CustomType) and i < len(symbols): \n            #We will look inside the types members and executables\n            if symbols[i] in base.members:\n                #Types can have types inside of them. If the next symbol\n                #is a member, we need to check if it is also a custom type\n                base = base.members[symbols[i]]\n                if base.is_custom:\n                    base, basemod = self.tree_find(base.kind, origin, \"types\")\n            elif symbols[i] in base.executables:\n                base = base.executables[symbols[i]]\n            #We want to keep iterating through until we find a non-type\n            #which is either a non-type member or an executable\n            i += 1\n\n        return base", "response": "This function recursively searches the module trees looking for the final type name of the first element in the sequence of symbols and returns the base object that was found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the code element corresponding to the specified symbol in the specified origin module and attribute.", "response": "def tree_find(self, symbol, origin, attribute):\n        \"\"\"Finds the code element corresponding to specified symbol\n        by searching all modules in the parser.\n\n        :arg symbol: the name of the code element to find.\n        :arg origin: an instance of a Module element who owns the text\n          that is generate the find search.\n        :arg attribute: one of ['dependencies', 'publics', 'members',\n          'types', 'executables', 'interfaces'] that specifies which collection\n          in the module should house the symbol's element.\n        \"\"\"\n        #The symbol must be accessible to the origin module, otherwise\n        #it wouldn't compile. Start there, first looking at the origin\n        #itself and then the other modules that it depends on.\n\n        #Since we will be referring to this multiple times, might as \n        #well get a pointer to it.\n        oattr = origin.collection(attribute)\n        base = None\n        lorigin = None\n        if symbol in oattr:\n            base = oattr[symbol]\n            lorigin = origin\n        else:\n            for module in origin.dependencies:\n                usespec = module.split(\".\")\n                if len(usespec) > 1:\n                    if usespec[1] == symbol:\n                        #The dependency is to a specific element in the module,\n                        #and it matches.\n                        lorigin = self.get(usespec[0])\n                    else:\n                        lorigin = None\n                else:\n                    #The dependency is to the entire module!\n                    lorigin = self.get(usespec[0])\n            \n                #If we have code for the origin, we can search for the\n                #actual base object that we are interested in\n                if lorigin is not None:\n                    lattr = lorigin.collection(attribute)\n                    if symbol in lattr:\n                        base = lattr[symbol]\n                        break\n\n        #By now, we either have the item we were after or we don't have\n        #code for the module it needs\n        return (base, lorigin)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_executable(self, fullname):\n        result = None\n        modname, exname = fullname.split(\".\")\n        module = self.get(modname)\n        if module is not None:\n            if exname in module.executables:\n                result = module.executables[exname]\n\n        return result", "response": "Gets the executable corresponding to the specified full name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_interface(self, fullname):\n        result = None\n        [modname, iname] = fullname.split(\".\")\n        module = self.get(modname)\n        if module is not None:\n            if iname in module.interfaces:\n                result = module.interfaces[iname]\n        return result", "response": "Gets the interface corresponding to the specified full name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the module with the given name if it exists in this code parser.", "response": "def get(self, name):\n        \"\"\"Gets the module with the given name if it exists in\n        this code parser.\"\"\"\n        if name not in self.modules:\n            self.load_dependency(name, False, False, False)\n\n        if name in self.modules:\n            return self.modules[name]\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_bucket(self, key, rate=None, capacity=None, **kwargs):\n        return buckets.Bucket(\n            key=key,\n            rate=rate or self.rate,\n            capacity=capacity or self.capacity,\n            storate=self.storate,\n            **kwargs)", "response": "Returns a new Bucket object for the given key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef consume(self, key, amount=1, rate=None, capacity=None, **kwargs):\n        bucket = self.get_bucket(key, rate, capacity, **kwargs)\n        return bucket.consume(amount)", "response": "Consume an amount of units for a given key."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconsume an amount for a given key.", "response": "def throttle(self, key, amount=1, rate=None, capacity=None,\n            exc_class=Throttled, **kwargs):\n        \"\"\"Consume an amount for a given key, or raise a Throttled exception.\"\"\"\n\n        if not self.consume(key, amount, rate, capacity, **kwargs):\n            raise exc_class(\"Request of %d unit for %s exceeds capacity.\"\n                    % (amount, key))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nleak the adequate amount of data from the bucket.", "response": "def leak(self):\n        \"\"\"Leak the adequate amount of data from the bucket.\n\n        This should be called before any consumption takes place.\n\n        Returns:\n            int: the new capacity of the bucket\n        \"\"\"\n        capacity, last_leak = self.storage.mget(self.key_amount, self.key_last_leak,\n                coherent=True)\n\n        now = time.time()\n\n        if last_leak:\n            elapsed = now - last_leak\n            decrement = elapsed * self.rate\n\n            new_capacity = max(int(capacity - decrement), 0)\n        else:\n            new_capacity = 0\n\n        self.storage.mset({\n            self.key_amount: new_capacity,\n            self.key_last_leak: now,\n        })\n\n        return new_capacity"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconsuming one or more units from the bucket.", "response": "def consume(self, amount=1):\n        \"\"\"Consume one or more units from the bucket.\"\"\"\n        # First, cleanup old stock\n        current = self.leak()\n\n        if current + amount > self.capacity:\n            return False\n\n        self._incr(amount)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register(self, entry_point):\n        if entry_point in self.registered_converters:\n            raise ValueError('Already registered')\n        self.registered_converters.insert(0, entry_point)", "response": "Register a converter to be used for the given entry point."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse():\n    from fortpy.code import CodeParser\n    c = CodeParser()\n    \n    if args[\"verbose\"]:\n        c.verbose = True\n\n    f90files = {}\n    c.scan_path(args[\"source\"], f90files)\n    for fname, fpath in f90files.items():\n        if fname not in c._modulefiles:\n            c._modulefiles[fname] = []\n        c._parse_from_file(fpath, fname, args[\"recursive\"], args[\"recursive\"], False)\n\n    return c", "response": "Parses all the modules in the library specified by the script args."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _check_pointers(parser):\n    from fortpy.stats.bp import check_pointers\n    check_pointers(parser, args[\"source\"], args[\"filter\"], args[\"recursive\"])", "response": "Checks the pointer best - practice conditions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses any interfaces out of the module.", "response": "def parse(self, parent):\n        \"\"\"Parses any interfaces out of the module preamble which is the pre-contains section\n        of the program or module.\n        \n        :arg parent: the ancle.elements.Module instance that will own the interfaces that get\n          parsed from the module.\n        \"\"\"\n        for iface in self.RE_INTERFACE.finditer(parent.preamble):\n            name = iface.group(\"name\")\n            symbol = iface.group(\"symbol\")\n            contents = iface.group(\"contents\")\n            result = Interface(name, [], parent, symbol)\n            self._parse_procedures(contents, result)\n\n            #Set the regex start and end char indices\n            result.start, result.end = parent.absolute_charindex(iface.string, iface.start(),\n                                                                 iface.end())\n            self.update_docs(result, parent)\n            parent.interfaces[name.lower()] = result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_docs(self, iface, module):\n        #We need to look in the parent module docstrings for this types decorating tags.\n        key = \"{}.{}\".format(module.name, iface.name)\n        if key in module.predocs:\n            iface.docstring = self.docparser.to_doc(module.predocs[key][0], iface.name)\n            iface.docstart, iface.docend = (module.predocs[key][1], module.predocs[key][2])", "response": "Updates the documentation for the specified interface using the module predocs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the list of procedures or signatures defined in the generic operator or assignment interface.", "response": "def _parse_procedures(self, contents, iface):\n        \"\"\"\"Parses the list of procedures or signatures defined in the generic, operator\n        or assignment interface.\n        \n        :arg contents: the text between the interface ... end interface keywords.\n        :arg iface: the fortpy.elements.Interface instance that will own the parsed\n          procedures/signatures.\n        \"\"\"\n        procs = contents.split(\"module procedure\")\n        stripped = [p.strip() for p in procs if p.strip() != \"\"]\n        for embed in stripped:\n            #We want to first extract the name of the procedure, then find its element\n            #instance to append to the Interface instance's procedures list.\n            methods = re.split(\",\\s*\", embed.replace(\"&\\n\", \"\"))\n            keys = [\"{}.{}\".format(iface.module.name, m) for m in methods]\n            iface.procedures.extend(keys)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef makefile(identifier, dependencies, makepath, compileid,\n             precompile=False, inclfortpy=True, parser=None,\n             executable=True, extralinks=None, inclfpyaux=False,\n             makefpyaux=False, verbose=False):\n    \"\"\"Generates a makefile to create the unit testing executable\n    for the specified test identifier.\n\n    :arg identifier: the id of the test/library that this makefile should be made for.\n    :arg dependencies: a list of the module names that need to be included in the compilation.\n    :arg makepath: the path to the file to save the Makefile in.\n    :arg compileid: the 'module.executable' that this Makefile is being produced for.\n    :arg precompile: when True, the precompiler flags will be added to the makefile.\n    :arg inclfortpy: when True, the fortpy module will be added first to the list of modules\n      to compile for the executable/library.\n    :arg parser: if the module file names are different from the module names, specify a\n      code parser to use for converting one to the other. \n    :arg executable: when true and executable is compiled for rule 'all', else the library\n      is the default and the executable is set as a different rule for 'identifier'.x.\n    :arg extralinks: a list of additional libraries to link in with the explicitly compiled\n      f90 files. These aren't checked at all, just added to the linklist.\n    :arg verbose: when True, the full compilation header will be printed with flags and module\n      information; otherwise it won't.\n    \"\"\"\n    lines = []\n\n    #Append the general variables\n    lines.append(\"EXENAME\\t\\t= {}.x\".format(identifier))\n    lines.append(\"SHELL\\t\\t= /bin/bash\")\n    lines.append(\"UNAME\\t\\t= $(shell uname)\")\n    lines.append(\"HOSTNAME\\t= $(shell hostname)\")\n    lines.append(\"LOG\\t\\t= compile.{}.log\".format(identifier if identifier is not None else \"default\"))\n    lines.append(\"\")\n\n    #Now the standard entries for ifort. We will just have the ifort include\n    #file so that the MPI and other options can be tested to.\n    lines.append(_make_compiler_include(precompile, extralinks))\n    lines.append(\".SILENT:\")\n    lines.append(\"\")\n    \n    #Append all the dependent modules to the makefile\n    lines.append(\"LIBMODULESF90\\t= \\\\\")\n\n    for modk in dependencies:\n        if modk not in [\"fortpy\", \"fpy_auxiliary\", identifier]:\n            if parser is not None:\n                lines.append(\"\\t\\t{} \\\\\".format(_get_mapping(parser, modk)))\n            else:\n                lines.append(\"\\t\\t{} \\\\\".format(modk))\n    if makefpyaux:\n        lines.append(\"\\t\\tfpy_auxiliary.f90 \\\\\")\n    lines.append(\"\")\n    \n    lines.append(\"MAINF90\\t\\t= {}.f90\".format(identifier))\n    lines.append(\"SRCF90\\t\\t= $(LIBMODULESF90) $(MAINF90)\")\n    lines.append(\"OBJSF90\\t\\t= $(SRCF90:.f90=.o)\")\n    lines.append(\"SLIBF90\\t\\t= $(LIBMODULESF90:.f90=.o)\")\n    lines.append(\"\")\n\n    #Add explicitly defined libraries that should be included when linking\n    #the unit testing executable.\n    linklibs = True\n    _add_explicit_includes(lines, dependencies, extralinks)\n    if inclfortpy or inclfpyaux:\n        import sys\n        if len(sys.modules[\"config\"].includes) == 0:\n            lines.append(\"LIBS\\t\\t= \\\\\")\n\n        if inclfortpy:\n            lines.append(\"\\t\\tfortpy.o \\\\\")\n        if inclfpyaux:\n            lines.append(\"\\t\\tfpy_aux.so \\\\\")\n\n    lines.append(\"\")\n\n    #We need to add the error handling commands to make debugging compiling easier.\n    lines.append(_make_error())\n    lines.append(\"\")\n\n    main = \"$(EXENAME)\" if executable == True else \"{}.{}\".format(identifier, executable)\n    lines.append(\"all:\tinfo {}\".format(main))\n    lines.append(_make_info(compileid, verbose))\n    lines.append(_make_exe(linklibs, identifier, verbose))\n\n    from os import path\n    makedir, makef = path.split(makepath)\n    lines[-1] += \"\tmake -f '{}'\".format(makef)\n\n    with open(makepath, 'w') as f:\n        f.writelines(\"\\n\".join(lines))", "response": "Generates a makefile for the specified test identifier."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding any relevant libraries that need to be explicitly included according to the fortpy configuration file. Returns True if relevant libraries were added.", "response": "def _add_explicit_includes(lines, dependencies=None, extralinks=None):\n    \"\"\"Adds any relevant libraries that need to be explicitly included according\n    to the fortpy configuration file. Libraries are appended to the specified\n    collection of lines. Returns true if relevant libraries were added.\n    \"\"\"\n    from fortpy import config\n    import sys\n    from os import path\n    includes = sys.modules[\"config\"].includes\n    linklibs = False\n\n    if extralinks is not None and len(extralinks) > 0:\n        for i, link in enumerate(extralinks):\n            lines.append(\"LBD{0:d} \t\t= {1}\".format(i, link))\n        lines.append(\"\")\n    \n    if len(includes) > 0:\n        lines.append(\"LIBS\\t\\t= \\\\\")\n        for library in includes:\n            addlib = False\n            if \"modules\" in library:\n                #We need to loop over the modules specified for the library and see\n                #if any of them are in our list of modules.\n                for libmod in library[\"modules\"]:\n                    if dependencies is None or libmod.lower() in dependencies:\n                        addlib = True\n                        break\n            else:\n                addlib = True\n\n            if addlib:\n                linklibs = True\n                lines.append(\"\\t\\t{} \\\\\".format(library[\"path\"]))\n\n        #These links specify explicit libraries to include in the final compilation.\n        if extralinks is not None:\n            for i in range(len(extralinks)):\n                if path.isfile(extralinks[i]):\n                    lines.append(\"\\t\\t$(LBD{0:d}) \\\\\".format(i))\n            \n    return linklibs or (extralinks is not None and len(extralinks) > 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _make_compiler_include(precompile, extralinks):\n    base = \"\"\"ifeq ($(FAM),ifort)\n  include {2}/Makefile.ifort{0}{3}\nelse\nifeq ($(FAM),gfortran)\n  include {2}/Makefile.gfortran{1}{3}\nelse\n  include Makefile.error\nendif\nendif\"\"\"\n    if extralinks is not None and len(extralinks) > 0:\n        from os import path\n        libs = []\n        for i, link in enumerate(extralinks):\n            #We can only include *directories* for the -I specification.\n            if path.isdir(link):\n                libs.append(\"-I$(LBD{0:d})\".format(i))\n        exlinks = \"\\n  FFLAGS += {}\".format(' '.join(libs))\n    else:\n        exlinks = \"\"\n        \n    #We need to see whether to include the pre-compiler directive or not.    \n    if precompile:\n        insert = [\"\\n  FFLAGS += -fpp -save-temps -heap-arrays\", \"\\n  FFLAGS += -cpp\",\n                  get_fortpy_templates(), exlinks]\n        return base.format(*insert)\n    else:\n        return base.format(\"\", \"\", get_fortpy_templates(), exlinks)", "response": "Returns the include statement for the compiler to use."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates the script to run the compiling.", "response": "def _make_exe(linklibs, identifier, verbose):\n    \"\"\"Generates the script to run the compiling.\"\"\"\n    linktxt = \"$(LIBS) \" if linklibs else \"\"\n    redirect = \"\" if verbose else \" > /dev/null\"\n    base = \"\"\"\n$(EXENAME): $(OBJSF90)\n\t-rm $(EXENAME) 2> /dev/null\n\techo -n \"Linking... \"{2}\n\t-$(F90) $(LDFLAGS) -o $(EXENAME) $(OBJSF90) {0}>> $(LOG) 2>> $(LOG)\n\techo \"done.\"{2}\n\tif test -e $(EXENAME); then echo \"Produced executable: $(EXENAME)\"{2}; else $(SHOW_LOG); echo \"Error.\"; fi\n\n$(OBJSF90): %.o: %.f90\n\techo -n \"Compiling: $^... \"{2}\n\t-$(F90) -c $(FFLAGS) $^ >> $(LOG) 2>> $(LOG)\n\techo \"done.\"{2}\n\n{1}.so: $(SLIBF90)\n\t-rm {1}.so 2> /dev/null\n\techo -n \"Creating shared library...\"{2}\n\t-$(F90) -shared -fPIC $(FFLAGS) -o {1}.so {0}$(SLIBF90) >> $(LOG) 2>> $(LOG)\n\techo \"done.\"{2}\n\n{1}.a: $(SLIBF90)\n\techo -n \"Creating linked library...\"{2}\n\tar ru $@ $?\n\tranlib $@\n\techo \"done.\"{2}\n\nclean:\n\t-mv fpy_auxiliary.mod fpy_auxiliary.modt 2> /dev/null\n\t-mv fpy_auxiliary.o fpy_auxiliary.ot 2> /dev/null\n\t-mv fortpy.o fortpy.ot\n\t-mv fortpy.mod fortpy.modt\n\t-rm *.o *.mod *.i90 $(EXENAME) initializeTree.so 2> /dev/null\n\t-mv fpy_auxiliary.modt fpy_auxiliary.mod 2> /dev/null\n\t-mv fpy_auxiliary.ot fpy_auxiliary.o 2> /dev/null\n\t-mv fortpy.ot fortpy.o\n\t-mv fortpy.modt fortpy.mod\nremake: clean\n\t-rm *.o *.mod *.i90 $(EXENAME) {1}.so\n\"\"\"\n    return base.format(linktxt, identifier, redirect)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _make_info(identifier, verbose):\n    module, method = identifier.split(\".\")\n    redirect = \"| tee -a\" if verbose else \" >>\"\n    return \"\"\"\ninfo: \n\techo -e \"\\\\nCompile time:\" > $(LOG)\n\tdate >> $(LOG)\n\techo \"------------------------------------------------------\"{2} $(LOG)\n\techo \"                     FORTPY\"                           {2} $(LOG)\n\techo \"               >>> version 1.7 <<<                    \"{2} $(LOG)         \n\techo \"------------------------------------------------------\"{2} $(LOG)\n\techo -e \"Compiling on system  : $(UNAME)\"                    {2} $(LOG)\n\techo -e \"             machine : $(HOSTNAME)\"                 {2} $(LOG)\n\techo \"Compiling for module : {0}\"                            {2} $(LOG)         \n\techo \"              method : {1}\"                            {2} $(LOG)         \n\techo \"------------------------------------------------------\"{2} $(LOG)\n\techo -e \"DEBUG mode\\\\t:\\\\t$(DEBUG)\"                          {2} $(LOG)\n\techo -e \"GPROF mode\\\\t:\\\\t$(GPROF)\"                          {2} $(LOG)\n\techo \"------------------------------------------------------\"{2} $(LOG)\n\techo \"F90    : $(F90)\"                                       {2} $(LOG)\n\techo \"FFLAGS : $(FFLAGS)\"                                    {2} $(LOG)\n\techo \"LDFLAGS: $(LDFLAGS)\"                                   {2} $(LOG)\n\techo \"MKLpath:$(MKL)\"                                        {2} $(LOG)\n\techo \"------------------------------------------------------\"{2} $(LOG)\n\techo \"\"                                                      {2} $(LOG)\n\n\"\"\".format(module, method, redirect)", "response": "Generates the script for displaying compile - time info."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_mapping(parser, mapped):\n    if mapped in parser.mappings:\n        return parser.mappings[mapped]\n    else:\n        return mapped + \".f90\"", "response": "Gets the original file name for a module that was mapped\n    when the module name does not coincide with the original file name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a Language instance from an IETF language code.", "response": "def fromietf(cls, ietf):\n        \"\"\"Create a :class:`Language` by from an IETF language code\n\n        :param string ietf: the ietf code\n        :return: the corresponding :class:`Language` instance\n        :rtype: :class:`Language`\n\n        \"\"\"\n        subtags = ietf.split('-')\n        language_subtag = subtags.pop(0).lower()\n        if len(language_subtag) == 2:\n            language = cls.fromalpha2(language_subtag)\n        else:\n            language = cls(language_subtag)\n        while subtags:\n            subtag = subtags.pop(0)\n            if len(subtag) == 2:\n                language.country = Country(subtag.upper())\n            else:\n                language.script = Script(subtag.capitalize())\n            if language.script is not None:\n                if subtags:\n                    raise ValueError('Wrong IETF format. Unmatched subtags: %r' % subtags)\n                break\n        return language"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef patch(self, overrides):\n        overrides = overrides or {}\n        for key, value in iteritems(overrides):\n            current = self.get(key)\n            if isinstance(value, dict) and isinstance(current, dict):\n                current.patch(value)\n            else:\n                self[key] = value", "response": "Patches the config with the given overrides."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_sidebar(self, manga_page):\n    # if MAL says the series doesn't exist, raise an InvalidMangaError.\n    error_tag = manga_page.find(u'div', {'class': 'badresult'})\n    if error_tag:\n        raise InvalidMangaError(self.id)\n\n    try:\n      title_tag = manga_page.find(u'div', {'id': 'contentWrapper'}).find(u'h1')\n      if not title_tag.find(u'div'):\n        # otherwise, raise a MalformedMangaPageError.\n        raise MalformedMangaPageError(self.id, manga_page, message=\"Could not find title div\")\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    # otherwise, begin parsing.\n    manga_info = super(Manga, self).parse_sidebar(manga_page)\n\n    info_panel_first = manga_page.find(u'div', {'id': 'content'}).find(u'table').find(u'td')\n\n    try:\n      volumes_tag = info_panel_first.find(text=u'Volumes:').parent.parent\n      utilities.extract_tags(volumes_tag.find_all(u'span', {'class': 'dark_text'}))\n      manga_info[u'volumes'] = int(volumes_tag.text.strip()) if volumes_tag.text.strip() != 'Unknown' else None\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      chapters_tag = info_panel_first.find(text=u'Chapters:').parent.parent\n      utilities.extract_tags(chapters_tag.find_all(u'span', {'class': 'dark_text'}))\n      manga_info[u'chapters'] = int(chapters_tag.text.strip()) if chapters_tag.text.strip() != 'Unknown' else None\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      published_tag = info_panel_first.find(text=u'Published:').parent.parent\n      utilities.extract_tags(published_tag.find_all(u'span', {'class': 'dark_text'}))\n      published_parts = published_tag.text.strip().split(u' to ')\n      if len(published_parts) == 1:\n        # this published once.\n        try:\n          published_date = utilities.parse_profile_date(published_parts[0])\n        except ValueError:\n          raise MalformedMangaPageError(self.id, published_parts[0], message=\"Could not parse single publish date\")\n        manga_info[u'published'] = (published_date,)\n      else:\n        # two publishing dates.\n        try:\n          publish_start = utilities.parse_profile_date(published_parts[0])\n        except ValueError:\n          raise MalformedMangaPageError(self.id, published_parts[0], message=\"Could not parse first of two publish dates\")\n        if published_parts == u'?':\n          # this is still publishing.\n          publish_end = None\n        else:\n          try:\n            publish_end = utilities.parse_profile_date(published_parts[1])\n          except ValueError:\n            raise MalformedMangaPageError(self.id, published_parts[1], message=\"Could not parse second of two publish dates\")\n        manga_info[u'published'] = (publish_start, publish_end)\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      authors_tag = info_panel_first.find(text=u'Authors:').parent.parent\n      utilities.extract_tags(authors_tag.find_all(u'span', {'class': 'dark_text'}))\n      manga_info[u'authors'] = {}\n      for author_link in authors_tag.find_all('a'):\n        link_parts = author_link.get('href').split('/')\n        # of the form /people/1867/Naoki_Urasawa\n        person = self.session.person(int(link_parts[2])).set({'name': author_link.text})\n        role = author_link.nextSibling.replace(' (', '').replace(')', '')\n        manga_info[u'authors'][person] = role\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      serialization_tag = info_panel_first.find(text=u'Serialization:').parent.parent\n      publication_link = serialization_tag.find('a')\n      manga_info[u'serialization'] = None\n      if publication_link:\n        link_parts = publication_link.get('href').split('mid=')\n        # of the form /manga.php?mid=1\n        manga_info[u'serialization'] = self.session.publication(int(link_parts[1])).set({'name': publication_link.text})\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return manga_info", "response": "Parses the DOM and returns the manga attributes in the sidebar."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_controller_info(self):\n\n        # Read the controller information.\n        self.controller_info = customer_details(self._user_token)\n        self.controller_status = status_schedule(self._user_token)\n\n        if self.controller_info is None or self.controller_status is None:\n            return False\n\n        # Only supports one controller right now.\n        # Use the first one from the array.\n        self.current_controller = self.controller_info['controllers'][0]\n        self.status = self.current_controller['status']\n        self.controller_id = self.current_controller['controller_id']\n        self.customer_id = self.controller_info['customer_id']\n        self.user_id = self.controller_status['user_id']\n        self.num_relays = len(self.controller_status['relays'])\n        self.relays = self.controller_status['relays']\n        self.name = self.controller_status['name']\n        self.watering_time = self.controller_status['watering_time']\n        self.sensors = self.controller_status['sensors']\n        try:\n            self.running = self.controller_status['running']\n        except KeyError:\n            self.running = None\n\n        return True", "response": "Updates the controller info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef controller(self):\n\n        if hasattr(self, 'controller_id'):\n            if len(self.controller_info['controllers']) > 1:\n                raise TypeError(\n                    'Only one controller per account is supported.'\n                )\n            return self.controller_id\n        raise AttributeError('No controllers assigned to this account.')", "response": "Checks if multiple controllers are connected."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the information about a given relay.", "response": "def relay_info(self, relay, attribute=None):\n        \"\"\"\n        Return information about a relay.\n\n        :param relay: The relay being queried.\n        :type relay: int\n        :param attribute: The attribute being queried, or all attributes for\n                          that relay if None is specified.\n        :type attribute: string or None\n        :returns: The attribute being queried or None if not found.\n        :rtype: string or int\n        \"\"\"\n\n        # Check if the relay number is valid.\n        if (relay < 0) or (relay > (self.num_relays - 1)):\n            # Invalid relay index specified.\n            return None\n        else:\n            if attribute is None:\n                # Return all the relay attributes.\n                return self.relays[relay]\n            else:\n                try:\n                    return self.relays[relay][attribute]\n                except KeyError:\n                    # Invalid key specified.\n                    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsuspending a zone or unsuspends all zones for an amount of time.", "response": "def suspend_zone(self, days, zone=None):\n        \"\"\"\n        Suspend or unsuspend a zone or all zones for an amount of time.\n\n        :param days: Number of days to suspend the zone(s)\n        :type days: int\n        :param zone: The zone to suspend. If no zone is specified then suspend\n                     all zones\n        :type zone: int or None\n        :returns: The response from set_zones() or None if there was an error.\n        :rtype: None or string\n        \"\"\"\n        if zone is None:\n            zone_cmd = 'suspendall'\n            relay_id = None\n        else:\n            if zone < 0 or zone > (len(self.relays) - 1):\n                return None\n            else:\n                zone_cmd = 'suspend'\n                relay_id = self.relays[zone]['relay_id']\n\n        # If days is 0 then remove suspension\n        if days <= 0:\n            time_cmd = 0\n        else:\n            # 1 day = 60 * 60 * 24 seconds = 86400\n            time_cmd = time.mktime(time.localtime()) + (days * 86400)\n\n        return set_zones(self._user_token, zone_cmd, relay_id, time_cmd)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns or stops a zone or all zones for an amount of time.", "response": "def run_zone(self, minutes, zone=None):\n        \"\"\"\n        Run or stop a zone or all zones for an amount of time.\n\n        :param minutes: The number of minutes to run.\n        :type minutes: int\n        :param zone: The zone number to run. If no zone is specified then run\n                     all zones.\n        :type zone: int or None\n        :returns: The response from set_zones() or None if there was an error.\n        :rtype: None or string\n        \"\"\"\n        if zone is None:\n            zone_cmd = 'runall'\n            relay_id = None\n        else:\n            if zone < 0 or zone > (len(self.relays) - 1):\n                return None\n            else:\n                zone_cmd = 'run'\n                relay_id = self.relays[zone]['relay_id']\n\n        if minutes <= 0:\n            time_cmd = 0\n            if zone is None:\n                zone_cmd = 'stopall'\n            else:\n                zone_cmd = 'stop'\n        else:\n            time_cmd = minutes * 60\n\n        return set_zones(self._user_token, zone_cmd, relay_id, time_cmd)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_running_zones(self):\n\n        self.update_controller_info()\n\n        if self.running is None or not self.running:\n            return None\n        return int(self.running[0]['relay'])", "response": "Returns the currently active relay number or None if no active relay is found."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the state of the specified zone.", "response": "def is_zone_running(self, zone):\n        \"\"\"\n        Returns the state of the specified zone.\n\n        :param zone: The zone to check.\n        :type zone: int\n        :returns: Returns True if the zone is currently running, otherwise\n                  returns False if the zone is not running.\n        :rtype: boolean\n        \"\"\"\n\n        self.update_controller_info()\n\n        if self.running is None or not self.running:\n            return False\n\n        if int(self.running[0]['relay']) == zone:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the amount of time left in seconds in the watering cycle.", "response": "def time_remaining(self, zone):\n        \"\"\"\n        Returns the amount of watering time left in seconds.\n\n        :param zone: The zone to check.\n        :type zone: int\n        :returns: If the zone is not running returns 0. If the zone doesn't\n                  exist returns None. Otherwise returns number of seconds left\n                  in the watering cycle.\n        :rtype: None or seconds left in the waterting cycle.\n        \"\"\"\n\n        self.update_controller_info()\n\n        if zone < 0 or zone > (self.num_relays-1):\n            return None\n\n        if self.is_zone_running(zone):\n            return int(self.running[0]['time_left'])\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles the parsing of the specified operation using the current state of the buffer and cache.", "response": "def parse(self, op, mode=None):\n        \"\"\"Handles the parsing of the specified operation using the current\n        statements from the buffer/cache. If 'comment' is not None, the \n        statement in comment is parsed instead.\n\n        :arg mode: override the 'insert', 'replace' or 'delete' specifier.\n        \"\"\"\n        #We need to handle docstrings separately because they are XML and slight\n        #insertions/changes can't be handled using only one line. We have to get\n        #hold of the entire XML block and parse it all at once again.\n        if op.state[0] is None:\n            linenum, statement, length = op.curcached\n        else:\n            linenum, statement, length = op.curbuffer\n\n        #If there is nothing to run, it is pointless carrying on down the\n        #stack of functions before this gets realized.\n        if statement != \"\":\n            self._current_op = op\n            #We may need to override the mode for the 'replace' operation.\n            nmode = mode if mode is not None else op.mode\n\n            #We are dealing with pure code, decide what type the owner is and run\n            #their method for real time updating.\n            if isinstance(op.element, Executable):\n                op.element.rt_update(statement, linenum, nmode, \n                                     op.context.parser.modulep.xparser)\n            elif isinstance(op.element, CustomType):\n                op.element.rt_update(statement, linenum, nmode, \n                                     op.context.parser.modulep.tparser)\n            elif isinstance(op.element, Module):\n                op.element.rt_update(statement, linenum, nmode, \n                                     op.context.parser.modulep, self)\n\n        if len(self.additions) > 0:\n            #Some new instances were created from a single line signature.\n            #probably any additional statements in the list being executed\n            #include items that should belong to the new instance.\n            for add in self.additions:\n                instance, module = add\n                self.parent.update_instance_extent(instance, module, op)\n\n            self.additions = []"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the absolute character index of the specified regex match start and end indices in the buffer * refstring.", "response": "def absolute_charindex(self, string, start, end):\n        \"\"\"Finds the absolute character index of the specified regex match\n        start and end indices in the *buffer* refstring.\"\"\"\n        search = string[start:end]\n        abs_start = self.refstring.index(search)\n        return abs_start, (end - start) + abs_start"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine the absolute character index for the specified line and character using the buffer s code string.", "response": "def charindex(self, line, char, context):\n        \"\"\"Determines the absolute character index for the specified line\n        and char using the *buffer's* code string.\"\"\"\n        #Make sure that we have chars and lines to work from\n        if len(context.bufferstr) > 0 and len(self._chars) == 0:\n            #Add one for the \\n that we split on for each line\n            self._chars = [ len(x) + 1 for x in context.bufferstr ]\n            #Remove the last line break since it doesn't exist\n            self._chars[-1] -= 1\n\n            #Now we want to add up the number of characters in each line\n            #as the lines progress so that it is easy to search for the\n            #line of a single character index\n            total = 0\n            for i in range(len(self._chars)):\n                total += self._chars[i]\n                self._chars[i] = total\n        \n        return self._chars[line - 1] + char"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the element who owns the first line number for the operation in the cached source code.", "response": "def element(self):\n        \"\"\"Returns the instance of the element who owns the first line\n        number for the operation in the cached source code.\"\"\"\n        #We assume here that the entire operation is associated with a single\n        #code element. Since the sequence matcher groups operations by contiguous\n        #lines of code to change, this is a safe assumption.\n        if self._element is None:\n            line = self.icached[0]\n            #If we are inserting a new line, the location at the start of the line\n            #that used to be there interferes with the element finder.\n            if self.mode == \"insert\":\n                line -= 1\n            self._element = self.context.module.get_element(line, 0)\n\n        return self._element"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef docelement(self):\n        #This is needed since the decorating documentation\n        #for types and executables is in the body of the module, but when they\n        #get edited, the edit belongs to the type/executable because the character\n        #falls within the absstart and end attributes.\n        if self._docelement is None:\n            if isinstance(self.element, Module):\n                self._docelement = self.element\n            else:\n                ichar = self.element.module.charindex(self.icached[0], 1)\n                if (ichar > self.element.docstart and ichar <= self.element.docend):\n                    self._docelement = self.element.parent\n                else:\n                    self._docelement = self.element\n\n        return self._docelement", "response": "Returns the instance of the element whose body owns the docstring\n        in the current operation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle(self):\n        #If we have more statements in the buffer than the cached, it doesn't matter, \n        #we just run the first few replacements of the cache concurrently and do \n        #what's left over from the buffer.\n        #REVIEW\n        if self.mode == \"insert\": #then self.icached[0] == self.icached[1]:\n            #We are inserting the lines from the buffer into the cached version\n            for ib in range(len(self.buffered)):\n                self.state = (ib, None)\n                self.parser.parse(self)\n                self._update_extent()\n\n        elif self.mode == \"delete\": #then self.ibuffer[0] == self.ibuffer[1]:\n            #We are deleting lines from the cached version\n            for ic in range(len(self.cached)):\n                self.state = (None, ic)\n                self.parser.parse(self)\n                self._update_extent()\n        \n        else: # mode == 'replace'\n            #Need lines from both the buffer and the cached version\n            #First we run all the statements in cached as deletions\n            for ic in range(len(self.cached)):\n                self.state = (None, ic)\n                self.parser.parse(self, \"delete\")\n                self._update_extent()\n            #Then run all the buffer statements as insertions.\n            for ib in range(len(self.buffered)):\n                self.state = (ib, None)\n                self.parser.parse(self, \"insert\")\n                self._update_extent()\n\n        self._handle_docstrings()", "response": "Handles the real time update of some code from the cached representation\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _handle_docstrings(self):\n        #Docstrings have to be continuous sets of lines that start with !!\n        #When they change in any way (i.e. any of the three modes), we \n        #have to reparse the entire block because it has XML dependencies\n        #Because of that, the cached version of the docstrings is actually\n        #pointless and we only need to focus on the buffered.\n        blocks = self._docstring_getblocks()\n\n        if len(blocks) == 0:\n            return\n\n        xmldict = self._docstring_parse(blocks)\n        delta = 0\n\n        if isinstance(self.docelement, Module):\n            delta += self.docparser.rt_update_module(xmldict, self.docelement)\n        else:\n            #We just need to handle the type and executable internal defs.\n            if self.docelement.name in xmldict:\n                docs = self.docparser.to_doc(xmldict[self.docelement.name][0],\n                                             self.docelement.name)\n                self.docparser.process_memberdocs(docs, self.docelement, False)\n            #Also update the docstrings for any embedded types or executables.\n            if isinstance(self.docelement, Executable):\n                delta += self.docparser.process_embedded(xmldict, \n                                                         self.docelement, False)\n\n        #Finally, we need to handle the overall character length change\n        #that this update caused to the element first and then for the\n        #operation as a whole for updating the module and its children.\n        buffertot = sum([len(self.context.bufferstr[i]) for i in self._doclines])\n        cachedtot = 0\n    \n        for i in range(self.icached[0],self.icached[1]):\n            if self.docparser.RE_DOCS.match(self.context.cachedstr[i]):\n                cachedtot += len(self.context.cachedstr[i])\n\n        self.length = buffertot - cachedtot\n\n        if delta == 0:\n            #The update must have been to members variables of the module or the\n            #executables/types. The element who owns the members is going to get\n            #missed when the module updates its children.\n            self.docelement.end += self.length\n        else:\n            #All the individual elements have been updated already, so just\n            #set the length change for this operation.\n            self.docdelta = delta", "response": "This function handles the docstrings of the current element."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the XML from the specified blocks of docstrings.", "response": "def _docstring_parse(self, blocks):\n        \"\"\"Parses the XML from the specified blocks of docstrings.\"\"\"\n        result = {}\n        for block, docline, doclength, key in blocks:\n            doctext = \"<doc>{}</doc>\".format(\" \".join(block))\n            try:\n                docs = ET.XML(doctext)\n                docstart = self.parser.charindex(docline, 0, self.context)\n                if not key in result:\n                    result[key] = [list(docs), docstart, docstart + doclength]\n                else:\n                    #If there are docblocks separated by whitespace in the\n                    #same element we can't easily keep track of the start and\n                    #end character indices anymore.\n                    result[key][0].extend(list(docs))\n            except ET.ParseError:\n                msg.warn(doctext)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the longest continuous block of docstrings from the buffer.", "response": "def _docstring_getblocks(self):\n        \"\"\"Gets the longest continuous block of docstrings from the buffer\n        code string if any of those lines are docstring lines.\n        \"\"\"\n        #If there are no lines to look at, we have nothing to do here.\n        if self.ibuffer[0] == self.ibuffer[1]:\n            return []\n\n        lines = self.context.bufferstr[self.ibuffer[0]:self.ibuffer[1]]\n        docblock = []\n        result = []\n        self._doclines = []\n\n        #We need to keep track of the line number for the start of the\n        #documentation strings.\n        docline = 0\n        doclength = 0\n\n        first = self.docparser.RE_DOCS.match(lines[0])\n        if first is not None:\n            docblock.append(first.group(\"docstring\"))\n            docline = self.ibuffer[0]\n            self._doclines.append(docline)\n            doclength += len(lines[0]) + 1 # + 1 for \\n removed by split.\n\n            #We need to search backwards in the main buffer string for\n            #additional tags to add to the block\n            i = self.ibuffer[0] - 1\n            while i > 0:\n                current = self.context.bufferstr[i]\n                docmatch = self.docparser.RE_DOCS.match(current)\n                if docmatch is not None:\n                    docblock.append(docmatch.group(\"docstring\"))\n                    docline = i\n                    doclength += len(current) + 1\n                else:\n                    break\n                i -= 1\n\n        #Reverse the docblock list since we were going backwards and appending.\n        if len(docblock) > 0:\n            docblock.reverse()\n\n        #Now handle the lines following the first line. Also handle the\n        #possibility of multiple, separate blocks that are still valid XML.\n        #We have to keep going until we have exceed the operational changes\n        #or found the decorating element.\n        i = self.ibuffer[0] + 1\n        while (i < len(self.context.bufferstr) and \n               (i < self.ibuffer[1] or len(docblock) > 0)):\n            line = self.context.bufferstr[i]\n            docmatch = self.docparser.RE_DOCS.match(line)\n            if docmatch is not None:\n                docblock.append(docmatch.group(\"docstring\"))\n                doclength += len(line)\n                if docline == 0:\n                    docline = i\n                #Only track actual documentation lines that are within the \n                #operations list of lines.\n                if i < self.ibuffer[1]:\n                    self._doclines.append(i)\n\n            elif len(docblock) > 0:\n                key = self._docstring_key(line)\n                result.append((docblock, docline, doclength, key))\n                docblock = []\n                docline = 0\n                doclength = 0\n\n            #We need to exit the loop if we have exceeded the length of\n            #the operational changes\n            if len(docblock) == 0 and i > self.ibuffer[1]:\n                break\n            i += 1\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _docstring_key(self, line):\n        decormatch = self.docparser.RE_DECOR.match(line)\n        if decormatch is not None:\n            key = \"{}.{}\".format(self.docelement.name, decormatch.group(\"name\"))\n        else:\n            key = self.element.name\n\n        return key", "response": "Returns the key to use for the docblock immediately preceding\n        the specified line."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _update_extent(self):\n        #For new instances, their length is being updated by the module\n        #updater and will include *all* statements, so we don't want to\n        #keep changing the endpoints.\n        if self.bar_extent:\n            return\n            \n        original = self.element.end\n        if self.mode == \"insert\":\n            #The end value needs to increase by the length of the current\n            #statement being executed.\n            self.element.end += self.curlength\n        elif self.mode == \"delete\":\n            #Reduce end by statement length\n            self.element.end -= self.curlength\n        elif self.mode == \"replace\":\n            #Check whether we are currently doing the delete portion of the\n            #replacement or the insert portion.\n            if self.state[0] is None:\n                self.element.end -= self.curlength\n            else:\n                self.element.end += self.curlength\n\n        #Keep track of the total effect of all statements in this operation\n        #so that it is easy to update the module once they are all done.\n        self.length += self.element.end - original", "response": "Updates the extent of the element being altered by this operation\n        to include the code that has changed."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of the statements that are new for the real time update.", "response": "def _get_buffered(self):\n        \"\"\"Gets a list of the statements that are new for the real time update.\"\"\"\n        lines = self.context.bufferstr[self.ibuffer[0]:self.ibuffer[1]]\n        return self._get_statements(lines, self.ibuffer[0])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_cached(self):\n        lines = self.context.cachedstr[self.icached[0]:self.icached[1]]\n        return self._get_statements(lines, self.icached[0])", "response": "Gets a list of statements that the operation will affect during the real\n        time update."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_statements(self, lines, start):\n        result = []\n        statement = []\n        nocomment = [l.split(\"!\")[0] for l in lines]\n        length = 0\n\n        for i in range(len(nocomment)):\n            line = nocomment[i].strip()\n            linenum = start + i\n            length += len(lines[i]) + 1\n\n            if len(line) == 0 or line[-1] != \"&\":\n                statement.append(line)\n                result.append((linenum-len(statement)+1, \n                               \" \".join(statement), length))\n                statement = []\n                length = 0\n            else:\n                #Append the line without the continuation character.\n                statement.append(line[:len(line)-1])\n\n        return result", "response": "Returns a list of complete Fortran statements for the specified lines by starting at the specified index."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, context):\n        #Get a list of all the operations that need to be performed and then\n        #execute them.\n        self._operations = self._get_operations(context)\n\n        for i in range(len(self._operations)):\n            self._operations[i].handle()\n            self.update_extent(self._operations[i])\n\n        #Last of all, we update the string content of the cached version of\n        #the module to have the latest source code.\n        if len(self._operations) > 0:\n            context.module.update_refstring(context.refstring)", "response": "Updates all references in the cached representation of the module with their latest source code string that was extracted from the specified source code string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the extent of the module and its elements using the specified operation which has already been executed.", "response": "def update_extent(self, operation):\n        \"\"\"Updates the extent of the *module* and its elements using the\n        specified operation which has already been executed.\"\"\"\n        #Operations represent continuous lines of code.\n        #The last operation to be executed is still the current one.\n        line, col = operation.start\n        operation.context.module.update_elements(line, col, operation.length,\n                                                 operation.docdelta)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of operations that need to be performed to turn the cached source code into the one in the buffer.", "response": "def _get_operations(self, context):\n        \"\"\"Returns a list of operations that need to be performed to turn the\n        cached source code into the one in the buffer.\"\"\"\n        #Most of the time, the real-time update is going to fire with\n        #incomplete statements that don't result in any changes being made\n        #to the module instances. The SequenceMatches caches hashes for the\n        #second argument. Logically, we want to turn the cached version into\n        #the buffer version; however, the buffer is the string that keeps \n        #changing.\n\n        #in order to optimize the real-time update, we *switch* the two strings\n        #when we set the sequence and then fix the references on the operations\n        #after the fact.\n        if context.module.changed or self.unset:\n            self.matcher.set_seq2(context.cachedstr)\n            self.unset = False\n            #Set the changed flag back to false now that the sequencer has\n            #reloaded it.\n            context.module.changed = False\n        self.matcher.set_seq1(context.bufferstr)\n\n        opcodes = self.matcher.get_opcodes()\n        result = []\n\n        #Index i keeps track of how many operations were actually added because\n        #they constituted a change we need to take care of.\n        i = 0\n        for code in opcodes:\n            if code[0] != \"equal\":\n                #Replacements don't have a mode change. All of the operations\n                #switch the order of the line indices for the two strings.\n                if code[0] == \"insert\":\n                    newcode = (\"delete\", code[3], code[4], code[1], code[2])\n                elif code[0] == \"delete\":\n                    newcode = (\"insert\", code[3], code[4], code[1], code[2])\n                else:\n                    newcode = (\"replace\", code[3], code[4], code[1], code[2])\n\n                op = Operation(context, self.parser, newcode, i)\n                result.append(op)\n                i += 1\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate a new instance that was added to a module.", "response": "def update_instance_extent(self, instance, module, operation):\n        \"\"\"Updates a new instance that was added to a module to be complete\n        if the end token is present in any remaining, overlapping operations.\n        \"\"\"\n        #Essentially, we want to look in the rest of the statements that are\n        #part of the current operation to see how many more of them pertain \n        #to the new instance that was added.\n\n        #New signatures only result in instances being added if mode is \"insert\"\n        #or \"replace\". In both cases, the important code is in the buffered\n        #statements, *not* the cached version. Iterate the remaining statements\n        #in the buffer and look for the end_token for the instance. If we don't\n        #find it, check for overlap between the operations' index specifiers.\n        instance.end -= operation.curlength\n        end_token = instance.end_token\n        (ibuffer, length) = self._find_end_token(end_token, operation)\n        cum_length = length\n        \n        opstack = [operation]\n        while ibuffer is None and opstack[-1].index + 1 < len(self._operations):\n            #We didn't find a natural termination to the new instance. Look for\n            #overlap in the operations\n            noperation = self._operations[opstack[-1].index + 1]\n            #We only want to check the next operation if it is a neighbor\n            #in line numbers in the buffer.\n            if noperation.ibuffer[0] - opstack[-1].ibuffer[1] == 1:\n                (ibuffer, length) = self._find_end_token(end_token, noperation)\n                cum_length += length\n                opstack.append(noperation)\n            else:\n                break\n            \n        if ibuffer is not None:\n            instance.incomplete = False\n            instance.end += cum_length\n            for op in opstack:\n                op.bar_extent = True\n                op.set_element(instance)\n        else:\n            #We set the element for the current operation to be the new instance\n            #for the rest of statements in its set.\n            operation.set_element(instance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches for a statement in the operation s list that matches the specified end token. Returns the index of the statement in the operation that matches the specified end token.", "response": "def _find_end_token(self, end_token, operation):\n        \"\"\"Looks for a statement in the operation's list that matches the specified\n        end token. Returns the index of the statement in the operation that matches.\n        \"\"\"\n        ibuffer, icache = operation.state\n        length = operation.buffered[ibuffer][2]\n        result = None\n\n        for i in range(len(operation.buffered) - ibuffer - 1):\n            linenum, statement, charlength = operation.buffered[i + ibuffer + 1]\n            length += charlength\n            \n            if end_token in statement.lower():\n                #We already have the absolute char index for the start of the\n                #instance; we just need to update the end.\n                result = (i + ibuffer + 1, length)\n                break        \n\n        #If we didn't find a terminating statement, the full length of the operation\n        #is a good estimate for the extent of the instance.\n        if result is None:\n            result = (None, length)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving values for a set of keys.", "response": "def mget(self, *keys, **kwargs):\n        \"\"\"Retrieve values for a set of keys.\n\n        Args:\n            keys (str list): the list of keys whose value should be retrieved\n\n        Keyword arguements:\n            default (object): the value to use for non-existent keys\n            coherent (bool): whether all fetched values should be \"coherent\",\n                i.e no other update was performed on any of those values while\n                fetching from the database.\n\n        Yields:\n            object: values for the keys, in the order they were passed\n        \"\"\"\n        default = kwargs.get('default')\n        coherent = kwargs.get('coherent', False)\n        for key in keys:\n            yield self.get(key, default=default)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the value of several keys at once.", "response": "def mset(self, values):\n        \"\"\"Set the value of several keys at once.\n\n        Args:\n            values (dict): maps a key to its value.\n        \"\"\"\n        for key, value in values.items():\n            self.set(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef names(self):\n        #This is where the context information is extremely useful in \n        #limiting the extent of the search space we need to examine.\n        if self._names is None:\n            attribute = self.get_attribute()\n            if self.context.module is not None:\n                symbol = self.context.symbol\n                fullsymbol = self.context.full_symbol\n                self._names = self._complete_el(symbol, attribute, fullsymbol)\n            else:\n                self._names = []\n\n        return self._names", "response": "Returns a list of possible completions for the symbol under the the\n        cursor in the current user context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bracket_complete(self):\n        #The important thing to keep track of here is that '(' can be\n        #pushed in the following places:\n        # - in a subroutine/function definition\n        # - when calling a function or subroutine, this includes calls within\n        #   the argument list of a function, e.g. function(a, fnb(c,d), e)\n        # - when specifying the dimensions of an array for element selection\n        # - inside of if/do/while blocks.\n\n        #If there is a \\s immediately preceding the bracket, then short_symbol\n        #will be null string and we are most likely doing arithmetic of some\n        #sort or a block statement.\n        if self.context.short_symbol == \"\":\n            return {}\n\n        line = self.context.current_line.lower()[:self.context.pos[1]-1]\n        if \"subroutine\" in line or \"function\" in line:\n            #We are in the definition of the subroutine or function. They\n            #are choosing the parameter names so we don't offer any suggestions.\n            return {}\n            \n        #Sometimes people do if() with the condition immediately after\n        #the keyword, this regex will catch that.\n        symbol = self.context.short_symbol.lower()\n        if symbol in [\"if\", \"do\", \"while\", \"elseif\", \"case\", \"associate\"]:\n            return {}\n        \n        #All that should be left now are dimensions and legitimate function\n        #calls.\n        fullsymbol = self.context.short_full_symbol.lower()\n        return self._bracket_complete_sig(symbol, fullsymbol)", "response": "Returns a function call signature for completion whenever a bracket is pressed."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _bracket_complete_sig(self, symbol, fullsymbol):\n        if symbol != fullsymbol:\n            #We have a sym%sym%... chain and the completion just needs to\n            #be the signature of the member method.\n            target, targmod = self._get_chain_parent_symbol(symbol, fullsymbol)\n\n            if symbol in target.executables:\n                child = target.executables[symbol]\n                return self._compile_signature(child.target, child.name)\n            elif symbol in target.members:\n                #We are dealing with a dimension request on an array that\n                #is a member of the type.\n                child = target.members[symbol]\n                return self._bracket_dim_suggest(child)\n            else:                \n                return {}\n        else:\n            #We must be dealing with a regular executable or builtin fxn\n            #or a regular variable dimension.\n            iexec = self._bracket_exact_exec(symbol)\n            if iexec is not None:\n                #It is indeed a function we are completing for.\n                return self._compile_signature(iexec, iexec.name)\n            else:\n                #We need to look at local and global variables to find the\n                #variable declaration and dimensionality.\n                ivar = self._bracket_exact_var(symbol)\n                return self._bracket_dim_suggest(ivar)", "response": "Returns the call signature and docstring for the executable\n            immediately preceding a bracket '(' that was typed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary of documentation for helping complete the dimensions of a variable.", "response": "def _bracket_dim_suggest(self, variable):\n        \"\"\"Returns a dictionary of documentation for helping complete the\n        dimensions of a variable.\"\"\"\n        if variable is not None:\n            #Look for <dimension> descriptors that are children of the variable\n            #in its docstrings.\n            dims = variable.doc_children(\"dimension\", [\"member\", \"parameter\", \"local\"])\n            descript = str(variable)\n            if len(dims) > 0:\n                descript += \" | \" + \" \".join([DocElement.format_dimension(d) for d in dims])\n\n            return dict(\n                params=[variable.dimension],\n                index=0,\n                call_name=variable.name,\n                description=descript,\n            )        \n        else:\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_definition(self):\n        #Check the variables first, then the functions.\n        match = self._bracket_exact_var(self.context.exact_match)\n        if match is None:\n           match = self._bracket_exact_exec(self.context.exact_match)\n\n        return match", "response": "Checks variable and executable code elements based on the current\n        context for a code element whose name matches context. exact_match. If none are found returns None."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _bracket_exact_var(self, symbol):\n        if isinstance(self.element, Executable):\n            if symbol in self.element.parameters:\n                return self.element.parameters[symbol]            \n            if symbol in self.element.members:\n                return self.element.members[symbol]\n\n        if symbol in self.element.module.members:\n            return self.element.module.members[symbol]\n\n        return None", "response": "Checks local first and then module global variables for an exact variable match to the specified symbol name. Returns None if no match is found."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _bracket_exact_exec(self, symbol):\n        if symbol in self.context.module.executables:\n            return self.context.module.executables[symbol]\n\n        if symbol in self.context.module.interfaces:\n            return self.context.module.interfaces[symbol]\n\n        if symbol in cache.builtin:\n            return cache.builtin[symbol]\n\n        #Loop through all the dependencies of the current module and see\n        #if one of them is the method we are looking for.\n        return self.context.module.get_dependency_element(symbol)", "response": "Checks builtin local and global executable collections for the\n        specified symbol and returns it as soon as it is found."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncompiles the signature for the specified executable and returns as a dictionary.", "response": "def _compile_signature(self, iexec, call_name):\n        \"\"\"Compiles the signature for the specified executable and returns\n        as a dictionary.\"\"\"\n        if iexec is not None:\n            summary = iexec.summary\n            if isinstance(iexec, Function):\n                summary = iexec.returns + \"| \" + iexec.summary\n            elif isinstance(iexec, Subroutine) and len(iexec.modifiers) > 0:\n                summary = \", \".join(iexec.modifiers) + \" | \" + iexec.summary\n            elif isinstance(iexec, Interface):\n                summary = iexec.describe()\n            else:\n                summary = iexec.summary\n\n            #Add the name of the module who owns the method. Useful in case the\n            #same executable is defined in multiple modules, but only one is\n            #referenced in the current context.\n            if iexec.parent is not None:\n                summary += \" | MODULE: {}\".format(iexec.module.name)\n            else:\n                summary += \" | BUILTIN\"\n\n            return dict(\n                params=[p.name for p in iexec.ordered_parameters],\n                index=0,\n                call_name=call_name,\n                description=summary,\n            )        \n        else:\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef signature(self):\n        #We can't really do anything sensible without the name of the function\n        #whose signature we are completing.\n        iexec, execmod = self.context.parser.tree_find(self.context.el_name, \n                                              self.context.module, \"executables\")\n        if iexec is None:\n            #Look in the interfaces next using a tree find as well\n            iexec, execmod = self.context.parser.tree_find(self.context.el_name, self.context.module,\n                                                  \"interfaces\")\n        if iexec is None:\n            return []\n\n        return self._signature_index(iexec)", "response": "Gets completion or call signature information for the current cursor."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining where in the call signature the cursor is to decide which parameter needs to have its information returned for the intellisense.", "response": "def _signature_index(self, iexec):\n        \"\"\"Determines where in the call signature the cursor is to decide which\n        parameter needs to have its information returned for the intellisense.\n        \"\"\"\n        #Find out where in the signature the cursor is at the moment.\n        call_index = self.context.call_arg_index\n        if call_index is not None:\n            #We found the index of the parameter whose docstring we want\n            #to return.\n            param = iexec.get_parameter(call_index)\n            paramlist = [ p.name for p in iexec.ordered_parameters ]\n            paramlist[call_index] = \"*{}*\".format(paramlist[call_index])\n\n            if not isinstance(param, list) and param is not None:\n                #Write a nice description that includes the parameter type and\n                #intent as well as dimension.\n                summary = \"{} | {}\".format(str(param), param.summary)\n                #We also want to determine if this parameter has its value changed\n                #by the function we are completing on.\n                changedby = iexec.changed(param.name)\n                if changedby is not None:\n                    summary += \" *MODIFIED*\"\n            elif isinstance(param, list) and len(param) > 0:\n                act_type = []\n                for iparam in param:\n                    if iparam is not None and iparam.strtype not in act_type:\n                        act_type.append(iparam.strtype)\n\n                act_text = ', '.join(act_type)\n                summary = \"SUMMARY: {} | ACCEPTS: {}\".format(param[0].summary, act_text)\n\n                if iexec.changed(param[0].name):\n                    summary += \" | *MODIFIED*\"\n            else:\n                summary = \"No matching variable definition.\"\n\n            #Add the name of the module who owns the executable.\n            summary += \" | MODULE: {}\".format(iexec.module.name)\n\n            return dict(\n                params=paramlist,\n                index=call_index,\n                call_name=self.context.el_name,\n                description=summary,\n            )\n        else:\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a list of completion objects for the symbol under the cursor.", "response": "def complete(self):\n        \"\"\"Gets a list of completion objects for the symbol under the cursor.\"\"\"\n        if self._possible is None:\n            self._possible = []\n            for possible in self.names:\n                c = Completion(self.context, self.names[possible], len(self.context.symbol))\n                self._possible.append(c)\n\n        return self._possible"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks whether the specified symbol is part of the name for completion.", "response": "def _symbol_in(self, symbol, name):\n        \"\"\"Checks whether the specified symbol is part of the name for completion.\"\"\"\n        lsymbol = symbol.lower()\n        lname = name.lower()\n        return lsymbol == lname[:len(symbol)] or \"_\" + lsymbol in lname"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsuggests a list of completions based on the el_section and el_call attributes.", "response": "def _complete_el(self, symbol, attribute, fullsymbol):\n        \"\"\"Suggests a list of completions based on the el_* attributes\n        of the user_context.\"\"\"\n        if symbol != fullsymbol:\n            #We have a sym%sym%... chain and the completion just needs to\n            #be a member variable or method of the type being referenced.\n            return self._complete_type_chain(symbol, fullsymbol)\n\n        if self.context.el_section == \"params\":\n            #They are in the process of defining a new executable and are\n            #picking the names themselves, return normal word complete.\n            return self._complete_word(symbol, attribute)\n        elif self.context.el_section == \"body\":\n            if self.context.el_call in [\"sub\", \"fun\"]:\n                return self._complete_sig(symbol, attribute)\n            else:\n                return self._complete_word(symbol, attribute)\n        else:\n            return self._complete_word(symbol, attribute)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the code element object for the parent of the specified symbol in the fullsymbol chain.", "response": "def _get_chain_parent_symbol(self, symbol, fullsymbol):\n        \"\"\"Gets the code element object for the parent of the specified\n        symbol in the fullsymbol chain.\"\"\"\n        #We are only interested in the type of the variable immediately preceding our symbol\n        #in the chain so we can list its members.\n        chain = fullsymbol.split(\"%\")\n\n        #We assume that if symbol != fullsymbol, we have at least a % at the end that \n        #tricked the symbol regex.\n        if len(chain) < 2:\n            return ([], None)\n        previous = chain[-2].lower()\n\n        #Now we need to use the name of the variable to find the actual type name\n        target_name = \"\"\n        if previous in self.element.members:\n            target_name = self.element.members[previous].kind\n        #The contextual element could be a module, in which case it has no parameters\n        if hasattr(self.element, \"parameters\") and previous in self.element.parameters:\n            target_name = self.element.parameters[previous].kind\n\n        if target_name == \"\":\n            return (None, None)\n\n        return self.context.parser.tree_find(target_name, self.context.module, \"types\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _complete_type_chain(self, symbol, fullsymbol):\n        target, targmod = self._get_chain_parent_symbol(symbol, fullsymbol)\n        if target is None:\n            return {}\n\n        result = {}\n        #We might know what kind of symbol to limit the completion by depending on whether\n        #it was preceded by a \"call \" for example. Check the context's el_call\n        if symbol != \"\":\n            if self.context.el_call != \"sub\":\n                for mkey in target.members:\n                    if self._symbol_in(symbol, mkey):\n                        result[mkey] = target.members[mkey]\n\n            for ekey in target.executables:\n                if (self._symbol_in(symbol, ekey)):\n                    if self.context.el_call == \"sub\":\n                        if (isinstance(target.executables[ekey], Subroutine)):\n                            result[ekey] = target.executables[ekey]\n                    else:\n                        if (isinstance(target.executables[ekey], Function)):\n                            result[ekey] = target.executables[ekey]\n        else:\n            if self.context.el_call != \"sub\":\n                result.update(target.members)\n                subdict = {k: target.executables[k] for k in target.executables\n                           if isinstance(target.executables[k].target, Function)}\n                result.update(subdict)\n            else:\n                subdict = {k: target.executables[k] for k in target.executables\n                           if isinstance(target.executables[k].target, Subroutine)}\n                result.update(subdict)\n\n        return result", "response": "Suggests completion for the end of a type chain."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsuggesting completion for calling a function or subroutine.", "response": "def _complete_sig(self, symbol, attribute):\n        \"\"\"Suggests completion for calling a function or subroutine.\"\"\"\n        #Return a list of valid parameters for the function being called\n        fncall = self.context.el_name\n        iexec, execmod = self.context.parser.tree_find(fncall, self.context.module, \"executables\")\n\n        if iexec is None:\n            #Try the interfaces as a possible executable to complete.\n            iexec, execmod = self.context.parser.tree_find(fncall, self.context.module, \"interfaces\")\n\n        if iexec is not None:\n            if symbol == \"\":\n                return iexec.parameters\n            else:\n                result = {}\n                for ikey in iexec.parameters:\n                    if self._symbol_in(symbol, ikey):\n                        result[ikey] = iexec.parameters[ikey]\n                return result\n        else:\n            return self._complete_word(symbol, attribute)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsuggest context completions based exclusively on the word preceding the cursor.", "response": "def _complete_word(self, symbol, attribute):\n        \"\"\"Suggests context completions based exclusively on the word\n        preceding the cursor.\"\"\"\n        #The cursor is after a %(,\\s and the user is looking for a list\n        #of possibilities that is a bit smarter that regular AC.\n        if self.context.el_call in [\"sub\", \"fun\", \"assign\", \"arith\"]:\n            if symbol == \"\":\n                #The only possibilities are local vars, global vars or functions\n                #presented in that order of likelihood. \n                return self._complete_values()\n            else:\n                #It is also possible that subroutines are being called, but that\n                #the full name hasn't been entered yet.\n                return self._complete_values(symbol)\n        else:\n            return self.context.module.completions(symbol, attribute, True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters the specified dict of executables to include only those that are not referenced in a derived type or an interface.", "response": "def _generic_filter_execs(self, module):\n        \"\"\"Filters the specified dict of executables to include only those that are not referenced\n        in a derived type or an interface.\n        \n        :arg module: the module whose executables should be filtered.\n        \"\"\"\n        interface_execs = []\n        for ikey in module.interfaces:\n            interface_execs.extend(module.interfaces[ikey].procedures)\n\n        return {k: module.executables[k] for k in module.executables if \n                (\"{}.{}\".format(module.name, k) not in interface_execs and \n                 not module.executables[k].is_type_target)}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompiles a list of possible symbols that can hold a value in place. These consist of local vars global vars and functions.", "response": "def _complete_values(self, symbol = \"\"):\n        \"\"\"Compiles a list of possible symbols that can hold a value in\n        place. These consist of local vars, global vars, and functions.\"\"\"\n        result = {}\n        #Also add the subroutines from the module and its dependencies.\n        moddict = self._generic_filter_execs(self.context.module)\n        self._cond_update(result, moddict, symbol)\n        self._cond_update(result, self.context.module.interfaces, symbol)\n        for depend in self.context.module.dependencies:\n            if depend in self.context.module.parent.modules:\n                #We don't want to display executables that are part of an interface, or that are embedded in\n                #a derived type, since those will be called through the type or interface\n                filtdict = self._generic_filter_execs(self.context.module.parent.modules[depend])\n                self._cond_update(result, filtdict, symbol)\n                self._cond_update(result, self.context.module.parent.modules[depend].interfaces, symbol)\n\n        #Add all the local vars if we are in an executable\n        if (isinstance(self.context.element, Function) or \n            isinstance(self.context.element, Subroutine)):\n            self._cond_update(result, self.element.members, symbol)\n        #Next add the global variables from the module\n        if self.context.module is not None:\n            self._cond_update(result, self.context.module.members, symbol)\n            #Next add user defined functions to the mix\n            for execkey in self.context.module.executables:\n                iexec = self.context.module.executables[execkey]\n                if isinstance(iexec, Function) and self._symbol_in(symbol, iexec.name):\n                    result[iexec.name] = iexec\n\n        #Finally add the builtin functions to the mix. We need to add support\n        #for these in a separate file so we have their call signatures.\n        if symbol == \"\":\n            #Use the abbreviated list of most common fortran builtins\n            self._cond_update(result, cache.common_builtin, symbol)\n        else:\n            #we can use the full list as there will probably not be that\n            #many left over.\n            self._cond_update(result, cache.builtin, symbol)           \n        \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _cond_update(self, first, second, symbol, maxadd = -1):\n        if symbol != \"\":\n            added = 0\n            for key in second:\n                if self._symbol_in(symbol, key) and (maxadd == -1 or added <= maxadd):\n                    first[key] = second[key]\n                    added += 1\n        else:\n            first.update(second)", "response": "Updates the keys and values in the first dictionary with thoseCOOKIES of the second dictionary with thoseCOOKIES of the second dictionary with thoseCOOKIES of the second dictionary with thoseCOOKIES of the second dictionary with the specified symbol."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_attribute(self):\n        attributes = ['dependencies', 'publics', 'members', \n                          'types', 'executables']\n        #Find the correct attribute based on the type of the context\n        if self.context.el_type in [Function, Subroutine]:\n            attribute = attributes[4]\n        elif self.context.el_type == CustomType:\n            attribute = attributes[3]\n        else:\n            attribute = attributes[2]\n\n        return attribute", "response": "Gets the appropriate module attribute name for a collection \n        corresponding to the context s element type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_dimension(dimension):\n        result = \"\"\n        if \"type\" in dimension.attrib:\n            result += \"[R\" if dimension.attrib[\"type\"] == \"row\" else \"[C\"\n        else:\n            result += \"[C\"\n        if \"index\" in dimension.attrib:\n            result += \":\" + dimension.attrib[\"index\"]\n\n        result += \"] \" + re.sub(\"\\s+\", \" \", dimension.text.replace(\"\\n\", \" \"))\n        return result", "response": "Formats the specified <dimension > XML tag for string output."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self, parser, xml):\n        #We can only process references if the XML tag has inner-XML\n        if xml.text is not None:\n            matches = parser.RE_REFS.finditer(xml.text)\n            if matches:\n                for match in matches:\n                    #Handle \"special\" references to this.name and param.name here.\n                    self.references.append(match.group(\"reference\"))\n\n        #We also need to get all the XML attributes into the element\n        for key in list(xml.keys()):\n            self.attributes[key] = xml.get(key)", "response": "Parses the rawtext to extract contents and references."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_fileservice_dir():\n    conf = getattr(settings, 'FILESERVICE_CONFIG', {})\n    dir = conf.get('store_dir', './fileservice_store')\n    return os.path.normpath(dir) + os.sep", "response": "get the file service directory"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a parser with common command - line options for all the scripts in the fortpy suite.", "response": "def _common_parser():\n    \"\"\"Returns a parser with common command-line options for all the scripts\n    in the fortpy suite.\n    \"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(add_help=False)\n    parser.add_argument(\"-examples\", action=\"store_true\",\n                        help=\"See detailed help and examples for this script.\")\n    parser.add_argument(\"-verbose\", action=\"store_true\",\n                        help=\"See verbose output as the script runs.\")\n    parser.add_argument('-action', nargs=1, choices=['save','print'], default='print',\n                        help=\"Specify what to do with the output (print or save)\")\n    parser.add_argument(\"-debug\", action=\"store_true\",\n                        help=\"Print verbose calculation information for debugging.\")\n\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate headers list for flask wrapper", "response": "def _getHeaders(self, updateParams=None):\n\t\t\"\"\" create headers list for flask wrapper \"\"\"\n\t\tif not updateParams:\n\t\t\tupdateParams = {}\n\t\tpolicies = self.defaultPolicies\n\t\tif len(updateParams) > 0:\n\t\t\tfor k,v in updateParams.items():\n\t\t\t\tk = k.replace('-','_')\n\t\t\t\tc = globals()[k](v)\n\t\t\t\ttry:\n\t\t\t\t\tpolicies[k] = c.update_policy(self.defaultPolicies[k])\n\t\t\t\texcept Exception, e:\n\t\t\t\t\traise\n\n\t\treturn [globals()[k](v).create_header()\n\t\t\t\tfor k,v in policies.items() if v is not None]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate wrapper for flask app route", "response": "def wrapper(self, updateParams=None):\n\t\t\"\"\" create wrapper for flask app route \"\"\"\n\t\tdef decorator(f):\n\t\t\t_headers = self._getHeaders(updateParams)\n\t\t\t\"\"\" flask decorator to include headers \"\"\"\n\t\t\t@wraps(f)\n\t\t\tdef decorated_function(*args, **kwargs):\n\t\t\t\tresp = make_response(f(*args, **kwargs))\n\t\t\t\tself._setRespHeader(resp, _headers)\n\t\t\t\tresp.has_secure_headers = True\n\t\t\t\treturn resp\n\t\t\treturn decorated_function\n\t\treturn decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nattempts to load the specified module from a serialized cached version. The method returns None if the module is not found.", "response": "def load_module(self, path, changed_time, parser=None):\n        \"\"\"Attempts to load the specified module from a serialized, cached\n        version. If that fails, the method returns none.\"\"\"\n        if settings.use_filesystem_cache == False:\n            return None\n        \n        try:\n            pickle_changed_time = self._index[path]\n        except KeyError:\n            return None\n\n        if (changed_time is not None and\n            pickle_changed_time < changed_time):\n            # the pickle file is outdated\n            return None\n\n        target_path = self._get_hashed_path(path)\n        with open(target_path, 'rb') as f:\n            try:\n                gc.disable()\n                cache_module = pickle.load(f)\n                if parser is not None:\n                    for mod in cache_module:\n                        mod.unpickle(parser)\n            finally:\n                gc.enable()\n\n        debug.dbg('pickle loaded: %s', path)\n        return cache_module"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_module(self, path, module, change_time=None):\n        #First, get a list of the module paths that have already been \n        #pickled. We will add to that list of pickling this module.\n        if settings.use_filesystem_cache == False:\n            return \n\n        self.__index = None\n        try:\n            files = self._index\n        except KeyError:\n            files = {}\n            self._index = files\n\n        target_path = self._get_hashed_path(path)\n        with open(target_path, 'wb') as f:\n            pickle.dump(module, f, pickle.HIGHEST_PROTOCOL)\n            if change_time is None:\n                files[path] = module[0].change_time\n            else:\n                files[path] = change_time\n\n        #Save the list back to the disk\n        self._flush_index()", "response": "Saves the specified module and its contents to the file system\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nkeys a list of file paths that have been pickled in this directory.", "response": "def _index(self):\n        \"\"\"Keys a list of file paths that have been pickled in this directory.\n        The index is stored in a json file in the same directory as the \n        pickled objects.\"\"\"\n        if self.__index is None:\n            try:\n                with open(self._get_path('index.json')) as f:\n                    data = json.load(f)\n            except (IOError, ValueError):\n                self.__index = {}\n            else:\n                # 0 means version is not defined (= always delete cache):\n                if data.get('version', 0) != self.version:\n                    self.clear_cache()\n                    self.__index = {}\n                else:\n                    self.__index = data['index']\n        return self.__index"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites the current list of file paths in the index to the json file and then sets self. _index to None.", "response": "def _flush_index(self):\n        \"\"\"Writes the current list of file paths in the index to the json file\n        and then sets self.__index = None.\n        \"\"\"\n        data = {'version': self.version, 'index': self._index}\n        with open(self._get_path('index.json'), 'w') as f:\n            json.dump(data, f)\n        self.__index = None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_path(self, file):\n        dir = self._cache_directory()\n        if not os.path.exists(dir):\n            os.makedirs(dir)\n        return os.path.join(dir, file)", "response": "Creates the cache directory if it doesn t exist. Returns the\n            full path to the specified file inside the cache directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _cache_directory(self):\n        if settings.unit_testing_mode or settings.use_test_cache:\n            return os.path.join(settings.cache_directory.replace(\"Fortpy\", \"Fortpy_Testing\"), self.py_tag)\n        else:\n            return os.path.join(settings.cache_directory, self.py_tag)", "response": "Returns the full path to the cache directory as specified in settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes a tag string and returns the tag library and tag name.", "response": "def get_lib_and_tag_name(tag):\n    \"\"\"\n    Takes a tag string and returns the tag library and tag name. For example,\n    \"app_tags.tag_name\" is returned as \"app_tags\", \"tag_name\" and\n    \"app_tags.sub.tag_name\" is returned as \"app_tags.sub\", \"tag_name\"\n    \"\"\"\n    if '.' not in tag:\n        raise ValueError('Tag string must be in the format \"tag_lib.tag_name\"')\n    lib = tag.rpartition('.')[0]\n    tag_name = tag.rpartition('.')[-1]\n    return lib, tag_name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the Django HTML to load the tag library and render the tag.", "response": "def get_tag_html(tag_id):\n    \"\"\"\n    Returns the Django HTML to load the tag library and render the tag.\n\n    Args:\n        tag_id (str): The tag id for the to return the HTML for.\n    \"\"\"\n    tag_data = get_lazy_tag_data(tag_id)\n    tag = tag_data['tag']\n    args = tag_data['args']\n    kwargs = tag_data['kwargs']\n    lib, tag_name = get_lib_and_tag_name(tag)\n\n    args_str = ''\n    if args:\n        for arg in args:\n            if isinstance(arg, six.string_types):\n                args_str += \"'{0}' \".format(arg)\n            else:\n                args_str += \"{0} \".format(arg)\n\n    kwargs_str = ''\n    if kwargs:\n        for name, value in kwargs.items():\n            if isinstance(value, six.string_types):\n                kwargs_str += \"{0}='{1}' \".format(name, value)\n            else:\n                kwargs_str += \"{0}={1} \".format(name, value)\n\n    html = '{{% load {lib} %}}{{% {tag_name} {args}{kwargs}%}}'.format(\n        lib=lib, tag_name=tag_name, args=args_str, kwargs=kwargs_str)\n\n    return html"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfixing for various DOM errors that MAL commits.", "response": "def fix_bad_html(html):\n  \"\"\"\n    Fixes for various DOM errors that MAL commits.\n    Yes, I know this is a cardinal sin, but there's really no elegant way to fix this.\n  \"\"\"\n  # on anime list pages, sometimes tds won't be properly opened.\n  html = re.sub(r'[\\s]td class=', \"<td class=\", html)\n  # on anime list pages, if the user doesn't specify progress, MAL will try to close a span it didn't open.\n  def anime_list_closing_span(match):\n    return match.group(u'count') + '/' + match.group(u'total') + '</td>'\n  html = re.sub(r'(?P<count>[0-9\\-]+)</span>/(?P<total>[0-9\\-]+)</a></span></td>', anime_list_closing_span, html)\n\n  # on anime info pages, under rating, there's an extra </div> by the \"licensing company\" note.\n  html = html.replace('<small>L</small></sup><small> represents licensing company</small></div>', '<small>L</small></sup><small> represents licensing company</small>')\n\n  # on manga character pages, sometimes the character info column will have an extra </div>.\n  def manga_character_double_closed_div_picture(match):\n    return \"<td \" + match.group(u'td_tag') + \">\\n\\t\\t\\t<div \" + match.group(u'div_tag') + \"><a \" + match.group(u'a_tag') + \"><img \" + match.group(u'img_tag') + \"></a></div>\\n\\t\\t\\t</td>\"\n  html = re.sub(r\"\"\"<td (?P<td_tag>[^>]+)>\\n\\t\\t\\t<div (?P<div_tag>[^>]+)><a (?P<a_tag>[^>]+)><img (?P<img_tag>[^>]+)></a></div>\\n\\t\\t\\t</div>\\n\\t\\t\\t</td>\"\"\", manga_character_double_closed_div_picture, html)\n\n  def manga_character_double_closed_div_character(match):\n    return \"\"\"<a href=\"/character/\"\"\" + match.group(u'char_link') + \"\"\"\">\"\"\" + match.group(u'char_name') + \"\"\"</a>\\n\\t\\t\\t<div class=\"spaceit_pad\"><small>\"\"\" + match.group(u'role') + \"\"\"</small></div>\"\"\"\n  html = re.sub(r\"\"\"<a href=\"/character/(?P<char_link>[^\"]+)\">(?P<char_name>[^<]+)</a>\\n\\t\\t\\t<div class=\"spaceit_pad\"><small>(?P<role>[A-Za-z ]+)</small></div>\\n\\t\\t\\t</div>\"\"\", manga_character_double_closed_div_character, html)\n  return html"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a MAL date on a profile page.", "response": "def parse_profile_date(text, suppress=False):\n  \"\"\"\n    Parses a MAL date on a profile page.\n    May raise ValueError if a malformed date is found.\n    If text is \"Unknown\" or \"?\" or \"Not available\" then returns None.\n    Otherwise, returns a datetime.date object.\n  \"\"\"\n  try:\n    if text == u\"Unknown\" or text == u\"?\" or text == u\"Not available\":\n      return None\n    if text == u\"Now\":\n      return datetime.datetime.now()\n\n    seconds_match = re.match(r'(?P<seconds>[0-9]+) second(s)? ago', text)\n    if seconds_match:\n      return datetime.datetime.now() - datetime.timedelta(seconds=int(seconds_match.group(u'seconds')))\n\n    minutes_match = re.match(r'(?P<minutes>[0-9]+) minute(s)? ago', text)\n    if minutes_match:\n      return datetime.datetime.now() - datetime.timedelta(minutes=int(minutes_match.group(u'minutes')))\n\n    hours_match = re.match(r'(?P<hours>[0-9]+) hour(s)? ago', text)\n    if hours_match:\n      return datetime.datetime.now() - datetime.timedelta(hours=int(hours_match.group(u'hours')))\n\n    today_match = re.match(r'Today, (?P<hour>[0-9]+):(?P<minute>[0-9]+) (?P<am>[APM]+)', text)\n    if today_match:\n      hour = int(today_match.group(u'hour'))\n      minute = int(today_match.group(u'minute'))\n      am = today_match.group(u'am')\n      if am == u'PM' and hour < 12:\n        hour += 12\n      today = datetime.date.today()\n      return datetime.datetime(year=today.year, month=today.month, day=today.day, hour=hour, minute=minute, second=0)\n\n    yesterday_match = re.match(r'Yesterday, (?P<hour>[0-9]+):(?P<minute>[0-9]+) (?P<am>[APM]+)', text)\n    if yesterday_match:\n      hour = int(yesterday_match.group(u'hour'))\n      minute = int(yesterday_match.group(u'minute'))\n      am = yesterday_match.group(u'am')\n      if am == u'PM' and hour < 12:\n        hour += 12\n      yesterday = datetime.date.today() - datetime.timedelta(days=1)\n      return datetime.datetime(year=yesterday.year, month=yesterday.month, day=yesterday.day, hour=hour, minute=minute, second=0)\n\n    try:\n      return datetime.datetime.strptime(text, '%m-%d-%y, %I:%M %p')\n    except ValueError:\n      pass\n    # see if it's a date.\n    try:\n      return datetime.datetime.strptime(text, '%m-%d-%y').date()\n    except ValueError:\n      pass\n    try:\n      return datetime.datetime.strptime(text, '%Y-%m-%d').date()\n    except ValueError:\n      pass\n    try:\n      return datetime.datetime.strptime(text, '%Y-%m-00').date()\n    except ValueError:\n      pass\n    try:\n      return datetime.datetime.strptime(text, '%Y-00-00').date()\n    except ValueError:\n      pass\n    try:\n      return datetime.datetime.strptime(text, '%B %d, %Y').date()\n    except ValueError:\n      pass\n    try:\n      return datetime.datetime.strptime(text, '%b %d, %Y').date()\n    except ValueError:\n      pass\n    try:\n      return datetime.datetime.strptime(text, '%Y').date()\n    except ValueError:\n      pass\n    try:\n      return datetime.datetime.strptime(text, '%b %d, %Y').date()\n    except ValueError:\n      pass\n    # see if it's a month/year pairing.\n    return datetime.datetime.strptime(text, '%b %Y').date()\n  except:\n    if suppress:\n      return None\n    raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the specified xmlglobals dictionary with the specific global tag definitions.", "response": "def _update_globals(kids, xmlglobals):\n    \"\"\"Updates the specified 'xmlglobals' dictionary with the specific\n    *and* supported global tag definitions.\n    \"\"\"\n    for child in kids:\n        key = child.tag.lower()\n        if key != \"defaults\":\n            if key not in xmlglobals:\n                xmlglobals[key] = {}\n            if \"identifier\" in child.attrib:\n                xmlglobals[key][child.attrib[\"identifier\"]] = child\n            elif \"name\" in child.attrib:\n                xmlglobals[key][child.attrib[\"name\"].lower()] = child\n        else:\n            if \"defaults\" not in xmlglobals:\n                xmlglobals[\"defaults\"] = {}\n            xmlglobals[\"defaults\"].update(child.attrib)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the default attributes on all tags that were specified in the global xmlglobals dictionary.", "response": "def _set_global_defaults(xmlglobals):\n    \"\"\"Sets the default attributes on tags that were specified in <global>\n    tags in the XML file.\"\"\"\n    for key, val in xmlglobals.items():\n        if key != \"defaults\":\n            for name, tag in val.items():\n                _update_from_globals(tag, xmlglobals, None)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the specified test tag has attribute ignores ; if it does create a global ignore = true /> tag for each variable in the list.", "response": "def _handle_ignores(testtag):\n    \"\"\"Checks if the specified test tag has attribute \"ignores\"; if it\n    does, a <global ignore=\"true\" /> tag is created for each variable\n    name in the list.\n    \"\"\"\n    if \"ignores\" in testtag.attrib:\n        from xml.etree.ElementTree import Element\n        for varname in re.split(\"[\\s,]+\", testtag.attrib[\"ignores\"]):\n            #For ignored variables, the order does not matter. However,\n            #if the user included the caret, just remove it.\n            if varname[0] == '^':\n                varname = varname[1::]\n            e = Element(\"global\", {\"name\": varname, \"ignore\": \"true\"})\n            testtag.append(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _update_from_globals(xtag, xmlglobals, container):\n    #We also need to perform a globals update on each of the *original* child tags\n    #in the current tag being updated.\n    for child in list(xtag):\n        _update_from_globals(child, xmlglobals, xtag)\n\n    #If the tag doesn't have a value that is in the global defaults\n    #then we automatically copy it over.\n    if \"defaults\" in xmlglobals:\n        #Iterate over the attributes that we have default values for.\n        for key in xmlglobals[\"defaults\"]:\n            if key not in xtag.attrib:\n                overwrite = True\n                #If the key is a limited one, then it only gets copied to\n                #tags that we know can actually use the attribute.\n                if key in limited:\n                    overwrite = (xtag.tag in monitored and key in monitored[xtag.tag])\n                if overwrite:\n                    xtag.attrib[key] = xmlglobals[\"defaults\"][key]\n\n    #For the global tags, we just want to update using the default values\n    #They aren't allowed to reference other globals.\n    if container is None:\n        return                \n                    \n    def update_tag(xtag, gtag):\n        \"\"\"Updates the missing attributes in xtag with those from gtag.\"\"\"\n        for attr, value in gtag.attr.items():\n            if attr not in xtag.attrib:\n                xtag.attr[attr] = value\n                \n    def resolve_global(xtag, xmlglobals, xtagname, gtagname, attrib, container, op, gassumed):\n        \"\"\"Adds the child in xmlglobals with the relevant id to the tag.\n\n        :arg xtag: the tag with the reference to a global tag.\n        :arg xmlglobals: the dictionary of global tags extracted from <global>.\n        :arg tagname: the name of the global tag to look for.\n        :arg attrib: the name of the attribute in 'xtag' that references the\n          global tag to process.\n        :arg container: for \"op\"==\"append\", the XMLElement to append the global\n          tag to as a subelement.\n        :arg op: one of [\"append\", \"update\"]. For \"append\" the global tag is appended\n          as a subelement to 'container'. For \"update\", the attributes of the global\n          tag are copied to 'xtag'.\n        :arg gassumed: when True, the 'attrib' being examined is assumed to reference\n          only tags in <globals>, so no 'global:' prefix is required before attributes.\n        \"\"\"\n        if attrib not in xtag.attrib:\n            return False\n\n        result = False\n        if xtag.tag == xtagname and (gassumed or \"global:\" in xtag.attrib[attrib]):\n            #We allow a ';'-separated list of global tag names, all of\n            #which are appended to the child's subelements list.\n            i = -1\n            for sattr in xtag.attrib[attrib].split(\";\"):\n                gid = sattr.strip().split(\":\")[1] if \":\" in sattr else sattr.strip()\n                #Since ordering matters, if the id starts with ^, we insert it at\n                #the beginning of the subelements list instead of appending\n                if gid[0] == '^':\n                    insert = True\n                    gid = gid[1::]\n                    i += 1\n                else:\n                    insert = False\n                    \n                if gtagname in xmlglobals and gid.lower() in xmlglobals[gtagname]:\n                    gtag = xmlglobals[gtagname][gid.lower()]\n                    if op == \"append\":\n                        if insert:\n                            container.insert(i, gtag)\n                        else:\n                            container.append(gtag)\n                    elif op == \"update\":\n                        update_tag(xtag, gtag)\n                    result = True\n                else:\n                    from fortpy.msg import warn\n                    wstr = 'The global tag of type <{}> for <{} {}=\"{}\"> does not exist.'\n                    warn(wstr.format(gtagname, xtagname, attrib, xtag.attrib[attrib]))\n\n            #Overwrite the name of the tag to not have the 'global:' in it anymore.\n            xtag.attrib[attrib] = xtag.attrib[attrib].replace(\"global:\", \"\")\n\n        return result\n                \n    #Next, we just need to check the attributes of the tag that are allowed\n    #to point to global tag children.\n    i = 0\n    #The order of these is xtagname, gtagname, xtagattrib, container, op, gassumed\n    tags = [(\"assignment\", \"value\", \"value\", xtag, \"append\", False),\n            (\"target\", \"output\", \"compareto\", container, \"append\", False),\n            (\"test\", \"input\", \"inputs\", xtag, \"append\", True),\n            (\"test\", \"global\", \"globals\", xtag, \"append\", True),\n            (\"test\", \"assignment\", \"assignments\", xtag, \"append\", True),\n            (\"test\", \"mapping\", \"mappings\", xtag, \"append\", True),\n            (\"group\", \"input\", \"inputs\", xtag, \"append\", True),\n            (\"group\", \"global\", \"globals\", xtag, \"append\", True),\n            (\"group\", \"assignment\", \"assignments\", xtag, \"append\", True),\n            (\"group\", \"mapping\", \"mappings\", xtag, \"append\", True)]\n\n    while i < len(tags):\n        resolve_global(xtag, xmlglobals, *tags[i])\n        i += 1\n\n    if xtag.tag in [\"test\", \"group\"]:\n        _handle_ignores(xtag)\n\n    if xtag.tag == \"auto\":\n        _expand_autotag(xtag, container)", "response": "Updates the attributes of the specified XML tag using the globals dictionary for those tags that are supported by the specified container."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexpand the contents of the specified auto tag within its parent container.", "response": "def _expand_autotag(atag, container):\n    \"\"\"Expands the contents of the specified auto tag within its parent container.\n    \"\"\"\n    if atag.tag != \"auto\":\n        return\n\n    if \"names\" in atag.attrib:\n        i = -1\n        for name in re.split(\"[\\s,]+\", atag.attrib[\"names\"]):\n            if name[0] == '^':\n                name = name[1::]\n                insert = True\n                i += 1\n            else:\n                insert = False\n                \n            for child in atag:\n                dupe = child.copy()\n                for attr, value in dupe.items():\n                    dupe.attrib[attr] = value.replace(\"$\", name)\n\n                if insert:\n                    container.insert(i, dupe)\n                else:\n                    container.append(dupe)            \n    else:\n        from fortpy.msg import warn\n        warn(\"'names' is a required attribute of the <auto> tag.\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting up the patterns and regex objects for parsing the docstrings.", "response": "def setup_regex(self):\n        \"\"\"Sets up the patterns and regex objects for parsing the docstrings.\"\"\"\n        #Regex for grabbing out valid XML tags that represent known docstrings that we can work with.\n        self.keywords = [ \"summary\", \"usage\", \"errors\", \"member\", \"group\", \"local\", \n                          \"comments\", \"parameter\" ]\n        #Regex for extracting the contents of docstrings minus the !! and any leading spaces.\n        self._RX_DOCS = \"^\\s*!!(?P<docstring>.+?)$\"\n        self.RE_DOCS = re.compile(self._RX_DOCS, re.M)\n        #Regex for handling cross references in the documentation\n        self._RX_REFS = r\"@CREF\\[(?P<reference>[^\\]]+)\\]\"\n        self.RE_REFS = re.compile(self._RX_REFS)\n        #Regex to match first lines of declarations for code elements that can be\n        #decorated by docstrings.\n        self._RX_DECOR = (r\"((?P<type>character|real|type|logical|integer|complex)?\"\n                          r\"(?P<kind>\\([a-z0-9_]+\\))?)?(,?(?P<modifiers>[^\\n]+?))?\"\n                          r\"\\s*(?P<codetype>subroutine|function|type|module|interface)\\s+(?P<name>[^(]+)\")\n        self.RE_DECOR = re.compile(self._RX_DECOR, re.I)\n        #Regex for getting the docstrings decorating one or more modules in a code file,\n        #Since they aren't contained inside any other code element, we can't just use\n        #the normal docblocks routines.\n        self._RX_MODDOCS = (r\"^(?P<docstring>\\s*!!.+?)\\n\\s*module\\s+(?P<name>[A-Za-z0-9_]+)\"\n                            \".+?end\\s+module(\\s+(?P=name))?\")\n        self.RE_MODDOCS = re.compile(self._RX_MODDOCS, re.DOTALL | re.I)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_docs(self, string, container = None):\n        from fortpy.utility import XML\n        result = {}\n        if container is None:\n            #We are working with the code file at the module level. Extract the module\n            #docstrings and XML and return the dictionary with module names as keys.\n            for module in self.RE_MODDOCS.finditer(string):\n                docstring = re.sub(\"\\s*!!\", \"\", module.group(\"docstring\"))\n                doctext = \"<doc>{}</doc>\".format(re.sub(\"\\n\", \"\\s\", docstring))\n                try:\n                    docs = XML(doctext)\n                    #Get the name of the module to use as the key and then add the list\n                    #of XML docstrings to the result.\n                    key = module.group(\"name\")\n                    if not key in result:\n                        result[key] = [list(docs), module.start(), module.end()]\n                    else:\n                        result[key][0].extend(list(docs))\n                except ET.ParseError:\n                    msg.err(doctext)\n        else:\n            #This is the text content of a code element that was buried inside of the module.\n            #Get all the docblocks and the items they decorate from this parent.\n            result = self._parse_docblocks(string, container)\n            \n        return result", "response": "Parses the docstrings from the specified string that is the contents of container."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _process_docgroup(self, group, code_el, add=True):\n        if group.name in code_el.groups and add:\n            msg.warn(\"duplicate group names in code element {}\".format(code_el.name))\n        else:\n            code_el.groups[group.name] = group\n\n        kids = self.to_doc(list(group.xml), group.decorates)\n        for child in kids:\n            child.group = group.name\n\n        return kids", "response": "Processes the group members into a list of docstrings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess the executable s documentation and adds them to the executable s parameters list.", "response": "def process_execdocs(self, docs, anexec, key, add=True):\n        \"\"\"Associates parameter documentation with parameters for the executable\n        and any remaining docs with the executable itself.\n\n         - key: the module.executable identifier for the function or subroutine.\n        \"\"\"\n        #Paramdocs has a list of docstrings for summary, usage, parameters, etc.\n        #check which belong to parameters and associate them, otherwise append\n        #them to the executable.\n        for doc in docs:\n            if doc.doctype == \"parameter\":\n                if doc.pointsto is not None and doc.pointsto in anexec.parameters:\n                    if add:\n                        anexec.parameters[doc.pointsto].docstring.append(doc)\n                    else:\n                        anexec.parameters[doc.pointsto].overwrite_docs(doc)\n                else: \n                    #the parameter docstring is orphaned, give a warning.\n                    wmsg = (\"the docstring for parameter '{}' had no corresponding \"\n                            \"parameter in the executable definition for '{}' ({}).\")\n                    msg.warn(wmsg.format(doc.pointsto, anexec.name, anexec.module.filepath))\n            elif doc.doctype == \"group\":\n                if \"name\" not in doc.attributes:\n                    doc.attributes[\"name\"] = \"default\"\n                kids = self._process_docgroup(doc, anexec)\n                if add:\n                    anexec.docstring.extend(kids)\n                else:\n                    for kid in kids:\n                        anexec.overwrite_docs(kid)\n            else:\n                #The docstring must be for the executable\n                if add:\n                    anexec.docstring.append(doc)\n                else:\n                    anexec.overwrite_docs(doc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_embedded(self, xlist, anexec, add=True):\n        #Keep track of the changes that took place in the lengths of the \n        #docstrings that got added/updated on the elements children.\n        delta = 0\n        for t in anexec.types:\n            key = \"{}.{}\".format(anexec.name, t)\n            if key in xlist:\n                docs = self.to_doc(xlist[key][0], t)\n                self.process_memberdocs(docs, anexec.types[t], add)\n                anexec.types[t].docstart = xlist[key][1]\n                delta += xlist[key][2] - anexec.types[t].docend\n                anexec.types[t].docend = xlist[key][2]\n\n        for iexec in anexec.executables:\n            key = \"{}.{}\".format(anexec.name, iexec)\n            if key in xlist:\n                docs = self.to_doc(xlist[key][0], t)\n                self.process_memberdocs(docs, anexec.executables[iexec], add)\n                anexec.executables[iexec].docstart = xlist[key][1]\n                delta += xlist[key][2] - anexec.executables[iexec].docend\n                anexec.executables[iexec].docend = xlist[key][2]\n\n        if not add:\n            return delta", "response": "Processes the specified xml list and executable to link embedded types and executables to their docstrings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_memberdocs(self, docs, codeEl, add=True):\n        #Now we need to associate the members with their docstrings\n        #Some of the members may be buried inside a group tag and\n        #need to be handled separately.\n        remainingdocs = []\n        expandeddocs = []\n\n        #Process any groups that are in the doc list.\n        for doc in docs:\n            if isinstance(doc, DocGroup):\n                kids = self._process_docgroup(doc, codeEl, add)\n                expandeddocs.extend(kids)\n            else:\n                expandeddocs.append(doc)\n\n        for doc in expandeddocs:\n            #Process the docstring, if it doesn't belong to a member\n            #we will add it to the list of unassigned docstrings,\n            #these most likely point to type declarations.           \n            if not self._process_docstrings(doc, codeEl.members, add):\n                remainingdocs.append(doc)\n        return remainingdocs", "response": "Processes the members of the specified code element and returns a list of docstrings that are associated with the members of the code element."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the docstrings from the list of DocElements to their respective members. Returns True if the doc element belonged to a member.", "response": "def _process_docstrings(self, doc, members, add=True):\n        \"\"\"Adds the docstrings from the list of DocElements to their\n        respective members.\n\n        Returns true if the doc element belonged to a member.\"\"\"\n        if ((doc.doctype == \"member\" or doc.doctype == \"local\") and \n            doc.pointsto is not None and \n            doc.pointsto in members):\n            if add:\n                members[doc.pointsto].docstring.append(doc)\n            else:\n                members[doc.pointsto].overwrite_docs(doc)\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_doc(self, xmllist, decorates):\n        result = []\n        for xitem in xmllist:\n            if xitem.tag != \"group\":\n                #The docstring allows a single string to point to multiple\n                #names in a comma-separated list in the names attribute.\n                if \"name\" in list(xitem.keys()):\n                    names = re.split(\"[\\s,]+\", xitem.get(\"name\"))\n                    for name in names:                        \n                        #Once we have created the DocElement, we need to override\n                        #its name attribute (which will have the comma-separated\n                        #list) with the single name\n                        docel = DocElement(xitem, self, decorates)\n                        docel.attributes[\"name\"] = name\n                        result.append(docel)\n                else:\n                    #This docstring doesn't have a name attribute, just add it\n                    result.append(DocElement(xitem, self, decorates))\n            else:\n                docel = DocGroup(xitem, decorates)\n                result.append(docel)\n        return result", "response": "Converts the specified xml list to a list of docstring elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_docblocks(self, string, container):\n        #The easiest way to do this is to look at one line at a time and see if it is a docstring\n        #When we find a group of docstrings that suddenly ends, the next item is the code element\n        #that they were decorating (which may or may not be pertinent).\n        from fortpy.utility import XML\n        current = []\n        docblocks = {}\n        docstart = 0\n\n        for line in string.split(\"\\n\"):\n            match = self.RE_DOCS.match(line)\n            if match is not None:\n                current.append(match.group(\"docstring\"))\n                if len(current) == 1:\n                    #This was the first docstring of a new documentation block.\n                    docend = docstart + len(line) + 1  # +1 for \\n removed by split()\n                else:\n                    #We already have some docstrings in the block, update start/end\n                    docend += len(line) + 1\n            else:\n                #See if we were previously working on a docstring block or not.\n                if len(current) > 0:\n                    #Save all the current docstrings in the blocks dictionary\n                    #under the name of the code element in this line.\n                    key = self._parse_docline(line, container)\n                    #If the docblock has multiple XML tags at the same depth, the XML\n                    #parser will scream. Wrap everything in a doc tag.\n                    doctext = \"<doc>{}</doc>\".format(\" \".join(current))\n                    try:\n                        #Let the docstart and docend *always* be absolute character references.\n                        tabsstart, tabsend = container.module.absolute_charindex(string, docstart, docend-len(line))\n                        emsg=\"module '{0}' docstring starting @ {1[0]}:{1[1]}\"\n                        emsg=emsg.format(container.module.name, container.module.linenum(tabsstart))\n                        docs = XML(doctext, emsg)\n                        if not key in docblocks:\n                            absstart, absend = tabsstart, tabsend\n                            docblocks[key] = [list(docs), absstart, absend]\n                        else:\n                            docblocks[key][0].extend(list(docs))\n                    except ET.ParseError as err:\n                        msg.err(err.msg)\n\n                    #Reset the list of current docstrings\n                    current = []\n                    docstart = docend + len(line) + 1\n                else:\n                    #We need to keep track of the line lengths for docstart/end.\n                    docstart += len(line) + 1\n\n        return docblocks", "response": "Parses all the docstrings out of the specified string and returns a dictionary of docstrings with the key as parent. code_element_name and the value a list of XML elements that contain docstrings."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a single line of code following a docblock to see if it is a valid code element that can be decorated. If so return the name of the code element.", "response": "def _parse_docline(self, line, container):\n        \"\"\"Parses a single line of code following a docblock to see if\n        it as a valid code element that can be decorated. If so, return\n        the name of the code element.\"\"\"\n        match = self.RE_DECOR.match(line)\n        if match is not None:\n            return \"{}.{}\".format(container.name, match.group(\"name\"))\n        else:\n            return container.name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the docstrings out of the specified xml file.", "response": "def parsexml(self, xmlstring, modules, source=None):\n        \"\"\"Parses the docstrings out of the specified xml file.\n\n        :arg source: the path to the file from which the XML string was extracted.\n        \"\"\"\n        result = {}\n\n        from fortpy.utility import XML_fromstring\n        xmlroot = XML_fromstring(xmlstring, source)\n        if xmlroot.tag == \"fortpy\" and \"mode\" in xmlroot.attrib and \\\n           xmlroot.attrib[\"mode\"] == \"docstring\":\n            #First, cycle through the kids to find the <global> tag (if any\n            #exist). It's children will apply to any of the other tags we find\n            #and we will have to update their attributes accordingly.\n            xmlglobals = {}\n            for child in xmlroot.iterfind(\"globals\"):\n                _update_globals(list(child), xmlglobals)\n            _set_global_defaults(xmlglobals)\n                \n            #We fill the dictionary with decorates names as keys and lists\n            #of the xml docstring elements as values.\n            for child in xmlroot:\n                if child.tag == \"globals\":\n                    continue\n\n                xmltags = []\n                if child.tag == \"decorates\" and \"name\" in child.attrib:\n                    decorates = child.attrib[\"name\"]\n                    xmltags.extend(list(child))\n                elif \"decorates\" in child.attrib:\n                    decorates = child.attrib[\"decorates\"]\n                    xmltags.append(child)\n\n                for xtag in xmltags:\n                    _update_from_globals(xtag, xmlglobals, child)\n\n                if decorates in result:\n                    result[decorates].extend(xmltags)\n                else:\n                    result[decorates] = xmltags\n\n            #Loop through all the docstrings we found and team them up with\n            #their respective module members.\n            self._xml_update_modules(result, modules)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _xml_update_modules(self, xmldict, modules):\n        for kdecor in xmldict:\n            modname, memname = kdecor.split(\".\")\n            if modname in modules:\n                module = modules[modname]\n                #We only need to check the members, types and executables\n                memname = memname.lower()\n                if memname in module.members:\n                    docs = self.to_doc(xmldict[kdecor], modname)\n                    self.process_memberdocs(docs, module)\n                elif memname in module.types:\n                    member = module.types[memname]\n                    docs = self.to_doc(xmldict[kdecor], memname)\n                    member.docstring.extend(docs)\n                elif memname in module.executables:\n                    member = module.executables[memname]\n                    docs = self.to_doc(xmldict[kdecor], memname)\n                    self.process_execdocs(docs, member, kdecor)\n                else:\n                    msg.warn(\"orphaned docstring. No member {} in module {}.\".format(\n                        memname, modname))\n            else:\n                msg.warn(\"orphaned docstring from XML docfile for {}\".format(kdecor))", "response": "Updates the docstrings in the specified modules by looking for the docstrings in the xmldict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rt_update_module(self, xmldict, module):\n        #This keeps track of how many character were added/removed by\n        #updating the docstrings in xmldict.\n        delta = 0\n        for kdecor in xmldict:\n            if \".\" in kdecor:\n                modname, memname = kdecor.split(\".\")\n            else:\n                modname, memname = module.name, None\n\n            if module.name == modname:\n                #This tag is relevant to the specified module. Continue\n                xlist, docstart, docend = xmldict[kdecor]\n\n                #We only need to check the members, types and executables\n                #For executables and types, we need to update the docstart and\n                #docend attributes since their docstrings must come as a single\n                #block immediately preceding the signature, so that our values\n                #from the updater will be correct.\n                if memname in module.types:\n                    member = module.types[memname]\n                    docs = self.to_doc(xlist, memname)\n                    member.docstring = docs\n                    delta += self._rt_update_docindices(member, docstart, docend)\n                elif memname in module.executables:\n                    member = module.executables[memname]\n                    docs = self.to_doc(xlist, memname)\n                    self.process_execdocs(docs, member, kdecor, False)\n                    delta += self._rt_update_docindices(member, docstart, docend)\n                else:\n                    #Since it didn't point to anything else, it must be for the\n                    #members of the module.\n                    docs = self.to_doc(xlist, modname)\n                    self.process_memberdocs(docs, module, False)               \n                \n        return delta", "response": "Updates the members executables and types in the specified module to have the latest docstring information from the xmldict."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the docstart docend start and end attributes for the specified element using the new limits for the docstring.", "response": "def _rt_update_docindices(self, element, docstart, docend):\n        \"\"\"Updates the docstart, docend, start and end attributes for the \n        specified element using the new limits for the docstring.\"\"\"\n        #see how many characters have to be added/removed from the end\n        #of the current doc limits.\n        delta = element.docend - docend\n        element.docstart = docstart\n        element.docend = docend\n        element.start += delta\n        element.end += delta\n\n        return delta"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninvoke before printing out anything. This method should be replaced by or merged to blessings package", "response": "def enter_fullscreen(self):\n        \"\"\"\n        Invoke before printing out anything.\n        This method should be replaced by or merged to blessings package\n        \"\"\"\n        self.term.stream.write(self.term.enter_fullscreen)\n        self.term.stream.write(self.term.hide_cursor)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef exit_fullscreen(self):\n        self.term.stream.write(self.term.exit_fullscreen)\n        self.term.stream.write(self.term.normal_cursor)", "response": "Invoke before printing out anything.\n        This method should be replaced by or merged to blessings package"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef paint(self, tbl):\n        if not isinstance(tbl, Table):\n            logging.error(\"unable to paint table: invalid object\")\n            return False\n\n        self.term.stream.write(self.term.clear)\n\n        self.term.stream.write(str(tbl))\n        return True", "response": "Paint the table on terminal"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the parser for the given key.", "response": "def parser(key = \"default\"):\n    \"\"\"Returns the parser for the given key, (e.g. 'ssh')\"\"\"\n    #Make sure we have a parser for that key. If we don't, then set\n    #one up if we know what parameters to use; otherwise return the\n    #default parser.\n    if key not in _parsers:\n        if key == \"ssh\":\n            _parsers[\"ssh\"] = CodeParser(True, False)\n        else:\n            key = \"default\"\n\n    return _parsers[key]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear_caches(delete_all=False):\n    global _time_caches\n\n    if delete_all:\n        _time_caches = []\n        _parser = { \"default\": CodeParser() }\n    else:\n        # normally just kill the expired entries, not all\n        for tc in _time_caches:\n            # check time_cache for expired entries\n            for key, (t, value) in list(tc.items()):\n                if t < time.time():\n                    # delete expired entries\n                    del tc[key]", "response": "Fortpy caches many things that should be completed after each completion\n    finishes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef time_cache(time_add_setting):\n    def _temp(key_func):\n        dct = {}\n        _time_caches.append(dct)\n\n        def wrapper(optional_callable, *args, **kwargs):\n            key = key_func(*args, **kwargs)\n            value = None\n            if key in dct:\n                expiry, value = dct[key]\n                if expiry > time.time():\n                    return value\n            value = optional_callable()\n            time_add = getattr(settings, time_add_setting)\n            if key is not None:\n                dct[key] = time.time() + time_add, value\n            return value\n        return wrapper\n    return _temp", "response": "A decorator that creates a cache for a node with a specific time add setting."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cache_call_signatures(source, user_pos, stmt):\n    index = user_pos[0] - 1\n    lines = source.splitlines() or ['']\n    if source and source[-1] == '\\n':\n        lines.append('')\n\n    before_cursor = lines[index][:user_pos[1]]\n    other_lines = lines[stmt.start_pos[0]:index]\n    whole = '\\n'.join(other_lines + [before_cursor])\n    before_bracket = re.match(r'.*\\(', whole, re.DOTALL)\n\n    module_path = stmt.get_parent_until().path\n    return None if module_path is None else (module_path, before_bracket, stmt.start_pos)", "response": "This function calculates the cache key for a call signature."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_new_node(self, distance, angle):\n        return Node((cos(-angle)*distance+self.pos[0],\n                     sin(-angle)*distance+self.pos[1]))", "response": "This method creates a new node from an existing node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_node_angle(self, node):\n        return atan2(self.pos[0]-node.pos[0], self.pos[1]-node.pos[1]) - pi / 2", "response": "Get the angle between two nodes relative to the horizont."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the distance between two nodes", "response": "def get_distance(self, node):\n        \"\"\"Get the distance beetween 2 nodes\n\n        Args:\n            node (object): The other node.\n        \"\"\"\n        delta = (node.pos[0]-self.pos[0], node.pos[1]-self.pos[1])\n        return sqrt(delta[0]**2+delta[1]**2)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef move(self, delta):\n        self.pos = (self.pos[0]+delta[0], self.pos[1]+delta[1])", "response": "Moves the node to the new position."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _exec_check_pointers(executable):\n    oparams = []\n    pmembers = {}\n    xassigns = map(lambda x: x.lower().strip(), executable.external_assignments())\n\n    def add_offense(pname, member):\n        \"\"\"Adds the specified member as an offender under the specified parameter.\"\"\"\n        if pname not in oparams:\n            oparams.append(pname)\n        if pname not in pmembers:\n            pmembers[pname] = [member]\n        else:\n            pmembers[pname].append(member)\n\n    def check_buried(executable, pname, member):\n        \"\"\"Checks whether the member has its value changed by one of the dependency\n        subroutines in the executable.\n        \"\"\"\n        for d in executable.dependencies:\n            if pname in d.argnames:\n                pindex = d.argnames.index(pname)\n                dtarget = d.target\n                if dtarget is not None:\n                    mparam = dtarget.ordered_parameters[pindex]\n            \n    for pname, param in executable.parameters.items():\n        if param.direction == \"(out)\" and param.is_custom:\n            utype = param.customtype\n            if utype is None:\n                continue\n            for mname, member in utype.members.items():\n                key = \"{}%{}\".format(pname, mname).lower().strip()\n                if key not in xassigns:\n                    #We also need to check the dependency calls to other, buried subroutines.\n                    compname = \"{}%{}\".format(pname, mname).lower()\n                    if executable.changed(compname) is None:\n                        add_offense(pname, member)\n                    \n    return (oparams, pmembers)", "response": "Checks the specified executable for the pointer condition that not\n    all members of the derived type have their values set."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _type_check_pointers(utype):\n    result = []\n    for mname, member in utype.members.items():\n        if (\"pointer\" in member.modifiers and member.D > 0 and\n            (member.default is None or \"null\" not in member.default)):\n            result.append(member)\n\n    return result", "response": "Checks the user - derived type for non - nullified pointer array declarations\n    in its base definition."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck the modules in the specified code parser to see if they have common but subtle pointer bugs.", "response": "def check_pointers(parser, codedir=None, mfilter=None, recursive=False):\n    \"\"\"Checks the modules in the specified code parser to see if they\n    have common, but subtle, pointer bugs in:\n\n    1. subroutines with a parameter of intent(out) and user-derived type\n      must* set *all* members of that parameter or they will have an\n      *undefined* status.\n    2. pointer-type arrays that are not nullified are set to a valid target\n      will return 'T' when passed to `associated`. Best practice is to nullify\n      pointer arrays in user-derived types as the default value on those types.\n    \n    :arg parser: [fortpy.code.CodeParser] with the modules to search *already loaded*.\n    :arg codedir: specify the full path to the library whose modules should be searched,\n      just another way to filter which modules are generating the warnings.\n    :arg mfilter: filter to apply to module names; can use the wildcard standard\n      from bash.\n    \"\"\"\n    from fnmatch import fnmatch\n    from fortpy.msg import std, set_verbosity, info\n\n    set_verbosity(0)\n    W1 = \"   {} '{}' does not set the value of members '{}' in parameter '{}'.\"\n    W2 = \"   Type '{}' does not nullify members '{}' on creation.\"\n\n    offenders = {}\n    for (modname, module) in parser.modules.items():\n        if not recursive and codedir is not None and not codedir.lower() in module.filepath.lower():\n            continue\n        if mfilter is not None and not fnmatch(module.name.lower(), mfilter.lower()):\n            continue\n\n        #Test the first condition above for all subroutines in the module; also handle\n        #the recursively defined subroutines.\n        hprinted = False\n        for xname, xvalue in module.executables.items():\n            oparams, pmembers = _exec_check_pointers(xvalue)\n            if len(oparams) > 0:\n                if not hprinted:\n                    info(\"Best practice suggestions: {}\".format(module.filepath))\n                    hprinted = True\n                    \n                for oparam in oparams:\n                    plist = ', '.join([p.name for p in pmembers[oparam]])                \n                    std(W1.format(type(xvalue).__name__, xname, plist, oparam), 0)\n                offenders[xvalue.full_name] = (oparams, pmembers)\n\n        for tname, tvalue in module.types.items():\n            result = _type_check_pointers(tvalue)\n            if len(result) > 0:\n                if not hprinted:\n                    info(\"Best practice suggestions: {}\".format(module.filepath))\n                    hprinted = True\n\n                plist = ', '.join([p.name for p in result])\n                std(W2.format(tname, plist), 0)            \n                offenders[xvalue.full_name] = result\n\n    return offenders"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef status_schedule(token):\n\n    url = 'https://app.hydrawise.com/api/v1/statusschedule.php'\n\n    payload = {\n        'api_key': token,\n        'hours': 168}\n\n    get_response = requests.get(url, params=payload, timeout=REQUESTS_TIMEOUT)\n\n    if get_response.status_code == 200 and \\\n       'error_msg' not in get_response.json():\n        return get_response.json()\n\n    return None", "response": "Returns the json string from the Hydrawise server after calling\n    statusschedule. php."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_zones(token, action, relay=None, time=None):\n    # Actions must be one from this list.\n    action_list = [\n        'run',        # Run a zone for an amount of time.\n        'runall',     # Run all zones for an amount of time.\n        'stop',       # Stop a zone.\n        'stopall',    # stop all zones.\n        'suspend',    # Suspend a zone for an amount of time.\n        'suspendall'  # Suspend all zones.\n    ]\n\n    # Was a valid action specified?\n    if action not in action_list:\n        return None\n\n    # Set the relay id if we are operating on a single relay.\n    if action in ['runall', 'stopall', 'suspendall']:\n        if relay is not None:\n            return None\n        else:\n            relay_cmd = ''\n    else:\n        relay_cmd = '&relay_id={}'.format(relay)\n\n    # Add a time argument if the action requires it.\n    if action in ['run', 'runall', 'suspend', 'suspendall']:\n        if time is None:\n            return None\n        else:\n            custom_cmd = '&custom={}'.format(time)\n            period_cmd = '&period_id=999'\n    else:\n        custom_cmd = ''\n        period_cmd = ''\n\n    # If action is on a single relay then make sure a relay is specified.\n    if action in ['stop', 'run', 'suspend'] and relay is None:\n        return None\n\n    get_response = requests.get('https://app.hydrawise.com/api/v1/'\n                                'setzone.php?'\n                                '&api_key={}'\n                                '&action={}{}{}{}'\n                                .format(token,\n                                        action,\n                                        relay_cmd,\n                                        period_cmd,\n                                        custom_cmd),\n                                timeout=REQUESTS_TIMEOUT)\n\n    if get_response.status_code == 200 and \\\n       'error_msg' not in get_response.json():\n        return get_response.json()\n\n    return None", "response": "Sets the zones on and off for the specified action."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_status(modeladmin, request, queryset, status):\n    # We loop over the objects here rather than use queryset.update() for\n    # two reasons:\n    #\n    #  1. No one should ever be updating zillions of Topics or Questions, so\n    #     performance is not an issue.\n    #  2. To be tidy, we want to log what the user has done.\n    #\n    for obj in queryset:\n        obj.status = status\n        obj.save()\n        # Now log what happened.\n        # Use ugettext_noop() 'cause this is going straight into the db.\n        log_message = ugettext_noop(u'Changed status to \\'%s\\'.' %\n            obj.get_status_display())\n        modeladmin.log_change(request, obj, log_message)\n\n    # Send a message to the user telling them what has happened.\n    message_dict = {\n        'count': queryset.count(),\n        'object': modeladmin.model._meta.verbose_name,\n        'verb': dict(STATUS_CHOICES)[status],\n    }\n    if not message_dict['count'] == 1:\n        message_dict['object'] = modeladmin.model._meta.verbose_name_plural\n    user_message = ungettext(\n        u'%(count)s %(object)s was successfully %(verb)s.',\n        u'%(count)s  %(object)s were successfully %(verb)s.',\n        message_dict['count']) % message_dict\n    modeladmin.message_user(request, user_message)\n\n    # Return None to display the change list page again and allow the user\n    # to reload the page without getting that nasty \"Send the form again ...\"\n    # warning from their browser.\n    return None", "response": "The workhorse function for the admin action functions that follow."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the dependency calls from the specified executable instance to the results dictionary.", "response": "def _exec_callers(xinst, result):\n    \"\"\"Adds the dependency calls from the specified executable instance\n    to the results dictionary.\n    \"\"\"\n    for depkey, depval in xinst.dependencies.items():\n        if depval.target is not None:\n            if depval.target.name in result:\n                if xinst not in result[depval.target.name]:\n                    result[depval.target.name].append(xinst)\n            else:\n                result[depval.target.name] = [xinst]\n\n    for xname, xvalue in xinst.executables:\n        _exec_callers(xvalue, result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _module_callers(parser, modname, result):\n    if modname in result:\n        #We have already processed this module.\n        return\n    \n    module = parser.get(modname)\n    mresult = {}\n    if module is not None:\n        for xname, xinst in module.executables():\n            _exec_callers(xinst, mresult)\n        result[modname] = mresult\n        \n        for depkey in module.dependencies:\n            depmod = depkey.split('.')[0].lower()\n            _module_callers(parser, depmod, result)", "response": "Adds any calls to executables contained in the specified module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a list of callees to the branch for each parent of the executable.", "response": "def _call_fan(branch, calls, executable):\n    \"\"\"Appends a list of callees to the branch for each parent\n    in the call list that calls this executable.\n    \"\"\"\n    #Since we don't keep track of the specific logic in the executables\n    #it is possible that we could get a infinite recursion of executables\n    #that keep calling each other.\n    if executable in branch:\n        return\n    branch.append(executable)\n    \n    if executable.name in calls:\n        for caller in calls[executable.name]:\n            twig = []\n            _call_fan(twig, calls, caller)\n            branch"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef topic_detail(request, slug):\n    extra_context = {\n        'question_list': Question.objects.published().filter(topic__slug=slug),\n    }\n\n    return object_detail(request, queryset=Topic.objects.published(),\n        extra_context=extra_context, template_object_name='topic', slug=slug)", "response": "A detail view of a Topic."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the full docstring information for the suggested as a completion.", "response": "def description(self):\n        \"\"\"Returns the full docstring information for the element suggested \n        as a completion.\"\"\"\n        result = \"\"\n        if isinstance(self._element, ValueElement):\n            if self._element.kind is not None:\n                result = \"{}({}) | {}\".format(self._element.dtype, self._element.kind,\n                                          self._element.summary)\n            else:\n                result = \"{} | {}\".format(self._element.dtype,\n                                          self._element.summary)\n        elif isinstance(self._element, Executable):\n            result = \"({})\".format(self._element.parameters_as_string())\n        elif isinstance(self._element, str):\n            result = \"Intrinsic Fortran Symbol\"\n        elif isinstance(self._element, TypeExecutable):\n            result = self._type_description()\n\n        #Clean off any line breaks from the XML and excessive whitespace.\n        cleaned = re.sub(\"\\s+\", \" \", result.replace(\"\\n\", \" \"))\n        return cleaned"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef params(self):\n        if self.context.el_type in [Function, Subroutine]:\n            return self.evaluator.element.parameters", "response": "Returns a list of ValueElement that represents the parameters of the current element."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef name(self):\n        if hasattr(self._element, \"name\"):\n            return self._element.name\n        else:\n            return str(self._element)", "response": "Returns the name of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _type_description(self):\n        #This is a little tricker because the docstring is housed\n        #inside of the module that contains the actual executable.\n        #These TypeExecutables are just pointers.\n        iexec = self._element.target\n        if iexec is not None:\n            result = \"method() | \" + iexec.summary\n        else:\n            result = \"Type Method: points to executable in module.\"    \n        return result", "response": "Gets the completion description for a TypeExecutable."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the DOM and returns anime attributes in the sidebar.", "response": "def parse_sidebar(self, anime_page):\n    \"\"\"Parses the DOM and returns anime attributes in the sidebar.\n\n    :type anime_page: :class:`bs4.BeautifulSoup`\n    :param anime_page: MAL anime page's DOM\n\n    :rtype: dict\n    :return: anime attributes\n\n    :raises: :class:`.InvalidAnimeError`, :class:`.MalformedAnimePageError`\n    \"\"\"\n    # if MAL says the series doesn't exist, raise an InvalidAnimeError.\n    error_tag = anime_page.find(u'div', {'class': 'badresult'})\n    if error_tag:\n        raise InvalidAnimeError(self.id)\n\n    title_tag = anime_page.find(u'div', {'id': 'contentWrapper'}).find(u'h1')\n    if not title_tag.find(u'div'):\n      # otherwise, raise a MalformedAnimePageError.\n      raise MalformedAnimePageError(self.id, anime_page, message=\"Could not find title div\")\n\n    anime_info = super(Anime, self).parse_sidebar(anime_page)\n    info_panel_first = anime_page.find(u'div', {'id': 'content'}).find(u'table').find(u'td')\n\n    try:\n      episode_tag = info_panel_first.find(text=u'Episodes:').parent.parent\n      utilities.extract_tags(episode_tag.find_all(u'span', {'class': 'dark_text'}))\n      anime_info[u'episodes'] = int(episode_tag.text.strip()) if episode_tag.text.strip() != 'Unknown' else 0\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      aired_tag = info_panel_first.find(text=u'Aired:').parent.parent\n      utilities.extract_tags(aired_tag.find_all(u'span', {'class': 'dark_text'}))\n      aired_parts = aired_tag.text.strip().split(u' to ')\n      if len(aired_parts) == 1:\n        # this aired once.\n        try:\n          aired_date = utilities.parse_profile_date(aired_parts[0], suppress=self.session.suppress_parse_exceptions)\n        except ValueError:\n          raise MalformedAnimePageError(self.id, aired_parts[0], message=\"Could not parse single air date\")\n        anime_info[u'aired'] = (aired_date,)\n      else:\n        # two airing dates.\n        try:\n          air_start = utilities.parse_profile_date(aired_parts[0], suppress=self.session.suppress_parse_exceptions)\n        except ValueError:\n          raise MalformedAnimePageError(self.id, aired_parts[0], message=\"Could not parse first of two air dates\")\n        try:\n          air_end = utilities.parse_profile_date(aired_parts[1], suppress=self.session.suppress_parse_exceptions)\n        except ValueError:\n          raise MalformedAnimePageError(self.id, aired_parts[1], message=\"Could not parse second of two air dates\")\n        anime_info[u'aired'] = (air_start, air_end)\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      producers_tag = info_panel_first.find(text=u'Producers:').parent.parent\n      utilities.extract_tags(producers_tag.find_all(u'span', {'class': 'dark_text'}))\n      utilities.extract_tags(producers_tag.find_all(u'sup'))\n      anime_info[u'producers'] = []\n      for producer_link in producers_tag.find_all('a'):\n        if producer_link.text == u'add some':\n          # MAL is saying \"None found, add some\".\n          break\n        link_parts = producer_link.get('href').split('p=')\n        # of the form: /anime.php?p=14\n        if len(link_parts) > 1:\n          anime_info[u'producers'].append(self.session.producer(int(link_parts[1])).set({'name': producer_link.text}))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      duration_tag = info_panel_first.find(text=u'Duration:').parent.parent\n      utilities.extract_tags(duration_tag.find_all(u'span', {'class': 'dark_text'}))\n      anime_info[u'duration'] = duration_tag.text.strip()\n      duration_parts = [part.strip() for part in anime_info[u'duration'].split(u'.')]\n      duration_mins = 0\n      for part in duration_parts:\n        part_match = re.match(u'(?P<num>[0-9]+)', part)\n        if not part_match:\n          continue\n        part_volume = int(part_match.group(u'num'))\n        if part.endswith(u'hr'):\n          duration_mins += part_volume * 60\n        elif part.endswith(u'min'):\n          duration_mins += part_volume\n      anime_info[u'duration'] = datetime.timedelta(minutes=duration_mins)\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      rating_tag = info_panel_first.find(text=u'Rating:').parent.parent\n      utilities.extract_tags(rating_tag.find_all(u'span', {'class': 'dark_text'}))\n      anime_info[u'rating'] = rating_tag.text.strip()\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    return anime_info"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the DOM and returns anime character attributes in the sidebar.", "response": "def parse_characters(self, character_page):\n    \"\"\"Parses the DOM and returns anime character attributes in the sidebar.\n\n    :type character_page: :class:`bs4.BeautifulSoup`\n    :param character_page: MAL anime character page's DOM\n\n    :rtype: dict\n    :return: anime character attributes\n\n    :raises: :class:`.InvalidAnimeError`, :class:`.MalformedAnimePageError`\n\n    \"\"\"\n    anime_info = self.parse_sidebar(character_page)\n\n    try:\n      character_title = filter(lambda x: 'Characters & Voice Actors' in x.text, character_page.find_all(u'h2'))\n      anime_info[u'characters'] = {}\n      anime_info[u'voice_actors'] = {}\n      if character_title:\n        character_title = character_title[0]\n        curr_elt = character_title.nextSibling\n        while True:\n          if curr_elt.name != u'table':\n            break\n          curr_row = curr_elt.find(u'tr')\n          # character in second col, VAs in third.\n          (_, character_col, va_col) = curr_row.find_all(u'td', recursive=False)\n\n          character_link = character_col.find(u'a')\n          character_name = ' '.join(reversed(character_link.text.split(u', ')))\n          link_parts = character_link.get(u'href').split(u'/')\n          # of the form /character/7373/Holo\n          character = self.session.character(int(link_parts[2])).set({'name': character_name})\n          role = character_col.find(u'small').text\n          character_entry = {'role': role, 'voice_actors': {}}\n\n          va_table = va_col.find(u'table')\n          if va_table:\n            for row in va_table.find_all(u'tr'):\n              va_info_cols = row.find_all(u'td')\n              if not va_info_cols:\n                # don't ask me why MAL has an extra blank table row i don't know!!!\n                continue\n              va_info_col = va_info_cols[0]\n              va_link = va_info_col.find(u'a')\n              if va_link:\n                va_name = ' '.join(reversed(va_link.text.split(u', ')))\n                link_parts = va_link.get(u'href').split(u'/')\n                # of the form /people/70/Ami_Koshimizu\n                person = self.session.person(int(link_parts[2])).set({'name': va_name})\n                language = va_info_col.find(u'small').text\n                anime_info[u'voice_actors'][person] = {'role': role, 'character': character, 'language': language}\n                character_entry[u'voice_actors'][person] = language\n          anime_info[u'characters'][character] = character_entry\n          curr_elt = curr_elt.nextSibling\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n\n    try:\n      staff_title = filter(lambda x: 'Staff' in x.text, character_page.find_all(u'h2'))\n      anime_info[u'staff'] = {}\n      if staff_title:\n        staff_title = staff_title[0]\n        staff_table = staff_title.nextSibling.nextSibling\n        for row in staff_table.find_all(u'tr'):\n          # staff info in second col.\n          info = row.find_all(u'td')[1]\n          staff_link = info.find(u'a')\n          staff_name = ' '.join(reversed(staff_link.text.split(u', ')))\n          link_parts = staff_link.get(u'href').split(u'/')\n          # of the form /people/1870/Miyazaki_Hayao\n          person = self.session.person(int(link_parts[2])).set({'name': staff_name})\n          # staff role(s).\n          anime_info[u'staff'][person] = set(info.find(u'small').text.split(u', '))\n    except:\n      if not self.session.suppress_parse_exceptions:\n        raise\n    \n    return anime_info"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef overwrite_docs(self, doc):\n        for i in range(len(self.docstring)):\n            if (self.docstring[i].doctype == doc.doctype and\n                self.docstring[i].pointsto == doc.pointsto):\n                del self.docstring[i]\n                break\n\n        self.docstring.append(doc)", "response": "Adds the specified DocElement to the docstring list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unpickle_docs(self):\n        for doc in self.docstring:\n            if (doc.parent_name is not None and \n                doc.parent_name in self.groups):\n                doc.group = self.groups[doc.parent_name]", "response": "Sets the pointers for the docstrings that have groups."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the absolute start of the element by including docstrings if applicable.", "response": "def absstart(self):\n        \"\"\"Returns the absolute start of the element by including docstrings\n        outside of the element definition if applicable.\"\"\"\n        if hasattr(self, \"docstart\") and self.docstart > 0:\n            return self.docstart\n        else:\n            return self.start"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the module that this code element belongs to.", "response": "def module(self):\n        \"\"\"Returns the module that this code element belongs to.\"\"\"\n        if self._module is None:\n            root = self\n            while self._module is None and root is not None:\n                if isinstance(root, Module):\n                    self._module = root\n                else:\n                    root = root.parent\n\n        return self._module"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef summary(self):\n        if self._summary is None:\n            self._summary = \"No summary for element.\"\n            for doc in self.docstring:\n                if doc.doctype == \"summary\":\n                    self._summary = doc.contents\n                    break\n\n            #If a parameter, member or local tag has dimensions or other children,\n            #then the inner-text is not the right thing to use; find a grand-child\n            #summary tag instead.\n            if self._summary == \"No summary for element.\" and len(self.docstring) > 0:\n                summary = self.doc_children(\"summary\")\n                if len(summary) > 0:\n                    self._summary = summary[0].contents\n                else:\n                    self._summary = self.docstring[0].contents\n\n        return self._summary", "response": "Returns the docstring summary for the code element if it exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef full_name(self):\n        if self._full_name is None:\n            ancestors = [ self.name ]\n            current = self.parent\n            while current is not None and type(current).__name__ != \"CodeParser\":\n                ancestors.append(current.name)\n                current = current.parent\n\n            self._full_name = \".\".join(reversed(ancestors))\n        \n        return self._full_name", "response": "Returns the full name of this element by visiting every\n            non - None parent in its ancestor chain."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef doc_children(self, doctype, limiters=[]):\n        result = []\n        for doc in self.docstring:\n            if len(limiters) == 0 or doc.doctype in limiters:\n                result.extend(doc.children(doctype))\n\n        return result", "response": "Finds all grand - children of this element s docstrings that match\n        the specified doctype."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef warn(self, collection):\n        if not self.has_docstring():\n            collection.append(\"WARNING: no docstring on code element {}\".format(self.name))", "response": "Checks this code element for documentation related problems."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if the two ValueElements are equal only by name dtype default value or some other inconsequential modifier.", "response": "def matched(self, other):\n        \"\"\"Returns True if the two ValueElement instances differ only by name,\n        default value or some other inconsequential modifier.\n        \"\"\"\n        mods = [\"allocatable\", \"pointer\"]\n        return (self.kind.lower() == other.kind.lower() and\n                self.dtype.lower() == other.dtype.lower() and\n                self.D == other.D and\n                all([m in other.modifiers for m in self.modifiers if m in mods]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef strtype(self):\n        if self.kind is not None:\n            return \"{}({})\".format(self.dtype, self.kind)\n        else:\n            return self.dtype", "response": "Returns a string representing the type and kind of this value element."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a formatted name for the ctypes Fortran wrapper module.", "response": "def _get_ctypes_name(self, index=None):\n        \"\"\"Returns a formatted name for the ctypes Fortran wrapper module.\n\n        :arg index: the index of the array to return a name for. None for the new parameter,\n          otherwise the index for the integer variable name of that dimension.\n        \"\"\"\n        if index is None:\n            if (\"allocatable\" not in self.modifiers and \"pointer\" not in self.modifiers\n                and self.dtype != \"logical\"):\n                #The fortan logical has type 4 by default, whereas c_bool only has 1\n                return self.name\n            else:\n                return \"{}_c\".format(self.name)\n        else:\n            return \"{0}_{1:d}_c\".format(self.name, index)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ctypes_parameter(self):\n        if self._ctypes_parameter is None:\n            #Essentially, we just need to check if we are an array that doesn't have explicitly\n            #defined bounds. Assumed-shape arrays have to be 'pointer' or 'allocatable'. However,\n            #the deffered/assumed shape arrays always use ':' as the array dimension.\n            if self.dimension is not None and \":\" in self.dimension:\n                result = [self._get_ctypes_name()]\n                result.extend([self._get_ctypes_name(i+1) for i in range(self.D)])\n                if self.direction == \"(inout)\" and (\"allocatable\" in self.modifiers or\n                                                    \"pointer\" in self.modifiers):\n                    result.append(\"{}_o\".format(self.name))\n                self._ctypes_parameter = result\n            elif self.dtype == \"logical\":\n                self._ctypes_parameter = [self._get_ctypes_name()]\n            elif hasattr(self, \"parameters\"):\n                #This is the handler for the function return types that are simple\n                self._ctypes_parameter = [self.name + \"_f\"]\n            else:\n                #Nothing special, just return the standard name.\n                self._ctypes_parameter = [self.name]\n\n        return self._ctypes_parameter", "response": "Returns the list of ctypes parameter names for this ValueElement adjusted for interoperability\n            with the ctypes module."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the direction of the variable if it is a parameter. Possible values are [ in out ) no intent. Possible values are [ in out ) no intent. Possible values are [ out ) no intent. Possible values are [ in out ) no intent.", "response": "def direction(self):\n        \"\"\"Returns the direction of the variable if it is a parameter. Possible values\n        are [\"\": no intent, \"(in)\", \"(out)\", \"(inout)\"].\n        \"\"\"\n        if self._direction is None:\n            if hasattr(self, \"parameters\"):\n                #This is actually a function that inherited from ValueElement, it is always\n                #intent(out) for our purposes.\n                self._direction = \"(out)\"\n            else:\n                intent = [m for m in self.modifiers if \"intent\" in m]\n                if len(intent) > 0:\n                    self._direction = intent[0].replace(\"intent\", \"\").strip()\n                else:\n                    self._direction = \"\"\n\n        return self._direction"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the fortran code string that would define this value element.", "response": "def definition(self, suffix = \"\", local=False, ctype=None, optionals=True,\n                   customdim=None, modifiers=None):\n        \"\"\"Returns the fortran code string that would define this value element.\n\n        :arg suffix: an optional suffix to append to the name of the variable.\n          Useful for re-using definitions with new names.\n        :arg local: when True, the parameter definition is re-cast as a local\n          variable definition that has the \"intent\" and \"optional\" modifiers removed.\n        :arg ctype: if a ctype should be used as the data type of the variable\n          instead of the original type, specify that string here.\n        :arg optionals: removes the \"optional\" modifier from the definition before\n          generating it.\n        :arg customdim: if the dimension string needs to be changed, specify the\n          new one here.\n        :arg modifiers: specify an additional list of modifiers to add to the\n          variable definition.\n        \"\"\"\n        kind = \"({})\".format(self.kind) if self.kind is not None else \"\"   \n        cleanmods = [m for m in self.modifiers if m != \"\" and m != \" \"\n                     and not (local and (\"intent\" in m or m == \"optional\"))\n                     and not (not optionals and m == \"optional\")]\n        if modifiers is not None:\n            cleanmods.extend(modifiers)\n        if len(cleanmods) > 0:\n            mods = \", \" + \", \".join(cleanmods) + \" \" \n        else:\n            mods = \" \"\n        if customdim is not None:\n            dimension = \"({})\".format(customdim)\n        else:\n            dimension = \"({})\".format(self.dimension) if self.dimension is not None else \"\"\n\n        if self.default is None:\n            default = \"\"\n        else:\n            if \">\" in self.default: #We have a pointer, don't add an extra space.\n                default = \" ={}\".format(self.default) if self.default is not None else \"\"\n            else:\n                default = \" = {}\".format(self.default) if self.default is not None else \"\"\n        name = \"{}{}\".format(self.name, suffix)\n        stype = self.dtype if ctype is None else ctype\n        return \"{}{}{}:: {}{}{}\".format(stype, kind, mods, name, dimension, default)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the ctypes argtypes for use with the method. argtypes assignment for the ctypes object.", "response": "def argtypes(self):\n        \"\"\"Returns the ctypes argtypes for use with the method.argtypes assignment for\n        an executable loaded from a shared library.\n        \"\"\"\n        if self.dimension is not None:\n            result = []\n            if \"in\" in self.direction:\n                #The only complication here is that the 'known' dimensionality could actually\n                #be a function like \"size\" that needs information about other variables.\n                #If we choose to ignore known shapes, we lose the error checking for the passed\n                #in variables from the python side.\n                if self.direction == \"(inout)\" and \":\" not in self.dimension:\n                    wstr = \", writeable\"\n                else:\n                    wstr = \"\"\n\n                if \":\" in self.dimension or \"size\" in self.dimension:\n                    template = 'ndpointer(dtype={}, ndim={}, flags=\"F{}\")'\n                    result.append(template.format(self.pytype, self.D, wstr))\n                else:\n                    template = 'ndpointer(dtype={}, ndim={}, shape=({}), flags=\"F{}\")'\n                    sdim = self.dimension + (\"\" if self.D > 1 else \",\")\n                    result.append(template.format(self.pytype, self.D, sdim, wstr))\n            elif self.direction == \"(out)\":\n                result.append(\"c_void_p\")\n\n            if self.D > 0 and \":\" in self.dimension:\n                result.extend([\"c_int_p\" for i in range(self.D)])\n            if (self.direction == \"(inout)\" and \":\" in self.dimension and\n                (\"allocatable\" in self.modifiers or \"pointer\" in self.modifiers)):\n                result.append(\"c_void_p\")\n            return result\n        else:\n            ctype = self.ctype\n            if ctype is not None:\n                return [\"{}_p\".format(ctype.lower())]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the name of the c_type from the iso_c_binding to use when declaring the output parameter for interaction with python ctypes.", "response": "def ctype(self):\n        \"\"\"Returns the name of the c_type from iso_c_binding to use when declaring\n        the output parameter for interaction with python ctypes.\n        \"\"\"\n        if self.dtype == \"logical\":\n            return \"C_BOOL\"\n        elif self.dtype == \"complex\":\n            #We don't actually know what the precision of the complex numbers is because\n            #it is defined by the developer when they construct the number with CMPLX()\n            #We just return double to be safe; it is a widening conversion, so there\n            #shouldn't be any issues.\n            return \"C_DOUBLE_COMPLEX\"\n        elif self.dtype == \"character\":\n            return \"C_CHAR\"\n        elif self.dtype in [\"integer\", \"real\"]:\n            if self.kind is None:\n                if self.dtype == \"integer\":\n                    return \"C_INT\"\n                else:\n                    return \"C_FLOAT\"\n                \n            if self._kind_module is None and self.kind is not None:\n                self.dependency()\n            if self._kind_module is None and self.kind is not None:\n                raise ValueError(\"Can't find the c-type for {}\".format(self.definition()))\n            elif self._kind_module is not None:\n                #We look up the parameter in the kind module to find out its\n                #precision etc.\n                import re\n                default = self._kind_module.members[self.kind].default\n                vals = default.split(\"(\")[1].replace(\")\", \"\")\n                ints = list(map(int, re.split(\",\\s*\", vals)))\n                if self.dtype == \"integer\" and len(ints) == 1:\n                    if ints[0] <= 15:\n                        return \"C_SHORT\"\n                    elif ints[0] <= 31:\n                        return \"C_INT\"\n                    elif ints[0] <= 63:\n                        return \"C_LONG\"\n                elif self.dtype == \"real\" and len(ints) == 2:\n                    if ints[0] <= 24 and ints[1] < 127:\n                        return \"C_FLOAT\"\n                    elif ints[0] <= 53 and ints[1] < 1023:\n                        return \"C_DOUBLE\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dependency(self):\n        from re import match\n        if self._kind_module is not None:\n            #We have already done this search at some point.\n            return self._kind_module.name\n\n        if (self.kind is not None and \"len=\" not in self.kind.lower()\n            and not match(\"\\d\", self.kind[0])):\n            #Find the module that declares this kind as:\n            # 1) derived type\n            # 2) parameter/member\n            #The good news is that in order for the module being unit tested to compile,\n            #it must have a 'use' statement for the derived type. We can just search from\n            #that module with a tree find. Also, at the end of the day, it will have to\n            #be declared as public, in order to be used in other modules.\n            found, foundmod = self.module.parent.tree_find(self.kind.lower(),\n                                                           self.module,\n                                                           \"publics\")\n            self._kind_module = foundmod #At worst this will be None again\n            if found is not None:\n                return foundmod.name", "response": "Returns the module name from the code parser that this parameter or variable\n            needs to compile successfully."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef customtype(self):\n        result = None\n        if self.is_custom:\n            #Look for the module that declares this variable's kind in its public list.\n            self.dependency()\n            if self._kind_module is not None:\n                if self.kind.lower() in self._kind_module.types:\n                    result = self._kind_module.types[self.kind.lower()]\n\n        return result", "response": "Returns the CustomType instance that represents this variable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef external_name(self):\n        target = self.target\n        if target is not None:\n            return \"{}.{}\".format(target.name.lower(), self.name)\n        else:\n            return \"{}.{}\".format(self.module.name.lower(), self.name)", "response": "Returns the modulename. executable string that uniquely identifies\n        the executable that this dependency points to."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the executable code element that this dependency points to if it can be found.", "response": "def target(self):\n        \"\"\"Returns the executable code element that this dependency points to\n        if it can be found.\n        \"\"\"\n        if self._target is None:\n            if '%' in self.name:\n                parts = self.name.split('%')\n                base = self.module.parent.type_search(parts[0], self.name, self.module)\n                if base is not None:\n                    self._target = base.target\n                else:\n                    self._target = False\n            else:\n                found, foundmod = self.module.parent.tree_find(self.name, self.module, \"executables\")\n                if found is not None:\n                    self._target = found\n                else:\n                    self._target = False\n\n        if isinstance(self._target, Executable):\n            return self._target\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a value indicating whether the specified character index is owned by the current object.", "response": "def find_section(self, charindex):\n        \"\"\"Returns a value indicating whether the specified character index\n        is owned by the current object.\"\"\"\n        #All objects instances of decorable also inherit from CodeElement,\n        #so we should have no problem accessing the start and end attributes.\n        result = None\n        if hasattr(self, \"start\") and hasattr(self, \"end\"):\n            #The 8 seems arbitrary, but it is the length of type::b\\n for a\n            #really short type declaration with one character name.\n            if charindex > self.docend and charindex - self.start < 8:\n                result = \"signature\"\n            elif charindex >= self.start and charindex <= self.end:\n                result = \"body\"\n\n        if (result is None and charindex >= self.docstart \n            and charindex <= self.docend):\n            result = \"docstring\"\n            \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of modules that this executable needs in order to run properly.", "response": "def search_dependencies(self):\n        \"\"\"Returns a list of modules that this executable needs in order to run\n        properly. This includes special kind declarations for precision or derived\n        types, but not dependency executable calls.\n        \"\"\"\n        #It is understood that this executable's module is obviously required. Just\n        #add any additional modules from the parameters.\n        result = [p.dependency() for p in self.ordered_parameters]\n        result.extend([v.dependency() for k, v in list(self.members.items())])\n        for ekey, anexec in list(self.executables.items()):\n            result.extend(anexec.search_dependencies())\n        return [m for m in result if m is not None and m != self.module.name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the parent pointer references for the module and all of its child classes that also have pointer references.", "response": "def unpickle(self, parent):\n        \"\"\"Sets the parent pointer references for the module *and* all of its\n        child classes that also have pointer references.\"\"\"\n        self.parent = parent\n        self._unpickle_collection(self.members)\n        self._unpickle_collection(self.dependencies)\n        self._unpickle_collection(self.types)\n        self._unpickle_collection(self.executables)\n        self._unpickle_collection(self._parameters)\n        self.unpickle_docs()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _unpickle_collection(self, collection):\n        for mkey in collection:\n            if isinstance(collection[mkey], list):\n                for item in collection[mkey]:\n                    item.unpickle(self)\n            else:\n                collection[mkey].unpickle(self)", "response": "Unpickles all members of the specified dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rt_update(self, statement, linenum, mode, xparser):\n        section = self.find_section(self.module.charindex(linenum, 1))\n\n        if section == \"body\":\n            xparser.parse_line(statement, self, mode)\n        elif section == \"signature\":\n            if mode == \"insert\":\n                xparser.parse_signature(statement, self)", "response": "Uses the specified line parser to parse the given line."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_name(self, name):\n        if name != self.name:\n            self.parent.executables[name] = self\n            del self.parent.executables[self.name]\n            self.name = name", "response": "Changes the name of this executable and the reference to it in the parent module."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if this executable is an embedded procedure in a custom type declaration ; else False.", "response": "def is_type_target(self):\n        \"\"\"Returns the CustomType instance if this executable is an embedded \n        procedure in a custom type declaration; else False.\n        \"\"\"\n        if self._is_type_target is None:\n            #All we need to do is search through the custom types in the parent\n            #module and see if any of their executables points to this method.\n            self._is_type_target = False\n            for tkey in self.module.types:\n                custype = self.module.types[tkey]\n                for execkey, execinst in custype.executables.items():\n                    if execinst.target is self:\n                        self._is_type_target = custype\n                        break\n                if self._is_type_target:\n                    break\n\n        return self._is_type_target"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn true if the specified symbol has it s value changed by this executable or any of its dependencies.", "response": "def changed(self, symbol, checked = None):\n        \"\"\"Returns true if the specified symbol has it's value changed\n        by this executable or *any* of its dependencies.\"\"\"\n        #Initialize the dictionary if we are the first executable to call this.\n        myname = \"{}.{}\".format(self.module.name, self.name).lower()\n        if checked is None:\n            checked = []\n\n        if myname not in checked:\n            matches = self._get_assignments_in(self._parameters, symbol)\n            if (matches is not None and\n                (isinstance(matches, bool) and matches == True) or\n                (isinstance(matches, list) and len(matches) > 0)):\n                return myname\n            else:\n                #Make sure we don't check any executable twice.\n                checked.append(myname)\n                #We need to check the dependencies of this executable and\n                #see if any of them modify the parameter.\n                for dependlist in self.dependencies:\n                    for dependency in self.dependencies[dependlist]:\n                        if dependency.operator:\n                            continue\n\n                        if symbol in dependency.argnames:\n                            pindex = dependency.argnames.index(symbol)\n                            iexec = dependency.target\n                            if iexec is not None:\n                                pname = iexec.ordered_parameters[pindex].name.lower()\n                                if iexec.changed(pname, checked) != \"\":\n                                    return iexec.full_name\n                            else:\n                                checked.append(dependency.external_name)\n                        else:\n                            checked.append(dependency.external_name)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of code elements whose names are in the specified object.", "response": "def _get_assignments_in(self, filterlist, symbol = \"\"):\n        \"\"\"Returns a list of code elements whose names are in the specified object.\n\n        :arg filterlist: the list of symbols to check agains the assignments.\n        :arg symbol: when specified, return true if that symbol has its value\n          changed via an assignment.\"\"\"\n        if symbol != \"\":\n            lsymbol = symbol\n            for assign in self._assignments:\n                target = assign.split(\"%\")[0].lower()\n                if target == lsymbol:\n                    return True\n        else:\n            result = []\n            for assign in self._assignments:\n                target = assign.split(\"%\")[0].lower()\n                if target in filterlist:\n                    result.append(assign)\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the ValueElement corresponding to the parameter at the specified index.", "response": "def get_parameter(self, index):\n        \"\"\"Returns the ValueElement corresponding to the parameter\n        at the specified index.\"\"\"\n        result = None\n        if index < len(self.paramorder):\n            key = self.paramorder[index]\n            if key in self._parameters:\n                result = self._parameters[key]\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_parameter(self, parameter):\n        if parameter.name.lower() not in self.paramorder:\n            self.paramorder.append(parameter.name.lower())\n        self._parameters[parameter.name.lower()] = parameter", "response": "Adds the specified parameter value to the list of parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove the specified parameter from the list.", "response": "def remove_parameter(self, parameter_name):\n        \"\"\"Removes the specified parameter from the list.\"\"\"\n        if parameter_name in self.paramorder:\n            index = self.paramorder.index(parameter_name)\n            del self.paramorder[index]\n\n        if parameter_name in self._parameters:\n            del self._parameters[parameter_name]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a comma - separated list of the parameters in the executable definition.", "response": "def parameters_as_string(self):\n        \"\"\"Returns a comma-separated list of the parameters in the executable definition.\"\"\"\n        params = \", \".join([ p.name for p in self.ordered_parameters ])\n        return params"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_assignment(self, value):\n        if not value in self._assignments:\n            self._assignments.append(value)", "response": "Adds the name of a variable whose value is changed by\n            this exectuable."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the specified executable dependency to the list for this executable.", "response": "def add_dependency(self, value):\n        \"\"\"Adds the specified executable dependency to the list for this executable.\"\"\"\n        if value.name in self.dependencies:\n            self.dependencies[value.name.lower()].append(value)\n        else:\n            self.dependencies[value.name.lower()] = [ value ]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, name, modifiers, dtype, kind):\n        self.update_name(name)\n        self.modifiers = modifiers\n        self.dtype = dtype\n        self.kind = kind\n        self.update_dtype()", "response": "Updates the attributes of the function instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_dtype(self, resvar=None):\n        if self.dtype is None:\n            #search the members of this function for one that has the same name\n            #as the function. If it gets found, overwrite the dtype, kind and\n            #modifiers attributes so the rest of the code works.\n            for m in self.members:\n                if m == self.name.lower() or m == resvar:\n                    member = self.members[m]\n                    self.dtype = member.dtype\n                    self.modifiers = member.modifiers\n                    self.kind = member.kind\n                    self.default = member.default\n                    self.dimension = member.dimension\n                    del self.members[m]\n                    break", "response": "Updates the dtype attribute of the function. This is required because fortran functions can have the same dtype kind and dimension attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef returns(self):\n        kind = \"({}) \".format(self.kind) if self.kind is not None else \"\"      \n        mods = \", \".join(self.modifiers) + \" \"\n        dtype = self.dtype if self.dtype is not None else \"\"\n        return \"{}{}{}\".format(dtype, kind, mods)", "response": "Gets a string showing the return type and modifiers for the\n        function in a nice display format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef signature(self):\n        mods = \", \".join(self.modifiers)\n        return \"{} SUBROUTINE {}({})\".format(mods, self.name,\n                                             self.parameters_as_string())", "response": "Returns the signature definition for the subroutine."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, name, modifiers):\n        self.update_name(name)\n        self.modifiers = modifiers", "response": "Updates the attributes of the subroutine instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef target(self):\n        if self.pointsto is not None:\n            #It is in the format of module.executable.\n            xinst = self.module.parent.get_executable(self.pointsto.lower())\n            return xinst\n        else:\n            #The executable it points to is the same as its name.\n            fullname = \"{}.{}\".format(self.module.name, self.name)\n            return self.module.parent.get_executable(fullname.lower())", "response": "Returns the code element that is the actual executable that this type\n            executable points to."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fixedvar(self):\n        possible = [m for m in self.members.values() if not m.is_custom]\n        #If any of the possible variables is not allocatable or pointer, it will always\n        #have a value and we can just use that.\n        sufficient = [m for m in possible if \"allocatable\" not in m.modifiers\n                      and \"pointer\" not in m.modifiers]\n        if len(sufficient) > 0:\n            return [sufficient[0].name]\n        else:\n            return [m.name for m in possible]", "response": "Returns the name of a member that is not custom and that it would terminate the auto - class variable context chain."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef recursive(self):\n        for m in self.members.values():\n            if m.kind is not None and m.kind.lower() == self.name.lower():\n                return True\n        else:\n            return False", "response": "When True this CustomType has at least one member that is of the same type as itself."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the name of the custom type in this instance and its parent reference.", "response": "def update_name(self, name):\n        \"\"\"Updates the name of the custom type in this instance and its\n        parent reference.\"\"\"\n        if name != self.name:\n            self.parent.types[name] = self\n            del self.parent.types[self.name]\n            self.name = name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unpickle(self, parent):\n        self.parent = parent\n        self._unpickle_collection(self.members)\n        self._unpickle_collection(self.executables)\n        self.unpickle_docs()", "response": "Sets the parent pointer references for the type and all of its\n        child classes that also have pointer references."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning true if the parameter with the specified name has its value changed by the first module procedure in the interface.", "response": "def changed(self, name):\n        \"\"\"Returns true if the parameter with the specified name has its value changed by\n        the *first* module procedure in the interface.\n\n        :arg name: the name of the parameter to check changed status for.\n        \"\"\"\n        if self.first:\n            return self.first.changed(name)\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_parameter(self, index):\n        result = []\n        for target in self.targets:\n            if target is not None:\n                result.append(target.get_parameter(index))\n\n        return result", "response": "Gets the list of parameters at the specified index in the calling argument\n        list for each of the module procedures in the interface."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the docstring of this interface using the docstrings of its embedded module procedures that it is an interface for.", "response": "def find_docstring(self):\n        \"\"\"Sets the docstring of this interface using the docstrings of its embedded\n        module procedures that it is an interface for.\n        \"\"\"\n        #The docstrings for the interface are compiled from the separate docstrings\n        #of the module procedures it is an interface for. We choose the first of these\n        #procedures by convention and copy its docstrings over.\n        #Just use the very first embedded method that isn't None and has a docstring.\n        if self.first and len(self.docstring) == 0:\n            self.docstring = self.first.docstring"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef describe(self):\n        #Interfaces are tricky because we can have an arbitrary number of embedded procedures\n        #that each have different calling interfaces and return types. We are trying to \n        #summarize that information in a single interface. Interfaces can't mix executable\n        #types; they are either all subroutines or all functions. \n        self.find_docstring()\n        if not self.subroutine:\n            #We have a return type to worry about, compile it from all the targets\n            ret_type = []\n            for target in self.targets:\n                if target.returns not in ret_type:\n                    ret_type.append(target.returns)\n\n            ret_text = ', '.join(ret_type)\n        else:\n            ret_text = \"\"\n\n        #The list of types it accepts is constructed the same way for functions and subroutines.\n        act_type = []\n        for target in self.targets:\n            param = target.ordered_parameters[0]\n            if param.strtype not in act_type:\n                act_type.append(param.strtype)\n\n        act_text = ', '.join(act_type)\n\n        if self.subroutine:\n            return \"SUMMARY: {} | ACCEPTS: {}\".format(self.summary, act_text)\n        else:\n            return \"SUMMARY: {} | RETURNS: {} | ACCEPTS: {}\".format(self.summary, ret_text, act_text)", "response": "Returns a home - grown description that includes a summary of the calling interface\n        and the list of types it accepts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef first(self):\n        if self._first is None:\n            for target in self.targets:\n                if target is not None:\n                    self._first = target\n                    break\n            else:\n                self._first = False\n\n        return self._first", "response": "Returns the first module procedure embedded in the interface that has a valid\n        instance of a CodeElement."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef targets(self):\n        if self._targets is None:\n            self._targets = {}\n            for key in self.procedures:\n                element = self.module.parent.get_executable(key)\n                if element is not None:\n                    self._targets[key] = element\n                else:\n                    self._targets[key] = None\n                    msg.warn(\"unable to locate module procedure {}\".format(key) +\n                             \" in interface {}\".format(self.name))\n\n        return [self._targets[key] for key in self.procedures]", "response": "Provides an ordered list of CodeElement instances for each of the embedded\n        module procedures in the generic interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of other modules that this module and its members and executables depend on in order to run correctly.", "response": "def search_dependencies(self):\n        \"\"\"Returns a list of other modules that this module and its members and executables\n        depend on in order to run correctly. This differs from the self.dependencies attribute\n        that just hase explicit module names from the 'use' clauses.\n        \"\"\"\n        result = [self.module.name]\n        #First we look at the explicit use references from this module and all\n        #its dependencies until the chain terminates.\n        stack = self.needs\n        while len(stack) > 0:\n            module = stack.pop()\n            if module in result:\n                continue\n            \n            self.parent.load_dependency(module, True, True, False)\n            if module in self.parent.modules:\n                for dep in self.parent.modules[module].needs:\n                    modname = dep.split(\".\")[0]\n                    if modname not in result:\n                        result.append(modname)\n                    if modname not in stack:\n                        stack.append(modname)\n\n        #Add any incidentals from the automatic construction of code. These can be from\n        #executables that use special precision types without importing them or from\n        #derived types. Same applies to the local members of this module.\n        for ekey, anexec in list(self.executables.items()):\n            for dep in anexec.search_dependencies():\n                if dep is not None and dep not in result:\n                    result.append(dep)\n\n        for member in list(self.members.values()):\n            dep = member.dependency()\n            if dep is not None and dep not in result:\n                result.append(dep)\n                        \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the file path to this module taking the pre - processing into account.", "response": "def compile_path(self):\n        \"\"\"Returns the file path to this module taking the pre-processing into account.\n        If the module requires pre-processing, the extension is reported as F90; otherwise,\n        the regular self.filepath is returned.\n        \"\"\"\n        if not self.precompile:\n            return self.filepath\n        else:\n            if self._compile_path is None:\n                segs = self.filepath.split('.')\n                segs.pop()\n                segs.append(\"F90\")\n                self._compile_path = '.'.join(segs)\n\n            return self._compile_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef all_to_public(self):\n        if \"private\" not in self.modifiers:\n            def public_collection(attribute):\n                for key in self.collection(attribute):\n                    if key not in self.publics:\n                        self.publics[key.lower()] = 1\n            public_collection(\"members\")\n            public_collection(\"types\")\n            public_collection(\"executables\")", "response": "Sets all members types and executables in this module as public as\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the contents of the current module with the contents of the given statement.", "response": "def rt_update(self, statement, linenum, mode, modulep, lineparser):\n        \"\"\"Uses the specified line parser to parse the given statement.\n\n        :arg statement: a string of lines that are part of a single statement.\n        :arg linenum: the line number of the first line in the statement relative to\n          the entire module contents.\n        :arg mode: either 'insert', 'replace' or 'delete'\n        :arg modulep: an instance of ModuleParser for handling the changes\n          to the instance of the module.\n        :arg lineparser: a line parser instance for dealing with new instances\n          of types or executables that are add using only a signature.\n        \"\"\"\n        #Most of the module is body, since that includes everything inside\n        #of the module ... end module keywords. Since docstrings are handled\n        #at a higher level by line parser, we only need to deal with the body\n        #Changes of module name are so rare that we aren't going to bother with them.\n        section = self.find_section(self.module.charindex(linenum, 1))\n        if section == \"body\":\n            modulep.rt_update(statement, self, mode, linenum, lineparser)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the parent pointer references for the module and all of its child classes that also have pointer references.", "response": "def unpickle(self, parent):\n        \"\"\"Sets the parent pointer references for the module *and* all of its\n        child classes that also have pointer references.\"\"\"\n        self.parent = parent\n        self._unpickle_collection(self.members)\n        self._unpickle_collection(self.executables)\n        self._unpickle_collection(self.types)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the specified symbol is the name of one of the methods that this module depends on and returns it. If it is not search for the actual code element and return it.", "response": "def get_dependency_element(self, symbol):\n        \"\"\"Checks if the specified symbol is the name of one of the methods\n        that this module depends on. If it is, search for the actual code\n        element and return it.\"\"\"\n        for depend in self.dependencies:\n            if \".\" in depend:\n                #We know the module name and the executable name, easy\n                if depend.split(\".\")[1] == symbol.lower():\n                    found = self.parent.get_executable(depend)\n                    break\n            else:\n                #We only have the name of an executable or interface, we have to search\n                #the whole module for the element.\n                fullname = \"{}.{}\".format(depend, symbol)\n                if self.parent.get_executable(fullname) is not None:\n                    found = self.parent.get_executable(fullname)\n                    break\n                if self.parent.get_interface(fullname) is not None:\n                    found = self.parent.get_interface(fullname)\n                    break\n        else:\n            return None\n\n        return found"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind all possible symbol completions of the given symbol that belong to this module and its dependencies.", "response": "def completions(self, symbol, attribute, recursive = False):\n        \"\"\"Finds all possible symbol completions of the given symbol that belong\n        to this module and its dependencies.\n\n        :arg symbol: the code symbol that needs to be completed.\n        :arg attribute: one of ['dependencies', 'publics', 'members', \n          'types', 'executables'] for specifying which collections to search.\n        :arg result: the possible completions collected so far in the search.\n        \"\"\"\n        possible = []\n        for ekey in self.collection(attribute):\n            if symbol in ekey:\n                possible.append(ekey)\n\n        #Try this out on all the dependencies as well to find all the possible\n        #completions.\n        if recursive:\n            for depkey in self.dependencies:\n                #Completions need to be fast. If the module for the parent isn't already\n                #loaded, we just ignore the completions it might have.\n                if depkey in self.parent.modules:\n                    possible.extend(self.parent.modules[depkey].completions(symbol, attribute))\n            \n        return possible"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef contains_index(self):\n        if self._contains_index is None:\n            max_t = 0\n            for tkey in self.types:\n                if self.types[tkey].end > max_t and not self.types[tkey].embedded:\n                    max_t = self.types[tkey].end\n\n            #Now we have a good first guess. Continue to iterate the next few lines\n            #of the the refstring until we find a solid \"CONTAINS\" keyword. If there\n            #are no types in the module, then max_t will be zero and we don't have\n            #the danger of running into a contains keyword as part of a type. In that\n            #case we can just keep going until we find it.\n            i = 0\n            start = self.linenum(max_t)[0]\n            max_i = 10 if max_t > 0 else len(self._lines)\n\n            while (self._contains_index is None and i < max_i\n                   and start + i < len(self._lines)):\n                iline = self._lines[start + i].lower()\n                if \"contains\" in iline:\n                    if '!' not in iline or (iline.index('!') > iline.index(\"contains\")):\n                        self._contains_index = start + i\n                i += 1\n\n            if self._contains_index is None:\n                #There must not be a CONTAINS keyword in the module\n                self._contains_index = len(self._lines)-1\n\n        return self._contains_index", "response": "Returns the index of the line number that contains the CONTAINS keyword separating the\n            member and type definitions from the subroutines and functions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef needs(self):\n        result = []\n        for dep in self.dependencies:\n            module = dep.split(\".\")[0].lower()\n            if module not in result:\n                result.append(module)\n\n        return result", "response": "Returns a unique list of module names that this module depends on."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _filter_execs(self, isSubroutine):\n        result = {}\n        for key in self.executables:\n            if (isinstance(self.executables[key], Subroutine) and isSubroutine) or \\\n               (isinstance(self.executables[key], Function) and not isSubroutine):\n                result[key] = self.executables[key]\n        \n        return result", "response": "Filters the executables in the dictionary by their type."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks the module for documentation and best - practice warnings.", "response": "def warn(self, collection):\n        \"\"\"Checks the module for documentation and best-practice warnings.\"\"\"\n        super(CodeElement, self).warn(collection)\n        if not \"implicit none\" in self.modifiers:\n            collection.append(\"WARNING: implicit none not set in {}\".format(self.name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef type_search(self, basetype, symbolstr):\n        return self.parent.type_search(basetype, symbolstr, self)", "response": "Recursively searches the module tree for a type name and a symbol string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the collection corresponding the attribute name.", "response": "def collection(self, attribute):\n        \"\"\"Returns the collection corresponding the attribute name.\"\"\"\n        return {\n            \"dependencies\": self.dependencies,\n            \"publics\": self.publics,\n            \"members\": self.members,\n            \"types\": self.types,\n            \"executables\": self.executables,\n            \"interfaces\": self.interfaces\n        }[attribute]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the refstring that represents the original string that the module was parsed from. Also updates any properties attributes containing the original string that are derived from the refstring.", "response": "def update_refstring(self, string):\n        \"\"\"Updates the refstring that represents the original string that\n        the module was parsed from. Also updates any properties or attributes\n        that are derived from the refstring.\"\"\"\n        self.refstring = string\n        self._lines = []\n        self._contains_index = None\n        self.changed = True\n\n        #The only other references that become out of date are the contains\n        #and preamble attributes which are determined by the parsers.\n        #Assuming we did everything right with the rt update, we should be\n        #able to just use the new contains index to update those.\n        icontains = self.contains_index\n        ichar = self.charindex(icontains, 0)\n        self.preamble = string[:ichar]\n        self.contains = string[ichar + 9:]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate all the elements that are children of this module that are children of this module.", "response": "def update_elements(self, line, column, charcount, docdelta=0):\n        \"\"\"Updates all the element instances that are children of this module\n        to have new start and end charindex values based on an operation that\n        was performed on the module source code.\n\n        :arg line: the line number of the *start* of the operation.\n        :arg column: the column number of the start of the operation.\n        :arg charcount: the total character length change from the operation.\n        :arg docdelta: the character length of changes made to types/execs\n          that are children of the module whose docstrings external to their\n          definitions were changed.\n        \"\"\"\n        target = self.charindex(line, column) + charcount\n\n        #We are looking for all the instances whose *start* attribute lies\n        #after this target. Then we update them all by that amount.\n        #However, we need to be careful because of docdelta. If an elements\n        #docstring contains the target, we don't want to update it.\n        if line < self.contains_index:\n            for t in self.types:\n                if self._update_char_check(self.types[t], target, docdelta):\n                    self._element_charfix(self.types[t], charcount)\n\n            for m in self.members:\n                if self.members[m].start > target:\n                    self.members[m].start += charcount\n                    self.members[m].end += charcount\n\n            self._contains_index = None\n        else:\n            for iexec in self.executables:\n                if self._update_char_check(self.executables[iexec], target, docdelta):\n                    self._element_charfix(self.executables[iexec], charcount)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_char_check(self, element, target, docdelta):\n        if docdelta != 0:\n            if (element.docstart <= target and \n                element.docend >= target - docdelta):\n                return True\n            else:\n                return element.absstart > target\n        else:\n            return element.absstart > target", "response": "Checks whether the specified element should have its character indices updated as part of real - time updating."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _element_charfix(self, element, charcount):\n        element.start += charcount\n        element.docstart += charcount\n        element.end += charcount\n        element.docend += charcount", "response": "Updates the start and end attributes by charcount for the element."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the instance of the element who owns the specified line and column.", "response": "def get_element(self, line, column):\n        \"\"\"Gets the instance of the element who owns the specified line\n        and column.\"\"\"\n        ichar = self.charindex(line, column)\n        icontains = self.contains_index\n        result = None\n\n        if line < icontains:\n            #We only need to search through the types and members.\n            maxstart = 0\n            tempresult = None\n            for t in self.types:\n                if ichar >= self.types[t].absstart:\n                    if self.types[t].absstart > maxstart:\n                        maxstart = self.types[t].absstart\n                        tempresult = self.types[t]\n\n            #This takes the possibility of an incomplete type into account\n            if (tempresult is not None and (ichar <= tempresult.end or \n                                            tempresult.incomplete)):\n                result = tempresult\n\n            if not result:\n                #Members only span a single line usually and don't get added\n                #without an end token.\n                for m in self.members:\n                    if (ichar >= self.members[m].start and \n                        ichar <= self.members[m].end):\n                        result = self.members[m]\n                        break\n        else:\n            #We only need to search through the executables\n            tempresult = None\n            maxstart = 0\n            for iexec in self.executables:\n                if (ichar >= self.executables[iexec].absstart):\n                    if self.executables[iexec].absstart > maxstart:\n                        maxstart = self.executables[iexec].absstart\n                        tempresult = self.executables[iexec]\n\n            if tempresult is not None and (ichar <= tempresult.end or\n                                           tempresult.incomplete):\n                result = tempresult\n\n        if result is None:\n            #We must be in the text of the module, return the module\n            return self\n        else:\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_embedded(self, attribute):\n        #The parser doesn't handle embeddings deeper than two levels.\n        coll = self.collection(attribute)\n        keys = list(coll.keys())\n        for key in keys:\n            element = coll[key]\n            new_parent = self.find_embedded_parent(element)\n            if new_parent is not None:\n                #Update the parent of the embedded element, add it to the collection\n                #of the parent element and then delete it from the module's collection.\n                element.parent = new_parent\n                if attribute == \"types\":\n                    new_parent.types[key] = element\n                else:\n                    new_parent.executables[key] = element\n                del coll[key]", "response": "Updates the elements in the module result that have character indices that are a subset of another element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the parent of the embedded element by seeing the start and end indices of the element.", "response": "def find_embedded_parent(self, element):\n        \"\"\"Finds the parent (if any) of the embedded element by seeing\n        if the start and end indices of the element are a subset of \n        any type or executable in this module.\n        \"\"\"\n        result = None\n        for t in self.types:\n            if (element.start > self.types[t].start and\n                element.end < self.types[t].end):\n                result = self.types[t]\n                break\n        else:\n            for iexec in self.executables:\n                if (element.start > self.executables[iexec].start and\n                    element.end < self.executables[iexec].end):\n                    result = self.executables[iexec]\n                    break\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef charindex(self, line, column):\n        #Make sure that we have chars and lines to work from if this\n        #gets called before linenum() does.\n        if len(self._lines) == 0:\n            self.linenum(1)\n\n        if line < len(self._chars):\n            return self._chars[line - 1] + column\n        else:\n            return len(self.refstring)", "response": "Gets the absolute character index of the line and column in the continuous string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef linenum(self, index):\n        if len(self._lines) == 0 and self.refstring != \"\":\n            self._lines = self.refstring.split(\"\\n\")\n            #Add one for the \\n that we split on for each line\n            self._chars = [ len(x) + 1 for x in self._lines ]\n            #Remove the last line break since it doesn't exist\n            self._chars[-1] -= 1\n\n            #Now we want to add up the number of characters in each line\n            #as the lines progress so that it is easy to search for the\n            #line of a single character index\n            total = 0\n            for i in range(len(self._chars)):\n                total += self._chars[i]\n                self._chars[i] = total\n\n        if len(self._lines) > 0:\n            #Now, find the first index where the character value is >= index\n            result = -1\n            i = 0\n            while result == -1 and i < len(self._chars):\n                if index <= self._chars[i]:\n                    result = [ i, self._chars[i] - index]\n                i += 1\n\n            return result\n        else:\n            return [ -1, -1 ]", "response": "Gets the line number of the character at the specified index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if input is valid", "response": "def check_valid(self):\n\t\t\"\"\" check if input is valid \"\"\"\n\t\tfor k,input in self.inputs.items():\n\t\t\tif k in self.valid_opts:\n\t\t\t\tfor param in self.valid_opts[k]:\n\t\t\t\t\tif param is None or input is None:\n\t\t\t\t\t\treturn True\n\t\t\t\t\telif type(param) is str and '+' in param:\n\t\t\t\t\t\tif re.search(r'^'+param,str(input)):\n\t\t\t\t\t\t\treturn True\n\t\t\t\t\telif type(param) is bool and type(input) is bool:\n\t\t\t\t\t\treturn True\n\t\t\t\t\telif type(param) is list and type(input) is list:\n\t\t\t\t\t\treturn True\n\t\t\t\t\telse:\n\t\t\t\t\t\tif str(input).lower() == str(param):\n\t\t\t\t\t\t\treturn True\n\t\t\t\traise ValueError(\"Invalid input for '%s' parameter. Options are: %s\" % (k,' '.join([\"'%s',\" % str(o) for o in self.valid_opts[k]]) ))\n\t\t\telse:\n\t\t\t\traise ValueError(\"Invalid parameter for '%s'. Params are: %s\" % (self.__class__.__name__,', '.join([\"'%s'\" % p for p in self.valid_opts.keys()]) ))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_policy(self,defaultHeaders):\n\t\tif self.inputs is not None:\n\t\t\tfor k,v in defaultHeaders.items():\n\t\t\t\tif k not in self.inputs:\n\t\t\t\t\tself.inputs[k] = v\n\t\t\treturn self.inputs\n\t\telse:\n\t\t\treturn self.inputs", "response": "update policy with default headers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a header dictionary for the object.", "response": "def create_header(self):\n\t\t\"\"\" return header dict \"\"\"\n\t\ttry:\n\t\t\tself.check_valid()\n\t\t\t_header_list = []\n\t\t\tfor k,v in self.inputs.items():\n\t\t\t\tif v is None:\n\t\t\t\t\treturn  {self.__class__.__name__.replace('_','-'):None}\n\t\t\t\telif k == 'value':\n\t\t\t\t\t_header_list.insert(0,str(v))\n\t\t\t\telif isinstance(v,bool):\n\t\t\t\t\tif v is True:\n\t\t\t\t\t\t_header_list.append(k)\n\t\t\t\telse:\n\t\t\t\t\t_header_list.append('%s=%s' % (k,str(v)))\n\t\t\treturn {self.__class__.__name__.replace('_','-'):'; '.join(_header_list)}\n\t\texcept Exception, e:\n\t\t\traise"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_policy(self,defaultHeaders):\n\t\tif self.inputs is not None:\n\t\t\tfor k,v in defaultHeaders.items():\n\t\t\t\tif k not in self.inputs:\n\t\t\t\t\tself.inputs[k] = v\n\t\t\t\tif k == 'pins':\n\t\t\t\t\tself.inputs[k] = self.inputs[k] + defaultHeaders[k]\n\t\t\treturn self.inputs\n\t\telse:\n\t\t\treturn self.inputs", "response": "rewrite update policy so that additional pins are added and not overwritten"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_header(self):\n\t\ttry:\n\t\t\tself.check_valid()\n\t\t\t_header_list = []\n\t\t\tfor k,v in self.inputs.items():\n\t\t\t\tif v is None:\n\t\t\t\t\treturn  {self.__class__.__name__.replace('_','-'):None}\n\t\t\t\telif k == 'value':\n\t\t\t\t\t_header_list.insert(0,str(v))\n\t\t\t\telif isinstance(v,bool):\n\t\t\t\t\tif v is True: _header_list.append(k)\n\t\t\t\telif type(v) is list:\n\t\t\t\t\tlambda v: len(v)>0, [_header_list.append(''.join(['pin-%s=%s' % (pink,pinv) for pink, pinv in pin.items()])) for pin in v]\n\t\t\t\telse:\n\t\t\t\t\t_header_list.append('%s=%s' % (k,str(v)))\n\t\t\treturn {self.__class__.__name__.replace('_','-'):'; '.join(_header_list)}\n\t\texcept Exception, e:\n\t\t\traise", "response": "rewrite return header dict for HPKP"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds items to existing csp policies", "response": "def update_policy(self,cspDefaultHeaders):\n\t\t\"\"\" add items to existing csp policies \"\"\"\n\t\ttry:\n\t\t\tself.check_valid(cspDefaultHeaders)\n\t\t\tif self.inputs is not None:\n\t\t\t\tfor p,l in self.inputs.items():\n\t\t\t\t\tcspDefaultHeaders[p] = cspDefaultHeaders[p]+ list(set(self.inputs[p]) - set(cspDefaultHeaders[p]))\n\t\t\t\treturn cspDefaultHeaders\n\t\t\telse:\n\t\t\t\treturn self.inputs\n\t\texcept Exception, e:\n\t\t\traise"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_header(self):\n\t\tencapsulate =  re.compile(\"|\".join(['^self','^none','^unsafe-inline','^unsafe-eval','^sha[\\d]+-[\\w=-]+','^nonce-[\\w=-]+']))\n\t\tcsp = {}\n\t\tfor p,array in self.inputs.items():\n\t\t\tcsp[p] = ' '.join([\"'%s'\" % l if encapsulate.match(l) else l for l in array])\n\n\t\treturn {self.header:'; '.join(['%s %s' % (k, v) for k, v in csp.items() if v != ''])}", "response": "Create a CSP header dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef invoke(self, dirname, filenames=set(), linter_configs=set()):\n        retval = defaultdict(lambda: defaultdict(list))\n        if len(filenames):\n            extensions = [e.lstrip('.') for e in self.get_file_extensions()]\n            filenames = [f for f in filenames if f.split('.')[-1] in extensions]\n\n            if not filenames:\n                # There were a specified set of files, but none were the right\n                # extension. Different from the else-case below.\n                return {}\n\n            to_find = ' -o '.join(['-samefile \"%s\"' % f for f in filenames])\n        else:\n            to_find = ' -o '.join(['-name \"*%s\"' % ext\n                                   for ext in self.get_file_extensions()])\n\n        cmd = 'find %s -path \"*/%s\" | xargs %s' % (\n            dirname, to_find, self.get_command(\n                dirname,\n                linter_configs=linter_configs))\n        result = self.executor(cmd)\n        for line in result.split('\\n'):\n            output = self.process_line(dirname, line)\n            if output is not None:\n                filename, lineno, messages = output\n                if filename.startswith(dirname):\n                    filename = filename[len(dirname) + 1:]\n                retval[filename][lineno].append(messages)\n        return retval", "response": "Invoke the command line tool and return the results."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses a line return a 3 - element tuple representing the filename line number and error messages.", "response": "def process_line(self, dirname, line):\n        \"\"\"\n        Processes a line return a 3-element tuple representing (filename,\n        line_number, error_messages) or None to indicate no error.\n\n        :param: dirname - directory the code is running in\n\n        For default implementation, regex in `self.response_format` is expected\n        to have the capture groups `filename`, `line`, `message` in order. If\n        not, override this method.\n        \"\"\"\n        if not hasattr(self, 'response_format'):\n            raise NotImplementedError()\n\n        match = self.response_format.search(line)\n        if match is not None:\n            if len(self.filenames) != 0:\n                if match.group('filename') not in self.filenames:\n                    return\n            filename, line, messages = match.groups()\n            return filename, line, messages"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncleaning already reported messages.", "response": "def clean_already_reported(self, comments, file_name, position,\n                               message):\n        \"\"\"\n        message is potentially a list of messages to post. This is later\n        converted into a string.\n        \"\"\"\n        for comment in comments:\n            if ((comment['path'] == file_name and\n                 comment['position'] == position and\n                 comment['user']['login'] == self.requester.username)):\n\n                return [m for m in message if m not in comment['body']]\n        return message"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_message_to_string(self, message):\n        final_message = ''\n        for submessage in message:\n            final_message += '* {submessage}\\n'.format(submessage=submessage)\n        return final_message", "response": "Convert a list of items to a string for GitHub API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nposting a comment to the github issue.", "response": "def post_comment(self, message):\n        \"\"\"\n        Comments on an issue, not on a particular line.\n        \"\"\"\n        report_url = (\n            'https://api.github.com/repos/%s/issues/%s/comments'\n            % (self.repo_name, self.pr_number)\n        )\n        result = self.requester.post(report_url, {'body': message})\n        if result.status_code >= 400:\n            log.error(\"Error posting comment to github. %s\", result.json())\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the keyword arguments for instantiating the form.", "response": "def get_form_kwargs(self):\n        \"\"\"\n        Returns the keyword arguments for instantiating the form.\n        \"\"\"\n        kwargs = {\"initial\": self.get_initial()}\n        if self.request.method == \"GET\":\n            kwargs.update({\"data\": self.request.GET})\n        kwargs.update({\"searchqueryset\": self.get_query_set()})\n        return kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhandle GET requests and instantiates a blank version of the form.", "response": "def get(self, request, *args, **kwargs):\n        \"\"\"\n        Handles GET requests and instantiates a blank version of the form.\n        \"\"\"\n        form_class = self.get_form_class()\n        form = self.get_form(form_class)\n        if form.is_valid():\n            return self.form_valid(form)\n\n        else:\n            return self.form_invalid(form)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef queryset(self, request, queryset):\n        form = self.get_form(request)\n\n        \"\"\"\n        That's the trick - we create self.form when django tries to get our queryset.\n        This allows to create unbount and bound form in the single place.\n        \"\"\"\n        self.form = form\n\n        start_date = form.start_date()\n        end_date = form.end_date()\n\n        if form.is_valid() and (start_date or end_date):\n            args = self.__get_filterargs(\n                start=start_date,\n                end=end_date,\n            )\n            return queryset.filter(**args)", "response": "Returns a queryset of the items in the database."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the arguments and runs the Docker - tag - naming command", "response": "def parse_args_and_run():\n    \"\"\"\n    :return: The parsed arguments\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers(help='Docker-tag-naming sub-commands',\n                                       dest='subparser_name')\n\n    #\n    #   Forge\n    #\n    parser_forge = subparsers.add_parser('forge',\n                                         help='Create a new version tag')\n    parser_forge.add_argument('--version', type=int, default=1,\n                              help='Version number')\n    parser_forge.add_argument('--commit-id', required=True,\n                              help='Git commit id')\n    parser_forge.add_argument('--branch', required=True,\n                              help='The branch name (ie. master)')\n\n    #\n    #   Latest\n    #\n    parser_latest = subparsers.add_parser('latest',\n                                          help='Query the latest tag in the'\n                                               ' registry')\n    parser_latest.add_argument('image',\n                               help='The image to query (ie. username/image)')\n    parser_latest.add_argument('branch',\n                               help='The branch name (ie. master)')\n\n    #\n    #   Bump\n    #\n    parser_bump = subparsers.add_parser('bump',\n                                        help='Query the latest tag in the'\n                                             ' registry and return a +1')\n    parser_bump.add_argument('image',\n                             help='The image to bump (ie. username/image)')\n    parser_bump.add_argument('branch',\n                             help='The branch name (ie. master)')\n    parser_bump.add_argument('--commit-id', required=True,\n                             help='Git commit id for the newly created tag')\n\n    #\n    #   Refresh\n    #\n    parser_latest = subparsers.add_parser('refresh',\n                                          help='Loop until the latest tag in'\n                                               ' the registry changes')\n    parser_latest.add_argument('image',\n                               help='The image to query (ie. username/image)')\n    parser_latest.add_argument('branch',\n                               help='The branch name (ie. master)')\n\n    args = parser.parse_args()\n\n    {'bump': run_bump,\n     'latest': run_latest,\n     'forge': run_forge,\n     'refresh': run_refresh}.get(args.subparser_name)(args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_up_clone(self, repo_name, remote_repo):\n        dirname = self.clone_dir(repo_name)\n        self.to_cleanup[repo_name] = dirname\n        klass = self.get_repo_class()\n        repo = klass(repo_name,\n                     dirname,\n                     self.tools,\n                     self.executor,\n                     shallow=self.shallow_clone)\n        return (dirname, repo)", "response": "Sets up the working directory and returns a tuple of the working directory and the remote repository."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclone the given repo and returns the Repository object.", "response": "def clone_repo(self, repo_name, remote_repo, ref):\n        \"\"\"Clones the given repo and returns the Repository object.\"\"\"\n        self.shallow_clone = False\n        dirname, repo = self.set_up_clone(repo_name, remote_repo)\n        if os.path.isdir(\"%s/.git\" % dirname):\n            log.debug(\"Updating %s to %s\", repo.download_location, dirname)\n            self.executor(\n                \"cd %s && git checkout master\" % dirname)\n            self.pull(dirname)\n        else:\n            log.debug(\"Cloning %s to %s\", repo.download_location, dirname)\n            self.executor(\n                \"git clone %s %s\" % (repo.download_location, dirname))\n\n        if remote_repo is not None:\n            log.debug(\"Pulling remote branch from %s\", remote_repo.url)\n            self.add_remote(dirname,\n                            remote_repo.name,\n                            remote_repo.url)\n            self.pull(dirname)\n        return repo"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prepare_object(obj, using=\"default\"):\n    model = obj.__class__\n    unified_index = connections[using].get_unified_index()\n    index = unified_index.get_index(model)\n    prepped_data = index.full_prepare(obj)\n    final_data = {}\n    for key, value in prepped_data.items():\n        final_data[key] = connections[using].get_backend()._from_python(value)\n    return final_data", "response": "Prepares the given object for use in Haystack search."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_model(app_label, model_name):\n    try:\n        from django.apps import apps\n        from django.core.exceptions import AppRegistryNotReady\n    except ImportError:\n        # Django < 1.7\n        from django.db import models\n        return models.get_model(app_label, model_name)\n\n    try:\n        return apps.get_model(app_label, model_name)\n\n    except AppRegistryNotReady:\n        if apps.apps_ready and not apps.models_ready:\n            # If this function is called while `apps.populate()` is\n            # loading models, ensure that the module that defines the\n            # target model has been imported and try looking the model up\n            # in the app registry. This effectively emulates\n            # `from path.to.app.models import Model` where we use\n            # `Model = get_model('app', 'Model')` instead.\n            app_config = apps.get_app_config(app_label)\n            # `app_config.import_models()` cannot be used here because it\n            # would interfere with `apps.populate()`.\n            import_module(\"%s.%s\" % (app_config.name, \"models\"))\n            # In order to account for case-insensitivity of model_name,\n            # look up the model through a private API of the app registry.\n            return apps.get_registered_model(app_label, model_name)\n\n        else:\n            # This must be a different case (e.g. the model really doesn't\n            # exist). We just re-raise the exception.\n            raise", "response": "Fetches a Django model using the app registry."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn contents of the given file which path is supposed relative to this module.", "response": "def read_relative_file(filename):\n    \"\"\"Returns contents of the given file, which path is supposed relative\n    to this module.\"\"\"\n    with open(join(dirname(abspath(__file__)), filename)) as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling the forge subcommand", "response": "def run_forge(args):\n    \"\"\"\n    Handle the forge subcommand\n    :param args: Parsed command line arguments\n    :return: None, output is written to console\n    \"\"\"\n    version = args.version\n    commit_id = args.commit_id\n    branch = args.branch\n\n    try:\n        print(Version(version, commit_id, branch))\n    except DockerTagNamingException, de:\n        print(de)\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef diff_commit(self, commit, compare_point=None):\n        # @@@ This is a security hazard as compare-point is user-passed in\n        # data. Doesn't matter until we wrap this in a service.\n        if compare_point is not None:\n            self.apply_commit(compare_point)\n        return self.executor(\"cd %s && git diff %s\" % (self.dirname, commit))", "response": "Returns a diff string from the current HEAD to the given commit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the diff text into a datastructure that looks like a list of Entry objects.", "response": "def parse(self):\n        \"\"\"\n        Parses everyting into a datastructure that looks like:\n\n            result = [{\n                'origin_filename': '',\n                'result_filename': '',\n                'origin_lines': [], // all lines of the original file\n                'result_lines': [], // all lines of the newest file\n                'added_lines': [], // all lines added to the result file\n                'removed_lines': [], // all lines removed from the result file\n            }, ...]\n\n        \"\"\"\n        result = []\n\n        z = None\n\n        before_line_number, after_line_number = 0, 0\n        position = 0\n\n        for line in self.diff_text.splitlines():\n\n            # New File\n            match = re.search(r'diff .*a/(?P<origin_filename>.*) '\n                              r'b/(?P<result_filename>.*)', line)\n            if match is not None:\n                if z is not None:\n                    result.append(z)\n                z = Entry(match.group('origin_filename'),\n                          match.group('result_filename'))\n                position = 0\n                continue\n\n            if self.should_skip_line(line):\n                continue\n\n            header = diff_re.search(line)\n            if header is not None:\n                before_line_number = int(header.group('removed_start'))\n                after_line_number = int(header.group('added_start'))\n                position += 1\n                continue\n\n            # removed line\n            if line.startswith('-'):\n                z.new_removed(Line(before_line_number, position, line[1:]))\n                z.new_origin(Line(before_line_number, position, line[1:]))\n                before_line_number += 1\n\n            # added line\n            elif line.startswith('+'):\n                z.new_added(Line(after_line_number, position, line[1:]))\n                z.new_result(Line(after_line_number, position, line[1:]))\n                after_line_number += 1\n\n            # untouched context line.\n            else:\n                z.new_origin(Line(before_line_number, position, line[1:]))\n                z.new_result(Line(after_line_number, position, line[1:]))\n\n                before_line_number += 1\n                after_line_number += 1\n\n            position += 1\n\n        if z is not None:\n            result.append(z)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle the refresh subcommand", "response": "def run_refresh(args):\n    \"\"\"\n    Handle the refresh subcommand\n    :param args: Parsed command line arguments\n    :return: None, output is written to console\n    \"\"\"\n    image = args.image\n    branch = args.branch\n\n    try:\n        initial_version = get_latest_version(image, branch)\n    except DockerTagNamingException, de:\n        print(de)\n        sys.exit(1)\n\n    if initial_version is None:\n        print('No version found')\n        sys.exit(1)\n\n    print('Initial version is %s , waiting for new release...' % initial_version)\n\n    for _ in xrange(120):\n        time.sleep(1)\n\n        try:\n            version = get_latest_version(image, branch)\n        except DockerTagNamingException, de:\n            print(de)\n            sys.exit(1)\n\n        if version.version_number != initial_version.version_number:\n            print('New version found: %s' % version)\n            sys.exit(0)\n\n    print('Timeout: version did not change.')\n    sys.exit(0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a value from the object with given key or index.", "response": "def get(self, key=NOT_SET, index=NOT_SET, d=None):\n\t\t\"\"\"Return value with given key or index.\n\n\t\tIf no value is found, return d (None by default).\n\t\t\"\"\"\n\t\tif index is NOT_SET and key is not NOT_SET:\n\t\t\ttry:\n\t\t\t\tindex, value = self._dict[key]\n\t\t\texcept KeyError:\n\t\t\t\treturn d\n\t\t\telse:\n\t\t\t\treturn value\n\t\telif index is not NOT_SET and key is NOT_SET:\n\t\t\ttry:\n\t\t\t\tkey, value = self._list[index]\n\t\t\texcept IndexError:\n\t\t\t\treturn d\n\t\t\telse:\n\t\t\t\treturn value\n\t\telse:\n\t\t\traise KEY_EQ_INDEX_ERROR"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove and return value with given key or index.", "response": "def pop(self, key=NOT_SET, index=NOT_SET, d=NOT_SET):\n\t\t\"\"\"Remove and return value with given key or index (last item by default).\n\n\t\tIf key is not found, returns d if given,\n\t\totherwise raises KeyError or IndexError.\n\n\t\tThis is generally O(N) unless removing last item, then O(1).\n\t\t\"\"\"\n\t\thas_default = d is not NOT_SET\n\n\t\tif index is NOT_SET and key is not NOT_SET:\n\t\t\tindex, value = self._pop_key(key, has_default)\n\t\telif key is NOT_SET:\n\t\t\tkey, index, value = self._pop_index(index, has_default)\n\t\telse:\n\t\t\traise KEY_AND_INDEX_ERROR\n\n\t\tif index is None:\n\t\t\treturn d\n\t\telse:\n\t\t\tself._fix_indices_after_delete(index)\n\t\t\treturn value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _pop_key(self, key, has_default):\n\t\ttry:\n\t\t\tindex, value = self._dict.pop(key)\n\t\texcept KeyError:\n\t\t\tif has_default:\n\t\t\t\treturn None, None\n\t\t\telse:\n\t\t\t\traise\n\t\tkey2, value2 = self._list.pop(index)\n\t\tassert key is key2\n\t\tassert value is value2\n\n\t\treturn index, value", "response": "Remove an element by key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving an element by index or last element.", "response": "def _pop_index(self, index, has_default):\n\t\t\"\"\"Remove an element by index, or last element.\"\"\"\n\t\ttry:\n\t\t\tif index is NOT_SET:\n\t\t\t\tindex = len(self._list) - 1\n\t\t\t\tkey, value = self._list.pop()\n\t\t\telse:\n\t\t\t\tkey, value = self._list.pop(index)\n\t\t\t\tif index < 0:\n\t\t\t\t\tindex += len(self._list) + 1\n\t\texcept IndexError:\n\t\t\tif has_default:\n\t\t\t\treturn None, None, None\n\t\t\telse:\n\t\t\t\traise\n\t\tindex2, value2 = self._dict.pop(key)\n\t\tassert index == index2\n\t\tassert value is value2\n\n\t\treturn key, index, value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fast_pop(self, key=NOT_SET, index=NOT_SET):\n\t\tif index is NOT_SET and key is not NOT_SET:\n\t\t\tindex, popped_value = self._dict.pop(key)\n\t\telif key is NOT_SET:\n\t\t\tif index is NOT_SET:\n\t\t\t\tindex = len(self._list) - 1\n\t\t\t\tkey, popped_value2 = self._list[-1]\n\t\t\telse:\n\t\t\t\tkey, popped_value2 = self._list[index]\n\t\t\t\tif index < 0:\n\t\t\t\t\tindex += len(self._list)\n\t\t\tindex2, popped_value = self._dict.pop(key)\n\t\t\tassert index == index2\n\t\telse:\n\t\t\traise KEY_AND_INDEX_ERROR\n\n\t\tif key == self._list[-1][0]:\n\t\t\t# The item we're removing happens to be the last in the list,\n\t\t\t# no swapping needed\n\t\t\t_, popped_value2 = self._list.pop()\n\t\t\tassert popped_value is popped_value2\n\t\t\treturn popped_value, len(self._list), key, popped_value\n\t\telse:\n\t\t\t# Swap the last item onto the deleted spot and\n\t\t\t# pop the last item from the list\n\t\t\tself._list[index] = self._list[-1]\n\t\t\tmoved_key, moved_value = self._list.pop()\n\t\t\tself._dict[moved_key] = (index, moved_value)\n\t\t\treturn popped_value, index, moved_key, moved_value", "response": "Pop a specific item quickly by swapping it to the end."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves and return last or first pair.", "response": "def popitem(self, last=True):\n\t\t\"\"\"Remove and return last (default) or first (last=False) pair (key, value).\n\n\t\tRaises KeyError if the dictionary is empty.\n\n\t\tRuns in O(1) for last item, O(N) for first one.\n\t\t\"\"\"\n\t\ttry:\n\t\t\tif last:\n\t\t\t\tkey, value = self._list.pop()\n\t\t\t\tindex = len(self._list)\n\t\t\telse:\n\t\t\t\tkey, value = self._list.pop(0)\n\t\t\t\tindex = 0\n\t\texcept IndexError:\n\t\t\traise KeyError(\"IndexedDict is empty\")\n\n\t\tindex2, value2 = self._dict.pop(key)\n\t\tassert index == index2\n\t\tassert value is value2\n\n\t\tif not last:\n\t\t\tself._fix_indices_after_delete()\n\n\t\treturn key, value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmoving an existing element to the end of the list.", "response": "def move_to_end(self, key=NOT_SET, index=NOT_SET, last=True):\n\t\t\"\"\"Move an existing element to the end (or beginning if last==False).\n\n\t\tRuns in O(N).\n\t\t\"\"\"\n\t\tif index is NOT_SET and key is not NOT_SET:\n\t\t\tindex, value = self._dict[key]\n\t\telif index is not NOT_SET and key is NOT_SET:\n\t\t\tkey, value = self._list[index]\n\n\t\t\t# Normalize index\n\t\t\tif index < 0:\n\t\t\t\tindex += len(self._list)\n\t\telse:\n\t\t\traise KEY_EQ_INDEX_ERROR\n\n\t\tif last:\n\t\t\tindex_range = range(len(self._list) - 1, index - 1, -1)\n\t\t\tself._dict[key] = (len(self._list) - 1, value)\n\t\telse:\n\t\t\tindex_range = range(index + 1)\n\t\t\tself._dict[key] = (0, value)\n\n\t\tprevious = (key, value)\n\t\tfor i in index_range:\n\t\t\tself._dict[previous[0]] = i, previous[1]\n\t\t\tprevious, self._list[i] = self._list[i], previous"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy(self):\n\t\tret = IndexedDict()\n\t\tret._dict = self._dict.copy()\n\t\tret._list = list(self._list)\n\t\treturn ret", "response": "Return a shallow copy of the IndexedDict."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_pr_info(requester, reponame, number):\n    \"Returns the PullRequest as a PRInfo object\"\n    resp = requester.get(\n        'https://api.github.com/repos/%s/pulls/%s' % (reponame, number))\n    return PRInfo(resp.json())", "response": "Returns the PullRequest as a PRInfo object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new collection with the specified properties.", "response": "def collection(iterable=None, mutable=True, ordered=False, unique=False):\n\t\"\"\"Return a :class:`Collection` with the specified properties.\n\n\tArgs:\n\t\titerable (Iterable): collection to instantiate new collection from.\n\t\tmutable (bool): Whether or not the new collection is mutable.\n\t\tordered (bool): Whether or not the new collection is ordered.\n\t\tunique (bool): Whether or not the new collection contains only unique values.\n\t\"\"\"\n\tif iterable is None:\n\t\titerable = tuple()\n\tif unique:\n\t\tif ordered:\n\t\t\tif mutable:\n\t\t\t\treturn setlist(iterable)\n\t\t\telse:\n\t\t\t\treturn frozensetlist(iterable)\n\t\telse:\n\t\t\tif mutable:\n\t\t\t\treturn set(iterable)\n\t\t\telse:\n\t\t\t\treturn frozenset(iterable)\n\telse:\n\t\tif ordered:\n\t\t\tif mutable:\n\t\t\t\treturn list(iterable)\n\t\t\telse:\n\t\t\t\treturn tuple(iterable)\n\t\telse:\n\t\t\tif mutable:\n\t\t\t\treturn bag(iterable)\n\t\t\telse:\n\t\t\t\treturn frozenbag(iterable)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse a version string into a tuple of the parsed version and the exception when the version is unknown or incorrect", "response": "def version_parser(version_string):\n    \"\"\"\n    :param version_string: The version tag as returned by the registry/hub API\n    :return: A tuple with the parsed version / an exception when the version\n             format is unknown/incorrect\n    \"\"\"\n    version, commit, branch = version_string.split('-', 3)\n\n    # Remove the \"v\"\n    version_number = version[1:]\n    version_number = int(version_number)\n\n    return Version(version_number, commit, branch)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the tags for the given image and branch.", "response": "def get_all_tags_with_auth(image_name, branch=None):\n    \"\"\"\n    Get the tag information using authentication credentials provided by the\n    user.\n\n    :param image_name: The image name to query\n    :param branch: The branch to filter by\n    :return: A list of Version instances, latest first\n    \"\"\"\n    logging.debug('Getting %s with authentication' % image_name)\n    url = '%s/%s/images' % (API_URL, image_name)\n\n    registry_user = os.environ.get('REGISTRY_USER')\n    registry_pass = os.environ.get('REGISTRY_PASS')\n\n    if registry_user is None or registry_pass is None:\n        msg = ('The docker image seems to be private and no authentication'\n               ' credentials were provided. Please set REGISTRY_USER and'\n               ' REGISTRY_PASS environment variables and try again.')\n        raise DockerTagNamingException(msg)\n\n    user_credentials = (registry_user, registry_pass)\n\n    headers = {'X-Docker-Token': 'true',\n               'Accept': 'application/json',\n               'Content-Type': 'application/json'}\n\n    try:\n        response = requests.get(url, auth=user_credentials, headers=headers)\n    except RequestException, re:\n        raise DockerTagNamingException('HTTP request exception \"%s\"' % re)\n\n    if response.status_code in (404, 401):\n        msg = ('Received unexpected status code %s from the registry'\n               ' REST API after sending authentication credentials, the image'\n               ' might not exist or is private.')\n        raise AuthException(msg % response.status_code)\n\n    token = response.headers.get('x-docker-token')\n    endpoint = response.headers.get('x-docker-endpoints')\n\n    if token is None:\n        raise DockerTagNamingException('No token returned by the REST API')\n\n    if endpoint is None:\n        raise DockerTagNamingException('No docker endpoint returned by the'\n                                       ' REST API')\n\n    url = 'https://{0}/v1/repositories/{1}/tags'.format(endpoint, image_name)\n    headers['Authorization'] = 'Token %s' % token\n    try:\n        response = requests.get(url, headers=headers)\n    except RequestException, re:\n        raise DockerTagNamingException('HTTP request exception \"%s\"' % re)\n\n    if response.status_code in (404,):\n        logging.debug('Received unexpected status code %s from the registry'\n                      ' REST API, the image might not exist in the registry'\n                      ' but was registered in the hub.')\n        return []\n\n    if response.status_code != 200:\n        msg = ('Received unexpected status code %s from the registry'\n               ' REST API. Please report a bug.')\n        raise AuthException(msg % response.status_code)\n\n    try:\n        json_data = response.json()\n    except ValueError:\n        msg = 'JSON decode failed! Raw data is: \"%s\". Please report a bug.'\n        raise DockerTagNamingException(msg % (response.content[:25]).strip())\n\n    #\n    #   Note that the registry returns a different format\n    #\n    output = []\n\n    for tag_name in json_data.keys():\n        try:\n            version = version_parser(tag_name)\n        except Exception, e:\n            msg = 'Ignoring version tag \"%s\" with incorrect format: \"%s\"'\n            logging.debug(msg % (tag_name, e))\n            continue\n\n        if branch is not None:\n            if version.branch != branch:\n                continue\n\n        output.append(version)\n\n    def sort_func(version_a, version_b):\n        return cmp(version_b.version_number, version_a.version_number)\n\n    output.sort(sort_func)\n\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_tags_no_auth(image_name, branch=None):\n    output = []\n    logging.debug('Getting %s without authentication' % image_name)\n\n    spec = '/%s/tags' % image_name\n    headers = {'Accept': 'application/json',\n               'Content-Type': 'application/json'}\n\n    try:\n        # This works well for any public images:\n        response = requests.get(API_URL + spec, headers=headers)\n    except RequestException, re:\n        raise DockerTagNamingException('HTTP request exception \"%s\"' % re)\n\n    if response.status_code == 401:\n        msg = ('Received unexpected status code %s from the registry'\n               ' REST API, the image is private.')\n        raise AuthException(msg % response.status_code)\n\n    if response.status_code != 200:\n        msg = ('Received unexpected status code %s from the registry'\n               ' REST API, the image might not exist')\n        raise DockerTagNamingException(msg % response.status_code)\n\n    try:\n        json_data = response.json()\n    except ValueError:\n        msg = 'JSON decode failed! Raw data is: \"%s\". Please report a bug.'\n        raise DockerTagNamingException(msg % (response.content[:25]).strip())\n\n    try:\n        tag_names = [tag_info['name'] for tag_info in json_data]\n    except Exception:\n        msg = ('The JSON data does not contain the expected format!'\n               ' Raw data is: \"%s\". Please report a bug.')\n        raise DockerTagNamingException(msg % (response.content[:25]).strip())\n\n    for tag_name in tag_names:\n\n        try:\n            version = version_parser(tag_name)\n        except Exception, e:\n            msg = 'Ignoring version tag \"%s\" with incorrect format: \"%s\"'\n            logging.debug(msg % (tag_name, e))\n            continue\n\n        if branch is not None:\n            if version.branch != branch:\n                continue\n\n        output.append(version)\n\n    def sort_func(version_a, version_b):\n        return cmp(version_b.version_number, version_a.version_number)\n\n    output.sort(sort_func)\n\n    return output", "response": "Get all tags that are not public."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets / v1 / repositories / <namespace > / tags", "response": "def get_all_tags(image_name, branch=None):\n    \"\"\"\n    GET /v1/repositories/<namespace>/<repository_name>/tags\n\n    :param image_name: The docker image name\n    :param branch: The branch to filter by\n    :return: A list of Version instances, latest first\n    \"\"\"\n    try:\n        return get_all_tags_no_auth(image_name, branch)\n    except AuthException:\n        return get_all_tags_with_auth(image_name, branch)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts publishing MySQL row - based binlog events to blinker signals.", "response": "def start_publishing(mysql_settings, **kwargs):\n    \"\"\"Start publishing MySQL row-based binlog events to blinker signals\n\n    Args:\n        mysql_settings (dict): information to connect to mysql via pymysql\n        **kwargs: The additional kwargs will be passed to\n        :py:class:`pymysqlreplication.BinLogStreamReader`.\n    \"\"\"\n    _logger.info('Start publishing from %s with:\\n%s'\n                 % (mysql_settings, kwargs))\n\n    kwargs.setdefault('server_id', random.randint(1000000000, 4294967295))\n    kwargs.setdefault('freeze_schema', True)\n\n    # connect to binlog stream\n    stream = pymysqlreplication.BinLogStreamReader(\n        mysql_settings,\n        only_events=[row_event.DeleteRowsEvent,\n                     row_event.UpdateRowsEvent,\n                     row_event.WriteRowsEvent],\n        **kwargs\n    )\n    \"\"\":type list[RowsEvent]\"\"\"\n\n    for event in stream:\n        # ignore non row events\n        if not isinstance(event, row_event.RowsEvent):\n            continue\n\n        _logger.debug('Send binlog signal \"%s@%s.%s\"' % (\n            event.__class__.__name__,\n            event.schema,\n            event.table\n        ))\n        signals.binlog_signal.send(event, stream=stream)\n        signals.binlog_position_signal.send((stream.log_file, stream.log_pos))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start_replication(mysql_settings,\n                      binlog_pos_memory=(None, 2),\n                      **kwargs):\n    \"\"\" Start replication on server specified by *mysql_settings*\n\n    Args:\n         mysql_settings (dict): mysql settings that is used to connect to\n                                mysql via pymysql\n        binlog_pos_memory (_bpm.BaseBinlogPosMemory):\n            Binlog Position Memory, it should be an instance of subclass of\n            :py:class:`_bpm.BaseBinlogPosMemory`.\n\n            If a tuple (str, float) is passed, it will be initialize parameters\n            for default :py:class:`_bpm.FileBasedBinlogPosMemory`. It the file-\n            name is None, it will be *`cwd`\\mysqlbinlog2blinker.binlog.pos*\n        **kwargs: any arguments that are accepted by\n            :py:class:`pymysqlreplication.BinLogStreamReader`'s constructor\n    \"\"\"\n    if not isinstance(binlog_pos_memory, _bpm.BaseBinlogPosMemory):\n        if not isinstance(binlog_pos_memory, (tuple, list)):\n            raise ValueError('Invalid binlog position memory: %s'\n                             % binlog_pos_memory)\n        binlog_pos_memory = _bpm.FileBasedBinlogPosMemory(*binlog_pos_memory)\n\n    mysql_settings.setdefault('connect_timeout', 5)\n    kwargs.setdefault('blocking', True)\n    kwargs.setdefault('resume_stream', True)\n\n    with binlog_pos_memory:\n        kwargs.setdefault('log_file', binlog_pos_memory.log_file)\n        kwargs.setdefault('log_pos', binlog_pos_memory.log_pos)\n        _logger.info('Start replication from %s with:\\n%s'\n                     % (mysql_settings, kwargs))\n\n        start_publishing(mysql_settings, **kwargs)", "response": "Start replication of the given mysql binlog file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extractFromHTML(html, blur=5):\n\n    #html = html.encode('utf-8', errors='ignore')\n    try:\n        html = unicode(html, errors='ignore')\n    except TypeError:\n        pass\n    assert isinstance(html, unicode)\n\n    # Create memory file.\n    _file = StringIO()\n\n    # Convert html to text.\n    f = formatter.AbstractFormatter(formatter.DumbWriter(_file))\n    p = TextExtractor()\n    p.pathBlur = blur\n    p.feed(html)\n    p.close()\n    text = p.get_plaintext()\n\n    # Remove stand-alone punctuation.\n    text = re.sub(\"\\s[\\(\\),;\\.\\?\\!](?=\\s)\", \" \", text).strip()\n\n    # Compress whitespace.\n    text = re.sub(\"[\\n\\s]+\", \" \", text).strip()\n\n    # Remove consequetive dashes.\n    text = re.sub(\"\\-{2,}\", \"\", text).strip()\n\n    # Remove consequetive periods.\n    text = re.sub(\"\\.{2,}\", \"\", text).strip()\n\n    return text", "response": "Extracts text from HTML content."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun an arbitrary HTML string through Tidy.", "response": "def tidyHTML(dirtyHTML):\n    \"\"\"\n    Runs an arbitrary HTML string through Tidy.\n    \"\"\"\n    try:\n        from tidylib import tidy_document\n    except ImportError as e:\n        raise ImportError((\"%s\\nYou need to install pytidylib.\\n\" +\n             \"e.g. sudo pip install pytidylib\") % e)\n    options = {\n        'output-xhtml':1,\n        #add_xml_decl=1,#option in tidy but not pytidylib\n        'indent':1,\n        'tidy-mark':1,\n        #'char-encoding':'utf8',\n        'char-encoding':'raw',\n    }\n    html, errors = tidy_document(dirtyHTML, options=options)\n    return html"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a cache key for the given string using the given pattern", "response": "def generate_key(s, pattern=\"%s.txt\"):\n    \"\"\"\n    Generates the cache key for the given string using the content in pattern\n    to format the output string\n    \"\"\"\n    h = hashlib.sha1()\n    #h.update(s)\n    h.update(s.encode('utf-8'))\n    return pattern % h.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cache_get(cache_dir, cache_key, default=None):\n    filename = os.path.join(cache_dir, cache_key)\n\n    if os.path.isfile(filename):\n        with open(filename, 'r') as f:\n            return f.read()\n\n    return default", "response": "Returns the content of a cache item or the given default if no content is available."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the content of a single item in the cache directory", "response": "def cache_set(cache_dir, cache_key, content):\n    \"\"\"\n    Creates a new cache file in the cache directory\n    \"\"\"\n    filename = os.path.join(cache_dir, cache_key)\n\n    with open(filename, 'w') as f:\n        f.write(content)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cache_info(cache_dir, cache_key):\n    filename = os.path.join(cache_dir, cache_key)\n    return os.path.getmtime(filename) if os.path.exists(filename) else 0", "response": "Returns the mtime of the cache file with the given key."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfetch the raw content of the URL.", "response": "def fetch(url, timeout=5, userAgent=None, only_mime_types=None):\n    \"\"\"\n    Retrieves the raw content of the URL.\n    \"\"\"\n    headers = {}\n    if userAgent:\n        headers['User-agent'] = str(userAgent)\n    else:\n        headers['User-agent'] = ua.random\n\n    #request = Request(url=url, headers=headers)\n    #response = urlopen(request, timeout=timeout)\n    response = requests.get(url, headers=headers, timeout=timeout)\n\n    # Return nothing of the content isn't one of the target mime-types.\n    if only_mime_types:\n        assert isinstance(only_mime_types, (tuple, list))\n        # Check for mimetype by looking at pattern in the URL.\n        # Not super accurate, but very fast.\n        ct, mt_encoding = mimetypes.guess_type(url)\n        # Then check for mimetype by actually requesting the resource and\n        # looking at the response.\n        # More accurate, but slower since we actually have to send a request.\n        if not ct:\n            response_info = response.info()\n            ct = (response_info.getheader('Content-Type') or '').split(';')[0]\n        #TODO:if still undefined, use magic.Magic(mime=True).from_file(url)?\n        if ct not in only_mime_types:\n            return\n    try:\n        #return response.read()\n        return response.text\n    except httplib.IncompleteRead as e:\n        # This should rarely happen, and is often the fault of the server\n        # sending a malformed response.\n        #TODO:just abandon all content and return '' instead?\n        return e.partial"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract text from a URL.", "response": "def extractFromURL(url,\n    cache=False,\n    cacheDir='_cache',\n    verbose=False,\n    encoding=None,\n    filters=None,\n    userAgent=None,\n    timeout=5,\n    blur=5,\n    ignore_robotstxt=False,\n    only_mime_types=None,\n    raw=False):\n    \"\"\"\n    Extracts text from a URL.\n\n    Parameters:\n    url := string\n        Remote URL or local filename where HTML will be read.\n    cache := bool\n        True=store and retrieve url from cache\n        False=always retrieve url from the web\n    cacheDir := str\n        Directory where cached url contents will be stored.\n    verbose := bool\n        True=print logging messages\n        False=print no output\n    encoding := string\n        The encoding of the page contents.\n        If none given, it will attempt to guess the encoding.\n        See http://docs.python.org/howto/unicode.html for further info\n        on Python Unicode and encoding support.\n    filters := string\n        Comma-delimited list of filters to apply before parsing.\n    only_mime_types := list of strings\n        A list of mime-types to limit parsing to.\n        If the mime-type of the raw-content retrieved does not match\n        one of these, a value of None will be returned.\n    \"\"\"\n\n    blur = int(blur)\n\n    try:\n        import chardet\n    except ImportError as e:\n        raise ImportError((\"%s\\nYou need to install chardet.\\n\" + \\\n             \"e.g. sudo pip install chardet\") % e)\n\n    if only_mime_types and isinstance(only_mime_types, six.text_type):\n        only_mime_types = only_mime_types.split(',')\n\n    # Load url from cache if enabled.\n    if cache:\n        if not os.path.isdir(cacheDir):\n            cache_perms = 488 # 750 in octal, '-rwxr-x---'\n            os.makedirs(cacheDir, cache_perms)\n\n        cache_key = generate_key(url)\n        cached_content = cache_get(cacheDir, cache_key)\n        if cached_content:\n            return cached_content\n\n    if not ignore_robotstxt:\n        if not check_robotstxt(url, cache, cacheDir, userAgent=userAgent):\n            if verbose: print(\"Request denied by robots.txt\")\n            return ''\n\n    # Otherwise download the url.\n    if verbose: print('Reading %s...' % url)\n    html = fetch(\n        url,\n        timeout=timeout,\n        userAgent=userAgent,\n        only_mime_types=only_mime_types)\n    if not html:\n        return ''\n\n    # If no encoding guess given, then attempt to determine\n    # encoding automatically.\n    if not encoding:\n        if isinstance(html, unicode):\n            html = html.encode('utf8', 'replace')\n        encoding_opinion = chardet.detect(html)\n        encoding = encoding_opinion['encoding']\n        if verbose: print('Using encoding %s.' % encoding)\n\n    # Save raw contents to cache if enabled.\n    if verbose: print('Read %i characters.' % len(html))\n    if cache:\n        raw_key = generate_key(url, \"%s.raw\")\n        cache_set(cacheDir, raw_key, html)\n\n    # Apply filters.\n    if filters:\n        filter_names = map(str.strip, filters.split(','))\n        for filter_name in filter_names:\n            fltr = get_filter(filter_name)\n            html = fltr(html)\n\n    # Clean up HTML.\n    html = tidyHTML(html)\n    if verbose: print('Extracted %i characters.' % len(html))\n\n    # Convert to Unicode.\n    if not html:\n        return ''\n    html = unicode(html, encoding=encoding, errors='replace')\n    if raw:\n        return html\n\n    # Extract text from HTML.\n    res = extractFromHTML(html, blur=blur)\n    assert isinstance(res, unicode)\n\n    # Save extracted text to cache if enabled.\n    res = res.encode(encoding, 'ignore')\n    if cache:\n        cache_set(cacheDir, cache_key, res)\n\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a shallow copy of self.", "response": "def copy(self):\n\t\t\"\"\"Create a shallow copy of self.\n\n\t\tThis runs in O(len(self.num_unique_elements()))\n\t\t\"\"\"\n\t\tout = self._from_iterable(None)\n\t\tout._dict = self._dict.copy()\n\t\tout._size = self._size\n\t\treturn out"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist the n most common elements and their counts.", "response": "def nlargest(self, n=None):\n\t\t\"\"\"List the n most common elements and their counts.\n\n\t\tList is from the most\n\t\tcommon to the least.  If n is None, the list all element counts.\n\n\t\tRun time should be O(m log m) where m is len(self)\n\t\tArgs:\n\t\t\tn (int): The number of elements to return\n\t\t\"\"\"\n\t\tif n is None:\n\t\t\treturn sorted(self.counts(), key=itemgetter(1), reverse=True)\n\t\telse:\n\t\t\treturn heapq.nlargest(n, self.counts(), key=itemgetter(1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a bag from a dict of elem - > count.", "response": "def from_mapping(cls, mapping):\n\t\t\"\"\"Create a bag from a dict of elem->count.\n\n\t\tEach key in the dict is added if the value is > 0.\n\n\t\tRaises:\n\t\t\tValueError: If any count is < 0.\n\t\t\"\"\"\n\t\tout = cls()\n\t\tfor elem, count in mapping.items():\n\t\t\tout._set_count(elem, count)\n\t\treturn out"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks that every element in self is a subset of other.", "response": "def is_subset(self, other):\n\t\t\"\"\"Check that every element in self has a count <= in other.\n\n\t\tArgs:\n\t\t\tother (Set)\n\t\t\"\"\"\n\t\tif isinstance(other, _basebag):\n\t\t\tfor elem, count in self.counts():\n\t\t\t\tif not count <= other.count(elem):\n\t\t\t\t\treturn False\n\t\telse:\n\t\t\tfor elem in self:\n\t\t\t\tif self.count(elem) > 1 or elem not in other:\n\t\t\t\t\treturn False\n\t\treturn True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd all of the elements of other to self.", "response": "def _iadd(self, other):\n\t\t\"\"\"Add all of the elements of other to self.\n\n\t\tif isinstance(it, _basebag):\n\t\t\t\tThis runs in O(it.num_unique_elements())\n\t\telse:\n\t\t\t\tThis runs in O(len(it))\n\t\t\"\"\"\n\t\tif isinstance(other, _basebag):\n\t\t\tfor elem, count in other.counts():\n\t\t\t\tself._increment_count(elem, count)\n\t\telse:\n\t\t\tfor elem in other:\n\t\t\t\tself._increment_count(elem, 1)\n\t\treturn self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _iand(self, other):\n\t\t# TODO do we have to create a bag from the other first?\n\t\tif not isinstance(other, _basebag):\n\t\t\tother = self._from_iterable(other)\n\t\tfor elem, old_count in set(self.counts()):\n\t\t\tother_count = other.count(elem)\n\t\t\tnew_count = min(other_count, old_count)\n\t\t\tself._set_count(elem, new_count)\n\t\treturn self", "response": "Sets multiplicity of each element to the minimum of the two collections."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets multiplicity of each element to the maximum of the two collections.", "response": "def _ior(self, other):\n\t\t\"\"\"Set multiplicity of each element to the maximum of the two collections.\n\n\t\tif isinstance(other, _basebag):\n\t\t\tThis runs in O(other.num_unique_elements())\n\t\telse:\n\t\t\tThis runs in O(len(other))\n\t\t\"\"\"\n\t\t# TODO do we have to create a bag from the other first?\n\t\tif not isinstance(other, _basebag):\n\t\t\tother = self._from_iterable(other)\n\t\tfor elem, other_count in other.counts():\n\t\t\told_count = self.count(elem)\n\t\t\tnew_count = max(other_count, old_count)\n\t\t\tself._set_count(elem, new_count)\n\t\treturn self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting self to the symmetric difference between the sets other.", "response": "def _ixor(self, other):\n\t\t\"\"\"Set self to the symmetric difference between the sets.\n\n\t\tif isinstance(other, _basebag):\n\t\t\tThis runs in O(other.num_unique_elements())\n\t\telse:\n\t\t\tThis runs in O(len(other))\n\t\t\"\"\"\n\t\tif isinstance(other, _basebag):\n\t\t\tfor elem, other_count in other.counts():\n\t\t\t\tcount = abs(self.count(elem) - other_count)\n\t\t\t\tself._set_count(elem, count)\n\t\telse:\n\t\t\t# Let a = self.count(elem) and b = other.count(elem)\n\t\t\t# if a >= b then elem is removed from self b times leaving a - b\n\t\t\t# if a < b then elem is removed from self a times then added (b - a)\n\t\t\t# times leaving a - a + (b - a) = b - a\n\t\t\tfor elem in other:\n\t\t\t\ttry:\n\t\t\t\t\tself._increment_count(elem, -1)\n\t\t\t\texcept ValueError:\n\t\t\t\t\tself._increment_count(elem, 1)\n\t\treturn self"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndiscarding the elements of other from self.", "response": "def _isub(self, other):\n\t\t\"\"\"Discard the elements of other from self.\n\n\t\tif isinstance(it, _basebag):\n\t\t\tThis runs in O(it.num_unique_elements())\n\t\telse:\n\t\t\tThis runs in O(len(it))\n\t\t\"\"\"\n\t\tif isinstance(other, _basebag):\n\t\t\tfor elem, other_count in other.counts():\n\t\t\t\ttry:\n\t\t\t\t\tself._increment_count(elem, -other_count)\n\t\t\t\texcept ValueError:\n\t\t\t\t\tself._set_count(elem, 0)\n\t\telse:\n\t\t\tfor elem in other:\n\t\t\t\ttry:\n\t\t\t\t\tself._increment_count(elem, -1)\n\t\t\t\texcept ValueError:\n\t\t\t\t\tpass\n\t\treturn self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_all(self, other):\n\t\tif not self.is_superset(other):\n\t\t\traise ValueError('Passed collection is not a subset of this bag')\n\t\tself.discard_all(other)", "response": "Removes all of the elems from other."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load(self,path):\n        try:\n            # Darwin requires dlopen to be called with mode RTLD_GLOBAL instead\n            # of the default RTLD_LOCAL.  Without this, you end up with\n            # libraries not being loadable, resulting in \"Symbol not found\"\n            # errors\n            if sys.platform == 'darwin':\n                return ctypes.CDLL(path, ctypes.RTLD_GLOBAL)\n            else:\n                return ctypes.cdll.LoadLibrary(path)\n        except OSError,e:\n            raise ImportError(e)", "response": "Given a path to a library load it."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles the bump subcommand", "response": "def run_bump(args):\n    \"\"\"\n    Handle the bump subcommand\n    :param args: Parsed command line arguments\n    :return: None, output is written to console\n    \"\"\"\n    commit_id = args.commit_id\n    image = args.image\n    branch = args.branch\n\n    try:\n        print(version_bump(image, branch, commit_id))\n    except DockerTagNamingException, de:\n        print(de)\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun git ls - files in the top - level project directory. Arguments go directly to execution call.", "response": "def git_ls_files(*cmd_args):\n    \"\"\"Run ``git ls-files`` in the top-level project directory. Arguments go\n    directly to execution call.\n\n    :return: set of file names\n    :rtype: :class:`set`\n    \"\"\"\n    cmd = ['git', 'ls-files']\n    cmd.extend(cmd_args)\n    return set(subprocess.check_output(cmd).splitlines())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning lint and return an exit code.", "response": "def _lint():\n    \"\"\"Run lint and return an exit code.\"\"\"\n    # Flake8 doesn't have an easy way to run checks using a Python function, so\n    # just fork off another process to do it.\n\n    # Python 3 compat:\n    # - The result of subprocess call outputs are byte strings, meaning we need\n    #   to pass a byte string to endswith.\n    project_python_files = [filename for filename in get_project_files()\n                            if filename.endswith(b'.py')]\n    retcode = subprocess.call(\n        ['flake8', '--max-complexity=10'] + project_python_files)\n    if retcode == 0:\n        print_success_message('No style errors')\n    return retcode"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlogin v2ex if possible otherwise we can t complete the mission.", "response": "def login(self):\n        \"\"\"Login v2ex, otherwise we can't complete the mission.\"\"\"\n        response = self.session.get(self.signin_url, verify=False)\n        user_param, password_param = self._get_hashed_params(response.text)\n        login_data = {\n            user_param: self.config['username'],\n            password_param: self.config['password'],\n            'once': self._get_once(response.text),\n            'next': '/'\n        }\n        headers = {'Referer': 'https://www.v2ex.com/signin'}\n        self.session.post(self.signin_url, headers=headers, data=login_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets hashed params which will be used when you login", "response": "def _get_hashed_params(self, page_text):\n        \"\"\"Get hashed params which will be used when you login, see issue#10\"\"\"\n        soup = BeautifulSoup(page_text, 'html.parser')\n        return [tag['name'] for tag in soup.find_all('input', class_='sl')]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget once which will be used when you login.", "response": "def _get_once(self, page_text):\n        \"\"\"Get once which will be used when you login.\"\"\"\n        soup = BeautifulSoup(page_text, 'html.parser')\n        once = soup.find('input', attrs={'name': 'once'})['value']\n        return once"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_money(self):\n        response = self.session.get(self.mission_url, verify=False)\n        soup = BeautifulSoup(response.text, 'html.parser')\n        onclick = soup.find('input', class_='super normal button')['onclick']\n        url = onclick.split('=', 1)[1][2:-2]\n\n        if url == '/balance':\n            return \"You have completed the mission today.\"\n        else:\n            headers = {'Referer': 'https://www.v2ex.com/mission/daily'}\n            data = {'once': url.split('=')[-1]}\n            self.session.get('https://www.v2ex.com'+url, verify=False,\n                             headers=headers, data=data)\n            balance = self._get_balance()\n            return balance", "response": "Complete daily mission then get the money."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_balance(self):\n        response = self.session.get(self.balance_url, verify=False)\n        soup = BeautifulSoup(response.text, 'html.parser')\n        first_line = soup.select(\n            \"table.data tr:nth-of-type(2)\")[0].text.strip().split('\\n')\n        total, today = first_line[-2:]\n        logging.info('%-26sTotal:%-8s', today, total)\n        return '\\n'.join([u\"Today: {0}\".format(today),\n                          \"Total: {0}\".format(total)])", "response": "Get to know how much you totally have and how much you get today."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_last(self):\n        response = self.session.get(self.mission_url, verify=False)\n        soup = BeautifulSoup(response.text, 'html.parser')\n        last = soup.select('#Main div')[-1].text\n        return last", "response": "Get to know how long you have kept signing in."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _save_log_pos_thread_runner(self):\n        _logger.debug('Start log pos saving thread')\n        while not self.save_log_pos_thread_stop_flag.wait(self.interval):\n            self._save_file_and_pos()\n        _logger.debug('Finish log pos saving thread')", "response": "Save the position into file after every second ArcGIS log file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving current position into file and reset _pos_changed flag", "response": "def _save_file_and_pos(self):\n        \"\"\" Save current position into file\n        \"\"\"\n        if not self._pos_changed:\n            return\n        with open(self.pos_storage_filename, 'w+') as f:\n            _pos = '%s:%s' % (self._log_file, self._log_pos)\n            _logger.debug('Saving position %s to file %s'\n                          % (_pos, self.pos_storage_filename))\n            f.write(_pos)\n            self._pos_changed = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read_file_and_pos(self):\n        try:\n            with open(self.pos_storage_filename, 'r+') as f:\n                _pos = f.read()\n                _logger.debug('Got position \"%s\" from file %s'\n                              % (_pos, self.pos_storage_filename))\n                if not _pos:\n                    return\n                log_file, log_pos = _pos.split(':')\n                try:\n                    log_file = str(log_file)\n                    log_pos = int(log_pos)\n                except (ValueError, TypeError) as e:\n                    _logger.critical('Can not read position: %s' % e)\n                    sys.exit(13)\n                self._log_file = log_file\n                self._log_pos = log_pos\n        except IOError as e:\n            _logger.error(e)", "response": "Read the last position from file store as current position\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the index of value between start and end.", "response": "def index(self, value, start=0, end=None):\n\t\t\"\"\"Return the index of value between start and end.\n\n\t\tBy default, the entire setlist is searched.\n\n\t\tThis runs in O(1)\n\n\t\tArgs:\n\t\t\tvalue: The value to find the index of\n\t\t\tstart (int): The index to start searching at (defaults to 0)\n\t\t\tend (int): The index to stop searching at (defaults to the end of the list)\n\t\tReturns:\n\t\t\tint: The index of the value\n\t\tRaises:\n\t\t\tValueError: If the value is not in the list or outside of start - end\n\t\t\tIndexError: If start or end are out of range\n\t\t\"\"\"\n\t\ttry:\n\t\t\tindex = self._dict[value]\n\t\texcept KeyError:\n\t\t\traise ValueError\n\t\telse:\n\t\t\tstart = self._fix_neg_index(start)\n\t\t\tend = self._fix_end_index(end)\n\t\t\tif start <= index and index < end:\n\t\t\t\treturn index\n\t\t\telse:\n\t\t\t\traise ValueError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the index of a subsequence.", "response": "def sub_index(self, sub, start=0, end=None):\n\t\t\"\"\"Return the index of a subsequence.\n\n\t\tThis runs in O(len(sub))\n\n\t\tArgs:\n\t\t\tsub (Sequence): An Iterable to search for\n\t\tReturns:\n\t\t\tint: The index of the first element of sub\n\t\tRaises:\n\t\t\tValueError: If sub isn't a subsequence\n\t\t\tTypeError: If sub isn't iterable\n\t\t\tIndexError: If start or end are out of range\n\t\t\"\"\"\n\t\tstart_index = self.index(sub[0], start, end)\n\t\tend = self._fix_end_index(end)\n\t\tif start_index + len(sub) > end:\n\t\t\traise ValueError\n\t\tfor i in range(1, len(sub)):\n\t\t\tif sub[i] != self[start_index + i]:\n\t\t\t\traise ValueError\n\t\treturn start_index"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pop(self, index=-1):\n\t\tvalue = self._list.pop(index)\n\t\tdel self._dict[value]\n\t\treturn value", "response": "Remove and return the item at index."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninserts value at index.", "response": "def insert(self, index, value):\n\t\t\"\"\"Insert value at index.\n\n\t\tArgs:\n\t\t\tindex (int): Index to insert value at\n\t\t\tvalue: Value to insert\n\t\tRaises:\n\t\t\tValueError: If value already in self\n\t\t\tIndexError: If start or end are out of range\n\t\t\"\"\"\n\t\tif value in self:\n\t\t\traise ValueError\n\t\tindex = self._fix_neg_index(index)\n\t\tself._dict[value] = index\n\t\tfor elem in self._list[index:]:\n\t\t\tself._dict[elem] += 1\n\t\tself._list.insert(index, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves the value from the list.", "response": "def remove(self, value):\n\t\t\"\"\"Remove value from self.\n\n\t\tArgs:\n\t\t\tvalue: Element to remove from self\n\t\tRaises:\n\t\t\tValueError: if element is already present\n\t\t\"\"\"\n\t\ttry:\n\t\t\tindex = self._dict[value]\n\t\texcept KeyError:\n\t\t\traise ValueError('Value \"%s\" is not present.')\n\t\telse:\n\t\t\tdel self[index]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate self to include only the difference with other.", "response": "def difference_update(self, other):\n\t\t\"\"\"Update self to include only the difference with other.\"\"\"\n\t\tother = set(other)\n\t\tindices_to_delete = set()\n\t\tfor i, elem in enumerate(self):\n\t\t\tif elem in other:\n\t\t\t\tindices_to_delete.add(i)\n\t\tif indices_to_delete:\n\t\t\tself._delete_values_by_index(indices_to_delete)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate self to include only the symmetric difference with other.", "response": "def symmetric_difference_update(self, other):\n\t\t\"\"\"Update self to include only the symmetric difference with other.\"\"\"\n\t\tother = setlist(other)\n\t\tindices_to_delete = set()\n\t\tfor i, item in enumerate(self):\n\t\t\tif item in other:\n\t\t\t\tindices_to_delete.add(i)\n\t\tfor item in other:\n\t\t\tself.add(item)\n\t\tself._delete_values_by_index(indices_to_delete)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshuffling all of the elements in self randomly.", "response": "def shuffle(self, random=None):\n\t\t\"\"\"Shuffle all of the elements in self randomly.\"\"\"\n\t\trandom_.shuffle(self._list, random=random)\n\t\tfor i, elem in enumerate(self._list):\n\t\t\tself._dict[elem] = i"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sort(self, *args, **kwargs):\n\t\tself._list.sort(*args, **kwargs)\n\t\tfor index, value in enumerate(self._list):\n\t\t\tself._dict[value] = index", "response": "Sort this setlist in place."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef swap(self, i, j):\n\t\ti = self._fix_neg_index(i)\n\t\tj = self._fix_neg_index(j)\n\t\tself._list[i], self._list[j] = self._list[j], self._list[i]\n\t\tself._dict[self._list[i]] = i\n\t\tself._dict[self._list[j]] = j", "response": "Swap the values at indices i & j."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets updated values from 2 dicts of values", "response": "def _get_updated_values(before_values, after_values):\n    \"\"\" Get updated values from 2 dicts of values\n\n    Args:\n        before_values (dict): values before update\n        after_values (dict): values after update\n\n    Returns:\n        dict: a diff dict with key is field key, value is tuple of\n              (before_value, after_value)\n    \"\"\"\n    assert before_values.keys() == after_values.keys()\n    return dict([(k, [before_values[k], after_values[k]])\n                 for k in before_values.keys()\n                 if before_values[k] != after_values[k]])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _convert_update_row(row):\n    after_values = row['after_values']  # type: dict\n    before_values = row['before_values']  # type: dict\n    values = after_values\n    return {\n        'values': values,\n        'updated_values': _get_updated_values(before_values, after_values)\n    }", "response": "Convert a row for update event\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a RowsEvent to a dict containing the data that is stored in the binlog file.", "response": "def _rows_event_to_dict(e, stream):\n    \"\"\" Convert RowsEvent to a dict\n\n    Args:\n        e (pymysqlreplication.row_event.RowsEvent): the event\n        stream (pymysqlreplication.BinLogStreamReader):\n            the stream that yields event\n\n    Returns:\n        dict: event's data as a dict\n    \"\"\"\n    pk_cols = e.primary_key if isinstance(e.primary_key, (list, tuple)) \\\n        else (e.primary_key, )\n\n    if isinstance(e, row_event.UpdateRowsEvent):\n        sig = signals.rows_updated\n        action = 'update'\n        row_converter = _convert_update_row\n    elif isinstance(e, row_event.WriteRowsEvent):\n        sig = signals.rows_inserted\n        action = 'insert'\n        row_converter = _convert_write_row\n    elif isinstance(e, row_event.DeleteRowsEvent):\n        sig = signals.rows_deleted\n        action = 'delete'\n        row_converter = _convert_write_row\n    else:\n        assert False, 'Invalid binlog event'\n\n    meta = {\n        'time': e.timestamp,\n        'log_pos': stream.log_pos,\n        'log_file': stream.log_file,\n        'schema': e.schema,\n        'table': e.table,\n        'action': action,\n    }\n    rows = list(map(row_converter, e.rows))\n    for row in rows:\n        row['keys'] = {k: row['values'][k] for k in pk_cols}\n    return rows, meta"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess a binlog event and send the corresponding table name and rows to the list of tables in the cluster.", "response": "def on_binlog(event, stream):\n    \"\"\" Process on a binlog event\n\n    1. Convert event instance into a dict\n    2. Send corresponding schema/table/signals\n\n    Args:\n        event (pymysqlreplication.row_event.RowsEvent): the event\n    \"\"\"\n    rows, meta = _rows_event_to_dict(event, stream)\n\n    table_name = '%s.%s' % (meta['schema'], meta['table'])\n\n    if meta['action'] == 'insert':\n        sig = signals.rows_inserted\n    elif meta['action'] == 'update':\n        sig = signals.rows_updated\n    elif meta['action'] == 'delete':\n        sig = signals.rows_deleted\n    else:\n        raise RuntimeError('Invalid action \"%s\"' % meta['action'])\n\n    sig.send(table_name, rows=rows, meta=meta)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hash_iterable(it):\n\thash_value = hash(type(it))\n\tfor value in it:\n\t\thash_value = hash((hash_value, value))\n\treturn hash_value", "response": "Perform a O ( 1 ) memory hash of an iterable of arbitrary length."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deprecated(msg, dep_version):\n\tdef wrapper(func):\n\t\tdocstring = func.__doc__ or ''\n\t\tdocstring_msg = '.. deprecated:: {version} {msg}'.format(\n\t\t\tversion=dep_version,\n\t\t\tmsg=msg,\n\t\t\t)\n\t\tif docstring:\n\t\t\t# We don't know how far to indent this message\n\t\t\t# so instead we just dedent everything.\n\t\t\tstring_list = docstring.splitlines()\n\t\t\tfirst_line = string_list[0]\n\t\t\tremaining = textwrap.dedent(''.join(string_list[1:]))\n\t\t\tdocstring = '\\n'.join([\n\t\t\t\tfirst_line,\n\t\t\t\tremaining,\n\t\t\t\t'',\n\t\t\t\tdocstring_msg,\n\t\t\t\t])\n\t\telse:\n\t\t\tdocstring = docstring_msg\n\t\tfunc.__doc__ = docstring\n\n\t\t@wraps(func)\n\t\tdef inner(*args, **kwargs):\n\t\t\twarnings.warn(msg, category=DeprecationWarning, stacklevel=2)\n\t\t\treturn func(*args, **kwargs)\n\n\t\treturn inner\n\n\treturn wrapper", "response": "Decorate a function method or class to mark as deprecated.\n\tRaise DeprecationWarning and add a deprecation notice to the docstring."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate MappedRanges for all mapped ranges.", "response": "def ranges(self, start=None, stop=None):\n\t\t\"\"\"Generate MappedRanges for all mapped ranges.\n\n\t\tYields:\n\t\t\tMappedRange\n\t\t\"\"\"\n\t\t_check_start_stop(start, stop)\n\t\tstart_loc = self._bisect_right(start)\n\t\tif stop is None:\n\t\t\tstop_loc = len(self._keys)\n\t\telse:\n\t\t\tstop_loc = self._bisect_left(stop)\n\t\tstart_val = self._values[start_loc - 1]\n\t\tcandidate_keys = [start] + self._keys[start_loc:stop_loc] + [stop]\n\t\tcandidate_values = [start_val] + self._values[start_loc:stop_loc]\n\t\tfor i, value in enumerate(candidate_values):\n\t\t\tif value is not NOT_SET:\n\t\t\t\tstart_key = candidate_keys[i]\n\t\t\t\tstop_key = candidate_keys[i + 1]\n\t\t\t\tyield MappedRange(start_key, stop_key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the value for a key.", "response": "def _getitem(self, key):\n\t\t\"\"\"Get the value for a key (not a slice).\"\"\"\n\t\tloc = self._bisect_right(key) - 1\n\t\tvalue = self._values[loc]\n\t\tif value is NOT_SET:\n\t\t\traise KeyError(key)\n\t\telse:\n\t\t\treturn value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_range(self, start=None, stop=None):\n\t\treturn self.from_iterable(self.ranges(start, stop))", "response": "Return a RangeMap for the range start to stop."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the range from start to stop to value.", "response": "def set(self, value, start=None, stop=None):\n\t\t\"\"\"Set the range from start to stop to value.\"\"\"\n\t\t_check_start_stop(start, stop)\n\t\t# start_index, stop_index will denote the sections we are replacing\n\t\tstart_index = self._bisect_left(start)\n\t\tif start is not None:  # start_index == 0\n\t\t\tprev_value = self._values[start_index - 1]\n\t\t\tif prev_value == value:\n\t\t\t\t# We're setting a range where the left range has the same\n\t\t\t\t# value, so create one big range\n\t\t\t\tstart_index -= 1\n\t\t\t\tstart = self._keys[start_index]\n\t\tif stop is None:\n\t\t\tnew_keys = [start]\n\t\t\tnew_values = [value]\n\t\t\tstop_index = len(self._keys)\n\t\telse:\n\t\t\tstop_index = self._bisect_right(stop)\n\t\t\tstop_value = self._values[stop_index - 1]\n\t\t\tstop_key = self._keys[stop_index - 1]\n\t\t\tif stop_key == stop and stop_value == value:\n\t\t\t\tnew_keys = [start]\n\t\t\t\tnew_values = [value]\n\t\t\telse:\n\t\t\t\tnew_keys = [start, stop]\n\t\t\t\tnew_values = [value, stop_value]\n\t\tself._keys[start_index:stop_index] = new_keys\n\t\tself._values[start_index:stop_index] = new_values"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete the range from start to stop from self. Raises KeyError if the range is not found in the map.", "response": "def delete(self, start=None, stop=None):\n\t\t\"\"\"Delete the range from start to stop from self.\n\n\t\tRaises:\n\t\t\tKeyError: If part of the passed range isn't mapped.\n\t\t\"\"\"\n\t\t_check_start_stop(start, stop)\n\t\tstart_loc = self._bisect_right(start) - 1\n\t\tif stop is None:\n\t\t\tstop_loc = len(self._keys)\n\t\telse:\n\t\t\tstop_loc = self._bisect_left(stop)\n\t\tfor value in self._values[start_loc:stop_loc]:\n\t\t\tif value is NOT_SET:\n\t\t\t\traise KeyError((start, stop))\n\t\t# this is inefficient, we've already found the sub ranges\n\t\tself.set(NOT_SET, start=start, stop=stop)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nemptying the range from start to stop.", "response": "def empty(self, start=None, stop=None):\n\t\t\"\"\"Empty the range from start to stop.\n\n\t\tLike delete, but no Error is raised if the entire range isn't mapped.\n\t\t\"\"\"\n\t\tself.set(NOT_SET, start=start, stop=stop)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the start key of the first range.", "response": "def start(self):\n\t\t\"\"\"Get the start key of the first range.\n\n\t\tNone if RangeMap is empty or unbounded to the left.\n\t\t\"\"\"\n\t\tif self._values[0] is NOT_SET:\n\t\t\ttry:\n\t\t\t\treturn self._keys[1]\n\t\t\texcept IndexError:\n\t\t\t\t# This is empty or everything is mapped to a single value\n\t\t\t\treturn None\n\t\telse:\n\t\t\t# This is unbounded to the left\n\t\t\treturn self._keys[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfilter all known plugins by a whitelist.", "response": "def get_tools(whitelist, known_plugins):\n    \"\"\"\n    Filter all known plugins by a whitelist specified. If the whitelist is\n    empty, default to all plugins.\n    \"\"\"\n    def getpath(c):\n        return \"%s:%s\" % (c.__module__, c.__class__.__name__)\n\n    tools = [x for x in known_plugins if getpath(x) in whitelist]\n\n    if not tools:\n        if whitelist:\n            raise UnknownTools(map(getpath, known_plugins))\n        tools = known_plugins\n    return tools"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_config(ctx, param, config_path):\n    if sys.argv[1] == 'init':\n        return\n    cfg = ctx.ensure_object(Config)\n    if config_path is None:\n        config_path = path.join(sys.path[0], 'v2ex_config.json')\n    if not path.exists(config_path):\n        sys.exit(\"Can't find config file at {0}.\\nPlease read \"\n                 \"https://github.com/lord63/v2ex_daily_mission \"\n                 \"to follow the guide.\".format(config_path))\n    cfg.load_config(config_path)\n    return config_path", "response": "Callback that is used whenever -- config is passed."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init(directory):\n    username = click.prompt(\"Input your username\")\n    password = click.prompt(\"Input your password\", hide_input=True,\n                            confirmation_prompt=True)\n    log_directory = click.prompt(\"Input your log directory\")\n\n    if not path.exists(log_directory):\n        sys.exit(\"Invalid log directory, please have a check.\")\n\n    config_file_path = path.join(directory, 'v2ex_config.json')\n    config = {\n        \"username\": username,\n        \"password\": password,\n        \"log_directory\": path.abspath(log_directory)\n    }\n    with open(config_file_path, 'w') as f:\n        json.dump(config, f)\n    click.echo(\"Init the config file at: {0}\".format(config_file_path))", "response": "Init the config fle."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsign in and get money.", "response": "def sign(conf):\n    \"\"\"Sign in and get money.\"\"\"\n    try:\n        v2ex = V2ex(conf.config)\n        v2ex.login()\n        balance = v2ex.get_money()\n        click.echo(balance)\n    except KeyError:\n        click.echo('Keyerror, please check your config file.')\n    except IndexError:\n        click.echo('Please check your username and password.')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef last(conf):\n    try:\n        v2ex = V2ex(conf.config)\n        v2ex.login()\n        last_date = v2ex.get_last()\n        click.echo(last_date)\n    except KeyError:\n        click.echo('Keyerror, please check your config file.')\n    except IndexError:\n        click.echo('Please check your username and password.')", "response": "How long you have kept signing in."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_uploads(text):\n    uploads = []\n    for match in UPLOAD_RE.finditer(text):\n        try:\n            upload = FileUpload.objects.get(slug=match.group(1))\n        except FileUpload.DoesNotExist:\n            continue\n        yield upload", "response": "Yields all the uploads referenced in the given text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a match object resulting from an UPLOAD_RE match and return a two - tuple where the first element is the FileUpload object and the second is a dictionary of the FileUpload key = value options.", "response": "def parse_match(match):\n    \"\"\"\n    Accept an re match object resulting from an ``UPLOAD_RE`` match\n    and return a two-tuple where the first element is the\n    corresponding ``FileUpload`` and the second is a dictionary of the\n    key=value options.\n\n    If there is no ``FileUpload`` object corresponding to the match,\n    the first element of the returned tuple is None.\n\n    \"\"\"\n    try:\n        upload = FileUpload.objects.get(slug=match.group(1))\n    except FileUpload.DoesNotExist:\n        upload = None\n    options = parse_options(match.group(2))\n    return (upload, options)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing options from a string in the form key = val key2 = val2 and returns a dictionary.", "response": "def parse_options(s):\n    \"\"\"\n    Expects a string in the form \"key=val:key2=val2\" and returns a\n    dictionary.\n\n    \"\"\"\n    options = {}\n    for option in s.split(':'):\n        if '=' in option:\n            key, val = option.split('=')\n            options[str(key).strip()] = val.strip()\n    return options"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build(self, jokers=False, num_jokers=0):\n        jokers = jokers or self.jokers\n        num_jokers = num_jokers or self.num_jokers\n\n        self.decks_used += 1\n\n        self.cards += build_cards(jokers, num_jokers)", "response": "Builds a standard 52 card French deck of Card instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of cards which are removed from the deck.", "response": "def deal(self, num=1, rebuild=False, shuffle=False, end=TOP):\n        \"\"\"\n        Returns a list of cards, which are removed from the deck.\n\n        :arg int num:\n            The number of cards to deal.\n        :arg bool rebuild:\n            Whether or not to rebuild the deck when cards run out.\n        :arg bool shuffle:\n            Whether or not to shuffle on rebuild.\n        :arg str end:\n            The end of the ``Stack`` to add the cards to. Can be ``TOP`` (\"top\")\n            or ``BOTTOM`` (\"bottom\").\n\n        :returns:\n            A given number of cards from the deck.\n\n        \"\"\"\n        _num = num\n\n        rebuild = rebuild or self.rebuild\n        re_shuffle = shuffle or self.re_shuffle\n\n        self_size = self.size\n\n        if rebuild or num <= self_size:\n            dealt_cards = [None] * num\n        elif num > self_size:\n            dealt_cards = [None] * self_size\n\n        while num > 0:\n            ends = {TOP: self.cards.pop, BOTTOM: self.cards.popleft}\n            n = _num - num\n            try:\n                card = ends[end]()\n                dealt_cards[n] = card\n                num -= 1\n            except:\n                if self.size == 0:\n                    if rebuild:\n                        self.build()\n                        if re_shuffle:\n                            self.shuffle()\n                    else:\n                        break\n\n        return Stack(cards=dealt_cards)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send(self, message):\n        self.socket.sendto(message.SerializeToString(), self.address)\n        return None", "response": "Sends a message over UDP and returns a response"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconnects to the given host", "response": "def connect(self):\n        \"\"\"Connects to the given host\"\"\"\n        self.socket = socket.create_connection(self.address, self.timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a message to a Riemann server and returns it s response", "response": "def send(self, message):\n        \"\"\"Sends a message to a Riemann server and returns it's response\n\n        :param message: The message to send to the Riemann server\n        :returns: The response message from Riemann\n        :raises RiemannError: if the server returns an error\n        \"\"\"\n        message = message.SerializeToString()\n        self.socket.sendall(struct.pack('!I', len(message)) + message)\n\n        length = struct.unpack('!I', self.socket.recv(4))[0]\n        response = riemann_client.riemann_pb2.Msg()\n        response.ParseFromString(socket_recvall(self.socket, length))\n\n        if not response.ok:\n            raise RiemannError(response.error)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconnecting using the base class TLSTransport. connect and wraps with TLS", "response": "def connect(self):\n        \"\"\"Connects using :py:meth:`TLSTransport.connect` and wraps with TLS\"\"\"\n        super(TLSTransport, self).connect()\n        self.socket = ssl.wrap_socket(\n            self.socket,\n            ssl_version=ssl.PROTOCOL_TLSv1,\n            cert_reqs=ssl.CERT_REQUIRED,\n            ca_certs=self.ca_certs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(self, message):\n        for event in message.events:\n            self.events.append(event)\n        reply = riemann_client.riemann_pb2.Msg()\n        reply.ok = True\n        return reply", "response": "Adds a message to the list returning a fake ok response"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves this item to the SDB.", "response": "def save(self, replace=True):\n        \"\"\"\n        Saves this item to SDB.\n        \n        :param bool replace: If ``True``, delete any attributes on the remote\n            SDB item that have a ``None`` value on this object.\n        \"\"\"\n        self.domain.put_attributes(self.name, self, replace)\n        # Delete any attributes set to \"None\"\n        if replace:\n            del_attrs = []\n            for name in self:\n                if self[name] == None:\n                    del_attrs.append(name)\n            if len(del_attrs) > 0:\n                self.domain.delete_attributes(self.name, del_attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_value(self, key, value):\n        if key in self:\n            # We already have this key on the item.\n            if not isinstance(self[key], list):\n                # The key isn't already a list, take its current value and\n                # convert it to a list with the only member being the\n                # current value.\n                self[key] = [self[key]]\n            # Add the new value to the list.\n            self[key].append(value)\n        else:\n            # This is a new attribute, just set it.\n            self[key] = value", "response": "Adds a value to the attribute of this item."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _in_version(self, *versions):\n        \"Returns true if this frame is in any of the specified versions of ID3.\"\n        for version in versions:\n            if (self._version == version\n                or (isinstance(self._version, collections.Container) \n                    and version in self._version)):\n                return True\n        return False", "response": "Returns true if this frame is in any of the specified versions of ID3."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the named spec.", "response": "def _spec(self, name):\n        \"Return the named spec.\"\n        for s in self._framespec:\n            if s.name == name:\n                return s\n        raise ValueError(\"Unknown spec: \" + name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the key exists on S3", "response": "def exists(self, callback=None):\n        \"\"\"\n        Returns True if the key exists\n\n        :rtype: bool\n        :return: Whether the key exists on S3\n        \"\"\"\n        def existence_tested(response):\n            if callable(callback):\n                callback(bool(response))\n        self.bucket.lookup(self.name, callback=existence_tested)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nuploading a file to a key into a bucket on S3.", "response": "def send_file(self, fp, headers=None, cb=None, num_cb=10,\n                  query_args=None, chunked_transfer=False, callback=None):\n        \"\"\"\n        Upload a file to a key into a bucket on S3.\n\n        :type fp: file\n        :param fp: The file pointer to upload\n\n        :type headers: dict\n        :param headers: The headers to pass along with the PUT request\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type num_cb: int\n        :param num_cb: (optional) If a callback is specified with the cb\n                       parameter this parameter determines the granularity\n                       of the callback by defining the maximum number of\n                       times the callback will be called during the file\n                       transfer. Providing a negative integer will cause\n                       your callback to be called with each buffer read.\n\n        \"\"\"\n        provider = self.bucket.connection.provider\n\n        def sender(http_conn, method, path, data, headers, sendback=None):\n            http_conn.putrequest(method, path)\n            for key in headers:\n                http_conn.putheader(key, headers[key])\n            http_conn.endheaders()\n            if chunked_transfer:\n                # MD5 for the stream has to be calculated on the fly, as\n                # we don't know the size of the stream before hand.\n                m = md5()\n            else:\n                fp.seek(0)\n\n            save_debug = self.bucket.connection.debug\n            self.bucket.connection.debug = 0\n            # If the debuglevel < 3 we don't want to show connection\n            # payload, so turn off HTTP connection-level debug output (to\n            # be restored below).\n            # Use the getattr approach to allow this to work in AppEngine.\n            if getattr(http_conn, 'debuglevel', 0) < 3:\n                http_conn.set_debuglevel(0)\n            if cb:\n                if chunked_transfer:\n                    # For chunked Transfer, we call the cb for every 1MB\n                    # of data transferred.\n                    cb_count = (1024 * 1024)/self.BufferSize\n                    self.size = 0\n                elif num_cb > 2:\n                    cb_count = self.size / self.BufferSize / (num_cb-2)\n                elif num_cb < 0:\n                    cb_count = -1\n                else:\n                    cb_count = 0\n                i = total_bytes = 0\n                cb(total_bytes, self.size)\n            l = fp.read(self.BufferSize)\n            while len(l) > 0:\n                if chunked_transfer:\n                    http_conn.send('%x;\\r\\n' % len(l))\n                    http_conn.send(l)\n                    http_conn.send('\\r\\n')\n                else:\n                    http_conn.send(l)\n                if cb:\n                    total_bytes += len(l)\n                    i += 1\n                    if i == cb_count or cb_count == -1:\n                        cb(total_bytes, self.size)\n                        i = 0\n                if chunked_transfer:\n                    m.update(l)\n                l = fp.read(self.BufferSize)\n            if chunked_transfer:\n                http_conn.send('0\\r\\n')\n                http_conn.send('\\r\\n')\n                if cb:\n                    self.size = total_bytes\n                # Get the md5 which is calculated on the fly.\n                self.md5 = m.hexdigest()\n            else:\n                fp.seek(0)\n            if cb:\n                cb(total_bytes, self.size)\n            def sender_sent(response):\n                body = response.read()\n                http_conn.set_debuglevel(save_debug)\n                self.bucket.connection.debug = save_debug\n                if ((response.status == 500 or response.status == 503 or\n                        response.getheader('location')) and not chunked_transfer):\n                    # we'll try again.\n                    if callable(sendback):\n                        sendback(response)\n                elif response.status >= 200 and response.status <= 299:\n                    self.etag = response.getheader('etag')\n                    if self.etag != '\"%s\"'  % self.md5:\n                        raise provider.storage_data_error(\n                            'ETag from S3 did not match computed MD5')\n                    if callable(sendback):\n                        sendback(response)\n                else:\n                    raise provider.storage_response_error(\n                        response.status, response.reason, body)\n            http_conn.getresponse(callback=sender_sent)\n\n        if not headers:\n            headers = {}\n        else:\n            headers = headers.copy()\n        headers['User-Agent'] = UserAgent\n        if self.base64md5:\n            headers['Content-MD5'] = self.base64md5\n        if self.storage_class != 'STANDARD':\n            headers[provider.storage_class_header] = self.storage_class\n        if headers.has_key('Content-Encoding'):\n            self.content_encoding = headers['Content-Encoding']\n        if headers.has_key('Content-Type'):\n            self.content_type = headers['Content-Type']\n        elif self.path:\n            self.content_type = mimetypes.guess_type(self.path)[0]\n            if self.content_type == None:\n                self.content_type = self.DefaultContentType\n            headers['Content-Type'] = self.content_type\n        else:\n            headers['Content-Type'] = self.content_type\n        if not chunked_transfer:\n            headers['Content-Length'] = str(self.size)\n#       headers['Expect'] = '100-Continue'\n        headers = boto.utils.merge_meta(headers, self.metadata, provider)\n        def file_sent(resp):\n            self.handle_version_headers(resp, force=True)\n            if callable(callback):\n                callback(resp)\n        self.bucket.connection.make_request('PUT', self.bucket.name,\n                                            self.name, headers,\n                                            sender=sender,\n                                            query_args=query_args, callback=file_sent)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstores an object using the name of the Key object as the key in cloud and the contents of the data stream pointed to by 'fp' as the contents. The stream object is not seekable and total size is not known. This has the implication that we can't specify the Content-Size and Content-MD5 in the header. So for huge uploads, the delay in calculating MD5 is avoided but with a penalty of inability to verify the integrity of the uploaded data. :type fp: file :param fp: the file whose contents are to be uploaded :type headers: dict :param headers: additional HTTP headers to be sent with the PUT request. :type replace: bool :param replace: If this parameter is False, the method will first check to see if an object exists in the bucket with the same key. If it does, it won't overwrite it. The default value is True which will overwrite the object. :type cb: function :param cb: a callback function that will be called to report progress on the upload. The callback should accept two integer parameters, the first representing the number of bytes that have been successfully transmitted to GS and the second representing the total number of bytes that need to be transmitted. :type num_cb: int :param num_cb: (optional) If a callback is specified with the cb parameter, this parameter determines the granularity of the callback by defining the maximum number of times the callback will be called during the file transfer. :type policy: :class:`boto.gs.acl.CannedACLStrings` :param policy: A canned ACL policy that will be applied to the new key in GS. :type reduced_redundancy: bool :param reduced_redundancy: If True, this will set the storage class of the new Key to be REDUCED_REDUNDANCY. The Reduced Redundancy Storage (RRS) feature of S3, provides lower redundancy at lower storage cost.", "response": "def set_contents_from_stream(self, fp, headers=None, replace=True,\n                                 cb=None, num_cb=10, policy=None,\n                                 reduced_redundancy=False, query_args=None, callback=None):\n        \"\"\"\n        Store an object using the name of the Key object as the key in\n        cloud and the contents of the data stream pointed to by 'fp' as\n        the contents.\n        The stream object is not seekable and total size is not known.\n        This has the implication that we can't specify the Content-Size and\n        Content-MD5 in the header. So for huge uploads, the delay in calculating\n        MD5 is avoided but with a penalty of inability to verify the integrity\n        of the uploaded data.\n\n        :type fp: file\n        :param fp: the file whose contents are to be uploaded\n\n        :type headers: dict\n        :param headers: additional HTTP headers to be sent with the PUT request.\n\n        :type replace: bool\n        :param replace: If this parameter is False, the method will first check\n            to see if an object exists in the bucket with the same key. If it\n            does, it won't overwrite it. The default value is True which will\n            overwrite the object.\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n            progress on the upload. The callback should accept two integer\n            parameters, the first representing the number of bytes that have\n            been successfully transmitted to GS and the second representing the\n            total number of bytes that need to be transmitted.\n\n        :type num_cb: int\n        :param num_cb: (optional) If a callback is specified with the cb\n            parameter, this parameter determines the granularity of the callback\n            by defining the maximum number of times the callback will be called\n            during the file transfer.\n\n        :type policy: :class:`boto.gs.acl.CannedACLStrings`\n        :param policy: A canned ACL policy that will be applied to the new key\n            in GS.\n\n        :type reduced_redundancy: bool\n        :param reduced_redundancy: If True, this will set the storage\n                                   class of the new Key to be\n                                   REDUCED_REDUNDANCY. The Reduced Redundancy\n                                   Storage (RRS) feature of S3, provides lower\n                                   redundancy at lower storage cost.\n        \"\"\"\n\n        provider = self.bucket.connection.provider\n        if not provider.supports_chunked_transfer():\n            raise BotoClientError('%s does not support chunked transfer'\n                % provider.get_provider_name())\n\n        # Name of the Object should be specified explicitly for Streams.\n        if not self.name or self.name == '':\n            raise BotoClientError('Cannot determine the destination '\n                                'object name for the given stream')\n\n        if headers is None:\n            headers = {}\n        if policy:\n            headers[provider.acl_header] = policy\n\n        # Set the Transfer Encoding for Streams.\n        headers['Transfer-Encoding'] = 'chunked'\n\n        if reduced_redundancy:\n            self.storage_class = 'REDUCED_REDUNDANCY'\n            if provider.storage_class_header:\n                headers[provider.storage_class_header] = self.storage_class\n\n        if self.bucket != None:\n            if not replace:\n                def existence_tested(k):\n                    if k:\n                        if callable(callback):\n                            callback(False)\n                    else:\n                        self.send_file(fp, headers, cb, num_cb, query_args,\n                                                        chunked_transfer=True, callback=callback)\n                self.bucket.lookup(self.name, callback=existence_tested)\n                return\n            self.send_file(fp, headers, cb, num_cb, query_args,\n                                            chunked_transfer=True, callback=callback)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_contents_from_file(self, fp, headers=None, replace=True,\n                               cb=None, num_cb=10, policy=None, md5=None,\n                               reduced_redundancy=False, query_args=None,\n                               encrypt_key=False, callback=None):\n        \"\"\"\n        Store an object in S3 using the name of the Key object as the\n        key in S3 and the contents of the file pointed to by 'fp' as the\n        contents.\n\n        :type fp: file\n        :param fp: the file whose contents to upload\n\n        :type headers: dict\n        :param headers: Additional HTTP headers that will be sent with\n                        the PUT request.\n\n        :type replace: bool\n        :param replace: If this parameter is False, the method\n                        will first check to see if an object exists in the\n                        bucket with the same key.  If it does, it won't\n                        overwrite it.  The default value is True which will\n                        overwrite the object.\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with the cb\n                       parameter this parameter determines the granularity\n                       of the callback by defining the maximum number of\n                       times the callback will be called during the\n                       file transfer.\n\n        :type policy: :class:`boto.s3.acl.CannedACLStrings`\n        :param policy: A canned ACL policy that will be applied to the\n                       new key in S3.\n\n        :type md5: A tuple containing the hexdigest version of the MD5\n                   checksum of the file as the first element and the\n                   Base64-encoded version of the plain checksum as the\n                   second element.  This is the same format returned by\n                   the compute_md5 method.\n        :param md5: If you need to compute the MD5 for any reason prior\n                    to upload, it's silly to have to do it twice so this\n                    param, if present, will be used as the MD5 values of\n                    the file.  Otherwise, the checksum will be computed.\n\n        :type reduced_redundancy: bool\n        :param reduced_redundancy: If True, this will set the storage\n                                   class of the new Key to be\n                                   REDUCED_REDUNDANCY. The Reduced Redundancy\n                                   Storage (RRS) feature of S3, provides lower\n                                   redundancy at lower storage cost.\n\n        :type encrypt_key: bool\n        :param encrypt_key: If True, the new copy of the object will\n                            be encrypted on the server-side by S3 and\n                            will be stored in an encrypted form while\n                            at rest in S3.\n        \"\"\"\n        provider = self.bucket.connection.provider\n        if headers is None:\n            headers = {}\n        if policy:\n            headers[provider.acl_header] = policy\n        if encrypt_key:\n            headers[provider.server_side_encryption_header] = 'AES256'\n\n        if reduced_redundancy:\n            self.storage_class = 'REDUCED_REDUNDANCY'\n            if provider.storage_class_header:\n                headers[provider.storage_class_header] = self.storage_class\n                # TODO - What if provider doesn't support reduced reduncancy?\n                # What if different providers provide different classes?\n        if hasattr(fp, 'name'):\n            self.path = fp.name\n        if self.bucket != None:\n            if not md5:\n                md5 = self.compute_md5(fp)\n            else:\n                # even if md5 is provided, still need to set size of content\n                fp.seek(0, 2)\n                self.size = fp.tell()\n                fp.seek(0)\n            self.md5 = md5[0]\n            self.base64md5 = md5[1]\n            if self.name == None:\n                self.name = self.md5\n            if not replace:\n                def existence_tested(k):\n                    if k:\n                        if callable(callback):\n                            callback(False)\n                    else:\n                        self.send_file(fp, headers, cb, num_cb, query_args, callback=callback)\n                self.bucket.lookup(self.name, callback=existence_tested)\n                return\n            self.send_file(fp, headers, cb, num_cb, query_args, callback=callback)", "response": "This method will upload an object from a file to the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving a file from an S3 Key :type fp: file :param fp: File pointer to put the data into :type headers: string :param: headers to send when retrieving the files :type cb: function :param cb: a callback function that will be called to report progress on the upload. The callback should accept two integer parameters, the first representing the number of bytes that have been successfully transmitted to S3 and the second representing the size of the to be transmitted object. :type cb: int :param num_cb: (optional) If a callback is specified with the cb parameter this parameter determines the granularity of the callback by defining the maximum number of times the callback will be called during the file transfer. :type torrent: bool :param torrent: Flag for whether to get a torrent for the file :type override_num_retries: int :param override_num_retries: If not None will override configured num_retries parameter for underlying GET. :type response_headers: dict :param response_headers: A dictionary containing HTTP headers/values that will override any headers associated with the stored object in the response. See http://goo.gl/EWOPb for details.", "response": "def get_file(self, fp, headers=None, cb=None, num_cb=10,\n                 torrent=False, version_id=None, override_num_retries=None,\n                 response_headers=None, callback=None):\n        \"\"\"\n        Retrieves a file from an S3 Key\n\n        :type fp: file\n        :param fp: File pointer to put the data into\n\n        :type headers: string\n        :param: headers to send when retrieving the files\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with\n                       the cb parameter this parameter determines the\n                       granularity of the callback by defining\n                       the maximum number of times the callback will\n                       be called during the file transfer.\n\n        :type torrent: bool\n        :param torrent: Flag for whether to get a torrent for the file\n\n        :type override_num_retries: int\n        :param override_num_retries: If not None will override configured\n                                     num_retries parameter for underlying GET.\n\n        :type response_headers: dict\n        :param response_headers: A dictionary containing HTTP headers/values\n                                 that will override any headers associated with\n                                 the stored object in the response.\n                                 See http://goo.gl/EWOPb for details.\n        \"\"\"\n        if cb:\n            if num_cb > 2:\n                cb_count = self.size / self.BufferSize / (num_cb-2)\n            elif num_cb < 0:\n                cb_count = -1\n            else:\n                cb_count = 0\n            i = total_bytes = 0\n            cb(total_bytes, self.size)\n        save_debug = self.bucket.connection.debug\n        if self.bucket.connection.debug == 1:\n            self.bucket.connection.debug = 0\n\n        query_args = []\n        if torrent:\n            query_args.append('torrent')\n        # If a version_id is passed in, use that.  If not, check to see\n        # if the Key object has an explicit version_id and, if so, use that.\n        # Otherwise, don't pass a version_id query param.\n        if version_id is None:\n            version_id = self.version_id\n        if version_id:\n            query_args.append('versionId=%s' % version_id)\n        if response_headers:\n            for key in response_headers:\n                query_args.append('%s=%s' % (key, response_headers[key]))\n        query_args = '&'.join(query_args)\n        def file_got(response):\n            body = self.resp.read()\n            fp.write(body)\n            if cb:\n                cb(total_bytes, self.size)\n            self.close()\n            self.bucket.connection.debug = save_debug\n            if callable(callback):\n                callback(response)\n        self.open('r', headers, query_args=query_args,\n                  override_num_retries=override_num_retries, callback=file_got)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve an object from S3 using the name of the Key object as the key in S3. Store contents of the object to a file named by 'filename'. See get_contents_to_file method for details about the parameters. :type filename: string :param filename: The filename of where to put the file contents :type headers: dict :param headers: Any additional headers to send in the request :type cb: function :param cb: a callback function that will be called to report progress on the upload. The callback should accept two integer parameters, the first representing the number of bytes that have been successfully transmitted to S3 and the second representing the size of the to be transmitted object. :type cb: int :param num_cb: (optional) If a callback is specified with the cb parameter this parameter determines the granularity of the callback by defining the maximum number of times the callback will be called during the file transfer. :type torrent: bool :param torrent: If True, returns the contents of a torrent file as a string. :type res_upload_handler: ResumableDownloadHandler :param res_download_handler: If provided, this handler will perform the download. :type response_headers: dict :param response_headers: A dictionary containing HTTP headers/values that will override any headers associated with the stored object in the response. See http://goo.gl/EWOPb for details.", "response": "def get_contents_to_filename(self, filename, headers=None,\n                                 cb=None, num_cb=10,\n                                 torrent=False,\n                                 version_id=None,\n                                 res_download_handler=None,\n                                 response_headers=None, callback=None):\n        \"\"\"\n        Retrieve an object from S3 using the name of the Key object as the\n        key in S3.  Store contents of the object to a file named by 'filename'.\n        See get_contents_to_file method for details about the\n        parameters.\n\n        :type filename: string\n        :param filename: The filename of where to put the file contents\n\n        :type headers: dict\n        :param headers: Any additional headers to send in the request\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with\n                       the cb parameter this parameter determines the\n                       granularity of the callback by defining\n                       the maximum number of times the callback will\n                       be called during the file transfer.\n\n        :type torrent: bool\n        :param torrent: If True, returns the contents of a torrent file\n                        as a string.\n\n        :type res_upload_handler: ResumableDownloadHandler\n        :param res_download_handler: If provided, this handler will\n                                     perform the download.\n\n        :type response_headers: dict\n        :param response_headers: A dictionary containing HTTP headers/values\n                                 that will override any headers associated with\n                                 the stored object in the response.\n                                 See http://goo.gl/EWOPb for details.\n        \"\"\"\n        fp = open(filename, 'wb')\n        def got_contents_to_filename(response):\n            fp.close()\n            # if last_modified date was sent from s3, try to set file's timestamp\n            if self.last_modified != None:\n                try:\n                    modified_tuple = rfc822.parsedate_tz(self.last_modified)\n                    modified_stamp = int(rfc822.mktime_tz(modified_tuple))\n                    os.utime(fp.name, (modified_stamp, modified_stamp))\n                except Exception: pass\n            if callable(callback):\n                callback(response)\n        self.get_contents_to_file(fp, headers, cb, num_cb, torrent=torrent,\n                                  version_id=version_id,\n                                  res_download_handler=res_download_handler,\n                                  response_headers=response_headers, callback=got_contents_to_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_contents_as_string(self, headers=None,\n                               cb=None, num_cb=10,\n                               torrent=False,\n                               version_id=None,\n                               response_headers=None, callback=None):\n        \"\"\"\n        Retrieve an object from S3 using the name of the Key object as the\n        key in S3.  Return the contents of the object as a string.\n        See get_contents_to_file method for details about the\n        parameters.\n\n        :type headers: dict\n        :param headers: Any additional headers to send in the request\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with\n                       the cb parameter this parameter determines the\n                       granularity of the callback by defining\n                       the maximum number of times the callback will\n                       be called during the file transfer.\n\n        :type torrent: bool\n        :param torrent: If True, returns the contents of a torrent file\n                        as a string.\n\n        :type response_headers: dict\n        :param response_headers: A dictionary containing HTTP headers/values\n                                 that will override any headers associated with\n                                 the stored object in the response.\n                                 See http://goo.gl/EWOPb for details.\n\n        :rtype: string\n        :returns: The contents of the file as a string\n        \"\"\"\n        fp = StringIO.StringIO()\n        def got_contents_as_string(response):\n            if callable(callback):\n                callback(fp.getvalue())\n        self.get_contents_to_file(fp, headers, cb, num_cb, torrent=torrent,\n                                  version_id=version_id,\n                                  response_headers=response_headers, callback=got_contents_as_string)", "response": "This method returns the contents of the object in S3 as a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_tag_data(data):\n    \"Raise a ValueError if DATA doesn't seem to be a well-formed ID3 tag.\"\n    if len(data) < 10:\n        raise ValueError(\"Tag too short\")\n    if data[0:3] != b\"ID3\":\n        raise ValueError(\"Missing ID3 identifier\")\n    if data[3] >= 5 or data[4] != 0:\n        raise ValueError(\"Unknown ID3 version\")\n    length = stagger.conversion.Syncsafe.decode(data[6:10]) + 10\n    if len(data) != length:\n        raise ValueError(\"Tag size mismatch\")", "response": "Raise a ValueError if DATA doesn t seem to be a well - formed ID3 tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the ID3 tag in FILENAME as a raw byte string.", "response": "def get_raw_tag_data(filename):\n    \"Return the ID3 tag in FILENAME as a raw byte string.\"\n    with open(filename, \"rb\") as file:\n        try:\n            (cls, offset, length) = stagger.tags.detect_tag(file)\n        except stagger.NoTagError:\n            return bytes()\n        file.seek(offset)\n        return file.read(length)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_raw_tag_data(filename, data, act=True, verbose=False):\n    \"Replace the ID3 tag in FILENAME with DATA.\"\n    check_tag_data(data)\n    with open(filename, \"rb+\") as file:\n        try:\n            (cls, offset, length) = stagger.tags.detect_tag(file)\n        except stagger.NoTagError:\n            (offset, length) = (0, 0)\n        if length > 0:\n            verb(verbose, \"{0}: replaced tag with {1} bytes of data\"\n                 .format(filename, len(data)))\n        else:\n            verb(verbose, \"{0}: created tag with {1} bytes of data\"\n                 .format(filename, len(data)))\n        if act:\n            stagger.fileutil.replace_chunk(file, offset, length, data)", "response": "Replace the ID3 tag in FILENAME with DATA."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_params(self, params, i):\n        prefix = 'Tags.member.%d.' % i\n        params[prefix+'ResourceId'] = self.resource_id\n        params[prefix+'ResourceType'] = self.resource_type\n        params[prefix+'Key'] = self.key\n        params[prefix+'Value'] = self.value\n        if self.propagate_at_launch:\n            params[prefix+'PropagateAtLaunch'] = 'true'\n        else:\n            params[prefix+'PropagateAtLaunch'] = 'false'", "response": "Builds the dictionary with the name and value pairs necessary to identify this Tag in a request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new SQS Queue.", "response": "def create_queue(self, queue_name, visibility_timeout=None):\n        \"\"\"\n        Create an SQS Queue.\n\n        :type queue_name: str or unicode\n        :param queue_name: The name of the new queue.  Names are scoped to\n                           an account and need to be unique within that\n                           account.  Calling this method on an existing\n                           queue name will not return an error from SQS\n                           unless the value for visibility_timeout is\n                           different than the value of the existing queue\n                           of that name.  This is still an expensive operation,\n                           though, and not the preferred way to check for\n                           the existence of a queue.  See the\n                           :func:`boto.sqs.connection.SQSConnection.lookup` method.\n\n        :type visibility_timeout: int\n        :param visibility_timeout: The default visibility timeout for all\n                                   messages written in the queue.  This can\n                                   be overridden on a per-message.\n\n        :rtype: :class:`boto.sqs.queue.Queue`\n        :return: The newly created queue.\n\n        \"\"\"\n        params = {'QueueName': queue_name}\n        if visibility_timeout:\n            params['Attribute.1.Name'] = 'VisibilityTimeout'\n            params['Attribute.1.Value'] = int(visibility_timeout)\n        return self.get_object('CreateQueue', params, Queue)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_message(self, queue, message):\n        params = {'ReceiptHandle' : message.receipt_handle}\n        return self.get_status('DeleteMessage', params, queue.id)", "response": "Delete a message from a queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_message_from_handle(self, queue, receipt_handle):\n        params = {'ReceiptHandle' : receipt_handle}\n        return self.get_status('DeleteMessage', params, queue.id)", "response": "Delete a message from a queue given a receipt handle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending up to 10 messages to a queue in a single request.", "response": "def send_message_batch(self, queue, messages):\n        \"\"\"\n        Delivers up to 10 messages to a queue in a single request.\n\n        :type queue: A :class:`boto.sqs.queue.Queue` object.\n        :param queue: The Queue to which the messages will be written.\n\n        :type messages: List of lists.\n        :param messages: A list of lists or tuples.  Each inner\n            tuple represents a single message to be written\n            and consists of and ID (string) that must be unique\n            within the list of messages, the message body itself\n            which can be a maximum of 64K in length, and an\n            integer which represents the delay time (in seconds)\n            for the message (0-900) before the message will\n            be delivered to the queue.\n        \"\"\"\n        params = {}\n        for i, msg in enumerate(messages):\n            p_name = 'SendMessageBatchRequestEntry.%i.Id' % (i+1)\n            params[p_name] = msg[0]\n            p_name = 'SendMessageBatchRequestEntry.%i.MessageBody' % (i+1)\n            params[p_name] = msg[1]\n            p_name = 'SendMessageBatchRequestEntry.%i.DelaySeconds' % (i+1)\n            params[p_name] = msg[2]\n        return self.get_object('SendMessageBatch', params, BatchResults,\n                               queue.id, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_queues(self, prefix=''):\n        params = {}\n        if prefix:\n            params['QueueNamePrefix'] = prefix\n        return self.get_list('ListQueues', params, [('QueueUrl', Queue)])", "response": "Retrieves all queues in the current region."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nretrieve the queue with the given name or None if no match was found.", "response": "def get_queue(self, queue_name):\n        \"\"\"\n        Retrieves the queue with the given name, or ``None`` if no match\n        was found.\n\n        :param str queue_name: The name of the queue to retrieve.\n        :rtype: :py:class:`boto.sqs.queue.Queue` or ``None``\n        :returns: The requested queue, or ``None`` if no match was found.\n        \"\"\"\n        rs = self.get_all_queues(queue_name)\n        for q in rs:\n            if q.url.endswith(queue_name):\n                return q\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_permission(self, queue, label):\n        params = {'Label': label}\n        return self.get_status('RemovePermission', params, queue.id)", "response": "Remove a permission from a queue."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the appropriate Manager class for a given Model class.", "response": "def get_manager(cls):\n    \"\"\"\n    Returns the appropriate Manager class for a given Model class.  It does this by\n    looking in the boto config for a section like this::\n    \n        [DB]\n        db_type = SimpleDB\n        db_user = <aws access key id>\n        db_passwd = <aws secret access key>\n        db_name = my_domain\n        [DB_TestBasic]\n        db_type = SimpleDB\n        db_user = <another aws access key id>\n        db_passwd = <another aws secret access key>\n        db_name = basic_domain\n        db_port = 1111\n    \n    The values in the DB section are \"generic values\" that will be used if nothing more\n    specific is found.  You can also create a section for a specific Model class that\n    gives the db info for that class.  In the example above, TestBasic is a Model subclass.\n    \"\"\"\n    db_user = boto.config.get('DB', 'db_user', None)\n    db_passwd = boto.config.get('DB', 'db_passwd', None)\n    db_type = boto.config.get('DB', 'db_type', 'SimpleDB')\n    db_name = boto.config.get('DB', 'db_name', None)\n    db_table = boto.config.get('DB', 'db_table', None)\n    db_host = boto.config.get('DB', 'db_host', \"sdb.amazonaws.com\")\n    db_port = boto.config.getint('DB', 'db_port', 443)\n    enable_ssl = boto.config.getbool('DB', 'enable_ssl', True)\n    sql_dir = boto.config.get('DB', 'sql_dir', None)\n    debug = boto.config.getint('DB', 'debug', 0)\n    # first see if there is a fully qualified section name in the Boto config file\n    module_name = cls.__module__.replace('.', '_')\n    db_section = 'DB_' + module_name + '_' + cls.__name__\n    if not boto.config.has_section(db_section):\n        db_section = 'DB_' + cls.__name__\n    if boto.config.has_section(db_section):\n        db_user = boto.config.get(db_section, 'db_user', db_user)\n        db_passwd = boto.config.get(db_section, 'db_passwd', db_passwd)\n        db_type = boto.config.get(db_section, 'db_type', db_type)\n        db_name = boto.config.get(db_section, 'db_name', db_name)\n        db_table = boto.config.get(db_section, 'db_table', db_table)\n        db_host = boto.config.get(db_section, 'db_host', db_host)\n        db_port = boto.config.getint(db_section, 'db_port', db_port)\n        enable_ssl = boto.config.getint(db_section, 'enable_ssl', enable_ssl)\n        debug = boto.config.getint(db_section, 'debug', debug)\n    elif hasattr(cls, \"_db_name\") and cls._db_name is not None:\n        # More specific then the generic DB config is any _db_name class property\n        db_name = cls._db_name\n    elif hasattr(cls.__bases__[0], \"_manager\"):\n        return cls.__bases__[0]._manager\n    if db_type == 'SimpleDB':\n        from sdbmanager import SDBManager\n        return SDBManager(cls, db_name, db_user, db_passwd,\n                          db_host, db_port, db_table, sql_dir, enable_ssl)\n    elif db_type == 'PostgreSQL':\n        from pgmanager import PGManager\n        if db_table:\n            return PGManager(cls, db_name, db_user, db_passwd,\n                             db_host, db_port, db_table, sql_dir, enable_ssl)\n        else:\n            return None\n    elif db_type == 'XML':\n        from xmlmanager import XMLManager\n        return XMLManager(cls, db_name, db_user, db_passwd,\n                          db_host, db_port, db_table, sql_dir, enable_ssl)\n    else:\n        raise ValueError, 'Unknown db_type: %s' % db_type"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nincreases counter by one and check whether a period is end", "response": "def increase_and_check_counter(self):\n        ''' increase counter by one and check whether a period is end '''\n        self.counter += 1\n        self.counter %= self.period\n        if not self.counter:\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tickUpdate(self, tick_dict):\n        ''' consume ticks '''\n        assert self.symbols\n        assert self.symbols[0] in tick_dict.keys()\n        symbol=self.symbols[0]\n        tick=tick_dict[symbol]\n\n        if self.increase_and_check_counter():\n            self.place_order(Order(account=self.account,\n                                  action=Action.BUY,\n                                  is_market=True,\n                                  symbol=symbol,\n                                  price=tick.close,\n                                  share=self.per_amount / float(tick.close)))", "response": "update the order with the tick dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmatch template and find exactly one match in the Image using specified features.", "response": "def match_one(template, image, options=None):\n    \"\"\"\n    Match template and find exactly one match in the Image using specified features.\n\n    :param template: Template Image\n    :param image: Search Image\n    :param options: Options include\n        - features: List of options for each feature\n    :return: (Box, Score) Bounding box of the matched object, Heatmap value\n    \"\"\"\n    heatmap, scale = multi_feat_match(template, image, options)\n\n    min_val, _, min_loc, _ = cv.minMaxLoc(heatmap)\n    top_left = tuple(scale * x for x in min_loc)\n    score = min_val\n\n    h, w = template.shape[:2]\n    return Box(top_left[0], top_left[1], w, h), score"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef multi_feat_match(template, image, options=None):\n    h, w = image.shape[:2]\n    scale = 1\n    if options is not None and 'features' in options:\n        heatmap = np.zeros((h, w), dtype=np.float64)\n        for foptions in options['features']:\n            f_hmap, _ = feature_match(template, image, foptions)\n            heatmap += cv.resize(f_hmap, (w, h), interpolation=cv.INTER_AREA)\n        heatmap /= len(options['features'])\n    else:\n        heatmap, scale = feature_match(template, image, options)\n    return heatmap, scale", "response": "Match template and image by extracting multiple features from it."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmatches template and image by extracting specified feature", "response": "def feature_match(template, image, options=None):\n    \"\"\"\n    Match template and image by extracting specified feature\n\n    :param template: Template image\n    :param image: Search image\n    :param options: Options include\n        - feature: Feature extractor to use. Default is 'rgb'. Available options are:\n            'hog', 'lab', 'rgb', 'gray'\n    :return: Heatmap\n    \"\"\"\n    op = _DEF_TM_OPT.copy()\n    if options is not None:\n        op.update(options)\n\n    feat = fe.factory(op['feature'])\n    tmpl_f = feat(template, op)\n    img_f = feat(image, op)\n\n    scale = image.shape[0] / img_f.shape[0]\n    heatmap = match_template(tmpl_f, img_f, op)\n    return heatmap, scale"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmatch template using OpenCV template matching implementation.", "response": "def match_template_opencv(template, image, options):\n    \"\"\"\n    Match template using OpenCV template matching implementation.\n        Limited by number of channels as maximum of 3.\n        Suitable for direct RGB or Gray-scale matching\n\n    :param options: Other options:\n        - distance: Distance measure to use. (euclidean | correlation | ccoeff).\n            Default: 'correlation'\n        - normalize: Heatmap values will be in the range of 0 to 1. Default: True\n        - retain_size: Whether to retain the same size as input image. Default: True\n    :return: Heatmap\n    \"\"\"\n    # if image has more than 3 channels, use own implementation\n    if len(image.shape) > 3:\n        return match_template(template, image, options)\n\n    op = _DEF_TM_OPT.copy()\n    if options is not None:\n        op.update(options)\n\n    method = cv.TM_CCORR_NORMED\n    if op['normalize'] and op['distance'] == 'euclidean':\n        method = cv.TM_SQDIFF_NORMED\n    elif op['distance'] == 'euclidean':\n        method = cv.TM_SQDIFF\n    elif op['normalize'] and op['distance'] == 'ccoeff':\n        method = cv.TM_CCOEFF_NORMED\n    elif op['distance'] == 'ccoeff':\n        method = cv.TM_CCOEFF\n    elif not op['normalize'] and op['distance'] == 'correlation':\n        method = cv.TM_CCORR\n\n    heatmap = cv.matchTemplate(image, template, method)\n\n    # make minimum peak heatmap\n    if method not in [cv.TM_SQDIFF, cv.TM_SQDIFF_NORMED]:\n        heatmap = heatmap.max() - heatmap\n\n    if op['normalize']:\n        heatmap /= heatmap.max()\n\n    # size\n    if op['retain_size']:\n        hmap = np.ones(image.shape[:2]) * heatmap.max()\n        h, w = heatmap.shape\n        hmap[:h, :w] = heatmap\n        heatmap = hmap\n\n    return heatmap"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resp_json(resp):\n    if isinstance(resp, flask.Response):\n        if 400 <= resp.status_code < 600:\n            msg = resp.status\n            try:\n                result = loads(resp.data.decode(\"utf-8\"))\n                if isinstance(result, str):\n                    msg = \"%s, %s\" % (resp.status, result)\n                else:\n                    msg = \"%s %s, %s\" % (\n                        resp.status_code, result[\"error\"], result[\"message\"])\n            except Exception:\n                pass\n            raise requests.HTTPError(msg, response=resp)\n        else:\n            return loads(resp.data.decode(\"utf-8\"))\n    else:\n        try:\n            resp.raise_for_status()\n        except requests.HTTPError as ex:\n            # the response may contains {\"error\": \"\", \"message\": \"\"}\n            # append error and message to exception if possible\n            try:\n                result = resp.json()\n                ex.args += (result[\"error\"], result[\"message\"])\n            except (ValueError, KeyError):\n                pass\n            raise\n        return resp.json()", "response": "Get JSON from response or raise requests. HTTPError if it fails"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting resource. action to url HTTP_METHOD", "response": "def res_to_url(resource, action):\n    \"\"\"Convert resource.action to (url, HTTP_METHOD)\"\"\"\n    i = action.find(\"_\")\n    if i < 0:\n        url = \"/\" + resource\n        httpmethod = action\n    else:\n        url = \"/%s/%s\" % (resource, action[i + 1:])\n        httpmethod = action[:i]\n    return url, httpmethod.upper()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _request(self, resource, action, data=None, headers=None):\n        url, httpmethod = res_to_url(resource, action)\n        return self.ajax(url, httpmethod, data, headers)", "response": "Send request to the NCBI server"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_event(data):\n        event = riemann_client.riemann_pb2.Event()\n        event.host = socket.gethostname()\n        event.tags.extend(data.pop('tags', []))\n\n        for key, value in data.pop('attributes', {}).items():\n            attribute = event.attributes.add()\n            attribute.key, attribute.value = key, value\n\n        for name, value in data.items():\n            if value is not None:\n                setattr(event, name, value)\n        return event", "response": "Translates a dictionary of event attributes to an Event object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_events(self, events):\n        message = riemann_client.riemann_pb2.Msg()\n        for event in events:\n            message.events.add().MergeFrom(event)\n        return self.transport.send(message)", "response": "Sends multiple events to Riemann in a single message"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend multiple events in a single message", "response": "def events(self, *events):\n        \"\"\"Sends multiple events in a single message\n\n        >>> client.events({'service': 'riemann-client', 'state': 'awesome'})\n\n         :param \\*events: event dictionaries for :py:func:`create_event`\n         :returns: The response message from Riemann\n        \"\"\"\n        return self.send_events(self.create_event(e) for e in events)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_dict(event):\n\n        data = dict()\n\n        for descriptor, value in event.ListFields():\n            if descriptor.name == 'tags':\n                value = list(value)\n            elif descriptor.name == 'attributes':\n                value = dict(((a.key, a.value) for a in value))\n            data[descriptor.name] = value\n\n        return data", "response": "Translates an Event object to a dictionary of event attributes\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_query(self, query):\n        message = riemann_client.riemann_pb2.Msg()\n        message.query.string = query\n        return self.transport.send(message)", "response": "Sends a query to the Riemann server"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef query(self, query):\n        if isinstance(self.transport, riemann_client.transport.UDPTransport):\n            raise Exception('Cannot query the Riemann server over UDP')\n        response = self.send_query(query)\n        return [self.create_dict(e) for e in response.events]", "response": "Sends a query to the Riemann server and returns a list of event dictionaries"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_events(self, events):\n        for event in events:\n            self.queue.events.add().MergeFrom(event)\n        return None", "response": "Adds multiple events to the queued message"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of valid host globs for an SSL certificate.", "response": "def GetValidHostsForCert(cert):\n  \"\"\"Returns a list of valid host globs for an SSL certificate.\n\n  Args:\n    cert: A dictionary representing an SSL certificate.\n  Returns:\n    list: A list of valid host globs.\n  \"\"\"\n  if 'subjectAltName' in cert:\n    return [x[1] for x in cert['subjectAltName'] if x[0].lower() == 'dns']\n  else:\n    return [x[0][1] for x in cert['subject']\n            if x[0][0].lower() == 'commonname']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating that a given hostname is valid for an SSL certificate.", "response": "def ValidateCertificateHostname(cert, hostname):\n  \"\"\"Validates that a given hostname is valid for an SSL certificate.\n\n  Args:\n    cert: A dictionary representing an SSL certificate.\n    hostname: The hostname to test.\n  Returns:\n    bool: Whether or not the hostname is valid for this certificate.\n  \"\"\"\n  hosts = GetValidHostsForCert(cert)\n  boto.log.debug(\n      \"validating server certificate: hostname=%s, certificate hosts=%s\",\n      hostname, hosts)\n  for host in hosts:\n    host_re = host.replace('.', '\\.').replace('*', '[^.]*')\n    if re.search('^%s$' % (host_re,), hostname, re.I):\n      return True\n  return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconnect to a host on a given ( SSL ) port.", "response": "def connect(self):\n    \"Connect to a host on a given (SSL) port.\"\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((self.host, self.port))\n    boto.log.debug(\"wrapping ssl socket; CA certificate file=%s\",\n                   self.ca_certs)\n    self.sock = ssl.wrap_socket(sock, keyfile=self.key_file,\n                                certfile=self.cert_file,\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=self.ca_certs)\n    cert = self.sock.getpeercert()\n    hostname = self.host.split(':', 0)[0]\n    if not ValidateCertificateHostname(cert, hostname):\n      raise InvalidCertificateException(hostname,\n                                        cert,\n                                        'remote hostname \"%s\" does not match '\\\n                                        'certificate' % hostname)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, cards, end=TOP):\n        if end is TOP:\n            try:\n                self.cards += cards\n            except:\n                self.cards += [cards]\n        elif end is BOTTOM:\n            try:\n                self.cards.extendleft(cards)\n            except:\n                self.cards.extendleft([cards])", "response": "Adds the given list of cards to the top of the stack."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deal(self, num=1, end=TOP):\n        ends = {TOP: self.cards.pop, BOTTOM: self.cards.popleft}\n\n        self_size = self.size\n\n        if num <= self_size:\n            dealt_cards = [None] * num\n        else:\n            num = self_size\n            dealt_cards = [None] * self_size\n\n        if self_size:\n            for n in xrange(num):\n                try:\n                    card = ends[end]()\n                    dealt_cards[n] = card\n                except:\n                    break\n\n            return Stack(cards=dealt_cards)\n        else:\n            return Stack()", "response": "Returns a list of cards which are removed from the stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef empty(self, return_cards=False):\n        cards = list(self.cards)\n        self.cards = []\n\n        if return_cards:\n            return cards", "response": "Empties the stack removing all cards from it returns them."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch the stack for cards with a value suit name or name or abbreviation matching the given term.", "response": "def find(self, term, limit=0, sort=False, ranks=None):\n        \"\"\"\n        Searches the stack for cards with a value, suit, name, or\n        abbreviation matching the given argument, 'term'.\n\n        :arg str term:\n            The search term. Can be a card full name, value, suit,\n            or abbreviation.\n        :arg int limit:\n            The number of items to retrieve for each term. ``0`` equals\n            no limit.\n        :arg bool sort:\n            Whether or not to sort the results.\n        :arg dict ranks:\n            The rank dict to reference for sorting. If ``None``, it will\n            default to ``DEFAULT_RANKS``.\n\n        :returns:\n            A list of stack indices for the cards matching the given terms,\n            if found.\n\n        \"\"\"\n        ranks = ranks or self.ranks\n        found_indices = []\n        count = 0\n\n        if not limit:\n            for i, card in enumerate(self.cards):\n                if check_term(card, term):\n                    found_indices.append(i)\n        else:\n            for i, card in enumerate(self.cards):\n                if count < limit:\n                    if check_term(card, term):\n                        found_indices.append(i)\n                        count += 1\n                else:\n                    break\n\n        if sort:\n            found_indices = sort_card_indices(self, found_indices, ranks)\n\n        return found_indices"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, term, limit=0, sort=False, ranks=None):\n        ranks = ranks or self.ranks\n        got_cards = []\n\n        try:\n            indices = self.find(term, limit=limit)\n            got_cards = [self.cards[i] for i in indices]\n            self.cards = [v for i, v in enumerate(self.cards) if\n                i not in indices]\n        except:\n            got_cards = [self.cards[term]]\n            self.cards = [v for i, v in enumerate(self.cards) if i is not term]\n\n        if sort:\n            got_cards = sort_cards(got_cards, ranks)\n\n        return got_cards", "response": "Get the specified card from the stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_list(self, terms, limit=0, sort=False, ranks=None):\n        ranks = ranks or self.ranks\n        got_cards = []\n\n        try:\n            indices = self.find_list(terms, limit=limit)\n            got_cards = [self.cards[i] for i in indices if self.cards[i]\n                not in got_cards]\n            self.cards = [v for i, v in enumerate(self.cards) if\n                i not in indices]\n        except:\n            indices = []\n            for item in terms:\n                try:\n                    card = self.cards[item]\n                    if card not in got_cards:\n                        got_cards.append(card)\n                        indices.append(item)\n                except:\n                    indices += self.find(item, limit=limit)\n                    got_cards += [self.cards[i] for i in indices if\n                        self.cards[i] not in got_cards]\n            self.cards = [v for i, v in enumerate(self.cards) if\n                i not in indices]\n\n        if sort:\n            got_cards = sort_cards(got_cards, ranks)\n\n        return got_cards", "response": "Get the specified cards from the stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef insert(self, card, indice=-1):\n        self_size = len(self.cards)\n\n        if indice in [0, -1]:\n            if indice == -1:\n                self.cards.append(card)\n            else:\n                self.cards.appendleft(card)\n        elif indice != self_size:\n            half_x, half_y = self.split(indice)\n            self.cards = list(half_x.cards) + [card] + list(half_y.cards)", "response": "Insert a given card into the stack at a given indice."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninserts a list of cards into the stack at a given indice.", "response": "def insert_list(self, cards, indice=-1):\n        \"\"\"\n        Insert a list of given cards into the stack at a given indice.\n\n        :arg list cards:\n            The list of cards to insert into the stack.\n        :arg int indice:\n            Where to insert the given cards.\n\n        \"\"\"\n        self_size = len(self.cards)\n\n        if indice in [0, -1]:\n            if indice == -1:\n                self.cards += cards\n            else:\n                self.cards.extendleft(cards)\n        elif indice != self_size:\n            half_x, half_y = self.split(indice)\n            self.cards = list(half_x.cards) + list(cards) + list(half_y.cards)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck whether the stack is sorted.", "response": "def is_sorted(self, ranks=None):\n        \"\"\"\n        Checks whether the stack is sorted.\n\n        :arg dict ranks:\n            The rank dict to reference for checking. If ``None``, it will\n            default to ``DEFAULT_RANKS``.\n\n        :returns:\n            Whether or not the cards are sorted.\n\n        \"\"\"\n        ranks = ranks or self.ranks\n\n        return check_sorted(self, ranks)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nshuffle the Stack. .. note:: Shuffling large numbers of cards (100,000+) may take a while. :arg int times: The number of times to shuffle.", "response": "def shuffle(self, times=1):\n        \"\"\"\n        Shuffles the Stack.\n\n        .. note::\n            Shuffling large numbers of cards (100,000+) may take a while.\n\n        :arg int times:\n            The number of times to shuffle.\n\n        \"\"\"\n        for _ in xrange(times):\n            random.shuffle(self.cards)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sort(self, ranks=None):\n        ranks = ranks or self.ranks\n        self.cards = sort_cards(self.cards, ranks)", "response": "Sorts the stack by the given ranks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsplit the Stack into two parts.", "response": "def split(self, indice=None):\n        \"\"\"\n        Splits the Stack, either in half, or at the given indice, into two\n        separate Stacks.\n\n        :arg int indice:\n            Optional. The indice to split the Stack at. Defaults to the middle\n            of the ``Stack``.\n\n        :returns:\n            The two parts of the Stack, as separate Stack instances.\n\n        \"\"\"\n        self_size = self.size\n        if self_size > 1:\n            if not indice:\n                mid = self_size // 2\n                return Stack(cards=self[0:mid]), Stack(cards=self[mid::])\n            else:\n                return Stack(cards=self[0:indice]), Stack(cards=self[indice::])\n        else:\n            return Stack(cards=self.cards), Stack()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef abort(code, error=None, message=None):\n    if error is None:\n        flask_abort(code)\n    elif isinstance(error, Response):\n        error.status_code = code\n        flask_abort(code, response=error)\n    else:\n        body = {\n            \"status\": code,\n            \"error\": error,\n            \"message\": message\n        }\n        flask_abort(code, response=export(body, code))", "response": "Abort with suitable error response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unpack(rv):\n    status = headers = None\n    if isinstance(rv, tuple):\n        rv, status, headers = rv + (None,) * (3 - len(rv))\n    if isinstance(status, (dict, list)):\n        headers, status = status, headers\n    return (rv, status, headers)", "response": "Convert rv to tuple that contains code and headers"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a suitable response for a resource.", "response": "def export(rv, code=None, headers=None):\n    \"\"\"\n    Create a suitable response\n\n    Args:\n        rv: return value of action\n        code: status code\n        headers: response headers\n    Returns:\n        flask.Response\n    \"\"\"\n    if isinstance(rv, ResponseBase):\n        return make_response(rv, code, headers)\n    else:\n        if code is None:\n            code = 200\n        mediatype = request.accept_mimetypes.best_match(\n            exporters.keys(), default='application/json')\n        return exporters[mediatype](rv, code, headers)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_docs(docs, marks):\n    if docs is None:\n        return {}\n    indexs = []\n    for mark in marks:\n        i = docs.find(mark)\n        if i >= 0:\n            indexs.append(i)\n    if not indexs:\n        return {\"$desc\": textwrap.dedent(docs).strip()}\n    start = min(indexs)\n    start = docs.rfind(\"\\n\", 0, start)\n    yamltext = textwrap.dedent(docs[start + 1:])\n    meta = yaml.load(yamltext)\n    meta[\"$desc\"] = textwrap.dedent(docs[:start]).strip()\n    return meta", "response": "Parse YAML syntax content from docs"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets request data based on request. method.", "response": "def get_request_data():\n    \"\"\"\n    Get request data based on request.method\n\n    If method is GET or DELETE, get data from request.args\n    If method is POST, PATCH or PUT, get data from request.form or request.json\n    \"\"\"\n    method = request.method.lower()\n    if method in [\"get\", \"delete\"]:\n        return request.args\n    elif method in [\"post\", \"put\", \"patch\"]:\n        if request.mimetype == 'application/json':\n            try:\n                return request.get_json()\n            except:\n                abort(400, \"InvalidData\", \"invalid json content\")\n        else:\n            return request.form\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_request():\n    find = None\n    if request.endpoint is not None:\n        find = PATTERN_ENDPOINT.findall(request.endpoint)\n    if not find:\n        raise ValueError(\"invalid endpoint %s\" % request.endpoint)\n    __, resource, action_name = find[0]\n    if action_name:\n        action = request.method.lower() + \"_\" + action_name\n    else:\n        action = request.method.lower()\n    return resource, action", "response": "Parse request endpoint and return resource and action"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget title of desc", "response": "def get_title(desc, default=None):\n    \"\"\"Get title of desc\"\"\"\n    if not desc:\n        return default\n    lines = desc.strip('\\n').split('\\n')\n    if not lines:\n        return default\n    return lines[0].lstrip('# ').rstrip(' ')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef meta_view(self):\n        # API_URL_PREFIX maybe diffierent in development and production,\n        # so pick it from app.config other than store it in metafile\n        self.meta[\"$url_prefix\"] = current_app.config.get(\"API_URL_PREFIX\", \"\")\n        mediatype = request.accept_mimetypes.best_match(\n            ['text/html', 'application/json'], default='text/html')\n        dumped = json.dumps(\n            self.meta, indent=4, sort_keys=True, ensure_ascii=False)\n        if mediatype == 'application/json' or 'json' in request.args:\n            return make_response(dumped, {\n                \"Content-Type\": \"application/json; charset=utf-8\"\n            })\n        filename = request.args.get('f')\n        if filename in [\"res.js\", \"res.min.js\"]:\n            # cache parsed meta\n            if self._resjs_cache is None:\n                self._resjs_cache = parse_meta(self.meta)\n            minify = filename == \"res.min.js\"\n            code = generate_code(self._resjs_cache,\n                                 prefix=self.meta[\"$url_prefix\"], min=minify)\n            response = make_response(code, {\n                \"Content-Type\": \"application/javascript\"\n            })\n            # handle etag\n            response.add_etag()\n            return response.make_conditional(request)\n        if filename:\n            return send_from_directory(DOCS_DIST, basename(filename))\n        with open(DOCS_HTML) as f:\n            content = f.read()\\\n                .replace('$(title)', self.meta.get('$title', ''))\\\n                .replace('$(meta)', dumped)\n        return make_response(content)", "response": "This function returns the API meta data for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing and add a resource and its actions route them by naming rule.", "response": "def add_resource(self, resource, *class_args, **class_kwargs):\n        \"\"\"\n        Add resource\n\n        Parse resource and it's actions, route actions by naming rule.\n\n        Args:\n            resource: resource class\n            class_args: class_args\n            class_kwargs: class_kwargs\n        \"\"\"\n        name = resource.__name__.lower()\n        meta_resource = parse_docs(resource.__doc__, [\"$shared\"])\n        self.meta[name] = meta_resource\n        shared = self.meta[\"$shared\"].copy()\n        shared.update(meta_resource.get(\"$shared\", {}))\n        with MarkKey(\"%s.$shared\" % resource.__name__):\n            sp = SchemaParser(validators=self.validators, shared=shared)\n        with MarkKey(resource.__name__):\n            resource = resource(*class_args, **class_kwargs)\n            # group actions by it's name, and\n            # make action group a view function\n            actions = defaultdict(lambda: {})\n            for action in dir(resource):\n                find = PATTERN_ACTION.findall(action)\n                if not find:\n                    continue\n                httpmethod, action_name = find[0]\n                action_group = actions[action_name]\n                fn = getattr(resource, action)\n                meta_action = parse_docs(\n                    fn.__doc__, [\"$input\", \"$output\", \"$error\"])\n                meta_resource[action] = meta_action\n                with MarkKey(fn.__name__):\n                    action_group[httpmethod] = \\\n                        self.make_action(fn, sp, meta_action)\n\n        for action_name in actions:\n            if action_name == \"\":\n                url = \"/\" + name\n                endpoint = name\n            else:\n                url = \"/{0}/{1}\".format(name, action_name)\n                endpoint = \"{0}@{1}\".format(name, action_name)\n            action_group = actions[action_name]\n            self.app.add_url_rule(\n                url, endpoint=endpoint,\n                view_func=self.make_view(action_group),\n                methods=set(action_group)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake a resource s method an action based on input and output schema.", "response": "def make_action(self, fn, schema_parser, meta):\n        \"\"\"\n        Make resource's method an action\n\n        Validate input, output by schema in meta.\n        If no input schema, call fn without params.\n        If no output schema, will not validate return value.\n\n        Args:\n            fn: resource's method\n            schema_parser: for parsing schema in meta\n            meta: meta data of the action\n        \"\"\"\n        validate_input = validate_output = None\n        if \"$input\" in meta:\n            with MarkKey(\"$input\"):\n                validate_input = schema_parser.parse(meta[\"$input\"])\n        if \"$output\" in meta:\n            with MarkKey(\"$output\"):\n                validate_output = schema_parser.parse(meta[\"$output\"])\n\n        def action(data):\n            if validate_input:\n                try:\n                    data = validate_input(data)\n                except Invalid as ex:\n                    return abort(400, \"InvalidData\", str(ex))\n                if isinstance(data, dict):\n                    rv = fn(**data)\n                else:\n                    rv = fn(data)\n            else:\n                rv = fn()\n            rv, status, headers = unpack(rv)\n            if validate_output:\n                try:\n                    rv = validate_output(rv)\n                except Invalid as ex:\n                    return abort(500, \"ServerError\", str(ex))\n            return rv, status, headers\n        return action"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a view function that checks permission and dispatches request to action by request. method SetException Returns a function that returns the response of the view.", "response": "def make_view(self, action_group):\n        \"\"\"\n        Create a view function\n\n        Check permission and Dispatch request to action by request.method\n        \"\"\"\n        def view(*args, **kwargs):\n            try:\n                httpmathod = request.method.lower()\n                if httpmathod not in action_group:\n                    abort(405)\n                resp = self._before_request()\n                if resp is None:\n                    fn = action_group[httpmathod]\n                    resp = fn(get_request_data())\n            except Exception as ex:\n                resp = self._handle_error(ex)\n                if resp is None:\n                    raise\n            resp = self._after_request(*unpack(resp))\n            return export(*resp)\n        return view"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks permission for the current user", "response": "def authorize(self, role):\n        \"\"\"Check permission\"\"\"\n        resource, action = parse_request()\n        roles = self.meta.get(\"$roles\", {})\n        message = \"%s can't access %s.%s\" % (role, resource, action)\n        try:\n            if action not in roles[role][resource]:\n                abort(403, \"PermissionDeny\", message)\n        except KeyError:\n            abort(403, \"PermissionDeny\", message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of all available regions for the SNS service.", "response": "def regions():\n    \"\"\"\n    Get all available regions for the SNS service.\n\n    :rtype: list\n    :return: A list of :class:`boto.regioninfo.RegionInfo` instances\n    \"\"\"\n    return [RegionInfo(name='us-east-1',\n                       endpoint='sns.us-east-1.amazonaws.com',\n                       connection_cls=SNSConnection),\n            RegionInfo(name='eu-west-1',\n                       endpoint='sns.eu-west-1.amazonaws.com',\n                       connection_cls=SNSConnection),\n            RegionInfo(name='us-west-1',\n                       endpoint='sns.us-west-1.amazonaws.com',\n                       connection_cls=SNSConnection),\n            RegionInfo(name='sa-east-1',\n                       endpoint='sns.sa-east-1.amazonaws.com',\n                       connection_cls=SNSConnection),\n            RegionInfo(name='us-west-2',\n                       endpoint='sns.us-west-2.amazonaws.com',\n                       connection_cls=SNSConnection),\n            RegionInfo(name='ap-northeast-1',\n                       endpoint='sns.ap-northeast-1.amazonaws.com',\n                       connection_cls=SNSConnection),\n            RegionInfo(name='ap-southeast-1',\n                       endpoint='sns.ap-southeast-1.amazonaws.com',\n                       connection_cls=SNSConnection),\n            ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect_to_region(region_name, **kw_params):\n    for region in regions():\n        if region.name == region_name:\n            return region.connect(**kw_params)\n    return None", "response": "Connect to a valid region."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding and return a : class : boto. regioninfo. RegionInfo object given a region name.", "response": "def get_region(region_name, **kw_params):\n    \"\"\"\n    Find and return a :class:`boto.regioninfo.RegionInfo` object\n    given a region name.\n\n    :type: str\n    :param: The name of the region.\n\n    :rtype: :class:`boto.regioninfo.RegionInfo`\n    :return: The RegionInfo object for the given region or None if\n             an invalid region name is provided.\n    \"\"\"\n    for region in regions(**kw_params):\n        if region.name == region_name:\n            return region\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_tag(self, key, value=''):\n        status = self.connection.create_tags([self.id], {key : value})\n        if self.tags is None:\n            self.tags = TagSet()\n        self.tags[key] = value", "response": "Add a tag to this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_tag(self, key, value=None):\n        if value:\n            tags = {key : value}\n        else:\n            tags = [key]\n        status = self.connection.delete_tags([self.id], tags)\n        if key in self.tags:\n            del self.tags[key]", "response": "Removes a tag from this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, frame, data):\n        \"Returns a list of values, eats all of data.\"\n        seq = []\n        while data:\n            elem, data = self.spec.read(frame, data)\n            seq.append(elem)\n        return seq, data", "response": "Returns a list of values eats all of data."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets this batch as XML", "response": "def to_xml(self):\n        \"\"\"Get this batch as XML\"\"\"\n        assert self.connection != None\n        s = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n        s += '<InvalidationBatch xmlns=\"http://cloudfront.amazonaws.com/doc/%s/\">\\n' % self.connection.Version\n        for p in self.paths:\n            s += '    <Path>%s</Path>\\n' % self.escape(p)\n        s += '    <CallerReference>%s</CallerReference>\\n' % self.caller_reference\n        s += '</InvalidationBatch>\\n'\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_attributes(self, attributes='All', callback=None):\n        return self.connection.get_queue_attributes(self, attributes, callback=callback)", "response": "Returns the attributes about this queue object and returns\n        them in an Attribute instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_attribute(self, attribute, value, callback=None):\n        return self.connection.set_queue_attribute(self, attribute, value, callback=callback)", "response": "Set a new value for an attribute of the Queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_timeout(self, callback=None):\n        def got_timeout(a):\n            if callable(callback):\n                callback(int(a['VisibilityTimeout']))\n        self.get_attributes('VisibilityTimeout', callback=got_timeout)", "response": "Get the visibility timeout for the queue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the visibility timeout for the queue.", "response": "def set_timeout(self, visibility_timeout, callback=None):\n        \"\"\"\n        Set the visibility timeout for the queue.\n\n        :type visibility_timeout: int\n        :param visibility_timeout: The desired timeout in seconds\n        \"\"\"\n        def _set_timeout(retval):\n            if retval:\n              self.visibility_timeout = visibility_timeout\n            if callable(callback):\n                callback(retval)\n        retval = self.set_attribute('VisibilityTimeout', visibility_timeout, callback=_set_timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a permission to a queue.", "response": "def add_permission(self, label, aws_account_id, action_name, callback=None):\n        \"\"\"\n        Add a permission to a queue.\n\n        :type label: str or unicode\n        :param label: A unique identification of the permission you are setting.\n                      Maximum of 80 characters ``[0-9a-zA-Z_-]``\n                      Example, AliceSendMessage\n\n        :type aws_account_id: str or unicode\n        :param principal_id: The AWS account number of the principal who will be given\n                             permission.  The principal must have an AWS account, but\n                             does not need to be signed up for Amazon SQS. For information\n                             about locating the AWS account identification.\n\n        :type action_name: str or unicode\n        :param action_name: The action.  Valid choices are:\n                            \\*|SendMessage|ReceiveMessage|DeleteMessage|\n                            ChangeMessageVisibility|GetQueueAttributes\n\n        :rtype: bool\n        :return: True if successful, False otherwise.\n\n        \"\"\"\n        return self.connection.add_permission(self, label, aws_account_id, action_name, callback=callback)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_permission(self, label, callback=None):\n        return self.connection.remove_permission(self, label, callback=callback)", "response": "Remove a permission from a queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(self, visibility_timeout=None, callback=None):\n        def _read(rs):\n            if callable(callback):\n                callback(rs[0] if len(rs) == 1 else None)\n        self.get_messages(1, visibility_timeout, callback=callback)", "response": "Read a single message from the queue."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a single message to the queue.", "response": "def write(self, message, callback=None):\n        \"\"\"\n        Add a single message to the queue.\n\n        :type message: Message\n        :param message: The message to be written to the queue\n\n        :rtype: :class:`boto.sqs.message.Message`\n        :return: The :class:`boto.sqs.message.Message` object that was written.\n        \"\"\"\n        def wrote(new_msg):\n            message.id = new_msg.id\n            message.md5 = new_msg.md5\n            if callable(callback):\n                callback(message)\n        self.connection.send_message(self, message.get_body_encoded(), callback=wrote)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a variable number of messages from the queue.", "response": "def get_messages(self, num_messages=1, visibility_timeout=None,\n                     attributes=None, callback=None):\n        \"\"\"\n        Get a variable number of messages.\n\n        :type num_messages: int\n        :param num_messages: The maximum number of messages to read from the queue.\n        \n        :type visibility_timeout: int\n        :param visibility_timeout: The VisibilityTimeout for the messages read.\n\n        :type attributes: str\n        :param attributes: The name of additional attribute to return with response\n                           or All if you want all attributes.  The default is to\n                           return no additional attributes.  Valid values:\n                           All\n                           SenderId\n                           SentTimestamp\n                           ApproximateReceiveCount\n                           ApproximateFirstReceiveTimestamp\n                           \n        :rtype: list\n        :return: A list of :class:`boto.sqs.message.Message` objects.\n        \"\"\"\n        return self.connection.receive_message(self, number_messages=num_messages,\n                                               visibility_timeout=visibility_timeout,\n                                               attributes=attributes, callback=callback)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_message(self, message, callback=None):\n        return self.connection.delete_message(self, message, callback=callback)", "response": "Delete a message from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef count(self, page_size=10, vtimeout=10, callback=None):\n        def counted(a):\n            if callable(callback):\n                callback(int(a['ApproximateNumberOfMessages']))\n        self.get_attributes('ApproximateNumberOfMessages', callback=counted)", "response": "This function counts the number of messages in a queue."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prepare_query(self, symbol,  start_date, end_date):\n        query = \\\n            'select * from yahoo.finance.historicaldata where symbol = \"%s\" and startDate = \"%s\" and endDate = \"%s\"' \\\n            % (symbol, start_date, end_date)\n\n        return query", "response": "Method returns prepared request query for Yahoo YQL API."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes a request on this connection and return the response.", "response": "def _make_request(self, method, url, post_data=None, body=None):\n        \"\"\"\n        Make a request on this connection\n        \"\"\"\n        if not self.connection:\n            self._connect()\n        try:\n            self.connection.close()\n        except:\n            pass\n        self.connection.connect()\n        headers = {}\n        if self.auth_header:\n            headers[\"Authorization\"] = self.auth_header\n        self.connection.request(method, url, body, headers)\n        resp = self.connection.getresponse()\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npull out the properties from this document and return a tuple containing the class properties and id.", "response": "def get_props_from_doc(self, cls, id, doc):\n        \"\"\"\n        Pull out the properties from this document\n        Returns the class, the properties in a hash, and the id if provided as a tuple\n        :return: (cls, props, id)\n        \"\"\"\n        obj_node = doc.getElementsByTagName('object')[0]\n        if not cls:\n            class_name = obj_node.getAttribute('class')\n            cls = find_class(class_name)\n        if not id:\n            id = obj_node.getAttribute('id')\n        props = {}\n        for prop_node in obj_node.getElementsByTagName('property'):\n            prop_name = prop_node.getAttribute('name')\n            prop = cls.find_property(prop_name)\n            value = self.decode_value(prop, prop_node)\n            value = prop.make_value_from_datastore(value)\n            if value != None:\n                props[prop.name] = value\n        return (cls, props, id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmarshals the object and do a PUT", "response": "def save_object(self, obj, expected_value=None):\n        \"\"\"\n        Marshal the object and do a PUT\n        \"\"\"\n        doc = self.marshal_object(obj)\n        if obj.id:\n            url = \"/%s/%s\" % (self.db_name, obj.id)\n        else:\n            url = \"/%s\" % (self.db_name)\n        resp = self._make_request(\"PUT\", url, body=doc.toxml())\n        new_obj = self.get_object_from_doc(obj.__class__, None, parse(resp))\n        obj.id = new_obj.id\n        for prop in obj.properties():\n            try:\n                propname = prop.name\n            except AttributeError:\n                propname = None\n            if propname:\n                value = getattr(new_obj, prop.name)\n                if value:\n                    setattr(obj, prop.name, value)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the DB instance s status information by making a call to fetch getCacheKey the current instance attributes from the service.", "response": "def update(self, validate=False):\n        \"\"\"\n        Update the DB instance's status information by making a call to fetch\n        the current instance attributes from the service.\n\n        :type validate: bool\n        :param validate: By default, if EC2 returns no data about the\n                         instance the update method returns quietly.  If\n                         the validate param is True, however, it will\n                         raise a ValueError exception if no data is\n                         returned from EC2.\n        \"\"\"\n        rs = self.connection.get_all_dbinstances(self.id)\n        if len(rs) > 0:\n            for i in rs:\n                if i.id == self.id:\n                    self.__dict__.update(i.__dict__)\n        elif validate:\n            raise ValueError('%s is not a valid Instance ID' % self.id)\n        return self.status"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete this DBInstance. :type skip_final_snapshot: bool :param skip_final_snapshot: This parameter determines whether a final db snapshot is created before the instance is deleted. If True, no snapshot is created. If False, a snapshot is created before deleting the instance. :type final_snapshot_id: str :param final_snapshot_id: If a final snapshot is requested, this is the identifier used for that snapshot. :rtype: :class:`boto.rds.dbinstance.DBInstance` :return: The deleted db instance.", "response": "def stop(self, skip_final_snapshot=False, final_snapshot_id=''):\n        \"\"\"\n        Delete this DBInstance.\n\n        :type skip_final_snapshot: bool\n        :param skip_final_snapshot: This parameter determines whether a final\n                                    db snapshot is created before the instance\n                                    is deleted.  If True, no snapshot is created.\n                                    If False, a snapshot is created before\n                                    deleting the instance.\n\n        :type final_snapshot_id: str\n        :param final_snapshot_id: If a final snapshot is requested, this\n                                  is the identifier used for that snapshot.\n\n        :rtype: :class:`boto.rds.dbinstance.DBInstance`\n        :return: The deleted db instance.\n        \"\"\"\n        return self.connection.delete_dbinstance(self.id,\n                                                 skip_final_snapshot,\n                                                 final_snapshot_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef modify(self, param_group=None, security_groups=None,\n               preferred_maintenance_window=None,\n               master_password=None, allocated_storage=None,\n               instance_class=None,\n               backup_retention_period=None,\n               preferred_backup_window=None,\n               multi_az=False,\n               apply_immediately=False):\n        \"\"\"\n        Modify this DBInstance.\n\n        :type security_groups: list of str or list of DBSecurityGroup objects\n        :param security_groups: List of names of DBSecurityGroup to authorize on\n                                this DBInstance.\n\n        :type preferred_maintenance_window: str\n        :param preferred_maintenance_window: The weekly time range (in UTC)\n                                             during which maintenance can\n                                             occur.\n                                             Default is Sun:05:00-Sun:09:00\n\n        :type master_password: str\n        :param master_password: Password of master user for the DBInstance.\n                                Must be 4-15 alphanumeric characters.\n\n        :type allocated_storage: int\n        :param allocated_storage: The new allocated storage size, in GBs.\n                                  Valid values are [5-1024]\n\n        :type instance_class: str\n        :param instance_class: The compute and memory capacity of the\n                               DBInstance.  Changes will be applied at\n                               next maintenance window unless\n                               apply_immediately is True.\n\n                               Valid values are:\n                               \n                               * db.m1.small\n                               * db.m1.large\n                               * db.m1.xlarge\n                               * db.m2.xlarge\n                               * db.m2.2xlarge\n                               * db.m2.4xlarge\n\n        :type apply_immediately: bool\n        :param apply_immediately: If true, the modifications will be applied\n                                  as soon as possible rather than waiting for\n                                  the next preferred maintenance window.\n\n        :type backup_retention_period: int\n        :param backup_retention_period: The number of days for which automated\n                                        backups are retained.  Setting this to\n                                        zero disables automated backups.\n\n        :type preferred_backup_window: str\n        :param preferred_backup_window: The daily time range during which\n                                        automated backups are created (if\n                                        enabled).  Must be in h24:mi-hh24:mi\n                                        format (UTC).\n\n        :type multi_az: bool\n        :param multi_az: If True, specifies the DB Instance will be\n                         deployed in multiple availability zones.\n\n        :rtype: :class:`boto.rds.dbinstance.DBInstance`\n        :return: The modified db instance.\n        \"\"\"\n        return self.connection.modify_dbinstance(self.id,\n                                                 param_group,\n                                                 security_groups,\n                                                 preferred_maintenance_window,\n                                                 master_password,\n                                                 allocated_storage,\n                                                 instance_class,\n                                                 backup_retention_period,\n                                                 preferred_backup_window,\n                                                 multi_az,\n                                                 apply_immediately)", "response": "Modify the DBSecurityGroup objects in the specified parameter group."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fetch(self, limit, offset=0):\n        self.limit = limit\n        self.offset = offset\n        return self", "response": "Set the limit and offset of the result set"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef orderExecuted(self, orderDict):\n        ''' call back for executed order '''\n        for orderId, order in orderDict.items():\n            if order.symbol in self.__trakers.keys():\n                self.__trakers[order.symbol].orderExecuted(orderId)", "response": "call back for executed order"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconsume ticks and update trakers", "response": "def tickUpdate(self, tickDict):\n        ''' consume ticks '''\n        if not self.__trakers:\n            self.__setUpTrakers()\n\n        for symbol, tick in tickDict.items():\n            if symbol in self.__trakers:\n                self.__trakers[symbol].tickUpdate(tick)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __getCashToBuyStock(self):\n        ''' calculate the amount of money to buy stock '''\n        account=self.__strategy.getAccountCopy()\n\n        if (account.buyingPower >= account.getTotalValue() / self.__buyingRatio):\n            return account.getTotalValue() / self.__buyingRatio\n        else:\n            return 0", "response": "calculate the amount of money to buy stock"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tickUpdate(self, tick):\n        ''' consume ticks '''\n        LOG.debug(\"tickUpdate %s with tick %s, price %s\" % (self.__symbol, tick.time, tick.close))\n        self.__priceZscore(tick.close)\n        self.__volumeZscore(tick.volume)\n\n        # if haven't started, don't do any trading\n        if tick.time <= self.__startDate:\n            return\n\n        # if not enough data, skip to reduce risk\n        if not self.__priceZscore.getLastValue() or not self.__volumeZscore.getLastValue():\n            return\n\n        # get zscore\n        priceZscore=self.__priceZscore.getLastValue()\n        volumeZscore=self.__volumeZscore.getLastValue()\n        if priceZscore is None or volumeZscore is None:\n            return\n\n        if priceZscore < self.__buyThreshold and self.__position <= 0 and abs(volumeZscore) > 1:\n            self.__placeBuyOrder(tick)\n\n        elif priceZscore > self.__sellThreshold and self.__position > 0 and abs(volumeZscore) > 1:\n            self.__placeSellOrder(tick)\n        \"\"\"\n        if self.__toBuy:\n            self.__placeBuyOrder(tick)\n            self.__toBuy=False\n            return\n\n        if self.__toSell:\n            self.__placeSellOrder(tick)\n            self.__toSell=False\n            return\n\n        if priceZscore < (-self.__threshold) and not self.__buyOrder and abs(volumeZscore) > 1.5:\n            self.__toBuy=True\n\n        elif self.__buyOrder and priceZscore > 0.5:\n            self.__toSell=True\n        \"\"\"", "response": "consume ticks and return the new entry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate and return a new Session Token based on the contents of a JSON document.", "response": "def from_json(cls, json_doc):\n        \"\"\"\n        Create and return a new Session Token based on the contents\n        of a JSON document.\n\n        :type json_doc: str\n        :param json_doc: A string containing a JSON document with a\n            previously saved Credentials object.\n        \"\"\"\n        d = json.loads(json_doc)\n        token = cls()\n        token.__dict__.update(d)\n        return token"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(cls, file_path):\n        fp = open(file_path)\n        json_doc = fp.read()\n        fp.close()\n        return cls.from_json(json_doc)", "response": "Create and return a new Session Token based on the contents of the JSON - format file containing the previously saved Session Token information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_dict(self):\n        return {'access_key': self.access_key,\n                'secret_key': self.secret_key,\n                'session_token': self.session_token,\n                'expiration': self.expiration,\n                'request_id': self.request_id}", "response": "Return a Python dict containing the important information about this Session Token."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the current Session Token to a file in JSON format.", "response": "def save(self, file_path):\n        \"\"\"\n        Persist a Session Token to a file in JSON format.\n\n        :type path: str\n        :param path: The fully qualified path to the file where the\n            the Session Token data should be written.  Any previous\n            data in the file will be overwritten.  To help protect\n            the credentials contained in the file, the permissions\n            of the file will be set to readable/writable by owner only.\n        \"\"\"\n        fp = open(file_path, 'wb')\n        json.dump(self.to_dict(), fp)\n        fp.close()\n        os.chmod(file_path, 0600)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_expired(self, time_offset_seconds=0):\n        now = datetime.datetime.utcnow()\n        if time_offset_seconds:\n            now = now + datetime.timedelta(seconds=time_offset_seconds)\n        ts = boto.utils.parse_ts(self.expiration)\n        delta = ts - now\n        return delta.total_seconds() <= 0", "response": "Checks to see if the Session Token is expired or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an entry to the crontab.", "response": "def add_cron(self, name, minute, hour, mday, month, wday, who, command, env=None):\n        \"\"\"\n        Add an entry to the system crontab.\n        \"\"\"\n        raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the export view to urls.", "response": "def get_urls(self):\n        \"\"\"\n        Add the export view to urls.\n        \"\"\"\n        urls = super(AccountAdmin, self).get_urls()\n        from django.conf.urls import url\n\n        def wrap(view):\n            def wrapper(*args, **kwargs):\n                return self.admin_site.admin_view(view)(*args, **kwargs)\n            return update_wrapper(wrapper, view)\n\n        info = self.opts.app_label, self.opts.model_name\n\n        extra_urls = [\n            url(r'^login/(?P<provider>(\\w|-)+)/$',\n                wrap(OAuthRedirect.as_view()), name='%s_%s_login' % info),\n            url(r'^callback/(?P<provider>(\\w|-)+)/$',\n                wrap(OAuthCallback.as_view()), name='%s_%s_callback' % info),\n            url(r'^(.+)/json/$', wrap(self.json_view), name='%s_%s_json' % info),\n        ]\n        return extra_urls + urls"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_location(self, ip, detailed=False):\n        seek = self._get_pos(ip)\n\n        if seek > 0:\n            return self._parse_location(seek, detailed=detailed)\n\n        return False", "response": "Returns a dictionary with location data or False on failure."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_locations(self, ip, detailed=False):\n        if isinstance(ip, str):\n            ip = [ip]\n            \n        seek = map(self._get_pos, ip)\n\n        return [self._parse_location(elem, detailed=detailed) if elem > 0 else False for elem in seek]", "response": "Returns a list of dictionaries with location data or False \n        on failure. Argument ip must be an iterable object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds an AuthHandler that is ready to authenticate for the requested capabilities config and provider.", "response": "def get_auth_handler(host, config, provider, requested_capability=None):\n    \"\"\"Finds an AuthHandler that is ready to authenticate.\n\n    Lists through all the registered AuthHandlers to find one that is willing\n    to handle for the requested capabilities, config and provider.\n\n    :type host: string\n    :param host: The name of the host\n\n    :type config: \n    :param config:\n\n    :type provider:\n    :param provider:\n\n    Returns:\n        An implementation of AuthHandler.\n\n    Raises:\n        boto.exception.NoAuthHandlerFound:\n        boto.exception.TooManyAuthHandlerReadyToAuthenticate:\n    \"\"\"\n    ready_handlers = []\n    auth_handlers = boto.plugin.get_plugin(AuthHandler, requested_capability)\n    total_handlers = len(auth_handlers)\n    for handler in auth_handlers:\n        try:\n            ready_handlers.append(handler(host, config, provider))\n        except boto.auth_handler.NotReadyToAuthenticate:\n            pass\n \n    if not ready_handlers:\n        checked_handlers = auth_handlers\n        names = [handler.__name__ for handler in checked_handlers]\n        raise boto.exception.NoAuthHandlerFound(\n              'No handler was ready to authenticate. %d handlers were checked.'\n              ' %s ' \n              'Check your credentials' % (len(names), str(names)))\n\n    if len(ready_handlers) > 1:\n        # NOTE: Even though it would be nice to accept more than one handler\n        # by using one of the many ready handlers, we are never sure that each\n        # of them are referring to the same storage account. Since we cannot\n        # easily guarantee that, it is always safe to fail, rather than operate\n        # on the wrong account.\n        names = [handler.__class__.__name__ for handler in ready_handlers]\n        raise boto.exception.TooManyAuthHandlerReadyToAuthenticate(\n               '%d AuthHandlers %s ready to authenticate for requested_capability '\n               '%s, only 1 expected. This happens if you import multiple '\n               'pluging.Plugin implementations that declare support for the '\n               'requested_capability.' % (len(names), str(names),\n               requested_capability))\n\n    return ready_handlers[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nselects the headers that need to be included in the StringToSign.", "response": "def headers_to_sign(self, http_request):\n        \"\"\"\n        Select the headers from the request that need to be included\n        in the StringToSign.\n        \"\"\"\n        headers_to_sign = {}\n        headers_to_sign = {'Host' : self.host}\n        for name, value in http_request.headers.items():\n            lname = name.lower()\n            if lname.startswith('x-amz'):\n                headers_to_sign[name] = value\n        return headers_to_sign"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef canonical_headers(self, headers_to_sign):\n        l = ['%s:%s'%(n.lower().strip(),\n                      headers_to_sign[n].strip()) for n in headers_to_sign]\n        l.sort()\n        return '\\n'.join(l)", "response": "Return the canonical headers of the StringToSign\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef string_to_sign(self, http_request):\n        headers_to_sign = self.headers_to_sign(http_request)\n        canonical_headers = self.canonical_headers(headers_to_sign)\n        string_to_sign = '\\n'.join([http_request.method,\n                                    http_request.path,\n                                    '',\n                                    canonical_headers,\n                                    '',\n                                    http_request.body])\n        return string_to_sign, headers_to_sign", "response": "Return the canonical StringToSign as well as a dict\n        containing the original version of all headers that were included in the StringToSign."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd AWS3 authentication to a request.", "response": "def add_auth(self, req, **kwargs):\n        \"\"\"\n        Add AWS3 authentication to a request.\n\n        :type req: :class`boto.connection.HTTPRequest`\n        :param req: The HTTPRequest object.\n        \"\"\"\n        # This could be a retry.  Make sure the previous\n        # authorization header is removed first.\n        if 'X-Amzn-Authorization' in req.headers:\n            del req.headers['X-Amzn-Authorization']\n        req.headers['X-Amz-Date'] = formatdate(usegmt=True)\n        req.headers['X-Amz-Security-Token'] = self._provider.security_token\n        string_to_sign, headers_to_sign = self.string_to_sign(req)\n        boto.log.debug('StringToSign:\\n%s' % string_to_sign)\n        hash_value = sha256(string_to_sign).digest()\n        b64_hmac = self.sign_string(hash_value)\n        s = \"AWS3 AWSAccessKeyId=%s,\" % self._provider.access_key\n        s += \"Algorithm=%s,\" % self.algorithm()\n        s += \"SignedHeaders=%s,\" % ';'.join(headers_to_sign)\n        s += \"Signature=%s\" % b64_hmac\n        req.headers['X-Amzn-Authorization'] = s"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_capable(cls, requested_capability):\n        for c in requested_capability:\n            if not c in cls.capability:\n                return False\n        return True", "response": "Returns true if the requested capability is supported by this plugin s application."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the next connection in this pool that is ready to be reused. Returns None if there aren t any.", "response": "def get(self):\n        \"\"\"\n        Returns the next connection in this pool that is ready to be\n        reused.  Returns None of there aren't any.\n        \"\"\"\n        # Discard ready connections that are too old.\n        self.clean()\n\n        # Return the first connection that is ready, and remove it\n        # from the queue.  Connections that aren't ready are returned\n        # to the end of the queue with an updated time, on the\n        # assumption that somebody is actively reading the response.\n        for _ in range(len(self.queue)):\n            (conn, _) = self.queue.pop(0)\n            if self._conn_ready(conn):\n                return conn\n            else:\n                self.put(conn)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _conn_ready(self, conn):\n        if ON_APP_ENGINE:\n            # Google App Engine implementation of HTTPConnection doesn't contain\n            # _HTTPConnection__response attribute. Moreover, it's not possible\n            # to determine if given connection is ready. Reusing connections\n            # simply doesn't make sense with App Engine urlfetch service.\n            return False\n        else:\n            response = getattr(conn, '_HTTPConnection__response', None)\n            return (response is None) or response.isclosed()", "response": "Returns True if the given connection is ready to be used."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean(self):\n        # Note that we do not close the connection here -- somebody\n        # may still be reading from it.\n        while len(self.queue) > 0 and self._pair_stale(self.queue[0]):\n            self.queue.pop(0)", "response": "Remove stale entries from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn true of the connection pair is too old to be used.", "response": "def _pair_stale(self, pair):\n        \"\"\"\n        Returns true of the (connection,time) pair is too old to be\n        used.\n        \"\"\"\n        (_conn, return_time) = pair\n        now = time.time()\n        return return_time + ConnectionPool.STALE_DURATION < now"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_http_connection(self, host, is_secure):\n        self.clean()\n        with self.mutex:\n            key = (host, is_secure)\n            if key not in self.host_to_pool:\n                return None\n            return self.host_to_pool[key].get()", "response": "Gets a connection from the pool for the named host. Returns None if there is no connection."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a connection to the pool of connections that can be reused for the named host.", "response": "def put_http_connection(self, host, is_secure, conn):\n        \"\"\"\n        Adds a connection to the pool of connections that can be\n        reused for the named host.\n        \"\"\"\n        with self.mutex:\n            key = (host, is_secure)\n            if key not in self.host_to_pool:\n                self.host_to_pool[key] = HostConnectionPool()\n            self.host_to_pool[key].put(conn)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncleaning up the stale connections in all of the pools and then remove any empty pools.", "response": "def clean(self):\n        \"\"\"\n        Clean up the stale connections in all of the pools, and then\n        get rid of empty pools.  Pools clean themselves every time a\n        connection is fetched; this cleaning takes care of pools that\n        aren't being used any more, so nothing is being gotten from\n        them. \n        \"\"\"\n        with self.mutex:\n            now = time.time()\n            if self.last_clean_time + self.CLEAN_INTERVAL < now:\n                to_remove = []\n                for (host, pool) in self.host_to_pool.items():\n                    pool.clean()\n                    if pool.size() == 0:\n                        to_remove.append(host)\n                for host in to_remove:\n                    del self.host_to_pool[host]\n                self.last_clean_time = now"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _mexe(self, request, sender=None, override_num_retries=None,\n              retry_handler=None):\n        \"\"\"\n        mexe - Multi-execute inside a loop, retrying multiple times to handle\n               transient Internet errors by simply trying again.\n               Also handles redirects.\n\n        This code was inspired by the S3Utils classes posted to the boto-users\n        Google group by Larry Bates.  Thanks!\n\n        \"\"\"\n        boto.log.debug('Method: %s' % request.method)\n        boto.log.debug('Path: %s' % request.path)\n        boto.log.debug('Data: %s' % request.body)\n        boto.log.debug('Headers: %s' % request.headers)\n        boto.log.debug('Host: %s' % request.host)\n        response = None\n        body = None\n        e = None\n        if override_num_retries is None:\n            num_retries = config.getint('Boto', 'num_retries', self.num_retries)\n        else:\n            num_retries = override_num_retries\n        i = 0\n        connection = self.get_http_connection(request.host, self.is_secure)\n        while i <= num_retries:\n            # Use binary exponential backoff to desynchronize client requests\n            next_sleep = random.random() * (2 ** i)\n            try:\n                # we now re-sign each request before it is retried\n                boto.log.debug('Token: %s' % self.provider.security_token)\n                request.authorize(connection=self)\n                if callable(sender):\n                    response = sender(connection, request.method, request.path,\n                                      request.body, request.headers)\n                else:\n                    connection.request(request.method, request.path,\n                                       request.body, request.headers)\n                    response = connection.getresponse()\n                location = response.getheader('location')\n                # -- gross hack --\n                # httplib gets confused with chunked responses to HEAD requests\n                # so I have to fake it out\n                if request.method == 'HEAD' and getattr(response,\n                                                        'chunked', False):\n                    response.chunked = 0\n                if callable(retry_handler):\n                    status = retry_handler(response, i, next_sleep)\n                    if status:\n                        msg, i, next_sleep = status\n                        if msg:\n                            boto.log.debug(msg)\n                        time.sleep(next_sleep)\n                        continue\n                if response.status == 500 or response.status == 503:\n                    msg = 'Received %d response.  ' % response.status\n                    msg += 'Retrying in %3.1f seconds' % next_sleep\n                    boto.log.debug(msg)\n                    body = response.read()\n                elif response.status < 300 or response.status >= 400 or \\\n                        not location:\n                    self.put_http_connection(request.host, self.is_secure,\n                                             connection)\n                    return response\n                else:\n                    scheme, request.host, request.path, \\\n                        params, query, fragment = urlparse.urlparse(location)\n                    if query:\n                        request.path += '?' + query\n                    msg = 'Redirecting: %s' % scheme + '://'\n                    msg += request.host + request.path\n                    boto.log.debug(msg)\n                    connection = self.get_http_connection(request.host,\n                                                          scheme == 'https')\n                    continue\n            except self.http_exceptions, e:\n                for unretryable in self.http_unretryable_exceptions:\n                    if isinstance(e, unretryable):\n                        boto.log.debug(\n                            'encountered unretryable %s exception, re-raising' %\n                            e.__class__.__name__)\n                        raise e\n                boto.log.debug('encountered %s exception, reconnecting' % \\\n                                  e.__class__.__name__)\n                connection = self.new_http_connection(request.host,\n                                                      self.is_secure)\n            time.sleep(next_sleep)\n            i += 1\n        # If we made it here, it's because we have exhausted our retries\n        # and stil haven't succeeded.  So, if we have a response object,\n        # use it to raise an exception.\n        # Otherwise, raise the exception that must have already h#appened.\n        if response:\n            raise BotoServerError(response.status, response.reason, body)\n        elif e:\n            raise e\n        else:\n            msg = 'Please report this exception as a Boto Issue!'\n            raise BotoClientError(msg)", "response": "This method handles the multi - execute of the HTTP request."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes a request to the server with multiple - retry logic.", "response": "def make_request(self, method, path, headers=None, data='', host=None,\n                     auth_path=None, sender=None, override_num_retries=None):\n        \"\"\"Makes a request to the server, with stock multiple-retry logic.\"\"\"\n        http_request = self.build_base_http_request(method, path, auth_path,\n                                                    {}, headers, data, host)\n        return self._mexe(http_request, sender, override_num_retries)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget file paths with dialog", "response": "def GetFilePathsWithDialog(fileTypes=[]):\n    \"\"\"\n        Multipul File Select with dialog\n\n        fileTypes: you can choise file extension\n            ex) fileTypes=[('Excel Files', '.xlsx')]\n    \"\"\"\n    root = tkinter.Tk()\n    root.withdraw()\n    filepath = filedialog.askopenfilenames(\n        filetypes=fileTypes, parent=root)\n\n    if isinstance(filepath, str):\n        fileList = filepath.split(\" \")\n    elif isinstance(filepath, tuple):\n        fileList = list(filepath)\n    elif isinstance(filepath, list):\n        fileList = filepath\n\n    root.destroy()\n    print(str(len(fileList)) + \" files are selected\")\n\n    return fileList"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a radio button window for option selection", "response": "def GetRadioButtonSelect(selectList, title=\"Select\", msg=\"\"):\n    \"\"\"\n    Create radio button window for option selection\n\n    title: Window name\n    mag: Label of the radio button\n\n    return (seldctedItem, selectedindex)\n    \"\"\"\n    root = tkinter.Tk()\n    root.title(title)\n    val = tkinter.IntVar()\n    val.set(0)\n\n    if msg != \"\":\n        tkinter.Label(root, text=msg).pack()\n\n    index = 0\n    for item in selectList:\n        tkinter.Radiobutton(root, text=item, variable=val,\n                            value=index).pack(anchor=tkinter.W)\n        index += 1\n\n    tkinter.Button(root, text=\"OK\", fg=\"black\", command=root.quit).pack()\n    root.mainloop()\n    root.destroy()\n\n    print(selectList[val.get()] + \" is selected\")\n    return (selectList[val.get()], val.get())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef GetListSelect(selectList, title=\"Select\", msg=\"\"):\n    root = tkinter.Tk()\n    root.title(title)\n\n    label = tkinter.Label(root, text=msg)\n    label.pack()\n\n    listbox = tkinter.Listbox(root)\n    for i in selectList:\n        listbox.insert(tkinter.END, i)\n    listbox.pack()\n\n    tkinter.Button(root, text=\"OK\", fg=\"black\", command=root.quit).pack()\n    root.mainloop()\n\n    selected = listbox.get(listbox.curselection())\n    print(selected + \" is selected\")\n    root.destroy()\n    return (selected, selectList.index(selected))", "response": "Create list with selectList and then return seleced string and index"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef GetCheckButtonSelect(selectList, title=\"Select\", msg=\"\"):\n    root = tkinter.Tk()\n    root.title(title)\n\n    label = tkinter.Label(root, text=msg)\n    label.pack()\n\n    optList = []\n    for item in selectList:\n        opt = tkinter.BooleanVar()\n        opt.set(False)\n        tkinter.Checkbutton(root, text=item, variable=opt).pack()\n        optList.append(opt)\n\n    tkinter.Button(root, text=\"OK\", fg=\"black\", command=root.quit).pack()\n    root.mainloop()\n    root.destroy()\n\n    result = {}\n    for (opt, select) in zip(optList, selectList):\n        result[select] = opt.get()\n\n    print(result)\n    return result", "response": "Get selected check button options"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef GetEntries(dataList, title=\"Select\", msg=\"\"):\n    root = tkinter.Tk()\n    root.title(title)\n\n    label = tkinter.Label(root, text=msg)\n    label.pack()\n\n    entries = []\n    for item in dataList:\n        tkinter.Label(root, text=item).pack()\n        entry = tkinter.Entry(root)\n        entry.pack()\n        entries.append(entry)\n\n    # print entries\n    tkinter.Button(root, text=\"OK\", fg=\"black\", command=root.quit).pack()\n    root.mainloop()\n\n    result = {}\n    for (entry, data) in zip(entries, dataList):\n        result[data] = entry.get()\n\n    root.destroy()\n    print(result)\n    return result", "response": "Get entries of the list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_rule(self, ip_protocol, from_port, to_port,\n                 src_group_name, src_group_owner_id, cidr_ip):\n        \"\"\"\n        Add a rule to the SecurityGroup object.  Note that this method\n        only changes the local version of the object.  No information\n        is sent to EC2.\n        \"\"\"\n        rule = IPPermissions(self)\n        rule.ip_protocol = ip_protocol\n        rule.from_port = from_port\n        rule.to_port = to_port\n        self.rules.append(rule)\n        rule.add_grant(src_group_name, src_group_owner_id, cidr_ip)", "response": "Add a rule to the SecurityGroup object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_rule(self, ip_protocol, from_port, to_port,\n                    src_group_name, src_group_owner_id, cidr_ip):\n        \"\"\"\n        Remove a rule to the SecurityGroup object.  Note that this method\n        only changes the local version of the object.  No information\n        is sent to EC2.\n        \"\"\"\n        target_rule = None\n        for rule in self.rules:\n            if rule.ip_protocol == ip_protocol:\n                if rule.from_port == from_port:\n                    if rule.to_port == to_port:\n                        target_rule = rule\n                        target_grant = None\n                        for grant in rule.grants:\n                            if grant.name == src_group_name:\n                                if grant.owner_id == src_group_owner_id:\n                                    if grant.cidr_ip == cidr_ip:\n                                        target_grant = grant\n                        if target_grant:\n                            rule.grants.remove(target_grant)\n        if len(rule.grants) == 0:\n            self.rules.remove(target_rule)", "response": "This method removes a rule from the SecurityGroup object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef authorize(self, ip_protocol=None, from_port=None, to_port=None,\n                  cidr_ip=None, src_group=None):\n        \"\"\"\n        Add a new rule to this security group.\n        You need to pass in either src_group_name\n        OR ip_protocol, from_port, to_port,\n        and cidr_ip.  In other words, either you are authorizing another\n        group or you are authorizing some ip-based rule.\n        \n        :type ip_protocol: string\n        :param ip_protocol: Either tcp | udp | icmp\n\n        :type from_port: int\n        :param from_port: The beginning port number you are enabling\n\n        :type to_port: int\n        :param to_port: The ending port number you are enabling\n\n        :type cidr_ip: string\n        :param cidr_ip: The CIDR block you are providing access to.\n                        See http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n\n        :type src_group: :class:`boto.ec2.securitygroup.SecurityGroup` or\n                         :class:`boto.ec2.securitygroup.GroupOrCIDR`\n        :param src_group: The Security Group you are granting access to.\n                         \n        :rtype: bool\n        :return: True if successful.\n        \"\"\"\n        if src_group:\n            cidr_ip = None\n            src_group_name = src_group.name\n            src_group_owner_id = src_group.owner_id\n        else:\n            src_group_name = None\n            src_group_owner_id = None\n        status = self.connection.authorize_security_group(self.name,\n                                                          src_group_name,\n                                                          src_group_owner_id,\n                                                          ip_protocol,\n                                                          from_port,\n                                                          to_port,\n                                                          cidr_ip)\n        if status:\n            self.add_rule(ip_protocol, from_port, to_port, src_group_name,\n                          src_group_owner_id, cidr_ip)\n        return status", "response": "This method is used to add a new rule to the security group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy_to_region(self, region, name=None):\n        if region.name == self.region:\n            raise BotoClientError('Unable to copy to the same Region')\n        conn_params = self.connection.get_params()\n        rconn = region.connect(**conn_params)\n        sg = rconn.create_security_group(name or self.name, self.description)\n        source_groups = []\n        for rule in self.rules:\n            for grant in rule.grants:\n                if grant.name:\n                    if grant.name not in source_groups:\n                        source_groups.append(grant.name)\n                        sg.authorize(None, None, None, None, grant)\n                else:\n                    sg.authorize(rule.ip_protocol, rule.from_port, rule.to_port,\n                                 grant.cidr_ip)\n        return sg", "response": "Create a copy of this security group in a specific region."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds all of the current instances that are running within this security group.", "response": "def instances(self):\n        \"\"\"\n        Find all of the current instances that are running within this\n        security group.\n\n        :rtype: list of :class:`boto.ec2.instance.Instance`\n        :return: A list of Instance objects\n        \"\"\"\n        # It would be more efficient to do this with filters now\n        # but not all services that implement EC2 API support filters.\n        instances = []\n        rs = self.connection.get_all_instances()\n        for reservation in rs:\n            uses_group = [g.name for g in reservation.groups if g.name == self.name]\n            if uses_group:\n                instances.extend(reservation.instances)\n        return instances"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild the policy document for the post policy.", "response": "def build_post_policy(self, expiration_time, conditions):\n        \"\"\"\n        Taken from the AWS book Python examples and modified for use with boto\n        \"\"\"\n        assert type(expiration_time) == time.struct_time, \\\n            'Policy document must include a valid expiration Time object'\n\n        # Convert conditions object mappings to condition statements\n\n        return '{\"expiration\": \"%s\",\\n\"conditions\": [%s]}' % \\\n            (time.strftime(boto.utils.ISO8601, expiration_time), \",\".join(conditions))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild the arguments needed for the post form of a file.", "response": "def build_post_form_args(self, bucket_name, key, expires_in = 6000,\n                             acl = None, success_action_redirect = None,\n                             max_content_length = None,\n                             http_method = \"http\", fields=None,\n                             conditions=None):\n        \"\"\"\n        Taken from the AWS book Python examples and modified for use with boto\n        This only returns the arguments required for the post form, not the\n        actual form.  This does not return the file input field which also\n        needs to be added\n        \n        :type bucket_name: string \n        :param bucket_name: Bucket to submit to\n        \n        :type key: string\n        :param key:  Key name, optionally add ${filename} to the end to\n            attach the submitted filename\n        \n        :type expires_in: integer\n        :param expires_in: Time (in seconds) before this expires, defaults\n            to 6000\n        \n        :type acl: :class:`boto.s3.acl.ACL`\n        :param acl: ACL rule to use, if any\n        \n        :type success_action_redirect: string \n        :param success_action_redirect: URL to redirect to on success\n        \n        :type max_content_length: integer \n        :param max_content_length: Maximum size for this file\n        \n        :type http_method: string\n        :param http_method:  HTTP Method to use, \"http\" or \"https\"\n        \n        :rtype: dict\n        :return: A dictionary containing field names/values as well as\n            a url to POST to\n        \n            .. code-block:: python\n            \n                {\n                    \"action\": action_url_to_post_to, \n                    \"fields\": [ \n                        {\n                            \"name\": field_name, \n                            \"value\":  field_value\n                        }, \n                        {\n                            \"name\": field_name2, \n                            \"value\": field_value2\n                        } \n                    ] \n                }\n            \n        \"\"\"\n        if fields == None:\n            fields = []\n        if conditions == None:\n            conditions = []\n        expiration = time.gmtime(int(time.time() + expires_in))\n\n        # Generate policy document\n        conditions.append('{\"bucket\": \"%s\"}' % bucket_name)\n        if key.endswith(\"${filename}\"):\n            conditions.append('[\"starts-with\", \"$key\", \"%s\"]' % key[:-len(\"${filename}\")])\n        else:\n            conditions.append('{\"key\": \"%s\"}' % key)\n        if acl:\n            conditions.append('{\"acl\": \"%s\"}' % acl)\n            fields.append({ \"name\": \"acl\", \"value\": acl})\n        if success_action_redirect:\n            conditions.append('{\"success_action_redirect\": \"%s\"}' % success_action_redirect)\n            fields.append({ \"name\": \"success_action_redirect\", \"value\": success_action_redirect})\n        if max_content_length:\n            conditions.append('[\"content-length-range\", 0, %i]' % max_content_length)\n            fields.append({\"name\":'content-length-range', \"value\": \"0,%i\" % max_content_length})\n\n        policy = self.build_post_policy(expiration, conditions)\n\n        # Add the base64-encoded policy document as the 'policy' field\n        policy_b64 = base64.b64encode(policy)\n        fields.append({\"name\": \"policy\", \"value\": policy_b64})\n\n        # Add the AWS access key as the 'AWSAccessKeyId' field\n        fields.append({\"name\": \"AWSAccessKeyId\",\n                       \"value\": self.aws_access_key_id})\n\n        # Add signature for encoded policy document as the 'AWSAccessKeyId' field\n        signature = self._auth_handler.sign_string(policy_b64)\n        fields.append({\"name\": \"signature\", \"value\": signature})\n        fields.append({\"name\": \"key\", \"value\": key})\n\n        # HTTPS protocol will be used if the secure HTTP option is enabled.\n        url = '%s://%s/' % (http_method,\n                            self.calling_format.build_host(self.server_name(),\n                                                           bucket_name))\n\n        return {\"action\": url, \"fields\": fields}"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new located bucket.", "response": "def create_bucket(self, bucket_name, headers=None,\n                      location=Location.DEFAULT, policy=None):\n        \"\"\"\n        Creates a new located bucket. By default it's in the USA. You can pass\n        Location.EU to create an European bucket.\n\n        :type bucket_name: string\n        :param bucket_name: The name of the new bucket\n        \n        :type headers: dict\n        :param headers: Additional headers to pass along with the request to AWS.\n\n        :type location: :class:`boto.s3.connection.Location`\n        :param location: The location of the new bucket\n        \n        :type policy: :class:`boto.s3.acl.CannedACLStrings`\n        :param policy: A canned ACL policy that will be applied to the\n            new key in S3.\n             \n        \"\"\"\n        check_lowercase_bucketname(bucket_name)\n\n        if policy:\n            if headers:\n                headers[self.provider.acl_header] = policy\n            else:\n                headers = {self.provider.acl_header : policy}\n        if location == Location.DEFAULT:\n            data = ''\n        else:\n            data = '<CreateBucketConstraint><LocationConstraint>' + \\\n                    location + '</LocationConstraint></CreateBucketConstraint>'\n        response = self.make_request('PUT', bucket_name, headers=headers,\n                data=data)\n        body = response.read()\n        if response.status == 409:\n            raise self.provider.storage_create_error(\n                response.status, response.reason, body)\n        if response.status == 200:\n            return self.bucket_class(self, bucket_name)\n        else:\n            raise self.provider.storage_response_error(\n                response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndecode a syncsafe integer", "response": "def decode(data):\n        \"Decodes a syncsafe integer\"\n        value = 0\n        for b in data:\n            if b > 127:  # iTunes bug\n                raise ValueError(\"Invalid syncsafe integer\")\n            value <<= 7\n            value += b\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef encode(i, *, width=-1):\n        if i < 0:\n            raise ValueError(\"value is negative\")\n        assert width != 0\n        data = bytearray()\n        while i:\n            data.append(i & 127)\n            i >>= 7\n        if width > 0 and len(data) > width:\n            raise ValueError(\"Integer too large\")\n        if len(data) < abs(width):\n            data.extend([0] * (abs(width) - len(data)))\n        data.reverse()\n        return data", "response": "Encodes a nonnegative integer into syncsafe format"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_timeout(self, visibility_timeout):\n        retval = self.set_attribute('VisibilityTimeout', visibility_timeout)\n        if retval:\n            self.visibility_timeout = visibility_timeout\n        return retval", "response": "Set the visibility timeout for the queue."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread a single message from the queue.", "response": "def read(self, visibility_timeout=None):\n        \"\"\"\n        Read a single message from the queue.\n        \n        :type visibility_timeout: int\n        :param visibility_timeout: The timeout for this message in seconds\n\n        :rtype: :class:`boto.sqs.message.Message`\n        :return: A single message or None if queue is empty\n        \"\"\"\n        rs = self.get_messages(1, visibility_timeout)\n        if len(rs) == 1:\n            return rs[0]\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write(self, message, delay_seconds=None):\n        new_msg = self.connection.send_message(self, message.get_body_encoded(), delay_seconds)\n        message.id = new_msg.id\n        message.md5 = new_msg.md5\n        return message", "response": "Adds a single message to the queue."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef new_message(self, body=''):\n        m = self.message_class(self, body)\n        m.queue = self\n        return m", "response": "Create a new message of appropriate class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear(self, page_size=10, vtimeout=10):\n        n = 0\n        l = self.get_messages(page_size, vtimeout)\n        while l:\n            for m in l:\n                self.delete_message(m)\n                n += 1\n            l = self.get_messages(page_size, vtimeout)\n        return n", "response": "Utility function to remove all messages from a queue"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncounts the number of messages in a queue that are very slow.", "response": "def count_slow(self, page_size=10, vtimeout=10):\n        \"\"\"\n        Deprecated.  This is the old 'count' method that actually counts\n        the messages by reading them all.  This gives an accurate count but\n        is very slow for queues with non-trivial number of messasges.\n        Instead, use get_attribute('ApproximateNumberOfMessages') to take\n        advantage of the new SQS capability.  This is retained only for\n        the unit tests.\n        \"\"\"\n        n = 0\n        l = self.get_messages(page_size, vtimeout)\n        while l:\n            for m in l:\n                n += 1\n            l = self.get_messages(page_size, vtimeout)\n        return n"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving all messages from the queue to a file - like object.", "response": "def save_to_file(self, fp, sep='\\n'):\n        \"\"\"\n        Read all messages from the queue and persist them to file-like object.\n        Messages are written to the file and the 'sep' string is written\n        in between messages.  Messages are deleted from the queue after\n        being written to the file.\n        Returns the number of messages saved.\n        \"\"\"\n        n = 0\n        m = self.read()\n        while m:\n            n += 1\n            fp.write(m.get_body())\n            if sep:\n                fp.write(sep)\n            self.delete_message(m)\n            m = self.read()\n        return n"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_to_filename(self, file_name, sep='\\n'):\n        fp = open(file_name, 'wb')\n        n = self.save_to_file(fp, sep)\n        fp.close()\n        return n", "response": "Save all messages from the queue to a local file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_to_s3(self, bucket):\n        n = 0\n        m = self.read()\n        while m:\n            n += 1\n            key = bucket.new_key('%s/%s' % (self.id, m.id))\n            key.set_contents_from_string(m.get_body())\n            self.delete_message(m)\n            m = self.read()\n        return n", "response": "Save all messages from the queue to S3."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading all messages from S3 bucket.", "response": "def load_from_s3(self, bucket, prefix=None):\n        \"\"\"\n        Load messages previously saved to S3.\n        \"\"\"\n        n = 0\n        if prefix:\n            prefix = '%s/' % prefix\n        else:\n            prefix = '%s/' % self.id[1:]\n        rs = bucket.list(prefix=prefix)\n        for key in rs:\n            n += 1\n            m = self.new_message(key.get_contents_as_string())\n            self.write(m)\n        return n"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_from_file(self, fp, sep='\\n'):\n        n = 0\n        body = ''\n        l = fp.readline()\n        while l:\n            if l == sep:\n                m = Message(self, body)\n                self.write(m)\n                n += 1\n                print 'writing message %d' % n\n                body = ''\n            else:\n                body = body + l\n            l = fp.readline()\n        return n", "response": "Utility function to load messages from a file - like object to a queue"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_from_filename(self, file_name, sep='\\n'):\n        fp = open(file_name, 'rb')\n        n = self.load_from_file(fp, sep)\n        fp.close()\n        return n", "response": "Utility function to load messages from a local filename to a queue"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef echo_event(data):\n    return click.echo(json.dumps(data, sort_keys=True, indent=2))", "response": "Echo a json dump of an object using click"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconnects to a Riemann server and sends events or query the index.", "response": "def main(ctx, host, port, transport_type, timeout, ca_certs):\n    \"\"\"Connects to a Riemann server to send events or query the index\n\n    By default, will attempt to contact Riemann on localhost:5555 over TCP. The\n    RIEMANN_HOST and RIEMANN_PORT environment variables can be used to\n    configure the host and port used. Command line parameters will override the\n    environment variables.\n\n    Use `-T none` to test commands without actually connecting to a server.\n    \"\"\"\n    if transport_type == 'udp':\n        if timeout is not None:\n            ctx.fail('--timeout cannot be used with the UDP transport')\n        transport = riemann_client.transport.UDPTransport(host, port)\n    elif transport_type == 'tcp':\n        transport = riemann_client.transport.TCPTransport(host, port, timeout)\n    elif transport_type == 'tls':\n        if ca_certs is None:\n            ctx.fail('--ca-certs must be set when using the TLS transport')\n        transport = riemann_client.transport.TLSTransport(\n            host, port, timeout, ca_certs)\n    elif transport_type == 'none':\n        transport = riemann_client.transport.BlankTransport()\n\n    ctx.obj = transport"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending a single event to Riemann", "response": "def send(transport, time, state, host, description, service, tag, attribute,\n         ttl, metric_f, echo):\n    \"\"\"Send a single event to Riemann\"\"\"\n    client = CommandLineClient(transport)\n    event = client.create_event({\n        'time': time,\n        'state': state,\n        'host': host,\n        'description': description,\n        'service': service,\n        'tags': tag,\n        'attributes': dict(attribute),\n        'ttl': ttl,\n        'metric_f': metric_f\n    })\n\n    with client:\n        client.send_event(event)\n    if echo:\n        echo_event(client.create_dict(event))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef query(transport, query):\n    with CommandLineClient(transport) as client:\n        echo_event(client.query(query))", "response": "Query the Riemann server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef put_attributes(self, attrs):\n        assert(isinstance(attrs, dict)), \"Argument must be a dict of key->values to save\"\n        for prop_name in attrs:\n            value = attrs[prop_name]\n            prop = self.find_property(prop_name)\n            assert(prop), \"Property not found: %s\" % prop_name\n            self._manager.set_property(prop, self, prop_name, value)\n        self.reload()\n        return self", "response": "Save attributes to the object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_attributes(self, attrs):\n        assert(isinstance(attrs, list)), \"Argument must be a list of names of keys to delete.\"\n        self._manager.domain.delete_attributes(self.id, attrs)\n        self.reload()\n        return self", "response": "Delete attributes from the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_subclass(cls, name):\n        if name == cls.__name__:\n            return cls\n        for sc in cls.__sub_classes__:\n            r = sc.find_subclass(name)\n            if r != None:\n                return r", "response": "Find a subclass with a given name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self):\n        if not self.access_point:\n            return\n\n        new_hc = self.connection.configure_health_check(self.access_point, self)\n        self.interval = new_hc.interval\n        self.target = new_hc.target\n        self.healthy_threshold = new_hc.healthy_threshold\n        self.unhealthy_threshold = new_hc.unhealthy_threshold\n        self.timeout = new_hc.timeout", "response": "This method updates the health check attributes of the current instance with the new values from the existing health check attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_uploads(content, template_path=\"adminfiles/render/\"):\n    def _replace(match):\n        upload, options = parse_match(match)\n        return render_upload(upload, template_path, **options)\n    return oembed_replace(substitute_uploads(content, _replace))", "response": "Replace all uploaded file references in a content string with the appropriate embed markup."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrender a single file upload using the given template_path and options and return the rendered HTML.", "response": "def render_upload(upload, template_path=\"adminfiles/render/\", **options):\n    \"\"\"\n    Render a single ``FileUpload`` model instance using the\n    appropriate rendering template and the given keyword options, and\n    return the rendered HTML.\n    \n    The template used to render each upload is selected based on the\n    mime-type of the upload. For an upload with mime-type\n    \"image/jpeg\", assuming the default ``template_path`` of\n    \"adminfiles/render\", the template used would be the first one\n    found of the following: ``adminfiles/render/image/jpeg.html``,\n    ``adminfiles/render/image/default.html``, and\n    ``adminfiles/render/default.html``\n    \n    \"\"\"\n    if upload is None:\n        return settings.ADMINFILES_STRING_IF_NOT_FOUND\n    template_name = options.pop('as', None)\n    if template_name:\n        templates = [template_name,\n                     \"%s/default\" % template_name.split('/')[0],\n                     \"default\"]\n    else:\n        templates = [join(upload.content_type, upload.sub_type),\n                     join(upload.content_type, \"default\"),\n                     \"default\"]\n    tpl = template.loader.select_template(\n        [\"%s.html\" % join(template_path, p) for p in templates])\n    return tpl.render(template.Context({'upload': upload,\n                                        'options': options}))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the metadata of API WorkItem into a tuple.", "response": "def parse_meta(meta):\n    \"\"\"\n    Parse metadata of API\n\n    Args:\n        meta: metadata of API\n    Returns:\n        tuple(url_prefix, auth_header, resources)\n    \"\"\"\n    resources = {}\n    for name in meta:\n        if name.startswith(\"$\"):\n            continue\n        resources[name] = resource = {}\n        for action in meta[name]:\n            if action.startswith(\"$\"):\n                continue\n            url, httpmethod = res_to_url(name, action)\n            resource[action] = {\n                \"url\": url,\n                \"method\": httpmethod\n            }\n    url_prefix = meta.get(\"$url_prefix\", \"\").rstrip(\"/\")\n    return url_prefix, meta[\"$auth\"][\"header\"].lower(), resources"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates res. core. js", "response": "def render_core(url_prefix, auth_header, resources):\n    \"\"\"Generate res.core.js\"\"\"\n    code = ''\n    code += \"function(root, init) {\\n\"\n    code += \"  var q = init('%(auth_header)s', '%(url_prefix)s');\\n\" %\\\n        {'url_prefix': url_prefix, 'auth_header': auth_header}\n    code += \"  var r = null;\\n\"\n    for key in resources:\n        code += \"  r = root.%(key)s = {};\\n\" % {'key': key}\n        for action, item in resources[key].items():\n            code += \"    r.%(action)s = q('%(url)s', '%(method)s');\\n\" %\\\n                {'action': action,\n                 'url': item['url'],\n                 'method': item['method']}\n    code += \"}\"\n    return code"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating res. js source code for a single APIVersion.", "response": "def generate_code(meta, prefix=None, node=False, min=False):\n    \"\"\"\n    Generate res.js\n\n    Args:\n        meta: tuple(url_prefix, auth_header, resources) or metadata of API\n    Returns:\n        res.js source code\n    \"\"\"\n    if isinstance(meta, dict):\n        url_prefix, auth_header, resources = parse_meta(meta)\n    else:\n        url_prefix, auth_header, resources = meta\n    if prefix is not None:\n        url_prefix = prefix\n    core = render_core(url_prefix, auth_header, resources)\n    if min:\n        filename = 'res.web.min.js'\n    else:\n        filename = 'res.web.js'\n    if node:\n        filename = 'res.node.js'\n    base = read_file(filename)\n    return base.replace('\"#res.core.js#\"', core)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate res. js and save it", "response": "def resjs(url, dest='./res.js', prefix=None, node=False, min=False):\n    \"\"\"Generate res.js and save it\"\"\"\n    meta = requests.get(url, headers={'Accept': 'application/json'}).json()\n    code = generate_code(meta, prefix, node, min)\n    save_file(dest, code)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Queue(hub, size):\n    assert size > 0\n\n    def main(upstream, downstream, size):\n        queue = collections.deque()\n\n        while True:\n            if downstream.halted:\n                # no one is downstream, so shutdown\n                upstream.close()\n                return\n\n            watch = []\n            if queue:\n                watch.append(downstream)\n            else:\n                # if the buffer is empty, and no one is upstream, shutdown\n                if upstream.halted:\n                    downstream.close()\n                    return\n\n            # if are upstream is still available, and there is spare room in\n            # the buffer, watch upstream as well\n            if not upstream.halted and len(queue) < size:\n                watch.append(upstream)\n\n            try:\n                ch, item = hub.select(watch)\n            except vanilla.exception.Halt:\n                continue\n\n            if ch == upstream:\n                queue.append(item)\n\n            elif ch == downstream:\n                item = queue.popleft()\n                downstream.send(item)\n\n    upstream = hub.pipe()\n    downstream = hub.pipe()\n\n    # TODO: rethink this\n    old_connect = upstream.sender.connect\n\n    def connect(recver):\n        old_connect(recver)\n        return downstream.recver\n\n    upstream.sender.connect = connect\n\n    hub.spawn(main, upstream.recver, downstream.sender, size)\n    return Pair(upstream.sender, downstream.recver)", "response": "A Queue of size size."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend an item on this pair.", "response": "def send(self, item, timeout=-1):\n        \"\"\"\n        Send an *item* on this pair. This will block unless our Rever is ready,\n        either forever or until *timeout* milliseconds.\n        \"\"\"\n        return self.sender.send(item, timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pipe(self, target):\n        return self._replace(recver=self.recver.pipe(target))", "response": "Pipe our current Sender to the target."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmap this Pair with f * ; see vanilla. core. Recver. map", "response": "def map(self, f):\n        \"\"\"\n        Maps this Pair with *f*'; see :meth:`vanilla.core.Recver.map`\n\n        Returns a new Pair of our current Sender and the mapped target's\n        Recver.\n        \"\"\"\n        return self._replace(recver=self.recver.map(f))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send(self, item, timeout=-1):\n        if not self.ready:\n            self.pause(timeout=timeout)\n\n        if isinstance(item, Exception):\n            return self.hub.throw_to(self.other.peak, item)\n\n        return self.hub.switch_to(self.other.peak, self.other, item)", "response": "Send an item on this pair."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self, recver):\n        r1 = recver\n        m1 = r1.middle\n        s2 = self\n        m2 = self.middle\n        r2 = self.other\n\n        r2.middle = m1\n        del m2.sender\n        del m2.recver\n\n        del m1.recver\n        m1.recver = weakref.ref(r2, m1.on_abandoned)\n        m1.recver_current = m2.recver_current\n\n        del r1.middle\n        del s2.middle\n\n        # if we are currently a chain, return the last recver of our chain\n        while True:\n            if getattr(r2, 'downstream', None) is None:\n                break\n            r2 = r2.downstream.other\n        return r2", "response": "Connect the recver to the current one."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef recv(self, timeout=-1):\n        if self.ready:\n            return self.other.handover(self)\n\n        return self.pause(timeout=timeout)", "response": "Receive and return a new item."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pipe(self, target):\n        if callable(target):\n            sender, recver = self.hub.pipe()\n\n            # link the two ends in the closure with a strong reference to\n            # prevent them from being garbage collected if this piped section\n            # is used in a chain\n            self.downstream = sender\n            sender.upstream = self\n\n            @self.hub.spawn\n            def _():\n                try:\n                    target(self, sender)\n                except vanilla.exception.Halt:\n                    sender.close()\n\n            return recver\n\n        else:\n            return target.connect(self)", "response": "Pipes this Recver to target."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef map(self, f):\n        @self.pipe\n        def recver(recver, sender):\n            for item in recver:\n                try:\n                    sender.send(f(item))\n                except Exception, e:\n                    sender.send(e)\n        return recver", "response": "A pipe that maps the items in the list to the new ones."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a sink which consumes all values for this Recver and sends a Hello message to the sender.", "response": "def consume(self, f):\n        \"\"\"\n        Creates a sink which consumes all values for this Recver. *f* is a\n        callable which takes a single argument. All values sent on this\n        Recver's Sender will be passed to *f* for processing. Unlike *map*\n        however consume terminates this chain::\n\n            sender, recver = h.pipe\n\n            @recver.consume\n            def _(data):\n                logging.info(data)\n\n            sender.send('Hello') # logs 'Hello'\n        \"\"\"\n        @self.hub.spawn\n        def _():\n            for item in self:\n                # TODO: think through whether trapping for HALT here is a good\n                # idea\n                try:\n                    f(item)\n                except vanilla.exception.Halt:\n                    self.close()\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a list of paths and a list of binary images this returns a dictionary of image addresses to the locations on the file system for all found images.", "response": "def find_debug_images(dsym_paths, binary_images):\n    \"\"\"Given a list of paths and a list of binary images this returns a\n    dictionary of image addresses to the locations on the file system for\n    all found images.\n    \"\"\"\n    images_to_load = set()\n\n    with timedsection('iterimages0'):\n        for image in binary_images:\n            if get_image_cpu_name(image) is not None:\n                images_to_load.add(image['uuid'].lower())\n\n    images = {}\n\n    # Step one: load images that are named by their UUID\n    with timedsection('loadimages-fast'):\n        for uuid in list(images_to_load):\n            for dsym_path in dsym_paths:\n                fn = os.path.join(dsym_path, uuid)\n                if os.path.isfile(fn):\n                    images[uuid] = fn\n                    images_to_load.discard(uuid)\n                    break\n\n    # Otherwise fall back to loading images from the dsym bundle.  Because\n    # this loading strategy is pretty slow we do't actually want to use it\n    # unless we have a path that looks like a bundle.  As a result we\n    # find all the paths which are bundles and then only process those.\n    if images_to_load:\n        slow_paths = []\n        for dsym_path in dsym_paths:\n            if os.path.isdir(os.path.join(dsym_path, 'Contents')):\n                slow_paths.append(dsym_path)\n\n        with timedsection('loadimages-slow'):\n            for dsym_path in slow_paths:\n                dwarf_base = os.path.join(dsym_path, 'Contents',\n                                          'Resources', 'DWARF')\n                if os.path.isdir(dwarf_base):\n                    for fn in os.listdir(dwarf_base):\n                        # Looks like a UUID we loaded, skip it\n                        if fn in images:\n                            continue\n                        full_fn = os.path.join(dwarf_base, fn)\n                        try:\n                            di = DebugInfo.open_path(full_fn)\n                        except DebugInfoError:\n                            continue\n                        for variant in di.get_variants():\n                            uuid = str(variant.uuid)\n                            if uuid in images_to_load:\n                                images[uuid] = full_fn\n                                images_to_load.discard(uuid)\n\n    rv = {}\n\n    # Now resolve all the images.\n    with timedsection('resolveimages'):\n        for image in binary_images:\n            cpu_name = get_image_cpu_name(image)\n            if cpu_name is None:\n                continue\n            uid = image['uuid'].lower()\n            if uid not in images:\n                continue\n            rv[parse_addr(image['image_addr'])] = images[uid]\n\n    return rv"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngives an instruction address this locates the image this address is contained in.", "response": "def find_image(self, addr):\n        \"\"\"Given an instruction address this locates the image this address\n        is contained in.\n        \"\"\"\n        idx = bisect.bisect_left(self._image_addresses, parse_addr(addr))\n        if idx > 0:\n            return self.images[self._image_addresses[idx - 1]]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef file_md5sum(filename):\n    '''Calculate and returns an MD5 checksum for the specified file.  Any file\n    errors (non-existent file, read error, etc.) are not handled here but should\n    be caught where this method is called.\n\n    :param filename: full path to the file for which a checksum should be calculated\n    :returns: hex-digest formatted MD5 checksum as a string\n    '''\n    # duplicated from keep.common.utils\n    # possibly at some point this should be moved to a common codebase/library\n    md5 = hashlib.md5()\n    with open(filename, 'rb') as filedata:\n        for chunk in iter(lambda: filedata.read(128 * md5.block_size), b''):\n            md5.update(chunk)\n    return md5.hexdigest()", "response": "Calculate and returns an MD5 checksum for the specified file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef md5sum(content):\n    '''Calculate and returns an MD5 checksum for the specified content.\n\n    :param content: text content\n    :returns: hex-digest formatted MD5 checksum as a string\n    '''\n    md5 = hashlib.md5()\n    md5.update(force_bytes(content))\n    return md5.hexdigest()", "response": "Calculate and returns an MD5 checksum for the specified content."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _build_list_params(self, params, items, label):\n        if isinstance(items, basestring):\n            items = [items]\n        for i in range(1, len(items) + 1):\n            params['%s.%d' % (label, i)] = items[i - 1]", "response": "Add an AWS API - compatible parameter list to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a request to the SES API.", "response": "def _make_request(self, action, params=None):\n        \"\"\"Make a call to the SES API.\n\n        :type action: string\n        :param action: The API method to use (e.g. SendRawEmail)\n\n        :type params: dict\n        :param params: Parameters that will be sent as POST data with the API\n            call.\n        \"\"\"\n        ct = 'application/x-www-form-urlencoded; charset=UTF-8'\n        headers = {'Content-Type': ct}\n        params = params or {}\n        params['Action'] = action\n\n        for k, v in params.items():\n            if isinstance(v, unicode):  # UTF-8 encode only if it's Unicode\n                params[k] = v.encode('utf-8')\n\n        response = super(SESConnection, self).make_request(\n            'POST',\n            '/',\n            headers=headers,\n            data=urllib.urlencode(params)\n        )\n        body = response.read()\n        if response.status == 200:\n            list_markers = ('VerifiedEmailAddresses', 'SendDataPoints')\n            e = boto.jsonresponse.Element(list_marker=list_markers)\n            h = boto.jsonresponse.XmlHandler(e, None)\n            h.parse(body)\n            return e\n        else:\n            # HTTP codes other than 200 are considered errors. Go through\n            # some error handling to determine which exception gets raised,\n            self._handle_error(response, body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _handle_error(self, response, body):\n        boto.log.error('%s %s' % (response.status, response.reason))\n        boto.log.error('%s' % body)\n\n        if \"Address blacklisted.\" in body:\n            # Delivery failures happened frequently enough with the recipient's\n            # email address for Amazon to blacklist it. After a day or three,\n            # they'll be automatically removed, and delivery can be attempted\n            # again (if you write the code to do so in your application).\n            ExceptionToRaise = ses_exceptions.SESAddressBlacklistedError\n            exc_reason = \"Address blacklisted.\"\n        elif \"Email address is not verified.\" in body:\n            # This error happens when the \"Reply-To\" value passed to\n            # send_email() hasn't been verified yet.\n            ExceptionToRaise = ses_exceptions.SESAddressNotVerifiedError\n            exc_reason = \"Email address is not verified.\"\n        elif \"Daily message quota exceeded.\" in body:\n            # Encountered when your account exceeds the maximum total number\n            # of emails per 24 hours.\n            ExceptionToRaise = ses_exceptions.SESDailyQuotaExceededError\n            exc_reason = \"Daily message quota exceeded.\"\n        elif \"Maximum sending rate exceeded.\" in body:\n            # Your account has sent above its allowed requests a second rate.\n            ExceptionToRaise = ses_exceptions.SESMaxSendingRateExceededError\n            exc_reason = \"Maximum sending rate exceeded.\"\n        elif \"Domain ends with dot.\" in body:\n            # Recipient address ends with a dot/period. This is invalid.\n            ExceptionToRaise = ses_exceptions.SESDomainEndsWithDotError\n            exc_reason = \"Domain ends with dot.\"\n        else:\n            # This is either a common AWS error, or one that we don't devote\n            # its own exception to.\n            ExceptionToRaise = self.ResponseError\n            exc_reason = response.reason\n\n        raise ExceptionToRaise(response.status, exc_reason, body)", "response": "Handle the error response from the server and raise the appropriate exception."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomposes an email message based on input data and then immediately queues the message for sending.", "response": "def send_email(self, source, subject, body, to_addresses, cc_addresses=None,\n                   bcc_addresses=None, format='text', reply_addresses=None,\n                   return_path=None, text_body=None, html_body=None):\n        \"\"\"Composes an email message based on input data, and then immediately\n        queues the message for sending.\n\n        :type source: string\n        :param source: The sender's email address.\n\n        :type subject: string\n        :param subject: The subject of the message: A short summary of the\n                        content, which will appear in the recipient's inbox.\n\n        :type body: string\n        :param body: The message body.\n\n        :type to_addresses: list of strings or string\n        :param to_addresses: The To: field(s) of the message.\n\n        :type cc_addresses: list of strings or string\n        :param cc_addresses: The CC: field(s) of the message.\n\n        :type bcc_addresses: list of strings or string\n        :param bcc_addresses: The BCC: field(s) of the message.\n\n        :type format: string\n        :param format: The format of the message's body, must be either \"text\"\n                       or \"html\".\n\n        :type reply_addresses: list of strings or string\n        :param reply_addresses: The reply-to email address(es) for the\n                                message. If the recipient replies to the\n                                message, each reply-to address will\n                                receive the reply.\n\n        :type return_path: string\n        :param return_path: The email address to which bounce notifications are\n                            to be forwarded. If the message cannot be delivered\n                            to the recipient, then an error message will be\n                            returned from the recipient's ISP; this message will\n                            then be forwarded to the email address specified by\n                            the ReturnPath parameter.\n\n        :type text_body: string\n        :param text_body: The text body to send with this email.\n\n        :type html_body: string\n        :param html_body: The html body to send with this email.\n\n        \"\"\"\n        format = format.lower().strip()\n        if body is not None:\n            if format == \"text\":\n                if text_body is not None:\n                    raise Warning(\"You've passed in both a body and a text_body; please choose one or the other.\")\n                text_body = body\n            else:\n                if html_body is not None:\n                    raise Warning(\"You've passed in both a body and an html_body; please choose one or the other.\")\n                html_body = body\n\n        params = {\n            'Source': source,\n            'Message.Subject.Data': subject,\n        }\n\n        if return_path:\n            params['ReturnPath'] = return_path\n\n        if html_body is not None:\n            params['Message.Body.Html.Data'] = html_body\n        if text_body is not None:\n            params['Message.Body.Text.Data'] = text_body\n\n        if(format not in (\"text\",\"html\")):\n            raise ValueError(\"'format' argument must be 'text' or 'html'\")\n\n        if(not (html_body or text_body)):\n            raise ValueError(\"No text or html body found for mail\")\n\n        self._build_list_params(params, to_addresses,\n                               'Destination.ToAddresses.member')\n        if cc_addresses:\n            self._build_list_params(params, cc_addresses,\n                                   'Destination.CcAddresses.member')\n\n        if bcc_addresses:\n            self._build_list_params(params, bcc_addresses,\n                                   'Destination.BccAddresses.member')\n\n        if reply_addresses:\n            self._build_list_params(params, reply_addresses,\n                                   'ReplyToAddresses.member')\n\n        return self._make_request('SendEmail', params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend an email message with the raw text of the message.", "response": "def send_raw_email(self, raw_message, source=None, destinations=None):\n        \"\"\"Sends an email message, with header and content specified by the\n        client. The SendRawEmail action is useful for sending multipart MIME\n        emails, with attachments or inline content. The raw text of the message\n        must comply with Internet email standards; otherwise, the message\n        cannot be sent.\n\n        :type source: string\n        :param source: The sender's email address. Amazon's docs say:\n\n          If you specify the Source parameter, then bounce notifications and\n          complaints will be sent to this email address. This takes precedence\n          over any Return-Path header that you might include in the raw text of\n          the message.\n\n        :type raw_message: string\n        :param raw_message: The raw text of the message. The client is\n          responsible for ensuring the following:\n\n          - Message must contain a header and a body, separated by a blank line.\n          - All required header fields must be present.\n          - Each part of a multipart MIME message must be formatted properly.\n          - MIME content types must be among those supported by Amazon SES.\n            Refer to the Amazon SES Developer Guide for more details.\n          - Content must be base64-encoded, if MIME requires it.\n\n        :type destinations: list of strings or string\n        :param destinations: A list of destinations for the message.\n\n        \"\"\"\n        params = {\n            'RawMessage.Data': base64.b64encode(raw_message),\n        }\n\n        if source:\n            params['Source'] = source\n\n        if destinations:\n            self._build_list_params(params, destinations,\n                                   'Destinations.member')\n\n        return self._make_request('SendRawEmail', params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self):\n        for item_name in self.item_names:\n            item = self.conn.get_attributes(self.domain_name, item_name)\n            self.items.append(item)", "response": "Start the threaded retrieval of items."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef print_usage(self):\n        print 'Total Usage: %f compute seconds' % self.box_usage\n        cost = self.box_usage * 0.14\n        print 'Approximate Cost: $%f' % cost", "response": "Print the BoxUsage and approximate Cost of all requests made on this specific SDBConnection instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_domain(self, domain_name, validate=True):\n        domain = Domain(self, domain_name)\n        if validate:\n            self.select(domain, \"\"\"select * from `%s` limit 1\"\"\" % domain_name)\n        return domain", "response": "Retrieves a domain object with the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_domains(self, max_domains=None, next_token=None):\n        params = {}\n        if max_domains:\n            params['MaxNumberOfDomains'] = max_domains\n        if next_token:\n            params['NextToken'] = next_token\n        return self.get_list('ListDomains', params, [('DomainName', Domain)])", "response": "Returns a list of all domains associated with this connection s Access Key ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_domain(self, domain_name):\n        params = {'DomainName':domain_name}\n        d = self.get_object('CreateDomain', params, Domain)\n        d.name = domain_name\n        return d", "response": "Create a SimpleDB domain."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a tuple with the domain and name for the requested domain or name.", "response": "def get_domain_and_name(self, domain_or_name):\n        \"\"\"\n        Given a ``str`` or :class:`boto.sdb.domain.Domain`, return a\n        ``tuple`` with the following members (in order):\n        \n            * In instance of :class:`boto.sdb.domain.Domain` for the requested\n              domain\n            * The domain's name as a ``str``\n            \n        :type domain_or_name: ``str`` or :class:`boto.sdb.domain.Domain`\n        :param domain_or_name: The domain or domain name to get the domain\n            and name for.\n            \n        :raises: :class:`boto.exception.SDBResponseError` when an invalid\n            domain name is specified.\n            \n        :rtype: tuple\n        :return: A ``tuple`` with contents outlined as per above.\n        \"\"\"\n        if (isinstance(domain_or_name, Domain)):\n            return (domain_or_name, domain_or_name.name)\n        else:\n            return (self.get_domain(domain_or_name), domain_or_name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_domain(self, domain_or_name):\n        domain, domain_name = self.get_domain_and_name(domain_or_name)\n        params = {'DomainName':domain_name}\n        return self.get_status('DeleteDomain', params)", "response": "Delete a SimpleDB domain."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the Metadata for a SimpleDB domain.", "response": "def domain_metadata(self, domain_or_name):\n        \"\"\"\n        Get the Metadata for a SimpleDB domain.\n\n        :type domain_or_name: string or :class:`boto.sdb.domain.Domain` object.\n        :param domain_or_name: Either the name of a domain or a Domain object\n\n        :rtype: :class:`boto.sdb.domain.DomainMetaData` object\n        :return: The newly created domain metadata object\n        \"\"\"\n        domain, domain_name = self.get_domain_and_name(domain_or_name)\n        params = {'DomainName':domain_name}\n        d = self.get_object('DomainMetadata', params, DomainMetaData)\n        d.domain = domain\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstores attributes for multiple items in a domain.", "response": "def batch_put_attributes(self, domain_or_name, items, replace=True):\n        \"\"\"\n        Store attributes for multiple items in a domain.\n        \n        :type domain_or_name: string or :class:`boto.sdb.domain.Domain` object.\n        :param domain_or_name: Either the name of a domain or a Domain object\n\n        :type items: dict or dict-like object\n        :param items: A dictionary-like object.  The keys of the dictionary are\n                      the item names and the values are themselves dictionaries\n                      of attribute names/values, exactly the same as the\n                      attribute_names parameter of the scalar put_attributes\n                      call.\n        \n        :type replace: bool\n        :param replace: Whether the attribute values passed in will replace\n                        existing values or will be added as addition values.\n                        Defaults to True.\n        \n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        domain, domain_name = self.get_domain_and_name(domain_or_name)\n        params = {'DomainName' : domain_name}\n        self._build_batch_list(params, items, replace)\n        return self.get_status('BatchPutAttributes', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving attributes for a given item in a domain. :type domain_or_name: string or :class:`boto.sdb.domain.Domain` object. :param domain_or_name: Either the name of a domain or a Domain object :type item_name: string :param item_name: The name of the item whose attributes are being retrieved. :type attribute_names: string or list of strings :param attribute_names: An attribute name or list of attribute names. This parameter is optional. If not supplied, all attributes will be retrieved for the item. :type consistent_read: bool :param consistent_read: When set to true, ensures that the most recent data is returned. :type item: :class:`boto.sdb.item.Item` :keyword item: Instead of instantiating a new Item object, you may specify one to update. :rtype: :class:`boto.sdb.item.Item` :return: An Item with the requested attribute name/values set on it", "response": "def get_attributes(self, domain_or_name, item_name, attribute_names=None,\n                       consistent_read=False, item=None):\n        \"\"\"\n        Retrieve attributes for a given item in a domain.\n\n        :type domain_or_name: string or :class:`boto.sdb.domain.Domain` object.\n        :param domain_or_name: Either the name of a domain or a Domain object\n\n        :type item_name: string\n        :param item_name: The name of the item whose attributes are \n            being retrieved.\n\n        :type attribute_names: string or list of strings\n        :param attribute_names: An attribute name or list of attribute names.\n            This parameter is optional.  If not supplied, all attributes will \n            be retrieved for the item.\n\n        :type consistent_read: bool\n        :param consistent_read: When set to true, ensures that the most recent\n            data is returned.\n                                \n        :type item: :class:`boto.sdb.item.Item`\n        :keyword item: Instead of instantiating a new Item object, you may\n            specify one to update.\n\n        :rtype: :class:`boto.sdb.item.Item`\n        :return: An Item with the requested attribute name/values set on it\n        \"\"\"\n        domain, domain_name = self.get_domain_and_name(domain_or_name)\n        params = {'DomainName' : domain_name,\n                  'ItemName' : item_name}\n        if consistent_read:\n            params['ConsistentRead'] = 'true'\n        if attribute_names:\n            if not isinstance(attribute_names, list):\n                attribute_names = [attribute_names]\n            self.build_list_params(params, attribute_names, 'AttributeName')\n        response = self.make_request('GetAttributes', params)\n        body = response.read()\n        if response.status == 200:\n            if item == None:\n                item = self.item_cls(domain, item_name)\n            h = handler.XmlHandler(item, self)\n            xml.sax.parseString(body, h)\n            return item\n        else:\n            raise SDBResponseError(response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting attributes from a given item in a domain. :type domain_or_name: string or :class:`boto.sdb.domain.Domain` object. :param domain_or_name: Either the name of a domain or a Domain object :type item_name: string :param item_name: The name of the item whose attributes are being deleted. :type attributes: dict, list or :class:`boto.sdb.item.Item` :param attributes: Either a list containing attribute names which will cause all values associated with that attribute name to be deleted or a dict or Item containing the attribute names and keys and list of values to delete as the value. If no value is supplied, all attribute name/values for the item will be deleted. :type expected_value: list :param expected_value: If supplied, this is a list or tuple consisting of a single attribute name and expected value. The list can be of the form: * ['name', 'value'] In which case the call will first verify that the attribute \"name\" of this item has a value of \"value\". If it does, the delete will proceed, otherwise a ConditionalCheckFailed error will be returned. The list can also be of the form: * ['name', True|False] which will simply check for the existence (True) or non-existence (False) of the attribute. :rtype: bool :return: True if successful", "response": "def delete_attributes(self, domain_or_name, item_name, attr_names=None,\n                          expected_value=None):\n        \"\"\"\n        Delete attributes from a given item in a domain.\n\n        :type domain_or_name: string or :class:`boto.sdb.domain.Domain` object.\n        :param domain_or_name: Either the name of a domain or a Domain object\n\n        :type item_name: string\n        :param item_name: The name of the item whose attributes are being\n                          deleted.\n\n        :type attributes: dict, list or :class:`boto.sdb.item.Item`\n        :param attributes: Either a list containing attribute names which\n                           will cause all values associated with that attribute\n                           name to be deleted or a dict or Item containing the\n                           attribute names and keys and list of values to\n                           delete as the value.  If no value is supplied,\n                           all attribute name/values for the item will be\n                           deleted.\n                           \n        :type expected_value: list\n        :param expected_value: If supplied, this is a list or tuple consisting\n            of a single attribute name and expected value. The list can be \n            of the form:\n\n                * ['name', 'value']\n\n            In which case the call will first verify that the attribute \"name\" \n            of this item has a value of \"value\".  If it does, the delete\n            will proceed, otherwise a ConditionalCheckFailed error will be \n            returned. The list can also be of the form:\n\n                * ['name', True|False]\n\n            which will simply check for the existence (True) or \n            non-existence (False) of the attribute.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        domain, domain_name = self.get_domain_and_name(domain_or_name)\n        params = {'DomainName':domain_name,\n                  'ItemName' : item_name}\n        if attr_names:\n            if isinstance(attr_names, list):\n                self._build_name_list(params, attr_names)\n            elif isinstance(attr_names, dict) or isinstance(attr_names, self.item_cls):\n                self._build_name_value_list(params, attr_names)\n        if expected_value:\n            self._build_expected_value(params, expected_value)\n        return self.get_status('DeleteAttributes', params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef batch_delete_attributes(self, domain_or_name, items):\n        domain, domain_name = self.get_domain_and_name(domain_or_name)\n        params = {'DomainName' : domain_name}\n        self._build_batch_list(params, items, False)\n        return self.get_status('BatchDeleteAttributes', params, verb='POST')", "response": "Delete multiple items in a domain."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an iterator that returns the attributes that match the query.", "response": "def select(self, domain_or_name, query='', next_token=None,\n               consistent_read=False):\n        \"\"\"\n        Returns a set of Attributes for item names within domain_name that\n        match the query.  The query must be expressed in using the SELECT\n        style syntax rather than the original SimpleDB query language.\n        Even though the select request does not require a domain object,\n        a domain object must be passed into this method so the Item objects\n        returned can point to the appropriate domain.\n        \n        :type domain_or_name: string or :class:`boto.sdb.domain.Domain` object\n        :param domain_or_name: Either the name of a domain or a Domain object\n\n        :type query: string\n        :param query: The SimpleDB query to be performed.\n\n        :type consistent_read: bool\n        :param consistent_read: When set to true, ensures that the most recent\n                                data is returned.\n\n        :rtype: ResultSet\n        :return: An iterator containing the results.\n        \"\"\"\n        domain, domain_name = self.get_domain_and_name(domain_or_name)\n        params = {'SelectExpression' : query}\n        if consistent_read:\n            params['ConsistentRead'] = 'true'\n        if next_token:\n            params['NextToken'] = next_token\n        try:\n            return self.get_list('Select', params, [('Item', self.item_cls)],\n                             parent=domain)\n        except SDBResponseError, e:\n            e.body = \"Query: %s\\n%s\" % (query, e.body)\n            raise e"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list(self, relpattern):\n        \"Note: partial implementation, just enough for the FeatureTracker\"\n        \n        parent_path = os.path.dirname(relpattern)\n        file_pattern = os.path.basename(relpattern)\n        parent = self._resolve_path(parent_path)\n        \n        if parent is None:\n            return []\n        else:\n            return [os.path.join(parent_path, name) \n                    for (name, mode, sha) in parent.iteritems() \n                    if fnmatch(name, file_pattern)]", "response": "Note : partial implementation just enough for the FeatureTracker"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_vpcs(self, vpc_ids=None, filters=None):\n        params = {}\n        if vpc_ids:\n            self.build_list_params(params, vpc_ids, 'VpcId')\n        if filters:\n            i = 1\n            for filter in filters:\n                params[('Filter.%d.Name' % i)] = filter[0]\n                params[('Filter.%d.Value.1' % i)] = filter[1]\n                i += 1\n        return self.get_list('DescribeVpcs', params, [('item', VPC)])", "response": "Retrieve information about your VPCs. You can filter results to retrieve information only about those VPCs associated with your account\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves information about your routing tables. You can filter results to return only those route tables that match your search parameters. Otherwise all route tables associated with your account are returned.", "response": "def get_all_route_tables(self, route_table_ids=None, filters=None):\n        \"\"\"\n        Retrieve information about your routing tables. You can filter results\n        to return information only about those route tables that match your\n        search parameters. Otherwise, all route tables associated with your\n        account are returned.\n\n        :type route_table_ids: list\n        :param route_table_ids: A list of strings with the desired route table\n                                IDs.\n\n        :type filters: list of tuples\n        :param filters: A list of tuples containing filters. Each tuple\n                        consists of a filter key and a filter value.\n\n        :rtype: list\n        :return: A list of :class:`boto.vpc.routetable.RouteTable`\n        \"\"\"\n        params = {}\n        if route_table_ids:\n            self.build_list_params(params, route_table_ids, \"RouteTableId\")\n        if filters:\n            self.build_filter_params(params, dict(filters))\n        return self.get_list('DescribeRouteTables', params, [('item', RouteTable)])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassociate a route table with a specific subnet. :type route_table_id: str :param route_table_id: The ID of the route table to associate. :type subnet_id: str :param subnet_id: The ID of the subnet to associate with. :rtype: str :return: The ID of the association created", "response": "def associate_route_table(self, route_table_id, subnet_id):\n        \"\"\"\n        Associates a route table with a specific subnet.\n\n        :type route_table_id: str\n        :param route_table_id: The ID of the route table to associate.\n\n        :type subnet_id: str\n        :param subnet_id: The ID of the subnet to associate with.\n\n        :rtype: str\n        :return: The ID of the association created\n        \"\"\"\n        params = {\n            'RouteTableId': route_table_id,\n            'SubnetId': subnet_id\n        }\n\n        result = self.get_object('AssociateRouteTable', params, ResultSet)\n        return result.associationId"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_route(self, route_table_id, destination_cidr_block, gateway_id=None, instance_id=None):\n        params = {\n            'RouteTableId': route_table_id,\n            'DestinationCidrBlock': destination_cidr_block\n        }\n\n        if gateway_id is not None:\n            params['GatewayId'] = gateway_id\n        elif instance_id is not None:\n            params['InstanceId'] = instance_id\n\n        return self.get_status('CreateRoute', params)", "response": "Creates a new route in the route table."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes a route from a route table within a VPC.", "response": "def delete_route(self, route_table_id, destination_cidr_block):\n        \"\"\"\n        Deletes a route from a route table within a VPC.\n\n        :type route_table_id: str\n        :param route_table_id: The ID of the route table with the route.\n\n        :type destination_cidr_block: str\n        :param destination_cidr_block: The CIDR address block used for\n                                       destination match.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        params = {\n            'RouteTableId': route_table_id,\n            'DestinationCidrBlock': destination_cidr_block\n        }\n\n        return self.get_status('DeleteRoute', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_all_internet_gateways(self, internet_gateway_ids=None, filters=None):\n        params = {}\n\n        if internet_gateway_ids:\n            self.build_list_params(params, internet_gateway_ids, 'InternetGatewayId')\n        if filters:\n            self.build_filter_params(params, dict(filters))\n\n        return self.get_list('DescribeInternetGateways', params, [('item', InternetGateway)])", "response": "Get a list of internet gateways. You can filter results to return information\n        about those gateways that you re interested in."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef attach_internet_gateway(self, internet_gateway_id, vpc_id):\n        params = {\n            'InternetGatewayId': internet_gateway_id,\n            'VpcId': vpc_id\n        }\n\n        return self.get_status('AttachInternetGateway', params)", "response": "Attach an internet gateway to a specific VPC."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndetach an internet gateway from a specific VPC.", "response": "def detach_internet_gateway(self, internet_gateway_id, vpc_id):\n        \"\"\"\n        Detach an internet gateway from a specific VPC.\n\n        :type internet_gateway_id: str\n        :param internet_gateway_id: The ID of the internet gateway to delete.\n\n        :type vpc_id: str\n        :param vpc_id: The ID of the VPC to attach to.\n\n        :rtype: Bool\n        :return: True if successful\n        \"\"\"\n        params = {\n            'InternetGatewayId': internet_gateway_id,\n            'VpcId': vpc_id\n        }\n\n        return self.get_status('DetachInternetGateway', params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve information about your CustomerGateways. You can filter results to return only those CustomerGateways that match your search parameters. You can filter results to return only those CustomerGateways that match your search parameters.", "response": "def get_all_customer_gateways(self, customer_gateway_ids=None, filters=None):\n        \"\"\"\n        Retrieve information about your CustomerGateways.  You can filter results to\n        return information only about those CustomerGateways that match your search\n        parameters.  Otherwise, all CustomerGateways associated with your account\n        are returned.\n\n        :type customer_gateway_ids: list\n        :param customer_gateway_ids: A list of strings with the desired CustomerGateway ID's\n\n        :type filters: list of tuples\n        :param filters: A list of tuples containing filters.  Each tuple\n                        consists of a filter key and a filter value.\n                        Possible filter keys are:\n\n                         - *state*, the state of the CustomerGateway\n                           (pending,available,deleting,deleted)\n                         - *type*, the type of customer gateway (ipsec.1)\n                         - *ipAddress* the IP address of customer gateway's\n                           internet-routable external inteface\n\n        :rtype: list\n        :return: A list of :class:`boto.vpc.customergateway.CustomerGateway`\n        \"\"\"\n        params = {}\n        if customer_gateway_ids:\n            self.build_list_params(params, customer_gateway_ids, 'CustomerGatewayId')\n        if filters:\n            i = 1\n            for filter in filters:\n                params[('Filter.%d.Name' % i)] = filter[0]\n                params[('Filter.%d.Value.1')] = filter[1]\n                i += 1\n        return self.get_list('DescribeCustomerGateways', params, [('item', CustomerGateway)])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_customer_gateway(self, type, ip_address, bgp_asn):\n        params = {'Type' : type,\n                  'IpAddress' : ip_address,\n                  'BgpAsn' : bgp_asn}\n        return self.get_object('CreateCustomerGateway', params, CustomerGateway)", "response": "Create a new Customer Gateway object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_vpn_gateways(self, vpn_gateway_ids=None, filters=None):\n        params = {}\n        if vpn_gateway_ids:\n            self.build_list_params(params, vpn_gateway_ids, 'VpnGatewayId')\n        if filters:\n            i = 1\n            for filter in filters:\n                params[('Filter.%d.Name' % i)] = filter[0]\n                params[('Filter.%d.Value.1')] = filter[1]\n                i += 1\n        return self.get_list('DescribeVpnGateways', params, [('item', VpnGateway)])", "response": "Retrieve information about your VpnGateways. You can filter results to return only those VpnGateways that match your search\n        parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_vpn_gateway(self, type, availability_zone=None):\n        params = {'Type' : type}\n        if availability_zone:\n            params['AvailabilityZone'] = availability_zone\n        return self.get_object('CreateVpnGateway', params, VpnGateway)", "response": "Create a new VPN Gateway."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef attach_vpn_gateway(self, vpn_gateway_id, vpc_id):\n        params = {'VpnGatewayId': vpn_gateway_id,\n                  'VpcId' : vpc_id}\n        return self.get_object('AttachVpnGateway', params, Attachment)", "response": "Attaches a VPN gateway to a VPC."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving information about your Subnets. You can filter results to retrieve information only about those Subnets associated with your account . If no filter is specified all Subnets associated with your account are returned.", "response": "def get_all_subnets(self, subnet_ids=None, filters=None):\n        \"\"\"\n        Retrieve information about your Subnets.  You can filter results to\n        return information only about those Subnets that match your search\n        parameters.  Otherwise, all Subnets associated with your account\n        are returned.\n\n        :type subnet_ids: list\n        :param subnet_ids: A list of strings with the desired Subnet ID's\n\n        :type filters: list of tuples\n        :param filters: A list of tuples containing filters.  Each tuple\n                        consists of a filter key and a filter value.\n                        Possible filter keys are:\n\n                        - *state*, the state of the Subnet\n                          (pending,available)\n                        - *vpdId*, the ID of teh VPC the subnet is in.\n                        - *cidrBlock*, CIDR block of the subnet\n                        - *availabilityZone*, the Availability Zone\n                          the subnet is in.\n\n\n        :rtype: list\n        :return: A list of :class:`boto.vpc.subnet.Subnet`\n        \"\"\"\n        params = {}\n        if subnet_ids:\n            self.build_list_params(params, subnet_ids, 'SubnetId')\n        if filters:\n            i = 1\n            for filter in filters:\n                params[('Filter.%d.Name' % i)] = filter[0]\n                params[('Filter.%d.Value.1' % i)] = filter[1]\n                i += 1\n        return self.get_list('DescribeSubnets', params, [('item', Subnet)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new subnet in a specific VPC.", "response": "def create_subnet(self, vpc_id, cidr_block, availability_zone=None):\n        \"\"\"\n        Create a new Subnet\n\n        :type vpc_id: str\n        :param vpc_id: The ID of the VPC where you want to create the subnet.\n\n        :type cidr_block: str\n        :param cidr_block: The CIDR block you want the subnet to cover.\n\n        :type availability_zone: str\n        :param availability_zone: The AZ you want the subnet in\n\n        :rtype: The newly created Subnet\n        :return: A :class:`boto.vpc.customergateway.Subnet` object\n        \"\"\"\n        params = {'VpcId' : vpc_id,\n                  'CidrBlock' : cidr_block}\n        if availability_zone:\n            params['AvailabilityZone'] = availability_zone\n        return self.get_object('CreateSubnet', params, Subnet)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_dhcp_options(self, dhcp_options_ids=None):\n        params = {}\n        if dhcp_options_ids:\n            self.build_list_params(params, dhcp_options_ids, 'DhcpOptionsId')\n        return self.get_list('DescribeDhcpOptions', params, [('item', DhcpOptions)])", "response": "Retrieve information about your DhcpOptions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_dhcp_options(self, vpc_id, cidr_block, availability_zone=None):\n        params = {'VpcId' : vpc_id,\n                  'CidrBlock' : cidr_block}\n        if availability_zone:\n            params['AvailabilityZone'] = availability_zone\n        return self.get_object('CreateDhcpOption', params, DhcpOptions)", "response": "Create a new DhcpOption object for a given subnet."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nassociates a set of Dhcp Options with a VPC.", "response": "def associate_dhcp_options(self, dhcp_options_id, vpc_id):\n        \"\"\"\n        Associate a set of Dhcp Options with a VPC.\n\n        :type dhcp_options_id: str\n        :param dhcp_options_id: The ID of the Dhcp Options\n\n        :type vpc_id: str\n        :param vpc_id: The ID of the VPC.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        params = {'DhcpOptionsId': dhcp_options_id,\n                  'VpcId' : vpc_id}\n        return self.get_status('AssociateDhcpOptions', params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_vpn_connections(self, vpn_connection_ids=None, filters=None):\n        params = {}\n        if vpn_connection_ids:\n            self.build_list_params(params, vpn_connection_ids, 'Vpn_ConnectionId')\n        if filters:\n            i = 1\n            for filter in filters:\n                params[('Filter.%d.Name' % i)] = filter[0]\n                params[('Filter.%d.Value.1')] = filter[1]\n                i += 1\n        return self.get_list('DescribeVpnConnections', params, [('item', VpnConnection)])", "response": "Retrieve information about VPN_CONNECTIONs associated with your account."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_vpn_connection(self, type, customer_gateway_id, vpn_gateway_id):\n        params = {'Type' : type,\n                  'CustomerGatewayId' : customer_gateway_id,\n                  'VpnGatewayId' : vpn_gateway_id}\n        return self.get_object('CreateVpnConnection', params, VpnConnection)", "response": "Create a VPN Connection."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncatch fedora errors between all_fedora_access and all_fedora_failed.", "response": "def do_catch_fedora_errors(parser, token):\n    \"\"\"Catches fedora errors between ``{% fedora_access %}`` and\n    ``{% end_fedora_access %}``. Template designers may specify \n    optional ``{% permission_denied %}`` and ``{% fedora_failed %}``\n    sections with fallback content in case of permission or other errors\n    while rendering the main block.\n\n    Note that when Django's ``TEMPLATE_DEBUG`` setting is on, it precludes\n    all error handling and displays the Django exception screen for all\n    errors, including fedora errors, even if you use this template tag. Turn\n    off ``TEMPLATE_DEBUG`` if that debug screen is getting in the way of the\n    use of {% fedora_access %}.\n    \"\"\"\n\n    END_TAGS = ('end_fedora_access',\n                'permission_denied', 'fedora_failed')\n\n    blocks = {}\n    blocks['fedora_access'] = parser.parse(END_TAGS)\n    token = parser.next_token()\n    while token.contents != 'end_fedora_access':\n        # need to convert token.contents manually to a str. django gives us\n        # a unicode. we use it below in **blocks, but python 2.6.2 and\n        # earlier can't use **kwargs with unicode keys. (2.6.5 is ok with\n        # it; not sure about intervening versions.) in any case, direct\n        # conversion to string is safe here (i.e., no encoding needed)\n        # because the parser guarantees it's one of our END_TAGS, which are\n        # all ascii.\n        current_block = str(token.contents)\n        if current_block in blocks:\n            raise template.TemplateSyntaxError(\n                current_block + ' may appear only once in a fedora_access block')\n\n        blocks[current_block] = parser.parse(END_TAGS)\n        token = parser.next_token()\n\n    return CatchFedoraErrorsNode(**blocks)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns size of file.", "response": "def get_cur_file_size(fp, position_to_eof=False):\n    \"\"\"\n    Returns size of file, optionally leaving fp positioned at EOF.\n    \"\"\"\n    if not position_to_eof:\n        cur_pos = fp.tell()\n    fp.seek(0, os.SEEK_END)\n    cur_file_size = fp.tell()\n    if not position_to_eof:\n        fp.seek(cur_pos, os.SEEK_SET)\n    return cur_file_size"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _attempt_resumable_download(self, key, fp, headers, cb, num_cb,\n                                    torrent, version_id):\n        \"\"\"\n        Attempts a resumable download.\n\n        Raises ResumableDownloadException if any problems occur.\n        \"\"\"\n        cur_file_size = get_cur_file_size(fp, position_to_eof=True)\n\n        if (cur_file_size and \n            self.etag_value_for_current_download and\n            self.etag_value_for_current_download == key.etag.strip('\"\\'')):\n            # Try to resume existing transfer.\n            if cur_file_size > key.size:\n              raise ResumableDownloadException(\n                  '%s is larger (%d) than %s (%d).\\nDeleting tracker file, so '\n                  'if you re-try this download it will start from scratch' %\n                  (fp.name, cur_file_size, str(storage_uri_for_key(key)),\n                   key.size), ResumableTransferDisposition.ABORT)\n            elif cur_file_size == key.size:\n                if key.bucket.connection.debug >= 1:\n                    print 'Download complete.'\n                return\n            if key.bucket.connection.debug >= 1:\n                print 'Resuming download.'\n            headers = headers.copy()\n            headers['Range'] = 'bytes=%d-%d' % (cur_file_size, key.size - 1)\n            cb = ByteTranslatingCallbackHandler(cb, cur_file_size).call\n            self.download_start_point = cur_file_size\n        else:\n            if key.bucket.connection.debug >= 1:\n                print 'Starting new resumable download.'\n            self._save_tracker_info(key)\n            self.download_start_point = 0\n            # Truncate the file, in case a new resumable download is being\n            # started atop an existing file.\n            fp.truncate(0)\n\n        # Disable AWSAuthConnection-level retry behavior, since that would\n        # cause downloads to restart from scratch.\n        key.get_file(fp, headers, cb, num_cb, torrent, version_id,\n                     override_num_retries=0)\n        fp.flush()", "response": "Attempts a resumable download of a file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_file(self, key, fp, headers, cb=None, num_cb=10, torrent=False,\n                 version_id=None):\n        \"\"\"\n        Retrieves a file from a Key\n        :type key: :class:`boto.s3.key.Key` or subclass\n        :param key: The Key object from which upload is to be downloaded\n        \n        :type fp: file\n        :param fp: File pointer into which data should be downloaded\n        \n        :type headers: string\n        :param: headers to send when retrieving the files\n        \n        :type cb: function\n        :param cb: (optional) a callback function that will be called to report\n             progress on the download.  The callback should accept two integer\n             parameters, the first representing the number of bytes that have\n             been successfully transmitted from the storage service and\n             the second representing the total number of bytes that need\n             to be transmitted.\n        \n        :type num_cb: int\n        :param num_cb: (optional) If a callback is specified with the cb\n             parameter this parameter determines the granularity of the callback\n             by defining the maximum number of times the callback will be\n             called during the file transfer.\n             \n        :type torrent: bool\n        :param torrent: Flag for whether to get a torrent for the file\n\n        :type version_id: string\n        :param version_id: The version ID (optional)\n\n        Raises ResumableDownloadException if a problem occurs during\n            the transfer.\n        \"\"\"\n\n        debug = key.bucket.connection.debug\n        if not headers:\n            headers = {}\n\n        # Use num-retries from constructor if one was provided; else check\n        # for a value specified in the boto config file; else default to 5.\n        if self.num_retries is None:\n            self.num_retries = config.getint('Boto', 'num_retries', 5)\n        progress_less_iterations = 0\n\n        while True:  # Retry as long as we're making progress.\n            had_file_bytes_before_attempt = get_cur_file_size(fp)\n            try:\n                self._attempt_resumable_download(key, fp, headers, cb, num_cb,\n                                                 torrent, version_id)\n                # Download succceded, so remove the tracker file (if have one).\n                self._remove_tracker_file()\n                # Previously, check_final_md5() was called here to validate \n                # downloaded file's checksum, however, to be consistent with\n                # non-resumable downloads, this call was removed. Checksum\n                # validation of file contents should be done by the caller.\n                if debug >= 1:\n                    print 'Resumable download complete.'\n                return\n            except self.RETRYABLE_EXCEPTIONS, e:\n                if debug >= 1:\n                    print('Caught exception (%s)' % e.__repr__())\n                if isinstance(e, IOError) and e.errno == errno.EPIPE:\n                    # Broken pipe error causes httplib to immediately\n                    # close the socket (http://bugs.python.org/issue5542),\n                    # so we need to close and reopen the key before resuming\n                    # the download.\n                    key.get_file(fp, headers, cb, num_cb, torrent, version_id,\n                                 override_num_retries=0)\n            except ResumableDownloadException, e:\n                if (e.disposition ==\n                    ResumableTransferDisposition.ABORT_CUR_PROCESS):\n                    if debug >= 1:\n                        print('Caught non-retryable ResumableDownloadException '\n                              '(%s)' % e.message)\n                    raise\n                elif (e.disposition ==\n                    ResumableTransferDisposition.ABORT):\n                    if debug >= 1:\n                        print('Caught non-retryable ResumableDownloadException '\n                              '(%s); aborting and removing tracker file' %\n                              e.message)\n                    self._remove_tracker_file()\n                    raise\n                else:\n                    if debug >= 1:\n                        print('Caught ResumableDownloadException (%s) - will '\n                              'retry' % e.message)\n\n            # At this point we had a re-tryable failure; see if made progress.\n            if get_cur_file_size(fp) > had_file_bytes_before_attempt:\n                progress_less_iterations = 0\n            else:\n                progress_less_iterations += 1\n\n            if progress_less_iterations > self.num_retries:\n                # Don't retry any longer in the current process.\n                raise ResumableDownloadException(\n                    'Too many resumable download attempts failed without '\n                    'progress. You might try this download again later',\n                    ResumableTransferDisposition.ABORT_CUR_PROCESS)\n\n            # Close the key, in case a previous download died partway\n            # through and left data in the underlying key HTTP buffer.\n            # Do this within a try/except block in case the connection is\n            # closed (since key.close() attempts to do a final read, in which\n            # case this read attempt would get an IncompleteRead exception,\n            # which we can safely ignore.\n            try:\n                key.close()\n            except httplib.IncompleteRead:\n                pass\n\n            sleep_time_secs = 2**progress_less_iterations\n            if debug >= 1:\n                print('Got retryable failure (%d progress-less in a row).\\n'\n                      'Sleeping %d seconds before re-trying' %\n                      (progress_less_iterations, sleep_time_secs))\n            time.sleep(sleep_time_secs)", "response": "This method attempts to download a file from a Key object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef datastream_etag(request, pid, dsid, repo=None,\n    as_of_date=None, **kwargs):\n    '''Method suitable for use as an etag function with\n    :class:`django.views.decorators.http.condition`.  Takes the same\n    arguments as :meth:`~eulfedora.views.raw_datastream`.\n    '''\n    # if a range is requested and it is not for the entire file,\n    # do *NOT* return an etag\n\n    # NOTE: using api directly here instead of object/ds models\n    # to avoid making unneeded api calls\n\n    try:\n        if repo is None:\n            repo = Repository()\n        resp = repo.api.getDatastream(pid, dsid, asOfDateTime=as_of_date)\n        dsprofile = parse_xml_object(DatastreamProfile, resp.content, resp.url)\n        if dsprofile and dsprofile.checksum_type != 'DISABLED':\n            return dsprofile.checksum\n    except RequestFailed:\n        pass\n\n    return None", "response": "Method suitable for use as an etag function with the same arguments as a raw_datastream function. Takes the same arguments as a list of objects. Returns None if the datastream is not found."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef datastream_lastmodified(request, pid, dsid, repo=None,\n    as_of_date=None, *args, **kwargs):\n    '''Method suitable for use as a a last-modified function with\n    :class:`django.views.decorators.http.condition`.  Takes basically\n    the same arguments as :meth:`~eulfedora.views.raw_datastream`.\n    '''\n    try:\n        if repo is None:\n            repo = Repository()\n        resp = repo.api.getDatastream(pid, dsid, asOfDateTime=as_of_date)\n        dsprofile = parse_xml_object(DatastreamProfile, resp.content, resp.url)\n        if dsprofile:\n            return dsprofile.created\n    except RequestFailed:\n        pass", "response": "Method suitable for use as a last - modified function with a specific datastream. Takes basically a datastream ID and a datastream ID and a Repository object. Returns the datetime of the datastream."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef raw_datastream(request, pid, dsid, repo=None, headers=None,\n       as_of_date=None):\n    '''\n    Access raw datastream content from a Fedora object.\n    Returns :class:`~django.http.HttpResponse` for HEAD requests,\n    :class:`~django.http.StreamingHttpResponse` for GET requests.  The\n    headers and status code from Fedora response are set on the\n    django response; any headers specified in the parameters will\n    override Fedora headers.  If an HTTP_RANGE header is present on the\n    request, it is passed through to Fedora.\n\n    This view method is wrapped with ETag and last modified conditionals.\n\n    :param request: HttpRequest\n    :param pid: Fedora object PID\n    :param dsid: datastream ID\n    :param repo: :class:`~eulcore.django.fedora.server.Repository` instance to use,\n        in case your application requires custom repository initialization (optional)\n    :param headers: dictionary of additional headers to include in the response\n    :param as_of_date: access a historical version of the datastream\n    '''\n    return _raw_datastream(request, pid, dsid, repo=repo, headers=headers,\n       as_of_date=as_of_date)", "response": "This is a convenience method that returns a Fedora object that is a raw datastream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nversioning of : meth : raw_datastream without conditionals for use in class - based views or elsewhere.", "response": "def _raw_datastream(request, pid, dsid, repo=None, headers=None,\n       as_of_date=None):\n    '''Version of :meth:`raw_datastream` without conditionals, for use\n    in class-based views or elsewhere.'''\n    if repo is None:\n        repo = Repository()\n\n    # if a range request is present, pass it through to fedora\n    rqst_headers = {}\n    if 'HTTP_RANGE' in request.META:\n        rqst_headers['RANGE'] = request.META['HTTP_RANGE']\n\n    try:\n        if request.method == 'HEAD':\n            response = repo.api.getDatastreamDissemination(pid, dsid, asOfDateTime=as_of_date,\n                head=True, rqst_headers=rqst_headers)\n            dj_response = HttpResponse()\n        else:\n            response = repo.api.getDatastreamDissemination(pid, dsid, asOfDateTime=as_of_date,\n                stream=True, rqst_headers=rqst_headers)\n            dj_response = StreamingHttpResponse(response.iter_content(4096))\n    except RequestFailed as rf:\n        # if error is object not found, raise generic django 404\n        if rf.code == 404:\n            raise Http404\n\n        # otherwise, raise the error\n        raise\n\n    # make sure django response code matches fedora code\n    # e.g. error code or 206 partial content for range requests\n    dj_response.status_code = response.status_code\n\n    # copy fedora response headers to the django response\n    resp_headers = response.headers\n    # any headers passed in should take precedence\n    if headers is not None:\n        resp_headers.update(headers)\n    # etag needn't always be content md5, but for fedora datastreams it is\n    if 'ETag' in resp_headers:\n        resp_headers['Content-MD5'] = resp_headers['ETag']\n\n    for header, value in six.iteritems(resp_headers):\n        dj_response[header] = value\n\n    return dj_response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef raw_datastream_old(request, pid, dsid, type=None, repo=None,\n                       headers=None, accept_range_request=False,\n                       as_of_date=None, streaming=False):\n    '''\n    .. NOTE::\n\n        This version of :meth:`raw_datastream` is deprecated, and you\n        should update to the new :meth:`raw_datastream`.  This version\n        is still available if you are using a version of Fedora\n        prior to 3.7 and need the additional functionality.\n\n    View to display a raw datastream that belongs to a Fedora Object.\n    Returns an :class:`~django.http.HttpResponse` with the response content\n    populated with the content of the datastream.  The following HTTP headers\n    may be included in all the responses:\n\n    - Content-Type: mimetype of the datastream in Fedora\n    - ETag: datastream checksum, as long as the checksum type is not 'DISABLED'\n\n    The following HTTP headers may be set if the appropriate content is included\n    in the datastream metadata:\n\n    - Content-MD5: MD5 checksum of the datastream in Fedora, if available\n    - Content-Length: size of the datastream in Fedora\n\n    If either the datastream or object are not found, raises an\n    :class:`~django.http.Http404` .  For any other errors (e.g., permission\n    denied by Fedora), the exception is re-raised and should be handled elsewhere.\n\n    :param request: HttpRequest\n    :param pid: Fedora object PID\n    :param dsid: datastream ID to be returned\n    :param type: custom object type (should extend\n        :class:`~eulcore.fedora.models.DigitalObject`) (optional)\n    :param repo: :class:`~eulcore.django.fedora.server.Repository` instance to use,\n        in case your application requires custom repository initialization (optional)\n    :param headers: dictionary of additional headers to include in the response\n    :param accept_range_request: enable HTTP Range requests (disabled by default)\n    :param as_of_date: access a historical version of the datastream\n    :param streaming: if True, response will be returned as an instance of\n        :class:`django.http.StreamingHttpResponse` instead of\n        :class:`django.http.HttpResponse`; intended for use with large\n        datastreams, defaults to False.\n    '''\n\n    if repo is None:\n        repo = Repository()\n    if headers is None:\n        headers = {}\n\n    get_obj_opts = {}\n    if type is not None:\n        get_obj_opts['type'] = type\n    obj = repo.get_object(pid, **get_obj_opts)\n\n    range_request = False\n    partial_request = False\n\n    try:\n        # NOTE: we could test that pid is actually the requested\n        # obj.has_requisite_content_models but that would mean\n        # an extra API call for every datastream but RELS-EXT\n        # Leaving out for now, for efficiency\n\n        ds = obj.getDatastreamObject(dsid, as_of_date=as_of_date)\n\n        if ds and ds.exists:\n            # because retrieving the content is expensive and checking\n            # headers can be useful, explicitly support HEAD requests\n            if request.method == 'HEAD':\n                content = ''\n\n            elif accept_range_request and request.META.get('HTTP_RANGE', None) is not None:\n                rng = request.META['HTTP_RANGE']\n                logger.debug('HTTP Range request: %s', rng)\n                range_request = True\n                kind, numbers = rng.split('=')\n                if kind != 'bytes':\n                    return HttpResponseRangeNotSatisfiable()\n\n                try:\n                    start, end = numbers.split('-')\n                    # NOTE: could potentially be complicated stuff like\n                    # this: 0-999,1002-9999,1-9999\n                    # for now, only support the simple case of a single range\n                except ValueError:\n                    return HttpResponseRangeNotSatisfiable()\n\n                start = int(start)\n                if not end:\n                    end = ds.info.size - 1\n                else:\n                    end = int(end)\n\n                # ignore requests where end is before start\n                if end < start:\n                    return HttpResponseRangeNotSatisfiable()\n\n                if start == end:  # safari sends this (weird?); don't 500\n                    partial_length = 0\n                    partial_request = True\n                    content = ''\n\n                # special case for bytes=0-\n                elif start == 0 and end == (ds.info.size - 1):\n                    # set chunksize and end so range headers can be set on response\n                    # partial_length= ds.info.size\n                    partial_length = end - start\n\n                    content = ds.get_chunked_content()\n\n                # range with *NOT* full content requested\n                elif start != 0 or end != (ds.info.size - 1):\n                    partial_request = True\n                    partial_length = end - start\n                    # chunksize = min(end - start, 4096)\n                    # sample chunk 370726-3005759\n                    content = get_range_content(ds, start, end)\n\n            else:\n                # get the datastream content in chunks, to handle larger datastreams\n                content = ds.get_chunked_content()\n                # not using serialize(pretty=True) for XML/RDF datastreams, since\n                # we actually want the raw datastream content.\n\n            http_response_class = HttpResponse\n            if streaming:\n                http_response_class = StreamingHttpResponse\n            response = http_response_class(content, content_type=ds.mimetype)\n            # NOTE: might want to use StreamingHttpResponse here, at least\n            # over some size threshold or for range requests\n\n            # if we have a checksum, use it as an ETag\n            # (but checksum not valid when sending partial content)\n            if ds.checksum_type != 'DISABLED' and not partial_request:\n                response['ETag'] = ds.checksum\n            # ds.created is the creation date of this *version* of the datastream,\n            # so it is effectively our last-modified date\n            response['Last-Modified'] = ds.created\n\n            # Where available, set content length & MD5 checksum in response headers.\n            # (but checksum not valid when sending partial content)\n            if ds.checksum_type == 'MD5' and not partial_request:\n                response['Content-MD5'] = ds.checksum\n            if ds.info.size and not range_request:\n                response['Content-Length'] = ds.info.size\n            if ds.info.size and accept_range_request:\n                response['Accept-Ranges'] = 'bytes'\n                # response['Content-Range'] = '0,%d/%d' % (ds.info.size, ds.info.size)\n\n            # if partial request, status should be 206 (even for whole file?)\n            if range_request:\n                response.status_code = 206\n                if partial_request:\n                    response['Content-Length'] = partial_length\n                else:\n                    response['Content-Length'] = ds.info.size\n                cont_range = 'bytes %d-%d/%d' % (start, end, ds.info.size)\n                response['Content-Range'] = cont_range\n                logger.debug('Content-Length=%s Content-Range=%s',\n                             partial_length, cont_range)\n\n            # set any user-specified headers that were passed in\n            for header, val in six.iteritems(headers):\n                response[header] = val\n\n            # Fix for old Fedora data bug where the `Content-Length`\n            # was -1. IF it is -1 we're just going to get rid of it.\n            # Setting the value to an arbitrary value led to issues.\n            if int(response['Content-Length']) < 0:\n                del response['Content-Length']\n\n            return response\n        else:\n            raise Http404\n\n    except RequestFailed as rf:\n        # if object is not the speficied type or if either the object\n        # or the requested datastream doesn't exist, 404\n        if rf.code == 404 or \\\n            (type is not None and not obj.has_requisite_content_models) or \\\n                not getattr(obj, dsid).exists or not obj.exists:\n            raise Http404\n\n        # for anything else, re-raise & let Django's default 500 logic handle it\n        raise", "response": "Deprecated version of raw_datastream."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_range_content(ds, start, end):\n    '''Generator for range-requested datastream content.  Iterates over\n    datastream content in chunks, and yields the chunks (or partial chunks)\n    that are part of the requested range.'''\n    if not end or end > ds.info.size:\n        end = ds.info.size - 1\n    chunksize = 4096\n\n    content_chunks = ds.get_chunked_content(chunksize=chunksize)\n    length = 0\n    for i in range(int(end/chunksize) + 10):\n        chunk_start = chunksize  * i\n        chunk_end = chunk_start + chunksize\n\n        # probably shouldn't run out of data, but in case data doesn't\n        # match datastream metadata size in fedora...\n        try:\n            content = next(content_chunks)\n        except StopIteration:\n            break\n\n        real_chunksize = len(content)\n\n        if chunk_start <= start < chunk_end:\n            # start of range is somewhere in the current chunk\n            # get the section of requested content at start index\n            content = content[start - chunk_start:]\n\n            # range could also *end* in same chunk where it starts\n            if chunk_start < end <= chunk_end:\n\n                # trim based on *actual* size of current chunk (before any\n                # start trim), since last chunk may not be fullsize\n                end_trim = -(chunk_start + real_chunksize - end)\n                if end_trim:\n                    content = content[:end_trim]\n                length += len(content)\n                yield content\n\n                # stop - hit the end of the range\n                break\n            else:\n                length += len(content)\n                yield content\n\n        elif chunk_start < end <= chunk_end:\n            # end of range is in this chunk; trim if necessary, then stop\n\n            # trim based on *actual* size of current chunk (before any\n            # start trimming), since last chunk may not be fullsize\n            content = content[:-(chunk_start + real_chunksize - end)]\n\n            length += len(content)\n            yield content\n            # stop - hit the end of the range\n            break\n\n        elif chunk_start > start  and chunk_end < end:\n            # chunk is somewhere in the range of start - end\n            length += len(content)\n            yield content\n\n    logger.debug('total content length returned is %d', length)", "response": "Generator for range - requested datastream content. Iterates over chunks and yields the chunks or partial chunks that are part of the requested range."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nviewing to display the raw xml audit trail for a Fedora object.", "response": "def raw_audit_trail(request, pid, type=None, repo=None):\n    '''View to display the raw xml audit trail for a Fedora Object.\n    Returns an :class:`~django.http.HttpResponse` with the response content\n    populated with the content of the audit trial.\n\n    If the object is not found or does not have an audit trail, raises\n    an :class:`~django.http.Http404` .  For any other errors (e.g.,\n    permission denied by Fedora), the exception is not caught and\n    should be handled elsewhere.\n\n    :param request: HttpRequest\n    :param pid: Fedora object PID\n    :param repo: :class:`~eulcore.django.fedora.server.Repository` instance to use,\n        in case your application requires custom repository initialization (optional)\n\n    .. Note::\n\n      Fedora does not make checksums, size, or other attributes\n      available for the audit trail (since it is internal and not a\n      true datastream), so the additional headers included in\n      :meth:`raw_datastream` cannot be added here.\n\n    '''\n\n    if repo is None:\n        repo = Repository()\n    # no special options are *needed* to access audit trail, since it\n    # is available on any DigitalObject; but a particular view may be\n    # restricted to a certain type of object\n    get_obj_opts = {}\n    if type is not None:\n        get_obj_opts['type'] = type\n    obj = repo.get_object(pid, **get_obj_opts)\n    # object exists and has a non-empty audit trail\n    if obj.exists and obj.has_requisite_content_models and obj.audit_trail:\n        response = HttpResponse(obj.audit_trail.serialize(),\n                            content_type='text/xml')\n        # audit trail is updated every time the object gets modified\n        response['Last-Modified'] = obj.modified\n        return response\n\n    else:\n        raise Http404"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef login_and_store_credentials_in_session(request, *args, **kwargs):\n    '''Custom login view.  Calls the standard Django authentication,\n    but on successful login, stores encrypted user credentials in\n    order to allow accessing the Fedora repository with the\n    credentials of the currently-logged in user (e.g., when the\n    application and Fedora share a common authentication system, such\n    as LDAP).\n\n    In order for :class:`~eulcore.django.fedora.server.Repository` to\n    pick up user credentials, you must pass the request object in (so\n    it will have access to the session).  Example::\n\n        from eulcore.django.fedora.server import Repository\n\n        def my_view(rqst):\n            repo = Repository(request=rqst)\n\n\n    Any arguments supported by :meth:`django.contrib.auth.views.login`\n    can be specified and they will be passed along for the standard\n    login functionality.\n\n    **This is not a terribly secure.  Do NOT use this method unless\n    you need the functionality.**\n\n    '''\n    response = authviews.login(request, *args, **kwargs)\n    if request.method == \"POST\" and request.user.is_authenticated():\n        # on successful login, encrypt and store user's password to use for fedora access\n        request.session[FEDORA_PASSWORD_SESSION_KEY] = encrypt(request.POST.get('password'))\n    return response", "response": "Custom login view.  Calls the standard Django authentication,\n    but on successful login, stores encrypted user credentials in\n    order to allow accessing the Fedora repository with the\n    credentials of the currently-logged in user (e.g., when the\n    application and Fedora share a common authentication system, such\n    as LDAP).\n\n    In order for :class:`~eulcore.django.fedora.server.Repository` to\n    pick up user credentials, you must pass the request object in (so\n    it will have access to the session).  Example::\n\n        from eulcore.django.fedora.server import Repository\n\n        def my_view(rqst):\n            repo = Repository(request=rqst)\n\n\n    Any arguments supported by :meth:`django.contrib.auth.views.login`\n    can be specified and they will be passed along for the standard\n    login functionality.\n\n    **This is not a terribly secure.  Do NOT use this method unless\n    you need the functionality.**"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclassing method to generate an ETag for use with class configuration.", "response": "def etag(cls, request, *args, **kwargs):\n        '''Class method to generate an ETag for use with\n        conditional processing; calls :meth:`datastream_etag` with\n        class configuration.'''\n        pid = kwargs[cls.pid_url_kwarg]\n        date = kwargs.get(cls.as_of_date_url_kwarg, None)\n        return datastream_etag(\n            request, pid, cls.datastream_id,\n            type=cls.object_type, repo=cls.repository_class(request=request),\n            accept_range_request=cls.accept_range_request, as_of_date=date)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_profile_data(self, raw_token):\n        try:\n            response = self.request('get', self.profile_url, token=raw_token)\n            response.raise_for_status()\n        except RequestException as e:\n            logger.error('Unable to fetch user profile: {0}'.format(e))\n            return None\n        else:\n            return response.json() or response.text", "response": "Fetch user profile information."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds authentication redirect url.", "response": "def get_redirect_url(self, request, callback, parameters=None):\n        \"\"\"Build authentication redirect url.\"\"\"\n        args = self.get_redirect_args(request, callback=callback)\n        additional = parameters or {}\n        args.update(additional)\n        params = urlencode(args)\n        return '{0}?{1}'.format(self.authorization_url, params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches the OAuth request token. Only required for OAuth 1. 0.", "response": "def get_request_token(self, request, callback):\n        \"\"\"Fetch the OAuth request token. Only required for OAuth 1.0.\"\"\"\n        callback = force_text(request.build_absolute_uri(callback))\n        try:\n            response = self.request('post', self.request_token_url, oauth_callback=callback)\n            response.raise_for_status()\n        except RequestException as e:\n            logger.error('Unable to fetch request token: {0}'.format(e))\n            return None\n        else:\n            return response.text"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets request parameters for redirect url.", "response": "def get_redirect_args(self, request, callback):\n        \"\"\"Get request parameters for redirect url.\"\"\"\n        callback = force_text(request.build_absolute_uri(callback))\n        raw_token = self.get_request_token(request, callback)\n        token, secret, _ = self.parse_raw_token(raw_token)\n        if token is not None and secret is not None:\n            request.session[self.session_key] = raw_token\n        args = {\n            'oauth_token': token,\n            'oauth_callback': callback,\n        }\n\n        scope = self.get_scope(request)\n        if scope:\n            args['scope'] = self.scope_separator.join(self.get_scope(request))\n\n        return args"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_raw_token(self, raw_token):\n        if raw_token is None:\n            return (None, None, None)\n        qs = parse_qs(raw_token)\n        token = qs.get('oauth_token', [None])[0]\n        token_secret = qs.get('oauth_token_secret', [None])[0]\n        return (token, token_secret, None)", "response": "Parse token and secret from raw token response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch access token from callback request.", "response": "def get_access_token(self, request, callback=None):\n        \"\"\"Fetch access token from callback request.\"\"\"\n        callback = request.build_absolute_uri(callback or request.path)\n        if not self.check_application_state(request):\n            logger.error('Application state check failed.')\n            return None\n        if 'code' in request.GET:\n            args = {\n                'client_id': self.consumer_key,\n                'redirect_uri': callback,\n                'client_secret': self.consumer_secret,\n                'code': request.GET['code'],\n                'grant_type': 'authorization_code',\n            }\n        else:\n            logger.error('No code returned by the provider')\n            return None\n        try:\n            response = self.request('post', self.access_token_url, data=args)\n            response.raise_for_status()\n        except RequestException as e:\n            logger.error('Unable to fetch access token: {0}'.format(e))\n            return None\n        else:\n            return response.text"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting request parameters for redirect url.", "response": "def get_redirect_args(self, request, callback):\n        \"\"\"Get request parameters for redirect url.\"\"\"\n        callback = request.build_absolute_uri(callback)\n        args = {\n            'client_id': self.consumer_key,\n            'redirect_uri': callback,\n            'response_type': 'code',\n        }\n\n        scope = self.get_scope(request)\n        if scope:\n            args['scope'] = self.scope_separator.join(self.get_scope(request))\n\n        state = self.get_application_state(request, callback)\n        if state is not None:\n            args['state'] = state\n            request.session[self.session_key] = state\n\n        auth_params = self.get_auth_params(request)\n        if auth_params:\n            args.update(auth_params)\n\n        return args"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing token and secret from raw token response.", "response": "def parse_raw_token(self, raw_token):\n        \"\"\"Parse token and secret from raw token response.\"\"\"\n        if raw_token is None:\n            return (None, None, None)\n        # Load as json first then parse as query string\n        try:\n            token_data = json.loads(raw_token)\n        except ValueError:\n            qs = parse_qs(raw_token)\n            token = qs.get('access_token', [None])[0]\n            refresh_token = qs.get('refresh_token', [None])[0]\n            expires_at = qs.get(self.expires_in_key, [None])[0]\n        else:\n            token = token_data.get('access_token', None)\n            refresh_token = token_data.get('refresh_token', None)\n            expires_at = token_data.get(self.expires_in_key, None)\n\n        if expires_at:\n            expires_at = timezone.now() + timedelta(seconds=int(expires_at))\n\n        return (token, refresh_token, expires_at)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds remote url request. Constructs necessary auth.", "response": "def request(self, method, url, **kwargs):\n        \"\"\"Build remote url request. Constructs necessary auth.\"\"\"\n        user_token = kwargs.pop('token', self.token)\n        token, secret, expires_at = self.parse_raw_token(user_token)\n        if token is not None:\n            params = kwargs.get('params', {})\n            params['access_token'] = token\n            kwargs['params'] = params\n        return super(OAuth2Provider, self).request(method, url, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a list containing a full French deck of 52 Card instances.", "response": "def build_cards(jokers=False, num_jokers=0):\n    \"\"\"\n    Builds a list containing a full French deck of 52 Card instances. The\n    cards are sorted according to ``DEFAULT_RANKS``.\n\n    .. note:\n        Adding jokers may break some functions & methods at the moment.\n\n    :arg bool jokers:\n        Whether or not to include jokers in the deck.\n    :arg int num_jokers:\n        The number of jokers to include.\n\n    :returns:\n        A list containing a full French deck of 52 Card instances.\n\n    \"\"\"\n    new_deck = []\n\n    if jokers:\n        new_deck += [Card(\"Joker\", None) for i in xrange(num_jokers)]\n\n    new_deck += [Card(value, suit) for value in VALUES for suit in SUITS]\n\n    return new_deck"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking whether the given cards are sorted by the given ranks.", "response": "def check_sorted(cards, ranks=None):\n    \"\"\"\n    Checks whether the given cards are sorted by the given ranks.\n\n    :arg cards:\n        The cards to check. Can be a ``Stack``, ``Deck``, or ``list`` of\n        ``Card`` isntances.\n    :arg dict ranks:\n        The ranks to check against. Default is DEFAULT_RANKS.\n\n    :returns:\n        ``True`` or ``False``.\n\n    \"\"\"\n    ranks = ranks or DEFAULT_RANKS\n\n    sorted_cards = sort_cards(cards, ranks)\n\n    if cards == sorted_cards or cards[::-1] == sorted_cards:\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_term(card, term):\n    check_list = [\n        x.lower() for x in [card.name, card.suit, card.value, card.abbrev,\n        card.suit[0], card.value[0]]\n    ]\n\n    term = term.lower()\n\n    for check in check_list:\n        if check == term:\n            return True\n\n    return False", "response": "Checks a given search term against a given card s full name suit value and abbreviation. Returns True if the search term is valid False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompare two given Stacks and Decks.", "response": "def compare_stacks(cards_x, cards_y, sorted=False):\n    \"\"\"\n    Checks whether two given ``Stack``, ``Deck``, or ``list`` instances,\n    contain the same cards (based on value & suit, not instance). Does not\n    take into account the ordering.\n\n    :arg cards_x:\n        The first stack to check. Can be a ``Stack``, ``Deck``, or ``list``\n        instance.\n    :arg cards_y:\n        The second stack to check. Can be a ``Stack``, ``Deck``, or ``list``\n        instance.\n    :arg bool sorted:\n        Whether or not the cards are already sorted. If ``True``, then\n        ``compare_stacks`` will skip the sorting process.\n\n    :returns:\n        ``True`` or ``False``.\n\n    \"\"\"\n    if len(cards_x) == len(cards_y):\n        if not sorted:\n            cards_x = sort_cards(cards_x, DEFAULT_RANKS)\n            cards_y = sort_cards(cards_y, DEFAULT_RANKS)\n        for i, c in enumerate(cards_x):\n            if c != cards_y[i]:\n                return False\n        return True\n    else:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_card(cards, term, limit=0, sort=False, ranks=None):\n    got_cards = []\n\n    try:\n        indices = find_card(cards, term, limit=limit)\n        got_cards = [cards[i] for i in indices]\n        cards = [v for i, v in enumerate(cards) if i not in indices]\n    except:\n        got_cards = [cards[term]]\n        cards = [v for i, v in enumerate(cards) if i is not term]\n\n    if sort:\n        got_cards = sort_cards(got_cards)\n\n    return cards, got_cards", "response": "Get the specified cards from the stack."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open_cards(filename=None):\n    filename = filename or \"cards-%s.txt\" % (time.strftime(\"%Y%m%d\"))\n\n    with open(filename, \"r\") as deck_file:\n        card_data = [line.rstrip(\"\\n\") for line in deck_file.readlines()]\n\n    cards = [None] * len(card_data)\n\n    for i, card in enumerate(card_data):\n        card = card.split()\n        cards[i] = Card(card[0], card[1])\n\n    return cards", "response": "Opens the cards from a txt file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a random card from the Stack.", "response": "def random_card(cards, remove=False):\n    \"\"\"\n    Returns a random card from the Stack. If ``remove=True``, it will\n    also remove the card from the deck.\n\n    :arg bool remove:\n        Whether or not to remove the card from the deck.\n\n    :returns:\n        A random Card object, from the Stack.\n\n    \"\"\"\n    if not remove:\n        return random.choice(cards)\n    else:\n        i = random.randrange(len(cards))\n        card = cards[i]\n        del cards[i]\n        return card"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the given cards in plain text to a txt file.", "response": "def save_cards(cards, filename=None):\n    \"\"\"\n    Save the given cards, in plain text, to a txt file.\n\n    :arg cards:\n        The cards to save. Can be a ``Stack``, ``Deck``, or ``list``.\n    :arg str filename:\n        The filename to use for the cards file. If no filename given,\n        defaults to \"cards-YYYYMMDD.txt\", where \"YYYYMMDD\" is the year, month,\n        and day. For example, \"cards-20140711.txt\".\n\n    \"\"\"\n    filename = filename or \"cards-%s.txt\" % (time.strftime(\"%Y%m%d\"))\n\n    with open(filename, \"w\") as deck_file:\n        card_reprs = [\"%s %s\\n\" % (card.value, card.suit) for card in cards]\n        card_reprs[-1] = card_reprs[-1].rstrip(\"\\n\")\n        for card in card_reprs:\n            deck_file.write(card)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sort_card_indices(cards, indices, ranks=None):\n    ranks = ranks or DEFAULT_RANKS\n\n    if ranks.get(\"suits\"):\n        indices = sorted(\n            indices,\n            key=lambda x: ranks[\"suits\"][cards[x].suit] if\n                cards[x].suit != None else 0\n        )\n    if ranks.get(\"values\"):\n        indices = sorted(\n            indices,\n            key=lambda x: ranks[\"values\"][cards[x].value]\n        )\n\n    return indices", "response": "Sorts the given list of cards by the given ranks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sort_cards(cards, ranks=None):\n    ranks = ranks or DEFAULT_RANKS\n\n    if ranks.get(\"suits\"):\n        cards = sorted(\n            cards,\n            key=lambda x: ranks[\"suits\"][x.suit] if x.suit != None else 0\n        )\n    if ranks.get(\"values\"):\n        cards = sorted(\n            cards,\n            key=lambda x: ranks[\"values\"][x.value]\n        )\n\n    return cards", "response": "Sorts a given list of cards either by poker ranks or big two ranks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decode_map_element(self, item_type, value):\n        import urllib\n        key = value\n        if \":\" in value:\n            key, value = value.split(':',1)\n            key = urllib.unquote(key)\n        if Model in item_type.mro():\n            value = item_type(id=value)\n        else:\n            value = self.decode(item_type, value)\n        return (key, value)", "response": "Decode a single element for a map"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef encode_float(self, value):\n        s = '%e' % value\n        l = s.split('e')\n        mantissa = l[0].ljust(18, '0')\n        exponent = l[1]\n        if value == 0.0:\n            case = '3'\n            exponent = '000'\n        elif mantissa[0] != '-' and exponent[0] == '+':\n            case = '5'\n            exponent = exponent[1:].rjust(3, '0')\n        elif mantissa[0] != '-' and exponent[0] == '-':\n            case = '4'\n            exponent = 999 + int(exponent)\n            exponent = '%03d' % exponent\n        elif mantissa[0] == '-' and exponent[0] == '-':\n            case = '2'\n            mantissa = '%f' % (10 + float(mantissa))\n            mantissa = mantissa.ljust(18, '0')\n            exponent = exponent[1:].rjust(3, '0')\n        else:\n            case = '1'\n            mantissa = '%f' % (10 + float(mantissa))\n            mantissa = mantissa.ljust(18, '0')\n            exponent = 999 - int(exponent)\n            exponent = '%03d' % exponent\n        return '%s %s %s' % (case, exponent, mantissa)", "response": "Encode a float into a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecode a string representing a time into a time object.", "response": "def decode_time(self, value):\n        \"\"\" converts strings in the form of HH:MM:SS.mmmmmm\n            (created by datetime.time.isoformat()) to\n            datetime.time objects.\n\n            Timzone-aware strings (\"HH:MM:SS.mmmmmm+HH:MM\") won't\n            be handled right now and will raise TimeDecodeError.\n        \"\"\"\n        if '-' in value or '+' in value:\n            # TODO: Handle tzinfo\n            raise TimeDecodeError(\"Can't handle timezone aware objects: %r\" % value)\n        tmp = value.split('.')\n        arg = map(int, tmp[0].split(':'))\n        if len(tmp) == 2:\n            arg.append(int(tmp[1]))\n        return time(*arg)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode_string(self, value):\n        if not isinstance(value, str): return value\n        try:\n            return unicode(value, 'utf-8')\n        except: # really, this should throw an exception.\n                # in the interest of not breaking current\n                # systems, however:\n            arr = []\n            for ch in value:\n                arr.append(unichr(ord(ch)))\n            return u\"\".join(arr)", "response": "Convert ASCII Latin - 1 or UTF - 8 to pure Unicode"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef count(self, cls, filters, quick=True, sort_by=None, select=None):\n        query = \"select count(*) from `%s` %s\" % (self.domain.name, self._build_filter_part(cls, filters, sort_by, select))\n        count = 0\n        for row in self.domain.select(query):\n            count += int(row['Count'])\n            if quick:\n                return count\n        return count", "response": "Get the number of results that would be returned in this query"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _build_filter_part(self, cls, filters, order_by=None, select=None):\n        import types\n        query_parts = []\n\n        order_by_filtered = False\n\n        if order_by:\n            if order_by[0] == \"-\":\n                order_by_method = \"DESC\";\n                order_by = order_by[1:]\n            else:\n                order_by_method = \"ASC\";\n\n        if select:\n            if order_by and order_by in select:\n                order_by_filtered = True\n            query_parts.append(\"(%s)\" % select)\n\n        if isinstance(filters, str) or isinstance(filters, unicode):\n            query = \"WHERE %s AND `__type__` = '%s'\" % (filters, cls.__name__)\n            if order_by in [\"__id__\", \"itemName()\"]:\n                query += \" ORDER BY itemName() %s\" % order_by_method\n            elif order_by != None:\n                query += \" ORDER BY `%s` %s\" % (order_by, order_by_method)\n            return query\n\n        for filter in filters:\n            filter_parts = []\n            filter_props = filter[0]\n            if type(filter_props) != list:\n                filter_props = [filter_props]\n            for filter_prop in filter_props:\n                (name, op) = filter_prop.strip().split(\" \", 1)\n                value = filter[1]\n                property = cls.find_property(name)\n                if name == order_by:\n                    order_by_filtered = True\n                if types.TypeType(value) == types.ListType:\n                    filter_parts_sub = []\n                    for val in value:\n                        val = self.encode_value(property, val)\n                        if isinstance(val, list):\n                            for v in val:\n                                filter_parts_sub.append(self._build_filter(property, name, op, v))\n                        else:\n                            filter_parts_sub.append(self._build_filter(property, name, op, val))\n                    filter_parts.append(\"(%s)\" % (\" OR \".join(filter_parts_sub)))\n                else:\n                    val = self.encode_value(property, value)\n                    if isinstance(val, list):\n                        for v in val:\n                            filter_parts.append(self._build_filter(property, name, op, v))\n                    else:\n                        filter_parts.append(self._build_filter(property, name, op, val))\n            query_parts.append(\"(%s)\" % (\" or \".join(filter_parts)))\n\n\n        type_query = \"(`__type__` = '%s'\" % cls.__name__\n        for subclass in self._get_all_decendents(cls).keys():\n            type_query += \" or `__type__` = '%s'\" % subclass\n        type_query +=\")\"\n        query_parts.append(type_query)\n\n        order_by_query = \"\"\n\n        if order_by:\n            if not order_by_filtered:\n                query_parts.append(\"`%s` LIKE '%%'\" % order_by)\n            if order_by in [\"__id__\", \"itemName()\"]:\n                order_by_query = \" ORDER BY itemName() %s\" % order_by_method\n            else:\n                order_by_query = \" ORDER BY `%s` %s\" % (order_by, order_by_method)\n\n        if len(query_parts) > 0:\n            return \"WHERE %s %s\" % (\" AND \".join(query_parts), order_by_query)\n        else:\n            return \"\"", "response": "Builds the filter part of the query"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_all_decendents(self, cls):\n        decendents = {}\n        for sc in cls.__sub_classes__:\n            decendents[sc.__name__] = sc\n            decendents.update(self._get_all_decendents(sc))\n        return decendents", "response": "Get all decendents for a given class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, validate=False):\n        rs = self.connection.get_all_snapshots([self.id])\n        if len(rs) > 0:\n            self._update(rs[0])\n        elif validate:\n            raise ValueError('%s is not a valid Snapshot ID' % self.id)\n        return self.progress", "response": "Update the data associated with this snapshot by querying EC2."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ne(self, other, ranks=None):\n        ranks = ranks or DEFAULT_RANKS\n        if isinstance(other, Card):\n            if ranks.get(\"suits\"):\n                return (\n                    ranks[\"values\"][self.value] !=\n                    ranks[\"values\"][other.value] or\n                    ranks[\"suits\"][self.suit] !=\n                    ranks[\"suits\"][other.suit]\n                )\n            else:\n                return ranks[self.value] != ranks[other.value]\n        else:\n            return False", "response": "Compares the card against another card and checks whether the card is not equal to other based on the given ranks dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef index_data(request, id, repo=None):\n    '''Return the fields and values to be indexed for a single object\n    as JSON.  Index content is generated via\n    :meth:`eulfedora.models.DigitalObject.index_data`.\n\n    :param id: id of the object to be indexed; in this case a Fedora pid\n    '''\n\n    # Ensure permission to this resource is allowed. Currently based on IP only.\n    if _permission_denied_check(request):\n        return HttpResponseForbidden('Access to this web service was denied.', content_type='text/html')\n\n    if repo is None:\n        repo_opts = {}\n        # if credentials are specified via Basic Auth, use them for Fedora access\n        auth_info = request.META.get('HTTP_AUTHORIZATION', None)\n        basic = 'Basic '\n        if auth_info and auth_info.startswith(basic):\n            basic_info = auth_info[len(basic):]\n            basic_info_decoded = base64.b64decode(force_bytes(basic_info))\n            # NOTE: codecs.decode works everywhere but python 3.3. which\n            # complains about an unknown encoding\n            # basic_info_decoded = codecs.decode(force_bytes(basic_info), 'base64')\n            u, p = force_text(basic_info_decoded).split(':')\n            repo_opts.update({'username': u, 'password': p})\n\n        repo = TypeInferringRepository(**repo_opts)\n    try:\n        obj = repo.get_object(id)\n        return HttpResponse(json.dumps(obj.index_data()),\n                            content_type='application/json')\n    except RequestFailed:\n        # for now, treat any failure getting the object from Fedora as a 404\n        # (could also potentially be a permission error)\n        raise Http404", "response": "Return the fields and values to be indexed for a single object in a Fedora object tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _permission_denied_check(request):\n    '''Internal function to verify that access to this webservice is allowed.\n    Currently, based on the value of EUL_INDEXER_ALLOWED_IPS in settings.py.\n\n    :param request: HttpRequest\n\n    '''\n    allowed_ips = settings.EUL_INDEXER_ALLOWED_IPS\n    if allowed_ips != \"ANY\" and not request.META['REMOTE_ADDR'] in allowed_ips:\n        return True\n\n    return False", "response": "Internal function to verify that access to this webservice is allowed. Currently only checks if the request is allowed to this webservice."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the state of the instance by making a call to fetch getCacheKey the current instance attributes from the service.", "response": "def update(self, validate=False):\n        \"\"\"\n        Update the instance's state information by making a call to fetch\n        the current instance attributes from the service.\n\n        :type validate: bool\n        :param validate: By default, if EC2 returns no data about the\n                         instance the update method returns quietly.  If\n                         the validate param is True, however, it will\n                         raise a ValueError exception if no data is\n                         returned from EC2.\n        \"\"\"\n        rs = self.connection.get_all_instances([self.id])\n        if len(rs) > 0:\n            r = rs[0]\n            for i in r.instances:\n                if i.id == self.id:\n                    self._update(i)\n        elif validate:\n            raise ValueError('%s is not a valid Instance ID' % self.id)\n        return self.state"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstop the instance :type force: bool :param force: Forces the instance to stop :rtype: list :return: A list of the instances stopped", "response": "def stop(self, force=False):\n        \"\"\"\n        Stop the instance\n\n        :type force: bool\n        :param force: Forces the instance to stop\n        \n        :rtype: list\n        :return: A list of the instances stopped\n        \"\"\"\n        rs = self.connection.stop_instances([self.id], force)\n        if len(rs) > 0:\n            self._update(rs[0])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef modify_attribute(self, attribute, value):\n        return self.connection.modify_instance_attribute(self.id, attribute,\n                                                         value)", "response": "Modify an attribute of this instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_all_load_balancers(self, load_balancer_names=None):\n        params = {}\n        if load_balancer_names:\n            self.build_list_params(params, load_balancer_names,\n                                   'LoadBalancerNames.member.%d')\n        return self.get_list('DescribeLoadBalancers', params,\n                             [('member', LoadBalancer)])", "response": "Retrieves all load balancers associated with your account."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_load_balancer(self, name, zones, listeners, subnets=None,\n        security_groups=None):\n        \"\"\"\n        Create a new load balancer for your account. By default the load\n        balancer will be created in EC2. To create a load balancer inside a\n        VPC, parameter zones must be set to None and subnets must not be None.\n        The load balancer will be automatically created under the VPC that\n        contains the subnet(s) specified.\n\n        :type name: string\n        :param name: The mnemonic name associated with the new load balancer\n\n        :type zones: List of strings\n        :param zones: The names of the availability zone(s) to add.\n\n        :type listeners: List of tuples\n        :param listeners: Each tuple contains three or four values,\n                          (LoadBalancerPortNumber, InstancePortNumber,\n                          Protocol, [SSLCertificateId])\n                          where LoadBalancerPortNumber and InstancePortNumber\n                          are integer values between 1 and 65535, Protocol is a\n                          string containing either 'TCP', 'HTTP' or 'HTTPS';\n                          SSLCertificateID is the ARN of a AWS AIM certificate,\n                          and must be specified when doing HTTPS.\n\n        :rtype: :class:`boto.ec2.elb.loadbalancer.LoadBalancer`\n        :return: The newly created :class:`boto.ec2.elb.loadbalancer.LoadBalancer`\n        \"\"\"\n        params = {'LoadBalancerName' : name}\n        for index, listener in enumerate(listeners):\n            i = index + 1\n            params['Listeners.member.%d.LoadBalancerPort' % i] = listener[0]\n            params['Listeners.member.%d.InstancePort' % i] = listener[1]\n            params['Listeners.member.%d.Protocol' % i] = listener[2]\n            if listener[2]=='HTTPS':\n                params['Listeners.member.%d.SSLCertificateId' % i] = listener[3]\n        if zones:\n            self.build_list_params(params, zones, 'AvailabilityZones.member.%d')\n\n        if subnets:\n            self.build_list_params(params, subnets, 'Subnets.member.%d')\n\n        if security_groups:\n            self.build_list_params(params, security_groups, \n                                    'SecurityGroups.member.%d')\n\n        load_balancer = self.get_object('CreateLoadBalancer',\n                                        params, LoadBalancer)\n        load_balancer.name = name\n        load_balancer.listeners = listeners\n        load_balancer.availability_zones = zones\n        load_balancer.subnets = subnets\n        load_balancer.security_groups = security_groups\n        return load_balancer", "response": "Creates a new load balancer for your account."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_load_balancer_listeners(self, name, listeners):\n        params = {'LoadBalancerName' : name}\n        for index, listener in enumerate(listeners):\n            i = index + 1\n            params['Listeners.member.%d.LoadBalancerPort' % i] = listener[0]\n            params['Listeners.member.%d.InstancePort' % i] = listener[1]\n            params['Listeners.member.%d.Protocol' % i] = listener[2]\n            if listener[2]=='HTTPS':\n                params['Listeners.member.%d.SSLCertificateId' % i] = listener[3]\n        return self.get_status('CreateLoadBalancerListeners', params)", "response": "Creates a Listener for an existing Load Balancer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_load_balancer_listeners(self, name, ports):\n        params = {'LoadBalancerName' : name}\n        for index, port in enumerate(ports):\n            params['LoadBalancerPorts.member.%d' % (index + 1)] = port\n        return self.get_status('DeleteLoadBalancerListeners', params)", "response": "Delete a load balancer listener or group of listeners."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef enable_availability_zones(self, load_balancer_name, zones_to_add):\n        params = {'LoadBalancerName' : load_balancer_name}\n        self.build_list_params(params, zones_to_add,\n                               'AvailabilityZones.member.%d')\n        return self.get_list('EnableAvailabilityZonesForLoadBalancer',\n                             params, None)", "response": "Enable availability zones for a load balancer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisable availability zones for a load balancer.", "response": "def disable_availability_zones(self, load_balancer_name, zones_to_remove):\n        \"\"\"\n        Remove availability zones from an existing Load Balancer.\n        All zones must be in the same region as the Load Balancer.\n        Removing zones that are not registered with the Load Balancer\n        has no effect.\n        You cannot remove all zones from an Load Balancer.\n\n        :type load_balancer_name: string\n        :param load_balancer_name: The name of the Load Balancer\n\n        :type zones: List of strings\n        :param zones: The name of the zone(s) to remove.\n\n        :rtype: List of strings\n        :return: An updated list of zones for this Load Balancer.\n\n        \"\"\"\n        params = {'LoadBalancerName' : load_balancer_name}\n        self.build_list_params(params, zones_to_remove,\n                               'AvailabilityZones.member.%d')\n        return self.get_list('DisableAvailabilityZonesForLoadBalancer',\n                             params, None)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_instances(self, load_balancer_name, instances):\n        params = {'LoadBalancerName' : load_balancer_name}\n        self.build_list_params(params, instances,\n                               'Instances.member.%d.InstanceId')\n        return self.get_list('RegisterInstancesWithLoadBalancer',\n                             params, [('member', InstanceInfo)])", "response": "Register new Instances to an existing Load Balancer."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef deregister_instances(self, load_balancer_name, instances):\n        params = {'LoadBalancerName' : load_balancer_name}\n        self.build_list_params(params, instances,\n                               'Instances.member.%d.InstanceId')\n        return self.get_list('DeregisterInstancesFromLoadBalancer',\n                             params, [('member', InstanceInfo)])", "response": "Removes Instances from an existing Load Balancer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndescribe the current state of all Instances registered to an ELB.", "response": "def describe_instance_health(self, load_balancer_name, instances=None):\n        \"\"\"\n        Get current state of all Instances registered to an Load Balancer.\n\n        :type load_balancer_name: string\n        :param load_balancer_name: The name of the Load Balancer\n\n        :type instances: List of strings\n        :param instances: The instance ID's of the EC2 instances\n                          to return status for.  If not provided,\n                          the state of all instances will be returned.\n\n        :rtype: List of :class:`boto.ec2.elb.instancestate.InstanceState`\n        :return: list of state info for instances in this Load Balancer.\n\n        \"\"\"\n        params = {'LoadBalancerName' : load_balancer_name}\n        if instances:\n            self.build_list_params(params, instances,\n                                   'Instances.member.%d.InstanceId')\n        return self.get_list('DescribeInstanceHealth', params,\n                             [('member', InstanceState)])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_health_check(self, name, health_check):\n        params = {'LoadBalancerName' : name,\n                  'HealthCheck.Timeout' : health_check.timeout,\n                  'HealthCheck.Target' : health_check.target,\n                  'HealthCheck.Interval' : health_check.interval,\n                  'HealthCheck.UnhealthyThreshold' : health_check.unhealthy_threshold,\n                  'HealthCheck.HealthyThreshold' : health_check.healthy_threshold}\n        return self.get_object('ConfigureHealthCheck', params, HealthCheck)", "response": "Configures a health check for the load balancer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_lb_listener_SSL_certificate(self, lb_name, lb_port,\n                                        ssl_certificate_id):\n        \"\"\"\n        Sets the certificate that terminates the specified listener's SSL\n        connections. The specified certificate replaces any prior certificate\n        that was used on the same LoadBalancer and port.\n        \"\"\"\n        params = {\n                    'LoadBalancerName'          :   lb_name,\n                    'LoadBalancerPort'          :   lb_port,\n                    'SSLCertificateId'          :   ssl_certificate_id,\n                 }\n        return self.get_status('SetLoadBalancerListenerSSLCertificate', params)", "response": "Sets the certificate that terminates the specified listener s SSL\n        connections."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a stickiness policy that can be used to create a new application - generated cookie.", "response": "def create_app_cookie_stickiness_policy(self, name, lb_name, policy_name):\n        \"\"\"\n        Generates a stickiness policy with sticky session lifetimes that follow\n        that of an application-generated cookie. This policy can only be\n        associated with HTTP listeners.\n\n        This policy is similar to the policy created by\n        CreateLBCookieStickinessPolicy, except that the lifetime of the special\n        Elastic Load Balancing cookie follows the lifetime of the\n        application-generated cookie specified in the policy configuration. The\n        load balancer only inserts a new stickiness cookie when the application\n        response includes a new application cookie.\n\n        If the application cookie is explicitly removed or expires, the session\n        stops being sticky until a new application cookie is issued.\n        \"\"\"\n        params = {\n                    'CookieName'        :   name,\n                    'LoadBalancerName'  :   lb_name,\n                    'PolicyName'        :   policy_name,\n                 }\n        return self.get_status('CreateAppCookieStickinessPolicy', params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a stickiness policy that can be used to create a new load balancer cookie stickiness session.", "response": "def create_lb_cookie_stickiness_policy(self, cookie_expiration_period,\n                                           lb_name, policy_name):\n        \"\"\"\n        Generates a stickiness policy with sticky session lifetimes controlled\n        by the lifetime of the browser (user-agent) or a specified expiration\n        period. This policy can only be associated only with HTTP listeners.\n\n        When a load balancer implements this policy, the load balancer uses a\n        special cookie to track the backend server instance for each request.\n        When the load balancer receives a request, it first checks to see if\n        this cookie is present in the request. If so, the load balancer sends\n        the request to the application server specified in the cookie. If not,\n        the load balancer sends the request to a server that is chosen based on\n        the existing load balancing algorithm.\n\n        A cookie is inserted into the response for binding subsequent requests\n        from the same user to that server. The validity of the cookie is based\n        on the cookie expiration time, which is specified in the policy\n        configuration.\n        \"\"\"\n        params = {\n                    'CookieExpirationPeriod'    :   cookie_expiration_period,\n                    'LoadBalancerName'          :   lb_name,\n                    'PolicyName'                :   policy_name,\n                 }\n        return self.get_status('CreateLBCookieStickinessPolicy', params)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting a policy from the specified LoadBalancer.", "response": "def delete_lb_policy(self, lb_name, policy_name):\n        \"\"\"\n        Deletes a policy from the LoadBalancer. The specified policy must not\n        be enabled for any listeners.\n        \"\"\"\n        params = {\n                    'LoadBalancerName'          : lb_name,\n                    'PolicyName'                : policy_name,\n                 }\n        return self.get_status('DeleteLoadBalancerPolicy', params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the policies for a load balancer.", "response": "def set_lb_policies_of_listener(self, lb_name, lb_port, policies):\n        \"\"\"\n        Associates, updates, or disables a policy with a listener on the load\n        balancer. Currently only zero (0) or one (1) policy can be associated\n        with a listener.\n        \"\"\"\n        params = {\n                    'LoadBalancerName'          : lb_name,\n                    'LoadBalancerPort'          : lb_port,\n                 }\n        self.build_list_params(params, policies, 'PolicyNames.member.%d')\n        return self.get_status('SetLoadBalancerPoliciesOfListener', params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply_security_groups_to_lb(self, name, security_groups):\n        params = {'LoadBalancerName' : name}\n        self.build_list_params(params, security_groups, \n                               'SecurityGroups.member.%d')\n        return self.get_list('ApplySecurityGroupsToLoadBalancer', \n                             params,\n                             None)", "response": "Applies security groups to the load balancer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nattach load balancer to one or more subnets.", "response": "def attach_lb_to_subnets(self, name, subnets):\n        \"\"\"\n        Attaches load balancer to one or more subnets.\n        Attaching subnets that are already registered with the \n        Load Balancer has no effect.\n\n        :type name: string\n        :param name: The name of the Load Balancer\n\n        :type subnets: List of strings\n        :param subnets: The name of the subnet(s) to add.\n\n        :rtype: List of strings\n        :return: An updated list of subnets for this Load Balancer.\n\n        \"\"\"\n        params = {'LoadBalancerName' : name}\n        self.build_list_params(params, subnets, \n                               'Subnets.member.%d')\n        return self.get_list('AttachLoadBalancerToSubnets', \n                             params,\n                             None)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef detach_lb_from_subnets(self, name, subnets):\n        params = {'LoadBalancerName' : name}\n        self.build_list_params(params, subnets, \n                               'Subnets.member.%d')\n        return self.get_list('DettachLoadBalancerFromSubnets', \n                             params,\n                             None)", "response": "Detaches a load balancer from one or more subnets."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_missing_keys(src_dict, target_dict):\n    for key in list(target_dict.keys()):\n        if key not in src_dict:\n            target_dict.pop(key)", "response": "Removes keys from target_dict that are not available in src_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_dirs(path):\n    fname = os.path.basename(path)\n\n    # if file name exists in path, skip the filename\n    if fname.__contains__('.'):\n        path = os.path.dirname(path)\n\n    if not os.path.exists(path):\n        os.makedirs(path)", "response": "Creates all directories in the given path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates through all images in the given directory.", "response": "def each_img(dir_path):\n    \"\"\"\n    Iterates through each image in the given directory. (not recursive)\n    :param dir_path: Directory path where images files are present\n    :return: Iterator to iterate through image files\n    \"\"\"\n    for fname in os.listdir(dir_path):\n        if fname.endswith('.jpg') or fname.endswith('.png') or fname.endswith('.bmp'):\n            yield fname"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef select(cls, symbol, start_date, end_date):\n        instance = cls(symbol, start_date, end_date)\n\n        return instance.data", "response": "Method returns stock prices for current symbol start_date and end_date"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch the data for the current chunk.", "response": "def fetch_chunk_data(self):\n        \"\"\"If period of time between start end end is bigger then one year\n        We have to create and fetch chunks dates (6 months chunks).\"\"\"\n        data = []\n\n        counter = (relativedelta(self.end_date, self.start_date).months / 6) + 1\n        months = 0\n\n        for month in range(counter):\n\n            chunk_start_date = self.start_date + relativedelta(months=months)\n            chunk_end_date = self.start_date + relativedelta(months=months + 6)\n\n            months += 6\n\n            if chunk_end_date > self.end_date:\n                chunk_end_date = self.end_date\n\n            data = data + self.request.send(self.symbol, chunk_start_date, chunk_end_date)\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconnect to this Region s endpoint.", "response": "def connect(self, **kw_params):\n        \"\"\"\n        Connect to this Region's endpoint. Returns an connection\n        object pointing to the endpoint associated with this region.\n        You may pass any of the arguments accepted by the connection\n        class's constructor as keyword arguments and they will be\n        passed along to the connection object.\n        \n        :rtype: Connection object\n        :return: The connection to this regions endpoint\n        \"\"\"\n        if self.connection_cls:\n            return self.connection_cls(region=self, **kw_params)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_hit_type(self, title, description, reward, duration,\n                          keywords=None, approval_delay=None, qual_req=None):\n        \"\"\"\n        Register a new HIT Type\n        title, description are strings\n        reward is a Price object\n        duration can be a timedelta, or an object castable to an int\n        \"\"\"\n        params = dict(\n            Title=title,\n            Description=description,\n            AssignmentDurationInSeconds=\n                self.duration_as_seconds(duration),\n            )\n        params.update(MTurkConnection.get_price_as_price(reward).get_as_params('Reward'))\n\n        if keywords:\n            params['Keywords'] = self.get_keywords_as_string(keywords)\n\n        if approval_delay is not None:\n            d = self.duration_as_seconds(approval_delay)\n            params['AutoApprovalDelayInSeconds'] = d\n\n        if qual_req is not None:\n            params.update(qual_req.get_as_params())\n\n        return self._process_request('RegisterHITType', params)", "response": "Register a HIT Type with the user s account."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_email_notification(self, hit_type, email, event_types=None):\n        return self._set_notification(hit_type, 'Email', email, event_types)", "response": "Sets the HIT type to Notification Type Email"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting a HIT type to REST notification for a specific HIT type", "response": "def set_rest_notification(self, hit_type, url, event_types=None):\n        \"\"\"\n        Performs a SetHITTypeNotification operation to set REST notification\n        for a specified HIT type\n        \"\"\"\n        return self._set_notification(hit_type, 'REST', url, event_types)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _set_notification(self, hit_type, transport, destination, event_types=None):\n        assert type(hit_type) is str, \"hit_type argument should be a string.\"\n        \n        params = {'HITTypeId': hit_type}\n        \n        # from the Developer Guide:\n        # The 'Active' parameter is optional. If omitted, the active status of\n        # the HIT type's notification specification is unchanged. All HIT types\n        # begin with their notification specifications in the \"inactive\" status.\n        notification_params = {'Destination': destination,\n                               'Transport': transport,\n                               'Version': boto.mturk.notification.NotificationMessage.NOTIFICATION_VERSION,\n                               'Active': True,\n                               }\n\n        # add specific event types if required\n        if event_types:\n            self.build_list_params(notification_params, event_types, 'EventType')\n        \n        # Set up dict of 'Notification.1.Transport' etc. values\n        notification_rest_params = {}\n        num = 1\n        for key in notification_params:\n            notification_rest_params['Notification.%d.%s' % (num, key)] = notification_params[key]\n        \n        # Update main params dict\n        params.update(notification_rest_params)\n        \n        # Execute operation\n        return self._process_request('SetHITTypeNotification', params)", "response": "Common SetHITTypeNotification operation to set notification for HIT type a specific HIT type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_hit(self, hit_type=None, question=None,\n                   lifetime=datetime.timedelta(days=7),\n                   max_assignments=1, \n                   title=None, description=None, keywords=None,\n                   reward=None, duration=datetime.timedelta(days=7),\n                   approval_delay=None, annotation=None,\n                   questions=None, qualifications=None,\n                   response_groups=None):\n        \"\"\"\n        Creates a new HIT.\n        Returns a ResultSet\n        See: http://docs.amazonwebservices.com/AWSMechanicalTurkRequester/2006-10-31/ApiReference_CreateHITOperation.html\n        \"\"\"\n        \n        # handle single or multiple questions\n        neither = question is None and questions is None\n        both = question is not None and questions is not None\n        if neither or both:\n            raise ValueError(\"Must specify either question (single Question instance) or questions (list or QuestionForm instance), but not both\")\n\n        if question:\n            questions = [question]\n        question_param = QuestionForm(questions)\n        if isinstance(question, QuestionForm):\n            question_param = question\n        elif isinstance(question, ExternalQuestion):\n            question_param = question\n        \n        # Handle basic required arguments and set up params dict\n        params = {'Question': question_param.get_as_xml(),\n                  'LifetimeInSeconds' :\n                      self.duration_as_seconds(lifetime),\n                  'MaxAssignments' : max_assignments,\n                  }\n\n        # if hit type specified then add it\n        # else add the additional required parameters\n        if hit_type:\n            params['HITTypeId'] = hit_type\n        else:\n            # Handle keywords\n            final_keywords = MTurkConnection.get_keywords_as_string(keywords)\n            \n            # Handle price argument\n            final_price = MTurkConnection.get_price_as_price(reward)\n            \n            final_duration = self.duration_as_seconds(duration)\n\n            additional_params = dict(\n                Title=title,\n                Description=description,\n                Keywords=final_keywords,\n                AssignmentDurationInSeconds=final_duration,\n                )\n            additional_params.update(final_price.get_as_params('Reward'))\n\n            if approval_delay is not None:\n                d = self.duration_as_seconds(approval_delay)\n                additional_params['AutoApprovalDelayInSeconds'] = d\n\n            # add these params to the others\n            params.update(additional_params)\n\n        # add the annotation if specified\n        if annotation is not None:\n            params['RequesterAnnotation'] = annotation\n               \n        # Add the Qualifications if specified\n        if qualifications is not None:\n            params.update(qualifications.get_as_params())\n\n        # Handle optional response groups argument\n        if response_groups:\n            self.build_list_params(params, response_groups, 'ResponseGroup')\n                \n        # Submit\n        return self._process_request('CreateHIT', params, [('HIT', HIT),])", "response": "Creates a new HIT.\n        Returns a ResultSet\n        See: http://docs.amazonwebservices.com/AWSMechanicalTurkRequester/2006-10-31/ApiReference_CreateHITOperation.html"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef change_hit_type_of_hit(self, hit_id, hit_type):\n        params = {'HITId' : hit_id,\n                  'HITTypeId': hit_type}\n\n        return self._process_request('ChangeHITTypeOfHIT', params)", "response": "Change the HIT type of an existing HIT."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve HITs that have a status of Reviewable or Reviewing and that belong to the Requester.", "response": "def get_reviewable_hits(self, hit_type=None, status='Reviewable',\n                            sort_by='Expiration', sort_direction='Ascending', \n                            page_size=10, page_number=1):\n        \"\"\"\n        Retrieve the HITs that have a status of Reviewable, or HITs that\n        have a status of Reviewing, and that belong to the Requester\n        calling the operation.\n        \"\"\"\n        params = {'Status' : status,\n                  'SortProperty' : sort_by,\n                  'SortDirection' : sort_direction,\n                  'PageSize' : page_size,\n                  'PageNumber' : page_number}\n\n        # Handle optional hit_type argument\n        if hit_type is not None:\n            params.update({'HITTypeId': hit_type})\n\n        return self._process_request('GetReviewableHITs', params, [('HIT', HIT),])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_pages(page_size, total_records):\n        pages = total_records/page_size+bool(total_records%page_size)\n        return range(1, pages+1)", "response": "Given a page size and total number of records return the page numbers to be retrieved."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_all_hits(self):\n        page_size = 100\n        search_rs = self.search_hits(page_size=page_size)\n        total_records = int(search_rs.TotalNumResults)\n        get_page_hits = lambda(page): self.search_hits(page_size=page_size, page_number=page)\n        page_nums = self._get_pages(page_size, total_records)\n        hit_sets = itertools.imap(get_page_hits, page_nums)\n        return itertools.chain.from_iterable(hit_sets)", "response": "Return all of a Requester s HITs\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search_hits(self, sort_by='CreationTime', sort_direction='Ascending', \n                    page_size=10, page_number=1, response_groups=None):\n        \"\"\"\n        Return a page of a Requester's HITs, on behalf of the Requester.\n        The operation returns HITs of any status, except for HITs that\n        have been disposed with the DisposeHIT operation.\n        Note:\n        The SearchHITs operation does not accept any search parameters\n        that filter the results.\n        \"\"\"\n        params = {'SortProperty' : sort_by,\n                  'SortDirection' : sort_direction,\n                  'PageSize' : page_size,\n                  'PageNumber' : page_number}\n        # Handle optional response groups argument\n        if response_groups:\n            self.build_list_params(params, response_groups, 'ResponseGroup')\n                \n\n        return self._process_request('SearchHITs', params, [('HIT', HIT),])", "response": "Search HITs on behalf of the Requester."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves completed assignments for a HIT. Use this operation to retrieve the results for a HIT. The returned ResultSet will have the following attributes: NumResults The number of assignments on the page in the filtered results list, equivalent to the number of assignments being returned by this call. A non-negative integer PageNumber The number of the page in the filtered results list being returned. A positive integer TotalNumResults The total number of HITs in the filtered results list based on this call. A non-negative integer The ResultSet will contain zero or more Assignment objects", "response": "def get_assignments(self, hit_id, status=None,\n                            sort_by='SubmitTime', sort_direction='Ascending', \n                            page_size=10, page_number=1, response_groups=None):\n        \"\"\"\n        Retrieves completed assignments for a HIT. \n        Use this operation to retrieve the results for a HIT.\n\n        The returned ResultSet will have the following attributes:\n\n        NumResults\n                The number of assignments on the page in the filtered results\n                list, equivalent to the number of assignments being returned\n                by this call.\n                A non-negative integer\n        PageNumber\n                The number of the page in the filtered results list being\n                returned.\n                A positive integer\n        TotalNumResults\n                The total number of HITs in the filtered results list based\n                on this call.\n                A non-negative integer\n\n        The ResultSet will contain zero or more Assignment objects \n\n        \"\"\"\n        params = {'HITId' : hit_id,\n                  'SortProperty' : sort_by,\n                  'SortDirection' : sort_direction,\n                  'PageSize' : page_size,\n                  'PageNumber' : page_number}\n\n        if status is not None:\n            params['AssignmentStatus'] = status\n\n        # Handle optional response groups argument\n        if response_groups:\n            self.build_list_params(params, response_groups, 'ResponseGroup')\n                \n        return self._process_request('GetAssignmentsForHIT', params,\n                                     [('Assignment', Assignment),])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_reviewing(self, hit_id, revert=None):\n        params = {'HITId' : hit_id,}\n        if revert:\n            params['Revert'] = revert\n        return self._process_request('SetHITAsReviewing', params)", "response": "Set the HIT to Reviewing."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisabling a HIT from Mechanical Turk", "response": "def disable_hit(self, hit_id, response_groups=None):\n        \"\"\"\n        Remove a HIT from the Mechanical Turk marketplace, approves all\n        submitted assignments that have not already been approved or rejected,\n        and disposes of the HIT and all assignment data.\n\n        Assignments for the HIT that have already been submitted, but not yet\n        approved or rejected, will be automatically approved. Assignments in\n        progress at the time of the call to DisableHIT will be approved once\n        the assignments are submitted. You will be charged for approval of\n        these assignments.  DisableHIT completely disposes of the HIT and\n        all submitted assignment data. Assignment results data cannot be\n        retrieved for a HIT that has been disposed.\n\n        It is not possible to re-enable a HIT once it has been disabled.\n        To make the work from a disabled HIT available again, create a new HIT.\n        \"\"\"\n        params = {'HITId' : hit_id,}\n        # Handle optional response groups argument\n        if response_groups:\n            self.build_list_params(params, response_groups, 'ResponseGroup')\n                \n        return self._process_request('DisableHIT', params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextend a HIT by adding assignments or expiration date.", "response": "def extend_hit(self, hit_id, assignments_increment=None, expiration_increment=None):\n        \"\"\"\n        Increase the maximum number of assignments, or extend the\n        expiration date, of an existing HIT.\n        \n        NOTE: If a HIT has a status of Reviewable and the HIT is\n        extended to make it Available, the HIT will not be returned by\n        GetReviewableHITs, and its submitted assignments will not be\n        returned by GetAssignmentsForHIT, until the HIT is Reviewable\n        again.  Assignment auto-approval will still happen on its\n        original schedule, even if the HIT has been extended. Be sure\n        to retrieve and approve (or reject) submitted assignments\n        before extending the HIT, if so desired.\n        \"\"\"\n        # must provide assignment *or* expiration increment\n        if (assignments_increment is None and expiration_increment is None) or \\\n           (assignments_increment is not None and expiration_increment is not None):\n            raise ValueError(\"Must specify either assignments_increment or expiration_increment, but not both\")\n\n        params = {'HITId' : hit_id,}\n        if assignments_increment:\n            params['MaxAssignmentsIncrement'] = assignments_increment\n        if expiration_increment:\n            params['ExpirationIncrementInSeconds'] = expiration_increment\n\n        return self._process_request('ExtendHIT', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns information about the Mechanical Turk Service operations and response group", "response": "def get_help(self, about, help_type='Operation'):\n        \"\"\"\n        Return information about the Mechanical Turk Service\n        operations and response group NOTE - this is basically useless\n        as it just returns the URL of the documentation\n\n        help_type: either 'Operation' or 'ResponseGroup'\n        \"\"\"\n        params = {'About': about, 'HelpType': help_type,}\n        return self._process_request('Help', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef grant_bonus(self, worker_id, assignment_id, bonus_price, reason):\n        params = bonus_price.get_as_params('BonusAmount', 1)\n        params['WorkerId'] = worker_id\n        params['AssignmentId'] = assignment_id\n        params['Reason'] = reason\n\n        return self._process_request('GrantBonus', params)", "response": "Grant a bonus to a Worker."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef block_worker(self, worker_id, reason):\n        params = {'WorkerId': worker_id, 'Reason': reason}\n\n        return self._process_request('BlockWorker', params)", "response": "Block a worker from working on my tasks."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nunblocks a worker from working on my tasks.", "response": "def unblock_worker(self, worker_id, reason):\n        \"\"\"\n        Unblock a worker from working on my tasks.\n        \"\"\"\n        params = {'WorkerId': worker_id, 'Reason': reason}\n\n        return self._process_request('UnblockWorker', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a text message to workers.", "response": "def notify_workers(self, worker_ids, subject, message_text):\n        \"\"\"\n        Send a text message to workers.\n        \"\"\"\n        params = {'Subject' : subject,\n                  'MessageText': message_text}\n        self.build_list_params(params, worker_ids, 'WorkerId')\n\n        return self._process_request('NotifyWorkers', params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new qualification type.", "response": "def create_qualification_type(self,\n                                  name,\n                                  description,\n                                  status,\n                                  keywords=None,\n                                  retry_delay=None,\n                                  test=None,\n                                  answer_key=None,\n                                  answer_key_xml=None,\n                                  test_duration=None,\n                                  auto_granted=False,\n                                  auto_granted_value=1):\n        \"\"\"\n        Create a new Qualification Type.\n\n        name: This will be visible to workers and must be unique for a\n           given requester.\n\n        description: description shown to workers.  Max 2000 characters.\n\n        status: 'Active' or 'Inactive'\n\n        keywords: list of keyword strings or comma separated string.\n           Max length of 1000 characters when concatenated with commas.\n\n        retry_delay: number of seconds after requesting a\n           qualification the worker must wait before they can ask again.\n           If not specified, workers can only request this qualification\n           once.\n\n        test: a QuestionForm\n\n        answer_key: an XML string of your answer key, for automatically\n           scored qualification tests.\n           (Consider implementing an AnswerKey class for this to support.)\n\n        test_duration: the number of seconds a worker has to complete the test.\n\n        auto_granted: if True, requests for the Qualification are granted\n           immediately.  Can't coexist with a test.\n\n        auto_granted_value: auto_granted qualifications are given this value.\n\n        \"\"\"\n\n        params = {'Name' : name,\n                  'Description' : description,\n                  'QualificationTypeStatus' : status,\n                  }\n        if retry_delay is not None:\n            params['RetryDelayInSeconds'] = retry_delay\n\n        if test is not None:\n            assert(isinstance(test, QuestionForm))\n            assert(test_duration is not None)\n            params['Test'] = test.get_as_xml()\n\n        if test_duration is not None:\n            params['TestDurationInSeconds'] = test_duration\n\n        if answer_key is not None:\n            if isinstance(answer_key, basestring):\n                params['AnswerKey'] = answer_key # xml\n            else:\n                raise TypeError\n                # Eventually someone will write an AnswerKey class.\n\n        if auto_granted:\n            assert(test is None)\n            params['AutoGranted'] = True\n            params['AutoGrantedValue'] = auto_granted_value\n\n        if keywords:\n            params['Keywords'] = self.get_keywords_as_string(keywords)\n\n        return self._process_request('CreateQualificationType', params,\n                                     [('QualificationType', QualificationType),])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngranting a qualification to the current user.", "response": "def grant_qualification(self, qualification_request_id, integer_value=1):\n        \"\"\"TODO: Document.\"\"\"\n        params = {'QualificationRequestId' : qualification_request_id,\n                  'IntegerValue' : integer_value}\n        return self._process_request('GrantQualification', params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef revoke_qualification(self, subject_id, qualification_type_id,\n                             reason=None):\n        \"\"\"TODO: Document.\"\"\"\n        params = {'SubjectId' : subject_id,\n                  'QualificationTypeId' : qualification_type_id,\n                  'Reason' : reason}\n        return self._process_request('RevokeQualification', params)", "response": "Revoke a qualification from a subject."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the score of a worker in a qualification type.", "response": "def get_qualification_score(self, qualification_type_id, worker_id):\n        \"\"\"TODO: Document.\"\"\"\n        params = {'QualificationTypeId' : qualification_type_id,\n                  'SubjectId' : worker_id}\n        return self._process_request('GetQualificationScore', params,\n                    [('Qualification', Qualification),])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the qualification score for a worker.", "response": "def update_qualification_score(self, qualification_type_id, worker_id,\n                                   value):\n        \"\"\"TODO: Document.\"\"\"\n        params = {'QualificationTypeId' : qualification_type_id,\n                  'SubjectId' : worker_id,\n                  'IntegerValue' : value}\n        return self._process_request('UpdateQualificationScore', params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a comma + space - separated string of keywords from either a list or a string", "response": "def get_keywords_as_string(keywords):\n        \"\"\"\n        Returns a comma+space-separated string of keywords from either\n        a list or a string\n        \"\"\"\n        if type(keywords) is list:\n            keywords = ', '.join(keywords)\n        if type(keywords) is str:\n            final_keywords = keywords\n        elif type(keywords) is unicode:\n            final_keywords = keywords.encode('utf-8')\n        elif keywords is None:\n            final_keywords = \"\"\n        else:\n            raise TypeError(\"keywords argument must be a string or a list of strings; got a %s\" % type(keywords))\n        return final_keywords"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Price data structure from either a float or Price object", "response": "def get_price_as_price(reward):\n        \"\"\"\n        Returns a Price data structure from either a float or a Price\n        \"\"\"\n        if isinstance(reward, Price):\n            final_price = reward\n        else:\n            final_price = Price(reward)\n        return final_price"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if HIT has expired yet.", "response": "def _has_expired(self):\n        \"\"\" Has this HIT expired yet? \"\"\"\n        expired = False\n        if hasattr(self, 'Expiration'):\n            now = datetime.datetime.utcnow()\n            expiration = datetime.datetime.strptime(self.Expiration, '%Y-%m-%dT%H:%M:%SZ')\n            expired = (now >= expiration)\n        else:\n            raise ValueError(\"ERROR: Request for expired property, but no Expiration in HIT!\")\n        return expired"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef multipart_upload_lister(bucket, key_marker='',\n                            upload_id_marker='',\n                            headers=None):\n    \"\"\"\n    A generator function for listing multipart uploads in a bucket.\n    \"\"\"\n    more_results = True\n    k = None\n    while more_results:\n        rs = bucket.get_all_multipart_uploads(key_marker=key_marker,\n                                              upload_id_marker=upload_id_marker,\n                                              headers=headers)\n        for k in rs:\n            yield k\n        key_marker = rs.next_key_marker\n        upload_id_marker = rs.next_upload_id_marker\n        more_results= rs.is_truncated", "response": "A generator function for listing multipart uploads in a bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef put_attributes(self, item_name, attributes,\n                       replace=True, expected_value=None):\n        \"\"\"\n        Store attributes for a given item.\n\n        :type item_name: string\n        :param item_name: The name of the item whose attributes are being stored.\n\n        :type attribute_names: dict or dict-like object\n        :param attribute_names: The name/value pairs to store as attributes\n\n        :type expected_value: list\n        :param expected_value: If supplied, this is a list or tuple consisting\n            of a single attribute name and expected value. The list can be \n            of the form:\n\n             * ['name', 'value']\n\n            In which case the call will first verify that the attribute \n            \"name\" of this item has a value of \"value\".  If it does, the delete\n            will proceed, otherwise a ConditionalCheckFailed error will be \n            returned. The list can also be of the form:\n            \n             * ['name', True|False]\n            \n            which will simply check for the existence (True) or non-existence \n            (False) of the attribute.\n\n        :type replace: bool\n        :param replace: Whether the attribute values passed in will replace\n                        existing values or will be added as addition values.\n                        Defaults to True.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        return self.connection.put_attributes(self, item_name, attributes,\n                                              replace, expected_value)", "response": "Store attributes for a given item."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef batch_put_attributes(self, items, replace=True):\n        return self.connection.batch_put_attributes(self, items, replace)", "response": "Store attributes for multiple items."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves attributes for a given item.", "response": "def get_attributes(self, item_name, attribute_name=None,\n                       consistent_read=False, item=None):\n        \"\"\"\n        Retrieve attributes for a given item.\n\n        :type item_name: string\n        :param item_name: The name of the item whose attributes are being retrieved.\n\n        :type attribute_names: string or list of strings\n        :param attribute_names: An attribute name or list of attribute names.  This\n                                parameter is optional.  If not supplied, all attributes\n                                will be retrieved for the item.\n\n        :rtype: :class:`boto.sdb.item.Item`\n        :return: An Item mapping type containing the requested attribute name/values\n        \"\"\"\n        return self.connection.get_attributes(self, item_name, attribute_name,\n                                              consistent_read, item)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_attributes(self, item_name, attributes=None,\n                          expected_values=None):\n        \"\"\"\n        Delete attributes from a given item.\n\n        :type item_name: string\n        :param item_name: The name of the item whose attributes are being deleted.\n\n        :type attributes: dict, list or :class:`boto.sdb.item.Item`\n        :param attributes: Either a list containing attribute names which will cause\n                           all values associated with that attribute name to be deleted or\n                           a dict or Item containing the attribute names and keys and list\n                           of values to delete as the value.  If no value is supplied,\n                           all attribute name/values for the item will be deleted.\n                           \n        :type expected_value: list\n        :param expected_value: If supplied, this is a list or tuple consisting\n            of a single attribute name and expected value. The list can be of \n            the form:\n\n             * ['name', 'value']\n\n            In which case the call will first verify that the attribute \"name\"\n            of this item has a value of \"value\".  If it does, the delete\n            will proceed, otherwise a ConditionalCheckFailed error will be \n            returned. The list can also be of the form:\n\n             * ['name', True|False]\n\n            which will simply check for the existence (True) or \n            non-existence (False) of the attribute.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        return self.connection.delete_attributes(self, item_name, attributes,\n                                                 expected_values)", "response": "Delete attributes from a given item."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef select(self, query='', next_token=None, consistent_read=False, max_items=None):\n        return SelectResultSet(self, query, max_items=max_items, next_token=next_token,\n                               consistent_read=consistent_read)", "response": "Returns an iterator over the attributes of the items within the domain_name that match the query."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving an item from the domain along with all of its attributes.", "response": "def get_item(self, item_name, consistent_read=False):\n        \"\"\"\n        Retrieves an item from the domain, along with all of its attributes.\n        \n        :param string item_name: The name of the item to retrieve.\n        :rtype: :class:`boto.sdb.item.Item` or ``None``\n        :keyword bool consistent_read: When set to true, ensures that the most \n                                       recent data is returned.\n        :return: The requested item, or ``None`` if there was no match found \n        \"\"\"\n        item = self.get_attributes(item_name, consistent_read=consistent_read)\n        if item:\n            item.domain = self\n            return item\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_xml(self, f=None):\n        if not f:\n            from tempfile import TemporaryFile\n            f = TemporaryFile()\n        print >> f, '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n        print >> f, '<Domain id=\"%s\">' % self.name\n        for item in self:\n            print >> f, '\\t<Item id=\"%s\">' % item.name\n            for k in item:\n                print >> f, '\\t\\t<attribute id=\"%s\">' % k\n                values = item[k]\n                if not isinstance(values, list):\n                    values = [values]\n                for value in values:\n                    print >> f, '\\t\\t\\t<value><![CDATA[',\n                    if isinstance(value, unicode):\n                        value = value.encode('utf-8', 'replace')\n                    else:\n                        value = unicode(value, errors='replace').encode('utf-8', 'replace')\n                    f.write(value)\n                    print >> f, ']]></value>'\n                print >> f, '\\t\\t</attribute>'\n            print >> f, '\\t</Item>'\n        print >> f, '</Domain>'\n        f.flush()\n        f.seek(0)\n        return f", "response": "Get this domain as an XML DOM Document."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads this domain based on an XML document", "response": "def from_xml(self, doc):\n        \"\"\"Load this domain based on an XML document\"\"\"\n        import xml.sax\n        handler = DomainDumpParser(self)\n        xml.sax.parse(doc, handler)\n        return handler"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if either the datastream content or profile fields have changed", "response": "def isModified(self):\n        \"\"\"Check if either the datastream content or profile fields have changed\n        and should be saved to Fedora.\n\n        :rtype: boolean\n        \"\"\"\n        # NOTE: only check content digest if locally cached content is set\n        # (content already pulled or new content set); otherwise this\n        # results in pulling content down to checksum it !\n        return self.info_modified or \\\n            self._content and self._content_digest() != self.digest"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef history(self):\n        '''Get history/version information for this datastream and\n        return as an instance of\n        :class:`~eulfedora.xml.DatastreamHistory`.'''\n        r = self.obj.api.getDatastreamHistory(self.obj.pid, self.id, format='xml')\n        return parse_xml_object(DatastreamHistory, r.content, r.url)", "response": "Get history information for this datastream and\n        return as an instance of\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self, logmessage=None):\n        if self.as_of_date is not None:\n            raise RuntimeError('Saving is not implemented for datastream versions')\n\n        save_opts = {}\n        if self.info_modified:\n            if self.label:\n                save_opts['dsLabel'] = self.label\n            if self.mimetype:\n                save_opts['mimeType'] = self.mimetype\n            if self.versionable is not None:\n                save_opts['versionable'] = self.versionable\n            if self.state:\n                save_opts['dsState'] = self.state\n            if self.format:\n                save_opts['formatURI'] = self.format\n            if self.checksum:\n                if self.checksum_modified:\n                    save_opts['checksum'] = self.checksum\n            if self.checksum_type:\n                save_opts['checksumType'] = self.checksum_type\n            # FIXME: should be able to handle checksums\n        # NOTE: as of Fedora 3.2, updating content without specifying mimetype fails (Fedora bug?)\n        if 'mimeType' not in save_opts.keys():\n            # if datastreamProfile has not been pulled from fedora, use configured default mimetype\n            if self._info is not None:\n                save_opts['mimeType'] = self.mimetype\n            else:\n                save_opts['mimeType'] = self.defaults['mimetype']\n\n        # if datastream location has been set, use that for content\n        # otherwise, use local content (if any)\n        if self.ds_location is not None:\n            save_opts['dsLocation'] = self.ds_location\n        else:\n\n            save_opts['content'] = self._raw_content()\n\n        if self.exists:\n            # if not versionable, make a backup to back out changes if object save fails\n            if not self.versionable:\n                self._backup()\n            # if this datastream already exists, use modifyDatastream API call\n            r = self.obj.api.modifyDatastream(self.obj.pid, self.id,\n                    logMessage=logmessage, **save_opts)\n            # expects 200 ok\n            success = (r.status_code == requests.codes.ok)\n        else:\n            # if this datastream does not yet exist, add it\n            r = self.obj.api.addDatastream(self.obj.pid, self.id,\n                    controlGroup=self.defaults['control_group'],\n                    logMessage=logmessage, **save_opts)\n            # expects 201 created\n            success = (r.status_code == requests.codes.created)\n            # clean-up required for object info after adding a new datastream\n            if success:\n                # update exists flag - if add succeeded, the datastream exists now\n                self.exists = True\n                # if the datastream content is a file-like object, clear it out\n                # (we don't want to attempt to save the current file contents again,\n                # particularly since the file is not guaranteed to still be open)\n                if 'content' in save_opts and hasattr(save_opts['content'], 'read'):\n                    self._content = None\n                    self._content_modified = False\n\n        if success:\n            # update modification indicators\n            self.info_modified = False\n            self.checksum_modified = False\n            self.digest = self._content_digest()\n            # clear out ds location\n            self.ds_location = None\n\n        return success", "response": "Save the datastream content and any changed datastream profile to Fedora."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef undo_last_save(self, logMessage=None):\n        # NOTE: currently not clearing any of the object caches and backups\n        # of fedora content and datastream info, as it is unclear what (if anything)\n        # should be cleared\n\n        if self.versionable:\n            # if this is a versioned datastream, get datastream history\n            # and purge the most recent version\n            last_save = self.history().versions[0].created  # fedora returns most recent first\n            r = self.obj.api.purgeDatastream(self.obj.pid, self.id,\n                                                datetime_to_fedoratime(last_save),\n                                                logMessage=logMessage)\n            return r.status_code == requests.codes.ok\n        else:\n            # for an unversioned datastream, update with any content and info\n            # backups that were pulled from Fedora before any modifications were made\n            args = {}\n            if self._content_backup is not None:\n                args['content'] = self._content_backup\n            if self._info_backup is not None:\n                args.update(self._info_backup)\n            r = self.obj.api.modifyDatastream(self.obj.pid, self.id,\n                            logMessage=logMessage, **args)\n            return r.status_code == requests.codes.ok", "response": "Undo the last change made to the datastream content and profile effectively\n        reverting to the object state in Fedora as of the specified timestamp."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if this datastream has a valid checksum in Fedora by running the REST_API. compareDatastreamChecksum API call. Returns a boolean based on the checksum valid response from Fedora.", "response": "def validate_checksum(self, date=None):\n        '''Check if this datastream has a valid checksum in Fedora, by\n        running the :meth:`REST_API.compareDatastreamChecksum` API\n        call.  Returns a boolean based on the checksum valid\n        response from Fedora.\n\n        :param date: (optional) check the datastream validity at a\n            particular date/time (e.g., for versionable datastreams)\n        '''\n        r = self.obj.api.compareDatastreamChecksum(self.obj.pid, self.id,\n                                                               asOfDateTime=date)\n        dsprofile = parse_xml_object(DatastreamProfile, r.content, r.url)\n        return dsprofile.checksum_valid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreplacing a uri reference everywhere it appears in the graph with another one.", "response": "def replace_uri(self, src, dest):\n        \"\"\"Replace a uri reference everywhere it appears in the graph with\n        another one. It could appear as the subject, predicate, or object of\n        a statement, so for each position loop through each statement that\n        uses the reference in that position, remove the old statement, and\n        add the replacement. \"\"\"\n\n        # NB: The hypothetical statement <src> <src> <src> will be removed\n        # and re-added several times. The subject block will remove it and\n        # add <dest> <src> <src>. The predicate block will remove that and\n        # add <dest> <dest> <src>. The object block will then remove that\n        # and add <dest> <dest> <dest>.\n\n        # NB2: The list() call here is necessary. .triples() is a generator:\n        # It calculates its matches as it progressively iterates through the\n        # graph. Actively changing the graph inside the for loop while the\n        # generator is in the middle of examining it risks invalidating the\n        # generator and could conceivably make it Just Break, depending on\n        # the implementation of .triples(). Wrapping .triples() in a list()\n        # forces it to exhaust the generator, running through the entire\n        # graph to calculate the list of matches before continuing to the\n        # for loop.\n\n        subject_triples = list(self.content.triples((src, None, None)))\n        for s, p, o in subject_triples:\n            self.content.remove((src, p, o))\n            self.content.add((dest, p, o))\n\n        predicate_triples = list(self.content.triples((None, src, None)))\n        for s, p, o in predicate_triples:\n            self.content.remove((s, src, o))\n            self.content.add((s, dest, o))\n\n        object_triples = list(self.content.triples((None, None, src)))\n        for s, p, o in object_triples:\n            self.content.remove((s, p, src))\n            self.content.add((s, p, dest))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprepares the object for ingesting.", "response": "def _prepare_ingest(self):\n        \"\"\"If the RDF datastream refers to the object by the default dummy\n        uriref then we need to replace that dummy reference with a real one\n        before we ingest the object.\"\"\"\n\n        # see also commentary on DigitalObject.DUMMY_URIREF\n        self.replace_uri(self.obj.DUMMY_URIREF, self.obj.uriref)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninstances of : class : zffedora. api. ResourceIndex with the same root url and credentials", "response": "def risearch(self):\n        \"Instance of :class:`eulfedora.api.ResourceIndex`, with the same root url and credentials\"\n        if self._risearch is None:\n            self._risearch = ResourceIndex(self.api.base_url, self.api.username, self.api.password)\n        return self._risearch"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_object(self, pid, type=None):\n        '''Initialize and return a new\n        :class:`~eulfedora.models.DigitalObject` instance from the same\n        repository, passing along the connection credentials in use by\n        the current object.  If type is not specified, the current\n        DigitalObject class will be used.\n\n        :param pid: pid of the object to return\n        :param type: (optional) :class:`~eulfedora.models.DigitalObject`\n           type to initialize and return\n        '''\n        if type is None:\n            type = self.__class__\n        return type(self.api, pid)", "response": "Initialize and return a new object from the same\n        repository passing along the connection credentials in use by\n        the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the next default pid when creating and ingesting a new DigitalObject instance without specifying a pid.", "response": "def get_default_pid(self):\n        '''Get the next default pid when creating and ingesting a new\n        DigitalObject instance without specifying a pid.  By default,\n        calls :meth:`ApiFacade.getNextPID` with the configured class\n        default_pidspace (if specified) as the pid namespace.\n\n        If your project requires custom pid logic (e.g., object pids\n        are based on an external pid generator), you should extend\n        DigitalObject and override this method.'''\n        # This function is used by __init__ as a default pid generator if\n        # none is specified. If you get the urge to override it, make sure\n        # it still works there.\n        kwargs = {}\n        if self.default_pidspace is not None:\n            kwargs['namespace'] = self.default_pidspace\n        r = self.api.getNextPID(**kwargs)\n        nextpids = parse_xml_object(NewPids, r.content, r.url)\n        return nextpids.pids[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef uri(self):\n        \"Fedora URI for this object (``info:fedora/foo:###`` form of object pid) \"\n        use_pid = self.pid\n        if callable(use_pid):\n            use_pid = self.DUMMY_PID\n        return 'info:fedora/' + use_pid", "response": "Fedora URI for this object ( info : fedora / foo :### form of object pid"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread - only list of object owners separated by the configured : attr : OWNER_ID_SEPARATOR with whitespace stripped.", "response": "def owners(self):\n        '''Read-only list of object owners, separated by the configured\n        :attr:`OWNER_ID_SEPARATOR`, with whitespace stripped.'''\n        return [o.strip() for o in self.owner.split(self.OWNER_ID_SEPARATOR)]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef exists(self):\n\n        # If we made the object under the pretext that it doesn't exist in\n        # fedora yet, then assume it doesn't exist in fedora yet.\n        if self._create:\n            return False\n\n        # If we can get a valid object profile, regardless of its contents,\n        # then this object exists. If not, then it doesn't.\n        try:\n            self.getProfile()\n            return True\n        except RequestFailed:\n            return False", "response": "Returns True when the object actually exists in Fedora\n            False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_requisite_content_models(self):\n        ''':type: bool\n\n        True when the current object has the expected content models\n        for whatever subclass of :class:`DigitalObject` it was\n        initialized as.'''\n        for cmodel in getattr(self, 'CONTENT_MODELS', ()):\n            if not self.has_model(cmodel):\n                return False\n        return True", "response": "True when the current object has the expected content models for whatever subclass of DigitalObject it was initialized as."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget information about a particular datastream.", "response": "def getDatastreamProfile(self, dsid, date=None):\n        \"\"\"Get information about a particular datastream belonging to this object.\n\n        :param dsid: datastream id\n        :rtype: :class:`DatastreamProfile`\n        \"\"\"\n        # NOTE: used by DatastreamObject\n        if self._create:\n            return None\n\n        r = self.api.getDatastream(self.pid, dsid, asOfDateTime=date)\n        return parse_xml_object(DatastreamProfile, r.content, r.url)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef audit_trail_users(self):\n        '''A set of all usernames recorded in the :attr:`audit_trail`,\n        if available.'''\n        if self.audit_trail:\n            return set([r.user for r in self.audit_trail.records])\n        return set()", "response": "A set of all usernames recorded in the audit_trail."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets information about this object.", "response": "def getProfile(self):\n        \"\"\"Get information about this object (label, owner, date created, etc.).\n\n        :rtype: :class:`ObjectProfile`\n        \"\"\"\n        if self._create:\n            return ObjectProfile()\n        else:\n            if self._profile is None:\n                r = self.api.getObjectProfile(self.pid)\n                self._profile = parse_xml_object(ObjectProfile, r.content, r.url)\n            return self._profile"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, logMessage=None):\n\n        if self._create:\n            self._prepare_ingest()\n            self._ingest(logMessage)\n        else:\n            self._save_existing(logMessage)\n\n        #No errors, then return true\n        return True", "response": "Save to Fedora any parts of this object that have been modified."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _undo_save(self, datastreams, logMessage=None):\n        return [ds for ds in datastreams if self.dscache[ds].undo_last_save(logMessage)]", "response": "Takes a list of datastreams and a datetime and runs undo save on all of them"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all datastreams that belong to this object.", "response": "def _get_datastreams(self):\n        \"\"\"\n        Get all datastreams that belong to this object.\n\n        Returns a dictionary; key is datastream id, value is an :class:`ObjectDatastream`\n        for that datastream.\n\n        :rtype: dictionary\n        \"\"\"\n        if self._create:\n            # FIXME: should we default to the datastreams defined in code?\n            return {}\n        else:\n            # NOTE: can be accessed as a cached class property via ds_list\n            r = self.api.listDatastreams(self.pid)\n            dsobj = parse_xml_object(ObjectDatastreams, r.content, r.url)\n            return dict([(ds.dsid, ds) for ds in dsobj.datastreams])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ds_list(self):      # NOTE: how to name to distinguish from locally configured datastream objects?\n        # FIXME: how to make access to a versioned ds_list ?\n\n        if self._ds_list is None:\n            self._ds_list = self._get_datastreams()\n        return self._ds_list", "response": "Returns a list of all datastream objects that belong to this object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting any datastream on this object as a : class:`DatastreamObject| or ** add a new datastream.", "response": "def getDatastreamObject(self, dsid, dsobj_type=None, as_of_date=None):\n        '''Get any datastream on this object as a :class:`DatastreamObject`\n        **or** add a new datastream.  If the datastream id corresponds\n        to a predefined datastream, the configured object will be returned\n        and the datastream object will be returned.  If type is not\n        specified for an existing datastream, attempts to infer the\n        appropriate subclass of datastream object to return based on the\n        mimetype (for XML and RELS-EXT).\n\n        Note that if you use this method to add new datastreams you should\n        be sure to set all datastream metadata appropriately for your content\n        (i.e., label, mimetype, control group, etc).\n\n        :param dsid: datastream id\n        :param dsobj_type: optional :class:`DatastreamObject` type to\n            be returned\n        :param as_of_date: optional datetime, used to load a historical\n            version of the requested datastream\n        '''\n\n        # NOTE: disabling this option because it returns a Datastream instead of\n        # a DatastreamObject, which is unexpected\n        # if the requested datastream is a defined datastream, return it\n        # if dsid in self._defined_datastreams:\n        #   return self._defined_datastreams[dsid]\n\n        if dsid in self._adhoc_datastreams:\n            return self._adhoc_datastreams[dsid]\n\n        if dsid in self.ds_list:\n            ds_info = self.ds_list[dsid]\n            # FIXME: can we take advantage of Datastream descriptor? or at least use dscache ?\n\n            if dsobj_type is None:\n                # if datastream mimetype matches one of our base datastream objects, use it\n\n                # special case: rels-ext should always be loaded as rdf\n                if ds_info.mimeType == RdfDatastreamObject.default_mimetype \\\n                  or dsid == 'RELS-EXT':\n                    dsobj_type = RdfDatastreamObject\n                elif ds_info.mimeType == XmlDatastreamObject.default_mimetype:\n                    dsobj_type = XmlDatastreamObject\n                else:\n                    # default to base datastream object class\n                    dsobj_type = DatastreamObject\n\n            dsobj = dsobj_type(self, dsid, label=ds_info.label,\n                               mimetype=ds_info.mimeType, as_of_date=as_of_date)\n\n            # add to dscache so modifications will be saved on existing object\n            self.dscache[dsid] = dsobj\n            setattr(self, dsid, dsobj)\n\n            return dsobj\n\n        else:\n            if dsobj_type is None:\n                dsobj_type = DatastreamObject\n            logger.info('Adding new datastream %s to %r', dsid, self)\n            # NOTE: label is required to initialize a new datastream object;\n            # using dsid as label since we don't have anything else.\n            dsobj = dsobj_type(self, dsid, dsid)\n            # add to the adhoc datastreams so it will get ingested to fedora (if new)\n            self._adhoc_datastreams[dsid] = dsobj\n            # make available like a defined datastream object so ingest will work\n            setattr(self, dsid, dsobj)\n            # add to dscache so new datastream will be saved on existing object\n            self.dscache[dsid] = dsobj\n            # default modification logic should be appropriate here since the\n            # calling program should be setting content, label, etc\n\n            return dsobj"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new relationship to the RELS - EXT for this object.", "response": "def add_relationship(self, rel_uri, obj):\n        \"\"\"\n        Add a new relationship to the RELS-EXT for this object.\n        Calls :meth:`API_M.addRelationship`.\n\n        Example usage::\n\n            isMemberOfCollection = 'info:fedora/fedora-system:def/relations-external#isMemberOfCollection'\n            collection_uri = 'info:fedora/foo:456'\n            object.add_relationship(isMemberOfCollection, collection_uri)\n\n        :param rel_uri: URI for the new relationship\n        :param obj: related object; can be :class:`DigitalObject` or string; if\n                        string begins with info:fedora/ it will be treated as\n                        a resource, otherwise it will be treated as a literal\n        :rtype: boolean\n        \"\"\"\n        if isinstance(rel_uri, URIRef):\n            rel_uri = force_text(rel_uri)\n\n        obj_is_literal = True\n        if isinstance(obj, DigitalObject):\n            obj = obj.uri\n            obj_is_literal = False\n        elif (isinstance(obj, str) or isinstance(obj, six.string_types)) \\\n          and obj.startswith('info:fedora/'):\n            obj_is_literal = False\n\n        # this call will change RELS-EXT, possibly creating it if it's\n        # missing. remove any cached info we have for that datastream.\n        if 'RELS-EXT' in self.dscache:\n            del self.dscache['RELS-EXT']\n        self._ds_list = None\n\n        return self.api.addRelationship(self.pid, self.uri, rel_uri, obj, obj_is_literal)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef modify_relationship(self, rel_uri, old_object, new_object):\n\n        if isinstance(rel_uri, URIRef):\n            rel_uri = force_text(rel_uri)\n\n        # old_object\n        obj_old_is_literal = True\n        if isinstance(old_object, DigitalObject):\n            old_object = old_object.uri\n            obj_old_is_literal = False\n        elif (isinstance(old_object, str) or isinstance(old_object, six.string_types)) \\\n          and old_object.startswith('info:fedora/'):\n            obj_old_is_literal = False\n\n        # new_object\n        obj_new_is_literal = True\n        if isinstance(new_object, DigitalObject):\n            new_object = new_object.uri\n            obj_new_is_literal = False\n        elif (isinstance(new_object, str) or isinstance(new_object, six.string_types)) \\\n          and new_object.startswith('info:fedora/'):\n            obj_new_is_literal = False\n\n        # this call will change RELS-EXT, possibly creating it if it's\n        # missing. remove any cached info we have for that datastream.\n        if 'RELS-EXT' in self.dscache:\n            del self.dscache['RELS-EXT']\n        self._ds_list = None\n\n        # attempt purge\n        if self.api.purgeRelationship(self.pid, self.uri, rel_uri, old_object,\n                                      obj_old_is_literal) is not True:\n            return False\n        # attempt add\n        elif self.api.addRelationship(self.pid, self.uri, rel_uri, new_object,\n                                      obj_new_is_literal) is not True:\n            # if addRelationship fails, rollback to old_object\n            self.api.addRelationship(self.pid, self.uri, rel_uri, old_object,\n                                     obj_old_is_literal)\n            return False\n        else:\n            return True", "response": "Modify a relationship from RELS - EXT to this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if this object subscribes to the specified content model.", "response": "def has_model(self, model):\n        \"\"\"\n        Check if this object subscribes to the specified content model.\n\n        :param model: URI for the content model, as a string\n                    (currently only accepted in ``info:fedora/foo:###`` format)\n        :rtype: boolean\n        \"\"\"\n        # TODO:\n        # - accept DigitalObject for model?\n        # - convert model pid to info:fedora/ form if not passed in that way?\n        try:\n            rels = self.rels_ext.content\n        except RequestFailed:\n            # if rels-ext can't be retrieved, confirm this object does not have a RELS-EXT\n            # (in which case, it does not subscribe to the specified content model)\n            if \"RELS-EXT\" not in self.ds_list.keys():\n                return False\n            else:\n                raise\n\n        st = (self.uriref, modelns.hasModel, URIRef(model))\n        return st in rels"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_models(self):\n        try:\n            rels = self.rels_ext.content\n        except RequestFailed:\n            # if rels-ext can't be retrieved, confirm this object does not have a RELS-EXT\n            # (in which case, it does not have any content models)\n            if \"RELS-EXT\" not in self.ds_list.keys():\n                return []\n            else:\n                raise\n\n        return list(rels.objects(self.uriref, modelns.hasModel))", "response": "Get a list of content models the object subscribes to."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates and return a dictionary of default fields to be indexed for searching.", "response": "def index_data(self):\n        '''Generate and return a dictionary of default fields to be\n        indexed for searching (e.g., in Solr).  Includes top-level\n        object properties, Content Model URIs, and Dublin Core\n        fields.\n\n        This method is intended to be customized and extended in order\n        to easily modify the fields that should be indexed for any\n        particular type of object in any project; data returned from\n        this method should be serializable as JSON (the current\n        implementation uses :mod:`django.utils.simplejson`).\n\n        This method was designed for use with :mod:`eulfedora.indexdata`.\n        '''\n        index_data = {\n            'pid': self.pid,\n            'label': self.label,\n            'owner': self.owners,\n            'state': self.state,\n            'content_model': [force_text(cm) for cm in self.get_models()],  # convert URIRefs to strings\n            }\n\n        # date created/modified won't be set unless the object actually exists in Fedora\n        # (probably the case for anything being indexed, except in tests)\n        if self.exists:\n            index_data.update({\n                # last_modified and created are configured as date type in sample solr Schema\n                # using isoformat here so they can be serialized via JSON\n                'last_modified': self.modified.isoformat(),\n                'created': self.created.isoformat(),\n                # datastream ids\n                'dsids': list(six.iterkeys(self.ds_list)),\n            })\n\n        index_data.update(self.index_data_descriptive())\n        index_data.update(self.index_data_relations())\n\n        return index_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a ContentModel object for the specified DigitalObject class.", "response": "def for_class(digobj, repo):\n        '''Generate a ContentModel object for the specified\n        :class:`DigitalObject` class.  Content model object is saved\n        in the specified repository if it doesn't already exist.'''\n        full_name = '%s.%s' % (digobj.__module__, digobj.__name__)\n        cmodels = getattr(digobj, 'CONTENT_MODELS', None)\n        if not cmodels:\n            logger.debug('%s has no content models', full_name)\n            return None\n        if len(cmodels) > 1:\n            logger.debug('%s has %d content models', full_name, len(cmodels))\n            raise ValueError(('Cannot construct ContentModel object for ' +\n                              '%s, which has %d CONTENT_MODELS (only 1 is ' +\n                              'supported)') %\n                             (full_name, len(cmodels)))\n\n        cmodel_uri = cmodels[0]\n        logger.debug('cmodel for %s is %s', full_name, cmodel_uri)\n        cmodel_obj = repo.get_object(cmodel_uri, type=ContentModel,\n                                     create=False)\n        if cmodel_obj.exists:\n            logger.debug('%s already exists', cmodel_uri)\n            return cmodel_obj\n\n        # otherwise the cmodel doesn't exist. let's create it.\n        logger.debug('creating %s from %s', cmodel_uri, full_name)\n        cmodel_obj = repo.get_object(cmodel_uri, type=ContentModel,\n                                     create=True)\n        # XXX: should this use _defined_datastreams instead?\n        for ds in digobj._local_datastreams.values():\n            ds_composite_model = cmodel_obj.ds_composite_model.content\n            type_model = ds_composite_model.get_type_model(ds.id, create=True)\n            type_model.mimetype = ds.default_mimetype\n            if ds.default_format_uri:\n                type_model.format_uri = ds.default_format_uri\n        cmodel_obj.save()\n        return cmodel_obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild the list parameters for the EC2 API.", "response": "def build_list_params(self, params, items, label):\n        \"\"\"\n        Items is a list of dictionaries or strings::\n\n            [\n                {\n                    'Protocol' : 'HTTP',\n                    'LoadBalancerPort' : '80',\n                    'InstancePort' : '80'\n                },\n                ..\n            ] etc.\n\n        or::\n\n            ['us-east-1b',...]\n        \"\"\"\n        # different from EC2 list params\n        for i in xrange(1, len(items)+1):\n            if isinstance(items[i-1], dict):\n                for k, v in items[i-1].iteritems():\n                    if isinstance(v, dict):\n                        for kk, vv in v.iteritems():\n                            params['%s.member.%d.%s.%s' % (label, i, k, kk)] = vv\n                    else:\n                        params['%s.member.%d.%s' % (label, i, k)] = v\n            elif isinstance(items[i-1], basestring):\n                params['%s.member.%d' % (label, i)] = items[i-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_auto_scaling_group(self, name, force_delete=False):\n        if(force_delete):\n            params = {'AutoScalingGroupName': name, 'ForceDelete': 'true'}\n        else:\n            params = {'AutoScalingGroupName': name}\n        return self.get_object('DeleteAutoScalingGroup', params, Request)", "response": "Deletes the specified auto scaling group."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_launch_configuration(self, launch_config):\n        params = {'ImageId': launch_config.image_id,\n                  'LaunchConfigurationName': launch_config.name,\n                  'InstanceType': launch_config.instance_type}\n        if launch_config.key_name:\n            params['KeyName'] = launch_config.key_name\n        if launch_config.user_data:\n            params['UserData'] = base64.b64encode(launch_config.user_data)\n        if launch_config.kernel_id:\n            params['KernelId'] = launch_config.kernel_id\n        if launch_config.ramdisk_id:\n            params['RamdiskId'] = launch_config.ramdisk_id\n        if launch_config.block_device_mappings:\n            self.build_list_params(params, launch_config.block_device_mappings,\n                                   'BlockDeviceMappings')\n        if launch_config.security_groups:\n            self.build_list_params(params, launch_config.security_groups,\n                                   'SecurityGroups')\n        if launch_config.instance_monitoring:\n            params['InstanceMonitoring.Enabled'] = 'true'\n        return self.get_object('CreateLaunchConfiguration', params,\n                               Request, verb='POST')", "response": "Creates a new Launch Configuration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new Scaling Policy.", "response": "def create_scaling_policy(self, scaling_policy):\n        \"\"\"\n        Creates a new Scaling Policy.\n\n        :type scaling_policy: :class:`boto.ec2.autoscale.policy.ScalingPolicy`\n        :param scaling_policy: ScalingPolicy object.\n        \"\"\"\n        params = {'AdjustmentType': scaling_policy.adjustment_type,\n                  'AutoScalingGroupName': scaling_policy.as_name,\n                  'PolicyName': scaling_policy.name,\n                  'ScalingAdjustment': scaling_policy.scaling_adjustment}\n        if scaling_policy.cooldown is not None:\n            params['Cooldown'] = scaling_policy.cooldown\n\n        return self.get_object('PutScalingPolicy', params, Request)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_groups(self, names=None, max_records=None, next_token=None):\n        params = {}\n        if max_records:\n            params['MaxRecords'] = max_records\n        if next_token:\n            params['NextToken'] = next_token\n        if names:\n            self.build_list_params(params, names, 'AutoScalingGroupNames')\n        return self.get_list('DescribeAutoScalingGroups', params,\n                             [('member', AutoScalingGroup)])", "response": "Returns a full description of each Auto Scaling group in the given names list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_all_launch_configurations(self, **kwargs):\n        params = {}\n        max_records = kwargs.get('max_records', None)\n        names = kwargs.get('names', None)\n        if max_records is not None:\n            params['MaxRecords'] = max_records\n        if names:\n            self.build_list_params(params, names, 'LaunchConfigurationNames')\n        next_token = kwargs.get('next_token')\n        if next_token:\n            params['NextToken'] = next_token\n        return self.get_list('DescribeLaunchConfigurations', params,\n                             [('member', LaunchConfiguration)])", "response": "Returns a full description of the launch configurations given the names specified."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_activities(self, autoscale_group, activity_ids=None,\n                           max_records=None, next_token=None):\n        \"\"\"\n        Get all activities for the given autoscaling group.\n\n        This action supports pagination by returning a token if there are more\n        pages to retrieve. To get the next page, call this action again with\n        the returned token as the NextToken parameter\n\n        :type autoscale_group: str or\n            :class:`boto.ec2.autoscale.group.AutoScalingGroup` object\n        :param autoscale_group: The auto scaling group to get activities on.\n\n        :type max_records: int\n        :param max_records: Maximum amount of activities to return.\n\n        :rtype: list\n        :returns: List of\n            :class:`boto.ec2.autoscale.activity.Activity` instances.\n        \"\"\"\n        name = autoscale_group\n        if isinstance(autoscale_group, AutoScalingGroup):\n            name = autoscale_group.name\n        params = {'AutoScalingGroupName' : name}\n        if max_records:\n            params['MaxRecords'] = max_records\n        if next_token:\n            params['NextToken'] = next_token\n        if activity_ids:\n            self.build_list_params(params, activity_ids, 'ActivityIds')\n        return self.get_list('DescribeScalingActivities',\n                             params, [('member', Activity)])", "response": "Get all activities for the given auto scaling group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete a previously scheduled action.", "response": "def delete_scheduled_action(self, scheduled_action_name,\n                                autoscale_group=None):\n        \"\"\"\n        Deletes a previously scheduled action.\n\n        :type scheduled_action_name: str\n        :param scheduled_action_name: The name of the action you want\n            to delete.\n\n        :type autoscale_group: str\n        :param autoscale_group: The name of the autoscale group.\n        \"\"\"\n        params = {'ScheduledActionName': scheduled_action_name}\n        if autoscale_group:\n            params['AutoScalingGroupName'] = autoscale_group\n        return self.get_status('DeleteScheduledAction', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nterminates the specified instance.", "response": "def terminate_instance(self, instance_id, decrement_capacity=True):\n        \"\"\"\n        Terminates the specified instance. The desired group size can\n        also be adjusted, if desired.\n\n        :type instance_id: str\n        :param instance_id: The ID of the instance to be terminated.\n\n        :type decrement_capability: bool\n        :param decrement_capacity: Whether to decrement the size of the\n            autoscaling group or not.\n        \"\"\"\n        params = {'InstanceId': instance_id}\n        if decrement_capacity:\n            params['ShouldDecrementDesiredCapacity'] = 'true'\n        else:\n            params['ShouldDecrementDesiredCapacity'] = 'false'\n        return self.get_object('TerminateInstanceInAutoScalingGroup', params,\n                               Activity)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_policy(self, policy_name, autoscale_group=None):\n        params = {'PolicyName': policy_name}\n        if autoscale_group:\n            params['AutoScalingGroupName'] = autoscale_group\n        return self.get_status('DeletePolicy', params)", "response": "Delete a specific policy."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a description of each Auto Scaling instance in the instance_ids list.", "response": "def get_all_autoscaling_instances(self, instance_ids=None,\n                                      max_records=None, next_token=None):\n        \"\"\"\n        Returns a description of each Auto Scaling instance in the instance_ids\n        list. If a list is not provided, the service returns the full details\n        of all instances up to a maximum of fifty.\n\n        This action supports pagination by returning a token if there are more\n        pages to retrieve. To get the next page, call this action again with\n        the returned token as the NextToken parameter.\n\n        :type instance_ids: list\n        :param instance_ids: List of Autoscaling Instance IDs which should be\n            searched for.\n\n        :type max_records: int\n        :param max_records: Maximum number of results to return.\n\n        :rtype: list\n        :returns: List of\n            :class:`boto.ec2.autoscale.activity.Activity` objects.\n        \"\"\"\n        params = {}\n        if instance_ids:\n            self.build_list_params(params, instance_ids, 'InstanceIds')\n        if max_records:\n            params['MaxRecords'] = max_records\n        if next_token:\n            params['NextToken'] = next_token\n        return self.get_list('DescribeAutoScalingInstances',\n                             params, [('member', Instance)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns descriptions of what each policy does. This action supports pagination.", "response": "def get_all_policies(self, as_group=None, policy_names=None,\n                         max_records=None, next_token=None):\n        \"\"\"\n        Returns descriptions of what each policy does. This action supports\n        pagination. If the response includes a token, there are more records\n        available. To get the additional records, repeat the request with the\n        response token as the NextToken parameter.\n\n        If no group name or list of policy names are provided, all\n        available policies are returned.\n\n        :type as_name: str\n        :param as_name: The name of the\n            :class:`boto.ec2.autoscale.group.AutoScalingGroup` to filter for.\n\n        :type names: list\n        :param names: List of policy names which should be searched for.\n\n        :type max_records: int\n        :param max_records: Maximum amount of groups to return.\n        \"\"\"\n        params = {}\n        if as_group:\n            params['AutoScalingGroupName'] = as_group\n        if policy_names:\n            self.build_list_params(params, policy_names, 'PolicyNames')\n        if max_records:\n            params['MaxRecords'] = max_records\n        if next_token:\n            params['NextToken'] = next_token\n        return self.get_list('DescribePolicies', params,\n                             [('member', ScalingPolicy)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsuspending the processes on an Auto Scaling group.", "response": "def suspend_processes(self, as_group, scaling_processes=None):\n        \"\"\"\n        Suspends Auto Scaling processes for an Auto Scaling group.\n\n        :type as_group: string\n        :param as_group: The auto scaling group to suspend processes on.\n\n        :type scaling_processes: list\n        :param scaling_processes: Processes you want to suspend. If omitted, all\n            processes will be suspended.\n        \"\"\"\n        params = {'AutoScalingGroupName': as_group}\n        if scaling_processes:\n            self.build_list_params(params, scaling_processes, 'ScalingProcesses')\n        return self.get_status('SuspendProcesses', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resume_processes(self, as_group, scaling_processes=None):\n        params = {'AutoScalingGroupName': as_group}\n\n        if scaling_processes:\n            self.build_list_params(params, scaling_processes, 'ScalingProcesses')\n        return self.get_status('ResumeProcesses', params)", "response": "Resumes all processes on an Auto Scaling group."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_scheduled_group_action(self, as_group, name, time,\n                                      desired_capacity=None,\n                                      min_size=None, max_size=None):\n        \"\"\"\n        Creates a scheduled scaling action for a Auto Scaling group. If you\n        leave a parameter unspecified, the corresponding value remains\n        unchanged in the affected Auto Scaling group.\n\n        :type as_group: string\n        :param as_group: The auto scaling group to get activities on.\n\n        :type name: string\n        :param name: Scheduled action name.\n\n        :type time: datetime.datetime\n        :param time: The time for this action to start.\n\n        :type desired_capacity: int\n        :param desired_capacity: The number of EC2 instances that should\n            be running in this group.\n\n        :type min_size: int\n        :param min_size: The minimum size for the new auto scaling group.\n\n        :type max_size: int\n        :param max_size: The minimum size for the new auto scaling group.\n        \"\"\"\n        params = {'AutoScalingGroupName': as_group,\n                  'ScheduledActionName': name,\n                  'Time': time.isoformat()}\n        if desired_capacity is not None:\n            params['DesiredCapacity'] = desired_capacity\n        if min_size is not None:\n            params['MinSize'] = min_size\n        if max_size is not None:\n            params['MaxSize'] = max_size\n        return self.get_status('PutScheduledUpdateGroupAction', params)", "response": "Creates a scheduled action for an Auto Scaling group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisable monitoring of group metrics for the Auto Scaling group .", "response": "def disable_metrics_collection(self, as_group, metrics=None):\n        \"\"\"\n        Disables monitoring of group metrics for the Auto Scaling group\n        specified in AutoScalingGroupName. You can specify the list of affected\n        metrics with the Metrics parameter.\n        \"\"\"\n        params = {'AutoScalingGroupName': as_group}\n\n        if metrics:\n            self.build_list_params(params, metrics, 'Metrics')\n        return self.get_status('DisableMetricsCollection', params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enable_metrics_collection(self, as_group, granularity, metrics=None):\n        params = {'AutoScalingGroupName': as_group,\n                  'Granularity': granularity}\n        if metrics:\n            self.build_list_params(params, metrics, 'Metrics')\n        return self.get_status('EnableMetricsCollection', params)", "response": "Enables monitoring of group metrics for the Auto Scaling group\n        specified in AutoScalingGroupName."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_instance_health(self, instance_id, health_status,\n                            should_respect_grace_period=True):\n        \"\"\"\n        Explicitly set the health status of an instance.\n\n        :type instance_id: str\n        :param instance_id: The identifier of the EC2 instance.\n\n        :type health_status: str\n        :param health_status: The health status of the instance.\n            \"Healthy\" means that the instance is healthy and should remain\n            in service. \"Unhealthy\" means that the instance is unhealthy.\n            Auto Scaling should terminate and replace it.\n\n        :type should_respect_grace_period: bool\n        :param should_respect_grace_period: If True, this call should\n            respect the grace period associated with the group.\n        \"\"\"\n        params = {'InstanceId': instance_id,\n                  'HealthStatus': health_status}\n        if should_respect_grace_period:\n            params['ShouldRespectGracePeriod'] = 'true'\n        else:\n            params['ShouldRespectGracePeriod'] = 'false'\n        return self.get_status('SetInstanceHealth', params)", "response": "Explicitly set the health status of an instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist the Auto Scaling group tags. This action supports pagination by returning a token if there are more pages to retrieve. To get the next page, call this action again with the returned token as the NextToken parameter. :type filters: dict :param filters: The value of the filter type used to identify the tags to be returned. NOT IMPLEMENTED YET. :type max_records: int :param max_records: Maximum number of tags to return. :rtype: list :returns: List of :class:`boto.ec2.autoscale.tag.Tag` instances.", "response": "def get_all_tags(self, filters=None, max_records=None, next_token=None):\n        \"\"\"\n        Lists the Auto Scaling group tags.\n\n        This action supports pagination by returning a token if there are more\n        pages to retrieve. To get the next page, call this action again with             the returned token as the NextToken parameter.\n\n        :type filters: dict\n        :param filters: The value of the filter type used to identify\n            the tags to be returned.  NOT IMPLEMENTED YET.\n\n        :type max_records: int\n        :param max_records: Maximum number of tags to return.\n\n        :rtype: list\n        :returns: List of :class:`boto.ec2.autoscale.tag.Tag`\n            instances.\n        \"\"\"\n        params = {}\n        if max_records:\n            params['MaxRecords'] = max_records\n        if next_token:\n            params['NextToken'] = next_token\n        return self.get_list('DescribeTags', params,\n                             [('member', Tag)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_or_update_tags(self, tags):\n        params = {}\n        for i, tag in enumerate(tags):\n            tag.build_params(params, i+1)\n        return self.get_status('CreateOrUpdateTags', params, verb='POST')", "response": "Creates new tags or updates existing tags for an Auto Scaling group."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of all available regions for the SQS service.", "response": "def regions():\n    \"\"\"\n    Get all available regions for the SQS service.\n        \n    :rtype: list\n    :return: A list of :class:`boto.ec2.regioninfo.RegionInfo`\n    \"\"\"\n    return [SQSRegionInfo(name='us-east-1',\n                          endpoint='sqs.us-east-1.amazonaws.com'),\n            SQSRegionInfo(name='eu-west-1',\n                          endpoint='sqs.eu-west-1.amazonaws.com'),\n            SQSRegionInfo(name='us-west-1',\n                          endpoint='sqs.us-west-1.amazonaws.com'),\n            SQSRegionInfo(name='us-west-2',\n                          endpoint='sqs.us-west-2.amazonaws.com'),\n            SQSRegionInfo(name='sa-east-1',\n                          endpoint='sqs.sa-east-1.amazonaws.com'),\n            SQSRegionInfo(name='ap-northeast-1',\n                          endpoint='sqs.ap-northeast-1.amazonaws.com'),\n            SQSRegionInfo(name='ap-southeast-1',\n                          endpoint='sqs.ap-southeast-1.amazonaws.com')\n            ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open_read(self, headers=None, query_args='',\n                  override_num_retries=None, response_headers=None):\n        \"\"\"\n        Open this key for reading\n\n        :type headers: dict\n        :param headers: Headers to pass in the web request\n\n        :type query_args: string\n        :param query_args: Arguments to pass in the query string (ie, 'torrent')\n\n        :type override_num_retries: int\n        :param override_num_retries: If not None will override configured\n                                     num_retries parameter for underlying GET.\n\n        :type response_headers: dict\n        :param response_headers: A dictionary containing HTTP headers/values\n                                 that will override any headers associated with\n                                 the stored object in the response.\n                                 See http://goo.gl/EWOPb for details.\n        \"\"\"\n        if self.resp == None:\n            self.mode = 'r'\n\n            provider = self.bucket.connection.provider\n            self.resp = self.bucket.connection.make_request(\n                'GET', self.bucket.name, self.name, headers,\n                query_args=query_args,\n                override_num_retries=override_num_retries)\n            if self.resp.status < 199 or self.resp.status > 299:\n                body = self.resp.read()\n                raise provider.storage_response_error(self.resp.status,\n                                                      self.resp.reason, body)\n            response_headers = self.resp.msg\n            self.metadata = boto.utils.get_aws_metadata(response_headers,\n                                                        provider)\n            for name,value in response_headers.items():\n                # To get correct size for Range GETs, use Content-Range\n                # header if one was returned. If not, use Content-Length\n                # header.\n                if (name.lower() == 'content-length' and\n                    'Content-Range' not in response_headers):\n                    self.size = int(value)\n                elif name.lower() == 'content-range':\n                    end_range = re.sub('.*/(.*)', '\\\\1', value)\n                    self.size = int(end_range)\n                elif name.lower() == 'etag':\n                    self.etag = value\n                elif name.lower() == 'content-type':\n                    self.content_type = value\n                elif name.lower() == 'content-encoding':\n                    self.content_encoding = value\n                elif name.lower() == 'last-modified':\n                    self.last_modified = value\n                elif name.lower() == 'cache-control':\n                    self.cache_control = value\n            self.handle_version_headers(self.resp)\n            self.handle_encryption_headers(self.resp)", "response": "Open this key for reading."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef next(self):\n        self.open_read()\n        data = self.resp.read(self.BufferSize)\n        if not data:\n            self.close()\n            raise StopIteration\n        return data", "response": "Returns the next key in the response."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef change_storage_class(self, new_storage_class, dst_bucket=None):\n        if new_storage_class == 'STANDARD':\n            return self.copy(self.bucket.name, self.name,\n                             reduced_redundancy=False, preserve_acl=True)\n        elif new_storage_class == 'REDUCED_REDUNDANCY':\n            return self.copy(self.bucket.name, self.name,\n                             reduced_redundancy=True, preserve_acl=True)\n        else:\n            raise BotoClientError('Invalid storage class: %s' %\n                                  new_storage_class)", "response": "Change the storage class of an existing key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self, dst_bucket, dst_key, metadata=None,\n             reduced_redundancy=False, preserve_acl=False,\n             encrypt_key=False):\n        \"\"\"\n        Copy this Key to another bucket.\n\n        :type dst_bucket: string\n        :param dst_bucket: The name of the destination bucket\n\n        :type dst_key: string\n        :param dst_key: The name of the destination key\n\n        :type metadata: dict\n        :param metadata: Metadata to be associated with new key.\n                         If metadata is supplied, it will replace the\n                         metadata of the source key being copied.\n                         If no metadata is supplied, the source key's\n                         metadata will be copied to the new key.\n\n        :type reduced_redundancy: bool\n        :param reduced_redundancy: If True, this will force the storage\n                                   class of the new Key to be\n                                   REDUCED_REDUNDANCY regardless of the\n                                   storage class of the key being copied.\n                                   The Reduced Redundancy Storage (RRS)\n                                   feature of S3, provides lower\n                                   redundancy at lower storage cost.\n\n        :type preserve_acl: bool\n        :param preserve_acl: If True, the ACL from the source key\n                             will be copied to the destination\n                             key.  If False, the destination key\n                             will have the default ACL.\n                             Note that preserving the ACL in the\n                             new key object will require two\n                             additional API calls to S3, one to\n                             retrieve the current ACL and one to\n                             set that ACL on the new object.  If\n                             you don't care about the ACL, a value\n                             of False will be significantly more\n                             efficient.\n\n        :type encrypt_key: bool\n        :param encrypt_key: If True, the new copy of the object will\n                            be encrypted on the server-side by S3 and\n                            will be stored in an encrypted form while\n                            at rest in S3.\n                            \n        :rtype: :class:`boto.s3.key.Key` or subclass\n        :returns: An instance of the newly created key object\n        \"\"\"\n        dst_bucket = self.bucket.connection.lookup(dst_bucket)\n        if reduced_redundancy:\n            storage_class = 'REDUCED_REDUNDANCY'\n        else:\n            storage_class = self.storage_class\n        return dst_bucket.copy_key(dst_key, self.bucket.name,\n                                   self.name, metadata,\n                                   storage_class=storage_class,\n                                   preserve_acl=preserve_acl,\n                                   encrypt_key=encrypt_key)", "response": "Copy this Key to another bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self):\n        return self.bucket.delete_key(self.name, version_id=self.version_id)", "response": "Delete this key from S3"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_url(self, expires_in, method='GET', headers=None,\n                     query_auth=True, force_http=False, response_headers=None,\n                     expires_in_absolute=False):\n        \"\"\"\n        Generate a URL to access this key.\n\n        :type expires_in: int\n        :param expires_in: How long the url is valid for, in seconds\n\n        :type method: string\n        :param method: The method to use for retrieving the file\n                       (default is GET)\n\n        :type headers: dict\n        :param headers: Any headers to pass along in the request\n\n        :type query_auth: bool\n        :param query_auth:\n\n        :rtype: string\n        :return: The URL to access the key\n        \"\"\"\n        return self.bucket.connection.generate_url(expires_in, method,\n                                                   self.bucket.name, self.name,\n                                                   headers, query_auth,\n                                                   force_http,\n                                                   response_headers,\n                                                   expires_in_absolute)", "response": "Generate a URL to access this key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupload a file to a key into an S3 bucket.", "response": "def send_file(self, fp, headers=None, cb=None, num_cb=10,\n                  query_args=None, chunked_transfer=False, size=None):\n        \"\"\"\n        Upload a file to a key into a bucket on S3.\n\n        :type fp: file\n        :param fp: The file pointer to upload. The file pointer must point\n                   point at the offset from which you wish to upload.\n                   ie. if uploading the full file, it should point at the\n                   start of the file. Normally when a file is opened for\n                   reading, the fp will point at the first byte. See the\n                   bytes parameter below for more info.\n\n        :type headers: dict\n        :param headers: The headers to pass along with the PUT request\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type num_cb: int\n        :param num_cb: (optional) If a callback is specified with the cb\n                       parameter this parameter determines the granularity\n                       of the callback by defining the maximum number of\n                       times the callback will be called during the file\n                       transfer. Providing a negative integer will cause\n                       your callback to be called with each buffer read.\n\n        :type size: int\n        :param size: (optional) The Maximum number of bytes to read from\n                      the file pointer (fp). This is useful when uploading\n                      a file in multiple parts where you are splitting the\n                      file up into different ranges to be uploaded. If not\n                      specified, the default behaviour is to read all bytes\n                      from the file pointer. Less bytes may be available.\n        \"\"\"\n        provider = self.bucket.connection.provider\n        try:\n            spos = fp.tell()\n        except IOError:\n            spos = None\n            self.read_from_stream = False\n\n        def sender(http_conn, method, path, data, headers):\n            # This function is called repeatedly for temporary retries\n            # so we must be sure the file pointer is pointing at the\n            # start of the data.\n            if spos is not None and spos != fp.tell():\n                fp.seek(spos)\n            elif spos is None and self.read_from_stream:\n                # if seek is not supported, and we've read from this\n                # stream already, then we need to abort retries to \n                # avoid setting bad data.\n                raise provider.storage_data_error(\n                    'Cannot retry failed request. fp does not support seeking.')\n\n            http_conn.putrequest(method, path)\n            for key in headers:\n                http_conn.putheader(key, headers[key])\n            http_conn.endheaders()\n            if chunked_transfer and not self.base64md5:\n                # MD5 for the stream has to be calculated on the fly.\n                m = md5()\n            else:\n                m = None\n\n            save_debug = self.bucket.connection.debug\n            self.bucket.connection.debug = 0\n            # If the debuglevel < 3 we don't want to show connection\n            # payload, so turn off HTTP connection-level debug output (to\n            # be restored below).\n            # Use the getattr approach to allow this to work in AppEngine.\n            if getattr(http_conn, 'debuglevel', 0) < 3:\n                http_conn.set_debuglevel(0)\n\n            data_len = 0\n            if cb:\n                if size:\n                    cb_size = size\n                elif self.size:\n                    cb_size = self.size\n                else:\n                    cb_size = 0\n                if chunked_transfer and cb_size == 0:\n                    # For chunked Transfer, we call the cb for every 1MB\n                    # of data transferred, except when we know size.\n                    cb_count = (1024 * 1024)/self.BufferSize\n                elif num_cb > 1:\n                    cb_count = int(math.ceil(cb_size/self.BufferSize/(num_cb-1.0)))\n                elif num_cb < 0:\n                    cb_count = -1\n                else:\n                    cb_count = 0\n                i = 0\n                cb(data_len, cb_size)\n\n            bytes_togo = size\n            if bytes_togo and bytes_togo < self.BufferSize:\n                chunk = fp.read(bytes_togo)\n            else:\n                chunk = fp.read(self.BufferSize)\n            if spos is None:\n                # read at least something from a non-seekable fp.\n                self.read_from_stream = True\n            while chunk:\n                chunk_len = len(chunk)\n                data_len += chunk_len\n                if chunked_transfer:\n                    http_conn.send('%x;\\r\\n' % chunk_len)\n                    http_conn.send(chunk)\n                    http_conn.send('\\r\\n')\n                else:\n                    http_conn.send(chunk)\n                if m:\n                    m.update(chunk)\n                if bytes_togo:\n                    bytes_togo -= chunk_len\n                    if bytes_togo <= 0:\n                        break\n                if cb:\n                    i += 1\n                    if i == cb_count or cb_count == -1:\n                        cb(data_len, cb_size)\n                        i = 0\n                if bytes_togo and bytes_togo < self.BufferSize:\n                    chunk = fp.read(bytes_togo)\n                else:\n                    chunk = fp.read(self.BufferSize)\n\n            self.size = data_len\n            if chunked_transfer:\n                http_conn.send('0\\r\\n')\n                if m:\n                    # Use the chunked trailer for the digest\n                    hd = m.hexdigest()\n                    self.md5, self.base64md5 = self.get_md5_from_hexdigest(hd)\n                    # http_conn.send(\"Content-MD5: %s\\r\\n\" % self.base64md5)\n                http_conn.send('\\r\\n')\n\n            if cb and (cb_count <= 1 or i > 0) and data_len > 0:\n                cb(data_len, cb_size)\n\n            response = http_conn.getresponse()\n            body = response.read()\n            http_conn.set_debuglevel(save_debug)\n            self.bucket.connection.debug = save_debug\n            if ((response.status == 500 or response.status == 503 or\n                    response.getheader('location')) and not chunked_transfer):\n                # we'll try again.\n                return response\n            elif response.status >= 200 and response.status <= 299:\n                self.etag = response.getheader('etag')\n                if self.etag != '\"%s\"'  % self.md5:\n                    raise provider.storage_data_error(\n                        'ETag from S3 did not match computed MD5')\n                return response\n            else:\n                raise provider.storage_response_error(\n                    response.status, response.reason, body)\n\n        if not headers:\n            headers = {}\n        else:\n            headers = headers.copy()\n        headers['User-Agent'] = UserAgent\n        if self.storage_class != 'STANDARD':\n            headers[provider.storage_class_header] = self.storage_class\n        if headers.has_key('Content-Encoding'):\n            self.content_encoding = headers['Content-Encoding']\n        if headers.has_key('Content-Type'):\n            # Some use cases need to suppress sending of the Content-Type \n            # header and depend on the receiving server to set the content\n            # type. This can be achieved by setting headers['Content-Type'] \n            # to None when calling this method.\n            if headers['Content-Type']:\n                self.content_type = headers['Content-Type']\n            else:\n                # Delete null Content-Type value to skip sending that header.\n                del headers['Content-Type']\n        elif self.path:\n            self.content_type = mimetypes.guess_type(self.path)[0]\n            if self.content_type == None:\n                self.content_type = self.DefaultContentType\n            headers['Content-Type'] = self.content_type\n        else:\n            headers['Content-Type'] = self.content_type\n        if self.base64md5:\n            headers['Content-MD5'] = self.base64md5\n        if chunked_transfer:\n            headers['Transfer-Encoding'] = 'chunked'\n            #if not self.base64md5:\n            #    headers['Trailer'] = \"Content-MD5\"\n        else:\n            headers['Content-Length'] = str(self.size)\n        headers['Expect'] = '100-Continue'\n        headers = boto.utils.merge_meta(headers, self.metadata, provider)\n        resp = self.bucket.connection.make_request('PUT', self.bucket.name,\n                                                   self.name, headers,\n                                                   sender=sender,\n                                                   query_args=query_args)\n        self.handle_version_headers(resp, force=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute the MD5 hash of the file - pointer to the file being uploaded.", "response": "def compute_md5(self, fp, size=None):\n        \"\"\"\n        :type fp: file\n        :param fp: File pointer to the file to MD5 hash.  The file pointer\n                   will be reset to the same position before the\n                   method returns.\n\n        :type size: int\n        :param size: (optional) The Maximum number of bytes to read from\n                     the file pointer (fp). This is useful when uploading\n                     a file in multiple parts where the file is being\n                     split inplace into different parts. Less bytes may\n                     be available.\n\n        :rtype: tuple\n        :return: A tuple containing the hex digest version of the MD5 hash\n                 as the first element and the base64 encoded version of the\n                 plain digest as the second element.\n        \"\"\"\n        tup = compute_md5(fp, size=size)\n        # Returned values are MD5 hash, base64 encoded MD5 hash, and data size.\n        # The internal implementation of compute_md5() needs to return the \n        # data size but we don't want to return that value to the external\n        # caller because it changes the class interface (i.e. it might        \n        # break some code) so we consume the third tuple value here and \n        # return the remainder of the tuple to the caller, thereby preserving \n        # the existing interface.\n        self.size = tup[2]\n        return tup[0:2]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_contents_from_stream(self, fp, headers=None, replace=True,\n                                 cb=None, num_cb=10, policy=None,\n                                 reduced_redundancy=False, query_args=None,\n                                 size=None):\n        \"\"\"\n        Store an object using the name of the Key object as the key in\n        cloud and the contents of the data stream pointed to by 'fp' as\n        the contents.\n        The stream object is not seekable and total size is not known.\n        This has the implication that we can't specify the Content-Size and\n        Content-MD5 in the header. So for huge uploads, the delay in calculating\n        MD5 is avoided but with a penalty of inability to verify the integrity\n        of the uploaded data.\n\n        :type fp: file\n        :param fp: the file whose contents are to be uploaded\n\n        :type headers: dict\n        :param headers: additional HTTP headers to be sent with the PUT request.\n\n        :type replace: bool\n        :param replace: If this parameter is False, the method will first check\n            to see if an object exists in the bucket with the same key. If it\n            does, it won't overwrite it. The default value is True which will\n            overwrite the object.\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n            progress on the upload. The callback should accept two integer\n            parameters, the first representing the number of bytes that have\n            been successfully transmitted to GS and the second representing the\n            total number of bytes that need to be transmitted.\n\n        :type num_cb: int\n        :param num_cb: (optional) If a callback is specified with the cb\n            parameter, this parameter determines the granularity of the callback\n            by defining the maximum number of times the callback will be called\n            during the file transfer.\n\n        :type policy: :class:`boto.gs.acl.CannedACLStrings`\n        :param policy: A canned ACL policy that will be applied to the new key\n            in GS.\n\n        :type reduced_redundancy: bool\n        :param reduced_redundancy: If True, this will set the storage\n                                   class of the new Key to be\n                                   REDUCED_REDUNDANCY. The Reduced Redundancy\n                                   Storage (RRS) feature of S3, provides lower\n                                   redundancy at lower storage cost.\n        :type size: int\n        :param size: (optional) The Maximum number of bytes to read from\n                      the file pointer (fp). This is useful when uploading\n                      a file in multiple parts where you are splitting the\n                      file up into different ranges to be uploaded. If not\n                      specified, the default behaviour is to read all bytes\n                      from the file pointer. Less bytes may be available.\n        \"\"\"\n\n        provider = self.bucket.connection.provider\n        if not provider.supports_chunked_transfer():\n            raise BotoClientError('%s does not support chunked transfer'\n                % provider.get_provider_name())\n\n        # Name of the Object should be specified explicitly for Streams.\n        if not self.name or self.name == '':\n            raise BotoClientError('Cannot determine the destination '\n                                'object name for the given stream')\n\n        if headers is None:\n            headers = {}\n        if policy:\n            headers[provider.acl_header] = policy\n\n        if reduced_redundancy:\n            self.storage_class = 'REDUCED_REDUNDANCY'\n            if provider.storage_class_header:\n                headers[provider.storage_class_header] = self.storage_class\n\n        if self.bucket != None:\n            if not replace:\n                if self.bucket.lookup(self.name):\n                    return\n            self.send_file(fp, headers, cb, num_cb, query_args,\n                           chunked_transfer=True, size=size)", "response": "This method will upload the contents of a file to the key in the object store. The file object is uploaded to the GS and the headers will be sent to the PUT request. The headers will be sent to the PUT request. The size parameter will be set to the size of the file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstoring an object in S3 using the name of the Key object as the key in S3 and the contents of the file pointed to by 'fp' as the contents. :type fp: file :param fp: the file whose contents to upload :type headers: dict :param headers: Additional HTTP headers that will be sent with the PUT request. :type replace: bool :param replace: If this parameter is False, the method will first check to see if an object exists in the bucket with the same key. If it does, it won't overwrite it. The default value is True which will overwrite the object. :type cb: function :param cb: a callback function that will be called to report progress on the upload. The callback should accept two integer parameters, the first representing the number of bytes that have been successfully transmitted to S3 and the second representing the size of the to be transmitted object. :type cb: int :param num_cb: (optional) If a callback is specified with the cb parameter this parameter determines the granularity of the callback by defining the maximum number of times the callback will be called during the file transfer. :type policy: :class:`boto.s3.acl.CannedACLStrings` :param policy: A canned ACL policy that will be applied to the new key in S3. :type md5: A tuple containing the hexdigest version of the MD5 checksum of the file as the first element and the Base64-encoded version of the plain checksum as the second element. This is the same format returned by the compute_md5 method. :param md5: If you need to compute the MD5 for any reason prior to upload, it's silly to have to do it twice so this param, if present, will be used as the MD5 values of the file. Otherwise, the checksum will be computed. :type reduced_redundancy: bool :param reduced_redundancy: If True, this will set the storage class of the new Key to be REDUCED_REDUNDANCY. The Reduced Redundancy Storage (RRS) feature of S3, provides lower redundancy at lower storage cost. :type encrypt_key: bool :param encrypt_key: If True, the new copy of the object will be encrypted on the server-side by S3 and will be stored in an encrypted form while at rest in S3. :type size: int :param size: (optional) The Maximum number of bytes to read from the file pointer (fp). This is useful when uploading a file in multiple parts where you are splitting the file up into different ranges to be uploaded. If not specified, the default behaviour is to read all bytes from the file pointer. Less bytes may be available.", "response": "def set_contents_from_file(self, fp, headers=None, replace=True,\n                               cb=None, num_cb=10, policy=None, md5=None,\n                               reduced_redundancy=False, query_args=None,\n                               encrypt_key=False, size=None):\n        \"\"\"\n        Store an object in S3 using the name of the Key object as the\n        key in S3 and the contents of the file pointed to by 'fp' as the\n        contents.\n\n        :type fp: file\n        :param fp: the file whose contents to upload\n\n        :type headers: dict\n        :param headers: Additional HTTP headers that will be sent with\n                        the PUT request.\n\n        :type replace: bool\n        :param replace: If this parameter is False, the method\n                        will first check to see if an object exists in the\n                        bucket with the same key.  If it does, it won't\n                        overwrite it.  The default value is True which will\n                        overwrite the object.\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with the cb\n                       parameter this parameter determines the granularity\n                       of the callback by defining the maximum number of\n                       times the callback will be called during the\n                       file transfer.\n\n        :type policy: :class:`boto.s3.acl.CannedACLStrings`\n        :param policy: A canned ACL policy that will be applied to the\n                       new key in S3.\n\n        :type md5: A tuple containing the hexdigest version of the MD5\n                   checksum of the file as the first element and the\n                   Base64-encoded version of the plain checksum as the\n                   second element.  This is the same format returned by\n                   the compute_md5 method.\n        :param md5: If you need to compute the MD5 for any reason prior\n                    to upload, it's silly to have to do it twice so this\n                    param, if present, will be used as the MD5 values of\n                    the file.  Otherwise, the checksum will be computed.\n\n        :type reduced_redundancy: bool\n        :param reduced_redundancy: If True, this will set the storage\n                                   class of the new Key to be\n                                   REDUCED_REDUNDANCY. The Reduced Redundancy\n                                   Storage (RRS) feature of S3, provides lower\n                                   redundancy at lower storage cost.\n\n        :type encrypt_key: bool\n        :param encrypt_key: If True, the new copy of the object will\n                            be encrypted on the server-side by S3 and\n                            will be stored in an encrypted form while\n                            at rest in S3.\n\n        :type size: int\n        :param size: (optional) The Maximum number of bytes to read from\n                      the file pointer (fp). This is useful when uploading\n                      a file in multiple parts where you are splitting the\n                      file up into different ranges to be uploaded. If not\n                      specified, the default behaviour is to read all bytes\n                      from the file pointer. Less bytes may be available.\n        \"\"\"\n        provider = self.bucket.connection.provider\n        headers = headers or {}\n        if policy:\n            headers[provider.acl_header] = policy\n        if encrypt_key:\n            headers[provider.server_side_encryption_header] = 'AES256'\n\n        if reduced_redundancy:\n            self.storage_class = 'REDUCED_REDUNDANCY'\n            if provider.storage_class_header:\n                headers[provider.storage_class_header] = self.storage_class\n                # TODO - What if provider doesn't support reduced reduncancy?\n                # What if different providers provide different classes?\n        if hasattr(fp, 'name'):\n            self.path = fp.name\n\n        if self.bucket != None:\n            if not md5 and provider.supports_chunked_transfer():\n                # defer md5 calculation to on the fly and\n                # we don't know anything about size yet.\n                chunked_transfer = True\n                self.size = None\n            else:\n                chunked_transfer = False\n                if not md5:\n                    # compute_md5() and also set self.size to actual\n                    # size of the bytes read computing the md5.\n                    md5 = self.compute_md5(fp, size)\n                    # adjust size if required\n                    size = self.size\n                elif size:\n                    self.size = size\n                else:\n                    # If md5 is provided, still need to size so\n                    # calculate based on bytes to end of content\n                    spos = fp.tell()\n                    fp.seek(0, os.SEEK_END)\n                    self.size = fp.tell() - spos\n                    fp.seek(spos)\n                    size = self.size\n                self.md5 = md5[0]\n                self.base64md5 = md5[1]\n\n            if self.name == None:\n                self.name = self.md5\n            if not replace:\n                if self.bucket.lookup(self.name):\n                    return\n\n            self.send_file(fp, headers=headers, cb=cb, num_cb=num_cb,\n                           query_args=query_args, chunked_transfer=chunked_transfer,\n                           size=size)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_contents_from_filename(self, filename, headers=None, replace=True,\n                                   cb=None, num_cb=10, policy=None, md5=None,\n                                   reduced_redundancy=False,\n                                   encrypt_key=False):\n        \"\"\"\n        Store an object in S3 using the name of the Key object as the\n        key in S3 and the contents of the file named by 'filename'.\n        See set_contents_from_file method for details about the\n        parameters.\n\n        :type filename: string\n        :param filename: The name of the file that you want to put onto S3\n\n        :type headers: dict\n        :param headers: Additional headers to pass along with the\n                        request to AWS.\n\n        :type replace: bool\n        :param replace: If True, replaces the contents of the file\n                        if it already exists.\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with\n                       the cb parameter this parameter determines the\n                       granularity of the callback by defining\n                       the maximum number of times the callback will\n                       be called during the file transfer.\n\n        :type policy: :class:`boto.s3.acl.CannedACLStrings`\n        :param policy: A canned ACL policy that will be applied to the\n                       new key in S3.\n\n        :type md5: A tuple containing the hexdigest version of the MD5\n                   checksum of the file as the first element and the\n                   Base64-encoded version of the plain checksum as the\n                   second element.  This is the same format returned by\n                   the compute_md5 method.\n        :param md5: If you need to compute the MD5 for any reason prior\n                    to upload, it's silly to have to do it twice so this\n                    param, if present, will be used as the MD5 values\n                    of the file.  Otherwise, the checksum will be computed.\n\n        :type reduced_redundancy: bool\n        :param reduced_redundancy: If True, this will set the storage\n                                   class of the new Key to be\n                                   REDUCED_REDUNDANCY. The Reduced Redundancy\n                                   Storage (RRS) feature of S3, provides lower\n                                   redundancy at lower storage cost.\n        :type encrypt_key: bool\n        :param encrypt_key: If True, the new copy of the object will\n                            be encrypted on the server-side by S3 and\n                            will be stored in an encrypted form while\n                            at rest in S3.\n        \"\"\"\n        fp = open(filename, 'rb')\n        self.set_contents_from_file(fp, headers, replace, cb, num_cb,\n                                    policy, md5, reduced_redundancy,\n                                    encrypt_key=encrypt_key)\n        fp.close()", "response": "This method will store the contents of a file in S3 and store it in the Key object store."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a file from an S3 Key :type fp: file :param fp: File pointer to put the data into :type headers: string :param: headers to send when retrieving the files :type cb: function :param cb: a callback function that will be called to report progress on the upload. The callback should accept two integer parameters, the first representing the number of bytes that have been successfully transmitted to S3 and the second representing the size of the to be transmitted object. :type cb: int :param num_cb: (optional) If a callback is specified with the cb parameter this parameter determines the granularity of the callback by defining the maximum number of times the callback will be called during the file transfer. :type torrent: bool :param torrent: Flag for whether to get a torrent for the file :type override_num_retries: int :param override_num_retries: If not None will override configured num_retries parameter for underlying GET. :type response_headers: dict :param response_headers: A dictionary containing HTTP headers/values that will override any headers associated with the stored object in the response. See http://goo.gl/EWOPb for details.", "response": "def get_file(self, fp, headers=None, cb=None, num_cb=10,\n                 torrent=False, version_id=None, override_num_retries=None,\n                 response_headers=None):\n        \"\"\"\n        Retrieves a file from an S3 Key\n\n        :type fp: file\n        :param fp: File pointer to put the data into\n\n        :type headers: string\n        :param: headers to send when retrieving the files\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with\n                       the cb parameter this parameter determines the\n                       granularity of the callback by defining\n                       the maximum number of times the callback will\n                       be called during the file transfer.\n\n        :type torrent: bool\n        :param torrent: Flag for whether to get a torrent for the file\n\n        :type override_num_retries: int\n        :param override_num_retries: If not None will override configured\n                                     num_retries parameter for underlying GET.\n\n        :type response_headers: dict\n        :param response_headers: A dictionary containing HTTP headers/values\n                                 that will override any headers associated with\n                                 the stored object in the response.\n                                 See http://goo.gl/EWOPb for details.\n        \"\"\"\n        save_debug = self.bucket.connection.debug\n        if self.bucket.connection.debug == 1:\n            self.bucket.connection.debug = 0\n\n        query_args = []\n        if torrent:\n            query_args.append('torrent')\n            m = None\n        else:\n            m = md5()\n        # If a version_id is passed in, use that.  If not, check to see\n        # if the Key object has an explicit version_id and, if so, use that.\n        # Otherwise, don't pass a version_id query param.\n        if version_id is None:\n            version_id = self.version_id\n        if version_id:\n            query_args.append('versionId=%s' % version_id)\n        if response_headers:\n            for key in response_headers:\n                query_args.append('%s=%s' % (key, urllib.quote(response_headers[key])))\n        query_args = '&'.join(query_args)\n        self.open('r', headers, query_args=query_args,\n                  override_num_retries=override_num_retries)\n\n        data_len = 0\n        if cb:\n            if self.size is None:\n                cb_size = 0\n            else:\n                cb_size = self.size\n            if self.size is None and num_cb != -1:\n                # If size is not available due to chunked transfer for example,\n                # we'll call the cb for every 1MB of data transferred.\n                cb_count = (1024 * 1024)/self.BufferSize\n            elif num_cb > 1:\n                cb_count = int(math.ceil(cb_size/self.BufferSize/(num_cb-1.0)))\n            elif num_cb < 0:\n                cb_count = -1\n            else:\n                cb_count = 0\n            i = 0\n            cb(data_len, cb_size)\n        for bytes in self:\n            fp.write(bytes)\n            data_len += len(bytes)\n            if m:\n                m.update(bytes)\n            if cb:\n                if cb_size > 0 and data_len >= cb_size:\n                    break\n                i += 1\n                if i == cb_count or cb_count == -1:\n                    cb(data_len, cb_size)\n                    i = 0\n        if cb and (cb_count <= 1 or i > 0) and data_len > 0:\n            cb(data_len, cb_size)\n        if m:\n            self.md5 = m.hexdigest()\n        if self.size is None and not torrent and not headers.has_key(\"Range\"):\n            self.size = data_len\n        self.close()\n        self.bucket.connection.debug = save_debug"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_torrent_file(self, fp, headers=None, cb=None, num_cb=10):\n        return self.get_file(fp, headers, cb, num_cb, torrent=True)", "response": "Get a torrent file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_contents_to_file(self, fp, headers=None,\n                             cb=None, num_cb=10,\n                             torrent=False,\n                             version_id=None,\n                             res_download_handler=None,\n                             response_headers=None):\n        \"\"\"\n        Retrieve an object from S3 using the name of the Key object as the\n        key in S3.  Write the contents of the object to the file pointed\n        to by 'fp'.\n\n        :type fp: File -like object\n        :param fp:\n\n        :type headers: dict\n        :param headers: additional HTTP headers that will be sent with\n                        the GET request.\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with\n                       the cb parameter this parameter determines the\n                       granularity of the callback by defining\n                       the maximum number of times the callback will\n                       be called during the file transfer.\n\n        :type torrent: bool\n        :param torrent: If True, returns the contents of a torrent\n                        file as a string.\n\n        :type res_upload_handler: ResumableDownloadHandler\n        :param res_download_handler: If provided, this handler will\n                                     perform the download.\n\n        :type response_headers: dict\n        :param response_headers: A dictionary containing HTTP headers/values\n                                 that will override any headers associated with\n                                 the stored object in the response.\n                                 See http://goo.gl/EWOPb for details.\n        \"\"\"\n        if self.bucket != None:\n            if res_download_handler:\n                res_download_handler.get_file(self, fp, headers, cb, num_cb,\n                                              torrent=torrent,\n                                              version_id=version_id)\n            else:\n                self.get_file(fp, headers, cb, num_cb, torrent=torrent,\n                              version_id=version_id,\n                              response_headers=response_headers)", "response": "This method returns the contents of the object pointed to by the object in S3 and writes it to the file pointed to by fp."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_contents_as_string(self, headers=None,\n                               cb=None, num_cb=10,\n                               torrent=False,\n                               version_id=None,\n                               response_headers=None):\n        \"\"\"\n        Retrieve an object from S3 using the name of the Key object as the\n        key in S3.  Return the contents of the object as a string.\n        See get_contents_to_file method for details about the\n        parameters.\n\n        :type headers: dict\n        :param headers: Any additional headers to send in the request\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with\n                       the cb parameter this parameter determines the\n                       granularity of the callback by defining\n                       the maximum number of times the callback will\n                       be called during the file transfer.\n\n        :type torrent: bool\n        :param torrent: If True, returns the contents of a torrent file\n                        as a string.\n\n        :type response_headers: dict\n        :param response_headers: A dictionary containing HTTP headers/values\n                                 that will override any headers associated with\n                                 the stored object in the response.\n                                 See http://goo.gl/EWOPb for details.\n\n        :rtype: string\n        :returns: The contents of the file as a string\n        \"\"\"\n        fp = StringIO.StringIO()\n        self.get_contents_to_file(fp, headers, cb, num_cb, torrent=torrent,\n                                  version_id=version_id,\n                                  response_headers=response_headers)\n        return fp.getvalue()", "response": "This method returns the contents of the object in S3 as a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_user_grant(self, permission, user_id, headers=None,\n                       display_name=None):\n        \"\"\"\n        Convenience method that provides a quick way to add a canonical\n        user grant to a key.  This method retrieves the current ACL,\n        creates a new grant based on the parameters passed in, adds that\n        grant to the ACL and then PUT's the new ACL back to S3.\n\n        :type permission: string\n        :param permission: The permission being granted. Should be one of:\n                           (READ, WRITE, READ_ACP, WRITE_ACP, FULL_CONTROL).\n\n        :type user_id: string\n        :param user_id:     The canonical user id associated with the AWS\n                            account your are granting the permission to.\n\n        :type display_name: string\n        :param display_name: An option string containing the user's\n                             Display Name.  Only required on Walrus.\n        \"\"\"\n        policy = self.get_acl()\n        policy.acl.add_user_grant(permission, user_id,\n                                  display_name=display_name)\n        self.set_acl(policy, headers=headers)", "response": "This method adds a user grant to the current ACL and PUTs the new ACL back to S3."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect_sqs(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from botornado.sqs.connection import AsyncSQSConnection\n    return AsyncSQSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Connect to Amazon s SQS connection"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_s3(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from botornado.s3.connection import AsyncS3Connection\n    return AsyncS3Connection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Connect to Amazon s S3"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect_euca(host=None, aws_access_key_id=None, aws_secret_access_key=None,\n                 port=8773, path='/services/Eucalyptus', is_secure=False,\n                 **kwargs):\n    \"\"\"\n    Connect to a Eucalyptus service.\n\n    :type host: string\n    :param host: the host name or ip address of the Eucalyptus server\n\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.ec2.connection.EC2Connection`\n    :return: A connection to Eucalyptus server\n    \"\"\"\n    raise BotoClientError('Not Implemented')", "response": "Connect to a Eucalyptus service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_obj(self, name):\n        val = self.get(name)\n        if not val:\n            return None\n        if name.find('queue') >= 0:\n            obj = boto.lookup('sqs', val)\n            if obj:\n                obj.set_message_class(ServiceMessage)\n        elif name.find('bucket') >= 0:\n            obj = boto.lookup('s3', val)\n        elif name.find('domain') >= 0:\n            obj = boto.lookup('sdb', val)\n        else:\n            obj = None\n        return obj", "response": "Returns the AWS object associated with a given option name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexport the given data to a JSON response.", "response": "def export_json(data, status, headers):\n    \"\"\"\n    Creates a JSON response\n\n    JSON content is encoded by utf-8, not unicode escape.\n\n    Args:\n        data: any type object that can dump to json\n        status (int): http status code\n        headers (dict): http headers\n    \"\"\"\n    dumped = json.dumps(data, ensure_ascii=False)\n    resp = current_app.response_class(\n        dumped, status=status, headers=headers,\n        content_type='application/json; charset=utf-8')\n    return resp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authorize(self, cidr_ip=None, ec2_group=None):\n        if isinstance(ec2_group, SecurityGroup):\n            group_name = ec2_group.name\n            group_owner_id = ec2_group.owner_id\n        else:\n            group_name = None\n            group_owner_id = None\n        return self.connection.authorize_dbsecurity_group(self.name,\n                                                          cidr_ip,\n                                                          group_name,\n                                                          group_owner_id)", "response": "Add a new rule to this DBSecurity group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef revoke(self, cidr_ip=None, ec2_group=None):\n        if isinstance(ec2_group, SecurityGroup):\n            group_name = ec2_group.name\n            group_owner_id = ec2_group.owner_id\n            return self.connection.revoke_dbsecurity_group(\n                self.name,\n                ec2_security_group_name=group_name,\n                ec2_security_group_owner_id=group_owner_id)\n\n        # Revoking by CIDR IP range\n        return self.connection.revoke_dbsecurity_group(\n            self.name, cidr_ip=cidr_ip)", "response": "Revokes access to a CIDR range or EC2 SecurityGroup."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles a 421 message.", "response": "def on_raw_421(self, message):\n        \"\"\"\n        Twitch doesn't support WHO/WHOIS,\n        so ignore errors from those commands\n        \"\"\"\n        if message.params[1] in {'WHO', 'WHOIS'}:\n            LOGGER.debug('Pydle sent WHO/WHOIS which resulted in 421')\n        else:\n            super().on_raw_421(message)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all parts of this MultiPart Upload.", "response": "def get_all_parts(self, max_parts=None, part_number_marker=None):\n        \"\"\"\n        Return the uploaded parts of this MultiPart Upload.  This is\n        a lower-level method that requires you to manually page through\n        results.  To simplify this process, you can just use the\n        object itself as an iterator and it will automatically handle\n        all of the paging with S3.\n        \"\"\"\n        self._parts = []\n        query_args = 'uploadId=%s' % self.id\n        if max_parts:\n            query_args += '&max-parts=%d' % max_parts\n        if part_number_marker:\n            query_args += '&part-number-marker=%s' % part_number_marker\n        response = self.bucket.connection.make_request('GET', self.bucket.name,\n                                                       self.key_name,\n                                                       query_args=query_args)\n        body = response.read()\n        if response.status == 200:\n            h = handler.XmlHandler(self, self)\n            xml.sax.parseString(body, h)\n            return self._parts"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload_part_from_file(self, fp, part_num, headers=None, replace=True,\n                              cb=None, num_cb=10, policy=None, md5=None,\n                              size=None):\n        \"\"\"\n        Upload another part of this MultiPart Upload.\n        \n        :type fp: file\n        :param fp: The file object you want to upload.\n        \n        :type part_num: int\n        :param part_num: The number of this part.\n\n        The other parameters are exactly as defined for the\n        :class:`boto.s3.key.Key` set_contents_from_file method.\n        \"\"\"\n        if part_num < 1:\n            raise ValueError('Part numbers must be greater than zero')\n        query_args = 'uploadId=%s&partNumber=%d' % (self.id, part_num)\n        key = self.bucket.new_key(self.key_name)\n        key.set_contents_from_file(fp, headers, replace, cb, num_cb, policy,\n                                   md5, reduced_redundancy=False,\n                                   query_args=query_args, size=size)", "response": "Uploads a single Part of a MultiPart Upload."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncopies another part of this MultiPart Upload.", "response": "def copy_part_from_key(self, src_bucket_name, src_key_name, part_num,\n                           start=None, end=None):\n        \"\"\"\n        Copy another part of this MultiPart Upload.\n\n        :type src_bucket_name: string\n        :param src_bucket_name: Name of the bucket containing the source key\n\n        :type src_key_name: string\n        :param src_key_name: Name of the source key\n\n        :type part_num: int\n        :param part_num: The number of this part.\n\n        :type start: int\n        :param start: Zero-based byte offset to start copying from\n\n        :type end: int\n        :param end: Zero-based byte offset to copy to\n        \"\"\"\n        if part_num < 1:\n            raise ValueError('Part numbers must be greater than zero')\n        query_args = 'uploadId=%s&partNumber=%d' % (self.id, part_num)\n        if start is not None and end is not None:\n            rng = 'bytes=%s-%s' % (start, end)\n            provider = self.bucket.connection.provider\n            headers = {provider.copy_source_range_header: rng}\n        else:\n            headers = None\n        return self.bucket.copy_key(self.key_name, src_bucket_name,\n                                    src_key_name, storage_class=None,\n                                    headers=headers,\n                                    query_args=query_args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncomplete the MultiPart Upload operation. This method should be called when all parts of the file have been successfully uploaded to S3. :rtype: :class:`boto.s3.multipart.CompletedMultiPartUpload` :returns: An object representing the completed upload.", "response": "def complete_upload(self):\n        \"\"\"\n        Complete the MultiPart Upload operation.  This method should\n        be called when all parts of the file have been successfully\n        uploaded to S3.\n\n        :rtype: :class:`boto.s3.multipart.CompletedMultiPartUpload`\n        :returns: An object representing the completed upload.\n        \"\"\"\n        xml = self.to_xml()\n        return self.bucket.complete_multipart_upload(self.key_name,\n                                                     self.id, xml)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_profile_data(self, raw_token):\n        token_data = json.loads(raw_token)\n        # This header is the 'magic' that makes this empty GET request work.\n        headers = {'Authorization': 'OAuth %s' % token_data['access_token']}\n\n        try:\n            response = self.request('get', self.profile_url, headers=headers)\n            response.raise_for_status()\n        except RequestException as e:\n            logger.error('Unable to fetch user profile: {0}'.format(e))\n            return None\n        else:\n            return response.json() or response.text", "response": "Fetch user profile information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tickUpdate(self, tick):\n        ''' consume ticks '''\n        LOG.debug(\"tickUpdate %s with tick %s, price %s\" % (self.__symbol, tick.time, tick.close))\n        self.__priceZscore(tick.close)\n        self.__volumeZscore(tick.volume)\n\n        # get zscore\n        priceZscore=self.__priceZscore.getLastValue()\n        volumeZscore=self.__volumeZscore.getLastValue()\n\n        # if haven't started, don't do any trading\n        if tick.time <= self.__startDate:\n            return\n\n        # if not enough data, skip to reduce risk\n        if priceZscore is None or volumeZscore is None:\n            return\n\n        if self.__position > 0:\n            self.__dayCounter += 1\n\n        if priceZscore > self.__buyThreshold and self.__preZscore and self.__preZscore < self.__buyThreshold and self.__position <= 0 and abs(volumeZscore) > 1:\n            self.__placeBuyOrder(tick)\n        elif self.__position > 0:\n            if (self.__dayCounter > self.__dayCounterThreshold and priceZscore < self.__sellThreshold)\\\n                    or priceZscore < 0 or self.__buyPrice * 0.9 > tick.close:\n                self.__placeSellOrder(tick)\n                self.__dayCounter=0\n\n        self.__preZscore=priceZscore", "response": "consume ticks and update the order of the next time."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_provider(self, provider):\n        if self.provider is not None:\n            return self.provider\n        return providers.by_id(provider)", "response": "Get instance of the OAuth client for this provider."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the callback url for this provider.", "response": "def get_callback_url(self, provider):\n        \"\"\"Return the callback url for this provider.\"\"\"\n        info = self.model._meta.app_label, self.model._meta.model_name\n        return reverse('admin:%s_%s_callback' % info, kwargs={'provider': provider.id})"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a redirect url for a given provider.", "response": "def get_redirect_url(self, **kwargs):\n        \"\"\"Build redirect url for a given provider.\"\"\"\n        provider_id = kwargs.get('provider', '')\n        provider = self.get_provider(provider_id)\n        if not provider:\n            raise Http404('Unknown OAuth provider.')\n        callback = self.get_callback_url(provider)\n        params = self.get_additional_parameters(provider)\n        return provider.get_redirect_url(self.request, callback=callback, parameters=params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_login_redirect(self, provider, account):\n        info = self.model._meta.app_label, self.model._meta.model_name\n        # inline import to prevent circular imports.\n        from .admin import PRESERVED_FILTERS_SESSION_KEY\n        preserved_filters = self.request.session.get(PRESERVED_FILTERS_SESSION_KEY, None)\n        redirect_url = reverse('admin:%s_%s_changelist' % info)\n        if preserved_filters:\n            redirect_url = add_preserved_filters(\n                {'preserved_filters': preserved_filters, 'opts': self.model._meta}, redirect_url)\n        return redirect_url", "response": "Return url to redirect authenticated users."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_error_redirect(self, provider, reason):\n        info = self.model._meta.app_label, self.model._meta.model_name\n        return reverse('admin:%s_%s_changelist' % info)", "response": "Return url to redirect on login failure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle_login_failure(self, provider, reason):\n        logger.error('Authenication Failure: {0}'.format(reason))\n        messages.error(self.request, 'Authenication Failed. Please try again')\n        return redirect(self.get_error_redirect(provider, reason))", "response": "Message user and redirect on error."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sshclient_from_instance(instance, ssh_key_file,\n                            host_key_file='~/.ssh/known_hosts',\n                            user_name='root', ssh_pwd=None):\n    \"\"\"\n    Create and return an SSHClient object given an\n    instance object.\n\n    :type instance: :class`boto.ec2.instance.Instance` object\n    :param instance: The instance object.\n\n    :type ssh_key_file: str\n    :param ssh_key_file: A path to the private key file used\n                         to log into instance.\n\n    :type host_key_file: str\n    :param host_key_file: A path to the known_hosts file used\n                          by the SSH client.\n                          Defaults to ~/.ssh/known_hosts\n    :type user_name: str\n    :param user_name: The username to use when logging into\n                      the instance.  Defaults to root.\n\n    :type ssh_pwd: str\n    :param ssh_pwd: The passphrase, if any, associated with\n                    private key.\n    \"\"\"\n    s = FakeServer(instance, ssh_key_file)\n    return SSHClient(s, host_key_file, user_name, ssh_pwd)", "response": "Create and return an SSHClient object given an instance object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open(self, filename, mode='r', bufsize=-1):\n        sftp_client = self.open_sftp()\n        return sftp_client.open(filename, mode, bufsize)", "response": "Open a file on the remote system and return a file - like object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes a command on the remote host.", "response": "def run(self, command):\n        \"\"\"\n        Execute a command on the remote host.  Return a tuple containing\n        an integer status and a two strings, the first containing stdout\n        and the second containing stderr from the command.\n        \"\"\"\n        boto.log.debug('running:%s on %s' % (command, self.server.instance_id))\n        status = 0\n        try:\n            t = self._ssh_client.exec_command(command)\n        except paramiko.SSHException:\n            status = 1\n        std_out = t[1].read()\n        std_err = t[2].read()\n        t[0].close()\n        t[1].close()\n        t[2].close()\n        boto.log.debug('stdout: %s' % std_out)\n        boto.log.debug('stderr: %s' % std_err)\n        return (status, std_out, std_err)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_pty(self, command):\n        boto.log.debug('running:%s on %s' % (command, self.server.instance_id))\n        channel = self._ssh_client.get_transport().open_session()\n        channel.get_pty()\n        channel.exec_command(command)\n        return channel.recv(1024)", "response": "Execute a command on the remote host with a pseudo - terminal."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a factory function for the specified feature", "response": "def factory(feature):\n    \"\"\"\n    Factory to choose feature extractor\n\n    :param feature: name of the feature\n    :return: Feature extractor function\n    \"\"\"\n    if feature == 'hog':\n        return hog\n    elif feature == 'deep':\n        return deep\n    elif feature == 'gray':\n        return gray\n    elif feature == 'lab':\n        return lab\n    elif feature == 'luv':\n        return luv\n    elif feature == 'hsv':\n        return hsv\n    elif feature == 'hls':\n        return hls\n    else:\n        return rgb"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hog(img, options=None):\n    op = _DEF_HOG_OPTS.copy()\n    if options is not None:\n        op.update(options)\n\n    img = gray(img)\n    img_fd = skimage.feature.hog(img,\n                                 orientations=op['orientations'],\n                                 pixels_per_cell=op['cell_size'],\n                                 cells_per_block=op['block_size'],\n                                 visualise=False)\n    h, w = img.shape\n\n    cx, cy = op['cell_size']\n    n_cellsx, n_cellsy = w // cx, h // cy\n\n    bx, by = op['block_size']\n    n_blksx, n_blksy = (n_cellsx - bx) + 1, (n_cellsy - by) + 1\n\n    hog_shape = n_blksy * by, n_blksx * bx, op['orientations']\n\n    image_hog = np.reshape(img_fd, hog_shape)\n    return image_hog", "response": "This function extracts the HOG feature for given image and returns it as numpy array."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a file from a Keycoat object.", "response": "def get_file(self, fp, headers=None, cb=None, num_cb=10, torrent=False):\n        \"\"\"\n        Retrieves a file from a Key\n\n        :type fp: file\n        :param fp: File pointer to put the data into\n\n        :type headers: string\n        :param: ignored in this subclass.\n\n        :type cb: function\n        :param cb: ignored in this subclass.\n\n        :type cb: int\n        :param num_cb: ignored in this subclass.\n        \"\"\"\n        if self.key_type & self.KEY_STREAM_READABLE:\n            raise BotoClientError('Stream is not Readable')\n        elif self.key_type & self.KEY_STREAM_WRITABLE:\n            key_file = self.fp\n        else:\n            key_file = open(self.full_path, 'rb')\n        try:\n            shutil.copyfileobj(key_file, fp)\n        finally:\n            key_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstores an object in a file using the name of the Key object as the key in file URI and the contents of the file pointed to by 'fp' as the contents. :type fp: file :param fp: the file whose contents to upload :type headers: dict :param headers: ignored in this subclass. :type replace: bool :param replace: If this parameter is False, the method will first check to see if an object exists in the bucket with the same key. If it does, it won't overwrite it. The default value is True which will overwrite the object. :type cb: function :param cb: ignored in this subclass. :type cb: int :param num_cb: ignored in this subclass. :type policy: :class:`boto.s3.acl.CannedACLStrings` :param policy: ignored in this subclass. :type md5: A tuple containing the hexdigest version of the MD5 checksum of the file as the first element and the Base64-encoded version of the plain checksum as the second element. This is the same format returned by the compute_md5 method. :param md5: ignored in this subclass.", "response": "def set_contents_from_file(self, fp, headers=None, replace=True, cb=None,\n                               num_cb=10, policy=None, md5=None):\n        \"\"\"\n        Store an object in a file using the name of the Key object as the\n        key in file URI and the contents of the file pointed to by 'fp' as the\n        contents.\n\n        :type fp: file\n        :param fp: the file whose contents to upload\n\n        :type headers: dict\n        :param headers: ignored in this subclass.\n\n        :type replace: bool\n        :param replace: If this parameter is False, the method\n                        will first check to see if an object exists in the\n                        bucket with the same key.  If it does, it won't\n                        overwrite it.  The default value is True which will\n                        overwrite the object.\n\n        :type cb: function\n        :param cb: ignored in this subclass.\n\n        :type cb: int\n        :param num_cb: ignored in this subclass.\n\n        :type policy: :class:`boto.s3.acl.CannedACLStrings`\n        :param policy: ignored in this subclass.\n\n        :type md5: A tuple containing the hexdigest version of the MD5 checksum\n                   of the file as the first element and the Base64-encoded\n                   version of the plain checksum as the second element.\n                   This is the same format returned by the compute_md5 method.\n        :param md5: ignored in this subclass.\n        \"\"\"\n        if self.key_type & self.KEY_STREAM_WRITABLE:\n            raise BotoClientError('Stream is not writable')\n        elif self.key_type & self.KEY_STREAM_READABLE:\n            key_file = self.fp\n        else:\n            if not replace and os.path.exists(self.full_path):\n                return\n            key_file = open(self.full_path, 'wb')\n        try:\n            shutil.copyfileobj(fp, key_file)\n        finally:\n            key_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving the contents of the Key and return them as a string.", "response": "def get_contents_as_string(self, headers=None, cb=None, num_cb=10,\n                               torrent=False):\n        \"\"\"\n        Retrieve file data from the Key, and return contents as a string.\n\n        :type headers: dict\n        :param headers: ignored in this subclass.\n\n        :type cb: function\n        :param cb: ignored in this subclass.\n\n        :type cb: int\n        :param num_cb: ignored in this subclass.\n\n        :type cb: int\n        :param num_cb: ignored in this subclass.\n\n        :type torrent: bool\n        :param torrent: ignored in this subclass.\n\n        :rtype: string\n        :returns: The contents of the file as a string\n        \"\"\"\n\n        fp = StringIO.StringIO()\n        self.get_contents_to_file(fp)\n        return fp.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef enclosing_box(boxes):\n        x = max(0, min([box.x for box in boxes]))\n        y = max(0, min([box.y for box in boxes]))\n        x2 = max([box.bottom_right()[0] for box in boxes])\n        y2 = max([box.bottom_right()[1] for box in boxes])\n        return Box.from_xy(x, y, x2, y2)", "response": "Finds a new box that exactly encloses all the given boxes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef left_most(boxes):\n        x_list = [(box.x, box) for box in boxes]\n        x_list.sort()\n        return x_list[0][1]", "response": "Finds the left most box out of the given boxes."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the right most Box object out of the given boxes.", "response": "def right_most(boxes):\n        \"\"\"\n        Finds the right most box out of the given boxes.\n\n        :param boxes: Array of Box objects\n        :return: The right-most Box object\n        \"\"\"\n        x_list = [(box.x, box) for box in boxes]\n        x_list.sort()\n        return x_list[-1][1]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef intersection_box(box1, box2):\n        b1_x2, b1_y2 = box1.bottom_right()\n        b2_x2, b2_y2 = box2.bottom_right()\n\n        x, y = max(box1.x, box2.x), max(box1.y, box2.y)\n        x2, y2 = min(b1_x2, b2_x2), min(b1_y2, b2_y2)\n        w, h = max(0, x2-x), max(0, y2-y)\n        return Box(x, y, w, h)", "response": "Finds an intersection box that is common to both boxes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iou(box1, box2):\n        int_box = Box.intersection_box(box1, box2)\n        int_area = int_box.area()\n        union_area = box1.area() + box2.area() - int_area\n\n        result = 0.0\n        if union_area > 0:\n            result = float(int_area) / float(union_area)\n\n        return result", "response": "Find intersection over union - area for given two boxes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef overlaps(self, box, th=0.0001):\n        int_box = Box.intersection_box(self, box)\n        small_box = self if self.smaller(box) else box\n        return True if int_box.area() / small_box.area() >= th else False", "response": "Check whether this box and given box overlaps at least by given threshold."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef expand(self, percentage):\n        ex_h = math.ceil(self.height * percentage / 100)\n        ex_w = math.ceil(self.width * percentage / 100)\n\n        x = max(0, self.x - ex_w)\n        y = max(0, self.y - ex_h)\n        x2 = self.x + self.width + ex_w\n        y2 = self.y + self.height + ex_h\n        return Box.from_xy(x, y, x2, y2)", "response": "Expands the box co -ordinates by given percentage on four sides. Ignores negative values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd padding around four sides of the box.", "response": "def padding(self, px):\n        \"\"\"\n        Add padding around four sides of box\n\n        :param px: padding value in pixels.\n            Can be an array in the format of [top right bottom left] or single value.\n        :return: New padding added box\n        \"\"\"\n        # if px is not an array, have equal padding all sides\n        if not isinstance(px, list):\n            px = [px] * 4\n\n        x = max(0, self.x - px[3])\n        y = max(0, self.y - px[0])\n        x2 = self.x + self.width + px[1]\n        y2 = self.y + self.height + px[2]\n        return Box.from_xy(x, y, x2, y2)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsplitting the box object into many boxes each of given size.", "response": "def split(self, box_size):\n        \"\"\"\n        Splits the box object into many boxes each of given size.\n        Assumption: the entire box can be split into rows and columns with the given size.\n\n        :param box_size: (width, height) of the new tiny boxes\n        :return: Array of tiny boxes\n        \"\"\"\n        w, h = box_size\n        rows = round(self.height / h)\n        cols = round(self.width / w)\n\n        boxes = []\n        for row in range(rows):\n            for col in range(cols):\n                box = Box(self.x + (col * w), self.y + (row * h), w, h)\n                boxes.append(box)\n        return boxes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pos_by_percent(self, x_percent, y_percent):\n        x = round(x_percent * self.width)\n        y = round(y_percent * self.height)\n        return int(x), int(y)", "response": "Finds a point inside the box that is exactly at the given percentage place."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmove the box by given point.", "response": "def move(self, point, reverse=False):\n        \"\"\"\n        Translates the box by given (tx, ty)\n\n        :param point: (tx, ty)\n        :param reverse: If true, the translation direction is reversed. ie. (-tx, -ty)\n        :return: New translated box\n        \"\"\"\n        if reverse:\n            point = [-1 * i for i in point]\n        return Box(self.x + point[0], self.y + point[1], self.width, self.height)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_int(self):\n        coord = [int(round(x)) for x in self.xy_coord()]\n        return self.from_xy(coord[0], coord[1], coord[2], coord[3])", "response": "Rounds off and converts x y w h to int\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pip_version(self):\n        if not self._pip_exists:\n            return None\n        if not hasattr(self, '_pip_version'):\n            # don't call `self._execute_pip` here as that method calls this one\n            output = self._execute(self._pip + ['-V'], log=False).split()[1]\n            self._pip_version = tuple([int(n) for n in output.split('.')])\n        return self._pip_version", "response": "Version of installed pip."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute virtualenv to create a new environment.", "response": "def _create(self):\n        \"\"\"Executes `virtualenv` to create a new environment.\"\"\"\n        if self.readonly:\n            raise VirtualenvReadonlyException()\n        args = ['virtualenv']\n        if self.system_site_packages:\n            args.append('--system-site-packages')\n        if self.python is None:\n            args.append(self.name)\n        else:\n            args.extend(['-p', self.python, self.name])\n        proc = subprocess.Popen(args, cwd=self.root, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        output, error = proc.communicate()\n        returncode = proc.returncode\n        if returncode:\n            raise VirtualenvCreationException((returncode, output, self.name))\n        self._write_to_log(output, truncate=True)\n        self._write_to_error(error, truncate=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _execute_pip(self, args, log=True):\n\n        # Copy the pip calling arguments so they can be extended\n        exec_args = list(self._pip)\n\n        # Older versions of pip don't support the version check argument.\n        # Fixes https://github.com/sjkingo/virtualenv-api/issues/35\n        if self.pip_version[0] >= 6:\n            exec_args.append('--disable-pip-version-check')\n\n        exec_args.extend(args)\n        return self._execute(exec_args, log=log)", "response": "Executes pip commands.\n\n        :param args: Arguments to pass to pip (list[str])\n        :param log: Log the output to a file [default: True] (boolean)\n        :return: See _execute"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _execute(self, args, log=True):\n        if not self._ready:\n            self.open_or_create()\n        output = ''\n        error = ''\n        try:\n            proc = subprocess.Popen(args, cwd=self.path, env=self.env, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            output, error = proc.communicate()\n            returncode = proc.returncode\n            if returncode:\n                raise subprocess.CalledProcessError(returncode, proc, (output, error))\n            return to_text(output)\n        except OSError as e:\n            # raise a more meaningful error with the program name\n            prog = args[0]\n            if prog[0] != os.sep:\n                prog = os.path.join(self.path, prog)\n            raise OSError('%s: %s' % (prog, six.u(str(e))))\n        except subprocess.CalledProcessError as e:\n            output, error = e.output\n            e.output = output\n            raise e\n        finally:\n            if log:\n                try:\n                    self._write_to_log(to_text(output))\n                    self._write_to_error(to_text(error))\n                except NameError:\n                    pass", "response": "Executes the given command inside the environment and returns the output."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the given output to the log file appending unless truncate is True.", "response": "def _write_to_log(self, s, truncate=False):\n        \"\"\"Writes the given output to the log file, appending unless `truncate` is True.\"\"\"\n        # if truncate is True, set write mode to truncate\n        with open(self._logfile, 'w' if truncate else 'a') as fp:\n            fp.writelines((to_text(s) if six.PY2 else to_text(s), ))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the given output to the error file appending unless truncate is True.", "response": "def _write_to_error(self, s, truncate=False):\n        \"\"\"Writes the given output to the error file, appending unless `truncate` is True.\"\"\"\n        # if truncate is True, set write mode to truncate\n        with open(self._errorfile, 'w' if truncate else 'a') as fp:\n            fp.writelines((to_text(s)), )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if pip exists inside the virtual environment.", "response": "def _pip_exists(self):\n        \"\"\"Returns True if pip exists inside the virtual environment. Can be\n        used as a naive way to verify that the environment is installed.\"\"\"\n        return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install(self, package, force=False, upgrade=False, options=None):\n        if self.readonly:\n            raise VirtualenvReadonlyException()\n        if options is None:\n            options = []\n        if isinstance(package, tuple):\n            package = '=='.join(package)\n        if package.startswith(('-e', '-r')):\n            package_args = package.split()\n        else:\n            package_args = [package]\n        if not (force or upgrade) and (package_args[0] != '-r' and self.is_installed(package_args[-1])):\n            self._write_to_log('%s is already installed, skipping (use force=True to override)' % package_args[-1])\n            return\n        if not isinstance(options, list):\n            raise ValueError(\"Options must be a list of strings.\")\n        if upgrade:\n            options += ['--upgrade']\n            if force:\n                options += ['--force-reinstall']\n        elif force:\n            options += ['--ignore-installed']\n        try:\n            self._execute_pip(['install'] + package_args + options)\n        except subprocess.CalledProcessError as e:\n            raise PackageInstallationException((e.returncode, e.output, package))", "response": "Installs the given package into this virtual environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uninstall(self, package):\n        if isinstance(package, tuple):\n            package = '=='.join(package)\n        if not self.is_installed(package):\n            self._write_to_log('%s is not installed, skipping' % package)\n            return\n        try:\n            self._execute_pip(['uninstall', '-y', package])\n        except subprocess.CalledProcessError as e:\n            raise PackageRemovalException((e.returncode, e.output, package))", "response": "Uninstalls the given package from this virtual environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a wheel of the given package from this virtual environment.", "response": "def wheel(self, package, options=None):\n        \"\"\"Creates a wheel of the given package from this virtual environment,\n        as specified in pip's package syntax or a tuple of ('name', 'ver'),\n        only if it is not already installed. Some valid examples:\n\n         'Django'\n         'Django==1.5'\n         ('Django', '1.5')\n\n        The `options` is a list of strings that can be used to pass to\n        pip.\"\"\"\n        if self.readonly:\n            raise VirtualenvReadonlyException()\n        if options is None:\n            options = []\n        if isinstance(package, tuple):\n            package = '=='.join(package)\n        if not self.is_installed('wheel'):\n            raise PackageWheelException((0, \"Wheel package must be installed in the virtual environment\", package))\n        if not isinstance(options, list):\n            raise ValueError(\"Options must be a list of strings.\")\n        try:\n            self._execute_pip(['wheel', package] + options)\n        except subprocess.CalledProcessError as e:\n            raise PackageWheelException((e.returncode, e.output, package))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if the given package is installed in the virtual environment.", "response": "def is_installed(self, package):\n        \"\"\"Returns True if the given package (given in pip's package syntax or a\n        tuple of ('name', 'ver')) is installed in the virtual environment.\"\"\"\n        if isinstance(package, tuple):\n            package = '=='.join(package)\n        if package.endswith('.git'):\n            pkg_name = os.path.split(package)[1][:-4]\n            return pkg_name in self.installed_package_names or \\\n                    pkg_name.replace('_', '-') in self.installed_package_names\n        pkg_tuple = split_package_name(package)\n        if pkg_tuple[1] is not None:\n            return pkg_tuple in self.installed_packages\n        else:\n            return pkg_tuple[0].lower() in self.installed_package_names"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupgrade all installed packages to their latest versions.", "response": "def upgrade_all(self):\n        \"\"\"\n        Upgrades all installed packages to their latest versions.\n        \"\"\"\n        for pkg in self.installed_package_names:\n            self.install(pkg, upgrade=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches the PyPi repository for the given term and returns a dictionary of results.", "response": "def search(self, term):\n        \"\"\"\n        Searches the PyPi repository for the given `term` and returns a\n        dictionary of results.\n\n        New in 2.1.5: returns a dictionary instead of list of tuples\n        \"\"\"\n        packages = {}\n        results = self._execute_pip(['search', term], log=False)  # Don't want to log searches\n        for result in results.split(linesep):\n            try:\n                name, description = result.split(six.u(' - '), 1)\n            except ValueError:\n                # '-' not in result so unable to split into tuple;\n                # this could be from a multi-line description\n                continue\n            else:\n                name = name.strip()\n                if len(name) == 0:\n                    continue\n                packages[name] = description.split(six.u('<br'), 1)[0].strip()\n        return packages"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef installed_packages(self):\n        freeze_options = ['-l', '--all'] if self.pip_version >= (8, 1, 0) else ['-l']\n        return list(map(split_package_name, filter(None, self._execute_pip(\n                ['freeze'] + freeze_options).split(linesep))))", "response": "Returns a list of all packages that are installed in this environment"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nenable availability zones to this Access Point.", "response": "def enable_zones(self, zones):\n        \"\"\"\n        Enable availability zones to this Access Point.\n        All zones must be in the same region as the Access Point.\n\n        :type zones: string or List of strings\n        :param zones: The name of the zone(s) to add.\n\n        \"\"\"\n        if isinstance(zones, str) or isinstance(zones, unicode):\n            zones = [zones]\n        new_zones = self.connection.enable_availability_zones(self.name, zones)\n        self.availability_zones = new_zones"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef disable_zones(self, zones):\n        if isinstance(zones, str) or isinstance(zones, unicode):\n            zones = [zones]\n        new_zones = self.connection.disable_availability_zones(self.name, zones)\n        self.availability_zones = new_zones", "response": "Disable availability zones from this Access Point."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding instances to this load balancer.", "response": "def register_instances(self, instances):\n        \"\"\"\n        Adds instances to this load balancer. All instances must be in the same\n        region as the load balancer. Adding endpoints that are already\n        registered with the load balancer has no effect.\n\n        :param list instances: List of instance IDs (strings) that you'd like\n            to add to this load balancer.\n\n        \"\"\"\n        if isinstance(instances, str) or isinstance(instances, unicode):\n            instances = [instances]\n        new_instances = self.connection.register_instances(self.name, instances)\n        self.instances = new_instances"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nattaching load balancer to one or more subnets.", "response": "def attach_subnets(self, subnets):\n        \"\"\"\n        Attaches load balancer to one or more subnets.\n        Attaching subnets that are already registered with the \n        Load Balancer has no effect.\n\n        :type subnets: string or List of strings\n        :param subnets: The name of the subnet(s) to add.\n\n        \"\"\"\n        if isinstance(subnets, str) or isinstance(subnets, unicode):\n            subnets = [subnets]\n        new_subnets = self.connection.attach_lb_to_subnets(self.name, subnets)\n        self.subnets = new_subnets"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndetaching load balancer from one or more subnets.", "response": "def detach_subnets(self, subnets):\n        \"\"\"\n        Detaches load balancer from one or more subnets.\n\n        :type subnets: string or List of strings\n        :param subnets: The name of the subnet(s) to detach.\n\n        \"\"\"\n        if isinstance(subnets, str) or isinstance(subnets, unicode):\n            subnets = [subnets]\n        new_subnets = self.connection.detach_lb_to_subnets(self.name, subnets)\n        self.subnets = new_subnets"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying security groups to the load balancer.", "response": "def apply_security_groups(self, security_groups):\n        \"\"\"\n        Applies security groups to the load balancer.\n        Applying security groups that are already registered with the \n        Load Balancer has no effect.\n\n        :type security_groups: string or List of strings\n        :param security_groups: The name of the security group(s) to add.\n\n        \"\"\"\n        if isinstance(security_groups, str) or \\\n              isinstance(security_groups, unicode):\n            security_groups = [security_groups]\n        new_sgs = self.connection.apply_security_groups_to_lb(\n                                         self.name, security_groups)\n        self.security_groups = new_sgs"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef detect_tag(filename):\n    with fileutil.opened(filename, \"rb\") as file:\n        file.seek(0)\n        header = file.read(10)\n        file.seek(0)\n        if len(header) < 10:\n            raise NoTagError(\"File too short\")\n        if header[0:3] != b\"ID3\":\n            raise NoTagError(\"ID3v2 tag not found\")\n        if header[3] not in _tag_versions or header[4] != 0:\n            raise TagError(\"Unknown ID3 version: 2.{0}.{1}\"\n                           .format(*header[3:5]))\n        cls = _tag_versions[header[3]]\n        offset = 0\n        length = Syncsafe.decode(header[6:10]) + 10\n        if header[3] == 4 and header[5] & _TAG24_FOOTER:\n            length += 10\n        return (cls, offset, length)", "response": "Detect the type and position of ID3v2 tag in filename."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters cls as a class representing an ID3 frame.", "response": "def frameclass(cls):\n    \"\"\"Register cls as a class representing an ID3 frame.\n\n    Sets cls.frameid and cls._version if not present, and registers the\n    new frame in Tag's known_frames dictionary.\n\n    To be used as a decorator on the class definition:\n\n    @frameclass\n    class UFID(Frame):\n        _framespec = (NullTerminatedStringSpec(\"owner\"), BinaryDataSpec(\"data\"))\n    \"\"\"\n    assert issubclass(cls, Frames.Frame)\n\n    # Register v2.2 versions of v2.3/v2.4 frames if encoded by inheritance.\n    if len(cls.__name__) == 3:\n        base = cls.__bases__[0]\n        if issubclass(base, Frames.Frame) and base._in_version(3, 4):\n            assert not hasattr(base, \"_v2_frame\")\n            base._v2_frame = cls\n            # Override frameid from base with v2.2 name\n            if base.frameid == cls.frameid:\n                cls.frameid = cls.__name__\n\n    # Add frameid.\n    if not hasattr(cls, \"frameid\"):\n        cls.frameid = cls.__name__\n    assert Tag._is_frame_id(cls.frameid)\n\n    # Supply _version attribute if missing.\n    if len(cls.frameid) == 3:\n        cls._version = 2\n    if len(cls.frameid) == 4 and not cls._version:\n        cls._version = (3, 4)\n\n    # Register cls as a known frame.\n    assert cls.frameid not in Tag.known_frames\n    Tag.known_frames[cls.frameid] = cls\n    \n    return cls"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the sort key for the given frame.", "response": "def key(self, frame):\n        \"Return the sort key for the given frame.\"\n        def keytuple(primary):\n            if frame.frameno is None:\n                return (primary, 1)\n            return (primary, 0, frame.frameno)\n\n        # Look up frame by exact match\n        if type(frame) in self.frame_keys:\n            return keytuple(self.frame_keys[type(frame)])\n\n        # Look up parent frame for v2.2 frames\n        if frame._in_version(2) and type(frame).__bases__[0] in self.frame_keys:\n            return keytuple(self.frame_keys[type(frame).__bases__[0]])\n\n        # Try each pattern\n        for (pattern, key) in self.re_keys:\n            if re.match(pattern, frame.frameid):\n                return keytuple(key)\n\n        return keytuple(self.unknown_key)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef frames(self, key=None, orig_order=False):\n        if key is not None:\n            # If there are multiple frames, then they are already in original order.\n            key = self._normalize_key(key)\n            if len(self._frames[key]) == 0:\n                raise KeyError(\"Key not found: \" + repr(key))\n            return self._frames[key]\n        \n        frames = []\n        for frameid in self._frames.keys():\n            for frame in self._frames[frameid]:\n                frames.append(frame)\n        if orig_order:\n            key = (lambda frame: \n                   (0, frame.frameno) \n                   if frame.frameno is not None \n                   else (1,))\n        else:\n            key = self.frame_order.key\n        frames.sort(key=key)\n        return frames", "response": "Returns a list of frames in this tag."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _normalize_key(self, key, unknown_ok=True):\n        if Frames.is_frame_class(key):\n            key = key.frameid\n        if isinstance(key, str):\n            if not self._is_frame_id(key):\n                raise KeyError(\"{0}: Invalid frame id\".format(key))\n            if key not in self.known_frames:\n                if unknown_ok:\n                    warn(\"{0}: Unknown frame id\".format(key), UnknownFrameWarning)\n                else:\n                    raise KeyError(\"{0}: Unknown frame id\".format(key))\n        return key", "response": "Return the normalized version of KEY."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read(cls, filename, offset=0):\n        i = 0\n        with fileutil.opened(filename, \"rb\") as file:\n            file.seek(offset)\n            tag = cls()\n            tag._read_header(file)\n            for (frameid, bflags, data) in tag._read_frames(file):\n                if len(data) == 0:\n                    warn(\"{0}: Ignoring empty frame\".format(frameid), \n                         EmptyFrameWarning)\n                else:\n                    frame = tag._decode_frame(frameid, bflags, data, i)\n                    if frame is not None:\n                        l = tag._frames.setdefault(frame.frameid, [])\n                        l.append(frame)\n                        if file.tell() > tag.offset + tag.size:\n                            break\n                        i += 1\n            try:\n                tag._filename = file.name\n            except AttributeError:\n                pass\n            return tag", "response": "Read an ID3v2 tag from a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_email_grant(self, permission, email_address):\n        acl = self.get_acl()\n        acl.add_email_grant(permission, email_address)\n        self.set_acl(acl)", "response": "This method creates a new email grant for the given permission and email address."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_group_grant(self, permission, group_id):\n        acl = self.get_acl()\n        acl.add_group_grant(permission, group_id)\n        self.set_acl(acl)", "response": "This method creates a new group grant for the specified permission and group_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_contents_from_string(self, s, headers=None, replace=True,\n                                 cb=None, num_cb=10, policy=None, md5=None):\n        \"\"\"\n        Store an object in S3 using the name of the Key object as the\n        key in S3 and the string 's' as the contents.\n        See set_contents_from_file method for details about the\n        parameters.\n\n        :type headers: dict\n        :param headers: Additional headers to pass along with the\n                        request to AWS.\n\n        :type replace: bool\n        :param replace: If True, replaces the contents of the file if\n                        it already exists.\n\n        :type cb: function\n        :param cb: a callback function that will be called to report\n                   progress on the upload.  The callback should accept\n                   two integer parameters, the first representing the\n                   number of bytes that have been successfully\n                   transmitted to S3 and the second representing the\n                   size of the to be transmitted object.\n\n        :type cb: int\n        :param num_cb: (optional) If a callback is specified with\n                       the cb parameter this parameter determines the\n                       granularity of the callback by defining\n                       the maximum number of times the callback will\n                       be called during the file transfer.\n\n        :type policy: :class:`boto.s3.acl.CannedACLStrings`\n        :param policy: A canned ACL policy that will be applied to the\n                       new key in S3.\n\n        :type md5: A tuple containing the hexdigest version of the MD5\n                   checksum of the file as the first element and the\n                   Base64-encoded version of the plain checksum as the\n                   second element.  This is the same format returned by\n                   the compute_md5 method.\n        :param md5: If you need to compute the MD5 for any reason prior\n                    to upload, it's silly to have to do it twice so this\n                    param, if present, will be used as the MD5 values\n                    of the file.  Otherwise, the checksum will be computed.\n        \"\"\"\n        if isinstance(s, unicode):\n            s = s.encode(\"utf-8\")\n        fp = StringIO.StringIO(s)\n        r = self.set_contents_from_file(fp, headers, replace, cb, num_cb,\n                                        policy, md5)\n        fp.close()\n        return r", "response": "This method will store an object in S3 using the name of the object in S3 and the contents of the string s."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef describe_jobflow(self, jobflow_id):\n        jobflows = self.describe_jobflows(jobflow_ids=[jobflow_id])\n        if jobflows:\n            return jobflows[0]", "response": "Describe a single Elastic MapReduce job flow."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve all the Elastic MapReduce job flows on your account.", "response": "def describe_jobflows(self, states=None, jobflow_ids=None,\n                           created_after=None, created_before=None):\n        \"\"\"\n        Retrieve all the Elastic MapReduce job flows on your account\n\n        :type states: list\n        :param states: A list of strings with job flow states wanted\n\n        :type jobflow_ids: list\n        :param jobflow_ids: A list of job flow IDs\n        :type created_after: datetime\n        :param created_after: Bound on job flow creation time\n\n        :type created_before: datetime\n        :param created_before: Bound on job flow creation time\n        \"\"\"\n        params = {}\n\n        if states:\n            self.build_list_params(params, states, 'JobFlowStates.member')\n        if jobflow_ids:\n            self.build_list_params(params, jobflow_ids, 'JobFlowIds.member')\n        if created_after:\n            params['CreatedAfter'] = created_after.strftime(\n                boto.utils.ISO8601)\n        if created_before:\n            params['CreatedBefore'] = created_before.strftime(\n                boto.utils.ISO8601)\n\n        return self.get_list('DescribeJobFlows', params, [('member', JobFlow)])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nterminate an Elastic MapReduce job flow", "response": "def terminate_jobflows(self, jobflow_ids):\n        \"\"\"\n        Terminate an Elastic MapReduce job flow\n\n        :type jobflow_ids: list\n        :param jobflow_ids: A list of job flow IDs\n        \"\"\"\n        params = {}\n        self.build_list_params(params, jobflow_ids, 'JobFlowIds.member')\n        return self.get_status('TerminateJobFlows', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_jobflow_steps(self, jobflow_id, steps):\n        if type(steps) != types.ListType:\n            steps = [steps]\n        params = {}\n        params['JobFlowId'] = jobflow_id\n\n        # Step args\n        step_args = [self._build_step_args(step) for step in steps]\n        params.update(self._build_step_list(step_args))\n\n        return self.get_object(\n            'AddJobFlowSteps', params, RunJobFlowResponse, verb='POST')", "response": "Adds a list of steps to a job flow."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_instance_groups(self, jobflow_id, instance_groups):\n        if type(instance_groups) != types.ListType:\n            instance_groups = [instance_groups]\n        params = {}\n        params['JobFlowId'] = jobflow_id\n        params.update(self._build_instance_group_list_args(instance_groups))\n\n        return self.get_object('AddInstanceGroups', params,\n                               AddInstanceGroupsResponse, verb='POST')", "response": "Adds instance groups to a running cluster."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef modify_instance_groups(self, instance_group_ids, new_sizes):\n        if type(instance_group_ids) != types.ListType:\n            instance_group_ids = [instance_group_ids]\n        if type(new_sizes) != types.ListType:\n            new_sizes = [new_sizes]\n\n        instance_groups = zip(instance_group_ids, new_sizes)\n\n        params = {}\n        for k, ig in enumerate(instance_groups):\n            # could be wrong - the example amazon gives uses\n            # InstanceRequestCount, while the api documentation\n            # says InstanceCount\n            params['InstanceGroups.member.%d.InstanceGroupId' % (k+1) ] = ig[0]\n            params['InstanceGroups.member.%d.InstanceCount' % (k+1) ] = ig[1]\n\n        return self.get_object('ModifyInstanceGroups', params,\n                               ModifyInstanceGroupsResponse, verb='POST')", "response": "Modify the number of nodes and configuration settings in an instance group."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning a job flow :type name: str :param name: Name of the job flow :type log_uri: str :param log_uri: URI of the S3 bucket to place logs :type ec2_keyname: str :param ec2_keyname: EC2 key used for the instances :type availability_zone: str :param availability_zone: EC2 availability zone of the cluster :type master_instance_type: str :param master_instance_type: EC2 instance type of the master :type slave_instance_type: str :param slave_instance_type: EC2 instance type of the slave nodes :type num_instances: int :param num_instances: Number of instances in the Hadoop cluster :type action_on_failure: str :param action_on_failure: Action to take if a step terminates :type keep_alive: bool :param keep_alive: Denotes whether the cluster should stay alive upon completion :type enable_debugging: bool :param enable_debugging: Denotes whether AWS console debugging should be enabled. :type hadoop_version: str :param hadoop_version: Version of Hadoop to use. If ami_version is not set, defaults to '0.20' for backwards compatibility with older versions of boto. :type steps: list(boto.emr.Step) :param steps: List of steps to add with the job :type bootstrap_actions: list(boto.emr.BootstrapAction) :param bootstrap_actions: List of bootstrap actions that run before Hadoop starts. :type instance_groups: list(boto.emr.InstanceGroup) :param instance_groups: Optional list of instance groups to use when creating this job. NB: When provided, this argument supersedes num_instances and master/slave_instance_type. :type ami_version: str :param ami_version: Amazon Machine Image (AMI) version to use for instances. Values accepted by EMR are '1.0', '2.0', and 'latest'; EMR currently defaults to '1.0' if you don't set 'ami_version'. :type additional_info: JSON str :param additional_info: A JSON string for selecting additional features :type api_params: dict :param api_params: a dictionary of additional parameters to pass directly to the EMR API (so you don't have to upgrade boto to use new EMR features). You can also delete an API parameter by setting it to None. :rtype: str :return: The jobflow id", "response": "def run_jobflow(self, name, log_uri, ec2_keyname=None,\n                    availability_zone=None,\n                    master_instance_type='m1.small',\n                    slave_instance_type='m1.small', num_instances=1,\n                    action_on_failure='TERMINATE_JOB_FLOW', keep_alive=False,\n                    enable_debugging=False,\n                    hadoop_version=None,\n                    steps=[],\n                    bootstrap_actions=[],\n                    instance_groups=None,\n                    additional_info=None,\n                    ami_version=\"1.0\",\n                    api_params=None):\n        \"\"\"\n        Runs a job flow\n        :type name: str\n        :param name: Name of the job flow\n        \n        :type log_uri: str\n        :param log_uri: URI of the S3 bucket to place logs\n        \n        :type ec2_keyname: str\n        :param ec2_keyname: EC2 key used for the instances\n        \n        :type availability_zone: str\n        :param availability_zone: EC2 availability zone of the cluster\n        \n        :type master_instance_type: str\n        :param master_instance_type: EC2 instance type of the master\n        \n        :type slave_instance_type: str\n        :param slave_instance_type: EC2 instance type of the slave nodes\n        \n        :type num_instances: int\n        :param num_instances: Number of instances in the Hadoop cluster\n        \n        :type action_on_failure: str\n        :param action_on_failure: Action to take if a step terminates\n        \n        :type keep_alive: bool\n        :param keep_alive: Denotes whether the cluster should stay\n            alive upon completion\n            \n        :type enable_debugging: bool\n        :param enable_debugging: Denotes whether AWS console debugging\n            should be enabled.\n\n        :type hadoop_version: str\n        :param hadoop_version: Version of Hadoop to use. If ami_version\n            is not set, defaults to '0.20' for backwards compatibility\n            with older versions of boto.\n\n        :type steps: list(boto.emr.Step)\n        :param steps: List of steps to add with the job\n        \n        :type bootstrap_actions: list(boto.emr.BootstrapAction)\n        :param bootstrap_actions: List of bootstrap actions that run\n            before Hadoop starts.\n            \n        :type instance_groups: list(boto.emr.InstanceGroup)\n        :param instance_groups: Optional list of instance groups to\n            use when creating this job.\n            NB: When provided, this argument supersedes num_instances\n            and master/slave_instance_type.\n                \n        :type ami_version: str\n        :param ami_version: Amazon Machine Image (AMI) version to use\n            for instances. Values accepted by EMR are '1.0', '2.0', and\n            'latest'; EMR currently defaults to '1.0' if you don't set\n            'ami_version'.\n            \n        :type additional_info: JSON str\n        :param additional_info: A JSON string for selecting additional features\n\n        :type api_params: dict\n        :param api_params: a dictionary of additional parameters to pass\n            directly to the EMR API (so you don't have to upgrade boto to\n            use new EMR features). You can also delete an API parameter\n            by setting it to None.\n\n        :rtype: str\n        :return: The jobflow id\n        \"\"\"\n        # hadoop_version used to default to '0.20', but this won't work\n        # on later AMI versions, so only default if it ami_version isn't set.\n        if not (hadoop_version or ami_version):\n            hadoop_version = '0.20'\n\n        params = {}\n        if action_on_failure:\n            params['ActionOnFailure'] = action_on_failure\n        params['Name'] = name\n        params['LogUri'] = log_uri\n\n        # Common instance args\n        common_params = self._build_instance_common_args(ec2_keyname,\n                                                         availability_zone,\n                                                         keep_alive,\n                                                         hadoop_version)\n        params.update(common_params)\n\n        # NB: according to the AWS API's error message, we must\n        # \"configure instances either using instance count, master and\n        # slave instance type or instance groups but not both.\"\n        #\n        # Thus we switch here on the truthiness of instance_groups.\n        if not instance_groups:\n            # Instance args (the common case)\n            instance_params = self._build_instance_count_and_type_args(\n                                                        master_instance_type,\n                                                        slave_instance_type,\n                                                        num_instances)\n            params.update(instance_params)\n        else:\n            # Instance group args (for spot instances or a heterogenous cluster)\n            list_args = self._build_instance_group_list_args(instance_groups)\n            instance_params = dict(\n                ('Instances.%s' % k, v) for k, v in list_args.iteritems()\n                )\n            params.update(instance_params)\n\n        # Debugging step from EMR API docs\n        if enable_debugging:\n            debugging_step = JarStep(name='Setup Hadoop Debugging',\n                                     action_on_failure='TERMINATE_JOB_FLOW',\n                                     main_class=None,\n                                     jar=self.DebuggingJar,\n                                     step_args=self.DebuggingArgs)\n            steps.insert(0, debugging_step)\n\n        # Step args\n        if steps:\n            step_args = [self._build_step_args(step) for step in steps]\n            params.update(self._build_step_list(step_args))\n\n        if bootstrap_actions:\n            bootstrap_action_args = [self._build_bootstrap_action_args(bootstrap_action) for bootstrap_action in bootstrap_actions]\n            params.update(self._build_bootstrap_action_list(bootstrap_action_args))\n\n        if ami_version:\n            params['AmiVersion'] = ami_version\n\n        if additional_info is not None:\n            params['AdditionalInfo'] = additional_info\n\n        if api_params:\n            for key, value in api_params.iteritems():\n                if value is None:\n                    params.pop(key, None)\n                else:\n                    params[key] = value\n\n        response = self.get_object(\n            'RunJobFlow', params, RunJobFlowResponse, verb='POST')\n        return response.jobflowid"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_termination_protection(self, jobflow_id,\n                                   termination_protection_status):\n        \"\"\"\n        Set termination protection on specified Elastic MapReduce job flows\n\n        :type jobflow_ids: list or str\n        :param jobflow_ids: A list of job flow IDs\n        \n        :type termination_protection_status: bool\n        :param termination_protection_status: Termination protection status\n        \"\"\"\n        assert termination_protection_status in (True, False)\n\n        params = {}\n        params['TerminationProtected'] = (termination_protection_status and \"true\") or \"false\"\n        self.build_list_params(params, [jobflow_id], 'JobFlowIds.member')\n\n        return self.get_status('SetTerminationProtection', params, verb='POST')", "response": "Set termination protection on specified Elastic MapReduce job flows."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _build_instance_common_args(self, ec2_keyname, availability_zone,\n                                    keep_alive, hadoop_version):\n        \"\"\"\n        Takes a number of parameters used when starting a jobflow (as\n        specified in run_jobflow() above). Returns a comparable dict for\n        use in making a RunJobFlow request.\n        \"\"\"\n        params = {\n            'Instances.KeepJobFlowAliveWhenNoSteps' : str(keep_alive).lower(),\n        }\n\n        if hadoop_version:\n            params['Instances.HadoopVersion'] = hadoop_version\n        if ec2_keyname:\n            params['Instances.Ec2KeyName'] = ec2_keyname\n        if availability_zone:\n            params['Instances.Placement.AvailabilityZone'] = availability_zone\n\n        return params", "response": "Build common arguments for the instance creation of a jobflow."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _build_instance_count_and_type_args(self, master_instance_type,\n                                            slave_instance_type, num_instances):\n        \"\"\"\n        Takes a master instance type (string), a slave instance type\n        (string), and a number of instances. Returns a comparable dict\n        for use in making a RunJobFlow request.\n        \"\"\"\n        params = {\n            'Instances.MasterInstanceType' : master_instance_type,\n            'Instances.SlaveInstanceType' : slave_instance_type,\n            'Instances.InstanceCount' : num_instances,\n            }\n        return params", "response": "Builds the dict containing the master instance count and type of instances."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _build_instance_group_args(self, instance_group):\n        params = {\n            'InstanceCount' : instance_group.num_instances,\n            'InstanceRole' : instance_group.role,\n            'InstanceType' : instance_group.type,\n            'Name' : instance_group.name,\n            'Market' : instance_group.market\n        }\n        if instance_group.market == 'SPOT':\n            params['BidPrice'] = instance_group.bidprice\n        return params", "response": "Builds the dictionary of arguments for the GetInstanceGroups operation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntake a list of InstanceGroups or a single InstanceGroup. Returns a comparable dict for use in making a RunJobFlow or AddInstanceGroups request.", "response": "def _build_instance_group_list_args(self, instance_groups):\n        \"\"\"\n        Takes a list of InstanceGroups, or a single InstanceGroup. Returns\n        a comparable dict for use in making a RunJobFlow or AddInstanceGroups\n        request.\n        \"\"\"\n        if type(instance_groups) != types.ListType:\n            instance_groups = [instance_groups]\n\n        params = {}\n        for i, instance_group in enumerate(instance_groups):\n            ig_dict = self._build_instance_group_args(instance_group)\n            for key, value in ig_dict.iteritems():\n                params['InstanceGroups.member.%d.%s' % (i+1, key)] = value\n        return params"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a Python data structure with information about all the Hosted Zones defined for the AWS account.", "response": "def get_all_hosted_zones(self, start_marker=None, zone_list=None):\n        \"\"\"\n        Returns a Python data structure with information about all\n        Hosted Zones defined for the AWS account.\n\n        :param int start_marker: start marker to pass when fetching additional\n            results after a truncated list\n        :param list zone_list: a HostedZones list to prepend to results\n        \"\"\"\n        params = {}\n        if start_marker:\n            params = {'marker': start_marker}\n        response = self.make_request('GET', '/%s/hostedzone' % self.Version,\n                params=params)\n        body = response.read()\n        boto.log.debug(body)\n        if response.status >= 300:\n            raise exception.DNSServerError(response.status,\n                                           response.reason,\n                                           body)\n        e = boto.jsonresponse.Element(list_marker='HostedZones',\n                                      item_marker=('HostedZone',))\n        h = boto.jsonresponse.XmlHandler(e, None)\n        h.parse(body)\n        if zone_list:\n            e['ListHostedZonesResponse']['HostedZones'].extend(zone_list)\n        while e['ListHostedZonesResponse'].has_key('NextMarker'):\n            next_marker = e['ListHostedZonesResponse']['NextMarker']\n            zone_list = e['ListHostedZonesResponse']['HostedZones']\n            e = self.get_all_hosted_zones(next_marker, zone_list)\n        return e"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new Hosted Zone.", "response": "def create_hosted_zone(self, domain_name, caller_ref=None, comment=''):\n        \"\"\"\n        Create a new Hosted Zone.  Returns a Python data structure with\n        information about the newly created Hosted Zone.\n        \n        :type domain_name: str\n        :param domain_name: The name of the domain. This should be a\n            fully-specified domain, and should end with a final period\n            as the last label indication.  If you omit the final period,\n            Amazon Route 53 assumes the domain is relative to the root.\n            This is the name you have registered with your DNS registrar.\n            It is also the name you will delegate from your registrar to\n            the Amazon Route 53 delegation servers returned in\n            response to this request.A list of strings with the image\n            IDs wanted.\n\n        :type caller_ref: str\n        :param caller_ref: A unique string that identifies the request\n            and that allows failed CreateHostedZone requests to be retried\n            without the risk of executing the operation twice.  If you don't\n            provide a value for this, boto will generate a Type 4 UUID and\n            use that.\n\n        :type comment: str\n        :param comment: Any comments you want to include about the hosted      \n            zone.\n\n        \"\"\"\n        if caller_ref is None:\n            caller_ref = str(uuid.uuid4())\n        params = {'name' : domain_name,\n                  'caller_ref' : caller_ref,\n                  'comment' : comment,\n                  'xmlns' : self.XMLNameSpace}\n        xml = HZXML % params\n        uri = '/%s/hostedzone' % self.Version\n        response = self.make_request('POST', uri,\n                                     {'Content-Type' : 'text/xml'}, xml)\n        body = response.read()\n        boto.log.debug(body)\n        if response.status == 201:\n            e = boto.jsonresponse.Element(list_marker='NameServers',\n                                          item_marker=('NameServer',))\n            h = boto.jsonresponse.XmlHandler(e, None)\n            h.parse(body)\n            return e\n        else:\n            raise exception.DNSServerError(response.status,\n                                           response.reason,\n                                           body)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the resource record sets defined for this Hosted Zone.", "response": "def get_all_rrsets(self, hosted_zone_id, type=None,\n                       name=None, identifier=None, maxitems=None):\n        \"\"\"\n        Retrieve the Resource Record Sets defined for this Hosted Zone.\n        Returns the raw XML data returned by the Route53 call.\n        \n        :type hosted_zone_id: str\n        :param hosted_zone_id: The unique identifier for the Hosted Zone\n\n        :type type: str\n        :param type: The type of resource record set to begin the record\n            listing from.  Valid choices are:\n\n                * A\n                * AAAA\n                * CNAME\n                * MX\n                * NS\n                * PTR\n                * SOA\n                * SPF\n                * SRV\n                * TXT\n\n            Valid values for weighted resource record sets:\n\n                * A\n                * AAAA\n                * CNAME\n                * TXT\n\n            Valid values for Zone Apex Aliases:\n\n                * A\n                * AAAA\n\n        :type name: str\n        :param name: The first name in the lexicographic ordering of domain\n                     names to be retrieved\n\n        :type identifier: str\n        :param identifier: In a hosted zone that includes weighted resource\n            record sets (multiple resource record sets with the same DNS\n            name and type that are differentiated only by SetIdentifier),\n            if results were truncated for a given DNS name and type,\n            the value of SetIdentifier for the next resource record\n            set that has the current DNS name and type\n\n        :type maxitems: int\n        :param maxitems: The maximum number of records\n\n        \"\"\"\n        from boto.route53.record import ResourceRecordSets\n        params = {'type': type, 'name': name,\n                  'Identifier': identifier, 'maxitems': maxitems}\n        uri = '/%s/hostedzone/%s/rrset' % (self.Version, hosted_zone_id)\n        response = self.make_request('GET', uri, params=params)\n        body = response.read()\n        boto.log.debug(body)\n        if response.status >= 300:\n            raise exception.DNSServerError(response.status,\n                                           response.reason,\n                                           body)\n        rs = ResourceRecordSets(connection=self, hosted_zone_id=hosted_zone_id)\n        h = handler.XmlHandler(rs, self)\n        xml.sax.parseString(body, h)\n        return rs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting information about a proposed set of changes.", "response": "def get_change(self, change_id):\n        \"\"\"\n        Get information about a proposed set of changes, as submitted\n        by the change_rrsets method.\n        Returns a Python data structure with status information about the\n        changes.\n\n        :type change_id: str\n        :param change_id: The unique identifier for the set of changes.\n            This ID is returned in the response to the change_rrsets method.\n\n        \"\"\"\n        uri = '/%s/change/%s' % (self.Version, change_id)\n        response = self.make_request('GET', uri)\n        body = response.read()\n        boto.log.debug(body)\n        if response.status >= 300:\n            raise exception.DNSServerError(response.status,\n                                           response.reason,\n                                           body)\n        e = boto.jsonresponse.Element()\n        h = boto.jsonresponse.XmlHandler(e, None)\n        h.parse(body)\n        return e"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_best_instruction(addr, cpu_name, meta=None):\n    addr = rv = parse_addr(addr)\n\n    # In case we're not on the crashing frame we apply a simple heuristic:\n    # since we're most likely dealing with return addresses we just assume\n    # that the call is one instruction behind the current one.\n    if not meta or meta.get('frame_number') != 0:\n        rv = get_previous_instruction(addr, cpu_name)\n\n    # In case registers are available we can check if the PC register\n    # does not match the given address we have from the first frame.\n    # If that is the case and we got one of a few signals taht are likely\n    # it seems that going with one instruction back is actually the\n    # correct thing to do.\n    else:\n        regs = meta.get('registers')\n        ip = get_ip_register(regs, cpu_name)\n        if ip is not None and ip != addr and \\\n           meta.get('signal') in (SIGILL, SIGBUS, SIGSEGV):\n            rv = get_previous_instruction(addr, cpu_name)\n\n    # Don't ask me why we do this, but apparently on arm we get better\n    # hits if we look at the end of an instruction in the DWARF file than\n    # the beginning.\n    return round_to_instruction_end(rv, cpu_name)", "response": "Given an instruction and meta information this attempts to find the best instruction for the frame."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists key objects within a bucket. This returns an instance of an BucketListResultSet that automatically handles all of the result paging, etc. from S3. You just need to keep iterating until there are no more results. Called with no arguments, this will return an iterator object across all keys within the bucket. The Key objects returned by the iterator are obtained by parsing the results of a GET on the bucket, also known as the List Objects request. The XML returned by this request contains only a subset of the information about each key. Certain metadata fields such as Content-Type and user metadata are not available in the XML. Therefore, if you want these additional metadata fields you will have to do a HEAD request on the Key in the bucket. :type prefix: string :param prefix: allows you to limit the listing to a particular prefix. For example, if you call the method with prefix='/foo/' then the iterator will only cycle through the keys that begin with the string '/foo/'. :type delimiter: string :param delimiter: can be used in conjunction with the prefix to allow you to organize and browse your keys hierarchically. See: http://docs.amazonwebservices.com/AmazonS3/2006-03-01/ for more details. :type marker: string :param marker: The \"marker\" of where you are in the result set :rtype: :class:`boto.s3.bucketlistresultset.BucketListResultSet` :return: an instance of a BucketListResultSet that handles paging, etc", "response": "def list(self, prefix='', delimiter='', marker='', headers=None):\n        \"\"\"\n        List key objects within a bucket.  This returns an instance of an\n        BucketListResultSet that automatically handles all of the result\n        paging, etc. from S3.  You just need to keep iterating until\n        there are no more results.\n        \n        Called with no arguments, this will return an iterator object across\n        all keys within the bucket.\n\n        The Key objects returned by the iterator are obtained by parsing\n        the results of a GET on the bucket, also known as the List Objects\n        request.  The XML returned by this request contains only a subset\n        of the information about each key.  Certain metadata fields such\n        as Content-Type and user metadata are not available in the XML.\n        Therefore, if you want these additional metadata fields you will\n        have to do a HEAD request on the Key in the bucket.\n        \n        :type prefix: string\n        :param prefix: allows you to limit the listing to a particular\n                        prefix.  For example, if you call the method with\n                        prefix='/foo/' then the iterator will only cycle\n                        through the keys that begin with the string '/foo/'.\n                        \n        :type delimiter: string\n        :param delimiter: can be used in conjunction with the prefix\n                        to allow you to organize and browse your keys\n                        hierarchically. See:\n                        http://docs.amazonwebservices.com/AmazonS3/2006-03-01/\n                        for more details.\n                        \n        :type marker: string\n        :param marker: The \"marker\" of where you are in the result set\n        \n        :rtype: :class:`boto.s3.bucketlistresultset.BucketListResultSet`\n        :return: an instance of a BucketListResultSet that handles paging, etc\n        \"\"\"\n        return BucketListResultSet(self, prefix, delimiter, marker, headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_versions(self, prefix='', delimiter='', key_marker='',\n                      version_id_marker='', headers=None):\n        \"\"\"\n        List version objects within a bucket.  This returns an instance of an\n        VersionedBucketListResultSet that automatically handles all of the result\n        paging, etc. from S3.  You just need to keep iterating until\n        there are no more results.\n        Called with no arguments, this will return an iterator object across\n        all keys within the bucket.\n        \n        :type prefix: string\n        :param prefix: allows you to limit the listing to a particular\n                        prefix.  For example, if you call the method with\n                        prefix='/foo/' then the iterator will only cycle\n                        through the keys that begin with the string '/foo/'.\n                        \n        :type delimiter: string\n        :param delimiter: can be used in conjunction with the prefix\n                        to allow you to organize and browse your keys\n                        hierarchically. See:\n                        http://docs.amazonwebservices.com/AmazonS3/2006-03-01/\n                        for more details.\n                        \n        :type marker: string\n        :param marker: The \"marker\" of where you are in the result set\n        \n        :rtype: :class:`boto.s3.bucketlistresultset.BucketListResultSet`\n        :return: an instance of a BucketListResultSet that handles paging, etc\n        \"\"\"\n        return VersionedBucketListResultSet(self, prefix, delimiter, key_marker,\n                                            version_id_marker, headers)", "response": "This method returns an iterator object across all of the version objects within a bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_multipart_uploads(self, key_marker='',\n                               upload_id_marker='',\n                               headers=None):\n        \"\"\"\n        List multipart upload objects within a bucket.  This returns an\n        instance of an MultiPartUploadListResultSet that automatically\n        handles all of the result paging, etc. from S3.  You just need\n        to keep iterating until there are no more results.\n        \n        :type marker: string\n        :param marker: The \"marker\" of where you are in the result set\n        \n        :rtype: :class:`boto.s3.bucketlistresultset.BucketListResultSet`\n        :return: an instance of a BucketListResultSet that handles paging, etc\n        \"\"\"\n        return MultiPartUploadListResultSet(self, key_marker,\n                                            upload_id_marker,\n                                            headers)", "response": "This method returns an instance of a BucketListResultSet that automatically handles all of the multipart uploads from S3."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete a set of keys from the S3 bucket using the Multi - Object Delete API.", "response": "def delete_keys(self, keys, quiet=False, mfa_token=None, headers=None):\n        \"\"\"\n        Deletes a set of keys using S3's Multi-object delete API. If a\n        VersionID is specified for that key then that version is removed.\n        Returns a MultiDeleteResult Object, which contains Deleted\n        and Error elements for each key you ask to delete.\n        \n        :type keys: list\n        :param keys: A list of either key_names or (key_name, versionid) pairs\n                     or a list of Key instances.\n\n        :type quiet: boolean\n        :param quiet: In quiet mode the response includes only keys where\n                      the delete operation encountered an error. For a\n                      successful deletion, the operation does not return\n                      any information about the delete in the response body.\n\n        :type mfa_token: tuple or list of strings\n        :param mfa_token: A tuple or list consisting of the serial number\n                          from the MFA device and the current value of\n                          the six-digit token associated with the device.\n                          This value is required anytime you are\n                          deleting versioned objects from a bucket\n                          that has the MFADelete option on the bucket.\n\n        :returns: An instance of MultiDeleteResult\n        \"\"\"\n        ikeys = iter(keys)\n        result = MultiDeleteResult(self)\n        provider = self.connection.provider\n        query_args = 'delete'\n        def delete_keys2(hdrs):\n            hdrs = hdrs or {}\n            data = u\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\"\"\"\n            data += u\"<Delete>\"\n            if quiet:\n                data += u\"<Quiet>true</Quiet>\"\n            count = 0\n            while count < 1000:\n                try:\n                    key = ikeys.next()\n                except StopIteration:\n                    break\n                if isinstance(key, basestring):\n                    key_name = key\n                    version_id = None\n                elif isinstance(key, tuple) and len(key) == 2:\n                    key_name, version_id = key\n                elif (isinstance(key, Key) or isinstance(key, DeleteMarker)) and key.name:\n                    key_name = key.name\n                    version_id = key.version_id\n                else:\n                    if isinstance(key, Prefix):\n                        key_name = key.name\n                        code = 'PrefixSkipped'   # Don't delete Prefix\n                    else:\n                        key_name = repr(key)     # try get a string\n                        code = 'InvalidArgument' # other unknown type\n                    message = 'Invalid. No delete action taken for this object.'\n                    error = Error(key_name, code=code, message=message)\n                    result.errors.append(error)\n                    continue\n                count += 1\n                #key_name = key_name.decode('utf-8')\n                data += u\"<Object><Key>%s</Key>\" % xml.sax.saxutils.escape(key_name)\n                if version_id:\n                    data += u\"<VersionId>%s</VersionId>\" % version_id\n                data += u\"</Object>\"\n            data += u\"</Delete>\"\n            if count <= 0:\n                return False # no more\n            data = data.encode('utf-8')\n            fp = StringIO.StringIO(data)\n            md5 = boto.utils.compute_md5(fp)\n            hdrs['Content-MD5'] = md5[1]\n            hdrs['Content-Type'] = 'text/xml'\n            if mfa_token:\n                hdrs[provider.mfa_header] = ' '.join(mfa_token)\n            response = self.connection.make_request('POST', self.name,\n                                                    headers=hdrs,\n                                                    query_args=query_args,\n                                                    data=data)\n            body = response.read()\n            if response.status == 200:\n                h = handler.XmlHandler(result, self)\n                xml.sax.parseString(body, h)\n                return count >= 1000 # more?\n            else:\n                raise provider.storage_response_error(response.status,\n                                                      response.reason,\n                                                      body)\n        while delete_keys2(headers):\n            pass\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy_key(self, new_key_name, src_bucket_name,\n                 src_key_name, metadata=None, src_version_id=None,\n                 storage_class='STANDARD', preserve_acl=False,\n                 encrypt_key=False, headers=None, query_args=None):\n        \"\"\"\n        Create a new key in the bucket by copying another existing key.\n\n        :type new_key_name: string\n        :param new_key_name: The name of the new key\n\n        :type src_bucket_name: string\n        :param src_bucket_name: The name of the source bucket\n\n        :type src_key_name: string\n        :param src_key_name: The name of the source key\n\n        :type src_version_id: string\n        :param src_version_id: The version id for the key.  This param\n                               is optional.  If not specified, the newest\n                               version of the key will be copied.\n\n        :type metadata: dict\n        :param metadata: Metadata to be associated with new key.\n                         If metadata is supplied, it will replace the\n                         metadata of the source key being copied.\n                         If no metadata is supplied, the source key's\n                         metadata will be copied to the new key.\n\n        :type storage_class: string\n        :param storage_class: The storage class of the new key.\n                              By default, the new key will use the\n                              standard storage class.  Possible values are:\n                              STANDARD | REDUCED_REDUNDANCY\n\n        :type preserve_acl: bool\n        :param preserve_acl: If True, the ACL from the source key\n                             will be copied to the destination\n                             key.  If False, the destination key\n                             will have the default ACL.\n                             Note that preserving the ACL in the\n                             new key object will require two\n                             additional API calls to S3, one to\n                             retrieve the current ACL and one to\n                             set that ACL on the new object.  If\n                             you don't care about the ACL, a value\n                             of False will be significantly more\n                             efficient.\n\n        :type encrypt_key: bool\n        :param encrypt_key: If True, the new copy of the object will\n                            be encrypted on the server-side by S3 and\n                            will be stored in an encrypted form while\n                            at rest in S3.\n\n        :type headers: dict\n        :param headers: A dictionary of header name/value pairs.\n\n        :type query_args: string\n        :param query_args: A string of additional querystring arguments\n                           to append to the request\n\n        :rtype: :class:`boto.s3.key.Key` or subclass\n        :returns: An instance of the newly created key object\n        \"\"\"\n        headers = headers or {}\n        provider = self.connection.provider\n        src_key_name = boto.utils.get_utf8_value(src_key_name)\n        if preserve_acl:\n            if self.name == src_bucket_name:\n                src_bucket = self\n            else:\n                src_bucket = self.connection.get_bucket(src_bucket_name)\n            acl = src_bucket.get_xml_acl(src_key_name)\n        if encrypt_key:\n            headers[provider.server_side_encryption_header] = 'AES256'\n        src = '%s/%s' % (src_bucket_name, urllib.quote(src_key_name))\n        if src_version_id:\n            src += '?versionId=%s' % src_version_id\n        headers[provider.copy_source_header] = str(src)\n        # make sure storage_class_header key exists before accessing it\n        if provider.storage_class_header and storage_class:\n            headers[provider.storage_class_header] = storage_class\n        if metadata:\n            headers[provider.metadata_directive_header] = 'REPLACE'\n            headers = boto.utils.merge_meta(headers, metadata, provider)\n        elif not query_args: # Can't use this header with multi-part copy.\n            headers[provider.metadata_directive_header] = 'COPY'\n        response = self.connection.make_request('PUT', self.name, new_key_name,\n                                                headers=headers,\n                                                query_args=query_args)\n        body = response.read()\n        if response.status == 200:\n            key = self.new_key(new_key_name)\n            h = handler.XmlHandler(key, self)\n            xml.sax.parseString(body, h)\n            if hasattr(key, 'Error'):\n                raise provider.storage_copy_error(key.Code, key.Message, body)\n            key.handle_version_headers(response)\n            if preserve_acl:\n                self.set_xml_acl(acl, new_key_name)\n            return key\n        else:\n            raise provider.storage_response_error(response.status,\n                                                  response.reason, body)", "response": "Copy a key from one bucket to another."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets a subresource for a bucket or key.", "response": "def set_subresource(self, subresource, value, key_name = '', headers=None,\n                        version_id=None):\n        \"\"\"\n        Set a subresource for a bucket or key.\n\n        :type subresource: string\n        :param subresource: The subresource to set.\n\n        :type value: string\n        :param value: The value of the subresource.\n\n        :type key_name: string\n        :param key_name: The key to operate on, or None to operate on the\n                         bucket.\n\n        :type headers: dict\n        :param headers: Additional HTTP headers to include in the request.\n\n        :type src_version_id: string\n        :param src_version_id: Optional. The version id of the key to operate\n                               on. If not specified, operate on the newest\n                               version.\n        \"\"\"\n        if not subresource:\n            raise TypeError('set_subresource called with subresource=None')\n        query_args = subresource\n        if version_id:\n            query_args += '&versionId=%s' % version_id\n        response = self.connection.make_request('PUT', self.name, key_name,\n                                                data=value.encode('UTF-8'),\n                                                query_args=query_args,\n                                                headers=headers)\n        body = response.read()\n        if response.status != 200:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a subresource for a bucket or key.", "response": "def get_subresource(self, subresource, key_name='', headers=None,\n                        version_id=None):\n        \"\"\"\n        Get a subresource for a bucket or key.\n\n        :type subresource: string\n        :param subresource: The subresource to get.\n\n        :type key_name: string\n        :param key_name: The key to operate on, or None to operate on the\n                         bucket.\n\n        :type headers: dict\n        :param headers: Additional HTTP headers to include in the request.\n\n        :type src_version_id: string\n        :param src_version_id: Optional. The version id of the key to operate\n                               on. If not specified, operate on the newest\n                               version.\n\n        :rtype: string\n        :returns: The value of the subresource.\n        \"\"\"\n        if not subresource:\n            raise TypeError('get_subresource called with subresource=None')\n        query_args = subresource\n        if version_id:\n            query_args += '&versionId=%s' % version_id\n        response = self.connection.make_request('GET', self.name, key_name,\n                                                query_args=query_args,\n                                                headers=headers)\n        body = response.read()\n        if response.status != 200:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)\n        return body"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_email_grant(self, permission, email_address,\n                        recursive=False, headers=None):\n        \"\"\"\n        Convenience method that provides a quick way to add an email grant\n        to a bucket. This method retrieves the current ACL, creates a new\n        grant based on the parameters passed in, adds that grant to the ACL\n        and then PUT's the new ACL back to S3.\n        \n        :type permission: string\n        :param permission: The permission being granted. Should be one of:\n                           (READ, WRITE, READ_ACP, WRITE_ACP, FULL_CONTROL).\n        \n        :type email_address: string\n        :param email_address: The email address associated with the AWS\n                              account your are granting the permission to.\n        \n        :type recursive: boolean\n        :param recursive: A boolean value to controls whether the command\n                          will apply the grant to all keys within the bucket\n                          or not.  The default value is False.  By passing a\n                          True value, the call will iterate through all keys\n                          in the bucket and apply the same grant to each key.\n                          CAUTION: If you have a lot of keys, this could take\n                          a long time!\n        \"\"\"\n        if permission not in S3Permissions:\n            raise self.connection.provider.storage_permissions_error(\n                'Unknown Permission: %s' % permission)\n        policy = self.get_acl(headers=headers)\n        policy.acl.add_email_grant(permission, email_address)\n        self.set_acl(policy, headers=headers)\n        if recursive:\n            for key in self:\n                key.add_email_grant(permission, email_address, headers=headers)", "response": "This method creates a new ACL and adds an email grant to all keys in the bucket."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_user_grant(self, permission, user_id, recursive=False,\n                       headers=None, display_name=None):\n        \"\"\"\n        Convenience method that provides a quick way to add a canonical\n        user grant to a bucket.  This method retrieves the current ACL,\n        creates a new grant based on the parameters passed in, adds that\n        grant to the ACL and then PUT's the new ACL back to S3.\n        \n        :type permission: string\n        :param permission: The permission being granted. Should be one of:\n                           (READ, WRITE, READ_ACP, WRITE_ACP, FULL_CONTROL).\n        \n        :type user_id: string\n        :param user_id:     The canonical user id associated with the AWS\n                            account your are granting the permission to.\n                            \n        :type recursive: boolean\n        :param recursive: A boolean value to controls whether the command\n                          will apply the grant to all keys within the bucket\n                          or not.  The default value is False.  By passing a\n                          True value, the call will iterate through all keys\n                          in the bucket and apply the same grant to each key.\n                          CAUTION: If you have a lot of keys, this could take\n                          a long time!\n                          \n        :type display_name: string\n        :param display_name: An option string containing the user's\n                             Display Name.  Only required on Walrus.\n        \"\"\"\n        if permission not in S3Permissions:\n            raise self.connection.provider.storage_permissions_error(\n                'Unknown Permission: %s' % permission)\n        policy = self.get_acl(headers=headers)\n        policy.acl.add_user_grant(permission, user_id,\n                                  display_name=display_name)\n        self.set_acl(policy, headers=headers)\n        if recursive:\n            for key in self:\n                key.add_user_grant(permission, user_id, headers=headers,\n                                   display_name=display_name)", "response": "This method adds a user grant to a bucket."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the LocationConstraint for the bucket.", "response": "def get_location(self):\n        \"\"\"\n        Returns the LocationConstraint for the bucket.\n\n        :rtype: str\n        :return: The LocationConstraint for the bucket or the empty\n                 string if no constraint was specified when bucket\n                 was created.\n        \"\"\"\n        response = self.connection.make_request('GET', self.name,\n                                                query_args='location')\n        body = response.read()\n        if response.status == 200:\n            rs = ResultSet(self)\n            h = handler.XmlHandler(rs, self)\n            xml.sax.parseString(body, h)\n            return rs.LocationConstraint\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure_versioning(self, versioning, mfa_delete=False,\n                             mfa_token=None, headers=None):\n        \"\"\"\n        Configure versioning for this bucket.\n        \n        ..note:: This feature is currently in beta.\n                 \n        :type versioning: bool\n        :param versioning: A boolean indicating whether version is\n                           enabled (True) or disabled (False).\n\n        :type mfa_delete: bool\n        :param mfa_delete: A boolean indicating whether the Multi-Factor\n                           Authentication Delete feature is enabled (True)\n                           or disabled (False).  If mfa_delete is enabled\n                           then all Delete operations will require the\n                           token from your MFA device to be passed in\n                           the request.\n\n        :type mfa_token: tuple or list of strings\n        :param mfa_token: A tuple or list consisting of the serial number\n                          from the MFA device and the current value of\n                          the six-digit token associated with the device.\n                          This value is required when you are changing\n                          the status of the MfaDelete property of\n                          the bucket.\n        \"\"\"\n        if versioning:\n            ver = 'Enabled'\n        else:\n            ver = 'Suspended'\n        if mfa_delete:\n            mfa = 'Enabled'\n        else:\n            mfa = 'Disabled'\n        body = self.VersioningBody % (ver, mfa)\n        if mfa_token:\n            if not headers:\n                headers = {}\n            provider = self.connection.provider\n            headers[provider.mfa_header] = ' '.join(mfa_token)\n        response = self.connection.make_request('PUT', self.name, data=body,\n                query_args='versioning', headers=headers)\n        body = response.read()\n        if response.status == 200:\n            return True\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)", "response": "Configure versioning for this bucket."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the current status of versioning on the bucket.", "response": "def get_versioning_status(self, headers=None):\n        \"\"\"\n        Returns the current status of versioning on the bucket.\n\n        :rtype: dict\n        :returns: A dictionary containing a key named 'Versioning'\n                  that can have a value of either Enabled, Disabled,\n                  or Suspended. Also, if MFADelete has ever been enabled\n                  on the bucket, the dictionary will contain a key\n                  named 'MFADelete' which will have a value of either\n                  Enabled or Suspended.\n        \"\"\"\n        response = self.connection.make_request('GET', self.name,\n                query_args='versioning', headers=headers)\n        body = response.read()\n        boto.log.debug(body)\n        if response.status == 200:\n            d = {}\n            ver = re.search(self.VersionRE, body)\n            if ver:\n                d['Versioning'] = ver.group(1)\n            mfa = re.search(self.MFADeleteRE, body)\n            if mfa:\n                d['MfaDelete'] = mfa.group(1)\n            return d\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconfiguring the lifecycle for this bucket.", "response": "def configure_lifecycle(self, lifecycle_config, headers=None):\n        \"\"\"\n        Configure lifecycle for this bucket.\n        \n        :type lifecycle_config: :class:`boto.s3.lifecycle.Lifecycle`\n        :param lifecycle_config: The lifecycle configuration you want\n            to configure for this bucket.\n        \"\"\"\n        fp = StringIO.StringIO(lifecycle_config.to_xml())\n        md5 = boto.utils.compute_md5(fp)\n        if headers is None:\n            headers = {}\n        headers['Content-MD5'] = md5[1]\n        headers['Content-Type'] = 'text/xml'\n        response = self.connection.make_request('PUT', self.name,\n                                                data=fp.getvalue(),\n                                                query_args='lifecycle',\n                                                headers=headers)\n        body = response.read()\n        if response.status == 200:\n            return True\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_lifecycle_config(self, headers=None):\n        response = self.connection.make_request('GET', self.name,\n                query_args='lifecycle', headers=headers)\n        body = response.read()\n        boto.log.debug(body)\n        if response.status == 200:\n            lifecycle = Lifecycle(self)\n            h = handler.XmlHandler(lifecycle, self)\n            xml.sax.parseString(body, h)\n            return lifecycle\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)", "response": "Returns the current lifecycle configuration on the bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure_website(self, suffix, error_key='', headers=None):\n        if error_key:\n            error_frag = self.WebsiteErrorFragment % error_key\n        else:\n            error_frag = ''\n        body = self.WebsiteBody % (suffix, error_frag)\n        response = self.connection.make_request('PUT', self.name, data=body,\n                                                query_args='website',\n                                                headers=headers)\n        body = response.read()\n        if response.status == 200:\n            return True\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)", "response": "Configure this bucket to act as a website."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_website_configuration(self, headers=None):\n        response = self.connection.make_request('GET', self.name,\n                query_args='website', headers=headers)\n        body = response.read()\n        boto.log.debug(body)\n        if response.status == 200:\n            e = boto.jsonresponse.Element()\n            h = boto.jsonresponse.XmlHandler(e, None)\n            h.parse(body)\n            return e\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)", "response": "Returns the current status of website configuration on the bucket."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting all website configuration from the bucket.", "response": "def delete_website_configuration(self, headers=None):\n        \"\"\"\n        Removes all website configuration from the bucket.\n        \"\"\"\n        response = self.connection.make_request('DELETE', self.name,\n                query_args='website', headers=headers)\n        body = response.read()\n        boto.log.debug(body)\n        if response.status == 204:\n            return True\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_website_endpoint(self):\n        l = [self.name]\n        l.append(S3WebsiteEndpointTranslate.translate_region(self.get_location()))\n        l.append('.'.join(self.connection.host.split('.')[-2:]))\n        return '.'.join(l)", "response": "Returns the fully qualified hostname to use is you want to access this\n        bucket as a website."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_policy(self, policy, headers=None):\n        response = self.connection.make_request('PUT', self.name,\n                                                data=policy,\n                                                query_args='policy',\n                                                headers=headers)\n        body = response.read()\n        if response.status >= 200 and response.status <= 204:\n            return True\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)", "response": "Add or replace the JSON policy associated with the bucket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef initiate_multipart_upload(self, key_name, headers=None,\n                                  reduced_redundancy=False,\n                                  metadata=None, encrypt_key=False):\n        \"\"\"\n        Start a multipart upload operation.\n\n        :type key_name: string\n        :param key_name: The name of the key that will ultimately result from\n                         this multipart upload operation.  This will be exactly\n                         as the key appears in the bucket after the upload\n                         process has been completed.\n\n        :type headers: dict\n        :param headers: Additional HTTP headers to send and store with the\n                        resulting key in S3.\n\n        :type reduced_redundancy: boolean\n        :param reduced_redundancy: In multipart uploads, the storage class is\n                                   specified when initiating the upload,\n                                   not when uploading individual parts.  So\n                                   if you want the resulting key to use the\n                                   reduced redundancy storage class set this\n                                   flag when you initiate the upload.\n\n        :type metadata: dict\n        :param metadata: Any metadata that you would like to set on the key\n                         that results from the multipart upload.\n                         \n        :type encrypt_key: bool\n        :param encrypt_key: If True, the new copy of the object will\n                            be encrypted on the server-side by S3 and\n                            will be stored in an encrypted form while\n                            at rest in S3.\n        \"\"\"\n        query_args = 'uploads'\n        provider = self.connection.provider\n        if headers is None:\n            headers = {}\n        if reduced_redundancy:\n            storage_class_header = provider.storage_class_header\n            if storage_class_header:\n                headers[storage_class_header] = 'REDUCED_REDUNDANCY'\n            # TODO: what if the provider doesn't support reduced redundancy?\n            # (see boto.s3.key.Key.set_contents_from_file)\n        if encrypt_key:\n            headers[provider.server_side_encryption_header] = 'AES256'\n        if metadata is None:\n            metadata = {}\n\n        headers = boto.utils.merge_meta(headers, metadata,\n                self.connection.provider)\n        response = self.connection.make_request('POST', self.name, key_name,\n                                                query_args=query_args,\n                                                headers=headers)\n        body = response.read()\n        boto.log.debug(body)\n        if response.status == 200:\n            resp = MultiPartUpload(self)\n            h = handler.XmlHandler(resp, self)\n            xml.sax.parseString(body, h)\n            return resp\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)", "response": "Initiate a multipart upload operation."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncompletes a multipart upload operation.", "response": "def complete_multipart_upload(self, key_name, upload_id,\n                                  xml_body, headers=None):\n        \"\"\"\n        Complete a multipart upload operation.\n        \"\"\"\n        query_args = 'uploadId=%s' % upload_id\n        if headers is None:\n            headers = {}\n        headers['Content-Type'] = 'text/xml'\n        response = self.connection.make_request('POST', self.name, key_name,\n                                                query_args=query_args,\n                                                headers=headers, data=xml_body)\n        contains_error = False\n        body = response.read()\n        # Some errors will be reported in the body of the response\n        # even though the HTTP response code is 200.  This check\n        # does a quick and dirty peek in the body for an error element.\n        if body.find('<Error>') > 0:\n            contains_error = True\n        boto.log.debug(body)\n        if response.status == 200 and not contains_error:\n            resp = CompleteMultiPartUpload(self)\n            h = handler.XmlHandler(resp, self)\n            xml.sax.parseString(body, h)\n            return resp\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a connection from the pool for the named host. Returns None if there is no connection.", "response": "def get_http_connection(self, host, is_secure):\n        \"\"\"\n        Gets a connection from the pool for the named host.  Returns\n        None if there is no connection that can be reused.\n        \"\"\"\n        if is_secure:\n            return AsyncHTTPSConnection(host, http_client=self._httpclient)\n        else:\n            return AsyncHTTPConnection(host, http_client=self._httpclient)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nverify the authenticity of a notification message.", "response": "def verify(self, secret_key):\n        \"\"\"\n        Verifies the authenticity of a notification message.\n\n        TODO: This is doing a form of authentication and\n              this functionality should really be merged\n              with the pluggable authentication mechanism\n              at some point.\n        \"\"\"\n        verification_input = NotificationMessage.SERVICE_NAME\n        verification_input += NotificationMessage.OPERATION_NAME\n        verification_input += self.timestamp\n        h = hmac.new(key=secret_key, digestmod=sha)\n        h.update(verification_input)\n        signature_calc = base64.b64encode(h.digest())\n        return self.signature == signature_calc"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, validate=False):\n        rs = self.connection.get_all_images([self.id])\n        if len(rs) > 0:\n            img = rs[0]\n            if img.id == self.id:\n                self._update(img)\n        elif validate:\n            raise ValueError('%s is not a valid Image ID' % self.id)\n        return self.state", "response": "Update the state of the image by making a call to fetch\n getCacheKey the current image attributes from the service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, min_count=1, max_count=1, key_name=None, \n            security_groups=None, user_data=None,\n            addressing_type=None, instance_type='m1.small', placement=None,\n            kernel_id=None, ramdisk_id=None,\n            monitoring_enabled=False, subnet_id=None,\n            block_device_map=None,\n            disable_api_termination=False,\n            instance_initiated_shutdown_behavior=None,\n            private_ip_address=None,\n            placement_group=None, security_group_ids=None):\n        \"\"\"\n        Runs this instance.\n        \n        :type min_count: int\n        :param min_count: The minimum number of instances to start\n        \n        :type max_count: int\n        :param max_count: The maximum number of instances to start\n        \n        :type key_name: string\n        :param key_name: The name of the keypair to run this instance with.\n        \n        :type security_groups: \n        :param security_groups:\n        \n        :type user_data: \n        :param user_data:\n        \n        :type addressing_type: \n        :param daddressing_type:\n        \n        :type instance_type: string\n        :param instance_type: The type of instance to run.  Current choices are:\n                              m1.small | m1.large | m1.xlarge | c1.medium |\n                              c1.xlarge | m2.xlarge | m2.2xlarge |\n                              m2.4xlarge | cc1.4xlarge\n        \n        :type placement: string\n        :param placement: The availability zone in which to launch the instances\n\n        :type kernel_id: string\n        :param kernel_id: The ID of the kernel with which to launch the instances\n        \n        :type ramdisk_id: string\n        :param ramdisk_id: The ID of the RAM disk with which to launch the instances\n        \n        :type monitoring_enabled: bool\n        :param monitoring_enabled: Enable CloudWatch monitoring on the instance.\n        \n        :type subnet_id: string\n        :param subnet_id: The subnet ID within which to launch the instances for VPC.\n        \n        :type private_ip_address: string\n        :param private_ip_address: If you're using VPC, you can optionally use\n                                   this parameter to assign the instance a\n                                   specific available IP address from the\n                                   subnet (e.g., 10.0.0.25).\n\n        :type block_device_map: :class:`boto.ec2.blockdevicemapping.BlockDeviceMapping`\n        :param block_device_map: A BlockDeviceMapping data structure\n                                 describing the EBS volumes associated\n                                 with the Image.\n\n        :type disable_api_termination: bool\n        :param disable_api_termination: If True, the instances will be locked\n                                        and will not be able to be terminated\n                                        via the API.\n\n        :type instance_initiated_shutdown_behavior: string\n        :param instance_initiated_shutdown_behavior: Specifies whether the instance\n                                                     stops or terminates on instance-initiated\n                                                     shutdown. Valid values are:\n                                                     stop | terminate\n\n        :type placement_group: string\n        :param placement_group: If specified, this is the name of the placement\n                                group in which the instance(s) will be launched.\n\n        :rtype: Reservation\n        :return: The :class:`boto.ec2.instance.Reservation` associated with the request for machines\n\n        :type security_group_ids: \n        :param security_group_ids:\n        \"\"\"\n\n        return self.connection.run_instances(self.id, min_count, max_count,\n                                             key_name, security_groups,\n                                             user_data, addressing_type,\n                                             instance_type, placement,\n                                             kernel_id, ramdisk_id,\n                                             monitoring_enabled, subnet_id,\n                                             block_device_map, disable_api_termination,\n                                             instance_initiated_shutdown_behavior,\n                                             private_ip_address, placement_group, \n                                             security_group_ids=security_group_ids)", "response": "Runs the instance with the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_xml(self):\n        s = '<LifecycleConfiguration>'\n        for rule in self:\n            s += rule.to_xml()\n        s += '</LifecycleConfiguration>'\n        return s", "response": "Returns a string containing the XML version of the LifecycleConfiguration object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a rule to the Lifecycle configuration.", "response": "def add_rule(self, id, prefix, status, expiration):\n        \"\"\"\n        Add a rule to this Lifecycle configuration.  This only adds\n        the rule to the local copy.  To install the new rule(s) on\n        the bucket, you need to pass this Lifecycle config object\n        to the configure_lifecycle method of the Bucket object.\n\n        :type id: str\n        :param id: Unique identifier for the rule. The value cannot be longer\n            than 255 characters.\n\n        :type prefix: str\n        :iparam prefix: Prefix identifying one or more objects to which the\n            rule applies.\n\n        :type status: str\n        :param status: If 'Enabled', the rule is currently being applied.\n            If 'Disabled', the rule is not currently being applied.\n\n        :type expiration: int\n        :param expiration: Indicates the lifetime, in days, of the objects\n            that are subject to the rule. The value must be a non-zero\n            positive integer.\n        \"\"\"\n        rule = Rule(id, prefix, status, expiration)\n        self.append(rule)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new instance of the specified class based on the passed in parameters.", "response": "def create(cls, config_file=None, logical_volume = None, cfg = None, **params):\n        \"\"\"\n        Create a new instance based on the specified configuration file or the specified\n        configuration and the passed in parameters.\n        \n        If the config_file argument is not None, the configuration is read from there. \n        Otherwise, the cfg argument is used.\n        \n        The config file may include other config files with a #import reference. The included\n        config files must reside in the same directory as the specified file. \n        \n        The logical_volume argument, if supplied, will be used to get the current physical \n        volume ID and use that as an override of the value specified in the config file. This \n        may be useful for debugging purposes when you want to debug with a production config \n        file but a test Volume. \n        \n        The dictionary argument may be used to override any EC2 configuration values in the \n        config file. \n        \"\"\"\n        if config_file:\n            cfg = Config(path=config_file)\n        if cfg.has_section('EC2'):\n            # include any EC2 configuration values that aren't specified in params:\n            for option in cfg.options('EC2'):\n                if option not in params:\n                    params[option] = cfg.get('EC2', option)\n        getter = CommandLineGetter()\n        getter.get(cls, params)\n        region = params.get('region')\n        ec2 = region.connect()\n        cls.add_credentials(cfg, ec2.aws_access_key_id, ec2.aws_secret_access_key)\n        ami = params.get('ami')\n        kp = params.get('keypair')\n        group = params.get('group')\n        zone = params.get('zone')\n        # deal with possibly passed in logical volume:\n        if logical_volume != None:\n           cfg.set('EBS', 'logical_volume_name', logical_volume.name) \n        cfg_fp = StringIO.StringIO()\n        cfg.write(cfg_fp)\n        # deal with the possibility that zone and/or keypair are strings read from the config file:\n        if isinstance(zone, Zone):\n            zone = zone.name\n        if isinstance(kp, KeyPair):\n            kp = kp.name\n        reservation = ami.run(min_count=1,\n                              max_count=params.get('quantity', 1),\n                              key_name=kp,\n                              security_groups=[group],\n                              instance_type=params.get('instance_type'),\n                              placement = zone,\n                              user_data = cfg_fp.getvalue())\n        l = []\n        i = 0\n        elastic_ip = params.get('elastic_ip')\n        instances = reservation.instances\n        if elastic_ip != None and instances.__len__() > 0:\n            instance = instances[0]\n            print 'Waiting for instance to start so we can set its elastic IP address...'\n            # Sometimes we get a message from ec2 that says that the instance does not exist.\n            # Hopefully the following delay will giv eec2 enough time to get to a stable state:\n            time.sleep(5) \n            while instance.update() != 'running':\n                time.sleep(1)\n            instance.use_ip(elastic_ip)\n            print 'set the elastic IP of the first instance to %s' % elastic_ip\n        for instance in instances:\n            s = cls()\n            s.ec2 = ec2\n            s.name = params.get('name') + '' if i==0 else str(i)\n            s.description = params.get('description')\n            s.region_name = region.name\n            s.instance_id = instance.id\n            if elastic_ip and i == 0:\n                s.elastic_ip = elastic_ip\n            s.put()\n            l.append(s)\n            i += 1\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef download(request):\n    '''Saves image from URL and returns ID for use with AJAX script'''\n    f = FileUpload()\n    f.title = request.GET['title'] or 'untitled'\n    f.description = request.GET['description']\n    url = urllib.unquote(request.GET['photo'])\n    file_content = urllib.urlopen(url).read()\n    file_name = url.split('/')[-1]\n    f.save_upload_file(file_name, file_content)\n    f.save()\n    return HttpResponse('%s' % (f.id))", "response": "Saves image from URL and returns ID for use with AJAX script"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks the ADMINFILES_BROWSER_VIEWS setting and return a list of browser views that have the necessary dependencies and configuration to run.", "response": "def get_enabled_browsers():\n    \"\"\"\n    Check the ADMINFILES_BROWSER_VIEWS setting and return a list of\n    instantiated browser views that have the necessary\n    dependencies/configuration to run.\n\n    \"\"\"\n    global _enabled_browsers_cache\n    if _enabled_browsers_cache is not None:\n        return _enabled_browsers_cache\n    enabled = []\n    for browser_path in settings.ADMINFILES_BROWSER_VIEWS:\n        try:\n            view_class = import_browser(browser_path)\n        except ImportError:\n            continue\n        if not issubclass(view_class, BaseView):\n            continue\n        browser = view_class\n        try:\n            browser.check()\n        except DisableView:\n            continue\n        enabled.append(browser)\n    _enabled_browsers_cache = enabled\n    return enabled"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a slug suitable for accessing this view in a URLconf.", "response": "def slug(cls):\n        \"\"\"\n        Return slug suitable for accessing this view in a URLconf.\n\n        \"\"\"\n        slug = cls.__name__.lower()\n        if slug.endswith('view'):\n            slug = slug[:-4]\n        return slug"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef link_text(cls):\n        link = cls.__name__\n        if link.endswith('View'):\n            link = link[:-4]\n        return link", "response": "Return the link text for this view."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, expected_value=None, return_values=None):\n        return self.table.layer2.update_item(self, expected_value,\n                                             return_values)", "response": "Save the item to DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting the item from DynamoDB.", "response": "def delete(self, expected_value=None, return_values=None):\n        \"\"\"\n        Delete the item from DynamoDB.\n\n        :type expected_value: dict\n        :param expected_value: A dictionary of name/value pairs that you expect.\n            This dictionary should have name/value pairs where the name\n            is the name of the attribute and the value is either the value\n            you are expecting or False if you expect the attribute not to\n            exist.\n            \n        :type return_values: str\n        :param return_values: Controls the return of attribute\n            name-value pairs before then were changed.  Possible\n            values are: None or 'ALL_OLD'. If 'ALL_OLD' is\n            specified and the item is overwritten, the content\n            of the old item is returned.\n        \"\"\"\n        return self.table.layer2.delete_item(self, expected_value,\n                                             return_values)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef put(self, expected_value=None, return_values=None):\n        return self.table.layer2.put_item(self, expected_value, return_values)", "response": "Store a new item or completely replace an existing item."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract the text from a PDF document.", "response": "def pdf_to_text(pdfstream):\n    '''Extract the text from a PDF document, e.g. to add PDF text\n    content to an index for searching.\n\n    To use on a file, the syntax is:\n        text = pdf_to_text(open(pdf_filepath, 'rb'))\n\n    To use on a datastream from EULFedora, the syntax is:\n        pdfobj = repository.get_object(pid)\n        text = pdf_to_text(pdfobj.pdf.content)\n\n    :param pdfstream: A file-like object that supports read and seek\n        methods, as required by :class:`pyPdf.PdfFileReader`\n\n    '''\n    pdfreader = PdfFileReader(pdfstream)\n    if pdfreader.isEncrypted:\n        raise Exception('Cannot extract text from encrypted PDF documents')\n    return '\\n'.join([page.extractText() for page in pdfreader.pages])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect_sqs(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.sqs.connection import SQSConnection\n    return SQSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Creates a connection to Amazon s SQS base on the passed in parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a connection to Amazon s S3.", "response": "def connect_s3(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.s3.connection.S3Connection`\n    :return: A connection to Amazon's S3\n    \"\"\"\n    from boto.s3.connection import S3Connection\n    return S3Connection(aws_access_key_id, aws_secret_access_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect_gs(gs_access_key_id=None, gs_secret_access_key=None, **kwargs):\n    from boto.gs.connection import GSConnection\n    return GSConnection(gs_access_key_id, gs_secret_access_key, **kwargs)", "response": "Connect to Google s Storage service."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a connection to Amazon s EC2 base on the passed in parameters.", "response": "def connect_ec2(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.ec2.connection.EC2Connection`\n    :return: A connection to Amazon's EC2\n    \"\"\"\n    from boto.ec2.connection import EC2Connection\n    return EC2Connection(aws_access_key_id, aws_secret_access_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect_elb(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.ec2.elb import ELBConnection\n    return ELBConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Creates a connection to an Amazon s Load Balancing Service"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect_autoscale(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.ec2.autoscale import AutoScaleConnection\n    return AutoScaleConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Creates a connection to the Amazon s Auto Scaling service."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connect_cloudwatch(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.ec2.cloudwatch import CloudWatchConnection\n    return CloudWatchConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Creates a CloudWatchConnection object for use with the CloudWatch API."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect_sdb(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.sdb.connection import SDBConnection\n    return SDBConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Creates a connection to Amazon s SDB"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect_fps(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.fps.connection import FPSConnection\n    return FPSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Connect to the FPS server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconnecting to the MTurk node.", "response": "def connect_mturk(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.mturk.connection.MTurkConnection`\n    :return: A connection to MTurk\n    \"\"\"\n    from boto.mturk.connection import MTurkConnection\n    return MTurkConnection(aws_access_key_id, aws_secret_access_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a connection to a CloudFront object.", "response": "def connect_cloudfront(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.fps.connection.FPSConnection`\n    :return: A connection to FPS\n    \"\"\"\n    from boto.cloudfront import CloudFrontConnection\n    return CloudFrontConnection(aws_access_key_id, aws_secret_access_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef connect_vpc(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.vpc import VPCConnection\n    return VPCConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Connect to a VPC"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_rds(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.rds import RDSConnection\n    return RDSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Connect to an RDS node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconnecting to an Elastic MapReduce node.", "response": "def connect_emr(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.emr.EmrConnection`\n    :return: A connection to Elastic mapreduce\n    \"\"\"\n    from boto.emr import EmrConnection\n    return EmrConnection(aws_access_key_id, aws_secret_access_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect_sns(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.sns import SNSConnection\n    return SNSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Creates a connection to Amazon s SNS base on the passed in parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a connection to the Amazon s IAM base account.", "response": "def connect_iam(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.iam.IAMConnection`\n    :return: A connection to Amazon's IAM\n    \"\"\"\n    from boto.iam import IAMConnection\n    return IAMConnection(aws_access_key_id, aws_secret_access_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect_route53(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    from boto.route53 import Route53Connection\n    return Route53Connection(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Creates a connection to Amazon s Route53 DNS Service."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a connection to the Amazon s CloudFormation service.", "response": "def connect_cloudformation(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.cloudformation.CloudFormationConnection`\n    :return: A connection to Amazon's CloudFormation Service\n    \"\"\"\n    from boto.cloudformation import CloudFormationConnection\n    return CloudFormationConnection(aws_access_key_id, aws_secret_access_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconnects to an Eucalyptus service.", "response": "def connect_euca(host=None, aws_access_key_id=None, aws_secret_access_key=None,\n                 port=8773, path='/services/Eucalyptus', is_secure=False,\n                 **kwargs):\n    \"\"\"\n    Connect to a Eucalyptus service.\n\n    :type host: string\n    :param host: the host name or ip address of the Eucalyptus server\n\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.ec2.connection.EC2Connection`\n    :return: A connection to Eucalyptus server\n    \"\"\"\n    from boto.ec2 import EC2Connection\n    from boto.ec2.regioninfo import RegionInfo\n\n    # Check for values in boto config, if not supplied as args\n    if not aws_access_key_id:\n        aws_access_key_id = config.get('Credentials',\n                                       'euca_access_key_id',\n                                       None)\n    if not aws_secret_access_key:\n        aws_secret_access_key = config.get('Credentials',\n                                           'euca_secret_access_key',\n                                           None)\n    if not host:\n        host = config.get('Boto', 'eucalyptus_host', None)\n\n    reg = RegionInfo(name='eucalyptus', endpoint=host)\n    return EC2Connection(aws_access_key_id, aws_secret_access_key,\n                         region=reg, port=port, path=path,\n                         is_secure=is_secure, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_ec2_endpoint(url, aws_access_key_id=None, aws_secret_access_key=None, \n                         **kwargs):\n    \"\"\"\n    Connect to an EC2 Api endpoint.  Additional arguments are passed\n    through to connect_ec2.\n\n    :type url: string\n    :param url: A url for the ec2 api endpoint to connect to\n\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.ec2.connection.EC2Connection`\n    :return: A connection to Eucalyptus server\n    \"\"\"\n    from boto.ec2.regioninfo import RegionInfo\n\n    purl = urlparse.urlparse(url)\n    kwargs['port'] = purl.port\n    kwargs['host'] = purl.hostname\n    kwargs['path'] = purl.path\n    if not 'is_secure' in kwargs:\n        kwargs['is_secure'] = (purl.scheme == \"https\")\n\n    kwargs['region'] = RegionInfo(name = purl.hostname,\n        endpoint = purl.hostname)\n    kwargs['aws_access_key_id']=aws_access_key_id\n    kwargs['aws_secret_access_key']=aws_secret_access_key\n\n    return(connect_ec2(**kwargs))", "response": "Connect to an EC2 API endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconnect to a Walrus service.", "response": "def connect_walrus(host=None, aws_access_key_id=None, aws_secret_access_key=None,\n                   port=8773, path='/services/Walrus', is_secure=False,\n                   **kwargs):\n    \"\"\"\n    Connect to a Walrus service.\n\n    :type host: string\n    :param host: the host name or ip address of the Walrus server\n\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.s3.connection.S3Connection`\n    :return: A connection to Walrus\n    \"\"\"\n    from boto.s3.connection import S3Connection\n    from boto.s3.connection import OrdinaryCallingFormat\n\n    # Check for values in boto config, if not supplied as args\n    if not aws_access_key_id:\n        aws_access_key_id = config.get('Credentials',\n                                       'euca_access_key_id',\n                                       None)\n    if not aws_secret_access_key:\n        aws_secret_access_key = config.get('Credentials',\n                                           'euca_secret_access_key',\n                                           None)\n    if not host:\n        host = config.get('Boto', 'walrus_host', None)\n        \n    return S3Connection(aws_access_key_id, aws_secret_access_key,\n                        host=host, port=port, path=path,\n                        calling_format=OrdinaryCallingFormat(),\n                        is_secure=is_secure, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a connection to Amazon s SES base.", "response": "def connect_ses(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.ses.SESConnection`\n    :return: A connection to Amazon's SES\n    \"\"\"\n    from boto.ses import SESConnection\n    return SESConnection(aws_access_key_id, aws_secret_access_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a connection to Amazon s STS", "response": "def connect_sts(aws_access_key_id=None, aws_secret_access_key=None, **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.sts.STSConnection`\n    :return: A connection to Amazon's STS\n    \"\"\"\n    from boto.sts import STSConnection\n    return STSConnection(aws_access_key_id, aws_secret_access_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting to the Internet Archive via their S3 - like API.", "response": "def connect_ia(ia_access_key_id=None, ia_secret_access_key=None,\n               is_secure=False, **kwargs):\n    \"\"\"\n    Connect to the Internet Archive via their S3-like API.\n\n    :type ia_access_key_id: string\n    :param ia_access_key_id: Your IA Access Key ID.  This will also look in your\n                             boto config file for an entry in the Credentials\n                             section called \"ia_access_key_id\"\n\n    :type ia_secret_access_key: string\n    :param ia_secret_access_key: Your IA Secret Access Key.  This will also\n                                 look in your boto config file for an entry\n                                 in the Credentials section called\n                                 \"ia_secret_access_key\"\n\n    :rtype: :class:`boto.s3.connection.S3Connection`\n    :return: A connection to the Internet Archive\n    \"\"\"\n    from boto.s3.connection import S3Connection\n    from boto.s3.connection import OrdinaryCallingFormat\n\n    access_key = config.get('Credentials', 'ia_access_key_id',\n                            ia_access_key_id)\n    secret_key = config.get('Credentials', 'ia_secret_access_key',\n                            ia_secret_access_key)\n\n    return S3Connection(access_key, secret_key,\n                        host='s3.us.archive.org',\n                        calling_format=OrdinaryCallingFormat(),\n                        is_secure=is_secure, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_dynamodb(aws_access_key_id=None,\n                     aws_secret_access_key=None,\n                     **kwargs):\n    \"\"\"\n    :type aws_access_key_id: string\n    :param aws_access_key_id: Your AWS Access Key ID\n\n    :type aws_secret_access_key: string\n    :param aws_secret_access_key: Your AWS Secret Access Key\n\n    :rtype: :class:`boto.dynamodb.layer2.Layer2`\n    :return: A connection to the Layer2 interface for DynamoDB.\n    \"\"\"\n    from boto.dynamodb.layer2 import Layer2\n    return Layer2(aws_access_key_id, aws_secret_access_key, **kwargs)", "response": "Connect to the DynamoDB Layer2 interface for Layer2."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a StorageUri for the given key.", "response": "def storage_uri_for_key(key):\n    \"\"\"Returns a StorageUri for the given key.\n\n    :type key: :class:`boto.s3.key.Key` or subclass\n    :param key: URI naming bucket + optional object.\n    \"\"\"\n    if not isinstance(key, boto.s3.key.Key):\n        raise InvalidUriError('Requested key (%s) is not a subclass of '\n                              'boto.s3.key.Key' % str(type(key)))\n    prov_name = key.bucket.connection.provider.get_provider_name()\n    uri_str = '%s://%s/%s' % (prov_name, key.bucket.name, key.name)\n    return storage_uri(uri_str)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_comments(self, commentable_type, id_):\n    return _get_request(_COM.format(c_api=_C_API_BEGINNING,\n                                            ct=commentable_type,\n                                            id_=id_,\n                                            api=_API_VERSION,\n                                            at=self.access_token))", "response": "Get comments for a single item."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_likes(self, likable_type, likable_id):\n    return _get_request(_LIKES.format(c_api=_C_API_BEGINNING,\n                                              api=_API_VERSION,\n                                              lt=likable_type,\n                                              li=likable_id,\n                                              at=self.access_token))", "response": "Get the likes of a specific object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_paths(self, user_ids=None, startup_ids=None, direction=None):\n    if user_ids is None and startup_ids is None and direction is None:\n      raise Exception('At least one input argument should be different than None')\n    if isinstance(user_ids, list):\n      user_ids = ','.join(list(map(lambda k: str(k), user_ids)))\n    if isinstance(startup_ids, list):\n      startup_ids = ','.join(list(map(lambda k: str(k), startup_ids)))\n\n    paths_url = _PATHS.format(c_api=_C_API_BEGINNING,\n                                      api=_API_VERSION,\n                                      at=self.access_token)\n    if not user_ids is None:\n      paths_url += '&' + _USER_IDS_SUFFIX.format(user_ids=user_ids)\n    if not startup_ids is None:\n      paths_url += '&' + _STARTUP_IDS_SUFFIX.format(\n                                                    startup_ids=startup_ids)\n    if not direction is None:\n      paths_url += '&' + _DIRECTION_SUFFIX.format(direction=direction)\n    return _get_request(paths_url)", "response": "Get the paths between two users and startups."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting users from a batch of users.", "response": "def get_users_batch(self, ids):\n    \"\"\"\n    Ids: a list of ids that we want to return\n    \"\"\"\n    # Allowed maximum number of ids is 50\n    assert len(ids) <= 50\n    ids_ = ','.join(ids)\n    url = _USERS_BATCH.format(c_api=_C_API_BEGINNING,\n                                              api=_API_VERSION,\n                                              ids=ids_,\n\t\t\t\t\t      at=self.access_token)\n    return _get_request(url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_tags_users(self, id_):\n    return _get_request(_TAGS_USERS.format(c_api=_C_API_BEGINNING,\n                                                                      api=_API_VERSION,\n                                                                      id_=id_,\n                                                                      at=self.access_token))", "response": "Get a particular user which are tagged based on the id_\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets startup based on id", "response": "def get_startup(self, id_):\n    \"\"\" Get startup based on id\n    \"\"\"\n    return _get_request(_STARTUP.format(c_api=_C_API_BEGINNING,\n                                        api=_API_VERSION,\n                                        id_=id_,\n                                        at=self.access_token))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_startup_roles(self, user_id=None, startup_id=None, role=None, direction='incoming'):\n\n    if user_id is None and startup_id is None:\n      raise Exception(\"You need to provide at least one parameter\")\n    url = _STARTUP_R.format(c_api=_C_API_BEGINNING,\n                                          api=_API_VERSION,\n                                          at=self.access_token)\n    if user_id is not None:\n      url += '&user_id=' + str(user_id)\n    if startup_id is not None:\n      url += '&startup_id=' + str(startup_id)\n    if role is not None:\n      url += '&role=' + role\n    url += '&direction' + direction\n    return _get_request(url)", "response": "Get startup roles for a specific user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_startup_comments(self, id_):\n    return _get_request(_STARTUP_C.format(c_api=_C_API_BEGINNING,\n                                                               api=_API_VERSION,\n                                                               id_=id_,\n                                                               at=self.access_token))", "response": "Retrieve the comments of a particular startup"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_startups_filtered_by(self, filter_='raising'):\n    url = _STARTUP_RAISING.format(c_api=_C_API_BEGINNING,\n                                                                         api=_API_VERSION,\n                                                                         filter_=filter_,\n                                                                         at=self.access_token)\n    return _get_request(url)", "response": "Get startups based on which companies are raising funding\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets status updates of a startup", "response": "def get_status_updates(self, startup_id):\n    \"\"\" Get status updates of a startup\n    \"\"\"\n    return _get_request(_STATUS_U.format(c_api=_C_API_BEGINNING,\n                                                             api=_API_VERSION,\n                                                             startup_id=startup_id,\n                                                             at=self.access_token))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch for a particular slug", "response": "def get_search_for_slugs(self, slug):\n    \"\"\" Search for a particular slug\n    \"\"\"\n    return _get_request(_SLUG_SEARCH.format(c_api=_C_API_BEGINNING,\n                                            api=_API_VERSION,\n                                            slug=_format_query(slug),\n                                            at=self.access_token))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_search(self, query, type_=None):\n    search_url = _S_SEARCH.format(c_api=_C_API_BEGINNING,\n                                  api=_API_VERSION,\n                                  query=_format_query(query),\n                                  at=self.access_token)\n    if type_ is not None:\n      search_url + _TYPE_SUFFIX.format(type_=type_)\n    return _get_request(search_url)", "response": "Search for query, type_ is optional.\n    type_: 'User', 'Startup', 'MarketTag', 'LocationTag'"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_reviews(self, user_id):\n    url = _REVIEWS_USER.format(c_api=_C_API_BEGINNING,\n                                                api=_API_VERSION,\n                                                user_id=user_id,\n                                                at=self.access_token)\n    return _get_request(url)", "response": "Get reviews for a particular user"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a particular review id independent from the user_id and startup_id", "response": "def get_review_id(self, id_):\n    \"\"\" Get a particular review id, independent from the user_id and\n    startup_id\n    \"\"\"\n    return _get_request(_REVIEW_ID.format(c_api=_C_API_BEGINNING,\n                                                              api=_API_VERSION,\n                                                              id_=id_,\n                                                              at=self.access_token))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of all available regions for the SDB service.", "response": "def regions():\n    \"\"\"\n    Get all available regions for the SDB service.\n\n    :rtype: list\n    :return: A list of :class:`boto.sdb.regioninfo.RegionInfo` instances\n    \"\"\"\n    return [SDBRegionInfo(name='us-east-1',\n                          endpoint='sdb.amazonaws.com'),\n            SDBRegionInfo(name='eu-west-1',\n                          endpoint='sdb.eu-west-1.amazonaws.com'),\n            SDBRegionInfo(name='us-west-1',\n                          endpoint='sdb.us-west-1.amazonaws.com'),\n            SDBRegionInfo(name='sa-east-1',\n                          endpoint='sdb.sa-east-1.amazonaws.com'),\n            SDBRegionInfo(name='us-west-2',\n                          endpoint='sdb.us-west-2.amazonaws.com'),\n            SDBRegionInfo(name='ap-northeast-1',\n                          endpoint='sdb.ap-northeast-1.amazonaws.com'),\n            SDBRegionInfo(name='ap-southeast-1',\n                          endpoint='sdb.ap-southeast-1.amazonaws.com')\n            ]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a cron command to the current directory", "response": "def add_cron(self, name, command, minute=\"*\", hour=\"*\", mday=\"*\", month=\"*\", wday=\"*\", who=\"root\", env=None):\n        \"\"\"\n        Write a file to /etc/cron.d to schedule a command\n            env is a dict containing environment variables you want to set in the file\n            name will be used as the name of the file\n        \"\"\"\n        if minute == 'random':\n            minute = str(random.randrange(60))\n        if hour == 'random':\n            hour = str(random.randrange(24))\n        fp = open('/etc/cron.d/%s' % name, \"w\")\n        if env:\n            for key, value in env.items():\n                fp.write('%s=%s\\n' % (key, value))\n        fp.write('%s %s %s %s %s %s %s\\n' % (minute, hour, mday, month, wday, who, command))\n        fp.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_init_script(self, file, name):\n        f_path = os.path.join(\"/etc/init.d\", name)\n        f = open(f_path, \"w\")\n        f.write(file)\n        f.close()\n        os.chmod(f_path, stat.S_IREAD| stat.S_IWRITE | stat.S_IEXEC)\n        self.run(\"/usr/sbin/update-rc.d %s defaults\" % name)", "response": "Add this file to the init. d directory"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_env(self, key, value):\n        boto.log.info('Adding env variable: %s=%s' % (key, value))\n        if not os.path.exists(\"/etc/environment.orig\"):\n            self.run('cp /etc/environment /etc/environment.orig', notify=False, exit_on_error=False)\n        fp = open('/etc/environment', 'a')\n        fp.write('\\n%s=\"%s\"' % (key, value))\n        fp.close()\n        os.environ[key] = value", "response": "Add an environment variable to the current directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_user(self, user):\n        self.run(\"useradd -m %s\" % user)\n        usr =  getpwnam(user)\n        return usr", "response": "Create a user on the local system"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sync_object(src_obj, dest_repo, export_context='migrate',\n                overwrite=False, show_progress=False,\n                requires_auth=False, omit_checksums=False,\n                verify=False):\n    '''Copy an object from one repository to another using the Fedora\n    export functionality.\n\n    :param src_obj: source :class:`~eulfedora.models.DigitalObject` to\n        be copied\n    :param dest_repo: destination  :class:`~eulfedora.server.Repository`\n        where the object will be copied to\n    :param export_context: Fedora export format to use, one of \"migrate\"\n        or \"archive\"; migrate is generally faster, but requires access\n        from destination repository to source and may result in checksum\n        errors for some content; archive exports take longer to process\n        (default: migrate)\n    :param overwrite: if an object with the same pid is already present\n        in the destination repository, it will be removed only if\n        overwrite is set to true (default: false)\n    :param show_progress: if True, displays a progress bar with content size,\n        progress, speed, and ETA (only applicable to archive exports)\n    :param requires_auth: content datastreams require authentication,\n        and should have credentials patched in (currently only supported\n        in archive-xml export mode)  (default: False)\n    :param omit_checksums: scrubs contentDigest -- aka checksums -- from datastreams;\n        helpful for datastreams with Redirect (R) or External (E) contexts\n        (default: False)\n    :returns: result of Fedora ingest on the destination repository on\n        success\n    '''\n\n    # NOTE: currently exceptions are expected to be handled by the\n    # calling method; see repo-cp script for an example\n\n    # if overwrite is not requested, check first and bail out\n    dest_obj = dest_repo.get_object(src_obj.pid)\n    if not overwrite and dest_obj.exists:\n        logger.info('%s exists in destination repo and no overwrite; skipping',\n                    src_obj.pid)\n        return False\n\n    if show_progress and progressbar:\n        # calculate rough estimate of object size\n        size_estimate = estimate_object_size(src_obj,\n            archive=(export_context in ['archive', 'archive-xml']))\n        # create a new progress bar with current pid and size\n        widgets = [src_obj.pid,\n            ' Estimated size: %s // ' % humanize_file_size(size_estimate),\n            'Read: ', progressbar.widgets.DataSize(), ' ',\n            progressbar.widgets.AdaptiveTransferSpeed(), ' ',\n            '| Uploaded: ', progressbar.widgets.DataSize(value='upload'), ' // ',\n            # FileTransferSpeed('upload'), currently no way to track upload speed...\n             progressbar.widgets.Timer(), ' | ', progressbar.widgets.AdaptiveETA()\n            ]\n\n        class DownUpProgressBar(progressbar.ProgressBar):\n            upload = 0\n            def data(self):\n                data = super(DownUpProgressBar, self).data()\n                data['upload'] = self.upload\n                return data\n\n        pbar = DownUpProgressBar(widgets=widgets, max_value=size_estimate)\n    else:\n        pbar = None\n\n    # migrate export can simply be read and uploaded to dest fedora\n    if export_context == 'migrate':\n        response = src_obj.api.export(src_obj, context=export_context, stream=True)\n        export_data = response.iter_content(4096*1024)\n\n    # archive export needs additional processing to handle large binary content\n    elif export_context in ['archive', 'archive-xml']:\n        export = ArchiveExport(src_obj, dest_repo,\n            progress_bar=pbar, requires_auth=requires_auth,\n            xml_only=(export_context == 'archive-xml'),\n            verify=verify)\n        # NOTE: should be possible to pass BytesIO to be read, but that is failing\n        export_data = export.object_data().getvalue()\n\n    else:\n        raise Exception('Unsupported export context %s', export_context)\n\n    # wipe checksums from FOXML if flagged in options\n    if omit_checksums:\n        checksum_re = re.compile(b'<foxml:contentDigest.+?/>')\n        try:\n            # export data is either a string\n            export_data = checksum_re.sub(b'', export_data)\n        except TypeError:\n            export_data = (re.sub(checksum_re, '', chunk)\n                           for chunk in export_data)\n\n    if overwrite and dest_obj.exists:\n        logger.debug('Overwriting %s in destination repository', src_obj.pid)\n        dest_repo.purge_object(src_obj.pid)\n\n    result = dest_repo.ingest(export_data)\n    if pbar:\n        pbar.finish()\n    return force_text(result)", "response": "Copy an object from one repository to another using the Fedora\n    export functionality."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsplit a chunk of data into sections by start and end binaryContent tags.", "response": "def binarycontent_sections(chunk):\n    '''Split a chunk of data into sections by start and end binary\n    content tags.'''\n    # using string split because it is significantly faster than regex.\n\n    # use common text of start and end tags to split the text\n    # (i.e. without < or </ tag beginning)\n    binary_content_tag = BINARY_CONTENT_START[1:]\n    if binary_content_tag not in chunk:\n        # if no tags are present, don't do any extra work\n        yield chunk\n\n    else:\n        # split on common portion of foxml:binaryContent\n        sections = chunk.split(binary_content_tag)\n        for sec in sections:\n            extra = b''\n            # check the end of the section to determine start/end tag\n            if sec.endswith(b'</'):\n                extra = sec[-2:]\n                yield sec[:-2]\n\n            elif sec.endswith(b'<'):\n                extra = sec[-1:]\n                yield sec[:-1]\n\n            else:\n                yield sec\n\n            if extra:\n                # yield the actual binary content tag\n                # (delimiter removed by split, but needed for processing)\n                yield b''.join([extra, binary_content_tag])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates a rough estimate of object size based on the sizes of all versions of all datastreams and the sizes of all managed datastreams.", "response": "def estimate_object_size(obj, archive=True):\n    '''Calculate a rough estimate of object size, based on the sizes of\n    all versions of all datastreams.  If archive is true, adjusts\n    the size estimate of managed datastreams for base64 encoded data.\n    '''\n    size_estimate = 250000   # initial rough estimate for foxml size\n    for ds in obj.ds_list:\n        dsobj = obj.getDatastreamObject(ds)\n        for version in dsobj.history().versions:\n            if archive and version.control_group == 'M':\n                size_estimate += base64_size(version.size)\n            else:\n                size_estimate += version.size\n\n    return size_estimate"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the text ends with any partial version of the specified string.", "response": "def endswith_partial(text, partial_str):\n    '''Check if the text ends with any partial version of the\n    specified string.'''\n    # at the end of the content\n    # we don't care about complete overlap, so start checking\n    # for matches without the last character\n    test_str = partial_str[:-1]\n    # look for progressively smaller segments\n    while test_str:\n        if text.endswith(test_str):\n            return len(test_str)\n        test_str = test_str[:-1]\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing regular expressions to pull datastream info for binary content and datastream context.", "response": "def get_datastream_info(self, dsinfo):\n        '''Use regular expressions to pull datastream [version]\n        details (id, mimetype, size, and checksum) for binary content,\n        in order to sanity check the decoded data.\n\n        :param dsinfo: text content just before a binaryContent tag\n        :returns: dict with keys for id, mimetype, size, type and digest,\n            or None if no match is found\n        '''\n        # we only need to look at the end of this section of content\n        dsinfo = dsinfo[-750:]\n        # if not enough content is present, include the end of\n        # the last read chunk, if available\n        if len(dsinfo) < 750 and self.end_of_last_chunk is not None:\n            dsinfo = self.end_of_last_chunk + dsinfo\n\n        # force text needed for python 3 compatibility (in python 3\n        # dsinfo is bytes instead of a string)\n        try:\n            text = force_text(dsinfo)\n        except UnicodeDecodeError as err:\n            # it's possible to see a unicode character split across\n            # read blocks; if we get an \"invalid start byte\" unicode\n            # decode error, try converting the text without the first\n            # character; if that's the problem, it's not needed\n            # for datastream context\n            if 'invalid start byte' in force_text(err):\n                text = force_text(dsinfo[1:])\n            else:\n                raise err\n\n        # in case the text contains multiple datastream ids, find\n        # all matches and then use the last, since we want the last one\n        # in this section, just before the datastream content\n        matches = list(self.dsinfo_regex.finditer(text))\n        if matches:\n            infomatch = matches[-1]\n            return infomatch.groupdict()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses the archival export and return a buffer with foxml EffectiveContent for ingest into the destination repository.", "response": "def object_data(self):\n        '''Process the archival export and return a buffer with foxml\n        content for ingest into the destination repository.\n\n        :returns: :class:`io.BytesIO` for ingest, with references\n            to uploaded datastream content or content location urls\n        '''\n        self.foxml_buffer = io.BytesIO()\n\n        if self.progress_bar:\n            self.progress_bar.start()\n\n        previous_section = None\n        while True:\n            try:\n                section = self.get_next_section()\n            except StopIteration:\n                break\n\n            if section == BINARY_CONTENT_START:\n                self.within_file = True\n\n                # get datastream info from the end of the section just before this one\n                # (needed to provide size to upload request)\n                dsinfo = self.get_datastream_info(previous_section)\n                if dsinfo:\n                    logger.info('Found encoded datastream %(id)s (%(mimetype)s, size %(size)s, %(type)s %(digest)s)',\n                                dsinfo)\n                else:\n                    # error if datastream info is not found, because either\n                    # size or version date is required to handle content\n                    raise Exception('Failed to find datastream information for %s from \\n%s' \\\n                        % (self.obj.pid, previous_section))\n\n                if self.xml_only and not \\\n                   dsinfo['mimetype'] in ['text/xml', 'application/rdf+xml',\n                                          'application/xml']:\n                    # possibly other mimetypes also?\n                    try:\n                        dsid = dsinfo['id'].split('.')[0]\n                    except ValueError:\n                        # if dsid doesn't include a .# (for versioning),\n                        # use the id as is.\n                        dsid = dsinfo['id']\n\n                    if self.url_credentials:\n                        # if url credentials are set, parse the base fedora api\n                        # url so they can be inserted at the right place\n                        parsed_url = urlparse(self.obj.api.base_url)\n                        # reassemble base url, adding in credentials\n                        base_url = ''.join([parsed_url.scheme, '://',\n                            self.url_credentials, parsed_url.netloc,\n                            parsed_url.path])\n                    else:\n                        base_url = self.obj.api.base_url\n\n                    # versioned datastream dissemination url\n                    content_location = '%sobjects/%s/datastreams/%s/content?asOfDateTime=%s' % \\\n                        (base_url, self.obj.pid, dsid, dsinfo['created'])\n                else:\n                    upload_args = {}\n                    if self.progress_bar:\n                        def upload_callback(monitor):\n                            self.progress_bar.upload = monitor.bytes_read\n                        upload_args = {'callback': upload_callback}\n\n                    # use upload id as content location\n                    content_location = self.dest_repo.api.upload(self.encoded_datastream(),\n                        size=int(dsinfo['size']), **upload_args)\n\n                self.foxml_buffer.write(force_bytes('<foxml:contentLocation REF=\"%s\" TYPE=\"URL\"/>' \\\n                    % content_location))\n\n            elif section == BINARY_CONTENT_END:\n                # should not occur here; this section will be processed by\n                # encoded_datastream method\n                self.within_file = False\n\n            elif self.within_file:\n                # should not occur here; this section will be pulled by\n                # encoded_datastream method\n\n                # binary content within a file - ignore here\n                # (handled by encoded_datastream method)\n                continue\n\n            else:\n                # not start or end of binary content, and not\n                # within a file, so yield as is (e.g., datastream tags\n                # between small files)\n                self.foxml_buffer.write(section)\n\n            previous_section = section\n\n        return self.foxml_buffer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating your Dynamic DNS record with DNSMadeEasy. com", "response": "def update_dme(username, password, dme_id, ip_address):\n    \"\"\"\n    Update your Dynamic DNS record with DNSMadeEasy.com\n    \"\"\"\n    dme_url = 'https://www.dnsmadeeasy.com/servlet/updateip'\n    dme_url += '?username=%s&password=%s&id=%s&ip=%s'\n    s = urllib2.urlopen(dme_url % (username, password, dme_id, ip_address))\n    return s.read()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch_file(uri, file=None, username=None, password=None):\n    boto.log.info('Fetching %s' % uri)\n    if file == None:\n        file = tempfile.NamedTemporaryFile()\n    try:\n        if uri.startswith('s3://'):\n            bucket_name, key_name = uri[len('s3://'):].split('/', 1)\n            c = boto.connect_s3(aws_access_key_id=username, aws_secret_access_key=password)\n            bucket = c.get_bucket(bucket_name)\n            key = bucket.get_key(key_name)\n            key.get_contents_to_file(file)\n        else:\n            if username and password:\n                passman = urllib2.HTTPPasswordMgrWithDefaultRealm()\n                passman.add_password(None, uri, username, password)\n                authhandler = urllib2.HTTPBasicAuthHandler(passman)\n                opener = urllib2.build_opener(authhandler)\n                urllib2.install_opener(opener)\n            s = urllib2.urlopen(uri)\n            file.write(s.read())\n        file.seek(0)\n    except:\n        raise\n        boto.log.exception('Problem Retrieving file: %s' % uri)\n        file = None\n    return file", "response": "Fetch a file based on the URI provided."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_mime_multipart(content, compress=False, deftype='text/plain', delimiter=':'):\n    wrapper = MIMEMultipart()\n    for name,con in content:\n        definite_type = guess_mime_type(con, deftype)\n        maintype, subtype = definite_type.split('/', 1)\n        if maintype == 'text':\n            mime_con = MIMEText(con, _subtype=subtype)\n        else:\n            mime_con = MIMEBase(maintype, subtype)\n            mime_con.set_payload(con)\n            # Encode the payload using Base64\n            Encoders.encode_base64(mime_con)\n        mime_con.add_header('Content-Disposition', 'attachment', filename=name)\n        wrapper.attach(mime_con)\n    rcontent = wrapper.as_string()\n\n    if compress:\n        buf = StringIO.StringIO()\n        gz = gzip.GzipFile(mode='wb', fileobj=buf)\n        try:\n            gz.write(rcontent)\n        finally:\n            gz.close()\n        rcontent = buf.getvalue()\n\n    return rcontent", "response": "This function writes a list of name - content pairs into a multipart object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nguess the mime type of a block of text", "response": "def guess_mime_type(content, deftype):\n    \"\"\"Description: Guess the mime type of a block of text\n    :param content: content we're finding the type of\n    :type str:\n\n    :param deftype: Default mime type\n    :type str:\n\n    :rtype: <type>:\n    :return: <description>\n    \"\"\"\n    #Mappings recognized by cloudinit\n    starts_with_mappings={\n        '#include' : 'text/x-include-url',\n        '#!' : 'text/x-shellscript',\n        '#cloud-config' : 'text/cloud-config',\n        '#upstart-job'  : 'text/upstart-job',\n        '#part-handler' : 'text/part-handler',\n        '#cloud-boothook' : 'text/cloud-boothook'\n    }\n    rtype = deftype\n    for possible_type,mimetype in starts_with_mappings.items():\n        if content.startswith(possible_type):\n            rtype = mimetype\n            break\n    return(rtype)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compute_md5(fp, buf_size=8192, size=None):\n    m = md5()\n    spos = fp.tell()\n    if size and size < buf_size:\n        s = fp.read(size)\n    else:\n        s = fp.read(buf_size)\n    while s:\n        m.update(s)\n        if size:\n            size -= len(s)\n            if size <= 0:\n                break\n        if size and size < buf_size:\n            s = fp.read(size)\n        else:\n            s = fp.read(buf_size)\n    hex_md5 = m.hexdigest()\n    base64md5 = base64.encodestring(m.digest())\n    if base64md5[-1] == '\\n':\n        base64md5 = base64md5[0:-1]\n    # data_size based on bytes read.\n    data_size = fp.tell() - spos\n    fp.seek(spos)\n    return (hex_md5, base64md5, data_size)", "response": "Compute MD5 hash on passed file and return results in a tuple of values."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef regions():\n    regions = []\n    for region_name in RegionData:\n        region = RegionInfo(name=region_name,\n                            endpoint=RegionData[region_name],\n                            connection_cls=CloudWatchConnection)\n        regions.append(region)\n    return regions", "response": "Returns a list of all available regions for CloudWatch service."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget time-series data for one or more statistics of a given metric. :type period: integer :param period: The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60. The default value is 60. :type start_time: datetime :param start_time: The time stamp to use for determining the first datapoint to return. The value specified is inclusive; results include datapoints with the time stamp specified. :type end_time: datetime :param end_time: The time stamp to use for determining the last datapoint to return. The value specified is exclusive; results will include datapoints up to the time stamp specified. :type metric_name: string :param metric_name: The metric name. :type namespace: string :param namespace: The metric's namespace. :type statistics: list :param statistics: A list of statistics names Valid values: Average | Sum | SampleCount | Maximum | Minimum :type dimensions: dict :param dimensions: A dictionary of dimension key/values where the key is the dimension name and the value is either a scalar value or an iterator of values to be associated with that dimension. :rtype: list", "response": "def get_metric_statistics(self, period, start_time, end_time, metric_name,\n                              namespace, statistics, dimensions=None,\n                              unit=None):\n        \"\"\"\n        Get time-series data for one or more statistics of a given metric.\n\n        :type period: integer\n        :param period: The granularity, in seconds, of the returned datapoints.\n                       Period must be at least 60 seconds and must be a multiple\n                       of 60. The default value is 60.\n\n        :type start_time: datetime\n        :param start_time: The time stamp to use for determining the first\n                           datapoint to return. The value specified is\n                           inclusive; results include datapoints with the\n                           time stamp specified.\n\n        :type end_time: datetime\n        :param end_time: The time stamp to use for determining the last\n                         datapoint to return. The value specified is\n                         exclusive; results will include datapoints up to\n                         the time stamp specified.\n\n        :type metric_name: string\n        :param metric_name: The metric name.\n\n        :type namespace: string\n        :param namespace: The metric's namespace.\n\n        :type statistics: list\n        :param statistics: A list of statistics names Valid values:\n                           Average | Sum | SampleCount | Maximum | Minimum\n\n        :type dimensions: dict\n        :param dimensions: A dictionary of dimension key/values where\n                           the key is the dimension name and the value\n                           is either a scalar value or an iterator\n                           of values to be associated with that\n                           dimension.\n        :rtype: list\n        \"\"\"\n        params = {'Period' : period,\n                  'MetricName' : metric_name,\n                  'Namespace' : namespace,\n                  'StartTime' : start_time.isoformat(),\n                  'EndTime' : end_time.isoformat()}\n        self.build_list_params(params, statistics, 'Statistics.member.%d')\n        if dimensions:\n            self.build_dimension_param(dimensions, params)\n        return self.get_list('GetMetricStatistics', params,\n                             [('member', Datapoint)])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_metrics(self, next_token=None, dimensions=None,\n                     metric_name=None, namespace=None):\n        \"\"\"\n        Returns a list of the valid metrics for which there is recorded\n        data available.\n\n        :type next_token: str\n        :param next_token: A maximum of 500 metrics will be returned at one\n                           time.  If more results are available, the\n                           ResultSet returned will contain a non-Null\n                           next_token attribute.  Passing that token as a\n                           parameter to list_metrics will retrieve the\n                           next page of metrics.\n\n        :type dimension: dict\n        :param dimension_filters: A dictionary containing name/value pairs\n                                  that will be used to filter the results.\n                                  The key in the dictionary is the name of\n                                  a Dimension.  The value in the dictionary\n                                  is either a scalar value of that Dimension\n                                  name that you want to filter on, a list\n                                  of values to filter on or None if\n                                  you want all metrics with that Dimension name.\n\n        :type metric_name: str\n        :param metric_name: The name of the Metric to filter against.  If None,\n                            all Metric names will be returned.\n\n        :type namespace: str\n        :param namespace: A Metric namespace to filter against (e.g. AWS/EC2).\n                          If None, Metrics from all namespaces will be returned.\n        \"\"\"\n        params = {}\n        if next_token:\n            params['NextToken'] = next_token\n        if dimensions:\n            self.build_dimension_param(dimensions, params)\n        if metric_name:\n            params['MetricName'] = metric_name\n        if namespace:\n            params['Namespace'] = namespace\n        \n        return self.get_list('ListMetrics', params, [('member', Metric)])", "response": "Returns a list of the valid metrics for which there is recorded\nialog data available."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put_metric_data(self, namespace, name, value=None, timestamp=None, \n                        unit=None, dimensions=None, statistics=None):\n        \"\"\"\n        Publishes metric data points to Amazon CloudWatch. Amazon Cloudwatch \n        associates the data points with the specified metric. If the specified \n        metric does not exist, Amazon CloudWatch creates the metric. If a list \n        is specified for some, but not all, of the arguments, the remaining \n        arguments are repeated a corresponding number of times.\n\n        :type namespace: str\n        :param namespace: The namespace of the metric.\n\n        :type name: str or list\n        :param name: The name of the metric.\n\n        :type value: float or list\n        :param value: The value for the metric.\n\n        :type timestamp: datetime or list\n        :param timestamp: The time stamp used for the metric. If not specified, \n            the default value is set to the time the metric data was received.\n        \n        :type unit: string or list\n        :param unit: The unit of the metric.  Valid Values: Seconds | \n            Microseconds | Milliseconds | Bytes | Kilobytes |\n            Megabytes | Gigabytes | Terabytes | Bits | Kilobits |\n            Megabits | Gigabits | Terabits | Percent | Count |\n            Bytes/Second | Kilobytes/Second | Megabytes/Second |\n            Gigabytes/Second | Terabytes/Second | Bits/Second |\n            Kilobits/Second | Megabits/Second | Gigabits/Second |\n            Terabits/Second | Count/Second | None\n        \n        :type dimensions: dict\n        :param dimensions: Add extra name value pairs to associate \n            with the metric, i.e.:\n            {'name1': value1, 'name2': (value2, value3)}\n        \n        :type statistics: dict or list\n        :param statistics: Use a statistic set instead of a value, for example::\n\n            {'maximum': 30, 'minimum': 1, 'samplecount': 100, 'sum': 10000}\n        \"\"\"\n        params = {'Namespace': namespace}\n        self.build_put_params(params, name, value=value, timestamp=timestamp,\n            unit=unit, dimensions=dimensions, statistics=statistics)\n\n        return self.get_status('PutMetricData', params)", "response": "This method is used to add data points to a specific metric."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve alarms with the specified names. If no name is specified, all alarms for the user are returned. Alarms can be retrieved by using only a prefix for the alarm name, the alarm state, or a prefix for any action. :type action_prefix: string :param action_name: The action name prefix. :type alarm_name_prefix: string :param alarm_name_prefix: The alarm name prefix. AlarmNames cannot be specified if this parameter is specified. :type alarm_names: list :param alarm_names: A list of alarm names to retrieve information for. :type max_records: int :param max_records: The maximum number of alarm descriptions to retrieve. :type state_value: string :param state_value: The state value to be used in matching alarms. :type next_token: string :param next_token: The token returned by a previous call to indicate that there is more data. :rtype list", "response": "def describe_alarms(self, action_prefix=None, alarm_name_prefix=None,\n                        alarm_names=None, max_records=None, state_value=None,\n                        next_token=None):\n        \"\"\"\n        Retrieves alarms with the specified names. If no name is specified, all\n        alarms for the user are returned. Alarms can be retrieved by using only\n        a prefix for the alarm name, the alarm state, or a prefix for any\n        action.\n\n        :type action_prefix: string\n        :param action_name: The action name prefix.\n\n        :type alarm_name_prefix: string\n        :param alarm_name_prefix: The alarm name prefix. AlarmNames cannot\n                                  be specified if this parameter is specified.\n\n        :type alarm_names: list\n        :param alarm_names: A list of alarm names to retrieve information for.\n\n        :type max_records: int\n        :param max_records: The maximum number of alarm descriptions\n                            to retrieve.\n\n        :type state_value: string\n        :param state_value: The state value to be used in matching alarms.\n\n        :type next_token: string\n        :param next_token: The token returned by a previous call to\n                           indicate that there is more data.\n\n        :rtype list\n        \"\"\"\n        params = {}\n        if action_prefix:\n            params['ActionPrefix'] = action_prefix\n        if alarm_name_prefix:\n            params['AlarmNamePrefix'] = alarm_name_prefix\n        elif alarm_names:\n            self.build_list_params(params, alarm_names, 'AlarmNames.member.%s')\n        if max_records:\n            params['MaxRecords'] = max_records\n        if next_token:\n            params['NextToken'] = next_token\n        if state_value:\n            params['StateValue'] = state_value\n        return self.get_list('DescribeAlarms', params,\n                             [('MetricAlarms', MetricAlarms)])[0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef describe_alarm_history(self, alarm_name=None,\n                               start_date=None, end_date=None,\n                               max_records=None, history_item_type=None,\n                               next_token=None):\n        \"\"\"\n        Retrieves history for the specified alarm. Filter alarms by date range\n        or item type. If an alarm name is not specified, Amazon CloudWatch\n        returns histories for all of the owner's alarms.\n\n        Amazon CloudWatch retains the history of deleted alarms for a period of\n        six weeks. If an alarm has been deleted, its history can still be\n        queried.\n\n        :type alarm_name: string\n        :param alarm_name: The name of the alarm.\n\n        :type start_date: datetime\n        :param start_date: The starting date to retrieve alarm history.\n\n        :type end_date: datetime\n        :param end_date: The starting date to retrieve alarm history.\n\n        :type history_item_type: string\n        :param history_item_type: The type of alarm histories to retreive\n                                  (ConfigurationUpdate | StateUpdate | Action)\n\n        :type max_records: int\n        :param max_records: The maximum number of alarm descriptions\n                            to retrieve.\n\n        :type next_token: string\n        :param next_token: The token returned by a previous call to indicate\n                           that there is more data.\n\n        :rtype list\n        \"\"\"\n        params = {}\n        if alarm_name:\n            params['AlarmName'] = alarm_name\n        if start_date:\n            params['StartDate'] = start_date.isoformat()\n        if end_date:\n            params['EndDate'] = end_date.isoformat()\n        if history_item_type:\n            params['HistoryItemType'] = history_item_type\n        if max_records:\n            params['MaxRecords'] = max_records\n        if next_token:\n            params['NextToken'] = next_token\n        return self.get_list('DescribeAlarmHistory', params,\n                             [('member', AlarmHistoryItem)])", "response": "This method returns the history of the specified alarms."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef describe_alarms_for_metric(self, metric_name, namespace, period=None,\n                                   statistic=None, dimensions=None, unit=None):\n        \"\"\"\n        Retrieves all alarms for a single metric. Specify a statistic, period,\n        or unit to filter the set of alarms further.\n\n        :type metric_name: string\n        :param metric_name: The name of the metric\n\n        :type namespace: string\n        :param namespace: The namespace of the metric.\n\n        :type period: int\n        :param period: The period in seconds over which the statistic\n                       is applied.\n\n        :type statistic: string\n        :param statistic: The statistic for the metric.\n\n        :param dimension_filters: A dictionary containing name/value pairs\n                                  that will be used to filter the results.\n                                  The key in the dictionary is the name of\n                                  a Dimension.  The value in the dictionary\n                                  is either a scalar value of that Dimension\n                                  name that you want to filter on, a list\n                                  of values to filter on or None if\n                                  you want all metrics with that Dimension name.\n\n        :type unit: string\n\n        :rtype list\n        \"\"\"\n        params = {'MetricName' : metric_name,\n                  'Namespace' : namespace}\n        if period:\n            params['Period'] = period\n        if statistic:\n            params['Statistic'] = statistic\n        if dimensions:\n            self.build_dimension_param(dimensions, params)\n        if unit:\n            params['Unit'] = unit\n        return self.get_list('DescribeAlarmsForMetric', params,\n                             [('member', MetricAlarm)])", "response": "This method returns all the alarms associated with a single metric."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef put_metric_alarm(self, alarm):\n        params = {\n                    'AlarmName'             :       alarm.name,\n                    'MetricName'            :       alarm.metric,\n                    'Namespace'             :       alarm.namespace,\n                    'Statistic'             :       alarm.statistic,\n                    'ComparisonOperator'    :       alarm.comparison,\n                    'Threshold'             :       alarm.threshold,\n                    'EvaluationPeriods'     :       alarm.evaluation_periods,\n                    'Period'                :       alarm.period,\n                 }\n        if alarm.actions_enabled is not None:\n            params['ActionsEnabled'] = alarm.actions_enabled\n        if alarm.alarm_actions:\n            self.build_list_params(params, alarm.alarm_actions,\n                                   'AlarmActions.member.%s')\n        if alarm.description:\n            params['AlarmDescription'] = alarm.description\n        if alarm.dimensions:\n            self.build_dimension_param(alarm.dimensions, params)\n        if alarm.insufficient_data_actions:\n            self.build_list_params(params, alarm.insufficient_data_actions,\n                                   'InsufficientDataActions.member.%s')\n        if alarm.ok_actions:\n            self.build_list_params(params, alarm.ok_actions,\n                                   'OKActions.member.%s')\n        if alarm.unit:\n            params['Unit'] = alarm.unit\n        alarm.connection = self\n        return self.get_status('PutMetricAlarm', params)", "response": "Creates or updates an Amazon CloudWatch metric alarm and associates it with the specified CloudWatch metric."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_alarms(self, alarms):\n        params = {}\n        self.build_list_params(params, alarms, 'AlarmNames.member.%s')\n        return self.get_status('DeleteAlarms', params)", "response": "Delete all specified alarms."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_alarm_state(self, alarm_name, state_reason, state_value,\n                        state_reason_data=None):\n        \"\"\"\n        Temporarily sets the state of an alarm. When the updated StateValue\n        differs from the previous value, the action configured for the\n        appropriate state is invoked. This is not a permanent change. The next\n        periodic alarm check (in about a minute) will set the alarm to its\n        actual state.\n\n        :type alarm_name: string\n        :param alarm_name: Descriptive name for alarm.\n\n        :type state_reason: string\n        :param state_reason: Human readable reason.\n\n        :type state_value: string\n        :param state_value: OK | ALARM | INSUFFICIENT_DATA\n\n        :type state_reason_data: string\n        :param state_reason_data: Reason string (will be jsonified).\n        \"\"\"\n        params = {'AlarmName' : alarm_name,\n                  'StateReason' : state_reason,\n                  'StateValue' : state_value}\n        if state_reason_data:\n            params['StateReasonData'] = json.dumps(state_reason_data)\n\n        return self.get_status('SetAlarmState', params)", "response": "Temporarily sets the state of an alarm."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enable_alarm_actions(self, alarm_names):\n        params = {}\n        self.build_list_params(params, alarm_names, 'AlarmNames.member.%s')\n        return self.get_status('EnableAlarmActions', params)", "response": "Enables actions for the specified alarms."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef disable_alarm_actions(self, alarm_names):\n        params = {}\n        self.build_list_params(params, alarm_names, 'AlarmNames.member.%s')\n        return self.get_status('DisableAlarmActions', params)", "response": "Disables actions for the specified alarms."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check(self):\n        boto.log.info('checking Task[%s]-now=%s, last=%s' % (self.name, self.now, self.last_executed))\n\n        if self.hourly and not self.last_executed:\n            return 0\n            \n        if self.daily and not self.last_executed:\n            if int(self.hour) == self.now.hour:\n                return 0\n            else:\n                return max( (int(self.hour)-self.now.hour), (self.now.hour-int(self.hour)) )*60*60\n\n        delta = self.now - self.last_executed\n        if self.hourly:\n            if delta.seconds >= 60*60:\n                return 0\n            else:\n                return 60*60 - delta.seconds\n        else:\n            if int(self.hour) == self.now.hour:\n                if delta.days >= 1:\n                    return 0\n                else:\n                    return 82800 # 23 hours, just to be safe\n            else:\n                return max( (int(self.hour)-self.now.hour), (self.now.hour-int(self.hour)) )*60*60", "response": "Determine how long until the next scheduled time for a Task."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef order_executed(self, orderDict):\n        ''' call back for executed order '''\n        for orderId, order in orderDict.items():\n            if order.security in self.__trakers.keys():\n                self.__trakers[order.security].orderExecuted(orderId)", "response": "call back for executed order"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the trakers with the tickDict", "response": "def update(self, tickDict):\n        ''' consume ticks '''\n        if not self.__trakers:\n            self.__setUpTrakers()\n\n        for security, tick in tickDict.items():\n            if security in self.__trakers:\n                self.__trakers[security].tickUpdate(tick)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __buyIfMeet(self, tick):\n        ''' place buy order if conditions meet '''\n        # place short sell order\n        '''\n        if (self.__smaShort.getLastValue() < self.__smaLong.getLastValue() or self.__smaMid.getLastValue() < self.__smaLong.getLastValue()):\n            if tick.close/self.__previousMovingLowWeek < 0.95:\n                return\n\n            if self.__previousSmaShort > self.__previousSmaLong and self.__smaShort.getLastValue() < self.__smaLong.getLastValue() and self.__previousSmaVolumeMid < (self.__previousSmaVolumeShort/1.1):\n                # assume no commission fee for now\n                self.__placeSellShortOrder(tick)\n\n            elif self.__previousSmaLong > self.__previousSmaShort > self.__previousSmaMid and self.__smaLong.getLastValue() > self.__smaMid.getLastValue() > self.__smaShort.getLastValue():\n                # assume no commission fee for now\n                self.__placeSellShortOrder(tick)\n        '''\n        # place buy order\n        if (self.__smaShort.getLastValue() > self.__smaLong.getLastValue() or self.__smaMid.getLastValue() > self.__smaLong.getLastValue()):\n            if tick.close / self.__previousMovingLowWeek > 1.05:\n                return\n\n            if self.__previousSmaShort < self.__previousSmaLong and self.__smaShort.getLastValue() > self.__smaLong.getLastValue() and self.__previousSmaVolumeMid < (self.__previousSmaVolumeShort / 1.1):\n                # assume no commission fee for now\n                self.__placeBuyOrder(tick)\n\n            elif self.__previousSmaLong < self.__previousSmaShort < self.__previousSmaMid and self.__smaLong.getLastValue() < self.__smaMid.getLastValue() < self.__smaShort.getLastValue() and self.__previousSmaVolumeMid < (self.__previousSmaVolumeShort / 1.1):\n                # assume no commission fee for now\n                self.__placeBuyOrder(tick)", "response": "place short sell order if conditions meet"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __placeSellShortOrder(self, tick):\n        ''' place short sell order'''\n        share=math.floor(self.__strategy.getAccountCopy().getCash() / float(tick.close))\n        sellShortOrder=Order(accountId=self.__strategy.accountId,\n                                  action=Action.SELL_SHORT,\n                                  is_market=True,\n                                  security=self.__security,\n                                  share=share)\n\n        if self.__strategy.placeOrder(sellShortOrder):\n            self.__buyOrder=sellShortOrder\n\n            # place stop order\n            stopOrder=Order(accountId=self.__strategy.accountId,\n                          action=Action.BUY_TO_COVER,\n                          is_stop=True,\n                          security=self.__security,\n                          price=tick.close * 1.05,\n                          share=0 - share)\n            self.__placeStopOrder(stopOrder)", "response": "place sell short order"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __getCashToBuyStock(self):\n        ''' calculate the amount of money to buy stock '''\n        account=self.__strategy.getAccountCopy()\n        if (account.getCash() >= account.getTotalValue() / self.buying_ratio):\n            return account.getTotalValue() / self.buying_ratio\n        else:\n            return 0", "response": "calculate the amount of money to buy stock"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling back for executed order", "response": "def orderExecuted(self, orderId):\n        ''' call back for executed order '''\n        if orderId == self.__stopOrderId:\n            LOG.debug(\"smaStrategy stop order canceled %s\" % orderId)\n            # stop order executed\n            self.__clearStopOrder()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __adjustStopOrder(self, tick):\n        ''' update stop order if needed '''\n        if not self.__stopOrderId:\n            return\n\n        if self.__stopOrder.action == Action.SELL:\n            orgStopPrice=self.__buyOrder.price * 0.95\n            newStopPrice=max(((tick.close + orgStopPrice) / 2), tick.close * 0.85)\n            newStopPrice=min(newStopPrice, tick.close * 0.95)\n\n            if newStopPrice > self.__stopOrder.price:\n                self.__strategy.tradingEngine.cancelOrder(self.__security, self.__stopOrderId)\n                stopOrder=Order(accountId=self.__strategy.accountId,\n                                  action=Action.SELL,\n                                  is_stop=True,\n                                  security=self.__security,\n                                  price=newStopPrice,\n                                  share=self.__stopOrder.share)\n                self.__placeStopOrder(stopOrder)\n        '''\n        elif self.__stopOrder.action == Action.BUY_TO_COVER:\n            orgStopPrice=self.__buyOrder.price * 1.05\n            newStopPrice=min(((orgStopPrice + tick.close) / 2), tick.close * 1.15)\n            newStopPrice=max(newStopPrice, tick.close * 1.05)\n\n            if newStopPrice < self.__stopOrder.price:\n                self.__strategy.tradingEngine.cancelOrder(self.__security, self.__stopOrderId)\n                stopOrder=Order(accountId=self.__strategy.accountId,\n                                  action=Action.BUY_TO_COVER,\n                                  type=Type.STOP,\n                                  security=self.__security,\n                                  price=newStopPrice,\n                                  share=self.__stopOrder.share)\n                self.__placeStopOrder(stopOrder)\n        '''", "response": "adjusts the stop order if needed"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __updatePreviousState(self, tick):\n        ''' update previous state '''\n        self.__previousTick=tick\n        self.__previousSmaShort=self.__smaShort.getLastValue()\n        self.__previousSmaMid=self.__smaMid.getLastValue()\n        self.__previousSmaLong=self.__smaLong.getLastValue()\n        self.__previousSmaVolumeShort=self.__smaVolumeShort.getLastValue()\n        self.__previousSmaVolumeMid=self.__smaVolumeMid.getLastValue()\n        self.__previousMovingLowShort=self.__movingLowShort.getLastValue()\n        self.__previousMovingLowWeek=self.__movingLowWeek.getLastValue()", "response": "update previous state of the record"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tickUpdate(self, tick):\n        ''' consume ticks '''\n        LOG.debug(\"tickUpdate %s with tick %s, price %s\" % (self.__security, tick.time, tick.close))\n        # update sma\n        self.__smaShort(tick.close)\n        self.__smaMid(tick.close)\n        self.__smaLong(tick.close)\n        self.__smaVolumeShort(tick.volume)\n        self.__smaVolumeMid(tick.volume)\n        self.__movingLowShort(tick.close)\n        self.__movingLowWeek(tick.close)\n\n        # if not enough data, skip to reduce risk -- SKIP NEWLY IPOs\n        if not self.__smaLong.getLastValue() or not self.__smaMid.getLastValue() or not self.__smaShort.getLastValue():\n            self.__updatePreviousState(tick)\n            return\n\n        # if haven't started, don't do any trading\n        if tick.time <= self.start_date:\n            return\n\n        # already have some holdings\n        if self.__stopOrderId:\n            self.__sellIfMeet(tick)\n            self.__adjustStopOrder(tick)\n\n        # don't have any holdings\n        if not self.__stopOrderId and self.__getCashToBuyStock():\n            self.__buyIfMeet(tick)\n\n        self.__updatePreviousState(tick)", "response": "update the internal state of the internal state of the IPOs with the tick"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nincrementing a single value in the sequence string", "response": "def _inc(self, val):\n        \"\"\"Increment a single value\"\"\"\n        assert(len(val) == self.sequence_length)\n        return self.sequence_string[(self.sequence_string.index(val)+1) % len(self.sequence_string)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the value of the attribute of the object", "response": "def set(self, val):\n        \"\"\"Set the value\"\"\"\n        import time\n        now = time.time()\n        expected_value = []\n        new_val = {}\n        new_val['timestamp'] = now\n        if self._value != None:\n            new_val['last_value'] = self._value\n            expected_value = ['current_value', str(self._value)]\n        new_val['current_value'] = val\n        try:\n            self.db.put_attributes(self.id, new_val, expected_value=expected_value)\n            self.timestamp = new_val['timestamp']\n        except SDBResponseError, e:\n            if e.status == 409:\n                raise ValueError, \"Sequence out of sync\"\n            else:\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self):\n        val = self.db.get_attributes(self.id, consistent_read=True)\n        if val:\n            if val.has_key('timestamp'):\n                self.timestamp = val['timestamp']\n            if val.has_key('current_value'):\n                self._value = self.item_type(val['current_value'])\n            if val.has_key(\"last_value\") and val['last_value'] != None:\n                self.last_value = self.item_type(val['last_value'])\n        return self._value", "response": "Get the value of the attribute"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _connect(self):\n        if not self._db:\n            import boto\n            sdb = boto.connect_sdb()\n            if not self.domain_name:\n                self.domain_name = boto.config.get(\"DB\", \"sequence_db\", boto.config.get(\"DB\", \"db_name\", \"default\"))\n            try:\n                self._db = sdb.get_domain(self.domain_name)\n            except SDBResponseError, e:\n                if e.status == 400:\n                    self._db = sdb.create_domain(self.domain_name)\n                else:\n                    raise\n        return self._db", "response": "Connect to our domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_credential_file(self, path):\n        c_data = StringIO.StringIO()\n        c_data.write(\"[Credentials]\\n\")\n        for line in open(path, \"r\").readlines():\n            c_data.write(line.replace(\"AWSAccessKeyId\", \"aws_access_key_id\").replace(\"AWSSecretKey\", \"aws_secret_access_key\"))\n        c_data.seek(0)\n        self.readfp(c_data)", "response": "Load a credential file as is setup like the Java utilities"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_option(self, path, section, option, value):\n        config = ConfigParser.SafeConfigParser()\n        config.read(path)\n        if not config.has_section(section):\n            config.add_section(section)\n        config.set(section, option, value)\n        fp = open(path, 'w')\n        config.write(fp)\n        fp.close()\n        if not self.has_section(section):\n            self.add_section(section)\n        self.set(section, option, value)", "response": "Save the specified option to the config file specified by path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_batch(self, table, keys, attributes_to_get=None):\n        self.append(Batch(table, keys, attributes_to_get))", "response": "Adds a batch to the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects a connection to the appropriate provider based on the given URI.", "response": "def connect(self, access_key_id=None, secret_access_key=None, **kwargs):\n        \"\"\"\n        Opens a connection to appropriate provider, depending on provider\n        portion of URI. Requires Credentials defined in boto config file (see\n        boto/pyami/config.py).\n        @type storage_uri: StorageUri\n        @param storage_uri: StorageUri specifying a bucket or a bucket+object\n        @rtype: L{AWSAuthConnection<boto.gs.connection.AWSAuthConnection>}\n        @return: A connection to storage service provider of the given URI.\n        \"\"\"\n        connection_args = dict(self.connection_args or ())\n        # Use OrdinaryCallingFormat instead of boto-default\n        # SubdomainCallingFormat because the latter changes the hostname\n        # that's checked during cert validation for HTTPS connections,\n        # which will fail cert validation (when cert validation is enabled).\n        # Note: the following import can't be moved up to the start of\n        # this file else it causes a config import failure when run from\n        # the resumable upload/download tests.\n        from boto.s3.connection import OrdinaryCallingFormat\n        connection_args['calling_format'] = OrdinaryCallingFormat()\n        if (hasattr(self, 'suppress_consec_slashes') and\n            'suppress_consec_slashes' not in connection_args):\n            connection_args['suppress_consec_slashes'] = (\n                self.suppress_consec_slashes)\n        connection_args.update(kwargs)\n        if not self.connection:\n            if self.scheme in self.provider_pool:\n                self.connection = self.provider_pool[self.scheme]\n            elif self.scheme == 's3':\n                from boto.s3.connection import S3Connection\n                self.connection = S3Connection(access_key_id,\n                                               secret_access_key,\n                                               **connection_args)\n                self.provider_pool[self.scheme] = self.connection\n            elif self.scheme == 'gs':\n                from boto.gs.connection import GSConnection\n                self.connection = GSConnection(access_key_id,\n                                               secret_access_key,\n                                               **connection_args)\n                self.provider_pool[self.scheme] = self.connection\n            elif self.scheme == 'file':\n                from boto.file.connection import FileConnection\n                self.connection = FileConnection(self)\n            else:\n                raise InvalidUriError('Unrecognized scheme \"%s\"' %\n                                      self.scheme)\n        self.connection.debug = self.debug\n        return self.connection"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a bucket s acl", "response": "def get_acl(self, validate=True, headers=None, version_id=None):\n        \"\"\"returns a bucket's acl\"\"\"\n        if not self.bucket_name:\n            raise InvalidUriError('get_acl on bucket-less URI (%s)' % self.uri)\n        bucket = self.get_bucket(validate, headers)\n        # This works for both bucket- and object- level ACLs (former passes\n        # key_name=None):\n        acl = bucket.get_acl(self.object_name, headers, version_id)\n        self.check_response(acl, 'acl', self.uri)\n        return acl"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset or updates a bucket s acl", "response": "def set_acl(self, acl_or_str, key_name='', validate=True, headers=None,\n                version_id=None):\n        \"\"\"sets or updates a bucket's acl\"\"\"\n        if not self.bucket_name:\n            raise InvalidUriError('set_acl on bucket-less URI (%s)' %\n                                  self.uri)\n        self.get_bucket(validate, headers).set_acl(acl_or_str, key_name,\n                                                   headers, version_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_canned_acl(self, acl_str, validate=True, headers=None,\n                       version_id=None):\n        \"\"\"sets or updates a bucket's acl to a predefined (canned) value\"\"\"\n        if not self.object_name:\n            raise InvalidUriError('set_canned_acl on object-less URI (%s)' %\n                                  self.uri)\n        key = self.get_key(validate, headers)\n        self.check_response(key, 'key', self.uri)\n        key.set_canned_acl(acl_str, headers, version_id)", "response": "sets or updates a bucket s acl to a predefined ( canned ) value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef names_container(self):\n        if not self.stream:\n            return os.path.isdir(self.object_name)\n        else:\n            return False", "response": "Returns True if this URI is not representing input or output stream\n        and names a directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if this URI names a file or a file - like object.", "response": "def names_singleton(self):\n        \"\"\"Returns True if this URI names a file or\n        if URI represents input/output stream.\n        \"\"\"\n        if self.stream:\n            return True\n        else:\n            return os.path.isfile(self.object_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn stock prices for Apple company.", "response": "def fetch_appl():\n    \"\"\"Returns stock prices for Apple company.\"\"\"\n    yql = YQL('AAPL', '2014-01-01', '2014-01-10')\n\n    for item in yql:\n        print item.get('date'), item.get('price')\n\n    yql.select('AAPL', '2014-01-01', '2014-01-10')\n\n    for item in yql:\n        print item.get('date'), item.get('price')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_googl():\n    yql = YQL('GOOGL', '2014-01-01', '2014-01-10')\n\n    for item in yql:\n        print item.get('date'), item.get('price')\n\n    yql.select('GOOGL', '2014-01-01', '2014-01-10')\n\n    for item in yql:\n        print item.get('date'), item.get('price')", "response": "Returns stock prices for Google company."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, validate=False):\n        # Check the resultset since Eucalyptus ignores the volumeId param\n        unfiltered_rs = self.connection.get_all_volumes([self.id])\n        rs = [ x for x in unfiltered_rs if x.id == self.id ]\n        if len(rs) > 0:\n            self._update(rs[0])\n        elif validate:\n            raise ValueError('%s is not a valid Volume ID' % self.id)\n        return self.status", "response": "Update the data associated with this volume by querying EC2."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef attach(self, instance_id, device):\n        return self.connection.attach_volume(self.id, instance_id, device)", "response": "Attach this EBS volume to an EC2 instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetach this EBS volume from an EC2 instance.", "response": "def detach(self, force=False):\n        \"\"\"\n        Detach this EBS volume from an EC2 instance.\n\n        :type force: bool\n        :param force: Forces detachment if the previous detachment attempt did\n                      not occur cleanly.  This option can lead to data loss or\n                      a corrupted file system. Use this option only as a last\n                      resort to detach a volume from a failed instance. The\n                      instance will not have an opportunity to flush file system\n                      caches nor file system meta data. If you use this option,\n                      you must perform file system check and repair procedures.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        instance_id = None\n        if self.attach_data:\n            instance_id = self.attach_data.instance_id\n        device = None\n        if self.attach_data:\n            device = self.attach_data.device\n        return self.connection.detach_volume(self.id, instance_id, device, force)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef attachment_state(self):\n        state = None\n        if self.attach_data:\n            state = self.attach_data.status\n        return state", "response": "Get the attachment state."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all snapshots related to this volume.", "response": "def snapshots(self, owner=None, restorable_by=None):\n        \"\"\"\n        Get all snapshots related to this volume.  Note that this requires\n        that all available snapshots for the account be retrieved from EC2\n        first and then the list is filtered client-side to contain only\n        those for this volume.\n\n        :type owner: str\n        :param owner: If present, only the snapshots owned by the specified user\n                      will be returned.  Valid values are:\n                      self | amazon | AWS Account ID\n\n        :type restorable_by: str\n        :param restorable_by: If present, only the snapshots that are restorable\n                              by the specified account id will be returned.\n\n        :rtype: list of L{boto.ec2.snapshot.Snapshot}\n        :return: The requested Snapshot objects\n        \n        \"\"\"\n        rs = self.connection.get_all_snapshots(owner=owner,\n                                               restorable_by=restorable_by)\n        mine = []\n        for snap in rs:\n            if snap.volume_id == self.id:\n                mine.append(snap)\n        return mine"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_encryption_key():\n    '''Method for accessing an encryption key based on the SECRET_KEY\n    defined in django settings.'''\n    # initialize ENCRYPTION_KEY the first time it is needed, so that\n    # applications that use eulcore without using this specific\n    # functionality do not get bogus warnings about SECRET_KEY size.\n    global ENCRYPTION_KEY\n    if ENCRYPTION_KEY is None:\n        # NOTE: Blowfish key length is variable but must be 32-448 bits\n        # (but PyCrypto does not actually make this information accessible)\n        KEY_MIN_CHARS = 32/8\n        KEY_MAX_CHARS = 448/8\n        if KEY_MIN_CHARS <= len(settings.SECRET_KEY) <= KEY_MAX_CHARS:\n            ENCRYPTION_KEY = settings.SECRET_KEY\n        else:\n            ENCRYPTION_KEY = hashlib.sha224(settings.SECRET_KEY).hexdigest()\n            message = '''Django secret key (current length of %d) requires hashing for use as encryption key\n            (to avoid hashing, should be %d-%d characters)''' % \\\n            (len(settings.SECRET_KEY), KEY_MIN_CHARS, KEY_MAX_CHARS)\n            logger.warn(message)\n    return ENCRYPTION_KEY", "response": "Method for accessing an encryption key based on the SECRET_KEY defined in django settings."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencrypt a string using an encryption key based on the django SECRET_KEY", "response": "def encrypt(text):\n    'Encrypt a string using an encryption key based on the django SECRET_KEY'\n    crypt = EncryptionAlgorithm.new(_get_encryption_key())\n    return crypt.encrypt(to_blocksize(text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses the arguments passed to the request and create a new set of parameters that will be sent to the AWS service.", "response": "def process_args(self, **args):\n        \"\"\"\n        Responsible for walking through Params defined for the request and:\n\n        * Matching them with keyword parameters passed to the request\n          constructor or via the command line.\n        * Checking to see if all required parameters have been specified\n          and raising an exception, if not.\n        * Encoding each value into the set of request parameters that will\n          be sent in the request to the AWS service.\n        \"\"\"\n        self.args.update(args)\n        self.connection_args = copy.copy(self.args)\n        if 'debug' in self.args and self.args['debug'] >= 2:\n            boto.set_stream_logger(self.name())\n        required = [p.name for p in self.Params+self.Args if not p.optional]\n        for param in self.Params+self.Args:\n            if param.long_name:\n                python_name = param.long_name.replace('-', '_')\n            else:\n                python_name = boto.utils.pythonize_name(param.name, '_')\n            value = None\n            if python_name in self.args:\n                value = self.args[python_name]\n            if value is None:\n                value = param.default\n            if value is not None:\n                if param.name in required:\n                    required.remove(param.name)\n                if param.request_param:\n                    if param.encoder:\n                        param.encoder(param, self.request_params, value)\n                    else:\n                        Encoder.encode(param, self.request_params, value)\n            if python_name in self.args:\n                del self.connection_args[python_name]\n        if required:\n            l = []\n            for p in self.Params+self.Args:\n                if p.name in required:\n                    if p.short_name and p.long_name:\n                        l.append('(%s, %s)' % (p.optparse_short_name,\n                                               p.optparse_long_name))\n                    elif p.short_name:\n                        l.append('(%s)' % p.optparse_short_name)\n                    else:\n                        l.append('(%s)' % p.optparse_long_name)\n            raise RequiredParamError(','.join(l))\n        boto.log.debug('request_params: %s' % self.request_params)\n        self.process_markers(self.Response)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef item_object_hook(dct):\n    if len(dct.keys()) > 1:\n        return dct\n    if 'S' in dct:\n        return dct['S']\n    if 'N' in dct:\n        return convert_num(dct['N'])\n    if 'SS' in dct:\n        return set(dct['SS'])\n    if 'NS' in dct:\n        return set(map(convert_num, dct['NS']))\n    return dct", "response": "A custom object hook for use when decoding JSON items."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a set of pending item updates into a dictionary that can be used to update a resource attribute.", "response": "def dynamize_attribute_updates(self, pending_updates):\n        \"\"\"\n        Convert a set of pending item updates into the structure\n        required by Layer1.\n        \"\"\"\n        d = {}\n        for attr_name in pending_updates:\n            action, value = pending_updates[attr_name]\n            if value is None:\n                # DELETE without an attribute value\n                d[attr_name] = {\"Action\": action}\n            else:\n                d[attr_name] = {\"Action\": action,\n                                \"Value\": self.dynamize_value(value)}\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a layer2 range key condition into the structure required by Layer1.", "response": "def dynamize_range_key_condition(self, range_key_condition):\n        \"\"\"\n        Convert a layer2 range_key_condition parameter into the\n        structure required by Layer1.\n        \"\"\"\n        d = None\n        if range_key_condition:\n            d = {}\n            for range_value in range_key_condition:\n                range_condition = range_key_condition[range_value]\n                if range_condition == 'BETWEEN':\n                    if isinstance(range_value, tuple):\n                        avl = [self.dynamize_value(v) for v in range_value]\n                    else:\n                        msg = 'BETWEEN condition requires a tuple value'\n                        raise TypeError(msg)\n                elif isinstance(range_value, tuple):\n                    msg = 'Tuple can only be supplied with BETWEEN condition'\n                    raise TypeError(msg)\n                else:\n                    avl = [self.dynamize_value(range_value)]\n            d = {'AttributeValueList': avl,\n                 'ComparisonOperator': range_condition}\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a layer2 scan_filter parameter into the structure required by Layer1.", "response": "def dynamize_scan_filter(self, scan_filter):\n        \"\"\"\n        Convert a layer2 scan_filter parameter into the\n        structure required by Layer1.\n        \"\"\"\n        d = None\n        if scan_filter:\n            d = {}\n            for attr_name, op, value in scan_filter:\n                if op == 'BETWEEN':\n                    if isinstance(value, tuple):\n                        avl = [self.dynamize_value(v) for v in value]\n                    else:\n                        msg = 'BETWEEN condition requires a tuple value'\n                        raise TypeError(msg)\n                elif op == 'NULL' or op == 'NOT_NULL':\n                    avl = None\n                elif isinstance(value, tuple):\n                    msg = 'Tuple can only be supplied with BETWEEN condition'\n                    raise TypeError(msg)\n                else:\n                    avl = [self.dynamize_value(value)]\n            dd = {'ComparisonOperator': op}\n            if avl:\n                dd['AttributeValueList'] = avl\n            d[attr_name] = dd\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting an expected_value parameter into the data structure required for Layer1.", "response": "def dynamize_expected_value(self, expected_value):\n        \"\"\"\n        Convert an expected_value parameter into the data structure\n        required for Layer1.\n        \"\"\"\n        d = None\n        if expected_value:\n            d = {}\n            for attr_name in expected_value:\n                attr_value = expected_value[attr_name]\n                if attr_value is True:\n                    attr_value = {'Exists': True}\n                elif attr_value is False:\n                    attr_value = {'Exists': False}\n                else:\n                    val = self.dynamize_value(expected_value[attr_name])\n                    attr_value = {'Value': val}\n                d[attr_name] = attr_value\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a last_evaluated_key parameter into the data structure required for Layer1.", "response": "def dynamize_last_evaluated_key(self, last_evaluated_key):\n        \"\"\"\n        Convert a last_evaluated_key parameter into the data structure\n        required for Layer1.\n        \"\"\"\n        d = None\n        if last_evaluated_key:\n            hash_key = last_evaluated_key['HashKeyElement']\n            d = {'HashKeyElement': self.dynamize_value(hash_key)}\n            if 'RangeKeyElement' in last_evaluated_key:\n                range_key = last_evaluated_key['RangeKeyElement']\n                d['RangeKeyElement'] = self.dynamize_value(range_key)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dynamize_request_items(self, batch_list):\n        d = None\n        if batch_list:\n            d = {}\n            for batch in batch_list:\n                batch_dict = {}\n                key_list = []\n                for key in batch.keys:\n                    if isinstance(key, tuple):\n                        hash_key, range_key = key\n                    else:\n                        hash_key = key\n                        range_key = None\n                    k = self.build_key_from_values(batch.table.schema,\n                                                   hash_key, range_key)\n                    key_list.append(k)\n                batch_dict['Keys'] = key_list\n                if batch.attributes_to_get:\n                    batch_dict['AttributesToGet'] = batch.attributes_to_get\n            d[batch.table.name] = batch_dict\n        return d", "response": "Convert a request_items parameter into the data structure that Layer1 provides."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a scalar Python value and return a string representing the corresponding Amazon DynamoDB type.", "response": "def get_dynamodb_type(self, val):\n        \"\"\"\n        Take a scalar Python value and return a string representing\n        the corresponding Amazon DynamoDB type.  If the value passed in is\n        not a supported type, raise a TypeError.\n        \"\"\"\n        dynamodb_type = None\n        if is_num(val):\n            dynamodb_type = 'N'\n        elif is_str(val):\n            dynamodb_type = 'S'\n        elif isinstance(val, (set, frozenset)):\n            if False not in map(is_num, val):\n                dynamodb_type = 'NS'\n            elif False not in map(is_str, val):\n                dynamodb_type = 'SS'\n        if dynamodb_type is None:\n            raise TypeError('Unsupported type \"%s\" for value \"%s\"' % (type(val), val))\n        return dynamodb_type"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dynamize_value(self, val):\n        def _str(val):\n            \"\"\"\n            DynamoDB stores booleans as numbers. True is 1, False is 0.\n            This function converts Python booleans into DynamoDB friendly\n            representation.\n            \"\"\"\n            if isinstance(val, bool):\n                return str(int(val))\n            return str(val)\n\n        dynamodb_type = self.get_dynamodb_type(val)\n        if dynamodb_type == 'N':\n            val = {dynamodb_type : _str(val)}\n        elif dynamodb_type == 'S':\n            val = {dynamodb_type : val}\n        elif dynamodb_type == 'NS':\n            val = {dynamodb_type : [ str(n) for n in val]}\n        elif dynamodb_type == 'SS':\n            val = {dynamodb_type : [ n for n in val]}\n        return val", "response": "Take a scalar Python value and return a dict consisting of the Amazon DynamoDB type specification and the value that requires to be sent to Amazon DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_key_from_values(self, schema, hash_key, range_key=None):\n        dynamodb_key = {}\n        dynamodb_value = self.dynamize_value(hash_key)\n        if dynamodb_value.keys()[0] != schema.hash_key_type:\n            msg = 'Hashkey must be of type: %s' % schema.hash_key_type\n            raise TypeError(msg)\n        dynamodb_key['HashKeyElement'] = dynamodb_value\n        if range_key is not None:\n            dynamodb_value = self.dynamize_value(range_key)\n            if dynamodb_value.keys()[0] != schema.range_key_type:\n                msg = 'RangeKey must be of type: %s' % schema.range_key_type\n                raise TypeError(msg)\n            dynamodb_key['RangeKeyElement'] = dynamodb_value\n        return dynamodb_key", "response": "Builds a Key structure from the supplied hash key and optional range key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_tables(self, limit=None, start_table=None):\n        result = self.layer1.list_tables(limit, start_table)\n        return result['TableNames']", "response": "List all tables associated with the current account and region."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the Table object for an existing table.", "response": "def get_table(self, name):\n        \"\"\"\n        Retrieve the Table object for an existing table.\n\n        :type name: str\n        :param name: The name of the desired table.\n\n        :rtype: :class:`boto.dynamodb.table.Table`\n        :return: A Table object representing the table.\n        \"\"\"\n        response = self.layer1.describe_table(name)\n        return Table(self,  response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_table(self, name, schema, read_units, write_units):\n        response = self.layer1.create_table(name, schema.dict,\n                                            {'ReadCapacityUnits': read_units,\n                                             'WriteCapacityUnits': write_units})\n        return Table(self,  response)", "response": "Creates a new table in the specified table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_throughput(self, table, read_units, write_units):\n        response = self.layer1.update_table(table.name,\n                                            {'ReadCapacityUnits': read_units,\n                                             'WriteCapacityUnits': write_units})\n        table.update_from_response(response['TableDescription'])", "response": "Update the ProvisionedThroughput for the Amazon DynamoDB Table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting this table and all items in it.", "response": "def delete_table(self, table):\n        \"\"\"\n        Delete this table and all items in it.  After calling this\n        the Table objects status attribute will be set to 'DELETING'.\n\n        :type table: :class:`boto.dynamodb.table.Table`\n        :param table: The Table object that is being deleted.\n        \"\"\"\n        response = self.layer1.delete_table(table.name)\n        table.update_from_response(response)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_schema(self, hash_key_name, hash_key_proto_value,\n                      range_key_name=None, range_key_proto_value=None):\n        \"\"\"\n        Create a Schema object used when creating a Table.\n\n        :type hash_key_name: str\n        :param hash_key_name: The name of the HashKey for the schema.\n\n        :type hash_key_proto_value: int|long|float|str|unicode\n        :param hash_key_proto_value: A sample or prototype of the type\n            of value you want to use for the HashKey.\n            \n        :type range_key_name: str\n        :param range_key_name: The name of the RangeKey for the schema.\n            This parameter is optional.\n\n        :type range_key_proto_value: int|long|float|str|unicode\n        :param range_key_proto_value: A sample or prototype of the type\n            of value you want to use for the RangeKey.  This parameter\n            is optional.\n        \"\"\"\n        schema = {}\n        hash_key = {}\n        hash_key['AttributeName'] = hash_key_name\n        hash_key_type = self.get_dynamodb_type(hash_key_proto_value)\n        hash_key['AttributeType'] = hash_key_type\n        schema['HashKeyElement'] = hash_key\n        if range_key_name and range_key_proto_value is not None:\n            range_key = {}\n            range_key['AttributeName'] = range_key_name\n            range_key_type = self.get_dynamodb_type(range_key_proto_value)\n            range_key['AttributeType'] = range_key_type\n            schema['RangeKeyElement'] = range_key\n        return Schema(schema)", "response": "Create a Schema object used when creating a Table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_item(self, table, hash_key, range_key=None,\n                 attributes_to_get=None, consistent_read=False,\n                 item_class=Item):\n        \"\"\"\n        Retrieve an existing item from the table.\n\n        :type table: :class:`boto.dynamodb.table.Table`\n        :param table: The Table object from which the item is retrieved.\n        \n        :type hash_key: int|long|float|str|unicode\n        :param hash_key: The HashKey of the requested item.  The\n            type of the value must match the type defined in the\n            schema for the table.\n        \n        :type range_key: int|long|float|str|unicode\n        :param range_key: The optional RangeKey of the requested item.\n            The type of the value must match the type defined in the\n            schema for the table.\n            \n        :type attributes_to_get: list\n        :param attributes_to_get: A list of attribute names.\n            If supplied, only the specified attribute names will\n            be returned.  Otherwise, all attributes will be returned.\n\n        :type consistent_read: bool\n        :param consistent_read: If True, a consistent read\n            request is issued.  Otherwise, an eventually consistent\n            request is issued.\n\n        :type item_class: Class\n        :param item_class: Allows you to override the class used\n            to generate the items. This should be a subclass of\n            :class:`boto.dynamodb.item.Item`\n        \"\"\"\n        key = self.build_key_from_values(table.schema, hash_key, range_key)\n        response = self.layer1.get_item(table.name, key,\n                                        attributes_to_get, consistent_read,\n                                        object_hook=item_object_hook)\n        item = item_class(table, hash_key, range_key, response['Item'])\n        if 'ConsumedCapacityUnits' in response:\n            item.consumed_units = response['ConsumedCapacityUnits']\n        return item", "response": "Retrieves an existing item from the table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef batch_get_item(self, batch_list):\n        request_items = self.dynamize_request_items(batch_list)\n        return self.layer1.batch_get_item(request_items,\n                                          object_hook=item_object_hook)", "response": "Batch get item method."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstores an item or completely replace an existing item.", "response": "def put_item(self, item, expected_value=None, return_values=None):\n        \"\"\"\n        Store a new item or completely replace an existing item\n        in Amazon DynamoDB.\n\n        :type item: :class:`boto.dynamodb.item.Item`\n        :param item: The Item to write to Amazon DynamoDB.\n        \n        :type expected_value: dict\n        :param expected_value: A dictionary of name/value pairs that you expect.\n            This dictionary should have name/value pairs where the name\n            is the name of the attribute and the value is either the value\n            you are expecting or False if you expect the attribute not to\n            exist.\n\n        :type return_values: str\n        :param return_values: Controls the return of attribute\n            name-value pairs before then were changed.  Possible\n            values are: None or 'ALL_OLD'. If 'ALL_OLD' is\n            specified and the item is overwritten, the content\n            of the old item is returned.\n            \n        \"\"\"\n        expected_value = self.dynamize_expected_value(expected_value)\n        response = self.layer1.put_item(item.table.name,\n                                        self.dynamize_item(item),\n                                        expected_value, return_values,\n                                        object_hook=item_object_hook)\n        if 'ConsumedCapacityUnits' in response:\n            item.consumed_units = response['ConsumedCapacityUnits']\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_item(self, item, expected_value=None, return_values=None):\n        expected_value = self.dynamize_expected_value(expected_value)\n        key = self.build_key_from_values(item.table.schema,\n                                         item.hash_key, item.range_key)\n        attr_updates = self.dynamize_attribute_updates(item._updates)\n\n        response = self.layer1.update_item(item.table.name, key,\n                                           attr_updates,\n                                           expected_value, return_values,\n                                           object_hook=item_object_hook)\n        item._updates.clear()\n        if 'ConsumedCapacityUnits' in response:\n            item.consumed_units = response['ConsumedCapacityUnits']\n        return response", "response": "Commit pending item updates to Amazon DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete the item from Amazon DynamoDB.", "response": "def delete_item(self, item, expected_value=None, return_values=None):\n        \"\"\"\n        Delete the item from Amazon DynamoDB.\n\n        :type item: :class:`boto.dynamodb.item.Item`\n        :param item: The Item to delete from Amazon DynamoDB.\n        \n        :type expected_value: dict\n        :param expected_value: A dictionary of name/value pairs that you expect.\n            This dictionary should have name/value pairs where the name\n            is the name of the attribute and the value is either the value\n            you are expecting or False if you expect the attribute not to\n            exist.\n            \n        :type return_values: str\n        :param return_values: Controls the return of attribute\n            name-value pairs before then were changed.  Possible\n            values are: None or 'ALL_OLD'. If 'ALL_OLD' is\n            specified and the item is overwritten, the content\n            of the old item is returned.\n        \"\"\"\n        expected_value = self.dynamize_expected_value(expected_value)\n        key = self.build_key_from_values(item.table.schema,\n                                         item.hash_key, item.range_key)\n        return self.layer1.delete_item(item.table.name, key,\n                                       expected=expected_value,\n                                       return_values=return_values,\n                                       object_hook=item_object_hook)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming a query on the table. :type table: :class:`boto.dynamodb.table.Table` :param table: The Table object that is being queried. :type hash_key: int|long|float|str|unicode :param hash_key: The HashKey of the requested item. The type of the value must match the type defined in the schema for the table. :type range_key_condition: dict :param range_key_condition: A dict where the key is either a scalar value appropriate for the RangeKey in the schema of the database or a tuple of such values. The value associated with this key in the dict will be one of the following conditions: 'EQ'|'LE'|'LT'|'GE'|'GT'|'BEGINS_WITH'|'BETWEEN' The only condition which expects or will accept a tuple of values is 'BETWEEN', otherwise a scalar value should be used as the key in the dict. :type attributes_to_get: list :param attributes_to_get: A list of attribute names. If supplied, only the specified attribute names will be returned. Otherwise, all attributes will be returned. :type request_limit: int :param request_limit: The maximum number of items to retrieve from Amazon DynamoDB on each request. You may want to set a specific request_limit based on the provisioned throughput of your table. The default behavior is to retrieve as many results as possible per request. :type max_results: int :param max_results: The maximum number of results that will be retrieved from Amazon DynamoDB in total. For example, if you only wanted to see the first 100 results from the query, regardless of how many were actually available, you could set max_results to 100 and the generator returned from the query method will only yeild 100 results max. :type consistent_read: bool :param consistent_read: If True, a consistent read request is issued. Otherwise, an eventually consistent request is issued. :type scan_index_forward: bool :param scan_index_forward: Specified forward or backward traversal of the index. Default is forward (True). :type exclusive_start_key: list or tuple :param exclusive_start_key: Primary key of the item from which to continue an earlier query. This would be provided as the LastEvaluatedKey in that query. :type item_class: Class :param item_class: Allows you to override the class used to generate the items. This should be a subclass of :class:`boto.dynamodb.item.Item` :rtype: generator", "response": "def query(self, table, hash_key, range_key_condition=None,\n              attributes_to_get=None, request_limit=None,\n              max_results=None, consistent_read=False,\n              scan_index_forward=True, exclusive_start_key=None,\n              item_class=Item):\n        \"\"\"\n        Perform a query on the table.\n        \n        :type table: :class:`boto.dynamodb.table.Table`\n        :param table: The Table object that is being queried.\n        \n        :type hash_key: int|long|float|str|unicode\n        :param hash_key: The HashKey of the requested item.  The\n            type of the value must match the type defined in the\n            schema for the table.\n\n        :type range_key_condition: dict\n        :param range_key_condition: A dict where the key is either\n            a scalar value appropriate for the RangeKey in the schema\n            of the database or a tuple of such values.  The value \n            associated with this key in the dict will be one of the\n            following conditions:\n\n            'EQ'|'LE'|'LT'|'GE'|'GT'|'BEGINS_WITH'|'BETWEEN'\n\n            The only condition which expects or will accept a tuple\n            of values is 'BETWEEN', otherwise a scalar value should\n            be used as the key in the dict.\n        \n        :type attributes_to_get: list\n        :param attributes_to_get: A list of attribute names.\n            If supplied, only the specified attribute names will\n            be returned.  Otherwise, all attributes will be returned.\n\n        :type request_limit: int\n        :param request_limit: The maximum number of items to retrieve\n            from Amazon DynamoDB on each request.  You may want to set\n            a specific request_limit based on the provisioned throughput\n            of your table.  The default behavior is to retrieve as many\n            results as possible per request.\n\n        :type max_results: int\n        :param max_results: The maximum number of results that will\n            be retrieved from Amazon DynamoDB in total.  For example,\n            if you only wanted to see the first 100 results from the\n            query, regardless of how many were actually available, you\n            could set max_results to 100 and the generator returned\n            from the query method will only yeild 100 results max.\n\n        :type consistent_read: bool\n        :param consistent_read: If True, a consistent read\n            request is issued.  Otherwise, an eventually consistent\n            request is issued.\n\n        :type scan_index_forward: bool\n        :param scan_index_forward: Specified forward or backward\n            traversal of the index.  Default is forward (True).\n\n        :type exclusive_start_key: list or tuple\n        :param exclusive_start_key: Primary key of the item from\n            which to continue an earlier query.  This would be\n            provided as the LastEvaluatedKey in that query.\n\n        :type item_class: Class\n        :param item_class: Allows you to override the class used\n            to generate the items. This should be a subclass of\n            :class:`boto.dynamodb.item.Item`\n\n        :rtype: generator\n        \"\"\"\n        rkc = self.dynamize_range_key_condition(range_key_condition)\n        response = True\n        n = 0\n        while response:\n            if response is True:\n                pass\n            elif response.has_key(\"LastEvaluatedKey\"):\n                lek = response['LastEvaluatedKey']\n                exclusive_start_key = self.dynamize_last_evaluated_key(lek)\n            else:\n                break\n            response = self.layer1.query(table.name,\n                                         self.dynamize_value(hash_key),\n                                         rkc, attributes_to_get, request_limit,\n                                         consistent_read, scan_index_forward,\n                                         exclusive_start_key,\n                                         object_hook=item_object_hook)\n            for item in response['Items']:\n                if max_results and n == max_results:\n                    break\n                yield item_class(table, attrs=item)\n                n += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform a scan of DynamoDB for the specified attributes.", "response": "def scan(self, table, scan_filter=None,\n             attributes_to_get=None, request_limit=None, max_results=None,\n             count=False, exclusive_start_key=None, item_class=Item):\n        \"\"\"\n        Perform a scan of DynamoDB.\n\n        :type table: :class:`boto.dynamodb.table.Table`\n        :param table: The Table object that is being scanned.\n\n        :type scan_filter: A list of tuples\n        :param scan_filter: A list of tuples where each tuple consists\n            of an attribute name, a comparison operator, and either\n            a scalar or tuple consisting of the values to compare\n            the attribute to.  Valid comparison operators are shown below\n            along with the expected number of values that should be supplied.\n\n             * EQ - equal (1)\n             * NE - not equal (1)\n             * LE - less than or equal (1)\n             * LT - less than (1)\n             * GE - greater than or equal (1)\n             * GT - greater than (1)\n             * NOT_NULL - attribute exists (0, use None)\n             * NULL - attribute does not exist (0, use None)\n             * CONTAINS - substring or value in list (1)\n             * NOT_CONTAINS - absence of substring or value in list (1)\n             * BEGINS_WITH - substring prefix (1)\n             * IN - exact match in list (N)\n             * BETWEEN - >= first value, <= second value (2)\n\n        :type attributes_to_get: list\n        :param attributes_to_get: A list of attribute names.\n            If supplied, only the specified attribute names will\n            be returned.  Otherwise, all attributes will be returned.\n\n        :type request_limit: int\n        :param request_limit: The maximum number of items to retrieve\n            from Amazon DynamoDB on each request.  You may want to set\n            a specific request_limit based on the provisioned throughput\n            of your table.  The default behavior is to retrieve as many\n            results as possible per request.\n\n        :type max_results: int\n        :param max_results: The maximum number of results that will\n            be retrieved from Amazon DynamoDB in total.  For example,\n            if you only wanted to see the first 100 results from the\n            query, regardless of how many were actually available, you\n            could set max_results to 100 and the generator returned\n            from the query method will only yeild 100 results max.\n\n        :type count: bool\n        :param count: If True, Amazon DynamoDB returns a total\n            number of items for the Scan operation, even if the\n            operation has no matching items for the assigned filter.\n\n        :type exclusive_start_key: list or tuple\n        :param exclusive_start_key: Primary key of the item from\n            which to continue an earlier query.  This would be\n            provided as the LastEvaluatedKey in that query.\n\n        :type item_class: Class\n        :param item_class: Allows you to override the class used\n            to generate the items. This should be a subclass of\n            :class:`boto.dynamodb.item.Item`\n\n        :rtype: generator\n        \"\"\"\n        sf = self.dynamize_scan_filter(scan_filter)\n        response = True\n        n = 0\n        while response:\n            if response is True:\n                pass\n            elif response.has_key(\"LastEvaluatedKey\"):\n                exclusive_start_key = response['LastEvaluatedKey']\n            else:\n                break\n\n            response = self.layer1.scan(table.name, sf,\n                                        attributes_to_get,request_limit,\n                                        count, exclusive_start_key,\n                                        object_hook=item_object_hook)\n            if response:\n                for item in response['Items']:\n                    if max_results and n == max_results:\n                        break\n                    yield item_class(table, attrs=item)\n                    n += 1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of Photo objects.", "response": "def photos_search(user_id='', auth=False,  tags='', tag_mode='', text='',\\\n                  min_upload_date='', max_upload_date='',\\\n                  min_taken_date='', max_taken_date='', \\\n                  license='', per_page='', page='', sort=''):\n    \"\"\"Returns a list of Photo objects.\n\n    If auth=True then will auth the user.  Can see private etc\n    \"\"\"\n    method = 'flickr.photos.search'\n\n    data = _doget(method, auth=auth, user_id=user_id, tags=tags, text=text,\\\n                  min_upload_date=min_upload_date,\\\n                  max_upload_date=max_upload_date, \\\n                  min_taken_date=min_taken_date, \\\n                  max_taken_date=max_taken_date, \\\n                  license=license, per_page=per_page,\\\n                  page=page, sort=sort)\n    photos = []\n    if isinstance(data.rsp.photos.photo, list):\n        for photo in data.rsp.photos.photo:\n            photos.append(_parse_photo(photo))\n    else:\n        photos = [_parse_photo(data.rsp.photos.photo)]\n    return photos"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef people_findByEmail(email):\n    method = 'flickr.people.findByEmail'\n    data = _doget(method, find_email=email)\n    user = User(data.rsp.user.id, username=data.rsp.user.username.text)\n    return user", "response": "Returns User object for a given email."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef people_findByUsername(username):\n    method = 'flickr.people.findByUsername'\n    data = _doget(method, username=username)\n    user = User(data.rsp.user.id, username=data.rsp.user.username.text)\n    return user", "response": "Returns User object for a given username."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef people_getPublicPhotos(user_id, per_page='', page=''):\n    method = 'flickr.people.getPublicPhotos'\n    data = _doget(method, user_id=user_id, per_page=per_page, page=page)\n    photos = []\n    if hasattr(data.rsp.photos, \"photo\"): # Check if there are photos at all (may be been paging too far).\n        if isinstance(data.rsp.photos.photo, list):\n            for photo in data.rsp.photos.photo:\n                photos.append(_parse_photo(photo))\n        else:\n            photos = [_parse_photo(data.rsp.photos.photo)]\n    return photos", "response": "Returns list of Photo objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning list of Photo objects.", "response": "def favorites_getList(user_id='', per_page='', page=''):\n    \"\"\"Returns list of Photo objects.\"\"\"\n    method = 'flickr.favorites.getList'\n    data = _doget(method, auth=True, user_id=user_id, per_page=per_page,\\\n                  page=page)\n    photos = []\n    if isinstance(data.rsp.photos.photo, list):\n        for photo in data.rsp.photos.photo:\n            photos.append(_parse_photo(photo))\n    else:\n        photos = [_parse_photo(data.rsp.photos.photo)]\n    return photos"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns list of Photo objects.", "response": "def favorites_getPublicList(user_id, per_page='', page=''):\n    \"\"\"Returns list of Photo objects.\"\"\"\n    method = 'flickr.favorites.getPublicList'\n    data = _doget(method, auth=False, user_id=user_id, per_page=per_page,\\\n                  page=page)\n    photos = []\n    if isinstance(data.rsp.photos.photo, list):\n        for photo in data.rsp.photos.photo:\n            photos.append(_parse_photo(photo))\n    else:\n        photos = [_parse_photo(data.rsp.photos.photo)]\n    return photos"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef favorites_add(photo_id):\n    method = 'flickr.favorites.add'\n    _dopost(method, auth=True, photo_id=photo_id)\n    return True", "response": "Add a photo to the user s favorites."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef favorites_remove(photo_id):\n    method = 'flickr.favorites.remove'\n    _dopost(method, auth=True, photo_id=photo_id)\n    return True", "response": "Remove a photo from the user s favorites."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a list of groups the auth'd user can post photos to.", "response": "def groups_pools_getGroups():\n    \"\"\"Get a list of groups the auth'd user can post photos to.\"\"\"\n    method = 'flickr.groups.pools.getGroups'\n    data = _doget(method, auth=True)\n    groups = []\n    if isinstance(data.rsp.groups.group, list):\n        for group in data.rsp.groups.group:\n            groups.append(Group(group.id, name=group.name, \\\n                                privacy=group.privacy))\n    else:\n        group = data.rsp.groups.group\n        groups = [Group(group.id, name=group.name, privacy=group.privacy)]\n    return groups"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tags_getListUser(user_id=''):\n    method = 'flickr.tags.getListUser'\n    auth = user_id == ''\n    data = _doget(method, auth=auth, user_id=user_id)\n    if isinstance(data.rsp.tags.tag, list):\n        return [tag.text for tag in data.rsp.tags.tag]\n    else:\n        return [data.rsp.tags.tag.text]", "response": "Returns a list of tags for the given user"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tags_getListUserPopular(user_id='', count=''):\n    method = 'flickr.tags.getListUserPopular'\n    auth = user_id == ''\n    data = _doget(method, auth=auth, user_id=user_id)\n    result = {}\n    if isinstance(data.rsp.tags.tag, list):\n        for tag in data.rsp.tags.tag:\n            result[tag.text] = tag.count\n    else:\n        result[data.rsp.tags.tag.text] = data.rsp.tags.tag.count\n    return result", "response": "Get the popular tags for a user in dictionary form tag = count"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the related tags for given tag.", "response": "def tags_getrelated(tag):\n    \"\"\"Gets the related tags for given tag.\"\"\"\n    method = 'flickr.tags.getRelated'\n    data = _doget(method, auth=False, tag=tag)\n    if isinstance(data.rsp.tags.tag, list):\n        return [tag.text for tag in data.rsp.tags.tag]\n    else:\n        return [data.rsp.tags.tag.text]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the contacts ( Users ) for the user_id", "response": "def contacts_getPublicList(user_id):\n    \"\"\"Gets the contacts (Users) for the user_id\"\"\"\n    method = 'flickr.contacts.getPublicList'\n    data = _doget(method, auth=False, user_id=user_id)\n    if isinstance(data.rsp.contacts.contact, list):\n        return [User(user.nsid, username=user.username) \\\n                for user in data.rsp.contacts.contact]\n    else:\n        user = data.rsp.contacts.contact\n        return [User(user.nsid, username=user.username)]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_photo(photo):\n    owner = User(photo.owner)\n    title = photo.title\n    ispublic = photo.ispublic\n    isfriend = photo.isfriend\n    isfamily = photo.isfamily\n    secret = photo.secret\n    server = photo.server\n    p = Photo(photo.id, owner=owner, title=title, ispublic=ispublic,\\\n              isfriend=isfriend, isfamily=isfamily, secret=secret, \\\n              server=server)        \n    return p", "response": "Create a Photo object from photo data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_properties(self):\n        self.__loaded = True\n        \n        method = 'flickr.photos.getInfo'\n        data = _doget(method, photo_id=self.id)\n        \n        photo = data.rsp.photo\n\n        self.__secret = photo.secret\n        self.__server = photo.server\n        self.__isfavorite = photo.isfavorite\n        self.__license = photo.license\n        self.__rotation = photo.rotation\n        \n\n\n        owner = photo.owner\n        self.__owner = User(owner.nsid, username=owner.username,\\\n                          realname=owner.realname,\\\n                          location=owner.location)\n\n        self.__title = photo.title.text\n        self.__description = photo.description.text\n        self.__ispublic = photo.visibility.ispublic\n        self.__isfriend = photo.visibility.isfriend\n        self.__isfamily = photo.visibility.isfamily\n\n        self.__dateposted = photo.dates.posted\n        self.__datetaken = photo.dates.taken\n        self.__takengranularity = photo.dates.takengranularity\n        \n        self.__cancomment = photo.editability.cancomment\n        self.__canaddmeta = photo.editability.canaddmeta\n        self.__comments = photo.comments.text\n\n        try:\n            self.__permcomment = photo.permissions.permcomment\n            self.__permaddmeta = photo.permissions.permaddmeta\n        except AttributeError:\n            self.__permcomment = None\n            self.__permaddmeta = None\n\n        #TODO: Implement Notes?\n        if hasattr(photo.tags, \"tag\"):\n            if isinstance(photo.tags.tag, list):\n                self.__tags = [Tag(tag.id, User(tag.author), tag.raw, tag.text) \\\n                               for tag in photo.tags.tag]\n            else:\n                tag = photo.tags.tag\n                self.__tags = [Tag(tag.id, User(tag.author), tag.raw, tag.text)]", "response": "Loads the properties from Flickr."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the tags for current photo to list tags.", "response": "def setTags(self, tags):\n        \"\"\"Set the tags for current photo to list tags.\n        (flickr.photos.settags)\n        \"\"\"\n        method = 'flickr.photos.setTags'\n        tags = uniq(tags)\n        _dopost(method, auth=True, photo_id=self.id, tags=tags)\n        self._load_properties()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd the list of tags to current tags.", "response": "def addTags(self, tags):\n        \"\"\"Adds the list of tags to current tags. (flickr.photos.addtags)\n        \"\"\"\n        method = 'flickr.photos.addTags'\n        if isinstance(tags, list):\n            tags = uniq(tags)\n\n        _dopost(method, auth=True, photo_id=self.id, tags=tags)\n        #load properties again\n        self._load_properties()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef removeTag(self, tag):\n        method = 'flickr.photos.removeTag'\n        tag_id = ''\n        try:\n            tag_id = tag.id\n        except AttributeError:\n            raise FlickrError, \"Tag object expected\"\n        _dopost(method, auth=True, photo_id=self.id, tag_id=tag_id)\n        self._load_properties()", "response": "Remove a tag from the photo."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the metadata for the current photo.", "response": "def setMeta(self, title=None, description=None):\n        \"\"\"Set metadata for photo. (flickr.photos.setMeta)\"\"\"\n        method = 'flickr.photos.setMeta'\n\n        if title is None:\n            title = self.title\n        if description is None:\n            description = self.description\n            \n        _dopost(method, auth=True, title=title, \\\n               description=description, photo_id=self.id)\n        \n        self.__title = title\n        self.__description = description"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getURL(self, size='Medium', urlType='url'):\n        method = 'flickr.photos.getSizes'\n        data = _doget(method, photo_id=self.id)\n        for psize in data.rsp.sizes.size:\n            if psize.label == size:\n                return getattr(psize, urlType)\n        raise FlickrError, \"No URL found\"", "response": "Retrieves a url for the photo."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getSizes(self):\n        method = 'flickr.photos.getSizes'\n        data = _doget(method, photo_id=self.id)\n        ret = []\n        # The given props are those that we return and the according types, since\n        # return width and height as string would make \"75\">\"100\" be True, which \n        # is just error prone.\n        props = {'url':str,'width':int,'height':int,'label':str,'source':str,'text':str}\n        for psize in data.rsp.sizes.size:\n            d = {}\n            for prop,convert_to_type in props.items():\n                d[prop] = convert_to_type(getattr(psize, prop))\n            ret.append(d)\n        return ret", "response": "Get all the available sizes of the current image and all available\n        data about them."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getLocation(self):\n        method = 'flickr.photos.geo.getLocation'\n        try:\n            data = _doget(method, photo_id=self.id)\n        except FlickrError: # Some other error might have occured too!?\n            return None\n        loc = data.rsp.photo.location\n        return [loc.latitude, loc.longitude]", "response": "Get the latitude + longitutde of the photo."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of Photos.", "response": "def getPhotos(self):\n        \"\"\"Returns list of Photos.\"\"\"\n        method = 'flickr.photosets.getPhotos'\n        data = _doget(method, photoset_id=self.id)\n        photos = data.rsp.photoset.photo\n        p = []\n        for photo in photos:\n            p.append(Photo(photo.id, title=photo.title, secret=photo.secret, \\\n                           server=photo.server))\n        return p"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nedit the photos in this set.", "response": "def editPhotos(self, photos, primary=None):\n        \"\"\"Edit the photos in this set.\n\n        photos - photos for set\n        primary - primary photo (if None will used current)\n        \"\"\"\n        method = 'flickr.photosets.editPhotos'\n\n        if primary is None:\n            primary = self.primary\n            \n        ids = [photo.id for photo in photos]\n        if primary.id not in ids:\n            ids.append(primary.id)\n\n        _dopost(method, auth=True, photoset_id=self.id,\\\n                primary_photo_id=primary.id,\n                photo_ids=ids)\n        self.__count = len(ids)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addPhoto(self, photo):\n        method = 'flickr.photosets.addPhoto'\n\n        _dopost(method, auth=True, photoset_id=self.id, photo_id=photo.id)\n\n        self.__count += 1\n        return True", "response": "Add a photo to this set."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nedit the metadata for the current photo.", "response": "def editMeta(self, title=None, description=None):\n        \"\"\"Set metadata for photo. (flickr.photos.setMeta)\"\"\"\n        method = 'flickr.photosets.editMeta'\n\n        if title is None:\n            title = self.title\n        if description is None:\n            description = self.description\n            \n        _dopost(method, auth=True, title=title, \\\n               description=description, photoset_id=self.id)\n        \n        self.__title = title\n        self.__description = description\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(cls, photo, title, description=''):\n        if not isinstance(photo, Photo):\n            raise TypeError, \"Photo expected\"\n        \n        method = 'flickr.photosets.create'\n        data = _dopost(method, auth=True, title=title,\\\n                       description=description,\\\n                       primary_photo_id=photo.id)\n        \n        set = Photoset(data.rsp.photoset.id, title, Photo(photo.id),\n                       photos=1, description=description)\n        return set", "response": "Create a new photoset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _general_getattr(self, var):\n        if getattr(self, \"_%s__%s\" % (self.__class__.__name__, var)) is None \\\n           and not self.__loaded:\n            self._load_properties()\n        return getattr(self, \"_%s__%s\" % (self.__class__.__name__, var))", "response": "Generic get attribute function."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload User properties from Flickr.", "response": "def _load_properties(self):\n        \"\"\"Load User properties from Flickr.\"\"\"\n        method = 'flickr.people.getInfo'\n        data = _doget(method, user_id=self.__id)\n\n        self.__loaded = True\n        \n        person = data.rsp.person\n\n        self.__isadmin = person.isadmin\n        self.__ispro = person.ispro\n        self.__icon_server = person.iconserver\n        if int(person.iconserver) > 0:\n            self.__icon_url = 'http://photos%s.flickr.com/buddyicons/%s.jpg' \\\n                              % (person.iconserver, self.__id)\n        else:\n            self.__icon_url = 'http://www.flickr.com/images/buddyicon.jpg'\n        \n        self.__username = person.username.text\n        self.__realname = person.realname.text\n        self.__location = person.location.text\n        self.__photos_firstdate = person.photos.firstdate.text\n        self.__photos_firstdatetaken = person.photos.firstdatetaken.text\n        self.__photos_count = person.photos.count.text"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of Photosets.", "response": "def getPhotosets(self):\n        \"\"\"Returns a list of Photosets.\"\"\"\n        method = 'flickr.photosets.getList'\n        data = _doget(method, user_id=self.id)\n        sets = []\n        if isinstance(data.rsp.photosets.photoset, list):\n            for photoset in data.rsp.photosets.photoset:\n                sets.append(Photoset(photoset.id, photoset.title.text,\\\n                                     Photo(photoset.primary),\\\n                                     secret=photoset.secret, \\\n                                     server=photoset.server, \\\n                                     description=photoset.description.text,\n                                     photos=photoset.photos))\n        else:\n            photoset = data.rsp.photosets.photoset\n            sets.append(Photoset(photoset.id, photoset.title.text,\\\n                                     Photo(photoset.primary),\\\n                                     secret=photoset.secret, \\\n                                     server=photoset.server, \\\n                                     description=photoset.description.text,\n                                     photos=photoset.photos))\n        return sets"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_properties(self):\n        method = 'flickr.groups.getInfo'\n        data = _doget(method, group_id=self.id)\n\n        self.__loaded = True\n        \n        group = data.rsp.group\n\n        self.__name = photo.name.text\n        self.__members = photo.members.text\n        self.__online = photo.online.text\n        self.__privacy = photo.privacy.text\n        self.__chatid = photo.chatid.text\n        self.__chatcount = photo.chatcount.text", "response": "Loads the properties from Flickr."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a list of photo objects for this group", "response": "def getPhotos(self, tags='', per_page='', page=''):\n        \"\"\"Get a list of photo objects for this group\"\"\"\n        method = 'flickr.groups.pools.getPhotos'\n        data = _doget(method, group_id=self.id, tags=tags,\\\n                      per_page=per_page, page=page)\n        photos = []\n        for photo in data.rsp.photos.photo:\n            photos.append(_parse_photo(photo))\n        return photos"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a Photo to the group", "response": "def add(self, photo):\n        \"\"\"Adds a Photo to the group\"\"\"\n        method = 'flickr.groups.pools.add'\n        _dopost(method, auth=True, photo_id=photo.id, group_id=self.id)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_all_keys(self, headers=None, **params):\n        key = Key(self.name, self.contained_key)\n        return SimpleResultSet([key])", "response": "This method returns the list of keys that are currently set on this object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_key(self, key_name, headers=None, version_id=None,\n                                            key_type=Key.KEY_REGULAR_FILE):\n        \"\"\"\n        Check to see if a particular key exists within the bucket.\n        Returns: An instance of a Key object or None\n\n        :type key_name: string\n        :param key_name: The name of the key to retrieve\n\n        :type version_id: string\n        :param version_id: Unused in this subclass.\n\n        :type stream_type: integer\n        :param stream_type: Type of the Key - Regular File or input/output Stream\n\n        :rtype: :class:`boto.file.key.Key`\n        :returns: A Key object from this bucket.\n        \"\"\"\n        if key_name == '-':\n            return Key(self.name, '-', key_type=Key.KEY_STREAM_READABLE)\n        else:\n            fp = open(key_name, 'rb')\n            return Key(self.name, key_name, fp)", "response": "Get a Key object from this bucket."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new_key(self, key_name=None, key_type=Key.KEY_REGULAR_FILE):\n        if key_name == '-':\n            return Key(self.name, '-', key_type=Key.KEY_STREAM_WRITABLE)\n        else:\n            dir_name = os.path.dirname(key_name)\n            if dir_name and not os.path.exists(dir_name):\n                os.makedirs(dir_name)\n            fp = open(key_name, 'wb')\n            return Key(self.name, key_name, fp)", "response": "Creates a new key object for the current file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_queue(self, queue_name, visibility_timeout=None, callback=None):\n        params = {'QueueName': queue_name}\n        if visibility_timeout:\n            params['DefaultVisibilityTimeout'] = '%d' % (visibility_timeout,)\n        return self.get_object('CreateQueue', params, botornado.sqs.queue.AsyncQueue, callback=callback)", "response": "Creates a new SQS Queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes an SQS Queue.", "response": "def delete_queue(self, queue, force_deletion=False, callback=None):\n        \"\"\"\n        Delete an SQS Queue.\n\n        :type queue: A Queue object\n        :param queue: The SQS queue to be deleted\n        \n        :type force_deletion: Boolean\n        :param force_deletion: Normally, SQS will not delete a queue that\n                               contains messages.  However, if the\n                               force_deletion argument is True, the\n                               queue will be deleted regardless of whether\n                               there are messages in the queue or not.\n                               USE WITH CAUTION.  This will delete all\n                               messages in the queue as well.\n                               \n        :rtype: bool\n        :return: True if the command succeeded, False otherwise\n        \"\"\"\n        return self.get_status('DeleteQueue', None, queue.id, callback=callback)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget one or all attributes of a SQS queue.", "response": "def get_queue_attributes(self, queue, attribute='All', callback=None):\n        \"\"\"\n        Gets one or all attributes of a Queue\n        \n        :type queue: A Queue object\n        :param queue: The SQS queue to be deleted\n\n        :type attribute: str\n        :type attribute: The specific attribute requested.  If not supplied,\n                         the default is to return all attributes.\n                         Valid attributes are:\n                         \n                         ApproximateNumberOfMessages|\n                         ApproximateNumberOfMessagesNotVisible|\n                         VisibilityTimeout|\n                         CreatedTimestamp|\n                         LastModifiedTimestamp|\n                         Policy\n                         \n        :rtype: :class:`boto.sqs.attributes.Attributes`\n        :return: An Attributes object containing request value(s).\n        \"\"\"\n        params = {'AttributeName' : attribute}\n        return self.get_object('GetQueueAttributes', params,\n                               Attributes, queue.id, callback=callback)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a number of messages from an SQS Queue.", "response": "def receive_message(self, queue, number_messages=1,\n                        visibility_timeout=None, attributes=None, callback=None):\n        \"\"\"\n        Read messages from an SQS Queue.\n\n        :type queue: A Queue object\n        :param queue: The Queue from which messages are read.\n        \n        :type number_messages: int\n        :param number_messages: The maximum number of messages to read\n                                (default=1)\n        \n        :type visibility_timeout: int\n        :param visibility_timeout: The number of seconds the message should\n                                   remain invisible to other queue readers\n                                   (default=None which uses the Queues default)\n\n        :type attributes: str\n        :param attributes: The name of additional attribute to return\n                           with response or All if you want all attributes.\n                           The default is to return no additional attributes.\n                           Valid values:\n                           \n                           All|SenderId|SentTimestamp|\n                           ApproximateReceiveCount|\n                           ApproximateFirstReceiveTimestamp\n        \n        :rtype: list\n        :return: A list of :class:`boto.sqs.message.Message` objects.\n        \"\"\"\n        params = {'MaxNumberOfMessages' : number_messages}\n        if visibility_timeout:\n            params['VisibilityTimeout'] = visibility_timeout\n        if attributes:\n            self.build_list_params(params, attributes, 'AttributeName')\n        return self.get_list('ReceiveMessage', params,\n                             [('Message', queue.message_class)],\n                             queue.id, queue, callback=callback)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef change_message_visibility(self, queue, receipt_handle,\n                                  visibility_timeout, callback=None):\n        \"\"\"\n        Extends the read lock timeout for the specified message from\n        the specified queue to the specified value.\n\n        :type queue: A :class:`boto.sqs.queue.Queue` object\n        :param queue: The Queue from which messages are read.\n        \n        :type receipt_handle: str\n        :param queue: The receipt handle associated with the message whose\n                      visibility timeout will be changed.\n        \n        :type visibility_timeout: int\n        :param visibility_timeout: The new value of the message's visibility\n                                   timeout in seconds.\n        \"\"\"\n        params = {'ReceiptHandle' : receipt_handle,\n                  'VisibilityTimeout' : visibility_timeout}\n        return self.get_status('ChangeMessageVisibility', params, queue.id, callback=callback)", "response": "Change the visibility of the specified message from the specified queue to the specified value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a permission to a queue.", "response": "def add_permission(self, queue, label, aws_account_id, action_name, callback=None):\n        \"\"\"\n        Add a permission to a queue.\n\n        :type queue: :class:`boto.sqs.queue.Queue`\n        :param queue: The queue object\n\n        :type label: str or unicode\n        :param label: A unique identification of the permission you are setting.\n                      Maximum of 80 characters ``[0-9a-zA-Z_-]``\n                      Example, AliceSendMessage\n\n        :type aws_account_id: str or unicode\n        :param principal_id: The AWS account number of the principal who will\n                             be given permission.  The principal must have\n                             an AWS account, but does not need to be signed\n                             up for Amazon SQS. For information\n                             about locating the AWS account identification.\n\n        :type action_name: str or unicode\n        :param action_name: The action.  Valid choices are:\n                            \\*|SendMessage|ReceiveMessage|DeleteMessage|\n                            ChangeMessageVisibility|GetQueueAttributes\n\n        :rtype: bool\n        :return: True if successful, False otherwise.\n\n        \"\"\"\n        params = {'Label': label,\n                  'AWSAccountId' : aws_account_id,\n                  'ActionName' : action_name}\n        return self.get_status('AddPermission', params, queue.id, callback=callback)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef regions():\n    return [RDSRegionInfo(name='us-east-1',\n                          endpoint='rds.us-east-1.amazonaws.com'),\n            RDSRegionInfo(name='eu-west-1',\n                          endpoint='rds.eu-west-1.amazonaws.com'),\n            RDSRegionInfo(name='us-west-1',\n                          endpoint='rds.us-west-1.amazonaws.com'),\n            RDSRegionInfo(name='us-west-2',\n                          endpoint='rds.us-west-2.amazonaws.com'),\n            RDSRegionInfo(name='sa-east-1',\n                          endpoint='rds.sa-east-1.amazonaws.com'),\n            RDSRegionInfo(name='ap-northeast-1',\n                          endpoint='rds.ap-northeast-1.amazonaws.com'),\n            RDSRegionInfo(name='ap-southeast-1',\n                          endpoint='rds.ap-southeast-1.amazonaws.com')\n            ]", "response": "Returns a list of all available regions for the RDS service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving all DB Instances in your account.", "response": "def get_all_dbinstances(self, instance_id=None, max_records=None,\n                            marker=None):\n        \"\"\"\n        Retrieve all the DBInstances in your account.\n\n        :type instance_id: str\n        :param instance_id: DB Instance identifier.  If supplied, only\n                            information this instance will be returned.\n                            Otherwise, info about all DB Instances will\n                            be returned.\n\n        :type max_records: int\n        :param max_records: The maximum number of records to be returned.\n                            If more results are available, a MoreToken will\n                            be returned in the response that can be used to\n                            retrieve additional records.  Default is 100.\n\n        :type marker: str\n        :param marker: The marker provided by a previous request.\n\n        :rtype: list\n        :return: A list of :class:`boto.rds.dbinstance.DBInstance`\n        \"\"\"\n        params = {}\n        if instance_id:\n            params['DBInstanceIdentifier'] = instance_id\n        if max_records:\n            params['MaxRecords'] = max_records\n        if marker:\n            params['Marker'] = marker\n        return self.get_list('DescribeDBInstances', params,\n                             [('DBInstance', DBInstance)])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new DBInstance.", "response": "def create_dbinstance(self, id, allocated_storage, instance_class,\n                          master_username, master_password, port=3306,\n                          engine='MySQL5.1', db_name=None, param_group=None,\n                          security_groups=None, availability_zone=None,\n                          preferred_maintenance_window=None,\n                          backup_retention_period=None,\n                          preferred_backup_window=None,\n                          multi_az=False,\n                          engine_version=None,\n                          auto_minor_version_upgrade=True):\n        \"\"\"\n        Create a new DBInstance.\n\n        :type id: str\n        :param id: Unique identifier for the new instance.\n                   Must contain 1-63 alphanumeric characters.\n                   First character must be a letter.\n                   May not end with a hyphen or contain two consecutive hyphens\n\n        :type allocated_storage: int\n        :param allocated_storage: Initially allocated storage size, in GBs.\n                                  Valid values are [5-1024]\n\n        :type instance_class: str\n        :param instance_class: The compute and memory capacity of\n                               the DBInstance. Valid values are:\n\n                               * db.m1.small\n                               * db.m1.large\n                               * db.m1.xlarge\n                               * db.m2.xlarge\n                               * db.m2.2xlarge\n                               * db.m2.4xlarge\n\n        :type engine: str\n        :param engine: Name of database engine. Must be MySQL5.1 for now.\n\n        :type master_username: str\n        :param master_username: Name of master user for the DBInstance.\n                                Must be 1-15 alphanumeric characters, first\n                                must be a letter.\n\n        :type master_password: str\n        :param master_password: Password of master user for the DBInstance.\n                                Must be 4-16 alphanumeric characters.\n\n        :type port: int\n        :param port: Port number on which database accepts connections.\n                     Valid values [1115-65535].  Defaults to 3306.\n\n        :type db_name: str\n        :param db_name: Name of a database to create when the DBInstance\n                        is created.  Default is to create no databases.\n\n        :type param_group: str\n        :param param_group: Name of DBParameterGroup to associate with\n                            this DBInstance.  If no groups are specified\n                            no parameter groups will be used.\n\n        :type security_groups: list of str or list of DBSecurityGroup objects\n        :param security_groups: List of names of DBSecurityGroup to authorize on\n                                this DBInstance.\n\n        :type availability_zone: str\n        :param availability_zone: Name of the availability zone to place\n                                  DBInstance into.\n\n        :type preferred_maintenance_window: str\n        :param preferred_maintenance_window: The weekly time range (in UTC)\n                                             during which maintenance can occur.\n                                             Default is Sun:05:00-Sun:09:00\n\n        :type backup_retention_period: int\n        :param backup_retention_period: The number of days for which automated\n                                        backups are retained.  Setting this to\n                                        zero disables automated backups.\n\n        :type preferred_backup_window: str\n        :param preferred_backup_window: The daily time range during which\n                                        automated backups are created (if\n                                        enabled).  Must be in h24:mi-hh24:mi\n                                        format (UTC).\n\n        :type multi_az: bool\n        :param multi_az: If True, specifies the DB Instance will be\n                         deployed in multiple availability zones.\n\n        :type engine_version: str\n        :param engine_version: Version number of the database engine to use.\n\n        :type auto_minor_version_upgrade: bool\n        :param auto_minor_version_upgrade: Indicates that minor engine\n                                           upgrades will be applied\n                                           automatically to the Read Replica\n                                           during the maintenance window.\n                                           Default is True.\n\n        :rtype: :class:`boto.rds.dbinstance.DBInstance`\n        :return: The new db instance.\n        \"\"\"\n        params = {'DBInstanceIdentifier': id,\n                  'AllocatedStorage': allocated_storage,\n                  'DBInstanceClass': instance_class,\n                  'Engine': engine,\n                  'MasterUsername': master_username,\n                  'MasterUserPassword': master_password,\n                  'Port': port,\n                  'MultiAZ': str(multi_az).lower(),\n                  'AutoMinorVersionUpgrade':\n                      str(auto_minor_version_upgrade).lower()}\n        if db_name:\n            params['DBName'] = db_name\n        if param_group:\n            params['DBParameterGroupName'] = param_group\n        if security_groups:\n            l = []\n            for group in security_groups:\n                if isinstance(group, DBSecurityGroup):\n                    l.append(group.name)\n                else:\n                    l.append(group)\n            self.build_list_params(params, l, 'DBSecurityGroups.member')\n        if availability_zone:\n            params['AvailabilityZone'] = availability_zone\n        if preferred_maintenance_window:\n            params['PreferredMaintenanceWindow'] = preferred_maintenance_window\n        if backup_retention_period is not None:\n            params['BackupRetentionPeriod'] = backup_retention_period\n        if preferred_backup_window:\n            params['PreferredBackupWindow'] = preferred_backup_window\n        if engine_version:\n            params['EngineVersion'] = engine_version\n\n        return self.get_object('CreateDBInstance', params, DBInstance)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new DBInstance Read Replica.", "response": "def create_dbinstance_read_replica(self, id, source_id,\n                                       instance_class=None,\n                                       port=3306,\n                                       availability_zone=None,\n                                       auto_minor_version_upgrade=None):\n        \"\"\"\n        Create a new DBInstance Read Replica.\n\n        :type id: str\n        :param id: Unique identifier for the new instance.\n                   Must contain 1-63 alphanumeric characters.\n                   First character must be a letter.\n                   May not end with a hyphen or contain two consecutive hyphens\n\n        :type source_id: str\n        :param source_id: Unique identifier for the DB Instance for which this\n                          DB Instance will act as a Read Replica.\n\n        :type instance_class: str\n        :param instance_class: The compute and memory capacity of the\n                               DBInstance.  Default is to inherit from\n                               the source DB Instance.\n\n                               Valid values are:\n\n                               * db.m1.small\n                               * db.m1.large\n                               * db.m1.xlarge\n                               * db.m2.xlarge\n                               * db.m2.2xlarge\n                               * db.m2.4xlarge\n\n        :type port: int\n        :param port: Port number on which database accepts connections.\n                     Default is to inherit from source DB Instance.\n                     Valid values [1115-65535].  Defaults to 3306.\n\n        :type availability_zone: str\n        :param availability_zone: Name of the availability zone to place\n                                  DBInstance into.\n\n        :type auto_minor_version_upgrade: bool\n        :param auto_minor_version_upgrade: Indicates that minor engine\n                                           upgrades will be applied\n                                           automatically to the Read Replica\n                                           during the maintenance window.\n                                           Default is to inherit this value\n                                           from the source DB Instance.\n\n        :rtype: :class:`boto.rds.dbinstance.DBInstance`\n        :return: The new db instance.\n        \"\"\"\n        params = {'DBInstanceIdentifier' : id,\n                  'SourceDBInstanceIdentifier' : source_id}\n        if instance_class:\n            params['DBInstanceClass'] = instance_class\n        if port:\n            params['Port'] = port\n        if availability_zone:\n            params['AvailabilityZone'] = availability_zone\n        if auto_minor_version_upgrade is not None:\n            if auto_minor_version_upgrade is True:\n                params['AutoMinorVersionUpgrade'] = 'true'\n            else:\n                params['AutoMinorVersionUpgrade'] = 'false'\n\n        return self.get_object('CreateDBInstanceReadReplica',\n                               params, DBInstance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmodifies an existing DBInstance.", "response": "def modify_dbinstance(self, id, param_group=None, security_groups=None,\n                          preferred_maintenance_window=None,\n                          master_password=None, allocated_storage=None,\n                          instance_class=None,\n                          backup_retention_period=None,\n                          preferred_backup_window=None,\n                          multi_az=False,\n                          apply_immediately=False):\n        \"\"\"\n        Modify an existing DBInstance.\n\n        :type id: str\n        :param id: Unique identifier for the new instance.\n\n        :type security_groups: list of str or list of DBSecurityGroup objects\n        :param security_groups: List of names of DBSecurityGroup to authorize on\n                                this DBInstance.\n\n        :type preferred_maintenance_window: str\n        :param preferred_maintenance_window: The weekly time range (in UTC)\n                                             during which maintenance can\n                                             occur.\n                                             Default is Sun:05:00-Sun:09:00\n\n        :type master_password: str\n        :param master_password: Password of master user for the DBInstance.\n                                Must be 4-15 alphanumeric characters.\n\n        :type allocated_storage: int\n        :param allocated_storage: The new allocated storage size, in GBs.\n                                  Valid values are [5-1024]\n\n        :type instance_class: str\n        :param instance_class: The compute and memory capacity of the\n                               DBInstance.  Changes will be applied at\n                               next maintenance window unless\n                               apply_immediately is True.\n\n                               Valid values are:\n\n                               * db.m1.small\n                               * db.m1.large\n                               * db.m1.xlarge\n                               * db.m2.xlarge\n                               * db.m2.2xlarge\n                               * db.m2.4xlarge\n\n        :type apply_immediately: bool\n        :param apply_immediately: If true, the modifications will be applied\n                                  as soon as possible rather than waiting for\n                                  the next preferred maintenance window.\n\n        :type backup_retention_period: int\n        :param backup_retention_period: The number of days for which automated\n                                        backups are retained.  Setting this to\n                                        zero disables automated backups.\n\n        :type preferred_backup_window: str\n        :param preferred_backup_window: The daily time range during which\n                                        automated backups are created (if\n                                        enabled).  Must be in h24:mi-hh24:mi\n                                        format (UTC).\n\n        :type multi_az: bool\n        :param multi_az: If True, specifies the DB Instance will be\n                         deployed in multiple availability zones.\n\n        :rtype: :class:`boto.rds.dbinstance.DBInstance`\n        :return: The modified db instance.\n        \"\"\"\n        params = {'DBInstanceIdentifier' : id}\n        if param_group:\n            params['DBParameterGroupName'] = param_group\n        if security_groups:\n            l = []\n            for group in security_groups:\n                if isinstance(group, DBSecurityGroup):\n                    l.append(group.name)\n                else:\n                    l.append(group)\n            self.build_list_params(params, l, 'DBSecurityGroups.member')\n        if preferred_maintenance_window:\n            params['PreferredMaintenanceWindow'] = preferred_maintenance_window\n        if master_password:\n            params['MasterUserPassword'] = master_password\n        if allocated_storage:\n            params['AllocatedStorage'] = allocated_storage\n        if instance_class:\n            params['DBInstanceClass'] = instance_class\n        if backup_retention_period is not None:\n            params['BackupRetentionPeriod'] = backup_retention_period\n        if preferred_backup_window:\n            params['PreferredBackupWindow'] = preferred_backup_window\n        if multi_az:\n            params['MultiAZ'] = 'true'\n        if apply_immediately:\n            params['ApplyImmediately'] = 'true'\n\n        return self.get_object('ModifyDBInstance', params, DBInstance)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete an existing DBInstance.", "response": "def delete_dbinstance(self, id, skip_final_snapshot=False,\n                          final_snapshot_id=''):\n        \"\"\"\n        Delete an existing DBInstance.\n\n        :type id: str\n        :param id: Unique identifier for the new instance.\n\n        :type skip_final_snapshot: bool\n        :param skip_final_snapshot: This parameter determines whether a final\n                                    db snapshot is created before the instance\n                                    is deleted.  If True, no snapshot\n                                    is created.  If False, a snapshot\n                                    is created before deleting the instance.\n\n        :type final_snapshot_id: str\n        :param final_snapshot_id: If a final snapshot is requested, this\n                                  is the identifier used for that snapshot.\n\n        :rtype: :class:`boto.rds.dbinstance.DBInstance`\n        :return: The deleted db instance.\n        \"\"\"\n        params = {'DBInstanceIdentifier' : id}\n        if skip_final_snapshot:\n            params['SkipFinalSnapshot'] = 'true'\n        else:\n            params['SkipFinalSnapshot'] = 'false'\n            params['FinalDBSnapshotIdentifier'] = final_snapshot_id\n        return self.get_object('DeleteDBInstance', params, DBInstance)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_dbparameter_groups(self, groupname=None, max_records=None,\n                                  marker=None):\n        \"\"\"\n        Get all parameter groups associated with your account in a region.\n\n        :type groupname: str\n        :param groupname: The name of the DBParameter group to retrieve.\n                          If not provided, all DBParameter groups will be returned.\n\n        :type max_records: int\n        :param max_records: The maximum number of records to be returned.\n                            If more results are available, a MoreToken will\n                            be returned in the response that can be used to\n                            retrieve additional records.  Default is 100.\n\n        :type marker: str\n        :param marker: The marker provided by a previous request.\n\n        :rtype: list\n        :return: A list of :class:`boto.ec2.parametergroup.ParameterGroup`\n        \"\"\"\n        params = {}\n        if groupname:\n            params['DBParameterGroupName'] = groupname\n        if max_records:\n            params['MaxRecords'] = max_records\n        if marker:\n            params['Marker'] = marker\n        return self.get_list('DescribeDBParameterGroups', params,\n                             [('DBParameterGroup', ParameterGroup)])", "response": "Get all DBParameterGroups associated with your account in a region."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all parameters associated with a ParameterGroup.", "response": "def get_all_dbparameters(self, groupname, source=None,\n                             max_records=None, marker=None):\n        \"\"\"\n        Get all parameters associated with a ParameterGroup\n\n        :type groupname: str\n        :param groupname: The name of the DBParameter group to retrieve.\n\n        :type source: str\n        :param source: Specifies which parameters to return.\n                       If not specified, all parameters will be returned.\n                       Valid values are: user|system|engine-default\n\n        :type max_records: int\n        :param max_records: The maximum number of records to be returned.\n                            If more results are available, a MoreToken will\n                            be returned in the response that can be used to\n                            retrieve additional records.  Default is 100.\n\n        :type marker: str\n        :param marker: The marker provided by a previous request.\n\n        :rtype: :class:`boto.ec2.parametergroup.ParameterGroup`\n        :return: The ParameterGroup\n        \"\"\"\n        params = {'DBParameterGroupName' : groupname}\n        if source:\n            params['Source'] = source\n        if max_records:\n            params['MaxRecords'] = max_records\n        if marker:\n            params['Marker'] = marker\n        pg = self.get_object('DescribeDBParameters', params, ParameterGroup)\n        pg.name = groupname\n        return pg"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new DBParameterGroup for your account.", "response": "def create_parameter_group(self, name, engine='MySQL5.1', description=''):\n        \"\"\"\n        Create a new dbparameter group for your account.\n\n        :type name: string\n        :param name: The name of the new dbparameter group\n\n        :type engine: str\n        :param engine: Name of database engine.\n\n        :type description: string\n        :param description: The description of the new security group\n\n        :rtype: :class:`boto.rds.dbsecuritygroup.DBSecurityGroup`\n        :return: The newly created DBSecurityGroup\n        \"\"\"\n        params = {'DBParameterGroupName': name,\n                  'DBParameterGroupFamily': engine,\n                  'Description' : description}\n        return self.get_object('CreateDBParameterGroup', params, ParameterGroup)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmodifying a parameter group for your account.", "response": "def modify_parameter_group(self, name, parameters=None):\n        \"\"\"\n        Modify a parameter group for your account.\n\n        :type name: string\n        :param name: The name of the new parameter group\n\n        :type parameters: list of :class:`boto.rds.parametergroup.Parameter`\n        :param parameters: The new parameters\n\n        :rtype: :class:`boto.rds.parametergroup.ParameterGroup`\n        :return: The newly created ParameterGroup\n        \"\"\"\n        params = {'DBParameterGroupName': name}\n        for i in range(0, len(parameters)):\n            parameter = parameters[i]\n            parameter.merge(params, i+1)\n        return self.get_list('ModifyDBParameterGroup', params,\n                             ParameterGroup, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresetting all of the parameters of a ParameterGroup to the default value.", "response": "def reset_parameter_group(self, name, reset_all_params=False,\n                              parameters=None):\n        \"\"\"\n        Resets some or all of the parameters of a ParameterGroup to the\n        default value\n\n        :type key_name: string\n        :param key_name: The name of the ParameterGroup to reset\n\n        :type parameters: list of :class:`boto.rds.parametergroup.Parameter`\n        :param parameters: The parameters to reset.  If not supplied,\n                           all parameters will be reset.\n        \"\"\"\n        params = {'DBParameterGroupName':name}\n        if reset_all_params:\n            params['ResetAllParameters'] = 'true'\n        else:\n            params['ResetAllParameters'] = 'false'\n            for i in range(0, len(parameters)):\n                parameter = parameters[i]\n                parameter.merge(params, i+1)\n        return self.get_status('ResetDBParameterGroup', params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_dbsecurity_groups(self, groupname=None, max_records=None,\n                                  marker=None):\n        \"\"\"\n        Get all security groups associated with your account in a region.\n\n        :type groupnames: list\n        :param groupnames: A list of the names of security groups to retrieve.\n                           If not provided, all security groups will\n                           be returned.\n\n        :type max_records: int\n        :param max_records: The maximum number of records to be returned.\n                            If more results are available, a MoreToken will\n                            be returned in the response that can be used to\n                            retrieve additional records.  Default is 100.\n\n        :type marker: str\n        :param marker: The marker provided by a previous request.\n\n        :rtype: list\n        :return: A list of :class:`boto.rds.dbsecuritygroup.DBSecurityGroup`\n        \"\"\"\n        params = {}\n        if groupname:\n            params['DBSecurityGroupName'] = groupname\n        if max_records:\n            params['MaxRecords'] = max_records\n        if marker:\n            params['Marker'] = marker\n        return self.get_list('DescribeDBSecurityGroups', params,\n                             [('DBSecurityGroup', DBSecurityGroup)])", "response": "Get all DB Security Groups associated with your account in a region."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new DBSecurityGroup with the specified name and optional description.", "response": "def create_dbsecurity_group(self, name, description=None):\n        \"\"\"\n        Create a new security group for your account.\n        This will create the security group within the region you\n        are currently connected to.\n\n        :type name: string\n        :param name: The name of the new security group\n\n        :type description: string\n        :param description: The description of the new security group\n\n        :rtype: :class:`boto.rds.dbsecuritygroup.DBSecurityGroup`\n        :return: The newly created DBSecurityGroup\n        \"\"\"\n        params = {'DBSecurityGroupName':name}\n        if description:\n            params['DBSecurityGroupDescription'] = description\n        group = self.get_object('CreateDBSecurityGroup', params,\n                                DBSecurityGroup)\n        group.name = name\n        group.description = description\n        return group"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authorize_dbsecurity_group(self, group_name, cidr_ip=None,\n                                   ec2_security_group_name=None,\n                                   ec2_security_group_owner_id=None):\n        \"\"\"\n        Add a new rule to an existing security group.\n        You need to pass in either src_security_group_name and\n        src_security_group_owner_id OR a CIDR block but not both.\n\n        :type group_name: string\n        :param group_name: The name of the security group you are adding\n                           the rule to.\n\n        :type ec2_security_group_name: string\n        :param ec2_security_group_name: The name of the EC2 security group\n                                        you are granting access to.\n\n        :type ec2_security_group_owner_id: string\n        :param ec2_security_group_owner_id: The ID of the owner of the EC2\n                                            security group you are granting\n                                            access to.\n\n        :type cidr_ip: string\n        :param cidr_ip: The CIDR block you are providing access to.\n                        See http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n\n        :rtype: bool\n        :return: True if successful.\n        \"\"\"\n        params = {'DBSecurityGroupName':group_name}\n        if ec2_security_group_name:\n            params['EC2SecurityGroupName'] = ec2_security_group_name\n        if ec2_security_group_owner_id:\n            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id\n        if cidr_ip:\n            params['CIDRIP'] = urllib.quote(cidr_ip)\n        return self.get_object('AuthorizeDBSecurityGroupIngress', params,\n                               DBSecurityGroup)", "response": "This method is used to add a new rule to an existing security group. It is intended to add a new rule to an existing security group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef revoke_dbsecurity_group(self, group_name, ec2_security_group_name=None,\n                                ec2_security_group_owner_id=None, cidr_ip=None):\n        \"\"\"\n        Remove an existing rule from an existing security group.\n        You need to pass in either ec2_security_group_name and\n        ec2_security_group_owner_id OR a CIDR block.\n\n        :type group_name: string\n        :param group_name: The name of the security group you are removing\n                           the rule from.\n\n        :type ec2_security_group_name: string\n        :param ec2_security_group_name: The name of the EC2 security group\n                                        from which you are removing access.\n\n        :type ec2_security_group_owner_id: string\n        :param ec2_security_group_owner_id: The ID of the owner of the EC2\n                                            security from which you are\n                                            removing access.\n\n        :type cidr_ip: string\n        :param cidr_ip: The CIDR block from which you are removing access.\n                        See http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing\n\n        :rtype: bool\n        :return: True if successful.\n        \"\"\"\n        params = {'DBSecurityGroupName':group_name}\n        if ec2_security_group_name:\n            params['EC2SecurityGroupName'] = ec2_security_group_name\n        if ec2_security_group_owner_id:\n            params['EC2SecurityGroupOwnerId'] = ec2_security_group_owner_id\n        if cidr_ip:\n            params['CIDRIP'] = cidr_ip\n        return self.get_object('RevokeDBSecurityGroupIngress', params,\n                               DBSecurityGroup)", "response": "Removes an existing rule from an existing security group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_dbsnapshots(self, snapshot_id=None, instance_id=None,\n                            max_records=None, marker=None):\n        \"\"\"\n        Get information about DB Snapshots.\n\n        :type snapshot_id: str\n        :param snapshot_id: The unique identifier of an RDS snapshot.\n                            If not provided, all RDS snapshots will be returned.\n\n        :type instance_id: str\n        :param instance_id: The identifier of a DBInstance.  If provided,\n                            only the DBSnapshots related to that instance will\n                            be returned.\n                            If not provided, all RDS snapshots will be returned.\n\n        :type max_records: int\n        :param max_records: The maximum number of records to be returned.\n                            If more results are available, a MoreToken will\n                            be returned in the response that can be used to\n                            retrieve additional records.  Default is 100.\n\n        :type marker: str\n        :param marker: The marker provided by a previous request.\n\n        :rtype: list\n        :return: A list of :class:`boto.rds.dbsnapshot.DBSnapshot`\n        \"\"\"\n        params = {}\n        if snapshot_id:\n            params['DBSnapshotIdentifier'] = snapshot_id\n        if instance_id:\n            params['DBInstanceIdentifier'] = instance_id\n        if max_records:\n            params['MaxRecords'] = max_records\n        if marker:\n            params['Marker'] = marker\n        return self.get_list('DescribeDBSnapshots', params,\n                             [('DBSnapshot', DBSnapshot)])", "response": "Get information about DB Snapshots."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_dbsnapshot(self, snapshot_id, dbinstance_id):\n        params = {'DBSnapshotIdentifier' : snapshot_id,\n                  'DBInstanceIdentifier' : dbinstance_id}\n        return self.get_object('CreateDBSnapshot', params, DBSnapshot)", "response": "Creates a new DB snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrestores an existing RDS instance from a DB snapshot.", "response": "def restore_dbinstance_from_dbsnapshot(self, identifier, instance_id,\n                                           instance_class, port=None,\n                                           availability_zone=None):\n\n        \"\"\"\n        Create a new DBInstance from a DB snapshot.\n\n        :type identifier: string\n        :param identifier: The identifier for the DBSnapshot\n\n        :type instance_id: string\n        :param instance_id: The source identifier for the RDS instance from\n                              which the snapshot is created.\n\n        :type instance_class: str\n        :param instance_class: The compute and memory capacity of the\n                               DBInstance.  Valid values are:\n                               db.m1.small | db.m1.large | db.m1.xlarge |\n                               db.m2.2xlarge | db.m2.4xlarge\n\n        :type port: int\n        :param port: Port number on which database accepts connections.\n                     Valid values [1115-65535].  Defaults to 3306.\n\n        :type availability_zone: str\n        :param availability_zone: Name of the availability zone to place\n                                  DBInstance into.\n\n        :rtype: :class:`boto.rds.dbinstance.DBInstance`\n        :return: The newly created DBInstance\n        \"\"\"\n        params = {'DBSnapshotIdentifier' : identifier,\n                  'DBInstanceIdentifier' : instance_id,\n                  'DBInstanceClass' : instance_class}\n        if port:\n            params['Port'] = port\n        if availability_zone:\n            params['AvailabilityZone'] = availability_zone\n        return self.get_object('RestoreDBInstanceFromDBSnapshot',\n                               params, DBInstance)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new DBInstance from a point in time. :type source_instance_id: string :param source_instance_id: The identifier for the source DBInstance. :type target_instance_id: string :param target_instance_id: The identifier of the new DBInstance. :type use_latest: bool :param use_latest: If True, the latest snapshot availabile will be used. :type restore_time: datetime :param restore_time: The date and time to restore from. Only used if use_latest is False. :type instance_class: str :param instance_class: The compute and memory capacity of the DBInstance. Valid values are: db.m1.small | db.m1.large | db.m1.xlarge | db.m2.2xlarge | db.m2.4xlarge :type port: int :param port: Port number on which database accepts connections. Valid values [1115-65535]. Defaults to 3306. :type availability_zone: str :param availability_zone: Name of the availability zone to place DBInstance into. :rtype: :class:`boto.rds.dbinstance.DBInstance` :return: The newly created DBInstance", "response": "def restore_dbinstance_from_point_in_time(self, source_instance_id,\n                                              target_instance_id,\n                                              use_latest=False,\n                                              restore_time=None,\n                                              dbinstance_class=None,\n                                              port=None,\n                                              availability_zone=None):\n\n        \"\"\"\n        Create a new DBInstance from a point in time.\n\n        :type source_instance_id: string\n        :param source_instance_id: The identifier for the source DBInstance.\n\n        :type target_instance_id: string\n        :param target_instance_id: The identifier of the new DBInstance.\n\n        :type use_latest: bool\n        :param use_latest: If True, the latest snapshot availabile will\n                           be used.\n\n        :type restore_time: datetime\n        :param restore_time: The date and time to restore from.  Only\n                             used if use_latest is False.\n\n        :type instance_class: str\n        :param instance_class: The compute and memory capacity of the\n                               DBInstance.  Valid values are:\n                               db.m1.small | db.m1.large | db.m1.xlarge |\n                               db.m2.2xlarge | db.m2.4xlarge\n\n        :type port: int\n        :param port: Port number on which database accepts connections.\n                     Valid values [1115-65535].  Defaults to 3306.\n\n        :type availability_zone: str\n        :param availability_zone: Name of the availability zone to place\n                                  DBInstance into.\n\n        :rtype: :class:`boto.rds.dbinstance.DBInstance`\n        :return: The newly created DBInstance\n        \"\"\"\n        params = {'SourceDBInstanceIdentifier' : source_instance_id,\n                  'TargetDBInstanceIdentifier' : target_instance_id}\n        if use_latest:\n            params['UseLatestRestorableTime'] = 'true'\n        elif restore_time:\n            params['RestoreTime'] = restore_time.isoformat()\n        if dbinstance_class:\n            params['DBInstanceClass'] = dbinstance_class\n        if port:\n            params['Port'] = port\n        if availability_zone:\n            params['AvailabilityZone'] = availability_zone\n        return self.get_object('RestoreDBInstanceToPointInTime',\n                               params, DBInstance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets information about events related to your DBInstances, DBSecurityGroups and DBParameterGroups. :type source_identifier: str :param source_identifier: If supplied, the events returned will be limited to those that apply to the identified source. The value of this parameter depends on the value of source_type. If neither parameter is specified, all events in the time span will be returned. :type source_type: str :param source_type: Specifies how the source_identifier should be interpreted. Valid values are: b-instance | db-security-group | db-parameter-group | db-snapshot :type start_time: datetime :param start_time: The beginning of the time interval for events. If not supplied, all available events will be returned. :type end_time: datetime :param end_time: The ending of the time interval for events. If not supplied, all available events will be returned. :type max_records: int :param max_records: The maximum number of records to be returned. If more results are available, a MoreToken will be returned in the response that can be used to retrieve additional records. Default is 100. :type marker: str :param marker: The marker provided by a previous request. :rtype: list :return: A list of class:`boto.rds.event.Event`", "response": "def get_all_events(self, source_identifier=None, source_type=None,\n                       start_time=None, end_time=None,\n                       max_records=None, marker=None):\n        \"\"\"\n        Get information about events related to your DBInstances,\n        DBSecurityGroups and DBParameterGroups.\n\n        :type source_identifier: str\n        :param source_identifier: If supplied, the events returned will be\n                                  limited to those that apply to the identified\n                                  source.  The value of this parameter depends\n                                  on the value of source_type.  If neither\n                                  parameter is specified, all events in the time\n                                  span will be returned.\n\n        :type source_type: str\n        :param source_type: Specifies how the source_identifier should\n                            be interpreted.  Valid values are:\n                            b-instance | db-security-group |\n                            db-parameter-group | db-snapshot\n\n        :type start_time: datetime\n        :param start_time: The beginning of the time interval for events.\n                           If not supplied, all available events will\n                           be returned.\n\n        :type end_time: datetime\n        :param end_time: The ending of the time interval for events.\n                         If not supplied, all available events will\n                         be returned.\n\n        :type max_records: int\n        :param max_records: The maximum number of records to be returned.\n                            If more results are available, a MoreToken will\n                            be returned in the response that can be used to\n                            retrieve additional records.  Default is 100.\n\n        :type marker: str\n        :param marker: The marker provided by a previous request.\n\n        :rtype: list\n        :return: A list of class:`boto.rds.event.Event`\n        \"\"\"\n        params = {}\n        if source_identifier and source_type:\n            params['SourceIdentifier'] = source_identifier\n            params['SourceType'] = source_type\n        if start_time:\n            params['StartTime'] = start_time.isoformat()\n        if end_time:\n            params['EndTime'] = end_time.isoformat()\n        if max_records:\n            params['MaxRecords'] = max_records\n        if marker:\n            params['Marker'] = marker\n        return self.get_list('DescribeEvents', params, [('Event', Event)])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading an ID3v1 tag from a file.", "response": "def read(cls, filename, offset=None, encoding=\"iso-8859-1\"):\n        \"\"\"Read an ID3v1 tag from a file.\"\"\"\n        with fileutil.opened(filename, \"rb\") as file:\n            if offset is None:\n                file.seek(-128, 2)\n            else:\n                file.seek(offset)\n            data = file.read(128)\n            return cls.decode(data, encoding=encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(cls, filename, offset=None):\n        with fileutil.opened(filename, \"rb+\") as file:\n            if offset is None:\n                file.seek(-128, 2)\n            else:\n                file.seek(offset)\n            offset = file.tell()\n            data = file.read(128)\n            if data[:3] == b\"TAG\":\n                fileutil.replace_chunk(file, offset, 128, b\"\", in_place=True)", "response": "Delete ID3v1 tag from a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_acl(self, acl_or_str, key_name='', headers=None, version_id=None):\n        if isinstance(acl_or_str, Policy):\n            raise InvalidAclError('Attempt to set S3 Policy on GS ACL')\n        elif isinstance(acl_or_str, ACL):\n            self.set_xml_acl(acl_or_str.to_xml(), key_name, headers=headers)\n        else:\n            self.set_canned_acl(acl_or_str, key_name, headers=headers)", "response": "sets or changes a bucket s acl."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset or changes a bucket s default object acl", "response": "def set_def_acl(self, acl_or_str, key_name='', headers=None):\n        \"\"\"sets or changes a bucket's default object acl\"\"\"\n        if isinstance(acl_or_str, Policy):\n            raise InvalidAclError('Attempt to set S3 Policy on GS ACL')\n        elif isinstance(acl_or_str, ACL):\n            self.set_def_xml_acl(acl_or_str.to_xml(), key_name, headers=headers)\n        else:\n            self.set_def_canned_acl(acl_or_str, key_name, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_acl_helper(self, key_name, headers, query_args):\n        response = self.connection.make_request('GET', self.name, key_name,\n                                                query_args=query_args, \n                                                headers=headers)\n        body = response.read()\n        if response.status == 200:\n            acl = ACL(self)\n            h = handler.XmlHandler(acl, self)\n            xml.sax.parseString(body, h)\n            return acl\n        else:\n            raise self.connection.provider.storage_response_error(\n                response.status, response.reason, body)", "response": "provides common functionality for get_acl and get_def_acl"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a bucket s acl", "response": "def get_acl(self, key_name='', headers=None, version_id=None):\n        \"\"\"returns a bucket's acl. We include a version_id argument\n           to support a polymorphic interface for callers, however, \n           version_id is not relevant for Google Cloud Storage buckets \n           and is therefore ignored here.\"\"\" \n        return self.get_acl_helper(key_name, headers, STANDARD_ACL)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_canned_acl(self, acl_str, key_name='', headers=None, \n                       version_id=None):\n        \"\"\"sets or changes a bucket's acl to a predefined (canned) value. \n           We include a version_id argument to support a polymorphic \n           interface for callers, however, version_id is not relevant for \n           Google Cloud Storage buckets and is therefore ignored here.\"\"\" \n        return self.set_canned_acl_helper(acl_str, key_name, headers, \n                                          STANDARD_ACL)", "response": "sets or changes a bucket s acl to a predefined ( canned ) value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting or changes a bucket s default object acl to a predefined ( canned ) value", "response": "def set_def_canned_acl(self, acl_str, key_name='', headers=None):\n        \"\"\"sets or changes a bucket's default object acl to a predefined \n           (canned) value\"\"\"\n        return self.set_canned_acl_helper(acl_str, key_name, headers, \n                                          query_args=DEF_OBJ_ACL)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_def_xml_acl(self, acl_str, key_name='', headers=None):\n        return self.set_xml_acl(acl_str, key_name, headers, \n                                query_args=DEF_OBJ_ACL)", "response": "sets or changes a bucket s default object acl"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of all completed snapshots for this volume ID.", "response": "def get_snapshots(self):\n        \"\"\"\n        Returns a list of all completed snapshots for this volume ID.\n        \"\"\"\n        ec2 = self.get_ec2_connection()\n        rs = ec2.get_all_snapshots()\n        all_vols = [self.volume_id] + self.past_volume_ids\n        snaps = []\n        for snapshot in rs:\n            if snapshot.volume_id in all_vols:\n                if snapshot.progress == '100%':\n                    snapshot.date = boto.utils.parse_ts(snapshot.start_time)\n                    snapshot.keep = True\n                    snaps.append(snapshot)\n        snaps.sort(cmp=lambda x,y: cmp(x.date, y.date))\n        return snaps"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef trim_snapshots(self, delete=False):\n        snaps = self.get_snapshots()\n        # Always keep the oldest and the newest\n        if len(snaps) <= 2:\n            return snaps\n        snaps = snaps[1:-1]\n        now = datetime.datetime.now(snaps[0].date.tzinfo)\n        midnight = datetime.datetime(year=now.year, month=now.month,\n                                     day=now.day, tzinfo=now.tzinfo)\n        # Keep the first snapshot from each day of the previous week\n        one_week = datetime.timedelta(days=7, seconds=60*60)\n        print midnight-one_week, midnight\n        previous_week = self.get_snapshot_range(snaps, midnight-one_week, midnight)\n        print previous_week\n        if not previous_week:\n            return snaps\n        current_day = None\n        for snap in previous_week:\n            if current_day and current_day == snap.date.day:\n                snap.keep = False\n            else:\n                current_day = snap.date.day\n        # Get ourselves onto the next full week boundary\n        if previous_week:\n            week_boundary = previous_week[0].date\n            if week_boundary.weekday() != 0:\n                delta = datetime.timedelta(days=week_boundary.weekday())\n                week_boundary = week_boundary - delta\n        # Keep one within this partial week\n        partial_week = self.get_snapshot_range(snaps, week_boundary, previous_week[0].date)\n        if len(partial_week) > 1:\n            for snap in partial_week[1:]:\n                snap.keep = False\n        # Keep the first snapshot of each week for the previous 4 weeks\n        for i in range(0,4):\n            weeks_worth = self.get_snapshot_range(snaps, week_boundary-one_week, week_boundary)\n            if len(weeks_worth) > 1:\n                for snap in weeks_worth[1:]:\n                    snap.keep = False\n            week_boundary = week_boundary - one_week\n        # Now look through all remaining snaps and keep one per month\n        remainder = self.get_snapshot_range(snaps, end_date=week_boundary)\n        current_month = None\n        for snap in remainder:\n            if current_month and current_month == snap.date.month:\n                snap.keep = False\n            else:\n                current_month = snap.date.month\n        if delete:\n            for snap in snaps:\n                if not snap.keep:\n                    boto.log.info('Deleting %s(%s) for %s' % (snap, snap.date, self.name))\n                    snap.delete()\n        return snaps", "response": "This method trims the number of snapshots for this volume."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate token expiration returns expiration if the token need to set expiration or refresh otherwise return None.", "response": "def calculate_expiration(self, token):\n        \"\"\"\n        Calculate token expiration\n\n        return expiration if the token need to set expiration or refresh,\n        otherwise return None.\n\n        Args:\n            token (dict): a decoded token\n        \"\"\"\n        if not token:\n            return None\n        now = datetime.utcnow()\n        time_to_live = self.config[\"expiration\"]\n        if \"exp\" not in token:\n            return now + timedelta(seconds=time_to_live)\n        elif self.config[\"refresh\"]:\n            exp = datetime.utcfromtimestamp(token[\"exp\"])\n            # 0.5: reduce refresh frequent\n            if exp - now < timedelta(seconds=0.5 * time_to_live):\n                return now + timedelta(seconds=time_to_live)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decode_token(self, token):\n        key = current_app.secret_key\n        if key is None:\n            if current_app.debug:\n                current_app.logger.debug(\"app.secret_key not set\")\n            return None\n        try:\n            return jwt.decode(\n                token, key,\n                algorithms=[self.config[\"algorithm\"]],\n                options={'require_exp': True}\n            )\n        except jwt.InvalidTokenError:\n            return None", "response": "Decode Authorization token return None if token invalid"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encode_token(self, token):\n        key = current_app.secret_key\n        if key is None:\n            raise RuntimeError(\n                \"please set app.secret_key before generate token\")\n        return jwt.encode(token, key, algorithm=self.config[\"algorithm\"])", "response": "Encode Authorization token return bytes token"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck for the existence of an AWS credential file and sets the appropriate attributes.", "response": "def check_for_credential_file(self):\n        \"\"\"\n        Checks for the existance of an AWS credential file.\n        If the environment variable AWS_CREDENTIAL_FILE is\n        set and points to a file, that file will be read and\n        will be searched credentials.\n        Note that if credentials have been explicitelypassed\n        into the class constructor, those values always take\n        precedence.\n        \"\"\"\n        if 'AWS_CREDENTIAL_FILE' in os.environ:\n            path = os.environ['AWS_CREDENTIAL_FILE']\n            path = os.path.expanduser(path)\n            path = os.path.expandvars(path)\n            if os.path.isfile(path):\n                fp = open(path)\n                lines = fp.readlines()\n                fp.close()\n                for line in lines:\n                    if line[0] != '#':\n                        if '=' in line:\n                            name, value = line.split('=', 1)\n                            if name.strip() == 'AWSAccessKeyId':\n                                if 'aws_access_key_id' not in self.args:\n                                    value = value.strip()\n                                    self.args['aws_access_key_id'] = value\n                            elif name.strip() == 'AWSSecretKey':\n                                if 'aws_secret_access_key' not in self.args:\n                                    value = value.strip()\n                                    self.args['aws_secret_access_key'] = value\n            else:\n                print 'Warning: unable to read AWS_CREDENTIAL_FILE'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_for_env_url(self):\n        url = self.args.get('url', None)\n        if url:\n            del self.args['url']\n        if not url and self.EnvURL in os.environ:\n            url = os.environ[self.EnvURL]\n        if url:\n            rslt = urlparse.urlparse(url)\n            if 'is_secure' not in self.args:\n                if rslt.scheme == 'https':\n                    self.args['is_secure'] = True\n                else:\n                    self.args['is_secure'] = False\n\n            host = rslt.netloc\n            port = None\n            l = host.split(':')\n            if len(l) > 1:\n                host = l[0]\n                port = int(l[1])\n            if 'host' not in self.args:\n                self.args['host'] = host\n            if port and 'port' not in self.args:\n                self.args['port'] = port\n\n            if rslt.path and 'path' not in self.args:\n                self.args['path'] = rslt.path", "response": "Checks to see if the url argument is explicitly passed in and if not it will be used. If not it will check if the environment variable is set in the environment variable. If not it will check if the environment variable is set in the environment variable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninstance of : class : ulfedora. api. ResourceIndex with the same root url and credentials", "response": "def risearch(self):\n        \"instance of :class:`eulfedora.api.ResourceIndex`, with the same root url and credentials\"\n        if self._risearch is None:\n            self._risearch = ResourceIndex(self.fedora_root, self.username, self.password)\n        return self._risearch"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_next_pid(self, namespace=None, count=None):\n        # this method should no longer be needed - default pid logic moved to DigitalObject\n        warnings.warn(\"\"\"get_next_pid() method is deprecated; you should mint new pids via DigitalObject or ApiFacade.getNextPID() instead.\"\"\",\n                      DeprecationWarning)\n        kwargs = {}\n        if namespace:\n            kwargs['namespace'] = namespace\n        elif self.default_pidspace:\n            kwargs['namespace'] = self.default_pidspace\n\n        if count:\n            kwargs['numPIDs'] = count\n        r = self.api.getNextPID(**kwargs)\n        nextpids = parse_xml_object(NewPids, r.content, r.url)\n\n        if count is None:\n            return nextpids.pids[0]\n        else:\n            return nextpids.pids", "response": "Request next available pid or pids from Fedora optionally in a specified namespace."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ingest(self, text, log_message=None):\n        kwargs = {'text': text}\n        if log_message:\n            kwargs['logMessage'] = log_message\n        response = self.api.ingest(**kwargs)\n        return response.content", "response": "Ingest a new object into Fedora. Returns the pid of the new object on success."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef purge_object(self, pid, log_message=None):\n        kwargs = {'pid': pid}\n        if log_message:\n            kwargs['logMessage'] = log_message\n        response = self.api.purgeObject(**kwargs)\n        return response.status_code == requests.codes.ok", "response": "Calls : meth : ApiFacade. purgeObject."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding objects in Fedora with the specified content model.", "response": "def get_objects_with_cmodel(self, cmodel_uri, type=None):\n        \"\"\"\n        Find objects in Fedora with the specified content model.\n\n        :param cmodel_uri: content model URI (should be full URI in  info:fedora/pid:### format)\n        :param type: type of object to return (e.g., class:`DigitalObject`)\n        :rtype: list of objects\n        \"\"\"\n        uris = self.risearch.get_subjects(modelns.hasModel, cmodel_uri)\n        return [self.get_object(uri, type) for uri in uris]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_object(self, pid=None, type=None, create=None):\n        objtype = type or self.default_object_type\n\n        if pid is None:\n            if create is None:\n                create = True\n        else:\n            if create is None:\n                create = False\n\n        return objtype(self.api, pid, create,\n                       default_pidspace=self.default_pidspace)", "response": "Initialize a single object from Fedora or create a new one."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninfers the object s subtype using the best subtype for the object.", "response": "def infer_object_subtype(self, api, pid=None, create=False, default_pidspace=None):\n        \"\"\"Construct a DigitalObject or appropriate subclass, inferring the\n        appropriate subtype using :meth:`best_subtype_for_object`. Note that\n        this method signature has been selected to match the\n        :class:`~eulfedora.models.DigitalObject` constructor so that this\n        method might be passed directly to :meth:`get_object` as a `type`::\n\n        >>> obj = repo.get_object(pid, type=repo.infer_object_subtype)\n\n        See also: :class:`TypeInferringRepository`\n        \"\"\"\n        obj = DigitalObject(api, pid, create, default_pidspace)\n        if create:\n            return obj\n        if not obj.exists:\n            return obj\n\n        match_type = self.best_subtype_for_object(obj)\n        return match_type(api, pid)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef best_subtype_for_object(self, obj, content_models=None):\n        if content_models is None:\n            obj_models = set(str(m) for m in obj.get_models())\n        else:\n            obj_models = content_models\n\n        # go through registered DigitalObject subtypes looking for what type\n        # this object might be. use the first longest match: that is, look\n        # for classes we qualify for by having all of their cmodels, and use\n        # the class with the longest set of cmodels. if there's a tie, warn\n        # and pick one.\n        # TODO: store these at registration in a way that doesn't require\n        # this manual search every time\n        # TODO: eventually we want to handle the case where a DigitalObject\n        # can use multiple unrelated cmodels, though we need some major\n        # changes beyond here to support that\n        match_len, matches = 0, []\n        for obj_type in DigitalObject.defined_types.values():\n            type_model_list = getattr(obj_type, 'CONTENT_MODELS', None)\n            if not type_model_list:\n                continue\n            type_models = set(type_model_list)\n            if type_models.issubset(obj_models):\n                if len(type_models) > match_len:\n                    match_len, matches = len(type_models), [obj_type]\n                elif len(type_models) == match_len:\n                    matches.append(obj_type)\n\n        if not matches:\n            return DigitalObject\n\n        if len(matches) > 1:\n            # Check to see if there happens to be an end subclass to the list of matches.\n            for obj_type in matches:\n                is_root_subclass = True\n                for possible_parent_type in matches:\n                    if not issubclass(obj_type, possible_parent_type):\n                        is_root_subclass = False\n                if is_root_subclass:\n                    return obj_type\n\n            logger.warn('%s has %d potential classes with no root subclass for the list. using the first: %s',\n                        obj, len(matches), repr(matches))\n        return matches[0]", "response": "Given an object and a list of content models and a list of content models return the most appropriate subclass for that object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind objects in Fedora.", "response": "def find_objects(self, terms=None, type=None, chunksize=None, **kwargs):\n        \"\"\"\n        Find objects in Fedora.  Find query should be generated via keyword\n        args, based on the fields in Fedora documentation.  By default, the\n        query uses a contains (~) search for all search terms.  Calls\n        :meth:`ApiFacade.findObjects`. Results seem to return consistently\n        in ascending PID order.\n\n        Example usage - search for all objects where the owner contains 'jdoe'::\n\n            repository.find_objects(ownerId='jdoe')\n\n        Supports all search operators provided by Fedora findObjects query (exact,\n        gt, gte, lt, lte, and contains).  To specify the type of query for\n        a particular search term, call find_objects like this::\n\n            repository.find_objects(ownerId__exact='lskywalker')\n            repository.find_objects(date__gt='20010302')\n\n        :param type: type of objects to return; defaults to :class:`DigitalObject`\n        :param chunksize: number of objects to return at a time\n        :rtype: generator for list of objects\n        \"\"\"\n        type = type or self.default_object_type\n\n        find_opts = {'chunksize' : chunksize}\n\n        search_operators = {\n            'exact': '=',\n            'gt': '>',\n            'gte': '>=',\n            'lt': '<',\n\n            'lte': '<=',\n            'contains': '~'\n        }\n\n        if terms is not None:\n            find_opts['terms'] = terms\n        else:\n            conditions = []\n            for field, value in six.iteritems(kwargs):\n                if '__' in field:\n                    field, filtr = field.split('__')\n                    if filtr not in search_operators:\n                        raise Exception(\"Unsupported search filter '%s'\" % filtr)\n                    op = search_operators[filtr]\n                else:\n                    op = search_operators['contains']   # default search mode\n\n                if field in self.search_fields_aliases:\n                    field = self.search_fields_aliases[field]\n                if field not in self.search_fields:\n                    raise Exception(\"Error generating Fedora findObjects query: unknown search field '%s'\" \\\n                                    % field)\n                if ' ' in value:\n                    # if value contains whitespace, it must be delimited with single quotes\n                    value = \"'%s'\" % value\n                conditions.append(\"%s%s%s\" % (field, op, value))\n\n            query = ' '.join(conditions)\n            find_opts['query'] = query\n\n        r = self.api.findObjects(**find_opts)\n        chunk = parse_xml_object(SearchResults, r.content, r.url)\n        while True:\n            for result in chunk.results:\n                yield type(self.api, result.pid)\n\n            if chunk.session_token:\n                r = self.api.findObjects(session_token=chunk.session_token, **find_opts)\n                chunk = parse_xml_object(SearchResults, r.content, r.url)\n            else:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self):\n        if not self._sync and not hasattr(self, '_buffer'):\n            self._buffer = {}\n        if not os.path.exists(self.cache_dir):\n            os.makedirs(self.cache_dir)", "response": "Create the write buffer and cache directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self):\n        if not self._sync:\n            del self._buffer\n        shutil.rmtree(self.cache_dir)", "response": "Delete the write buffer and cache directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _encode_key(self, key):\n        if isinstance(key, str) or isinstance(key, unicode):\n            key = key.encode(self._keyencoding)\n        elif not isinstance(key, bytes):\n            raise TypeError(\"key must be bytes or str\")\n        return codecs.encode(key, 'hex_codec').decode(self._keyencoding)", "response": "Encode a key using hex_codec for constructing a cache filename."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndecode the original key using hex_codec to retrieve the original key.", "response": "def _decode_key(self, key):\n        \"\"\"Decode key using hex_codec to retrieve the original key.\n\n        Keys are returned as :class:`str` if serialization is enabled.\n        Keys are returned as :class:`bytes` if serialization is disabled.\n\n        \"\"\"\n        bkey = codecs.decode(key.encode(self._keyencoding), 'hex_codec')\n        return bkey.decode(self._keyencoding) if self._serialize else bkey"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of absolute cache filenames", "response": "def _all_filenames(self):\n        \"\"\"Return a list of absolute cache filenames\"\"\"\n        try:\n            return [os.path.join(self.cache_dir, filename) for filename in\n                    os.listdir(self.cache_dir)]\n        except (FileNotFoundError, OSError):\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of all encoded key names.", "response": "def _all_keys(self):\n        \"\"\"Return a list of all encoded key names.\"\"\"\n        file_keys = [self._filename_to_key(fn) for fn in self._all_filenames()]\n        if self._sync:\n            return set(file_keys)\n        else:\n            return set(file_keys + list(self._buffer))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _write_to_file(self, filename, bytesvalue):\n        fh, tmp = tempfile.mkstemp()\n        with os.fdopen(fh, self._flag) as f:\n            f.write(self._dumps(bytesvalue))\n        rename(tmp, filename)\n        os.chmod(filename, self._mode)", "response": "Write bytesvalue to filename."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_from_file(self, filename):\n        try:\n            with open(filename, 'rb') as f:\n                return self._loads(f.read())\n        except (IOError, OSError):\n            logger.warning('Error opening file: {}'.format(filename))\n            return None", "response": "Read data from file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping function for Fedora REST API findObjects", "response": "def findObjects(self, query=None, terms=None, pid=True, chunksize=None, session_token=None):\n        \"\"\"\n        Wrapper function for `Fedora REST API findObjects <http://fedora-commons.org/confluence/display/FCR30/REST+API#RESTAPI-findObjects>`_\n        and `Fedora REST API resumeFindObjects <http://fedora-commons.org/confluence/display/FCR30/REST+API#RESTAPI-resumeFindObjects>`_\n\n        One and only one of query or terms must be specified.\n\n        :param query: string of fields and terms to search for\n        :param terms: phrase search across all fields\n        :param pid: include pid in search results\n        :param chunksize: number of objects to return at a time\n        :param session_token: get an additional chunk of results from a prior search\n        :param parse: optional data parser function; defaults to returning\n                      raw string data\n        :rtype: :class:`requests.models.Response`\n        \"\"\"\n        if query is not None and terms is not None:\n            raise Exception(\"Cannot findObject with both query ('%s') and terms ('%s')\" % (query, terms))\n\n        http_args = {'resultFormat': 'xml'}\n        if query is not None:\n            http_args['query'] = query\n        if terms is not None:\n            http_args['terms'] = terms\n\n        if pid:\n            http_args['pid'] = 'true'\n        if session_token:\n            http_args['sessionToken'] = session_token\n        if chunksize:\n            http_args['maxResults'] = chunksize\n        return self.get('objects', params=http_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getDatastreamDissemination(self, pid, dsID, asOfDateTime=None, stream=False,\n                head=False, rqst_headers=None):\n        \"\"\"Get a single datastream on a Fedora object; optionally, get the version\n        as of a particular date time.\n\n        :param pid: object pid\n        :param dsID: datastream id\n        :param asOfDateTime: optional datetime; ``must`` be a non-naive datetime\n            so it can be converted to a date-time format Fedora can understand\n        :param stream: return a streaming response (default: False); use\n            is recommended for large datastreams\n        :param head: return a HEAD request instead of GET (default: False)\n        :param rqst_headers: request headers to be passed through to Fedora,\n            such as http range requests\n\n        :rtype: :class:`requests.models.Response`\n        \"\"\"\n        # /objects/{pid}/datastreams/{dsID}/content ? [asOfDateTime] [download]\n        http_args = {}\n        if rqst_headers is None:\n            rqst_headers = {}\n        if asOfDateTime:\n            http_args['asOfDateTime'] = datetime_to_fedoratime(asOfDateTime)\n        url = 'objects/%(pid)s/datastreams/%(dsid)s/content' %  \\\n            {'pid': pid, 'dsid': dsID}\n        if head:\n            reqmethod = self.head\n        else:\n            reqmethod = self.get\n        return reqmethod(url, params=http_args, stream=stream, headers=rqst_headers)", "response": "Get a single datastream on a Fedora object ; optionally get the version\n            as of a particular date time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a service dissemination.", "response": "def getDissemination(self, pid, sdefPid, method, method_params=None):\n        '''Get a service dissemination.\n\n        .. NOTE:\n\n            This method not available in REST API until Fedora 3.3\n\n        :param pid: object pid\n        :param sDefPid: service definition pid\n        :param method: service method name\n        :param method_params: method parameters\n        :rtype: :class:`requests.models.Response`\n        '''\n        # /objects/{pid}/methods/{sdefPid}/{method} ? [method parameters]\n        if method_params is None:\n            method_params = {}\n        uri = 'objects/%(pid)s/methods/%(sdefpid)s/%(method)s' % \\\n            {'pid': pid, 'sdefpid': sdefPid, 'method': method}\n        return self.get(uri, params=method_params)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist available service methods.", "response": "def listMethods(self, pid, sdefpid=None):\n        '''List available service methods.\n\n        :param pid: object pid\n        :param sDefPid: service definition pid\n        :rtype: :class:`requests.models.Response`\n        '''\n        # /objects/{pid}/methods ? [format, datetime]\n        # /objects/{pid}/methods/{sdefpid} ? [format, datetime]\n\n        ## NOTE: getting an error when sdefpid is specified; fedora issue?\n\n        uri = 'objects/%(pid)s/methods' % {'pid': pid}\n        if sdefpid:\n            uri += '/' + sdefpid\n        return self.get(uri, params=self.format_xml)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a new datastream to an existing object.", "response": "def addDatastream(self, pid, dsID, dsLabel=None, mimeType=None, logMessage=None,\n        controlGroup=None, dsLocation=None, altIDs=None, versionable=None,\n        dsState=None, formatURI=None, checksumType=None, checksum=None, content=None):\n        '''Add a new datastream to an existing object.  On success,\n        the return response should have a status of 201 Created;\n        if there is an error, the response body includes the error message.\n\n        :param pid: object pid\n        :param dsID: id for the new datastream\n        :param dslabel: label for the new datastream (optional)\n        :param mimeType: mimetype for the new datastream (optional)\n        :param logMessage: log message for the object history (optional)\n        :param controlGroup: control group for the new datastream (optional)\n        :param dsLocation: URL where the content should be ingested from\n        :param altIDs: alternate ids (optional)\n        :param versionable: configure datastream versioning (optional)\n        :param dsState: datastream state (optional)\n        :param formatURI: datastream format (optional)\n        :param checksumType: checksum type (optional)\n        :param checksum: checksum  (optional)\n        :param content: datastream content, as a file-like object or\n            characterdata (optional)\n        :rtype: :class:`requests.models.Response`\n        '''\n\n        # objects/{pid}/datastreams/NEWDS? [opts]\n        # content via multipart file in request content, or dsLocation=URI\n        # one of dsLocation or filename must be specified\n\n        # if checksum is sent without checksum type, Fedora seems to\n        # ignore it (does not error on invalid checksum with no checksum type)\n        if checksum is not None and checksumType is None:\n            warnings.warn('Fedora will ignore the checksum (%s) because no checksum type is specified' \\\n                          % checksum)\n\n        http_args = {}\n        if dsLabel:\n            http_args['dsLabel'] = dsLabel\n        if mimeType:\n            http_args['mimeType'] = mimeType\n        if logMessage:\n            http_args['logMessage'] = logMessage\n        if controlGroup:\n            http_args['controlGroup'] = controlGroup\n        if dsLocation:\n            http_args['dsLocation'] = dsLocation\n        if altIDs:\n            http_args['altIDs'] = altIDs\n        if versionable is not None:\n            http_args['versionable'] = versionable\n        if dsState:\n            http_args['dsState'] = dsState\n        if formatURI:\n            http_args['formatURI'] = formatURI\n        if checksumType:\n            http_args['checksumType'] = checksumType\n        if checksum:\n            http_args['checksum'] = checksum\n\n        # Added code to match how content is now handled, see modifyDatastream.\n        extra_args = {}\n        # could be a string or a file-like object\n        if content:\n            if hasattr(content, 'read'):    # if content is a file-like object, warn if no checksum\n                if not checksum:\n                    logger.warning(\"File was ingested into fedora without a passed checksum for validation, pid was: %s and dsID was: %s.\",\n                                   pid, dsID)\n                extra_args['files'] = {'file': content}\n\n            else:\n                # fedora wants a multipart file upload;\n                # this seems to work better for handling unicode than\n                # simply sending content via requests data parameter\n                extra_args['files'] = {'file': ('filename', content)}\n\n        # set content-type header ?\n        url = 'objects/%s/datastreams/%s' % (pid, dsID)\n        return self.post(url, params=http_args, **extra_args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping function for Fedora REST API addRelationship", "response": "def addRelationship(self, pid, subject, predicate, object, isLiteral=False,\n                        datatype=None):\n        \"\"\"\n        Wrapper function for `Fedora REST API addRelationship <https://wiki.duraspace.org/display/FEDORA34/REST+API#RESTAPI-addRelationship>`_\n\n        :param pid: persistent id for the object to add the new relationship to\n        :param subject: subject of the relationship; object or datastream URI\n        :param predicate: predicate of the new relationship\n        :param object: object of the relationship\n        :param isLiteral: true if object is literal, false if it is a URI;\n            Fedora has no default; this method defaults to False\n        :param datatype: optional datatype for literal objects\n\n        :returns: boolean success\n        \"\"\"\n\n        http_args = {'subject': subject, 'predicate': predicate,\n                     'object': object, 'isLiteral': isLiteral}\n        if datatype is not None:\n            http_args['datatype'] = datatype\n\n        url = 'objects/%(pid)s/relationships/new' % {'pid': pid}\n        response = self.post(url, params=http_args)\n        return response.status_code == requests.codes.ok"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompares the checksum of a datastream.", "response": "def compareDatastreamChecksum(self, pid, dsID, asOfDateTime=None): # date time\n        '''Compare (validate) datastream checksum.  This is a special case of\n        :meth:`getDatastream`, with validate checksum set to True. Fedora\n        will recalculate the checksum and compare it to the stored value.\n        Response is the same content returned by :meth:`getDatastream`,\n        with validation result included in the xml.\n\n        :rtype: :class:`requests.models.Response`\n        '''\n        # special case of getDatastream, with validateChecksum = true\n        # currently returns datastream info returned by getDatastream...  what should it return?\n        return self.getDatastream(pid, dsID, validateChecksum=True, asOfDateTime=asOfDateTime)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexports an object to be migrated or archived.", "response": "def export(self, pid, context=None, format=None, encoding=None,\n                stream=False):\n        '''Export an object to be migrated or archived.\n\n        :param pid: object pid\n        :param context: export context, one of: public, migrate, archive\n            (default: public)\n        :param format: export format (Fedora default is foxml 1.1)\n        :param encoding: encoding (Fedora default is UTF-8)\n        :param stream: if True, request a streaming response to be\n            read in chunks\n        :rtype: :class:`requests.models.Response`\n        '''\n\n        http_args = {}\n        if context:\n            http_args['context'] = context\n        if format:\n            http_args['format'] = format\n        if encoding:\n            http_args['encoding'] = encoding\n        uri = 'objects/%s/export' % pid\n        return self.get(uri, params=http_args, stream=stream)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getDatastream(self, pid, dsID, asOfDateTime=None, validateChecksum=False):\n        # /objects/{pid}/datastreams/{dsID} ? [asOfDateTime] [format] [validateChecksum]\n        http_args = {}\n        if validateChecksum:\n            # fedora only responds to lower-case validateChecksum option\n            http_args['validateChecksum'] = str(validateChecksum).lower()\n        if asOfDateTime:\n            http_args['asOfDateTime'] = datetime_to_fedoratime(asOfDateTime)\n        http_args.update(self.format_xml)\n        uri = 'objects/%(pid)s/datastreams/%(dsid)s' % {'pid': pid, 'dsid': dsID}\n        return self.get(uri, params=http_args)", "response": "Get information about a single datastream on a Fedora object ; optionally get information about the version of the datastream as of a particular date time."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget history information for a datastream.", "response": "def getDatastreamHistory(self, pid, dsid, format=None):\n        '''Get history information for a datastream.\n\n        :param pid: object pid\n        :param dsid: datastream id\n        :param format: format\n        :rtype: :class:`requests.models.Response`\n        '''\n        http_args = {}\n        if format is not None:\n            http_args['format'] = format\n        # Fedora docs say the url should be:\n        #   /objects/{pid}/datastreams/{dsid}/versions\n        # In Fedora 3.4.3, that 404s but /history does not\n        uri = 'objects/%(pid)s/datastreams/%(dsid)s/history' % \\\n            {'pid': pid, 'dsid': dsid}\n        return self.get(uri, params=http_args)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getNextPID(self, numPIDs=None, namespace=None):\n        http_args = {'format': 'xml'}\n        if numPIDs:\n            http_args['numPIDs'] = numPIDs\n        if namespace:\n            http_args['namespace'] = namespace\n\n        rel_url = 'objects/nextPID'\n        return self.post(rel_url, params=http_args)", "response": "Wrapper function for Fedora REST API getNextPID"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrap function for Fedora REST API getRelationships <https://wiki. duraspace. org / display / FEDORA34 / REST - API - getRelationships > _", "response": "def getRelationships(self, pid, subject=None, predicate=None, format=None):\n        '''Get information about relationships on an object.\n\n        Wrapper function for\n         `Fedora REST API getRelationships <https://wiki.duraspace.org/display/FEDORA34/REST+API#RESTAPI-getRelationships>`_\n\n        :param pid: object pid\n        :param subject: subject (optional)\n        :param predicate: predicate (optional)\n        :param format: format\n        :rtype: :class:`requests.models.Response`\n        '''\n        http_args = {}\n        if subject is not None:\n            http_args['subject'] = subject\n        if predicate is not None:\n            http_args['predicate'] = predicate\n        if format is not None:\n            http_args['format'] = format\n\n        url = 'objects/%(pid)s/relationships' % {'pid': pid}\n        return self.get(url, params=http_args)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ingest(self, text, logMessage=None):\n        # NOTE: ingest method supports additional options for\n        # label/format/namespace/ownerId, etc - but we generally set\n        # those in the foxml that is passed in\n\n        http_args = {}\n        if logMessage:\n            http_args['logMessage'] = logMessage\n\n        headers = {'Content-Type': 'text/xml'}\n\n        url = 'objects/new'\n\n        # if text is unicode, it needs to be encoded so we can send the\n        # data as bytes; otherwise, we get ascii encode errors in httplib/ssl\n        if isinstance(text, six.text_type):\n            text = bytes(text.encode('utf-8'))\n\n        return self.post(url, data=text, params=http_args, headers=headers)", "response": "Ingest a new object into Fedora. Returns the pid of the newly created object on success."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef modifyDatastream(self, pid, dsID, dsLabel=None, mimeType=None, logMessage=None, dsLocation=None,\n        altIDs=None, versionable=None, dsState=None, formatURI=None, checksumType=None,\n        checksum=None, content=None, force=False):\n        '''Modify an existing datastream, similar to :meth:`addDatastraem`.\n        Content can be specified by either a URI location or as\n        string content or file-like object; if content is not specified,\n        datastream metadata will be updated without modifying the content.\n\n        On success, the returned response should have a status code 200;\n        on failure, the response body may include an error message.\n\n        :param pid: object pid\n        :param dsID: id for the new datastream\n        :param dslabel: label for the new datastream (optional)\n        :param mimeType: mimetype for the new datastream (optional)\n        :param logMessage: log message for the object history (optional)\n        :param dsLocation: URL where the content should be ingested from (optional)\n        :param altIDs: alternate ids (optional)\n        :param versionable: configure datastream versioning (optional)\n        :param dsState: datastream state (optional)\n        :param formatURI: datastream format (optional)\n        :param checksumType: checksum type (optional)\n        :param checksum: checksum (optional)\n        :param content: datastream content, as a file-like object or\n            characterdata (optional)\n        :param force: force the update (default: False)\n        :rtype: :class:`requests.models.Response`\n        '''\n        # /objects/{pid}/datastreams/{dsID} ? [dsLocation] [altIDs] [dsLabel]\n        # [versionable] [dsState] [formatURI] [checksumType] [checksum]\n        # [mimeType] [logMessage] [force] [ignoreContent]\n        # NOTE: not implementing ignoreContent (unneeded)\n\n        # Unlike addDatastream, if checksum is sent without checksum\n        # type, Fedora honors it (*does* error on invalid checksum\n        # with no checksum type) - it seems to use the existing\n        # checksum type if a new type is not specified.\n        http_args = {}\n        if dsLabel:\n            http_args['dsLabel'] = dsLabel\n        if mimeType:\n            http_args['mimeType'] = mimeType\n        if logMessage:\n            http_args['logMessage'] = logMessage\n        if dsLocation:\n            http_args['dsLocation'] = dsLocation\n        if altIDs:\n            http_args['altIDs'] = altIDs\n        if versionable is not None:\n            http_args['versionable'] = versionable\n        if dsState:\n            http_args['dsState'] = dsState\n        if formatURI:\n            http_args['formatURI'] = formatURI\n        if checksumType:\n            http_args['checksumType'] = checksumType\n        if checksum:\n            http_args['checksum'] = checksum\n        if force:\n            http_args['force'] = force\n\n        content_args = {}\n        if content:\n            # content can be either a string or a file-like object\n            if hasattr(content, 'read'):    # allow content to be a file\n                # warn about missing checksums for files\n                if not checksum:\n                    logger.warning(\"Updating datastream %s/%s with a file, but no checksum passed\",\n                                   pid, dsID)\n\n            # either way (string or file-like object), set content as request data\n            # (file-like objects supported in requests as of 0.13.1)\n            content_args['data'] = content\n\n        url = 'objects/%s/datastreams/%s' % (pid, dsID)\n        return self.put(url, params=http_args, **content_args)", "response": "Modify an existing datastream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef modifyObject(self, pid, label, ownerId, state, logMessage=None):\n        '''Modify object properties.  Returned response should have\n        a status of 200 on succuss.\n\n        :param pid: object pid\n        :param label: object label\n        :param ownerId: object owner\n        :param state: object state\n        :param logMessage: optional log message\n\n        :rtype: :class:`requests.models.Response`\n        '''\n        # /objects/{pid} ? [label] [ownerId] [state] [logMessage]\n        http_args = {'label': label,\n                     'ownerId': ownerId,\n                     'state': state}\n        if logMessage is not None:\n            http_args['logMessage'] = logMessage\n        url = 'objects/%(pid)s' % {'pid': pid}\n        return self.put(url, params=http_args)", "response": "Modify object properties. Returned response should have\n        a status of 200 on succuss."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npurging a datastream or specific versions of a Fedora object from a Fedora object.", "response": "def purgeDatastream(self, pid, dsID, startDT=None, endDT=None, logMessage=None,\n            force=False):\n        \"\"\"Purge a datastream, or specific versions of a dastream, from\n        a Fedora object.  On success, response content will include\n        a list of timestamps for the purged datastream versions; on failure,\n        response content may contain an error message.\n\n        :param pid: object pid\n        :param dsID: datastream ID\n        :param startDT: optional start datetime (when purging specific versions)\n        :param endDT: optional end datetime (when purging specific versions)\n        :param logMessage: optional log message\n\n        :rtype: :class:`requests.models.Response`\n        \"\"\"\n        # /objects/{pid}/datastreams/{dsID} ? [startDT] [endDT] [logMessage] [force]\n        http_args = {}\n        if logMessage:\n            http_args['logMessage'] = logMessage\n        if startDT:\n            http_args['startDT'] = startDT\n        if endDT:\n            http_args['endDT'] = endDT\n        if force:\n            http_args['force'] = force\n\n        url = 'objects/%(pid)s/datastreams/%(dsid)s' % {'pid': pid, 'dsid': dsID}\n        return self.delete(url, params=http_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef purgeObject(self, pid, logMessage=None):\n        http_args = {}\n        if logMessage:\n            http_args['logMessage'] = logMessage\n\n        url = 'objects/%(pid)s' % {'pid': pid}\n        return self.delete(url, params=http_args)", "response": "Purge an object from Fedora."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef purgeRelationship(self, pid, subject, predicate, object, isLiteral=False,\n                        datatype=None):\n        '''Remove a relationship from an object.\n\n        Wrapper function for\n        `Fedora REST API purgeRelationship <https://wiki.duraspace.org/display/FEDORA34/REST+API#RESTAPI-purgeRelationship>`_\n\n        :param pid: object pid\n        :param subject: relationship subject\n        :param predicate: relationship predicate\n        :param object: relationship object\n        :param isLiteral: boolean (default: false)\n        :param datatype: optional datatype\n        :returns: boolean; indicates whether or not a relationship was\n            removed\n        '''\n\n        http_args = {'subject': subject, 'predicate': predicate,\n                     'object': object, 'isLiteral': isLiteral}\n        if datatype is not None:\n            http_args['datatype'] = datatype\n\n        url = 'objects/%(pid)s/relationships' % {'pid': pid}\n        response = self.delete(url, params=http_args)\n        # should have a status code of 200;\n        # response body text indicates if a relationship was purged or not\n        return response.status_code == requests.codes.ok and response.content == b'true'", "response": "Removes a relationship from an object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setDatastreamState(self, pid, dsID, dsState):\n        '''Update datastream state.\n\n        :param pid: object pid\n        :param dsID: datastream id\n        :param dsState: datastream state\n        :returns: boolean success\n        '''\n        # /objects/{pid}/datastreams/{dsID} ? [dsState]\n        http_args = {'dsState' : dsState}\n        url = 'objects/%(pid)s/datastreams/%(dsid)s' % {'pid': pid, 'dsid': dsID}\n        response = self.put(url, params=http_args)\n        # returns response code 200 on success\n        return response.status_code == requests.codes.ok", "response": "Update datastream state.\n\n        :param pid: object pid\n        :param dsID: datastream id\n        :param dsState: datastream state\n        :returns: boolean success"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates datastream versionable setting.", "response": "def setDatastreamVersionable(self, pid, dsID, versionable):\n        '''Update datastream versionable setting.\n\n        :param pid: object pid\n        :param dsID: datastream id\n        :param versionable: boolean\n        :returns: boolean success\n        '''\n        # /objects/{pid}/datastreams/{dsID} ? [versionable]\n        http_args = {'versionable': versionable}\n        url = 'objects/%(pid)s/datastreams/%(dsid)s' % {'pid': pid, 'dsid': dsID}\n        response = self.put(url, params=http_args)\n        # returns response code 200 on success\n        return response.status_code == requests.codes.ok"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads a multi - part file for content to ingest. Returns a temporary upload id that can be used for the upload.", "response": "def upload(self, data, callback=None, content_type=None,\n               size=None):\n        '''\n        Upload a multi-part file for content to ingest.  Returns a\n        temporary upload id that can be used as a datstream location.\n\n        :param data: content string, file-like object, or iterable with\n            content to be uploaded\n        :param callback: optional callback method to monitor the upload;\n            see :mod:`requests-toolbelt` documentation for more\n            details: https://toolbelt.readthedocs.org/en/latest/user.html#uploading-data\n        :param content_type: optional content type of the data\n        :param size: optional size of the data; required when using an\n            iterable for the data\n\n        :returns: upload id on success\n        '''\n        url = 'upload'\n        # fedora only expects content uploaded as multipart file;\n        # make string content into a file-like object so requests.post\n        # sends it the way Fedora expects.\n        # NOTE: checking for both python 2.x next method and\n        # python 3.x __next__ to test if data is iteraable\n        if not hasattr(data, 'read') and \\\n          not (hasattr(data, '__next__') or hasattr(data, 'next')):\n            data = six.BytesIO(force_bytes(data))\n\n        # if data is an iterable, wrap in a readable iterator that\n        # requests-toolbelt can read data from\n        elif not hasattr(data, 'read') and \\\n          (hasattr(data, '__next__') or hasattr(data, 'next')):\n            if size is None:\n                raise Exception('Cannot upload iterable with unknown size')\n            data = ReadableIterator(data, size)\n\n        # use requests-toolbelt multipart encoder to avoid reading\n        # the full content of large files into memory\n        menc = MultipartEncoder(fields={'file': ('file', data, content_type)})\n\n        if callback is not None:\n            menc = MultipartEncoderMonitor(menc, callback)\n\n        headers = {'Content-Type': menc.content_type}\n\n        if size:\n            # latest version of requests requires str or bytes, not int\n            if not isinstance(size, six.string_types):\n                size = str(size)\n            headers['Content-Length'] = size\n\n        try:\n            response = self.post(url, data=menc, headers=headers)\n        except OverflowError:\n            # Python __len__ uses integer so it is limited to system maxint,\n            # and requests and requests-toolbelt use len() throughout.\n            # This results in an overflow error when trying to upload a file\n            # larger than system maxint (2GB on 32-bit OSes).\n            # See http://bugs.python.org/issue12159\n            msg = 'upload content larger than system maxint (32-bit OS limitation)'\n            logger.error('OverflowError: %s', msg)\n            raise OverflowError(msg)\n\n        if response.status_code == requests.codes.accepted:\n            return response.text.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning a query on the Fedora Resource Index and return the results.", "response": "def find_statements(self, query, language='spo', type='triples', flush=None,\n                        limit=None):\n        \"\"\"\n        Run a query in a format supported by the Fedora Resource Index (e.g., SPO\n        or Sparql) and return the results.\n\n        :param query: query as a string\n        :param language: query language to use; defaults to 'spo'\n        :param type: type of query - tuples or triples; defaults to 'triples'\n        :param flush: flush results to get recent changes; defaults to False\n        :rtype: :class:`rdflib.ConjunctiveGraph` when type is ``triples``; list\n            of dictionaries (keys based on return fields) when type is ``tuples``\n        \"\"\"\n        http_args = {\n            'type': type,\n            'lang': language,\n            'query': query,\n        }\n        if type == 'triples':\n            result_format = 'N-Triples'\n        elif type == 'tuples':\n            result_format = 'CSV'\n        if limit is not None:\n            http_args['limit'] = limit\n        # else - error/exception ?\n        http_args['format'] = result_format\n\n        return self._query(result_format, http_args, flush)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef count_statements(self, query, language='spo', type='triples',\n                         flush=None):\n        \"\"\"\n        Run a query in a format supported by the Fedora Resource Index\n        (e.g., SPO or Sparql) and return the count of the results.\n\n        :param query: query as a string\n        :param language: query language to use; defaults to 'spo'\n        :param flush: flush results to get recent changes; defaults to False\n        :rtype: integer\n        \"\"\"\n        result_format = 'count'\n        http_args = {\n            'type': type,\n            'lang': language,\n            'query': query,\n            'format': result_format\n        }\n        return self._query(result_format, http_args, flush)", "response": "Run a query and return the count of the results."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates and run a spo search.", "response": "def spo_search(self, subject=None, predicate=None, object=None):\n        \"\"\"\n        Create and run a subject-predicate-object (SPO) search.  Any search terms\n        that are not specified will be replaced as a wildcard in the query.\n\n        :param subject: optional subject to search\n        :param predicate: optional predicate to search\n        :param object: optional object to search\n        :rtype: :class:`rdflib.ConjunctiveGraph`\n        \"\"\"\n        spo_query = '%s %s %s' % \\\n                (self.spoencode(subject), self.spoencode(predicate), self.spoencode(object))\n        return self.find_statements(spo_query)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_subjects(self, predicate, object):\n        for statement in self.spo_search(predicate=predicate, object=object):\n            yield str(statement[0])", "response": "Search for all subjects related to the specified predicate and object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_predicates(self, subject, object):\n        for statement in self.spo_search(subject=subject, object=object):\n            yield str(statement[1])", "response": "Search for all subjects related to the specified subject and object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_objects(self, subject, predicate):\n        for statement in self.spo_search(subject=subject, predicate=predicate):\n            yield str(statement[2])", "response": "Search for all subjects related to the specified subject and predicate."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sparql_query(self, query, flush=None, limit=None):\n        return self.find_statements(query, language='sparql', type='tuples',\n            flush=flush, limit=limit)", "response": "Run a Sparql query."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncounting the number of items in a set of items in a Sparql query.", "response": "def sparql_count(self, query, flush=None):\n        \"\"\"\n        Count results for a Sparql query.\n\n        :param query: sparql query string\n        :rtype: int\n        \"\"\"\n        return self.count_statements(query, language='sparql', type='tuples',\n            flush=flush)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new CloudFormation Stack.", "response": "def create_stack(self, stack_name, template_body=None, template_url=None,\n            parameters=[], notification_arns=[], disable_rollback=False,\n            timeout_in_minutes=None, capabilities=None):\n        \"\"\"\n        Creates a CloudFormation Stack as specified by the template.\n\n        :type stack_name: string\n        :param stack_name: The name of the Stack, must be unique amoung running\n                            Stacks\n\n        :type template_body: string\n        :param template_body: The template body (JSON string)\n\n        :type template_url: string\n        :param template_url: An S3 URL of a stored template JSON document. If\n            both the template_body and template_url are\n            specified, the template_body takes precedence\n\n        :type parameters: list of tuples\n        :param parameters: A list of (key, value) pairs for template input\n            parameters.\n\n        :type notification_arns: list of strings\n        :param notification_arns: A list of SNS topics to send Stack event\n            notifications to.\n\n        :type disable_rollback: bool\n        :param disable_rollback: Indicates whether or not to rollback on\n            failure.\n\n        :type timeout_in_minutes: int\n        :param timeout_in_minutes: Maximum amount of time to let the Stack\n            spend creating itself. If this timeout is exceeded,\n            the Stack will enter the CREATE_FAILED state.\n\n        :type capabilities: list\n        :param capabilities: The list of capabilities you want to allow in\n            the stack.  Currently, the only valid capability is\n            'CAPABILITY_IAM'.\n\n        :rtype: string\n        :return: The unique Stack ID.\n        \"\"\"\n        params = {'ContentType': \"JSON\", 'StackName': stack_name,\n                'DisableRollback': self.encode_bool(disable_rollback)}\n        if template_body:\n            params['TemplateBody'] = template_body\n        if template_url:\n            params['TemplateURL'] = template_url\n        if template_body and template_url:\n            boto.log.warning(\"If both TemplateBody and TemplateURL are\"\n                \" specified, only TemplateBody will be honored by the API\")\n        if len(parameters) > 0:\n            for i, (key, value) in enumerate(parameters):\n                params['Parameters.member.%d.ParameterKey' % (i+1)] = key\n                params['Parameters.member.%d.ParameterValue' % (i+1)] = value\n        if capabilities:\n            for i, value in enumerate(capabilities):\n                params['Capabilities.member.%d' % (i+1)] = value\n        if len(notification_arns) > 0:\n            self.build_list_params(params, notification_arns,\n                                   \"NotificationARNs.member\")\n        if timeout_in_minutes:\n            params['TimeoutInMinutes'] = int(timeout_in_minutes)\n\n        response = self.make_request('CreateStack', params, '/', 'POST')\n        body = response.read()\n        if response.status == 200:\n            body = json.loads(body)\n            return body['CreateStackResponse']['CreateStackResult']['StackId']\n        else:\n            boto.log.error('%s %s' % (response.status, response.reason))\n            boto.log.error('%s' % body)\n            raise self.ResponseError(response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a change request to the list of changes.", "response": "def add_change(self, action, name, type, ttl=600,\n            alias_hosted_zone_id=None, alias_dns_name=None, identifier=None,\n            weight=None):\n        \"\"\"Add a change request\"\"\"\n        change = Record(name, type, ttl,\n                alias_hosted_zone_id=alias_hosted_zone_id,\n                alias_dns_name=alias_dns_name, identifier=identifier,\n                weight=weight)\n        self.changes.append([action, change])\n        return change"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_xml(self):\n        changesXML = \"\"\n        for change in self.changes:\n            changeParams = {\"action\": change[0], \"record\": change[1].to_xml()}\n            changesXML += self.ChangeXML % changeParams\n        params = {\"comment\": self.comment, \"changes\": changesXML}\n        return self.ChangeResourceRecordSetsBody % params", "response": "Convert this ResourceRecordSet into XML\n        to be saved via the ChangeResourceRecordSetsRequest"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nover-writes to add the NextRecordName NextRecordType and NextRecordType to the base object", "response": "def endElement(self, name, value, connection):\n        \"\"\"Overwritten to also add the NextRecordName and\n        NextRecordType to the base object\"\"\"\n        if name == 'NextRecordName':\n            self.next_record_name = value\n        elif name == 'NextRecordType':\n            self.next_record_type = value\n        else:\n            return ResultSet.endElement(self, name, value, connection)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_alias(self, alias_hosted_zone_id, alias_dns_name):\n        self.alias_hosted_zone_id = alias_hosted_zone_id\n        self.alias_dns_name = alias_dns_name", "response": "Make this an alias resource record set"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_xml(self):\n        if self.alias_hosted_zone_id != None and self.alias_dns_name != None:\n            # Use alias\n            body = self.AliasBody % (self.alias_hosted_zone_id, self.alias_dns_name)\n        else:\n            # Use resource record(s)\n            records = \"\"\n            for r in self.resource_records:\n                records += self.ResourceRecordBody % r\n            body = self.ResourceRecordsBody % {\n                \"ttl\": self.ttl,\n                \"records\": records,\n            }\n        weight = \"\"\n        if self.identifier != None and self.weight != None:\n            weight = self.WRRBody % {\"identifier\": self.identifier, \"weight\":\n                    self.weight}\n        params = {\n            \"name\": self.name,\n            \"type\": self.type,\n            \"weight\": weight,\n            \"body\": body,\n        }\n        return self.XMLBody % params", "response": "Spit this resource record set out as XML"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the state of the object based on the response from Amazon DynamoDB.", "response": "def update_from_response(self, response):\n        \"\"\"\n        Update the state of the Table object based on the response\n        data received from Amazon DynamoDB.\n        \"\"\"\n        if 'Table' in response:\n            self._dict.update(response['Table'])\n        elif 'TableDescription' in response:\n            self._dict.update(response['TableDescription'])\n        if 'KeySchema' in self._dict:\n            self._schema = Schema(self._dict['KeySchema'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrefresh all of the fields of the table by calling DescribeTable.", "response": "def refresh(self, wait_for_active=False, retry_seconds=5):\n        \"\"\"\n        Refresh all of the fields of the Table object by calling\n        the underlying DescribeTable request.\n\n        :type wait_for_active: bool\n        :param wait_for_active: If True, this command will not return\n            until the table status, as returned from Amazon DynamoDB, is\n            'ACTIVE'.\n\n        :type retry_seconds: int\n        :param retry_seconds: If wait_for_active is True, this\n            parameter controls the number of seconds of delay between\n            calls to update_table in Amazon DynamoDB.  Default is 5 seconds.\n        \"\"\"\n        done = False\n        while not done:\n            response = self.layer2.describe_table(self.name)\n            self.update_from_response(response)\n            if wait_for_active:\n                if self.status == 'ACTIVE':\n                    done = True\n                else:\n                    time.sleep(retry_seconds)\n            else:\n                done = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_throughput(self, read_units, write_units):\n        self.layer2.update_throughput(self, read_units, write_units)", "response": "Update the ProvisionedThroughput for the Amazon DynamoDB Table."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve an existing item from the table.", "response": "def get_item(self, hash_key, range_key=None,\n                 attributes_to_get=None, consistent_read=False,\n                 item_class=Item):\n        \"\"\"\n        Retrieve an existing item from the table.\n\n        :type hash_key: int|long|float|str|unicode\n        :param hash_key: The HashKey of the requested item.  The\n            type of the value must match the type defined in the\n            schema for the table.\n        \n        :type range_key: int|long|float|str|unicode\n        :param range_key: The optional RangeKey of the requested item.\n            The type of the value must match the type defined in the\n            schema for the table.\n            \n        :type attributes_to_get: list\n        :param attributes_to_get: A list of attribute names.\n            If supplied, only the specified attribute names will\n            be returned.  Otherwise, all attributes will be returned.\n\n        :type consistent_read: bool\n        :param consistent_read: If True, a consistent read\n            request is issued.  Otherwise, an eventually consistent\n            request is issued.\n\n        :type item_class: Class\n        :param item_class: Allows you to override the class used\n            to generate the items. This should be a subclass of\n            :class:`boto.dynamodb.item.Item`\n        \"\"\"\n        return self.layer2.get_item(self, hash_key, range_key,\n                                    attributes_to_get, consistent_read,\n                                    item_class)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the table to see if an item with the specified hash_key exists.", "response": "def has_item(self, hash_key, range_key=None, consistent_read=False):\n        \"\"\"\n        Checks the table to see if the Item with the specified ``hash_key``\n        exists. This may save a tiny bit of time/bandwidth over a\n        straight :py:meth:`get_item` if you have no intention to touch\n        the data that is returned, since this method specifically tells\n        Amazon not to return anything but the Item's key.\n\n        :type hash_key: int|long|float|str|unicode\n        :param hash_key: The HashKey of the requested item.  The\n            type of the value must match the type defined in the\n            schema for the table.\n\n        :type range_key: int|long|float|str|unicode\n        :param range_key: The optional RangeKey of the requested item.\n            The type of the value must match the type defined in the\n            schema for the table.\n\n        :type consistent_read: bool\n        :param consistent_read: If True, a consistent read\n            request is issued.  Otherwise, an eventually consistent\n            request is issued.\n\n        :rtype: bool\n        :returns: ``True`` if the Item exists, ``False`` if not.\n        \"\"\"\n        try:\n            # Attempt to get the key. If it can't be found, it'll raise\n            # an exception.\n            self.get_item(hash_key, range_key=range_key,\n                          # This minimizes the size of the response body.\n                          attributes_to_get=[hash_key],\n                          consistent_read=consistent_read)\n        except dynamodb_exceptions.DynamoDBKeyNotFoundError:\n            # Key doesn't exist.\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef new_item(self, hash_key, range_key=None, attrs=None):\n        return Item(self, hash_key, range_key, attrs)", "response": "Return a new unsaved Item which can later be PUT to\n        Amazon DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nperforming a query on the table. :type hash_key: int|long|float|str|unicode :param hash_key: The HashKey of the requested item. The type of the value must match the type defined in the schema for the table. :type range_key_condition: dict :param range_key_condition: A dict where the key is either a scalar value appropriate for the RangeKey in the schema of the database or a tuple of such values. The value associated with this key in the dict will be one of the following conditions: 'EQ'|'LE'|'LT'|'GE'|'GT'|'BEGINS_WITH'|'BETWEEN' The only condition which expects or will accept a tuple of values is 'BETWEEN', otherwise a scalar value should be used as the key in the dict. :type attributes_to_get: list :param attributes_to_get: A list of attribute names. If supplied, only the specified attribute names will be returned. Otherwise, all attributes will be returned. :type request_limit: int :param request_limit: The maximum number of items to retrieve from Amazon DynamoDB on each request. You may want to set a specific request_limit based on the provisioned throughput of your table. The default behavior is to retrieve as many results as possible per request. :type max_results: int :param max_results: The maximum number of results that will be retrieved from Amazon DynamoDB in total. For example, if you only wanted to see the first 100 results from the query, regardless of how many were actually available, you could set max_results to 100 and the generator returned from the query method will only yeild 100 results max. :type consistent_read: bool :param consistent_read: If True, a consistent read request is issued. Otherwise, an eventually consistent request is issued. :type scan_index_forward: bool :param scan_index_forward: Specified forward or backward traversal of the index. Default is forward (True). :type exclusive_start_key: list or tuple :param exclusive_start_key: Primary key of the item from which to continue an earlier query. This would be provided as the LastEvaluatedKey in that query. :type item_class: Class :param item_class: Allows you to override the class used to generate the items. This should be a subclass of :class:`boto.dynamodb.item.Item`", "response": "def query(self, hash_key, range_key_condition=None,\n              attributes_to_get=None, request_limit=None,\n              max_results=None, consistent_read=False,\n              scan_index_forward=True, exclusive_start_key=None,\n              item_class=Item):\n        \"\"\"\n        Perform a query on the table.\n        \n        :type hash_key: int|long|float|str|unicode\n        :param hash_key: The HashKey of the requested item.  The\n            type of the value must match the type defined in the\n            schema for the table.\n\n        :type range_key_condition: dict\n        :param range_key_condition: A dict where the key is either\n            a scalar value appropriate for the RangeKey in the schema\n            of the database or a tuple of such values.  The value \n            associated with this key in the dict will be one of the\n            following conditions:\n\n            'EQ'|'LE'|'LT'|'GE'|'GT'|'BEGINS_WITH'|'BETWEEN'\n\n            The only condition which expects or will accept a tuple\n            of values is 'BETWEEN', otherwise a scalar value should\n            be used as the key in the dict.\n        \n        :type attributes_to_get: list\n        :param attributes_to_get: A list of attribute names.\n            If supplied, only the specified attribute names will\n            be returned.  Otherwise, all attributes will be returned.\n\n        :type request_limit: int\n        :param request_limit: The maximum number of items to retrieve\n            from Amazon DynamoDB on each request.  You may want to set\n            a specific request_limit based on the provisioned throughput\n            of your table.  The default behavior is to retrieve as many\n            results as possible per request.\n\n        :type max_results: int\n        :param max_results: The maximum number of results that will\n            be retrieved from Amazon DynamoDB in total.  For example,\n            if you only wanted to see the first 100 results from the\n            query, regardless of how many were actually available, you\n            could set max_results to 100 and the generator returned\n            from the query method will only yeild 100 results max.\n\n        :type consistent_read: bool\n        :param consistent_read: If True, a consistent read\n            request is issued.  Otherwise, an eventually consistent\n            request is issued.\n\n        :type scan_index_forward: bool\n        :param scan_index_forward: Specified forward or backward\n            traversal of the index.  Default is forward (True).\n\n        :type exclusive_start_key: list or tuple\n        :param exclusive_start_key: Primary key of the item from\n            which to continue an earlier query.  This would be\n            provided as the LastEvaluatedKey in that query.\n\n        :type item_class: Class\n        :param item_class: Allows you to override the class used\n            to generate the items. This should be a subclass of\n            :class:`boto.dynamodb.item.Item`\n        \"\"\"\n        return self.layer2.query(self, hash_key, range_key_condition,\n                                 attributes_to_get, request_limit,\n                                 max_results, consistent_read,\n                                 scan_index_forward, exclusive_start_key,\n                                 item_class=item_class)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef scan(self, scan_filter=None,\n             attributes_to_get=None, request_limit=None, max_results=None,\n             count=False, exclusive_start_key=None, item_class=Item):\n        \"\"\"\n        Scan through this table, this is a very long\n        and expensive operation, and should be avoided if\n        at all possible.\n\n        :type scan_filter: A list of tuples\n        :param scan_filter: A list of tuples where each tuple consists\n            of an attribute name, a comparison operator, and either\n            a scalar or tuple consisting of the values to compare\n            the attribute to.  Valid comparison operators are shown below\n            along with the expected number of values that should be supplied.\n\n             * EQ - equal (1)\n             * NE - not equal (1)\n             * LE - less than or equal (1)\n             * LT - less than (1)\n             * GE - greater than or equal (1)\n             * GT - greater than (1)\n             * NOT_NULL - attribute exists (0, use None)\n             * NULL - attribute does not exist (0, use None)\n             * CONTAINS - substring or value in list (1)\n             * NOT_CONTAINS - absence of substring or value in list (1)\n             * BEGINS_WITH - substring prefix (1)\n             * IN - exact match in list (N)\n             * BETWEEN - >= first value, <= second value (2)\n\n        :type attributes_to_get: list\n        :param attributes_to_get: A list of attribute names.\n            If supplied, only the specified attribute names will\n            be returned.  Otherwise, all attributes will be returned.\n\n        :type request_limit: int\n        :param request_limit: The maximum number of items to retrieve\n            from Amazon DynamoDB on each request.  You may want to set\n            a specific request_limit based on the provisioned throughput\n            of your table.  The default behavior is to retrieve as many\n            results as possible per request.\n\n        :type max_results: int\n        :param max_results: The maximum number of results that will\n            be retrieved from Amazon DynamoDB in total.  For example,\n            if you only wanted to see the first 100 results from the\n            query, regardless of how many were actually available, you\n            could set max_results to 100 and the generator returned\n            from the query method will only yeild 100 results max.\n\n        :type count: bool\n        :param count: If True, Amazon DynamoDB returns a total\n            number of items for the Scan operation, even if the\n            operation has no matching items for the assigned filter.\n\n        :type exclusive_start_key: list or tuple\n        :param exclusive_start_key: Primary key of the item from\n            which to continue an earlier query.  This would be\n            provided as the LastEvaluatedKey in that query.\n\n        :type item_class: Class\n        :param item_class: Allows you to override the class used\n            to generate the items. This should be a subclass of\n            :class:`boto.dynamodb.item.Item`\n\n        :rtype: generator\n        \"\"\"\n        return self.layer2.scan(self, scan_filter, attributes_to_get,\n                                request_limit, max_results,\n                                exclusive_start_key, item_class=item_class)", "response": "Scan through the table for the specified attributes and return the corresponding items."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves all the language objects for a country.", "response": "def get_all_languages(self, sort='code'):\n    \"\"\"\n    Retrieve all the language objects for a country.  Language objects will be annotated with\n    the country and culturecode attributes when applicable.\n    :param sort: code|name_en|name_native\n    :return:\n    \"\"\"\n    langs = list(self.culturecode_set.all().as_languages())\n    langs.extend(self.language_set.exclude(iso_639_1__in=[x.iso_639_1 for x in langs]))\n    if sort in ['name_en', 'name_native']:\n        langs.sort(key=lambda x: getattr(x, sort))\n    elif sort == 'code':\n        codes = self.languages.split(',')\n\n        def code_sort(x):\n            return codes.index(x.sort_code)\n\n        langs.sort(key=code_sort)\n    else:\n        raise ValueError(\n            'Invalid code option %s.  Valid options are: code, name_en, name_native' % sort)\n    return langs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_by_code(self, code):\n        if any(x in code for x in ('_', '-')):\n            cc = CultureCode.objects.get(code=code.replace('_', '-'))\n            return cc.language\n\n        elif len(code) == 2:\n            return self.get(iso_639_1=code)\n\n        elif len(code) == 3:\n            return self.get(Q(iso_639_2T=code) |\n                            Q(iso_639_2B=code) |\n                            Q(iso_639_3=code))\n\n        raise ValueError(\n            'Code must be either 2, or 3 characters: \"%s\" is %s' % (code, len(code)))", "response": "Retrieve a language object by a code."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_culture_pair(self, code):\n        if not any(x in code for x in ('_', '-')):\n            raise ValueError(\"%s is not a valid culture code\" % code)\n\n        cc = CultureCode.objects.get(code=code.replace('_', '-'))\n        return cc.language, cc.country", "response": "Returns a tuple of the language and country for a given culture code"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a list of languages from a list of codes.", "response": "def filter_by_codes(self, codes, sort='name_en'):\n        \"\"\"\n        Retrieve a list (not queryset) of languages from a list of codes\n        The language objects retrieved by culture code will be annotated with the country and\n        culture code.\n        :param codes: list of strings that can be either iso codes (any of the three) or culture\n        codes.\n        :param sort: str name_en|name_native|sort_code\n        :return: a list of languages\n        \"\"\"\n        lang_codes = []\n        cc_codes = []\n        for code in codes:\n            if any(x in code for x in ('_', '-')):\n                cc_codes.append(code.replace('_', '-'))\n            else:\n                lang_codes.append(code)\n\n        cc_langs = CultureCode.objects.filter(code__in=cc_codes).as_languages()\n\n        qs = self.get_queryset().filter(Q(iso_639_1__in=lang_codes) |\n                                        Q(iso_639_2T__in=lang_codes) |\n                                        Q(iso_639_2B__in=lang_codes) |\n                                        Q(iso_639_3__in=lang_codes))\n        langs = list(qs)\n        langs.extend(cc_langs)\n        langs.sort(key=lambda x: getattr(x, sort))\n        return langs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_languages(self):\n        langs = []\n        for culture_code in self.select_related('language', 'country').all():\n            lang = culture_code.language\n            lang.country = culture_code.country\n            lang.culturecode = culture_code.code\n            langs.append(lang)\n        return langs", "response": "Returns the list of Language objects associated with this queryset of CultureCodes as a list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef channel(self, size=-1):\n        sender, recver = self.router()\n        if size > 0:\n            recver = recver.pipe(self.queue(size))\n        return vanilla.message.Pair(sender, recver.pipe(self.dealer()))", "response": "Creates a new Channel with the given size."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef serialize(self, f):\n        s = self.router()\n\n        @self.spawn\n        def _():\n            for f, a, kw, r in s.recver:\n                try:\n                    r.send(f(*a, **kw))\n                except Exception, e:\n                    r.send(e)\n\n        def _(*a, **kw):\n            r = self.pipe()\n            s.send((f, a, kw, r))\n            return r.recv()\n\n        return _", "response": "Decorator to serialize access to a callable f *\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef state(self, state=vanilla.message.NoState):\n        return vanilla.message.State(self, state=state)", "response": "Returns a State_ pair."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nthrow target to a list of exceptions", "response": "def throw_to(self, target, *a):\n        self.ready.append((getcurrent(), ()))\n        \"\"\"\n        if len(a) == 1 and isinstance(a[0], preserve_exception):\n            return target.throw(a[0].typ, a[0].val, a[0].tb)\n        \"\"\"\n        return target.throw(*a)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef spawn_later(self, ms, f, *a):\n        self.scheduled.add(ms, f, *a)", "response": "Spawns a callable on a new green thread scheduled for ms milliseconds in the future."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sleep(self, ms=1):\n        self.scheduled.add(ms, getcurrent())\n        self.loop.switch()", "response": "Pauses the current green thread for ms milliseconds"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self, directory_path):\n        if self.material:\n            directory_path = os.path.expanduser(directory_path)\n            file_path = os.path.join(directory_path, '%s.pem' % self.name)\n            if os.path.exists(file_path):\n                raise BotoClientError('%s already exists, it will not be overwritten' % file_path)\n            fp = open(file_path, 'wb')\n            fp.write(self.material)\n            fp.close()\n            os.chmod(file_path, 0600)\n            return True\n        else:\n            raise BotoClientError('KeyPair contains no material')", "response": "Save the material of a newly created KeyPair to a local file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncopy this security group to another region.", "response": "def copy_to_region(self, region):\n        \"\"\"\n        Create a new key pair of the same new in another region.\n        Note that the new key pair will use a different ssh\n        cert than the this key pair.  After doing the copy,\n        you will need to save the material associated with the\n        new key pair (use the save method) to a local file.\n\n        :type region: :class:`boto.ec2.regioninfo.RegionInfo`\n        :param region: The region to which this security group will be copied.\n\n        :rtype: :class:`boto.ec2.keypair.KeyPair`\n        :return: The new key pair\n        \"\"\"\n        if region.name == self.region:\n            raise BotoClientError('Unable to copy to the same Region')\n        conn_params = self.connection.get_params()\n        rconn = region.connect(**conn_params)\n        kp = rconn.create_key_pair(self.name)\n        return kp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Inventory(cls):\n        l = ServerSet()\n        rs = cls.find()\n        for server in rs:\n            l.append(server)\n        return l", "response": "Returns a list of Server instances one for each Server object persisted in the db\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_config(self, config):\n        self._config = config\n        self._config.dump_to_sdb(\"botoConfigs\", self.id)", "response": "Set the config for this instance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef attach_volume(self, volume, device=\"/dev/sdp\"):\n        if hasattr(volume, \"id\"):\n            volume_id = volume.id\n        else:\n            volume_id = volume\n        return self.ec2.attach_volume(volume_id=volume_id, instance_id=self.instance_id, device=device)", "response": "Attach an EBS volume to this server"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetaching an EBS volume from this server", "response": "def detach_volume(self, volume):\n        \"\"\"\n        Detach an EBS volume from this server\n\n        :param volume: EBS Volume to detach\n        :type volume: boto.ec2.volume.Volume\n        \"\"\"\n        if hasattr(volume, \"id\"):\n            volume_id = volume.id\n        else:\n            volume_id = volume\n        return self.ec2.detach_volume(volume_id=volume_id, instance_id=self.instance_id)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _save_tracker_uri_to_file(self):\n        if not self.tracker_file_name:\n            return\n        f = None\n        try:\n            f = open(self.tracker_file_name, 'w')\n            f.write(self.tracker_uri)\n        except IOError, e:\n            raise ResumableUploadException(\n                'Couldn\\'t write URI tracker file (%s): %s.\\nThis can happen'\n                'if you\\'re using an incorrectly configured upload tool\\n'\n                '(e.g., gsutil configured to save tracker files to an '\n                'unwritable directory)' %\n                (self.tracker_file_name, e.strerror),\n                ResumableTransferDisposition.ABORT)\n        finally:\n            if f:\n                f.close()", "response": "Saves URI to tracker file if one was passed to constructor."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the tracker URI for the current object.", "response": "def _set_tracker_uri(self, uri):\n        \"\"\"\n        Called when we start a new resumable upload or get a new tracker\n        URI for the upload. Saves URI and resets upload state.\n\n        Raises InvalidUriError if URI is syntactically invalid.\n        \"\"\"\n        parse_result = urlparse.urlparse(uri)\n        if (parse_result.scheme.lower() not in ['http', 'https'] or\n            not parse_result.netloc or not parse_result.query):\n            raise InvalidUriError('Invalid tracker URI (%s)' % uri)\n        qdict = cgi.parse_qs(parse_result.query)\n        if not qdict or not 'upload_id' in qdict:\n            raise InvalidUriError('Invalid tracker URI (%s)' % uri)\n        self.tracker_uri = uri\n        self.tracker_uri_host = parse_result.netloc\n        self.tracker_uri_path = '%s/?%s' % (parse_result.netloc,\n                                            parse_result.query)\n        self.server_has_bytes = 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nquerying server to find out state of given upload.", "response": "def _query_server_state(self, conn, file_length):\n        \"\"\"\n        Queries server to find out state of given upload.\n\n        Note that this method really just makes special case use of the\n        fact that the upload server always returns the current start/end\n        state whenever a PUT doesn't complete.\n\n        Returns HTTP response from sending request.\n\n        Raises ResumableUploadException if problem querying server.\n        \"\"\"\n        # Send an empty PUT so that server replies with this resumable\n        # transfer's state.\n        put_headers = {}\n        put_headers['Content-Range'] = (\n            self._build_content_range_header('*', file_length))\n        put_headers['Content-Length'] = '0'\n        return AWSAuthConnection.make_request(conn, 'PUT',\n                                              path=self.tracker_uri_path,\n                                              auth_path=self.tracker_uri_path,\n                                              headers=put_headers,\n                                              host=self.tracker_uri_host)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _query_server_pos(self, conn, file_length):\n        resp = self._query_server_state(conn, file_length)\n        if resp.status == 200:\n            return (0, file_length)  # Completed upload.\n        if resp.status != 308:\n            # This means the server didn't have any state for the given\n            # upload ID, which can happen (for example) if the caller saved\n            # the tracker URI to a file and then tried to restart the transfer\n            # after that upload ID has gone stale. In that case we need to\n            # start a new transfer (and the caller will then save the new\n            # tracker URI to the tracker file).\n            raise ResumableUploadException(\n                'Got non-308 response (%s) from server state query' %\n                resp.status, ResumableTransferDisposition.START_OVER)\n        got_valid_response = False\n        range_spec = resp.getheader('range')\n        if range_spec:\n            # Parse 'bytes=<from>-<to>' range_spec.\n            m = re.search('bytes=(\\d+)-(\\d+)', range_spec)\n            if m:\n                server_start = long(m.group(1))\n                server_end = long(m.group(2))\n                got_valid_response = True\n        else:\n            # No Range header, which means the server does not yet have\n            # any bytes. Note that the Range header uses inclusive 'from'\n            # and 'to' values. Since Range 0-0 would mean that the server\n            # has byte 0, omitting the Range header is used to indicate that\n            # the server doesn't have any bytes.\n            return self.SERVER_HAS_NOTHING\n        if not got_valid_response:\n            raise ResumableUploadException(\n                'Couldn\\'t parse upload server state query response (%s)' %\n                str(resp.getheaders()), ResumableTransferDisposition.START_OVER)\n        if conn.debug >= 1:\n            print 'Server has: Range: %d - %d.' % (server_start, server_end)\n        return (server_start, server_end)", "response": "Queries server to find out what bytes it currently has and returns the start and end of the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts a new resumable upload.", "response": "def _start_new_resumable_upload(self, key, headers=None):\n        \"\"\"\n        Starts a new resumable upload.\n\n        Raises ResumableUploadException if any errors occur.\n        \"\"\"\n        conn = key.bucket.connection\n        if conn.debug >= 1:\n            print 'Starting new resumable upload.'\n        self.server_has_bytes = 0\n\n        # Start a new resumable upload by sending a POST request with an\n        # empty body and the \"X-Goog-Resumable: start\" header. Include any\n        # caller-provided headers (e.g., Content-Type) EXCEPT Content-Length\n        # (and raise an exception if they tried to pass one, since it's\n        # a semantic error to specify it at this point, and if we were to\n        # include one now it would cause the server to expect that many\n        # bytes; the POST doesn't include the actual file bytes  We set\n        # the Content-Length in the subsequent PUT, based on the uploaded\n        # file size.\n        post_headers = {}\n        for k in headers:\n            if k.lower() == 'content-length':\n                raise ResumableUploadException(\n                    'Attempt to specify Content-Length header (disallowed)',\n                    ResumableTransferDisposition.ABORT)\n            post_headers[k] = headers[k]\n        post_headers[conn.provider.resumable_upload_header] = 'start'\n\n        resp = conn.make_request(\n            'POST', key.bucket.name, key.name, post_headers)\n        # Get tracker URI from response 'Location' header.\n        body = resp.read()\n\n        # Check for various status conditions.\n        if resp.status in [500, 503]:\n            # Retry status 500 and 503 errors after a delay.\n            raise ResumableUploadException(\n                'Got status %d from attempt to start resumable upload. '\n                'Will wait/retry' % resp.status,\n                ResumableTransferDisposition.WAIT_BEFORE_RETRY)\n        elif resp.status != 200 and resp.status != 201:\n            raise ResumableUploadException(\n                'Got status %d from attempt to start resumable upload. '\n                'Aborting' % resp.status,\n                ResumableTransferDisposition.ABORT)\n\n        # Else we got 200 or 201 response code, indicating the resumable\n        # upload was created.\n        tracker_uri = resp.getheader('Location')\n        if not tracker_uri:\n            raise ResumableUploadException(\n                'No resumable tracker URI found in resumable initiation '\n                'POST response (%s)' % body,\n                ResumableTransferDisposition.WAIT_BEFORE_RETRY)\n        self._set_tracker_uri(tracker_uri)\n        self._save_tracker_uri_to_file()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _upload_file_bytes(self, conn, http_conn, fp, file_length,\n                           total_bytes_uploaded, cb, num_cb):\n        \"\"\"\n        Makes one attempt to upload file bytes, using an existing resumable\n        upload connection.\n\n        Returns etag from server upon success.\n\n        Raises ResumableUploadException if any problems occur.\n        \"\"\"\n        buf = fp.read(self.BUFFER_SIZE)\n        if cb:\n            if num_cb > 2:\n                cb_count = file_length / self.BUFFER_SIZE / (num_cb-2)\n            elif num_cb < 0:\n                cb_count = -1\n            else:\n                cb_count = 0\n            i = 0\n            cb(total_bytes_uploaded, file_length)\n\n        # Build resumable upload headers for the transfer. Don't send a\n        # Content-Range header if the file is 0 bytes long, because the\n        # resumable upload protocol uses an *inclusive* end-range (so, sending\n        # 'bytes 0-0/1' would actually mean you're sending a 1-byte file).\n        put_headers = {}\n        if file_length:\n            range_header = self._build_content_range_header(\n                '%d-%d' % (total_bytes_uploaded, file_length - 1),\n                file_length)\n            put_headers['Content-Range'] = range_header\n        # Set Content-Length to the total bytes we'll send with this PUT.\n        put_headers['Content-Length'] = str(file_length - total_bytes_uploaded)\n        http_request = AWSAuthConnection.build_base_http_request(\n            conn, 'PUT', path=self.tracker_uri_path, auth_path=None,\n            headers=put_headers, host=self.tracker_uri_host)\n        http_conn.putrequest('PUT', http_request.path)\n        for k in put_headers:\n            http_conn.putheader(k, put_headers[k])\n        http_conn.endheaders()\n\n        # Turn off debug on http connection so upload content isn't included\n        # in debug stream.\n        http_conn.set_debuglevel(0)\n        while buf:\n            http_conn.send(buf)\n            total_bytes_uploaded += len(buf)\n            if cb:\n                i += 1\n                if i == cb_count or cb_count == -1:\n                    cb(total_bytes_uploaded, file_length)\n                    i = 0\n            buf = fp.read(self.BUFFER_SIZE)\n        if cb:\n            cb(total_bytes_uploaded, file_length)\n        if total_bytes_uploaded != file_length:\n            # Abort (and delete the tracker file) so if the user retries\n            # they'll start a new resumable upload rather than potentially\n            # attempting to pick back up later where we left off.\n            raise ResumableUploadException(\n                'File changed during upload: EOF at %d bytes of %d byte file.' %\n                (total_bytes_uploaded, file_length),\n                ResumableTransferDisposition.ABORT)\n        resp = http_conn.getresponse()\n        body = resp.read()\n        # Restore http connection debug level.\n        http_conn.set_debuglevel(conn.debug)\n\n        if resp.status == 200:\n            return resp.getheader('etag')  # Success\n        # Retry timeout (408) and status 500 and 503 errors after a delay.\n        elif resp.status in [408, 500, 503]:\n            disposition = ResumableTransferDisposition.WAIT_BEFORE_RETRY\n        else:\n            # Catch all for any other error codes.\n            disposition = ResumableTransferDisposition.ABORT\n        raise ResumableUploadException('Got response code %d while attempting '\n                                       'upload (%s)' %\n                                       (resp.status, resp.reason), disposition)", "response": "Uploads a file to the server using a resumable upload protocol."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nattempts a resumable upload.", "response": "def _attempt_resumable_upload(self, key, fp, file_length, headers, cb,\n                                  num_cb):\n        \"\"\"\n        Attempts a resumable upload.\n\n        Returns etag from server upon success.\n\n        Raises ResumableUploadException if any problems occur.\n        \"\"\"\n        (server_start, server_end) = self.SERVER_HAS_NOTHING\n        conn = key.bucket.connection\n        if self.tracker_uri:\n            # Try to resume existing resumable upload.\n            try:\n                (server_start, server_end) = (\n                    self._query_server_pos(conn, file_length))\n                self.server_has_bytes = server_start\n                key=key\n                if conn.debug >= 1:\n                    print 'Resuming transfer.'\n            except ResumableUploadException, e:\n                if conn.debug >= 1:\n                    print 'Unable to resume transfer (%s).' % e.message\n                self._start_new_resumable_upload(key, headers)\n        else:\n            self._start_new_resumable_upload(key, headers)\n\n        # upload_start_point allows the code that instantiated the\n        # ResumableUploadHandler to find out the point from which it started\n        # uploading (e.g., so it can correctly compute throughput).\n        if self.upload_start_point is None:\n            self.upload_start_point = server_end\n\n        if server_end == file_length:\n            # Boundary condition: complete file was already uploaded (e.g.,\n            # user interrupted a previous upload attempt after the upload\n            # completed but before the gsutil tracker file was deleted). Set\n            # total_bytes_uploaded to server_end so we'll attempt to upload\n            # no more bytes but will still make final HTTP request and get\n            # back the response (which contains the etag we need to compare\n            # at the end).\n            total_bytes_uploaded = server_end\n        else:\n            total_bytes_uploaded = server_end + 1\n        fp.seek(total_bytes_uploaded)\n        conn = key.bucket.connection\n\n        # Get a new HTTP connection (vs conn.get_http_connection(), which reuses\n        # pool connections) because httplib requires a new HTTP connection per\n        # transaction. (Without this, calling http_conn.getresponse() would get\n        # \"ResponseNotReady\".)\n        http_conn = conn.new_http_connection(self.tracker_uri_host,\n                                             conn.is_secure)\n        http_conn.set_debuglevel(conn.debug)\n\n        # Make sure to close http_conn at end so if a local file read\n        # failure occurs partway through server will terminate current upload\n        # and can report that progress on next attempt.\n        try:\n            return self._upload_file_bytes(conn, http_conn, fp, file_length,\n                                           total_bytes_uploaded, cb, num_cb)\n        except (ResumableUploadException, socket.error):\n            resp = self._query_server_state(conn, file_length)\n            if resp.status == 400:\n                raise ResumableUploadException('Got 400 response from server '\n                    'state query after failed resumable upload attempt. This '\n                    'can happen for various reasons, including specifying an '\n                    'invalid request (e.g., an invalid canned ACL) or if the '\n                    'file size changed between upload attempts',\n                    ResumableTransferDisposition.ABORT)\n            else:\n                raise\n        finally:\n            http_conn.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_final_md5(self, key, etag):\n        if key.bucket.connection.debug >= 1:\n            print 'Checking md5 against etag.'\n        if key.md5 != etag.strip('\"\\''):\n            # Call key.open_read() before attempting to delete the\n            # (incorrect-content) key, so we perform that request on a\n            # different HTTP connection. This is neededb because httplib\n            # will return a \"Response not ready\" error if you try to perform\n            # a second transaction on the connection.\n            key.open_read()\n            key.close()\n            key.delete()\n            raise ResumableUploadException(\n                'File changed during upload: md5 signature doesn\\'t match etag '\n                '(incorrect uploaded object deleted)',\n                ResumableTransferDisposition.ABORT)", "response": "Checks that the md5 of the a\n            object matches the etag. If it does not match the ETag raises ResumableUploadException."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_file(self, key, fp, headers, cb=None, num_cb=10):\n\n        if not headers:\n            headers = {}\n\n        fp.seek(0, os.SEEK_END)\n        file_length = fp.tell()\n        fp.seek(0)\n        debug = key.bucket.connection.debug\n\n        # Use num-retries from constructor if one was provided; else check\n        # for a value specified in the boto config file; else default to 5.\n        if self.num_retries is None:\n            self.num_retries = config.getint('Boto', 'num_retries', 5)\n        progress_less_iterations = 0\n\n        while True:  # Retry as long as we're making progress.\n            server_had_bytes_before_attempt = self.server_has_bytes\n            try:\n                etag = self._attempt_resumable_upload(key, fp, file_length,\n                                                      headers, cb, num_cb)\n                # Upload succceded, so remove the tracker file (if have one).\n                self._remove_tracker_file()\n                self._check_final_md5(key, etag)\n                if debug >= 1:\n                    print 'Resumable upload complete.'\n                return\n            except self.RETRYABLE_EXCEPTIONS, e:\n                if debug >= 1:\n                    print('Caught exception (%s)' % e.__repr__())\n                if isinstance(e, IOError) and e.errno == errno.EPIPE:\n                    # Broken pipe error causes httplib to immediately\n                    # close the socket (http://bugs.python.org/issue5542),\n                    # so we need to close the connection before we resume\n                    # the upload (which will cause a new connection to be\n                    # opened the next time an HTTP request is sent).\n                    key.bucket.connection.connection.close()\n            except ResumableUploadException, e:\n                if (e.disposition ==\n                    ResumableTransferDisposition.ABORT_CUR_PROCESS):\n                    if debug >= 1:\n                        print('Caught non-retryable ResumableUploadException '\n                              '(%s); aborting but retaining tracker file' %\n                              e.message)\n                    raise\n                elif (e.disposition ==\n                    ResumableTransferDisposition.ABORT):\n                    if debug >= 1:\n                        print('Caught non-retryable ResumableUploadException '\n                              '(%s); aborting and removing tracker file' %\n                              e.message)\n                    self._remove_tracker_file()\n                    raise\n                else:\n                    if debug >= 1:\n                        print('Caught ResumableUploadException (%s) - will '\n                              'retry' % e.message)\n\n            # At this point we had a re-tryable failure; see if made progress.\n            if self.server_has_bytes > server_had_bytes_before_attempt:\n                progress_less_iterations = 0\n            else:\n                progress_less_iterations += 1\n\n            if progress_less_iterations > self.num_retries:\n                # Don't retry any longer in the current process.\n                raise ResumableUploadException(\n                    'Too many resumable upload attempts failed without '\n                    'progress. You might try this upload again later',\n                    ResumableTransferDisposition.ABORT_CUR_PROCESS)\n\n            # Use binary exponential backoff to desynchronize client requests\n            sleep_time_secs = random.random() * (2**progress_less_iterations)\n            if debug >= 1:\n                print ('Got retryable failure (%d progress-less in a row).\\n'\n                       'Sleeping %3.1f seconds before re-trying' %\n                       (progress_less_iterations, sleep_time_secs))\n            time.sleep(sleep_time_secs)", "response": "Uploads a file to a key into a bucket on GS using GS resumable upload protocol."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the configuration of the current object of the Distribution.", "response": "def update(self, enabled=None, cnames=None, comment=None):\n        \"\"\"\n        Update the configuration of the Distribution.  The only values\n        of the DistributionConfig that can be directly updated are:\n\n         * CNAMES\n         * Comment\n         * Whether the Distribution is enabled or not\n\n        Any changes to the ``trusted_signers`` or ``origin`` properties of\n        this distribution's current config object will also be included in\n        the update. Therefore, to set the origin access identity for this\n        distribution, set ``Distribution.config.origin.origin_access_identity``\n        before calling this update method.\n\n        :type enabled: bool\n        :param enabled: Whether the Distribution is active or not.\n\n        :type cnames: list of str\n        :param cnames: The DNS CNAME's associated with this\n                        Distribution.  Maximum of 10 values.\n\n        :type comment: str or unicode\n        :param comment: The comment associated with the Distribution.\n\n        \"\"\"\n        new_config = DistributionConfig(self.connection, self.config.origin,\n                                        self.config.enabled, self.config.caller_reference,\n                                        self.config.cnames, self.config.comment,\n                                        self.config.trusted_signers,\n                                        self.config.default_root_object)\n        if enabled != None:\n            new_config.enabled = enabled\n        if cnames != None:\n            new_config.cnames = cnames\n        if comment != None:\n            new_config.comment = comment\n        self.etag = self.connection.set_distribution_config(self.id, self.etag, new_config)\n        self.config = new_config\n        self._object_class = Object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_objects(self):\n        bucket = self._get_bucket()\n        objs = []\n        for key in bucket:\n            objs.append(key)\n        return objs", "response": "Return a list of all content objects in this distribution."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the permissions for the given object to the appropriate S3 ACL grants for the given Distribution.", "response": "def set_permissions(self, object, replace=False):\n        \"\"\"\n        Sets the S3 ACL grants for the given object to the appropriate\n        value based on the type of Distribution.  If the Distribution\n        is serving private content the ACL will be set to include the\n        Origin Access Identity associated with the Distribution.  If\n        the Distribution is serving public content the content will\n        be set up with \"public-read\".\n\n        :type object: :class:`boto.cloudfront.object.Object`\n        :param enabled: The Object whose ACL is being set\n\n        :type replace: bool\n        :param replace: If False, the Origin Access Identity will be\n                        appended to the existing ACL for the object.\n                        If True, the ACL for the object will be\n                        completely replaced with one that grants\n                        READ permission to the Origin Access Identity.\n\n        \"\"\"\n        if isinstance(self.config.origin, S3Origin):\n            if self.config.origin.origin_access_identity:\n                id = self.config.origin.origin_access_identity.split('/')[-1]\n                oai = self.connection.get_origin_access_identity_info(id)\n                policy = object.get_acl()\n                if replace:\n                    policy.acl = ACL()\n                policy.acl.add_user_grant('READ', oai.s3_user_id)\n                object.set_acl(policy)\n            else:\n                object.set_canned_acl('public-read')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_permissions_all(self, replace=False):\n        bucket = self._get_bucket()\n        for key in bucket:\n            self.set_permissions(key, replace)", "response": "Sets the S3 ACL grants for all objects in the Distribution."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a new content object to the Distribution.", "response": "def add_object(self, name, content, headers=None, replace=True):\n        \"\"\"\n        Adds a new content object to the Distribution.  The content\n        for the object will be copied to a new Key in the S3 Bucket\n        and the permissions will be set appropriately for the type\n        of Distribution.\n\n        :type name: str or unicode\n        :param name: The name or key of the new object.\n\n        :type content: file-like object\n        :param content: A file-like object that contains the content\n                        for the new object.\n\n        :type headers: dict\n        :param headers: A dictionary containing additional headers\n                        you would like associated with the new\n                        object in S3.\n\n        :rtype: :class:`boto.cloudfront.object.Object`\n        :return: The newly created object.\n        \"\"\"\n        if self.config.origin.origin_access_identity:\n            policy = 'private'\n        else:\n            policy = 'public-read'\n        bucket = self._get_bucket()\n        object = bucket.new_key(name)\n        object.set_contents_from_file(content, headers=headers, policy=policy)\n        if self.config.origin.origin_access_identity:\n            self.set_permissions(object, replace)\n        return object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_signed_url(self, url, keypair_id,\n                          expire_time=None, valid_after_time=None,\n                          ip_address=None, policy_url=None,\n                          private_key_file=None, private_key_string=None):\n        \"\"\"\n        Creates a signed CloudFront URL that is only valid within the specified\n        parameters.\n\n        :type url: str\n        :param url: The URL of the protected object.\n\n        :type keypair_id: str\n        :param keypair_id: The keypair ID of the Amazon KeyPair used to sign\n            theURL.  This ID MUST correspond to the private key\n            specified with private_key_file or private_key_string.\n\n        :type expire_time: int\n        :param expire_time: The expiry time of the URL. If provided, the URL\n            will expire after the time has passed. If not provided the URL will\n            never expire. Format is a unix epoch.\n            Use time.time() + duration_in_sec.\n\n        :type valid_after_time: int\n        :param valid_after_time: If provided, the URL will not be valid until\n            after valid_after_time. Format is a unix epoch.\n            Use time.time() + secs_until_valid.\n\n        :type ip_address: str\n        :param ip_address: If provided, only allows access from the specified\n            IP address.  Use '192.168.0.10' for a single IP or\n            use '192.168.0.0/24' CIDR notation for a subnet.\n\n        :type policy_url: str\n        :param policy_url: If provided, allows the signature to contain\n            wildcard globs in the URL.  For example, you could\n            provide: 'http://example.com/media/\\*' and the policy\n            and signature would allow access to all contents of\n            the media subdirectory. If not specified, only\n            allow access to the exact url provided in 'url'.\n\n        :type private_key_file: str or file object.\n        :param private_key_file: If provided, contains the filename of the\n            private key file used for signing or an open\n            file object containing the private key\n            contents.  Only one of private_key_file or\n            private_key_string can be provided.\n\n        :type private_key_string: str\n        :param private_key_string: If provided, contains the private key string\n            used for signing. Only one of private_key_file or\n            private_key_string can be provided.\n\n        :rtype: str\n        :return: The signed URL.\n        \"\"\"\n        # Get the required parameters\n        params = self._create_signing_params(\n                     url=url, keypair_id=keypair_id, expire_time=expire_time,\n                     valid_after_time=valid_after_time, ip_address=ip_address,\n                     policy_url=policy_url, private_key_file=private_key_file,\n                     private_key_string=private_key_string)\n\n        #combine these into a full url\n        if \"?\" in url:\n            sep = \"&\"\n        else:\n            sep = \"?\"\n        signed_url_params = []\n        for key in [\"Expires\", \"Policy\", \"Signature\", \"Key-Pair-Id\"]:\n            if key in params:\n                param = \"%s=%s\" % (key, params[key])\n                signed_url_params.append(param)\n        signed_url = url + sep + \"&\".join(signed_url_params)\n        return signed_url", "response": "Creates a signed CloudFront URL that is only valid within the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the parameters for a signed URL.", "response": "def _create_signing_params(self, url, keypair_id,\n                          expire_time=None, valid_after_time=None,\n                          ip_address=None, policy_url=None,\n                          private_key_file=None, private_key_string=None):\n        \"\"\"\n        Creates the required URL parameters for a signed URL.\n        \"\"\"\n        params = {}\n        # Check if we can use a canned policy\n        if expire_time and not valid_after_time and not ip_address and not policy_url:\n            # we manually construct this policy string to ensure formatting\n            # matches signature\n            policy = self._canned_policy(url, expire_time)\n            params[\"Expires\"] = str(expire_time)\n        else:\n            # If no policy_url is specified, default to the full url.\n            if policy_url is None:\n                policy_url = url\n            # Can't use canned policy\n            policy = self._custom_policy(policy_url, expires=expire_time,\n                                         valid_after=valid_after_time,\n                                         ip_address=ip_address)\n\n            encoded_policy = self._url_base64_encode(policy)\n            params[\"Policy\"] = encoded_policy\n        #sign the policy\n        signature = self._sign_string(policy, private_key_file, private_key_string)\n        #now base64 encode the signature (URL safe as well)\n        encoded_signature = self._url_base64_encode(signature)\n        params[\"Signature\"] = encoded_signature\n        params[\"Key-Pair-Id\"] = keypair_id\n        return params"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _custom_policy(resource, expires=None, valid_after=None, ip_address=None):\n        condition = {}\n        if expires:\n            condition[\"DateLessThan\"] = {\"AWS:EpochTime\": expires}\n        if valid_after:\n            condition[\"DateGreaterThan\"] = {\"AWS:EpochTime\": valid_after}\n        if ip_address:\n            if '/' not in ip_address:\n                ip_address += \"/32\"\n            condition[\"IpAddress\"] = {\"AWS:SourceIp\": ip_address}\n        policy = {\"Statement\": [{\n                     \"Resource\": resource,\n                     \"Condition\": condition}]}\n        return json.dumps(policy, separators=(\",\", \":\"))", "response": "Creates a custom policy string based on the supplied parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsigns a string for use with Amazon CloudFront.", "response": "def _sign_string(message, private_key_file=None, private_key_string=None):\n        \"\"\"\n        Signs a string for use with Amazon CloudFront.  Requires the M2Crypto\n        library be installed.\n        \"\"\"\n        try:\n            from M2Crypto import EVP\n        except ImportError:\n            raise NotImplementedError(\"Boto depends on the python M2Crypto \"\n                                      \"library to generate signed URLs for \"\n                                      \"CloudFront\")\n        # Make sure only one of private_key_file and private_key_string is set\n        if private_key_file and private_key_string:\n            raise ValueError(\"Only specify the private_key_file or the private_key_string not both\")\n        if not private_key_file and not private_key_string:\n            raise ValueError(\"You must specify one of private_key_file or private_key_string\")\n        # if private_key_file is a file object read the key string from there\n        if isinstance(private_key_file, file):\n            private_key_string = private_key_file.read()\n        # Now load key and calculate signature\n        if private_key_string:\n            key = EVP.load_key_string(private_key_string)\n        else:\n            key = EVP.load_key(private_key_file)\n        key.reset_context(md='sha1')\n        key.sign_init()\n        key.sign_update(str(message))\n        signature = key.sign_final()\n        return signature"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, enabled=None, cnames=None, comment=None):\n        new_config = StreamingDistributionConfig(self.connection,\n                                                 self.config.origin,\n                                                 self.config.enabled,\n                                                 self.config.caller_reference,\n                                                 self.config.cnames,\n                                                 self.config.comment,\n                                                 self.config.trusted_signers)\n        if enabled != None:\n            new_config.enabled = enabled\n        if cnames != None:\n            new_config.cnames = cnames\n        if comment != None:\n            new_config.comment = comment\n        self.etag = self.connection.set_streaming_distribution_config(self.id,\n                                                                      self.etag,\n                                                                      new_config)\n        self.config = new_config\n        self._object_class = StreamingObject", "response": "Update the configuration of the StreamingDistribution."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extract_feature(self, image, layer):\n\n        img = image.astype(np.float32)\n        # Substracting Image mean value\n        img -= np.array((104.00698793, 116.66876762, 122.67891434))\n\n        # make dims C x H x W for Caffe\n        img = img.transpose((2, 0, 1))\n        in_img = img[np.newaxis, :, :, :]\n\n        self.net.blobs['data'].reshape(*in_img.shape)\n\n        data_feat = self.net.forward_all(data=in_img, blobs=[layer])\n\n        feature = data_feat[layer][0]\n\n        # feature = (feature - feature.mean()) / feature.std()\n        # feature /= np.linalg.norm(feature)\n        return feature", "response": "Passes image to a deepnet and extracts features from the specified layer name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the value of a field from a content model instance.", "response": "def _get_field(instance, field):\n    \"\"\"\n    This is here to support ``MarkupField``. It's a little ugly to\n    have that support baked-in; other option would be to have a\n    generic way (via setting?) to override how attribute values are\n    fetched from content model instances.\n\n    \"\"\"\n    \n    value = getattr(instance, field)\n    if hasattr(value, 'raw'):\n        value = value.raw\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the content model with the contents of the file upload.", "response": "def _update_content(sender, instance, created=None, **kwargs):\n    \"\"\"\n    Re-save any content models referencing the just-modified\n    ``FileUpload``.\n\n    We don't do anything special to the content model, we just re-save\n    it. If signals are in use, we assume that the content model has\n    incorporated ``render_uploads`` into some kind of rendering that\n    happens automatically at save-time.\n\n    \"\"\"\n    if created: # a brand new FileUpload won't be referenced\n        return\n    for ref in FileUploadReference.objects.filter(upload=instance):\n        try:\n            obj = ref.content_object\n            if obj:\n                obj.save()\n        except AttributeError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_params(self):\n        param_names = ['aws_access_key_id', 'aws_secret_access_key',\n                       'is_secure', 'port', 'proxy', 'proxy_port',\n                       'proxy_user', 'proxy_pass',\n                       'debug', 'https_connection_factory']\n        params = {}\n        for name in param_names:\n            params[name] = getattr(self, name)\n        return params", "response": "Returns a dictionary containing the value of all of the keyword\nAttributeNames arguments passed when constructing this connection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_all_images(self, image_ids=None, owners=None,\n                       executable_by=None, filters=None):\n        \"\"\"\n        Retrieve all the EC2 images available on your account.\n\n        :type image_ids: list\n        :param image_ids: A list of strings with the image IDs wanted\n\n        :type owners: list\n        :param owners: A list of owner IDs\n\n        :type executable_by: list\n        :param executable_by: Returns AMIs for which the specified\n                              user ID has explicit launch permissions\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n                        the results returned.  Filters are provided\n                        in the form of a dictionary consisting of\n                        filter names as the key and filter values\n                        as the value.  The set of allowable filter\n                        names/values is dependent on the request\n                        being performed.  Check the EC2 API guide\n                        for details.\n\n        :rtype: list\n        :return: A list of :class:`boto.ec2.image.Image`\n        \"\"\"\n        params = {}\n        if image_ids:\n            self.build_list_params(params, image_ids, 'ImageId')\n        if owners:\n            self.build_list_params(params, owners, 'Owner')\n        if executable_by:\n            self.build_list_params(params, executable_by, 'ExecutableBy')\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeImages', params,\n                             [('item', Image)], verb='POST')", "response": "Retrieve all the EC2 images available on your account."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_kernels(self, kernel_ids=None, owners=None):\n        params = {}\n        if kernel_ids:\n            self.build_list_params(params, kernel_ids, 'ImageId')\n        if owners:\n            self.build_list_params(params, owners, 'Owner')\n        filter = {'image-type' : 'kernel'}\n        self.build_filter_params(params, filter)\n        return self.get_list('DescribeImages', params,\n                             [('item', Image)], verb='POST')", "response": "Retrieve all the EC2 kernels available on your account."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve all the EC2 ramdisks available on your account.", "response": "def get_all_ramdisks(self, ramdisk_ids=None, owners=None):\n        \"\"\"\n        Retrieve all the EC2 ramdisks available on your account.\n        Constructs a filter to allow the processing to happen server side.\n\n        :type ramdisk_ids: list\n        :param ramdisk_ids: A list of strings with the image IDs wanted\n\n        :type owners: list\n        :param owners: A list of owner IDs\n\n        :rtype: list\n        :return: A list of :class:`boto.ec2.image.Image`\n        \"\"\"\n        params = {}\n        if ramdisk_ids:\n            self.build_list_params(params, ramdisk_ids, 'ImageId')\n        if owners:\n            self.build_list_params(params, owners, 'Owner')\n        filter = {'image-type' : 'ramdisk'}\n        self.build_filter_params(params, filter)\n        return self.get_list('DescribeImages', params,\n                             [('item', Image)], verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_image(self, name=None, description=None, image_location=None,\n                       architecture=None, kernel_id=None, ramdisk_id=None,\n                       root_device_name=None, block_device_map=None):\n        \"\"\"\n        Register an image.\n\n        :type name: string\n        :param name: The name of the AMI.  Valid only for EBS-based images.\n\n        :type description: string\n        :param description: The description of the AMI.\n\n        :type image_location: string\n        :param image_location: Full path to your AMI manifest in\n                               Amazon S3 storage.\n                               Only used for S3-based AMI's.\n\n        :type architecture: string\n        :param architecture: The architecture of the AMI.  Valid choices are:\n                             i386 | x86_64\n\n        :type kernel_id: string\n        :param kernel_id: The ID of the kernel with which to launch\n                          the instances\n\n        :type root_device_name: string\n        :param root_device_name: The root device name (e.g. /dev/sdh)\n\n        :type block_device_map: :class:`boto.ec2.blockdevicemapping.BlockDeviceMapping`\n        :param block_device_map: A BlockDeviceMapping data structure\n                                 describing the EBS volumes associated\n                                 with the Image.\n\n        :rtype: string\n        :return: The new image id\n        \"\"\"\n        params = {}\n        if name:\n            params['Name'] = name\n        if description:\n            params['Description'] = description\n        if architecture:\n            params['Architecture'] = architecture\n        if kernel_id:\n            params['KernelId'] = kernel_id\n        if ramdisk_id:\n            params['RamdiskId'] = ramdisk_id\n        if image_location:\n            params['ImageLocation'] = image_location\n        if root_device_name:\n            params['RootDeviceName'] = root_device_name\n        if block_device_map:\n            block_device_map.build_list_params(params)\n        rs = self.get_object('RegisterImage', params, ResultSet, verb='POST')\n        image_id = getattr(rs, 'imageId', None)\n        return image_id", "response": "Register an image.\n\n        :type name: string\n        :param name: The name of the AMI.  Valid only for EBS-based images.\n\n        :type description: string\n        :param description: The description of the AMI.\n\n        :type image_location: string\n        :param image_location: Full path to your AMI manifest in\n                               Amazon S3 storage.\n                               Only used for S3-based AMI's.\n\n        :type architecture: string\n        :param architecture: The architecture of the AMI.  Valid choices are:\n                             i386 | x86_64\n\n        :type kernel_id: string\n        :param kernel_id: The ID of the kernel with which to launch\n                          the instances\n\n        :type root_device_name: string\n        :param root_device_name: The root device name (e.g. /dev/sdh)\n\n        :type block_device_map: :class:`boto.ec2.blockdevicemapping.BlockDeviceMapping`\n        :param block_device_map: A BlockDeviceMapping data structure\n                                 describing the EBS volumes associated\n                                 with the Image.\n\n        :rtype: string\n        :return: The new image id"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_image(self, instance_id, name,\n                     description=None, no_reboot=False):\n        \"\"\"\n        Will create an AMI from the instance in the running or stopped\n        state.\n\n        :type instance_id: string\n        :param instance_id: the ID of the instance to image.\n\n        :type name: string\n        :param name: The name of the new image\n\n        :type description: string\n        :param description: An optional human-readable string describing\n                            the contents and purpose of the AMI.\n\n        :type no_reboot: bool\n        :param no_reboot: An optional flag indicating that the bundling process\n                          should not attempt to shutdown the instance before\n                          bundling.  If this flag is True, the responsibility\n                          of maintaining file system integrity is left to the\n                          owner of the instance.\n\n        :rtype: string\n        :return: The new image id\n        \"\"\"\n        params = {'InstanceId' : instance_id,\n                  'Name' : name}\n        if description:\n            params['Description'] = description\n        if no_reboot:\n            params['NoReboot'] = 'true'\n        img = self.get_object('CreateImage', params, Image, verb='POST')\n        return img.id", "response": "Create an image from an instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget an attribute from an image.", "response": "def get_image_attribute(self, image_id, attribute='launchPermission'):\n        \"\"\"\n        Gets an attribute from an image.\n\n        :type image_id: string\n        :param image_id: The Amazon image id for which you want info about\n\n        :type attribute: string\n        :param attribute: The attribute you need information about.\n                          Valid choices are:\n                          * launchPermission\n                          * productCodes\n                          * blockDeviceMapping\n\n        :rtype: :class:`boto.ec2.image.ImageAttribute`\n        :return: An ImageAttribute object representing the value of the\n                 attribute requested\n        \"\"\"\n        params = {'ImageId' : image_id,\n                  'Attribute' : attribute}\n        return self.get_object('DescribeImageAttribute', params,\n                               ImageAttribute, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmodify an attribute of an image.", "response": "def modify_image_attribute(self, image_id, attribute='launchPermission',\n                               operation='add', user_ids=None, groups=None,\n                               product_codes=None):\n        \"\"\"\n        Changes an attribute of an image.\n\n        :type image_id: string\n        :param image_id: The image id you wish to change\n\n        :type attribute: string\n        :param attribute: The attribute you wish to change\n\n        :type operation: string\n        :param operation: Either add or remove (this is required for changing\n                          launchPermissions)\n\n        :type user_ids: list\n        :param user_ids: The Amazon IDs of users to add/remove attributes\n\n        :type groups: list\n        :param groups: The groups to add/remove attributes\n\n        :type product_codes: list\n        :param product_codes: Amazon DevPay product code. Currently only one\n                              product code can be associated with an AMI. Once\n                              set, the product code cannot be changed or reset.\n        \"\"\"\n        params = {'ImageId' : image_id,\n                  'Attribute' : attribute,\n                  'OperationType' : operation}\n        if user_ids:\n            self.build_list_params(params, user_ids, 'UserId')\n        if groups:\n            self.build_list_params(params, groups, 'UserGroup')\n        if product_codes:\n            self.build_list_params(params, product_codes, 'ProductCode')\n        return self.get_status('ModifyImageAttribute', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresetting an attribute of an AMI to its default value.", "response": "def reset_image_attribute(self, image_id, attribute='launchPermission'):\n        \"\"\"\n        Resets an attribute of an AMI to its default value.\n\n        :type image_id: string\n        :param image_id: ID of the AMI for which an attribute will be described\n\n        :type attribute: string\n        :param attribute: The attribute to reset\n\n        :rtype: bool\n        :return: Whether the operation succeeded or not\n        \"\"\"\n        params = {'ImageId' : image_id,\n                  'Attribute' : attribute}\n        return self.get_status('ResetImageAttribute', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve all the instances associated with your account.", "response": "def get_all_instances(self, instance_ids=None, filters=None):\n        \"\"\"\n        Retrieve all the instances associated with your account.\n\n        :type instance_ids: list\n        :param instance_ids: A list of strings of instance IDs\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n                        the results returned.  Filters are provided\n                        in the form of a dictionary consisting of\n                        filter names as the key and filter values\n                        as the value.  The set of allowable filter\n                        names/values is dependent on the request\n                        being performed.  Check the EC2 API guide\n                        for details.\n\n        :rtype: list\n        :return: A list of  :class:`boto.ec2.instance.Reservation`\n        \"\"\"\n        params = {}\n        if instance_ids:\n            self.build_list_params(params, instance_ids, 'InstanceId')\n        if filters:\n            if 'group-id' in filters:\n                gid = filters.get('group-id')\n                if not gid.startswith('sg-') or len(gid) != 11:\n                    warnings.warn(\n                        \"The group-id filter now requires a security group \"\n                        \"identifier (sg-*) instead of a group name. To filter \"\n                        \"by group name use the 'group-name' filter instead.\",\n                        UserWarning)\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeInstances', params,\n                             [('item', Reservation)], verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_all_instance_status(self, instance_ids=None,\n                                max_results=None, next_token=None,\n                                filters=None):\n        \"\"\"\n        Retrieve all the instances in your account scheduled for maintenance.\n\n        :type instance_ids: list\n        :param instance_ids: A list of strings of instance IDs\n\n        :type max_results: int\n        :param max_results: The maximum number of paginated instance\n            items per response.\n\n        :type next_token: str\n        :param next_token: A string specifying the next paginated set\n            of results to return.\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n            the results returned.  Filters are provided\n            in the form of a dictionary consisting of\n            filter names as the key and filter values\n            as the value.  The set of allowable filter\n            names/values is dependent on the request\n            being performed.  Check the EC2 API guide\n            for details.\n\n        :rtype: list\n        :return: A list of instances that have maintenance scheduled.\n        \"\"\"\n        params = {}\n        if instance_ids:\n            self.build_list_params(params, instance_ids, 'InstanceId')\n        if max_results:\n            params['MaxResults'] = max_results\n        if next_token:\n            params['NextToken'] = next_token\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_object('DescribeInstanceStatus', params,\n                               InstanceStatusSet, verb='POST')", "response": "Get all the status of the instances in your account scheduled for maintenance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_instances(self, image_id, min_count=1, max_count=1,\n                      key_name=None, security_groups=None,\n                      user_data=None, addressing_type=None,\n                      instance_type='m1.small', placement=None,\n                      kernel_id=None, ramdisk_id=None,\n                      monitoring_enabled=False, subnet_id=None,\n                      block_device_map=None,\n                      disable_api_termination=False,\n                      instance_initiated_shutdown_behavior=None,\n                      private_ip_address=None,\n                      placement_group=None, client_token=None,\n                      security_group_ids=None):\n        \"\"\"\n        Runs an image on EC2.\n\n        :type image_id: string\n        :param image_id: The ID of the image to run\n\n        :type min_count: int\n        :param min_count: The minimum number of instances to launch\n\n        :type max_count: int\n        :param max_count: The maximum number of instances to launch\n\n        :type key_name: string\n        :param key_name: The name of the key pair with which to launch instances\n\n        :type security_groups: list of strings\n        :param security_groups: The names of the security groups with which to\n                                associate instances\n\n        :type user_data: string\n        :param user_data: The user data passed to the launched instances\n\n        :type instance_type: string\n        :param instance_type: The type of instance to run:\n\n                              * m1.small\n                              * m1.large\n                              * m1.xlarge\n                              * c1.medium\n                              * c1.xlarge\n                              * m2.xlarge\n                              * m2.2xlarge\n                              * m2.4xlarge\n                              * cc1.4xlarge\n                              * t1.micro\n\n        :type placement: string\n        :param placement: The availability zone in which to launch the instances\n\n        :type kernel_id: string\n        :param kernel_id: The ID of the kernel with which to launch the\n                          instances\n\n        :type ramdisk_id: string\n        :param ramdisk_id: The ID of the RAM disk with which to launch the\n                           instances\n\n        :type monitoring_enabled: bool\n        :param monitoring_enabled: Enable CloudWatch monitoring on the instance.\n\n        :type subnet_id: string\n        :param subnet_id: The subnet ID within which to launch the instances\n                          for VPC.\n\n        :type private_ip_address: string\n        :param private_ip_address: If you're using VPC, you can optionally use\n                                   this parameter to assign the instance a\n                                   specific available IP address from the\n                                   subnet (e.g., 10.0.0.25).\n\n        :type block_device_map: :class:`boto.ec2.blockdevicemapping.BlockDeviceMapping`\n        :param block_device_map: A BlockDeviceMapping data structure\n                                 describing the EBS volumes associated\n                                 with the Image.\n\n        :type disable_api_termination: bool\n        :param disable_api_termination: If True, the instances will be locked\n                                        and will not be able to be terminated\n                                        via the API.\n\n        :type instance_initiated_shutdown_behavior: string\n        :param instance_initiated_shutdown_behavior: Specifies whether the\n                                                     instance stops or\n                                                     terminates on\n                                                     instance-initiated\n                                                     shutdown.\n                                                     Valid values are:\n\n                                                     * stop\n                                                     * terminate\n\n        :type placement_group: string\n        :param placement_group: If specified, this is the name of the placement\n                                group in which the instance(s) will be launched.\n\n        :type client_token: string\n        :param client_token: Unique, case-sensitive identifier you provide\n                             to ensure idempotency of the request.\n                             Maximum 64 ASCII characters\n\n        :rtype: Reservation\n        :return: The :class:`boto.ec2.instance.Reservation` associated with\n                 the request for machines\n\n        :type security_group_ids: list of strings\n        :param security_group_ids: The ID of the VPC security groups with\n                                   which to associate instances\n        \"\"\"\n        params = {'ImageId':image_id,\n                  'MinCount':min_count,\n                  'MaxCount': max_count}\n        if key_name:\n            params['KeyName'] = key_name\n        if security_group_ids:\n            l = []\n            for group in security_group_ids:\n                if isinstance(group, SecurityGroup):\n                    l.append(group.id)\n                else:\n                    l.append(group)\n            self.build_list_params(params, l, 'SecurityGroupId')\n        if security_groups:\n            l = []\n            for group in security_groups:\n                if isinstance(group, SecurityGroup):\n                    l.append(group.name)\n                else:\n                    l.append(group)\n            self.build_list_params(params, l, 'SecurityGroup')\n        if user_data:\n            params['UserData'] = base64.b64encode(user_data)\n        if addressing_type:\n            params['AddressingType'] = addressing_type\n        if instance_type:\n            params['InstanceType'] = instance_type\n        if placement:\n            params['Placement.AvailabilityZone'] = placement\n        if placement_group:\n            params['Placement.GroupName'] = placement_group\n        if kernel_id:\n            params['KernelId'] = kernel_id\n        if ramdisk_id:\n            params['RamdiskId'] = ramdisk_id\n        if monitoring_enabled:\n            params['Monitoring.Enabled'] = 'true'\n        if subnet_id:\n            params['SubnetId'] = subnet_id\n        if private_ip_address:\n            params['PrivateIpAddress'] = private_ip_address\n        if block_device_map:\n            block_device_map.build_list_params(params)\n        if disable_api_termination:\n            params['DisableApiTermination'] = 'true'\n        if instance_initiated_shutdown_behavior:\n            val = instance_initiated_shutdown_behavior\n            params['InstanceInitiatedShutdownBehavior'] = val\n        if client_token:\n            params['ClientToken'] = client_token\n        return self.get_object('RunInstances', params, Reservation, verb='POST')", "response": "Runs an image on EC2."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef terminate_instances(self, instance_ids=None):\n        params = {}\n        if instance_ids:\n            self.build_list_params(params, instance_ids, 'InstanceId')\n        return self.get_list('TerminateInstances', params,\n                             [('item', Instance)], verb='POST')", "response": "Terminate the Instances specified by instance_ids."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stop_instances(self, instance_ids=None, force=False):\n        params = {}\n        if force:\n            params['Force'] = 'true'\n        if instance_ids:\n            self.build_list_params(params, instance_ids, 'InstanceId')\n        return self.get_list('StopInstances', params,\n                             [('item', Instance)], verb='POST')", "response": "Stop the specified Instances."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstarting the instances specified by instance_ids.", "response": "def start_instances(self, instance_ids=None):\n        \"\"\"\n        Start the instances specified\n\n        :type instance_ids: list\n        :param instance_ids: A list of strings of the Instance IDs to start\n\n        :rtype: list\n        :return: A list of the instances started\n        \"\"\"\n        params = {}\n        if instance_ids:\n            self.build_list_params(params, instance_ids, 'InstanceId')\n        return self.get_list('StartInstances', params,\n                             [('item', Instance)], verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves the console output for the specified instance.", "response": "def get_console_output(self, instance_id):\n        \"\"\"\n        Retrieves the console output for the specified instance.\n\n        :type instance_id: string\n        :param instance_id: The instance ID of a running instance on the cloud.\n\n        :rtype: :class:`boto.ec2.instance.ConsoleOutput`\n        :return: The console output as a ConsoleOutput object\n        \"\"\"\n        params = {}\n        self.build_list_params(params, [instance_id], 'InstanceId')\n        return self.get_object('GetConsoleOutput', params,\n                               ConsoleOutput, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets an instance attribute from an instance.", "response": "def get_instance_attribute(self, instance_id, attribute):\n        \"\"\"\n        Gets an attribute from an instance.\n\n        :type instance_id: string\n        :param instance_id: The Amazon id of the instance\n\n        :type attribute: string\n        :param attribute: The attribute you need information about\n                          Valid choices are:\n\n                          * instanceType|kernel|ramdisk|userData|\n                          * disableApiTermination|\n                          * instanceInitiatedShutdownBehavior|\n                          * rootDeviceName|blockDeviceMapping\n\n        :rtype: :class:`boto.ec2.image.InstanceAttribute`\n        :return: An InstanceAttribute object representing the value of the\n                 attribute requested\n        \"\"\"\n        params = {'InstanceId' : instance_id}\n        if attribute:\n            params['Attribute'] = attribute\n        return self.get_object('DescribeInstanceAttribute', params,\n                               InstanceAttribute, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmodifies an attribute of an instance.", "response": "def modify_instance_attribute(self, instance_id, attribute, value):\n        \"\"\"\n        Changes an attribute of an instance\n\n        :type instance_id: string\n        :param instance_id: The instance id you wish to change\n\n        :type attribute: string\n        :param attribute: The attribute you wish to change.\n\n                          * AttributeName - Expected value (default)\n                          * instanceType - A valid instance type (m1.small)\n                          * kernel - Kernel ID (None)\n                          * ramdisk - Ramdisk ID (None)\n                          * userData - Base64 encoded String (None)\n                          * disableApiTermination - Boolean (true)\n                          * instanceInitiatedShutdownBehavior - stop|terminate\n                          * rootDeviceName - device name (None)\n\n        :type value: string\n        :param value: The new value for the attribute\n\n        :rtype: bool\n        :return: Whether the operation succeeded or not\n        \"\"\"\n        # Allow a bool to be passed in for value of disableApiTermination\n        if attribute == 'disableApiTermination':\n            if isinstance(value, bool):\n                if value:\n                    value = 'true'\n                else:\n                    value = 'false'\n        params = {'InstanceId' : instance_id,\n                  'Attribute' : attribute,\n                  'Value' : value}\n        return self.get_status('ModifyInstanceAttribute', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nresetting an attribute of an instance to its default value.", "response": "def reset_instance_attribute(self, instance_id, attribute):\n        \"\"\"\n        Resets an attribute of an instance to its default value.\n\n        :type instance_id: string\n        :param instance_id: ID of the instance\n\n        :type attribute: string\n        :param attribute: The attribute to reset. Valid values are:\n                          kernel|ramdisk\n\n        :rtype: bool\n        :return: Whether the operation succeeded or not\n        \"\"\"\n        params = {'InstanceId' : instance_id,\n                  'Attribute' : attribute}\n        return self.get_status('ResetInstanceAttribute', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves all the spot instance requests associated with your account.", "response": "def get_all_spot_instance_requests(self, request_ids=None,\n                                       filters=None):\n        \"\"\"\n        Retrieve all the spot instances requests associated with your account.\n\n        :type request_ids: list\n        :param request_ids: A list of strings of spot instance request IDs\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n                        the results returned.  Filters are provided\n                        in the form of a dictionary consisting of\n                        filter names as the key and filter values\n                        as the value.  The set of allowable filter\n                        names/values is dependent on the request\n                        being performed.  Check the EC2 API guide\n                        for details.\n\n        :rtype: list\n        :return: A list of\n                 :class:`boto.ec2.spotinstancerequest.SpotInstanceRequest`\n        \"\"\"\n        params = {}\n        if request_ids:\n            self.build_list_params(params, request_ids, 'SpotInstanceRequestId')\n        if filters:\n            if 'launch.group-id' in filters:\n                lgid = filters.get('launch.group-id')\n                if not lgid.startswith('sg-') or len(lgid) != 11:\n                    warnings.warn(\n                        \"The 'launch.group-id' filter now requires a security \"\n                        \"group id (sg-*) and no longer supports filtering by \"\n                        \"group name. Please update your filters accordingly.\",\n                        UserWarning)\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeSpotInstanceRequests', params,\n                             [('item', SpotInstanceRequest)], verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_spot_price_history(self, start_time=None, end_time=None,\n                               instance_type=None, product_description=None,\n                               availability_zone=None):\n        \"\"\"\n        Retrieve the recent history of spot instances pricing.\n\n        :type start_time: str\n        :param start_time: An indication of how far back to provide price\n                           changes for. An ISO8601 DateTime string.\n\n        :type end_time: str\n        :param end_time: An indication of how far forward to provide price\n                         changes for.  An ISO8601 DateTime string.\n\n        :type instance_type: str\n        :param instance_type: Filter responses to a particular instance type.\n\n        :type product_description: str\n        :param product_description: Filter responses to a particular platform.\n                                    Valid values are currently: \"Linux/UNIX\",\n                                    \"SUSE Linux\", and \"Windows\"\n\n        :type availability_zone: str\n        :param availability_zone: The availability zone for which prices\n                                  should be returned\n\n        :rtype: list\n        :return: A list tuples containing price and timestamp.\n        \"\"\"\n        params = {}\n        if start_time:\n            params['StartTime'] = start_time\n        if end_time:\n            params['EndTime'] = end_time\n        if instance_type:\n            params['InstanceType'] = instance_type\n        if product_description:\n            params['ProductDescription'] = product_description\n        if availability_zone:\n            params['AvailabilityZone'] = availability_zone\n        return self.get_list('DescribeSpotPriceHistory', params,\n                             [('item', SpotPriceHistory)], verb='POST')", "response": "Retrieve the recent spot price history for a particular instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef request_spot_instances(self, price, image_id, count=1, type='one-time',\n                               valid_from=None, valid_until=None,\n                               launch_group=None, availability_zone_group=None,\n                               key_name=None, security_groups=None,\n                               user_data=None, addressing_type=None,\n                               instance_type='m1.small', placement=None,\n                               kernel_id=None, ramdisk_id=None,\n                               monitoring_enabled=False, subnet_id=None,\n                               block_device_map=None):\n        \"\"\"\n        Request instances on the spot market at a particular price.\n\n        :type price: str\n        :param price: The maximum price of your bid\n\n        :type image_id: string\n        :param image_id: The ID of the image to run\n\n        :type count: int\n        :param count: The of instances to requested\n\n        :type type: str\n        :param type: Type of request. Can be 'one-time' or 'persistent'.\n                     Default is one-time.\n\n        :type valid_from: str\n        :param valid_from: Start date of the request. An ISO8601 time string.\n\n        :type valid_until: str\n        :param valid_until: End date of the request.  An ISO8601 time string.\n\n        :type launch_group: str\n        :param launch_group: If supplied, all requests will be fulfilled\n                             as a group.\n\n        :type availability_zone_group: str\n        :param availability_zone_group: If supplied, all requests will be\n                                        fulfilled within a single\n                                        availability zone.\n\n        :type key_name: string\n        :param key_name: The name of the key pair with which to launch instances\n\n        :type security_groups: list of strings\n        :param security_groups: The names of the security groups with which to\n                                associate instances\n\n        :type user_data: string\n        :param user_data: The user data passed to the launched instances\n\n        :type instance_type: string\n        :param instance_type: The type of instance to run:\n\n                              * m1.small\n                              * m1.large\n                              * m1.xlarge\n                              * c1.medium\n                              * c1.xlarge\n                              * m2.xlarge\n                              * m2.2xlarge\n                              * m2.4xlarge\n                              * cc1.4xlarge\n                              * t1.micro\n\n        :type placement: string\n        :param placement: The availability zone in which to launch the instances\n\n        :type kernel_id: string\n        :param kernel_id: The ID of the kernel with which to launch the\n                          instances\n\n        :type ramdisk_id: string\n        :param ramdisk_id: The ID of the RAM disk with which to launch the\n                           instances\n\n        :type monitoring_enabled: bool\n        :param monitoring_enabled: Enable CloudWatch monitoring on the instance.\n\n        :type subnet_id: string\n        :param subnet_id: The subnet ID within which to launch the instances\n                          for VPC.\n\n        :type block_device_map: :class:`boto.ec2.blockdevicemapping.BlockDeviceMapping`\n        :param block_device_map: A BlockDeviceMapping data structure\n                                 describing the EBS volumes associated\n                                 with the Image.\n\n        :rtype: Reservation\n        :return: The :class:`boto.ec2.spotinstancerequest.SpotInstanceRequest`\n                 associated with the request for machines\n        \"\"\"\n        params = {'LaunchSpecification.ImageId':image_id,\n                  'Type' : type,\n                  'SpotPrice' : price}\n        if count:\n            params['InstanceCount'] = count\n        if valid_from:\n            params['ValidFrom'] = valid_from\n        if valid_until:\n            params['ValidUntil'] = valid_until\n        if launch_group:\n            params['LaunchGroup'] = launch_group\n        if availability_zone_group:\n            params['AvailabilityZoneGroup'] = availability_zone_group\n        if key_name:\n            params['LaunchSpecification.KeyName'] = key_name\n        if security_groups:\n            l = []\n            for group in security_groups:\n                if isinstance(group, SecurityGroup):\n                    l.append(group.name)\n                else:\n                    l.append(group)\n            self.build_list_params(params, l,\n                                   'LaunchSpecification.SecurityGroup')\n        if user_data:\n            params['LaunchSpecification.UserData'] = base64.b64encode(user_data)\n        if addressing_type:\n            params['LaunchSpecification.AddressingType'] = addressing_type\n        if instance_type:\n            params['LaunchSpecification.InstanceType'] = instance_type\n        if placement:\n            params['LaunchSpecification.Placement.AvailabilityZone'] = placement\n        if kernel_id:\n            params['LaunchSpecification.KernelId'] = kernel_id\n        if ramdisk_id:\n            params['LaunchSpecification.RamdiskId'] = ramdisk_id\n        if monitoring_enabled:\n            params['LaunchSpecification.Monitoring.Enabled'] = 'true'\n        if subnet_id:\n            params['LaunchSpecification.SubnetId'] = subnet_id\n        if block_device_map:\n            block_device_map.build_list_params(params, 'LaunchSpecification.')\n        return self.get_list('RequestSpotInstances', params,\n                             [('item', SpotInstanceRequest)],\n                             verb='POST')", "response": "Request the specified number of instances on the spot market at a particular price."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cancel_spot_instance_requests(self, request_ids):\n        params = {}\n        if request_ids:\n            self.build_list_params(params, request_ids, 'SpotInstanceRequestId')\n        return self.get_list('CancelSpotInstanceRequests', params,\n                             [('item', Instance)], verb='POST')", "response": "Cancel the specified Spot Instance Requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a spot instance datafeed subscription for this account.", "response": "def create_spot_datafeed_subscription(self, bucket, prefix):\n        \"\"\"\n        Create a spot instance datafeed subscription for this account.\n\n        :type bucket: str or unicode\n        :param bucket: The name of the bucket where spot instance data\n                       will be written.  The account issuing this request\n                       must have FULL_CONTROL access to the bucket\n                       specified in the request.\n\n        :type prefix: str or unicode\n        :param prefix: An optional prefix that will be pre-pended to all\n                       data files written to the bucket.\n\n        :rtype: :class:`boto.ec2.spotdatafeedsubscription.SpotDatafeedSubscription`\n        :return: The datafeed subscription object or None\n        \"\"\"\n        params = {'Bucket' : bucket}\n        if prefix:\n            params['Prefix'] = prefix\n        return self.get_object('CreateSpotDatafeedSubscription',\n                               params, SpotDatafeedSubscription, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_zones(self, zones=None, filters=None):\n        params = {}\n        if zones:\n            self.build_list_params(params, zones, 'ZoneName')\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeAvailabilityZones', params,\n                             [('item', Zone)], verb='POST')", "response": "Get all Availability Zones associated with the current region."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_all_addresses(self, addresses=None, filters=None, allocation_ids=None):\n        params = {}\n        if addresses:\n            self.build_list_params(params, addresses, 'PublicIp')\n        if allocation_ids:\n            self.build_list_params(params, allocation_ids, 'AllocationId')\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeAddresses', params, [('item', Address)], verb='POST')", "response": "Get all EIP s associated with the current credentials."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nallocates a new Elastic IP address and associate it with your account.", "response": "def allocate_address(self, domain=None):\n        \"\"\"\n        Allocate a new Elastic IP address and associate it with your account.\n\n        :rtype: :class:`boto.ec2.address.Address`\n        :return: The newly allocated Address\n        \"\"\"\n        params = {}\n\n        if domain is not None:\n            params['Domain'] = domain\n\n        return self.get_object('AllocateAddress', params, Address, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nassociate an Elastic IP address with a currently running instance.", "response": "def associate_address(self, instance_id, public_ip=None, allocation_id=None):\n        \"\"\"\n        Associate an Elastic IP address with a currently running instance.\n        This requires one of ``public_ip`` or ``allocation_id`` depending\n        on if you're associating a VPC address or a plain EC2 address.\n\n        :type instance_id: string\n        :param instance_id: The ID of the instance\n\n        :type public_ip: string\n        :param public_ip: The public IP address for EC2 based allocations.\n\n        :type allocation_id: string\n        :param allocation_id: The allocation ID for a VPC-based elastic IP.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        params = { 'InstanceId' : instance_id }\n\n        if public_ip is not None:\n            params['PublicIp'] = public_ip\n        elif allocation_id is not None:\n            params['AllocationId'] = allocation_id\n\n        return self.get_status('AssociateAddress', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndisassociate an Elastic IP address from a currently running instance.", "response": "def disassociate_address(self, public_ip=None, association_id=None):\n        \"\"\"\n        Disassociate an Elastic IP address from a currently running instance.\n\n        :type public_ip: string\n        :param public_ip: The public IP address for EC2 elastic IPs.\n\n        :type association_id: string\n        :param association_id: The association ID for a VPC based elastic ip.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        params = {}\n\n        if public_ip is not None:\n            params['PublicIp'] = public_ip\n        elif association_id is not None:\n            params['AssociationId'] = association_id\n\n        return self.get_status('DisassociateAddress', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfreeing up an Elastic IP address.", "response": "def release_address(self, public_ip=None, allocation_id=None):\n        \"\"\"\n        Free up an Elastic IP address.\n\n        :type public_ip: string\n        :param public_ip: The public IP address for EC2 elastic IPs.\n\n        :type allocation_id: string\n        :param allocation_id: The ID for VPC elastic IPs.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        params = {}\n\n        if public_ip is not None:\n            params['PublicIp'] = public_ip\n        elif allocation_id is not None:\n            params['AllocationId'] = allocation_id\n\n        return self.get_status('ReleaseAddress', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_volumes(self, volume_ids=None, filters=None):\n        params = {}\n        if volume_ids:\n            self.build_list_params(params, volume_ids, 'VolumeId')\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeVolumes', params,\n                             [('item', Volume)], verb='POST')", "response": "Get all Volumes associated with the current credentials."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new EBS Volume.", "response": "def create_volume(self, size, zone, snapshot=None):\n        \"\"\"\n        Create a new EBS Volume.\n\n        :type size: int\n        :param size: The size of the new volume, in GiB\n\n        :type zone: string or :class:`boto.ec2.zone.Zone`\n        :param zone: The availability zone in which the Volume will be created.\n\n        :type snapshot: string or :class:`boto.ec2.snapshot.Snapshot`\n        :param snapshot: The snapshot from which the new Volume will be created.\n        \"\"\"\n        if isinstance(zone, Zone):\n            zone = zone.name\n        params = {'AvailabilityZone' : zone}\n        if size:\n            params['Size'] = size\n        if snapshot:\n            if isinstance(snapshot, Snapshot):\n                snapshot = snapshot.id\n            params['SnapshotId'] = snapshot\n        return self.get_object('CreateVolume', params, Volume, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nattaches an EBS volume to an EC2 instance.", "response": "def attach_volume(self, volume_id, instance_id, device):\n        \"\"\"\n        Attach an EBS volume to an EC2 instance.\n\n        :type volume_id: str\n        :param volume_id: The ID of the EBS volume to be attached.\n\n        :type instance_id: str\n        :param instance_id: The ID of the EC2 instance to which it will\n                            be attached.\n\n        :type device: str\n        :param device: The device on the instance through which the\n                       volume will be exposted (e.g. /dev/sdh)\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        params = {'InstanceId' : instance_id,\n                  'VolumeId' : volume_id,\n                  'Device' : device}\n        return self.get_status('AttachVolume', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef detach_volume(self, volume_id, instance_id=None,\n                      device=None, force=False):\n        \"\"\"\n        Detach an EBS volume from an EC2 instance.\n\n        :type volume_id: str\n        :param volume_id: The ID of the EBS volume to be attached.\n\n        :type instance_id: str\n        :param instance_id: The ID of the EC2 instance from which it will\n                            be detached.\n\n        :type device: str\n        :param device: The device on the instance through which the\n                       volume is exposted (e.g. /dev/sdh)\n\n        :type force: bool\n        :param force: Forces detachment if the previous detachment attempt did\n                      not occur cleanly.  This option can lead to data loss or\n                      a corrupted file system. Use this option only as a last\n                      resort to detach a volume from a failed instance. The\n                      instance will not have an opportunity to flush file system\n                      caches nor file system meta data. If you use this option,\n                      you must perform file system check and repair procedures.\n\n        :rtype: bool\n        :return: True if successful\n        \"\"\"\n        params = {'VolumeId' : volume_id}\n        if instance_id:\n            params['InstanceId'] = instance_id\n        if device:\n            params['Device'] = device\n        if force:\n            params['Force'] = 'true'\n        return self.get_status('DetachVolume', params, verb='POST')", "response": "Detach an EBS volume from an EC2 instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all EBS Snapshots associated with the current credentials.", "response": "def get_all_snapshots(self, snapshot_ids=None,\n                          owner=None, restorable_by=None,\n                          filters=None):\n        \"\"\"\n        Get all EBS Snapshots associated with the current credentials.\n\n        :type snapshot_ids: list\n        :param snapshot_ids: Optional list of snapshot ids.  If this list is\n                             present, only the Snapshots associated with\n                             these snapshot ids will be returned.\n\n        :type owner: str\n        :param owner: If present, only the snapshots owned by the specified user\n                      will be returned.  Valid values are:\n\n                      * self\n                      * amazon\n                      * AWS Account ID\n\n        :type restorable_by: str\n        :param restorable_by: If present, only the snapshots that are restorable\n                              by the specified account id will be returned.\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n                        the results returned.  Filters are provided\n                        in the form of a dictionary consisting of\n                        filter names as the key and filter values\n                        as the value.  The set of allowable filter\n                        names/values is dependent on the request\n                        being performed.  Check the EC2 API guide\n                        for details.\n\n        :rtype: list of :class:`boto.ec2.snapshot.Snapshot`\n        :return: The requested Snapshot objects\n        \"\"\"\n        params = {}\n        if snapshot_ids:\n            self.build_list_params(params, snapshot_ids, 'SnapshotId')\n        if owner:\n            params['Owner'] = owner\n        if restorable_by:\n            params['RestorableBy'] = restorable_by\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeSnapshots', params,\n                             [('item', Snapshot)], verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_snapshot(self, volume_id, description=None):\n        params = {'VolumeId' : volume_id}\n        if description:\n            params['Description'] = description[0:255]\n        snapshot = self.get_object('CreateSnapshot', params,\n                                   Snapshot, verb='POST')\n        volume = self.get_all_volumes([volume_id])[0]\n        volume_name = volume.tags.get('Name')\n        if volume_name:\n            snapshot.add_tag('Name', volume_name)\n        return snapshot", "response": "Create a snapshot of an existing EBS Volume."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trim_snapshots(self, hourly_backups = 8, daily_backups = 7,\n                       weekly_backups = 4):\n        \"\"\"\n        Trim excess snapshots, based on when they were taken. More current\n        snapshots are retained, with the number retained decreasing as you\n        move back in time.\n\n        If ebs volumes have a 'Name' tag with a value, their snapshots\n        will be assigned the same tag when they are created. The values\n        of the 'Name' tags for snapshots are used by this function to\n        group snapshots taken from the same volume (or from a series\n        of like-named volumes over time) for trimming.\n\n        For every group of like-named snapshots, this function retains\n        the newest and oldest snapshots, as well as, by default,  the\n        first snapshots taken in each of the last eight hours, the first\n        snapshots taken in each of the last seven days, the first snapshots\n        taken in the last 4 weeks (counting Midnight Sunday morning as\n        the start of the week), and the first snapshot from the first\n        Sunday of each month forever.\n\n        :type hourly_backups: int\n        :param hourly_backups: How many recent hourly backups should be saved.\n\n        :type daily_backups: int\n        :param daily_backups: How many recent daily backups should be saved.\n\n        :type weekly_backups: int\n        :param weekly_backups: How many recent weekly backups should be saved.\n        \"\"\"\n\n        # This function first builds up an ordered list of target times\n        # that snapshots should be saved for (last 8 hours, last 7 days, etc.).\n        # Then a map of snapshots is constructed, with the keys being\n        # the snapshot / volume names and the values being arrays of\n        # chronologically sorted snapshots.\n        # Finally, for each array in the map, we go through the snapshot\n        # array and the target time array in an interleaved fashion,\n        # deleting snapshots whose start_times don't immediately follow a\n        # target time (we delete a snapshot if there's another snapshot\n        # that was made closer to the preceding target time).\n\n        now = datetime.utcnow()\n        last_hour = datetime(now.year, now.month, now.day, now.hour)\n        last_midnight = datetime(now.year, now.month, now.day)\n        last_sunday = datetime(now.year, now.month, now.day) - timedelta(days = (now.weekday() + 1) % 7)\n        start_of_month = datetime(now.year, now.month, 1)\n\n        target_backup_times = []\n\n        # there are no snapshots older than 1/1/2007\n        oldest_snapshot_date = datetime(2007, 1, 1)\n\n        for hour in range(0, hourly_backups):\n            target_backup_times.append(last_hour - timedelta(hours = hour))\n\n        for day in range(0, daily_backups):\n            target_backup_times.append(last_midnight - timedelta(days = day))\n\n        for week in range(0, weekly_backups):\n            target_backup_times.append(last_sunday - timedelta(weeks = week))\n\n        one_day = timedelta(days = 1)\n        while start_of_month > oldest_snapshot_date:\n            # append the start of the month to the list of\n            # snapshot dates to save:\n            target_backup_times.append(start_of_month)\n            # there's no timedelta setting for one month, so instead:\n            # decrement the day by one, so we go to the final day of\n            # the previous month...\n            start_of_month -= one_day\n            # ... and then go to the first day of that previous month:\n            start_of_month = datetime(start_of_month.year,\n                                      start_of_month.month, 1)\n\n        temp = []\n\n        for t in target_backup_times:\n            if temp.__contains__(t) == False:\n                temp.append(t)\n\n        target_backup_times = temp\n        # make the oldeest dates first, and make sure the month start\n        # and last four week's start are in the proper order\n        target_backup_times.sort()\n\n        # get all the snapshots, sort them by date and time, and\n        # organize them into one array for each volume:\n        all_snapshots = self.get_all_snapshots(owner = 'self')\n        all_snapshots.sort(cmp = lambda x, y: cmp(x.start_time, y.start_time))\n        snaps_for_each_volume = {}\n        for snap in all_snapshots:\n            # the snapshot name and the volume name are the same.\n            # The snapshot name is set from the volume\n            # name at the time the snapshot is taken\n            volume_name = snap.tags.get('Name')\n            if volume_name:\n                # only examine snapshots that have a volume name\n                snaps_for_volume = snaps_for_each_volume.get(volume_name)\n                if not snaps_for_volume:\n                    snaps_for_volume = []\n                    snaps_for_each_volume[volume_name] = snaps_for_volume\n                snaps_for_volume.append(snap)\n\n        # Do a running comparison of snapshot dates to desired time\n        #periods, keeping the oldest snapshot in each\n        # time period and deleting the rest:\n        for volume_name in snaps_for_each_volume:\n            snaps = snaps_for_each_volume[volume_name]\n            snaps = snaps[:-1] # never delete the newest snapshot\n            time_period_number = 0\n            snap_found_for_this_time_period = False\n            for snap in snaps:\n                check_this_snap = True\n                while check_this_snap and time_period_number < target_backup_times.__len__():\n                    snap_date = datetime.strptime(snap.start_time,\n                                                  '%Y-%m-%dT%H:%M:%S.000Z')\n                    if snap_date < target_backup_times[time_period_number]:\n                        # the snap date is before the cutoff date.\n                        # Figure out if it's the first snap in this\n                        # date range and act accordingly (since both\n                        #date the date ranges and the snapshots\n                        # are sorted chronologically, we know this\n                        #snapshot isn't in an earlier date range):\n                        if snap_found_for_this_time_period == True:\n                            if not snap.tags.get('preserve_snapshot'):\n                                # as long as the snapshot wasn't marked\n                                # with the 'preserve_snapshot' tag, delete it:\n                                try:\n                                    self.delete_snapshot(snap.id)\n                                    boto.log.info('Trimmed snapshot %s (%s)' % (snap.tags['Name'], snap.start_time))\n                                except EC2ResponseError:\n                                    boto.log.error('Attempt to trim snapshot %s (%s) failed. Possible result of a race condition with trimming on another server?' % (snap.tags['Name'], snap.start_time))\n                            # go on and look at the next snapshot,\n                            #leaving the time period alone\n                        else:\n                            # this was the first snapshot found for this\n                            #time period. Leave it alone and look at the\n                            # next snapshot:\n                            snap_found_for_this_time_period = True\n                        check_this_snap = False\n                    else:\n                        # the snap is after the cutoff date. Check it\n                        # against the next cutoff date\n                        time_period_number += 1\n                        snap_found_for_this_time_period = False", "response": "This function trims excess snapshots based on when they were taken."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting information about an attribute of a snapshot.", "response": "def get_snapshot_attribute(self, snapshot_id,\n                               attribute='createVolumePermission'):\n        \"\"\"\n        Get information about an attribute of a snapshot.  Only one attribute\n        can be specified per call.\n\n        :type snapshot_id: str\n        :param snapshot_id: The ID of the snapshot.\n\n        :type attribute: str\n        :param attribute: The requested attribute.  Valid values are:\n\n                          * createVolumePermission\n\n        :rtype: list of :class:`boto.ec2.snapshotattribute.SnapshotAttribute`\n        :return: The requested Snapshot attribute\n        \"\"\"\n        params = {'Attribute' : attribute}\n        if snapshot_id:\n            params['SnapshotId'] = snapshot_id\n        return self.get_object('DescribeSnapshotAttribute', params,\n                               SnapshotAttribute, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchanging an attribute of an image.", "response": "def modify_snapshot_attribute(self, snapshot_id,\n                                  attribute='createVolumePermission',\n                                  operation='add', user_ids=None, groups=None):\n        \"\"\"\n        Changes an attribute of an image.\n\n        :type snapshot_id: string\n        :param snapshot_id: The snapshot id you wish to change\n\n        :type attribute: string\n        :param attribute: The attribute you wish to change.  Valid values are:\n                          createVolumePermission\n\n        :type operation: string\n        :param operation: Either add or remove (this is required for changing\n                          snapshot ermissions)\n\n        :type user_ids: list\n        :param user_ids: The Amazon IDs of users to add/remove attributes\n\n        :type groups: list\n        :param groups: The groups to add/remove attributes.  The only valid\n                       value at this time is 'all'.\n\n        \"\"\"\n        params = {'SnapshotId' : snapshot_id,\n                  'Attribute' : attribute,\n                  'OperationType' : operation}\n        if user_ids:\n            self.build_list_params(params, user_ids, 'UserId')\n        if groups:\n            self.build_list_params(params, groups, 'UserGroup')\n        return self.get_status('ModifySnapshotAttribute', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreset an attribute of a snapshot to its default value.", "response": "def reset_snapshot_attribute(self, snapshot_id,\n                                 attribute='createVolumePermission'):\n        \"\"\"\n        Resets an attribute of a snapshot to its default value.\n\n        :type snapshot_id: string\n        :param snapshot_id: ID of the snapshot\n\n        :type attribute: string\n        :param attribute: The attribute to reset\n\n        :rtype: bool\n        :return: Whether the operation succeeded or not\n        \"\"\"\n        params = {'SnapshotId' : snapshot_id,\n                  'Attribute' : attribute}\n        return self.get_status('ResetSnapshotAttribute', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_key_pairs(self, keynames=None, filters=None):\n        params = {}\n        if keynames:\n            self.build_list_params(params, keynames, 'KeyName')\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeKeyPairs', params,\n                             [('item', KeyPair)], verb='POST')", "response": "Get all key pairs associated with your account."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_key_pair(self, keyname):\n        try:\n            return self.get_all_key_pairs(keynames=[keyname])[0]\n        except self.ResponseError, e:\n            if e.code == 'InvalidKeyPair.NotFound':\n                return None\n            else:\n                raise", "response": "Returns the KeyPair specified by keyname."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new key pair for your account.", "response": "def create_key_pair(self, key_name):\n        \"\"\"\n        Create a new key pair for your account.\n        This will create the key pair within the region you\n        are currently connected to.\n\n        :type key_name: string\n        :param key_name: The name of the new keypair\n\n        :rtype: :class:`boto.ec2.keypair.KeyPair`\n        :return: The newly created :class:`boto.ec2.keypair.KeyPair`.\n                 The material attribute of the new KeyPair object\n                 will contain the the unencrypted PEM encoded RSA private key.\n        \"\"\"\n        params = {'KeyName':key_name}\n        return self.get_object('CreateKeyPair', params, KeyPair, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_security_groups(self, groupnames=None, group_ids=None,\n                                filters=None):\n        \"\"\"\n        Get all security groups associated with your account in a region.\n\n        :type groupnames: list\n        :param groupnames: A list of the names of security groups to retrieve.\n                           If not provided, all security groups will be\n                           returned.\n\n        :type group_ids: list\n        :param group_ids: A list of IDs of security groups to retrieve for\n                          security groups within a VPC.\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n                        the results returned.  Filters are provided\n                        in the form of a dictionary consisting of\n                        filter names as the key and filter values\n                        as the value.  The set of allowable filter\n                        names/values is dependent on the request\n                        being performed.  Check the EC2 API guide\n                        for details.\n\n        :rtype: list\n        :return: A list of :class:`boto.ec2.securitygroup.SecurityGroup`\n        \"\"\"\n        params = {}\n        if groupnames is not None:\n            self.build_list_params(params, groupnames, 'GroupName')\n        if group_ids is not None:\n            self.build_list_params(params, group_ids, 'GroupId')\n        if filters is not None:\n            self.build_filter_params(params, filters)\n\n        return self.get_list('DescribeSecurityGroups', params,\n                             [('item', SecurityGroup)], verb='POST')", "response": "Get all security groups associated with your account in a region."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_security_group(self, name, description, vpc_id=None):\n        params = {\n            'GroupName': name,\n            'GroupDescription': description\n        }\n\n        if vpc_id is not None:\n            params['VpcId'] = vpc_id\n\n        group = self.get_object('CreateSecurityGroup', params,\n                                SecurityGroup, verb='POST')\n        group.name = name\n        group.description = description\n        return group", "response": "Create a new security group within the region you have connected to."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete a security group from your account.", "response": "def delete_security_group(self, name=None, group_id=None):\n        \"\"\"\n        Delete a security group from your account.\n\n        :type name: string\n        :param name: The name of the security group to delete.\n\n        :type group_id: string\n        :param group_id: The ID of the security group to delete within\n          a VPC.\n\n        :rtype: bool\n        :return: True if successful.\n        \"\"\"\n        params = {}\n\n        if name is not None:\n            params['GroupName'] = name\n        elif group_id is not None:\n            params['GroupId'] = group_id\n\n        return self.get_status('DeleteSecurityGroup', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authorize_security_group(self, group_name=None,\n                                 src_security_group_name=None,\n                                 src_security_group_owner_id=None,\n                                 ip_protocol=None, from_port=None, to_port=None,\n                                 cidr_ip=None, group_id=None,\n                                 src_security_group_group_id=None):\n        \"\"\"\n        Add a new rule to an existing security group.\n        You need to pass in either src_security_group_name and\n        src_security_group_owner_id OR ip_protocol, from_port, to_port,\n        and cidr_ip.  In other words, either you are authorizing another\n        group or you are authorizing some ip-based rule.\n\n        :type group_name: string\n        :param group_name: The name of the security group you are adding\n                           the rule to.\n\n        :type src_security_group_name: string\n        :param src_security_group_name: The name of the security group you are\n                                        granting access to.\n\n        :type src_security_group_owner_id: string\n        :param src_security_group_owner_id: The ID of the owner of the security\n                                            group you are granting access to.\n\n        :type ip_protocol: string\n        :param ip_protocol: Either tcp | udp | icmp\n\n        :type from_port: int\n        :param from_port: The beginning port number you are enabling\n\n        :type to_port: int\n        :param to_port: The ending port number you are enabling\n\n        :type cidr_ip: string\n        :param cidr_ip: The CIDR block you are providing access to.\n                        See http://goo.gl/Yj5QC\n\n        :type group_id: string\n        :param group_id: ID of the EC2 or VPC security group to modify.\n                         This is required for VPC security groups and\n                         can be used instead of group_name for EC2\n                         security groups.\n\n        :type group_id: string\n        :param group_id: ID of the EC2 or VPC source security group.\n                         This is required for VPC security groups and\n                         can be used instead of group_name for EC2\n                         security groups.\n\n        :rtype: bool\n        :return: True if successful.\n        \"\"\"\n        if src_security_group_name:\n            if from_port is None and to_port is None and ip_protocol is None:\n                return self.authorize_security_group_deprecated(\n                    group_name, src_security_group_name,\n                    src_security_group_owner_id)\n\n        params = {}\n\n        if group_name:\n            params['GroupName'] = group_name\n        if group_id:\n            params['GroupId'] = group_id\n        if src_security_group_name:\n            param_name = 'IpPermissions.1.Groups.1.GroupName'\n            params[param_name] = src_security_group_name\n        if src_security_group_owner_id:\n            param_name = 'IpPermissions.1.Groups.1.UserId'\n            params[param_name] = src_security_group_owner_id\n        if src_security_group_group_id:\n            param_name = 'IpPermissions.1.Groups.1.GroupId'\n            params[param_name] = src_security_group_group_id\n        if ip_protocol:\n            params['IpPermissions.1.IpProtocol'] = ip_protocol\n        if from_port is not None:\n            params['IpPermissions.1.FromPort'] = from_port\n        if to_port is not None:\n            params['IpPermissions.1.ToPort'] = to_port\n        if cidr_ip:\n            params['IpPermissions.1.IpRanges.1.CidrIp'] = cidr_ip\n\n        return self.get_status('AuthorizeSecurityGroupIngress',\n                               params, verb='POST')", "response": "This function is used to add a new rule to an existing security group. It is intended to be used by other security groups."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndeprecate method to remove a security group from an existing security group.", "response": "def revoke_security_group_deprecated(self, group_name,\n                                         src_security_group_name=None,\n                                         src_security_group_owner_id=None,\n                                         ip_protocol=None,\n                                         from_port=None, to_port=None,\n                                         cidr_ip=None):\n        \"\"\"\n        NOTE: This method uses the old-style request parameters\n              that did not allow a port to be specified when\n              authorizing a group.\n\n        Remove an existing rule from an existing security group.\n        You need to pass in either src_security_group_name and\n        src_security_group_owner_id OR ip_protocol, from_port, to_port,\n        and cidr_ip.  In other words, either you are revoking another\n        group or you are revoking some ip-based rule.\n\n        :type group_name: string\n        :param group_name: The name of the security group you are removing\n                           the rule from.\n\n        :type src_security_group_name: string\n        :param src_security_group_name: The name of the security group you are\n                                        revoking access to.\n\n        :type src_security_group_owner_id: string\n        :param src_security_group_owner_id: The ID of the owner of the security\n                                            group you are revoking access to.\n\n        :type ip_protocol: string\n        :param ip_protocol: Either tcp | udp | icmp\n\n        :type from_port: int\n        :param from_port: The beginning port number you are disabling\n\n        :type to_port: int\n        :param to_port: The ending port number you are disabling\n\n        :type to_port: string\n        :param to_port: The CIDR block you are revoking access to.\n                        http://goo.gl/Yj5QC\n\n        :type group_id: string\n        :param group_id: ID of the EC2 or VPC security group to modify.\n                         This is required for VPC security groups and\n                         can be used instead of group_name for EC2\n                         security groups.\n\n        :type group_id: string\n        :param group_id: ID of the EC2 or VPC source security group.\n                         This is required for VPC security groups and\n                         can be used instead of group_name for EC2\n                         security groups.\n\n        :rtype: bool\n        :return: True if successful.\n        \"\"\"\n        params = {'GroupName':group_name}\n        if src_security_group_name:\n            params['SourceSecurityGroupName'] = src_security_group_name\n        if src_security_group_owner_id:\n            params['SourceSecurityGroupOwnerId'] = src_security_group_owner_id\n        if ip_protocol:\n            params['IpProtocol'] = ip_protocol\n        if from_port:\n            params['FromPort'] = from_port\n        if to_port:\n            params['ToPort'] = to_port\n        if cidr_ip:\n            params['CidrIp'] = cidr_ip\n        return self.get_status('RevokeSecurityGroupIngress', params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving an existing rule from an existing security group.", "response": "def revoke_security_group(self, group_name=None, src_security_group_name=None,\n                              src_security_group_owner_id=None,\n                              ip_protocol=None, from_port=None, to_port=None,\n                              cidr_ip=None, group_id=None,\n                              src_security_group_group_id=None):\n        \"\"\"\n        Remove an existing rule from an existing security group.\n        You need to pass in either src_security_group_name and\n        src_security_group_owner_id OR ip_protocol, from_port, to_port,\n        and cidr_ip.  In other words, either you are revoking another\n        group or you are revoking some ip-based rule.\n\n        :type group_name: string\n        :param group_name: The name of the security group you are removing\n                           the rule from.\n\n        :type src_security_group_name: string\n        :param src_security_group_name: The name of the security group you are\n                                        revoking access to.\n\n        :type src_security_group_owner_id: string\n        :param src_security_group_owner_id: The ID of the owner of the security\n                                            group you are revoking access to.\n\n        :type ip_protocol: string\n        :param ip_protocol: Either tcp | udp | icmp\n\n        :type from_port: int\n        :param from_port: The beginning port number you are disabling\n\n        :type to_port: int\n        :param to_port: The ending port number you are disabling\n\n        :type cidr_ip: string\n        :param cidr_ip: The CIDR block you are revoking access to.\n                        See http://goo.gl/Yj5QC\n\n        :rtype: bool\n        :return: True if successful.\n        \"\"\"\n        if src_security_group_name:\n            if from_port is None and to_port is None and ip_protocol is None:\n                return self.revoke_security_group_deprecated(\n                    group_name, src_security_group_name,\n                    src_security_group_owner_id)\n        params = {}\n        if group_name is not None:\n            params['GroupName'] = group_name\n        if group_id is not None:\n            params['GroupId'] = group_id\n        if src_security_group_name:\n            param_name = 'IpPermissions.1.Groups.1.GroupName'\n            params[param_name] = src_security_group_name\n        if src_security_group_group_id:\n            param_name = 'IpPermissions.1.Groups.1.GroupId'\n            params[param_name] = src_security_group_group_id\n        if src_security_group_owner_id:\n            param_name = 'IpPermissions.1.Groups.1.UserId'\n            params[param_name] = src_security_group_owner_id\n        if ip_protocol:\n            params['IpPermissions.1.IpProtocol'] = ip_protocol\n        if from_port is not None:\n            params['IpPermissions.1.FromPort'] = from_port\n        if to_port is not None:\n            params['IpPermissions.1.ToPort'] = to_port\n        if cidr_ip:\n            params['IpPermissions.1.IpRanges.1.CidrIp'] = cidr_ip\n        return self.get_status('RevokeSecurityGroupIngress',\n                               params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_regions(self, region_names=None, filters=None):\n        params = {}\n        if region_names:\n            self.build_list_params(params, region_names, 'RegionName')\n        if filters:\n            self.build_filter_params(params, filters)\n        regions =  self.get_list('DescribeRegions', params,\n                                 [('item', RegionInfo)], verb='POST')\n        for region in regions:\n            region.connection_cls = EC2Connection\n        return regions", "response": "Get all available regions for the EC2 service."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all available Reserved Instances offerings for a specific language.", "response": "def get_all_reserved_instances_offerings(self, reserved_instances_id=None,\n                                             instance_type=None,\n                                             availability_zone=None,\n                                             product_description=None,\n                                             filters=None):\n        \"\"\"\n        Describes Reserved Instance offerings that are available for purchase.\n\n        :type reserved_instances_id: str\n        :param reserved_instances_id: Displays Reserved Instances with the\n                                      specified offering IDs.\n\n        :type instance_type: str\n        :param instance_type: Displays Reserved Instances of the specified\n                              instance type.\n\n        :type availability_zone: str\n        :param availability_zone: Displays Reserved Instances within the\n                                  specified Availability Zone.\n\n        :type product_description: str\n        :param product_description: Displays Reserved Instances with the\n                                    specified product description.\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n                        the results returned.  Filters are provided\n                        in the form of a dictionary consisting of\n                        filter names as the key and filter values\n                        as the value.  The set of allowable filter\n                        names/values is dependent on the request\n                        being performed.  Check the EC2 API guide\n                        for details.\n\n        :rtype: list\n        :return: A list of :class:`boto.ec2.reservedinstance.ReservedInstancesOffering`\n        \"\"\"\n        params = {}\n        if reserved_instances_id:\n            params['ReservedInstancesId'] = reserved_instances_id\n        if instance_type:\n            params['InstanceType'] = instance_type\n        if availability_zone:\n            params['AvailabilityZone'] = availability_zone\n        if product_description:\n            params['ProductDescription'] = product_description\n        if filters:\n            self.build_filter_params(params, filters)\n\n        return self.get_list('DescribeReservedInstancesOfferings',\n                             params, [('item', ReservedInstancesOffering)],\n                             verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget all available Reserved Instances.", "response": "def get_all_reserved_instances(self, reserved_instances_id=None,\n                                   filters=None):\n        \"\"\"\n        Describes Reserved Instance offerings that are available for purchase.\n\n        :type reserved_instance_ids: list\n        :param reserved_instance_ids: A list of the reserved instance ids that\n                                      will be returned. If not provided, all\n                                      reserved instances will be returned.\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n                        the results returned.  Filters are provided\n                        in the form of a dictionary consisting of\n                        filter names as the key and filter values\n                        as the value.  The set of allowable filter\n                        names/values is dependent on the request\n                        being performed.  Check the EC2 API guide\n                        for details.\n\n        :rtype: list\n        :return: A list of :class:`boto.ec2.reservedinstance.ReservedInstance`\n        \"\"\"\n        params = {}\n        if reserved_instances_id:\n            self.build_list_params(params, reserved_instances_id,\n                                   'ReservedInstancesId')\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeReservedInstances',\n                             params, [('item', ReservedInstance)], verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef purchase_reserved_instance_offering(self,\n                                            reserved_instances_offering_id,\n                                            instance_count=1):\n        \"\"\"\n        Purchase a Reserved Instance for use with your account.\n        ** CAUTION **\n        This request can result in large amounts of money being charged to your\n        AWS account.  Use with caution!\n\n        :type reserved_instances_offering_id: string\n        :param reserved_instances_offering_id: The offering ID of the Reserved\n                                               Instance to purchase\n\n        :type instance_count: int\n        :param instance_count: The number of Reserved Instances to purchase.\n                               Default value is 1.\n\n        :rtype: :class:`boto.ec2.reservedinstance.ReservedInstance`\n        :return: The newly created Reserved Instance\n        \"\"\"\n        params = {\n            'ReservedInstancesOfferingId' : reserved_instances_offering_id,\n            'InstanceCount' : instance_count}\n        return self.get_object('PurchaseReservedInstancesOffering', params,\n                               ReservedInstance, verb='POST')", "response": "This method creates a new Reserved Instance for use with your account. You must be authenticated with an admin privilege. You must have permission to manage this resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nenables CloudWatch monitoring for the supplied instances.", "response": "def monitor_instances(self, instance_ids):\n        \"\"\"\n        Enable CloudWatch monitoring for the supplied instances.\n\n        :type instance_id: list of strings\n        :param instance_id: The instance ids\n\n        :rtype: list\n        :return: A list of :class:`boto.ec2.instanceinfo.InstanceInfo`\n        \"\"\"\n        params = {}\n        self.build_list_params(params, instance_ids, 'InstanceId')\n        return self.get_list('MonitorInstances', params,\n                             [('item', InstanceInfo)], verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unmonitor_instances(self, instance_ids):\n        params = {}\n        self.build_list_params(params, instance_ids, 'InstanceId')\n        return self.get_list('UnmonitorInstances', params,\n                             [('item', InstanceInfo)], verb='POST')", "response": "Disable CloudWatch monitoring for the supplied instances."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbundles Windows instance. :type instance_id: string :param instance_id: The instance id :type s3_bucket: string :param s3_bucket: The bucket in which the AMI should be stored. :type s3_prefix: string :param s3_prefix: The beginning of the file name for the AMI. :type s3_upload_policy: string :param s3_upload_policy: Base64 encoded policy that specifies condition and permissions for Amazon EC2 to upload the user's image into Amazon S3.", "response": "def bundle_instance(self, instance_id,\n                        s3_bucket,\n                        s3_prefix,\n                        s3_upload_policy):\n        \"\"\"\n        Bundle Windows instance.\n\n        :type instance_id: string\n        :param instance_id: The instance id\n\n        :type s3_bucket: string\n        :param s3_bucket: The bucket in which the AMI should be stored.\n\n        :type s3_prefix: string\n        :param s3_prefix: The beginning of the file name for the AMI.\n\n        :type s3_upload_policy: string\n        :param s3_upload_policy: Base64 encoded policy that specifies condition\n                                 and permissions for Amazon EC2 to upload the\n                                 user's image into Amazon S3.\n        \"\"\"\n\n        params = {'InstanceId' : instance_id,\n                  'Storage.S3.Bucket' : s3_bucket,\n                  'Storage.S3.Prefix' : s3_prefix,\n                  'Storage.S3.UploadPolicy' : s3_upload_policy}\n        s3auth = boto.auth.get_auth_handler(None, boto.config,\n                                            self.provider, ['s3'])\n        params['Storage.S3.AWSAccessKeyId'] = self.aws_access_key_id\n        signature = s3auth.sign_string(s3_upload_policy)\n        params['Storage.S3.UploadPolicySignature'] = signature\n        return self.get_object('BundleInstance', params,\n                               BundleInstanceTask, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving all bundling tasks for the specified bundle ids.", "response": "def get_all_bundle_tasks(self, bundle_ids=None, filters=None):\n        \"\"\"\n        Retrieve current bundling tasks. If no bundle id is specified, all\n        tasks are retrieved.\n\n        :type bundle_ids: list\n        :param bundle_ids: A list of strings containing identifiers for\n                           previously created bundling tasks.\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n                        the results returned.  Filters are provided\n                        in the form of a dictionary consisting of\n                        filter names as the key and filter values\n                        as the value.  The set of allowable filter\n                        names/values is dependent on the request\n                        being performed.  Check the EC2 API guide\n                        for details.\n\n        \"\"\"\n\n        params = {}\n        if bundle_ids:\n            self.build_list_params(params, bundle_ids, 'BundleId')\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeBundleTasks', params,\n                             [('item', BundleInstanceTask)], verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cancel_bundle_task(self, bundle_id):\n\n        params = {'BundleId' : bundle_id}\n        return self.get_object('CancelBundleTask', params,\n                               BundleInstanceTask, verb='POST')", "response": "Cancel a previously submitted bundle task."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_password_data(self, instance_id):\n\n        params = {'InstanceId' : instance_id}\n        rs = self.get_object('GetPasswordData', params, ResultSet, verb='POST')\n        return rs.passwordData", "response": "Get encrypted administrator password for a Windows instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_all_placement_groups(self, groupnames=None, filters=None):\n        params = {}\n        if groupnames:\n            self.build_list_params(params, groupnames, 'GroupName')\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribePlacementGroups', params,\n                             [('item', PlacementGroup)], verb='POST')", "response": "Get all placement groups associated with your account in a region."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_placement_group(self, name, strategy='cluster'):\n        params = {'GroupName':name, 'Strategy':strategy}\n        group = self.get_status('CreatePlacementGroup', params, verb='POST')\n        return group", "response": "Create a placement group for your account."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving all the metadata tags associated with your account.", "response": "def get_all_tags(self, filters=None):\n        \"\"\"\n        Retrieve all the metadata tags associated with your account.\n\n        :type filters: dict\n        :param filters: Optional filters that can be used to limit\n                        the results returned.  Filters are provided\n                        in the form of a dictionary consisting of\n                        filter names as the key and filter values\n                        as the value.  The set of allowable filter\n                        names/values is dependent on the request\n                        being performed.  Check the EC2 API guide\n                        for details.\n\n        :rtype: dict\n        :return: A dictionary containing metadata tags\n        \"\"\"\n        params = {}\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeTags', params,\n                             [('item', Tag)], verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_tags(self, resource_ids, tags):\n        params = {}\n        self.build_list_params(params, resource_ids, 'ResourceId')\n        self.build_tag_param_list(params, tags)\n        return self.get_status('CreateTags', params, verb='POST')", "response": "Create new metadata tags for the specified resource ids."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_tags(self, resource_ids, tags):\n        if isinstance(tags, list):\n            tags = {}.fromkeys(tags, None)\n        params = {}\n        self.build_list_params(params, resource_ids, 'ResourceId')\n        self.build_tag_param_list(params, tags)\n        return self.get_status('DeleteTags', params, verb='POST')", "response": "Delete metadata tags for the specified resource ids."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_network_interfaces(self, filters=None):\n        params = {}\n        if filters:\n            self.build_filter_params(params, filters)\n        return self.get_list('DescribeNetworkInterfaces', params,\n                             [('item', NetworkInterface)], verb='POST')", "response": "Retrieve all Elastic Network Interfaces associated with your account."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_network_interface(self, subnet_id, private_ip_address=None,\n                                 description=None, groups=None):\n        \"\"\"\n        Creates a network interface in the specified subnet.\n\n        :type subnet_id: str\n        :param subnet_id: The ID of the subnet to associate with the\n            network interface.\n\n        :type private_ip_address: str\n        :param private_ip_address: The private IP address of the\n            network interface.  If not supplied, one will be chosen\n            for you.\n\n        :type description: str\n        :param description: The description of the network interface.\n\n        :type groups: list\n        :param groups: Lists the groups for use by the network interface.\n            This can be either a list of group ID's or a list of\n            :class:`boto.ec2.securitygroup.SecurityGroup` objects.\n\n        :rtype: :class:`boto.ec2.networkinterface.NetworkInterface`\n        :return: The newly created network interface.\n        \"\"\"\n        params = {'SubnetId' : subnet_id}\n        if private_ip_address:\n            params['PrivateIpAddress'] = private_ip_address\n        if description:\n            params['Description'] = description\n        if groups:\n            ids = []\n            for group in groups:\n                if isinstance(group, SecurityGroup):\n                    ids.append(group.id)\n                else:\n                    ids.append(group)\n            self.build_list_params(params, ids, 'SecurityGroupId')\n        return self.get_object('CreateNetworkInterface', params,\n                               NetworkInterface, verb='POST')", "response": "Creates a network interface in the specified subnet."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef attach_network_interface(self, network_interface_id,\n                                 instance_id, device_index):\n        \"\"\"\n        Attaches a network interface to an instance.\n\n        :type network_interface_id: str\n        :param network_interface_id: The ID of the network interface to attach.\n\n        :type instance_id: str\n        :param instance_id: The ID of the instance that will be attached\n            to the network interface.\n\n        :type device_index: int\n        :param device_index: The index of the device for the network\n            interface attachment on the instance.\n        \"\"\"\n        params = {'NetworkInterfaceId' : network_interface_id,\n                  'InstanceId' : instance_id,\n                  'Deviceindex' : device_index}\n        return self.get_status('AttachNetworkInterface', params, verb='POST')", "response": "Attaches a network interface to an instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetach a network interface from an instance.", "response": "def detach_network_interface(self, network_interface_id, force=False):\n        \"\"\"\n        Detaches a network interface from an instance.\n\n        :type network_interface_id: str\n        :param network_interface_id: The ID of the network interface to detach.\n\n        :type force: bool\n        :param force: Set to true to force a detachment.\n\n        \"\"\"\n        params = {'NetworkInterfaceId' : network_interface_id}\n        if force:\n            params['Force'] = 'true'\n        return self.get_status('DetachNetworkInterface', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the desired capacity for the group.", "response": "def set_capacity(self, capacity):\n        \"\"\"\n        Set the desired capacity for the group.\n        \"\"\"\n        params = {'AutoScalingGroupName' : self.name,\n                  'DesiredCapacity'      : capacity}\n        req = self.connection.get_object('SetDesiredCapacity', params,\n                                         Request)\n        self.connection.last_request = req\n        return req"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef shutdown_instances(self):\n        self.min_size = 0\n        self.max_size = 0\n        self.desired_capacity = 0\n        self.update()", "response": "This method is used to shutdown all the instances associated with this group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(self, force_delete=False):\n        return self.connection.delete_auto_scaling_group(self.name, force_delete)", "response": "Delete this auto - scaling group."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all activities for this group.", "response": "def get_activities(self, activity_ids=None, max_records=50):\n        \"\"\"\n        Get all activies for this group.\n        \"\"\"\n        return self.connection.get_all_activities(self, activity_ids,\n                                                  max_records)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting the groups that match the specified path prefix.", "response": "def get_all_groups(self, path_prefix='/', marker=None, max_items=None):\n        \"\"\"\n        List the groups that have the specified path prefix.\n\n        :type path_prefix: string\n        :param path_prefix: If provided, only groups whose paths match\n                            the provided prefix will be returned.\n\n        :type marker: string\n        :param marker: Use this only when paginating results and only in\n                       follow-up request after you've received a response\n                       where the results are truncated.  Set this to the\n                       value of the Marker element in the response you\n                       just received.\n\n        :type max_items: int\n        :param max_items: Use this only when paginating results to indicate\n                          the maximum number of groups you want in the\n                          response.\n        \"\"\"\n        params = {}\n        if path_prefix:\n            params['PathPrefix'] = path_prefix\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        return self.get_response('ListGroups', params,\n                                 list_marker='Groups')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_group(self, group_name, marker=None, max_items=None):\n        params = {'GroupName' : group_name}\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        return self.get_response('GetGroup', params, list_marker='Users')", "response": "Get a list of users in a group."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_group(self, group_name, path='/'):\n        params = {'GroupName' : group_name,\n                  'Path' : path}\n        return self.get_response('CreateGroup', params)", "response": "Create a new group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_group(self, group_name, new_group_name=None, new_path=None):\n        params = {'GroupName' : group_name}\n        if new_group_name:\n            params['NewGroupName'] = new_group_name\n        if new_path:\n            params['NewPath'] = new_path\n        return self.get_response('UpdateGroup', params)", "response": "Updates the name and path of the specified group."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_user_to_group(self, group_name, user_name):\n        params = {'GroupName' : group_name,\n                  'UserName' : user_name}\n        return self.get_response('AddUserToGroup', params)", "response": "Add a user to a group"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a user from a group.", "response": "def remove_user_from_group(self, group_name, user_name):\n        \"\"\"\n        Remove a user from a group.\n\n        :type group_name: string\n        :param group_name: The name of the group\n\n        :type user_name: string\n        :param user_name: The user to remove from the group.\n\n        \"\"\"\n        params = {'GroupName' : group_name,\n                  'UserName' : user_name}\n        return self.get_response('RemoveUserFromGroup', params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd or updates the specified policy document for the specified group.", "response": "def put_group_policy(self, group_name, policy_name, policy_json):\n        \"\"\"\n        Adds or updates the specified policy document for the specified group.\n\n        :type group_name: string\n        :param group_name: The name of the group the policy is associated with.\n\n        :type policy_name: string\n        :param policy_name: The policy document to get.\n\n        :type policy_json: string\n        :param policy_json: The policy document.\n        \n        \"\"\"\n        params = {'GroupName' : group_name,\n                  'PolicyName' : policy_name,\n                  'PolicyDocument' : policy_json}\n        return self.get_response('PutGroupPolicy', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the names of the policies associated with the specified group.", "response": "def get_all_group_policies(self, group_name, marker=None, max_items=None):\n        \"\"\"\n        List the names of the policies associated with the specified group.\n\n        :type group_name: string\n        :param group_name: The name of the group the policy is associated with.\n\n        :type marker: string\n        :param marker: Use this only when paginating results and only in\n                       follow-up request after you've received a response\n                       where the results are truncated.  Set this to the\n                       value of the Marker element in the response you\n                       just received.\n\n        :type max_items: int\n        :param max_items: Use this only when paginating results to indicate\n                          the maximum number of groups you want in the\n                          response.\n        \"\"\"\n        params = {'GroupName' : group_name}\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        return self.get_response('ListGroupPolicies', params,\n                                 list_marker='PolicyNames')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_group_policy(self, group_name, policy_name):\n        params = {'GroupName' : group_name,\n                  'PolicyName' : policy_name}\n        return self.get_response('GetGroupPolicy', params, verb='POST')", "response": "Retrieves the specified policy document for the specified group."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_group_policy(self, group_name, policy_name):\n        params = {'GroupName' : group_name,\n                  'PolicyName' : policy_name}\n        return self.get_response('DeleteGroupPolicy', params, verb='POST')", "response": "Deletes the specified policy document for the specified group."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting the users that have the specified path prefix.", "response": "def get_all_users(self, path_prefix='/', marker=None, max_items=None):\n        \"\"\"\n        List the users that have the specified path prefix.\n\n        :type path_prefix: string\n        :param path_prefix: If provided, only users whose paths match\n                            the provided prefix will be returned.\n\n        :type marker: string\n        :param marker: Use this only when paginating results and only in\n                       follow-up request after you've received a response\n                       where the results are truncated.  Set this to the\n                       value of the Marker element in the response you\n                       just received.\n\n        :type max_items: int\n        :param max_items: Use this only when paginating results to indicate\n                          the maximum number of groups you want in the\n                          response.\n        \"\"\"\n        params = {'PathPrefix' : path_prefix}\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        return self.get_response('ListUsers', params, list_marker='Users')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_user(self, user_name, path='/'):\n        params = {'UserName' : user_name,\n                  'Path' : path}\n        return self.get_response('CreateUser', params)", "response": "Create a user.\n\n        :type user_name: string\n        :param user_name: The name of the new user\n\n        :type path: string\n        :param path: The path in which the user will be created.\n                     Defaults to /."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving information about the specified user.", "response": "def get_user(self, user_name=None):\n        \"\"\"\n        Retrieve information about the specified user.\n\n        If the user_name is not specified, the user_name is determined\n        implicitly based on the AWS Access Key ID used to sign the request.\n\n        :type user_name: string\n        :param user_name: The name of the user to delete.\n                          If not specified, defaults to user making\n                          request.\n\n        \"\"\"\n        params = {}\n        if user_name:\n            params['UserName'] = user_name\n        return self.get_response('GetUser', params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the name and path of a user.", "response": "def update_user(self, user_name, new_user_name=None, new_path=None):\n        \"\"\"\n        Updates name and/or path of the specified user.\n\n        :type user_name: string\n        :param user_name: The name of the user\n\n        :type new_user_name: string\n        :param new_user_name: If provided, the username of the user will be\n                              changed to this username.\n\n        :type new_path: string\n        :param new_path: If provided, the path of the user will be\n                         changed to this path.\n\n        \"\"\"\n        params = {'UserName' : user_name}\n        if new_user_name:\n            params['NewUserName'] = new_user_name\n        if new_path:\n            params['NewPath'] = new_path\n        return self.get_response('UpdateUser', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_all_user_policies(self, user_name, marker=None, max_items=None):\n        params = {'UserName' : user_name}\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        return self.get_response('ListUserPolicies', params,\n                                 list_marker='PolicyNames')", "response": "Get the names of the policies associated with a user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef put_user_policy(self, user_name, policy_name, policy_json):\n        params = {'UserName' : user_name,\n                  'PolicyName' : policy_name,\n                  'PolicyDocument' : policy_json}\n        return self.get_response('PutUserPolicy', params, verb='POST')", "response": "Adds or updates the specified policy document for the specified user."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the specified policy document for the specified user.", "response": "def get_user_policy(self, user_name, policy_name):\n        \"\"\"\n        Retrieves the specified policy document for the specified user.\n\n        :type user_name: string\n        :param user_name: The name of the user the policy is associated with.\n\n        :type policy_name: string\n        :param policy_name: The policy document to get.\n        \n        \"\"\"\n        params = {'UserName' : user_name,\n                  'PolicyName' : policy_name}\n        return self.get_response('GetUserPolicy', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting the specified policy document for the specified user.", "response": "def delete_user_policy(self, user_name, policy_name):\n        \"\"\"\n        Deletes the specified policy document for the specified user.\n\n        :type user_name: string\n        :param user_name: The name of the user the policy is associated with.\n\n        :type policy_name: string\n        :param policy_name: The policy document to delete.\n        \n        \"\"\"\n        params = {'UserName' : user_name,\n                  'PolicyName' : policy_name}\n        return self.get_response('DeleteUserPolicy', params, verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_groups_for_user(self, user_name, marker=None, max_items=None):\n        params = {'UserName' : user_name}\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        return self.get_response('ListGroupsForUser', params,\n                                 list_marker='Groups')", "response": "Returns the list of groups that a specified user belongs to."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_all_access_keys(self, user_name, marker=None, max_items=None):\n        params = {'UserName' : user_name}\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        return self.get_response('ListAccessKeys', params,\n                                 list_marker='AccessKeyMetadata')", "response": "Get all access keys associated with a user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchanging the status of the specified access key from Active to Inactive or vice versa. This action can be used to disable a user's key as part of a key rotation workflow. If the user_name is not specified, the user_name is determined implicitly based on the AWS Access Key ID used to sign the request. :type access_key_id: string :param access_key_id: The ID of the access key. :type status: string :param status: Either Active or Inactive. :type user_name: string :param user_name: The username of user (optional).", "response": "def update_access_key(self, access_key_id, status, user_name=None):\n        \"\"\"\n        Changes the status of the specified access key from Active to Inactive\n        or vice versa.  This action can be used to disable a user's key as\n        part of a key rotation workflow.\n\n        If the user_name is not specified, the user_name is determined\n        implicitly based on the AWS Access Key ID used to sign the request.\n\n        :type access_key_id: string\n        :param access_key_id: The ID of the access key.\n\n        :type status: string\n        :param status: Either Active or Inactive.\n\n        :type user_name: string\n        :param user_name: The username of user (optional).\n\n        \"\"\"\n        params = {'AccessKeyId' : access_key_id,\n                  'Status' : status}\n        if user_name:\n            params['UserName'] = user_name\n        return self.get_response('UpdateAccessKey', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes an access key associated with a user.", "response": "def delete_access_key(self, access_key_id, user_name=None):\n        \"\"\"\n        Delete an access key associated with a user.\n\n        If the user_name is not specified, it is determined implicitly based\n        on the AWS Access Key ID used to sign the request.\n\n        :type access_key_id: string\n        :param access_key_id: The ID of the access key to be deleted.\n\n        :type user_name: string\n        :param user_name: The username of the user\n\n        \"\"\"\n        params = {'AccessKeyId' : access_key_id}\n        if user_name:\n            params['UserName'] = user_name\n        return self.get_response('DeleteAccessKey', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_signing_certs(self, marker=None, max_items=None,\n                              user_name=None):\n        \"\"\"\n        Get all signing certificates associated with an account.\n\n        If the user_name is not specified, it is determined implicitly based\n        on the AWS Access Key ID used to sign the request.\n\n        :type marker: string\n        :param marker: Use this only when paginating results and only in\n                       follow-up request after you've received a response\n                       where the results are truncated.  Set this to the\n                       value of the Marker element in the response you\n                       just received.\n\n        :type max_items: int\n        :param max_items: Use this only when paginating results to indicate\n                          the maximum number of groups you want in the\n                          response.\n                          \n        :type user_name: string\n        :param user_name: The username of the user\n\n        \"\"\"\n        params = {}\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        if user_name:\n            params['UserName'] = user_name\n        return self.get_response('ListSigningCertificates',\n                                 params, list_marker='Certificates')", "response": "Get all signing certificates associated with an account."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_signing_cert(self, cert_id, status, user_name=None):\n        params = {'CertificateId' : cert_id,\n                  'Status' : status}\n        if user_name:\n            params['UserName'] = user_name\n        return self.get_response('UpdateSigningCertificate', params)", "response": "Change the status of the specified signing certificate from Active to Inactive or vice versa."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupload an X. 509 signing certificate and associates it with the specified user.", "response": "def upload_signing_cert(self, cert_body, user_name=None):\n        \"\"\"\n        Uploads an X.509 signing certificate and associates it with\n        the specified user.\n\n        If the user_name is not specified, it is determined implicitly based\n        on the AWS Access Key ID used to sign the request.\n\n        :type cert_body: string\n        :param cert_body: The body of the signing certificate.\n\n        :type user_name: string\n        :param user_name: The username of the user\n\n        \"\"\"\n        params = {'CertificateBody' : cert_body}\n        if user_name:\n            params['UserName'] = user_name\n        return self.get_response('UploadSigningCertificate', params,\n                                 verb='POST')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_signing_cert(self, cert_id, user_name=None):\n        params = {'CertificateId' : cert_id}\n        if user_name:\n            params['UserName'] = user_name\n        return self.get_response('DeleteSigningCertificate', params)", "response": "Delete a signing certificate associated with a user."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists the server certificates that have the specified path prefix. If none exist, the action returns an empty list. :type path_prefix: string :param path_prefix: If provided, only certificates whose paths match the provided prefix will be returned. :type marker: string :param marker: Use this only when paginating results and only in follow-up request after you've received a response where the results are truncated. Set this to the value of the Marker element in the response you just received. :type max_items: int :param max_items: Use this only when paginating results to indicate the maximum number of groups you want in the response.", "response": "def get_all_server_certs(self, path_prefix='/',\n                             marker=None, max_items=None):\n        \"\"\"\n        Lists the server certificates that have the specified path prefix.\n        If none exist, the action returns an empty list.\n\n        :type path_prefix: string\n        :param path_prefix: If provided, only certificates whose paths match\n                            the provided prefix will be returned.\n\n        :type marker: string\n        :param marker: Use this only when paginating results and only in\n                       follow-up request after you've received a response\n                       where the results are truncated.  Set this to the\n                       value of the Marker element in the response you\n                       just received.\n\n        :type max_items: int\n        :param max_items: Use this only when paginating results to indicate\n                          the maximum number of groups you want in the\n                          response.\n                          \n        \"\"\"\n        params = {}\n        if path_prefix:\n            params['PathPrefix'] = path_prefix\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        return self.get_response('ListServerCertificates',\n                                 params,\n                                 list_marker='ServerCertificateMetadataList')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_server_cert(self, cert_name, new_cert_name=None,\n                           new_path=None):\n        \"\"\"\n        Updates the name and/or the path of the specified server certificate.\n\n        :type cert_name: string\n        :param cert_name: The name of the server certificate that you want\n                          to update.\n\n        :type new_cert_name: string\n        :param new_cert_name: The new name for the server certificate.\n                              Include this only if you are updating the\n                              server certificate's name.\n\n        :type new_path: string\n        :param new_path: If provided, the path of the certificate will be\n                         changed to this path.\n        \"\"\"\n        params = {'ServerCertificateName' : cert_name}\n        if new_cert_name:\n            params['NewServerCertificateName'] = new_cert_name\n        if new_path:\n            params['NewPath'] = new_path\n        return self.get_response('UpdateServerCertificate', params)", "response": "Updates the name and path of the specified server certificate."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload_server_cert(self, cert_name, cert_body, private_key,\n                           cert_chain=None, path=None):\n        \"\"\"\n        Uploads a server certificate entity for the AWS Account.\n        The server certificate entity includes a public key certificate,\n        a private key, and an optional certificate chain, which should\n        all be PEM-encoded.\n\n        :type cert_name: string\n        :param cert_name: The name for the server certificate. Do not\n                          include the path in this value.\n\n        :type cert_body: string\n        :param cert_body: The contents of the public key certificate\n                          in PEM-encoded format.\n\n        :type private_key: string\n        :param private_key: The contents of the private key in\n                            PEM-encoded format.\n\n        :type cert_chain: string\n        :param cert_chain: The contents of the certificate chain. This\n                           is typically a concatenation of the PEM-encoded\n                           public key certificates of the chain.\n\n        :type path: string\n        :param path: The path for the server certificate.\n\n        \"\"\"\n        params = {'ServerCertificateName' : cert_name,\n                  'CertificateBody' : cert_body,\n                  'PrivateKey' : private_key}\n        if cert_chain:\n            params['CertificateChain'] = cert_chain\n        if path:\n            params['Path'] = path\n        return self.get_response('UploadServerCertificate', params,\n                                 verb='POST')", "response": "This method uploads a server certificate entity to AWS Account."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_mfa_devices(self, user_name, marker=None, max_items=None):\n        params = {'UserName' : user_name}\n        if marker:\n            params['Marker'] = marker\n        if max_items:\n            params['MaxItems'] = max_items\n        return self.get_response('ListMFADevices',\n                                 params, list_marker='MFADevices')", "response": "Get all MFA devices associated with a user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enable_mfa_device(self, user_name, serial_number,\n                          auth_code_1, auth_code_2):\n        \"\"\"\n        Enables the specified MFA device and associates it with the\n        specified user.\n\n        :type user_name: string\n        :param user_name: The username of the user\n        \n        :type serial_number: string\n        :param seriasl_number: The serial number which uniquely identifies\n                               the MFA device.\n\n        :type auth_code_1: string\n        :param auth_code_1: An authentication code emitted by the device.\n\n        :type auth_code_2: string\n        :param auth_code_2: A subsequent authentication code emitted\n                            by the device.\n\n        \"\"\"\n        params = {'UserName' : user_name,\n                  'SerialNumber' : serial_number,\n                  'AuthenticationCode1' : auth_code_1,\n                  'AuthenticationCode2' : auth_code_2}\n        return self.get_response('EnableMFADevice', params)", "response": "Enables the specified MFA device and associates it with the specified user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef deactivate_mfa_device(self, user_name, serial_number):\n        params = {'UserName' : user_name,\n                  'SerialNumber' : serial_number}\n        return self.get_response('DeactivateMFADevice', params)", "response": "Deactivates the specified MFA device and removes it from the MFA association with the user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_login_profile(self, user_name, password):\n        params = {'UserName' : user_name,\n                  'Password' : password}\n        return self.get_response('CreateLoginProfile', params)", "response": "Creates a login profile for the specified user and password."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the password associated with the user s login profile.", "response": "def update_login_profile(self, user_name, password):\n        \"\"\"\n        Resets the password associated with the user's login profile.\n\n        :type user_name: string\n        :param user_name: The name of the user\n\n        :type password: string\n        :param password: The new password for the user\n\n        \"\"\"\n        params = {'UserName' : user_name,\n                  'Password' : password}\n        return self.get_response('UpdateLoginProfile', params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the URL where IAM users can use their login profile to sign in to this account s console.", "response": "def get_signin_url(self, service='ec2'):\n        \"\"\"\n        Get the URL where IAM users can use their login profile to sign in\n        to this account's console.\n\n        :type service: string\n        :param service: Default service to go to in the console.\n        \"\"\"\n        alias = self.get_account_alias()\n        if not alias:\n            raise Exception('No alias associated with this account.  Please use iam.create_account_alias() first.')\n\n        return \"https://%s.signin.aws.amazon.com/console/%s\" % (alias, service)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread exactly length bytes from file ; raise EOFError if file ends sooner.", "response": "def xread(file, length):\n    \"Read exactly length bytes from file; raise EOFError if file ends sooner.\"\n    data = file.read(length)\n    if len(data) != length:\n        raise EOFError\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef opened(filename, mode):\n    \"Open filename, or do nothing if filename is already an open file object\"\n    if isinstance(filename, str):\n        file = open(filename, mode)\n        try: \n            yield file\n        finally: \n            if not file.closed:\n                file.close()\n    else:\n        yield filename", "response": "Open filename or do nothing if filename is already an open file object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsuppress KeyboardInterrupt exceptions while the context is active.", "response": "def suppress_interrupt():\n    \"\"\"Suppress KeyboardInterrupt exceptions while the context is active.\n    \n    The suppressed interrupt (if any) is raised when the context is exited.\n    \"\"\"\n    interrupted = False\n\n    def sigint_handler(signum, frame):\n        nonlocal interrupted\n        interrupted = True\n    \n    s = signal.signal(signal.SIGINT, sigint_handler)\n    try:\n        yield None\n    finally:\n        signal.signal(signal.SIGINT, s)\n    if interrupted:\n        raise KeyboardInterrupt()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replace_chunk(filename, offset, length, chunk, in_place=True, max_mem=5):\n    with suppress_interrupt():\n        _replace_chunk(filename, offset, length, chunk, in_place, max_mem)", "response": "Replace length bytes of data with chunk starting at offset."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _copy_chunk(src, dst, length):\n    \"Copy length bytes from file src to file dst.\"\n    BUFSIZE = 128 * 1024\n    while length > 0:\n        l = min(BUFSIZE, length)\n        buf = src.read(l)\n        assert len(buf) == l\n        dst.write(buf)\n        length -= l", "response": "Copy length bytes from file src to file dst."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef symbolize(self, dsym_path, image_vmaddr, image_addr,\n                  instruction_addr, cpu_name,\n                  symbolize_inlined=False):\n        \"\"\"Symbolizes a single frame based on the information provided.  If\n        the symbolication fails a `SymbolicationError` is raised.\n\n        `dsym_path` is the path to the dsym file on the file system.\n        `image_vmaddr` is the slide of the image.  For most situations this\n        can just be set to `0`.  If it's zero or unset we will attempt to\n        find the slide from the dsym file.  `image_addr` is the canonical\n        image address as loaded.  `instruction_addr` is the address where the\n        error happened.\n\n        `cpu_name` is the CPU name.  It follows general apple conventions and\n        is used to special case certain behavior and look up the right\n        symbols.  Common names are `armv7` and `arm64`.\n\n        Additionally if `symbolize_inlined` is set to `True` then a list of\n        frames is returned instead which might contain inlined frames.  In\n        that case the return value might be an empty list instead.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError('Symbolizer is closed')\n        dsym_path = normalize_dsym_path(dsym_path)\n\n        image_vmaddr = parse_addr(image_vmaddr)\n        if not image_vmaddr:\n            di = self._symbolizer.get_debug_info(dsym_path)\n            if di is not None:\n                variant = di.get_variant(cpu_name)\n                if variant is not None:\n                    image_vmaddr = variant.vmaddr\n\n        image_addr = parse_addr(image_addr)\n        instruction_addr = parse_addr(instruction_addr)\n        if not is_valid_cpu_name(cpu_name):\n            raise SymbolicationError('\"%s\" is not a valid cpu name' % cpu_name)\n\n        addr = image_vmaddr + instruction_addr - image_addr\n\n        with self._lock:\n            with timedsection('symbolize'):\n                if symbolize_inlined:\n                    return self._symbolizer.symbolize_inlined(\n                        dsym_path, addr, cpu_name)\n                return self._symbolizer.symbolize(\n                    dsym_path, addr, cpu_name)", "response": "Symbolizes a single frame based on the information provided."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsplitting the given package name and returns a tuple ( name ver ).", "response": "def split_package_name(p):\n    \"\"\"Splits the given package name and returns a tuple (name, ver).\"\"\"\n    s = p.split(six.u('=='))\n    if len(s) == 1:\n        return (to_text(s[0]), None)\n    else:\n        return (to_text(s[0]), to_text(s[1]))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a key from the specified key name.", "response": "def lookup(self, key_name, headers=None, callback=None):\n        \"\"\"\n        Deprecated: Please use get_key method.\n        \n        :type key_name: string\n        :param key_name: The name of the key to retrieve\n        \n        :rtype: :class:`boto.s3.key.Key`\n        :returns: A Key object from this bucket.\n        \"\"\"\n        return self.get_key(key_name, headers=headers, callback=callback)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_keys(self, headers=None, callback=None, **params):\n        return self._get_all([('Contents', self.key_class),\n                              ('CommonPrefixes', boto.s3.prefix.Prefix)],\n                              '', headers, callback=callback, **params)", "response": "This method returns a list of all keys in a bucket."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete_key(self, key_name, headers=None,\n                   version_id=None, mfa_token=None, callback=None):\n        \"\"\"\n        Deletes a key from the bucket.  If a version_id is provided,\n        only that version of the key will be deleted.\n        \n        :type key_name: string\n        :param key_name: The key name to delete\n\n        :type version_id: string\n        :param version_id: The version ID (optional)\n        \n        :type mfa_token: tuple or list of strings\n        :param mfa_token: A tuple or list consisting of the serial number\n                          from the MFA device and the current value of\n                          the six-digit token associated with the device.\n                          This value is required anytime you are\n                          deleting versioned objects from a bucket\n                          that has the MFADelete option on the bucket.\n        \"\"\"\n        provider = self.connection.provider\n        if version_id:\n            query_args = 'versionId=%s' % version_id\n        else:\n            query_args = None\n        if mfa_token:\n            if not headers:\n                headers = {}\n            headers[provider.mfa_header] = ' '.join(mfa_token)\n        def key_deleted(response):\n            body = response.read()\n            if response.status != 204:\n                raise provider.storage_response_error(response.status,\n                                                      response.reason, body)\n            if callable(callback):\n                callback(True)\n        self.connection.make_request('DELETE', self.name, key_name,\n                                     headers=headers,\n                                     query_args=query_args, callback=key_deleted)", "response": "Delete a key from the bucket."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_request(self, action, body='', object_hook=None):\n        headers = {'X-Amz-Target' : '%s_%s.%s' % (self.ServiceName,\n                                                  self.Version, action),\n                   'Content-Type' : 'application/x-amz-json-1.0',\n                   'Content-Length' : str(len(body))}\n        http_request = self.build_base_http_request('POST', '/', '/',\n                                                    {}, headers, body, None)\n        response = self._mexe(http_request, sender=None,\n                              override_num_retries=10,\n                              retry_handler=self._retry_handler)\n        response_body = response.read()\n        boto.log.debug(response_body)\n        return json.loads(response_body, object_hook=object_hook)", "response": "Make a request to DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_tables(self, limit=None, start_table=None):\n        data = {}\n        if limit:\n            data['Limit'] = limit\n        if start_table:\n            data['ExclusiveStartTableName'] = start_table\n        json_input = json.dumps(data)\n        return self.make_request('ListTables', json_input)", "response": "List tables associated with the current account and endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndescribe the current state of the table including the current state of the table primary key schema and when the table was created.", "response": "def describe_table(self, table_name):\n        \"\"\"\n        Returns information about the table including current\n        state of the table, primary key schema and when the\n        table was created.\n\n        :type table_name: str\n        :param table_name: The name of the table to describe.\n        \"\"\"\n        data = {'TableName' : table_name}\n        json_input = json.dumps(data)\n        return self.make_request('DescribeTable', json_input)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new table in DynamoDB.", "response": "def create_table(self, table_name, schema, provisioned_throughput):\n        \"\"\"\n        Add a new table to your account.  The table name must be unique\n        among those associated with the account issuing the request.\n        This request triggers an asynchronous workflow to begin creating\n        the table.  When the workflow is complete, the state of the\n        table will be ACTIVE.\n\n        :type table_name: str\n        :param table_name: The name of the table to create.\n        \n        :type schema: dict\n        :param schema: A Python version of the KeySchema data structure\n            as defined by DynamoDB\n\n        :type provisioned_throughput: dict\n        :param provisioned_throughput: A Python version of the\n            ProvisionedThroughput data structure defined by\n            DynamoDB.\n        \n        \"\"\"\n        data = {'TableName' : table_name,\n                'KeySchema' : schema,\n                'ProvisionedThroughput': provisioned_throughput}\n        json_input = json.dumps(data)\n        response_dict = self.make_request('CreateTable', json_input)\n        return response_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_table(self, table_name, provisioned_throughput):\n        data = {'TableName': table_name,\n                'ProvisionedThroughput': provisioned_throughput}\n        json_input = json.dumps(data)\n        return self.make_request('UpdateTable', json_input)", "response": "Updates the provisioned throughput for a given table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_table(self, table_name):\n        data = {'TableName': table_name}\n        json_input = json.dumps(data)\n        return self.make_request('DeleteTable', json_input)", "response": "Deletes the table and all of it s data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_item(self, table_name, key, attributes_to_get=None,\n                 consistent_read=False, object_hook=None):\n        \"\"\"\n        Return a set of attributes for an item that matches\n        the supplied key.\n\n        :type table_name: str\n        :param table_name: The name of the table containing the item.\n\n        :type key: dict\n        :param key: A Python version of the Key data structure\n            defined by DynamoDB.\n\n        :type attributes_to_get: list\n        :param attributes_to_get: A list of attribute names.\n            If supplied, only the specified attribute names will\n            be returned.  Otherwise, all attributes will be returned.\n\n        :type consistent_read: bool\n        :param consistent_read: If True, a consistent read\n            request is issued.  Otherwise, an eventually consistent\n            request is issued.\n        \"\"\"\n        data = {'TableName': table_name,\n                'Key': key}\n        if attributes_to_get:\n            data['AttributesToGet'] = attributes_to_get\n        if consistent_read:\n            data['ConsistentRead'] = True\n        json_input = json.dumps(data)\n        response = self.make_request('GetItem', json_input,\n                                     object_hook=object_hook)\n        if not response.has_key('Item'):\n            raise dynamodb_exceptions.DynamoDBKeyNotFoundError(\n                \"Key does not exist.\"\n            )\n        return response", "response": "Get an item that matches the supplied key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef batch_get_item(self, request_items, object_hook=None):\n        data = {'RequestItems' : request_items}\n        json_input = json.dumps(data)\n        return self.make_request('BatchGetItem', json_input,\n                                 object_hook=object_hook)", "response": "This method is used to make a request to get a set of attributes for a multiple items in\n            multiple tables using their primary keys using their primary keys."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put_item(self, table_name, item,\n                 expected=None, return_values=None,\n                 object_hook=None):\n        \"\"\"\n        Create a new item or replace an old item with a new\n        item (including all attributes).  If an item already\n        exists in the specified table with the same primary\n        key, the new item will completely replace the old item.\n        You can perform a conditional put by specifying an\n        expected rule.\n\n        :type table_name: str\n        :param table_name: The name of the table in which to put the item.\n\n        :type item: dict\n        :param item: A Python version of the Item data structure\n            defined by DynamoDB.\n\n        :type expected: dict\n        :param expected: A Python version of the Expected\n            data structure defined by DynamoDB.\n\n        :type return_values: str\n        :param return_values: Controls the return of attribute\n            name-value pairs before then were changed.  Possible\n            values are: None or 'ALL_OLD'. If 'ALL_OLD' is\n            specified and the item is overwritten, the content\n            of the old item is returned.\n        \"\"\"\n        data = {'TableName' : table_name,\n                'Item' : item}\n        if expected:\n            data['Expected'] = expected\n        if return_values:\n            data['ReturnValues'] = return_values\n        json_input = json.dumps(data)\n        return self.make_request('PutItem', json_input,\n                                 object_hook=object_hook)", "response": "Create a new item or replace an existing item with a new one."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting an item and all of its attributes by primary key.", "response": "def delete_item(self, table_name, key,\n                    expected=None, return_values=None,\n                    object_hook=None):\n        \"\"\"\n        Delete an item and all of it's attributes by primary key.\n        You can perform a conditional delete by specifying an\n        expected rule.\n\n        :type table_name: str\n        :param table_name: The name of the table containing the item.\n\n        :type key: dict\n        :param key: A Python version of the Key data structure\n            defined by DynamoDB.\n\n        :type expected: dict\n        :param expected: A Python version of the Expected\n            data structure defined by DynamoDB.\n\n        :type return_values: str\n        :param return_values: Controls the return of attribute\n            name-value pairs before then were changed.  Possible\n            values are: None or 'ALL_OLD'. If 'ALL_OLD' is\n            specified and the item is overwritten, the content\n            of the old item is returned.\n        \"\"\"\n        data = {'TableName' : table_name,\n                'Key' : key}\n        if expected:\n            data['Expected'] = expected\n        if return_values:\n            data['ReturnValues'] = return_values\n        json_input = json.dumps(data)\n        return self.make_request('DeleteItem', json_input,\n                                 object_hook=object_hook)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms a query of DynamoDB. This version is currently punting and expecting you to provide a full and correct JSON body which is passed as is to DynamoDB. :type table_name: str :param table_name: The name of the table to query. :type hash_key_value: dict :param key: A DynamoDB-style HashKeyValue. :type range_key_conditions: dict :param range_key_conditions: A Python version of the RangeKeyConditions data structure. :type attributes_to_get: list :param attributes_to_get: A list of attribute names. If supplied, only the specified attribute names will be returned. Otherwise, all attributes will be returned. :type limit: int :param limit: The maximum number of items to return. :type consistent_read: bool :param consistent_read: If True, a consistent read request is issued. Otherwise, an eventually consistent request is issued. :type scan_index_forward: bool :param scan_index_forward: Specified forward or backward traversal of the index. Default is forward (True). :type exclusive_start_key: list or tuple :param exclusive_start_key: Primary key of the item from which to continue an earlier query. This would be provided as the LastEvaluatedKey in that query.", "response": "def query(self, table_name, hash_key_value, range_key_conditions=None,\n              attributes_to_get=None, limit=None, consistent_read=False,\n              scan_index_forward=True, exclusive_start_key=None,\n              object_hook=None):\n        \"\"\"\n        Perform a query of DynamoDB.  This version is currently punting\n        and expecting you to provide a full and correct JSON body\n        which is passed as is to DynamoDB.\n\n        :type table_name: str\n        :param table_name: The name of the table to query.\n\n        :type hash_key_value: dict\n        :param key: A DynamoDB-style HashKeyValue.\n\n        :type range_key_conditions: dict\n        :param range_key_conditions: A Python version of the\n            RangeKeyConditions data structure.\n\n        :type attributes_to_get: list\n        :param attributes_to_get: A list of attribute names.\n            If supplied, only the specified attribute names will\n            be returned.  Otherwise, all attributes will be returned.\n\n        :type limit: int\n        :param limit: The maximum number of items to return.\n\n        :type consistent_read: bool\n        :param consistent_read: If True, a consistent read\n            request is issued.  Otherwise, an eventually consistent\n            request is issued.\n\n        :type scan_index_forward: bool\n        :param scan_index_forward: Specified forward or backward\n            traversal of the index.  Default is forward (True).\n\n        :type exclusive_start_key: list or tuple\n        :param exclusive_start_key: Primary key of the item from\n            which to continue an earlier query.  This would be\n            provided as the LastEvaluatedKey in that query.\n        \"\"\"\n        data = {'TableName': table_name,\n                'HashKeyValue': hash_key_value}\n        if range_key_conditions:\n            data['RangeKeyCondition'] = range_key_conditions\n        if attributes_to_get:\n            data['AttributesToGet'] = attributes_to_get\n        if limit:\n            data['Limit'] = limit\n        if consistent_read:\n            data['ConsistentRead'] = True\n        if scan_index_forward:\n            data['ScanIndexForward'] = True\n        else:\n            data['ScanIndexForward'] = False\n        if exclusive_start_key:\n            data['ExclusiveStartKey'] = exclusive_start_key\n        json_input = json.dumps(data)\n        return self.make_request('Query', json_input,\n                                 object_hook=object_hook)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef scan(self, table_name, scan_filter=None,\n             attributes_to_get=None, limit=None,\n             count=False, exclusive_start_key=None,\n             object_hook=None):\n        \"\"\"\n        Perform a scan of DynamoDB.  This version is currently punting\n        and expecting you to provide a full and correct JSON body\n        which is passed as is to DynamoDB.\n\n        :type table_name: str\n        :param table_name: The name of the table to scan.\n\n        :type scan_filter: dict\n        :param scan_filter: A Python version of the\n            ScanFilter data structure.\n\n        :type attributes_to_get: list\n        :param attributes_to_get: A list of attribute names.\n            If supplied, only the specified attribute names will\n            be returned.  Otherwise, all attributes will be returned.\n\n        :type limit: int\n        :param limit: The maximum number of items to return.\n\n        :type count: bool\n        :param count: If True, Amazon DynamoDB returns a total\n            number of items for the Scan operation, even if the\n            operation has no matching items for the assigned filter.\n\n        :type exclusive_start_key: list or tuple\n        :param exclusive_start_key: Primary key of the item from\n            which to continue an earlier query.  This would be\n            provided as the LastEvaluatedKey in that query.\n        \"\"\"\n        data = {'TableName': table_name}\n        if scan_filter:\n            data['ScanFilter'] = scan_filter\n        if attributes_to_get:\n            data['AttributesToGet'] = attributes_to_get\n        if limit:\n            data['Limit'] = limit\n        if count:\n            data['Count'] = True\n        if exclusive_start_key:\n            data['ExclusiveStartKey'] = exclusive_start_key\n        json_input = json.dumps(data)\n        return self.make_request('Scan', json_input, object_hook=object_hook)", "response": "Perform a scan of DynamoDB."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_bg(img, th=(240, 255)):\n    if img.size == 0:\n        return img\n\n    img = gray3(img)\n\n    # delete rows with complete background color\n    h, w = img.shape[:2]\n    i = 0\n    while i < h:\n        mask = np.logical_or(img[i, :, :] < th[0], img[i, :, :] > th[1])\n        if not mask.any():\n            img = np.delete(img, i, axis=0)\n            i -= 1\n            h -= 1\n        i += 1\n\n    # if image is complete background only\n    if img.size == 0:\n        return img\n\n    # delete columns with complete background color\n    h, w = img.shape[:2]\n    i = 0\n    while i < w:\n        mask = np.logical_or(img[:, i, :] < th[0], img[:, i, :] > th[1])\n        if not mask.any():\n            img = np.delete(img, i, axis=1)\n            i -= 1\n            w -= 1\n        i += 1\n\n    return img", "response": "Removes similar colored background in the given image."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_bg(img, padding, color=COL_WHITE):\n    img = gray3(img)\n    h, w, d = img.shape\n    new_img = np.ones((h + 2*padding, w + 2*padding, d)) * color[:d]\n    new_img = new_img.astype(np.uint8)\n    set_img_box(new_img, (padding, padding, w, h), img)\n    return new_img", "response": "Adds a padding to the given image as background of specified color."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nselects the sub - image inside the given box from the main image", "response": "def img_box(img, box):\n    \"\"\"\n    Selects the sub-image inside the given box\n\n    :param img: Image to crop from\n    :param box: Box to crop from. Box can be either Box object or array of [x, y, width, height]\n    :return: Cropped sub-image from the main image\n    \"\"\"\n    if isinstance(box, tuple):\n        box = Box.from_tup(box)\n\n    if len(img.shape) == 3:\n        return img[box.y:box.y + box.height, box.x:box.x + box.width, :]\n    else:\n        return img[box.y:box.y + box.height, box.x:box.x + box.width]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the given text in the image.", "response": "def add_text_img(img, text, pos, box=None, color=None, thickness=1, scale=1, vertical=False):\n    \"\"\"\n    Adds the given text in the image.\n\n    :param img: Input image\n    :param text: String text\n    :param pos: (x, y) in the image or relative to the given Box object\n    :param box: Box object. If not None, the text is placed inside the box.\n    :param color: Color of the text.\n    :param thickness: Thickness of the font.\n    :param scale: Font size scale.\n    :param vertical: If true, the text is displayed vertically. (slow)\n    :return:\n    \"\"\"\n    if color is None:\n        color = COL_WHITE\n\n    text = str(text)\n    top_left = pos\n    if box is not None:\n        top_left = box.move(pos).to_int().top_left()\n        if top_left[0] > img.shape[1]:\n            return\n\n    if vertical:\n        if box is not None:\n            h, w, d = box.height, box.width, 3\n        else:\n            h, w, d = img.shape\n        txt_img = np.zeros((w, h, d), dtype=np.uint8)\n        # 90 deg rotation\n        top_left = h - pos[1], pos[0]\n        cv.putText(txt_img, text, top_left, cv.FONT_HERSHEY_PLAIN, scale, color, thickness)\n\n        txt_img = ndimage.rotate(txt_img, 90)\n        mask = txt_img > 0\n        if box is not None:\n            im_box = img_box(img, box)\n            im_box[mask] = txt_img[mask]\n        else:\n            img[mask] = txt_img[mask]\n    else:\n        cv.putText(img, text, top_left, cv.FONT_HERSHEY_PLAIN, scale, color, thickness)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a bounding box inside the image.", "response": "def add_rect(img, box, color=None, thickness=1):\n    \"\"\"\n    Draws a bounding box inside the image.\n\n    :param img: Input image\n    :param box: Box object that defines the bounding box.\n    :param color: Color of the box\n    :param thickness: Thickness of line\n    :return: Rectangle added image\n    \"\"\"\n    if color is None:\n        color = COL_GRAY\n\n    box = box.to_int()\n    cv.rectangle(img, box.top_left(), box.bottom_right(), color, thickness)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots multiple images using matplotlib AttributeNames by dynamically finding the required number of rows and cols.", "response": "def imshow(*imgs, **options):\n    \"\"\"\n    Plots multiple images using matplotlib\n        by dynamically finding the required number of rows and cols.\n    :param imgs: Images as any number of arguments\n    :param options: Dict of options\n        - cmap: Color map for gray scale images\n        - vmin: Minimum value to be used in color map\n        - vmax: Maximum value to be used in color map\n    \"\"\"\n    n = len(imgs)\n    nrows = int(math.ceil(math.sqrt(n)))\n    ncols = int(math.ceil(n / nrows))\n    for row in range(nrows):\n        for col in range(ncols):\n            i = row * ncols + col\n            if i >= n:\n                break\n            plt.subplot(nrows, ncols, i+1)\n            show_img(imgs[i], options)\n    plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef collage(imgs, size, padding=10, bg=COL_BLACK):\n    # make 2d array\n    if not isinstance(imgs[0], list):\n        imgs = [imgs]\n\n    h, w = imgs[0][0].shape[:2]\n    nrows, ncols = size\n    nr, nc = nrows * h + (nrows-1) * padding, ncols * w + (ncols-1) * padding\n\n    res = np.ones((nr, nc, 3), dtype=np.uint8) * np.array(bg, dtype=np.uint8)\n\n    for r in range(nrows):\n        for c in range(ncols):\n            img = imgs[r][c]\n\n            if is_gray(img):\n                img = gray3ch(img)\n\n            rs = r * (h + padding)\n            re = rs + h\n\n            cs = c * (w + padding)\n            ce = cs + w\n\n            res[rs:re, cs:ce, :] = img\n\n    return res", "response": "Construct a collage of same - sized images with specified padding."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread and iterates through each image file in the given directory.", "response": "def each_img(img_dir):\n    \"\"\"\n    Reads and iterates through each image file in the given directory\n    \"\"\"\n    for fname in utils.each_img(img_dir):\n        fname = os.path.join(img_dir, fname)\n        yield cv.imread(fname), fname"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an alarm action represented as an SNS topic to this alarm.", "response": "def add_alarm_action(self, action_arn=None):\n        \"\"\"\n        Adds an alarm action, represented as an SNS topic, to this alarm. \n        What do do when alarm is triggered.\n\n        :type action_arn: str\n        :param action_arn: SNS topics to which notification should be \n                           sent if the alarm goes to state ALARM.\n        \"\"\"\n        if not action_arn:\n            return # Raise exception instead?\n        self.actions_enabled = 'true'\n        self.alarm_actions.append(action_arn)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an insufficient_data action to the alarm.", "response": "def add_insufficient_data_action(self, action_arn=None):\n        \"\"\"\n        Adds an insufficient_data action, represented as an SNS topic, to\n        this alarm. What to do when the insufficient_data state is reached.\n\n        :type action_arn: str\n        :param action_arn: SNS topics to which notification should be \n                           sent if the alarm goes to state INSUFFICIENT_DATA.\n        \"\"\"\n        if not action_arn:\n            return\n        self.actions_enabled = 'true'\n        self.insufficient_data_actions.append(action_arn)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd an ok action to this alarm.", "response": "def add_ok_action(self, action_arn=None):\n        \"\"\"\n        Adds an ok action, represented as an SNS topic, to this alarm. What\n        to do when the ok state is reached.\n\n        :type action_arn: str\n        :param action_arn: SNS topics to which notification should be \n                           sent if the alarm goes to state INSUFFICIENT_DATA.\n        \"\"\"\n        if not action_arn:\n            return\n        self.actions_enabled = 'true'\n        self.ok_actions.append(action_arn)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_session_token(self, duration=None, force_new=False):\n        token_key = '%s:%s' % (self.region.name, self.provider.access_key)\n        token = self._check_token_cache(token_key, duration)\n        if force_new or not token:\n            boto.log.debug('fetching a new token for %s' % token_key)\n            self._mutex.acquire()\n            token = self._get_session_token(duration)\n            _session_token_cache[token_key] = token\n            self._mutex.release()\n        return token", "response": "Get a valid session token from the Secure Token Service."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_federation_token(self, name, duration=None, policy=None):\n        params = {'Name' : name}\n        if duration:\n            params['DurationSeconds'] = duration\n        if policy:\n            params['Policy'] = policy\n        return self.get_object('GetFederationToken', params,\n                                FederationToken, verb='POST')", "response": "Get a Federation Token for a user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the attributes of a topic.", "response": "def set_topic_attributes(self, topic, attr_name, attr_value):\n        \"\"\"\n        Get attributes of a Topic\n\n        :type topic: string\n        :param topic: The ARN of the topic.\n\n        :type attr_name: string\n        :param attr_name: The name of the attribute you want to set.\n                          Only a subset of the topic's attributes are mutable.\n                          Valid values: Policy | DisplayName\n\n        :type attr_value: string\n        :param attr_value: The new value for the attribute.\n\n        \"\"\"\n        params = {'ContentType' : 'JSON',\n                  'TopicArn' : topic,\n                  'AttributeName' : attr_name,\n                  'AttributeValue' : attr_value}\n        response = self.make_request('SetTopicAttributes', params, '/', 'GET')\n        body = response.read()\n        if response.status == 200:\n            return json.loads(body)\n        else:\n            boto.log.error('%s %s' % (response.status, response.reason))\n            boto.log.error('%s' % body)\n            raise self.ResponseError(response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a statement to a topic s access control policy granting the specified actions for each of the specified AWS accounts.", "response": "def add_permission(self, topic, label, account_ids, actions):\n        \"\"\"\n        Adds a statement to a topic's access control policy, granting\n        access for the specified AWS accounts to the specified actions.\n\n        :type topic: string\n        :param topic: The ARN of the topic.\n\n        :type label: string\n        :param label: A unique identifier for the new policy statement.\n\n        :type account_ids: list of strings\n        :param account_ids: The AWS account ids of the users who will be\n                            give access to the specified actions.\n\n        :type actions: list of strings\n        :param actions: The actions you want to allow for each of the\n                        specified principal(s).\n\n        \"\"\"\n        params = {'ContentType' : 'JSON',\n                  'TopicArn' : topic,\n                  'Label' : label}\n        self.build_list_params(params, account_ids, 'AWSAccountId')\n        self.build_list_params(params, actions, 'ActionName')\n        response = self.make_request('AddPermission', params, '/', 'GET')\n        body = response.read()\n        if response.status == 200:\n            return json.loads(body)\n        else:\n            boto.log.error('%s %s' % (response.status, response.reason))\n            boto.log.error('%s' % body)\n            raise self.ResponseError(response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef publish(self, topic, message, subject=None):\n        params = {'ContentType' : 'JSON',\n                  'TopicArn' : topic,\n                  'Message' : message}\n        if subject:\n            params['Subject'] = subject\n        response = self.make_request('Publish', params, '/', 'GET')\n        body = response.read()\n        if response.status == 200:\n            return json.loads(body)\n        else:\n            boto.log.error('%s %s' % (response.status, response.reason))\n            boto.log.error('%s' % body)\n            raise self.ResponseError(response.status, response.reason, body)", "response": "Publish a message to a topic."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef subscribe(self, topic, protocol, endpoint):\n        params = {'ContentType' : 'JSON',\n                  'TopicArn' : topic,\n                  'Protocol' : protocol,\n                  'Endpoint' : endpoint}\n        response = self.make_request('Subscribe', params, '/', 'GET')\n        body = response.read()\n        if response.status == 200:\n            return json.loads(body)\n        else:\n            boto.log.error('%s %s' % (response.status, response.reason))\n            boto.log.error('%s' % body)\n            raise self.ResponseError(response.status, response.reason, body)", "response": "Subscribe to a topic."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef subscribe_sqs_queue(self, topic, queue):\n        t = queue.id.split('/')\n        q_arn = 'arn:aws:sqs:%s:%s:%s' % (queue.connection.region.name,\n                                          t[1], t[2])\n        resp = self.subscribe(topic, 'sqs', q_arn)\n        policy = queue.get_attributes('Policy')\n        if 'Version' not in policy:\n            policy['Version'] = '2008-10-17'\n        if 'Statement' not in policy:\n            policy['Statement'] = []\n        statement = {'Action' : 'SQS:SendMessage',\n                     'Effect' : 'Allow',\n                     'Principal' : {'AWS' : '*'},\n                     'Resource' : q_arn,\n                     'Sid' : str(uuid.uuid4()),\n                     'Condition' : {'StringLike' : {'aws:SourceArn' : topic}}}\n        policy['Statement'].append(statement)\n        queue.set_attribute('Policy', json.dumps(policy))\n        return resp", "response": "Subscribe an SQS queue to a topic."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconfirms a subscription of a topic.", "response": "def confirm_subscription(self, topic, token,\n                             authenticate_on_unsubscribe=False):\n        \"\"\"\n        Get properties of a Topic\n\n        :type topic: string\n        :param topic: The ARN of the new topic.\n\n        :type token: string\n        :param token: Short-lived token sent to and endpoint during\n                      the Subscribe operation.\n\n        :type authenticate_on_unsubscribe: bool\n        :param authenticate_on_unsubscribe: Optional parameter indicating\n                                            that you wish to disable\n                                            unauthenticated unsubscription\n                                            of the subscription.\n\n        \"\"\"\n        params = {'ContentType' : 'JSON',\n                  'TopicArn' : topic,\n                  'Token' : token}\n        if authenticate_on_unsubscribe:\n            params['AuthenticateOnUnsubscribe'] = 'true'\n        response = self.make_request('ConfirmSubscription', params, '/', 'GET')\n        body = response.read()\n        if response.status == 200:\n            return json.loads(body)\n        else:\n            boto.log.error('%s %s' % (response.status, response.reason))\n            boto.log.error('%s' % body)\n            raise self.ResponseError(response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nallow endpoint owner to delete subscription. Confirmation message will be delivered. :type subscription: string :param subscription: The ARN of the subscription to be deleted.", "response": "def unsubscribe(self, subscription):\n        \"\"\"\n        Allows endpoint owner to delete subscription.\n        Confirmation message will be delivered.\n\n        :type subscription: string\n        :param subscription: The ARN of the subscription to be deleted.\n\n        \"\"\"\n        params = {'ContentType' : 'JSON',\n                  'SubscriptionArn' : subscription}\n        response = self.make_request('Unsubscribe', params, '/', 'GET')\n        body = response.read()\n        if response.status == 200:\n            return json.loads(body)\n        else:\n            boto.log.error('%s %s' % (response.status, response.reason))\n            boto.log.error('%s' % body)\n            raise self.ResponseError(response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_all_subscriptions(self, next_token=None):\n        params = {'ContentType' : 'JSON'}\n        if next_token:\n            params['NextToken'] = next_token\n        response = self.make_request('ListSubscriptions', params, '/', 'GET')\n        body = response.read()\n        if response.status == 200:\n            return json.loads(body)\n        else:\n            boto.log.error('%s %s' % (response.status, response.reason))\n            boto.log.error('%s' % body)\n            raise self.ResponseError(response.status, response.reason, body)", "response": "Get list of all subscriptions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new invalidation request for the specified distribution.", "response": "def create_invalidation_request(self, distribution_id, paths,\n                                    caller_reference=None):\n        \"\"\"Creates a new invalidation request\n            :see: http://goo.gl/8vECq\n        \"\"\"\n        # We allow you to pass in either an array or\n        # an InvalidationBatch object\n        if not isinstance(paths, InvalidationBatch):\n            paths = InvalidationBatch(paths)\n        paths.connection = self\n        uri = '/%s/distribution/%s/invalidation' % (self.Version,\n                                                    distribution_id)\n        response = self.make_request('POST', uri,\n                                     {'Content-Type' : 'text/xml'},\n                                     data=paths.to_xml())\n        body = response.read()\n        if response.status == 201:\n            h = handler.XmlHandler(paths, self)\n            xml.sax.parseString(body, h)\n            return paths\n        else:\n            raise CloudFrontServerError(response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninstalling a PaymentInstruction to the specified caller.", "response": "def install_payment_instruction(self, instruction,\n                                    token_type=\"Unrestricted\",\n                                    transaction_id=None):\n        \"\"\"\n        InstallPaymentInstruction\n        instruction: The PaymentInstruction to send, for example: \n        \n            MyRole=='Caller' orSay 'Roles do not match';\n        \n        token_type: Defaults to \"Unrestricted\"\n        transaction_id: Defaults to a new ID\n        \"\"\"\n\n        if(transaction_id == None):\n            transaction_id = uuid.uuid4()\n        params = {}\n        params['PaymentInstruction'] = instruction\n        params['TokenType'] = token_type\n        params['CallerReference'] = transaction_id\n        response = self.make_request(\"InstallPaymentInstruction\", params)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninstall a caller_token into the FPS section.", "response": "def install_caller_instruction(self, token_type=\"Unrestricted\",\n                                   transaction_id=None):\n        \"\"\"\n        Set us up as a caller\n        This will install a new caller_token into the FPS section.\n        This should really only be called to regenerate the caller token.\n        \"\"\"\n        response = self.install_payment_instruction(\"MyRole=='Caller';\",\n                                                    token_type=token_type,\n                                                    transaction_id=transaction_id)\n        body = response.read()\n        if(response.status == 200):\n            rs = ResultSet()\n            h = handler.XmlHandler(rs, self)\n            xml.sax.parseString(body, h)\n            caller_token = rs.TokenId\n            try:\n                boto.config.save_system_option(\"FPS\", \"caller_token\",\n                                               caller_token)\n            except(IOError):\n                boto.config.save_user_option(\"FPS\", \"caller_token\",\n                                             caller_token)\n            return caller_token\n        else:\n            raise FPSResponseError(response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_marketplace_registration_url(self, returnURL, pipelineName,\n                                          maxFixedFee=0.0, maxVariableFee=0.0,\n                                          recipientPaysFee=True, **params):  \n        \"\"\"\n        Generate the URL with the signature required for signing up a recipient\n        \"\"\"\n        # use the sandbox authorization endpoint if we're using the\n        #  sandbox for API calls.\n        endpoint_host = 'authorize.payments.amazon.com'\n        if 'sandbox' in self.host:\n            endpoint_host = 'authorize.payments-sandbox.amazon.com'\n        base = \"/cobranded-ui/actions/start\"\n\n        params['callerKey'] = str(self.aws_access_key_id)\n        params['returnURL'] = str(returnURL)\n        params['pipelineName'] = str(pipelineName)\n        params['maxFixedFee'] = str(maxFixedFee)\n        params['maxVariableFee'] = str(maxVariableFee)\n        params['recipientPaysFee'] = str(recipientPaysFee)\n        params[\"signatureMethod\"] = 'HmacSHA256'\n        params[\"signatureVersion\"] = '2'\n\n        if(not params.has_key('callerReference')):\n            params['callerReference'] = str(uuid.uuid4())\n\n        parts = ''\n        for k in sorted(params.keys()):\n            parts += \"&%s=%s\" % (k, urllib.quote(params[k], '~'))\n\n        canonical = '\\n'.join(['GET',\n                               str(endpoint_host).lower(),\n                               base,\n                               parts[1:]])\n\n        signature = self._auth_handler.sign_string(canonical)\n        params[\"signature\"] = signature\n\n        urlsuffix = ''\n        for k in sorted(params.keys()):\n            urlsuffix += \"&%s=%s\" % (k, urllib.quote(params[k], '~'))\n        urlsuffix = urlsuffix[1:] # strip the first &\n        \n        fmt = \"https://%(endpoint_host)s%(base)s?%(urlsuffix)s\"\n        final = fmt % vars()\n        return final", "response": "Generate the URL for the registration of a specific user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_url(self, returnURL, paymentReason, pipelineName,\n                 transactionAmount, **params):\n        \"\"\"\n        Generate the URL with the signature required for a transaction\n        \"\"\"\n        # use the sandbox authorization endpoint if we're using the\n        #  sandbox for API calls.\n        endpoint_host = 'authorize.payments.amazon.com'\n        if 'sandbox' in self.host:\n            endpoint_host = 'authorize.payments-sandbox.amazon.com'\n        base = \"/cobranded-ui/actions/start\"\n\n        params['callerKey'] = str(self.aws_access_key_id)\n        params['returnURL'] = str(returnURL)\n        params['paymentReason'] = str(paymentReason)\n        params['pipelineName'] = pipelineName\n        params['transactionAmount'] = transactionAmount\n        params[\"signatureMethod\"] = 'HmacSHA256'\n        params[\"signatureVersion\"] = '2'\n        \n        if(not params.has_key('callerReference')):\n            params['callerReference'] = str(uuid.uuid4())\n\n        parts = ''\n        for k in sorted(params.keys()):\n            parts += \"&%s=%s\" % (k, urllib.quote(params[k], '~'))\n\n        canonical = '\\n'.join(['GET',\n                               str(endpoint_host).lower(),\n                               base,\n                               parts[1:]])\n\n        signature = self._auth_handler.sign_string(canonical)\n        params[\"signature\"] = signature\n\n        urlsuffix = ''\n        for k in sorted(params.keys()):\n            urlsuffix += \"&%s=%s\" % (k, urllib.quote(params[k], '~'))\n        urlsuffix = urlsuffix[1:] # strip the first &\n        \n        fmt = \"https://%(endpoint_host)s%(base)s?%(urlsuffix)s\"\n        final = fmt % vars()\n        return final", "response": "Generate the URL for a transaction."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes a payment transaction. You must specify the amount. This can also perform a Reserve request if 'reserve' is set to True.", "response": "def pay(self, transactionAmount, senderTokenId,\n            recipientTokenId=None, callerTokenId=None,\n            chargeFeeTo=\"Recipient\",\n            callerReference=None, senderReference=None, recipientReference=None,\n            senderDescription=None, recipientDescription=None,\n            callerDescription=None, metadata=None,\n            transactionDate=None, reserve=False):\n        \"\"\"\n        Make a payment transaction. You must specify the amount.\n        This can also perform a Reserve request if 'reserve' is set to True.\n        \"\"\"\n        params = {}\n        params['SenderTokenId'] = senderTokenId\n        # this is for 2008-09-17 specification\n        params['TransactionAmount.Amount'] = str(transactionAmount)\n        params['TransactionAmount.CurrencyCode'] = \"USD\"\n        #params['TransactionAmount'] = str(transactionAmount)\n        params['ChargeFeeTo'] = chargeFeeTo\n        \n        params['RecipientTokenId'] = (\n            recipientTokenId if recipientTokenId is not None\n            else boto.config.get(\"FPS\", \"recipient_token\")\n            )\n        params['CallerTokenId'] = (\n            callerTokenId if callerTokenId is not None\n            else boto.config.get(\"FPS\", \"caller_token\")\n            )\n        if(transactionDate != None):\n            params['TransactionDate'] = transactionDate\n        if(senderReference != None):\n            params['SenderReference'] = senderReference\n        if(recipientReference != None):\n            params['RecipientReference'] = recipientReference\n        if(senderDescription != None):\n            params['SenderDescription'] = senderDescription\n        if(recipientDescription != None):\n            params['RecipientDescription'] = recipientDescription\n        if(callerDescription != None):\n            params['CallerDescription'] = callerDescription\n        if(metadata != None):\n            params['MetaData'] = metadata\n        if(callerReference == None):\n            callerReference = uuid.uuid4()\n        params['CallerReference'] = callerReference\n        \n        if reserve:\n            response = self.make_request(\"Reserve\", params)\n        else:\n            response = self.make_request(\"Pay\", params)\n        body = response.read()\n        if(response.status == 200):\n            rs = ResultSet()\n            h = handler.XmlHandler(rs, self)\n            xml.sax.parseString(body, h)\n            return rs\n        else:\n            raise FPSResponseError(response.status, response.reason, body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_transaction_status(self, transactionId):\n        params = {}\n        params['TransactionId'] = transactionId\n    \n        response = self.make_request(\"GetTransactionStatus\", params)\n        body = response.read()\n        if(response.status == 200):\n            rs = ResultSet()\n            h = handler.XmlHandler(rs, self)\n            xml.sax.parseString(body, h)\n            return rs\n        else:\n            raise FPSResponseError(response.status, response.reason, body)", "response": "Returns the status of a given transaction."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef settle(self, reserveTransactionId, transactionAmount=None):\n        params = {}\n        params['ReserveTransactionId'] = reserveTransactionId\n        if(transactionAmount != None):\n            params['TransactionAmount'] = transactionAmount\n        \n        response = self.make_request(\"Settle\", params)\n        body = response.read()\n        if(response.status == 200):\n            rs = ResultSet()\n            h = handler.XmlHandler(rs, self)\n            xml.sax.parseString(body, h)\n            return rs\n        else:\n            raise FPSResponseError(response.status, response.reason, body)", "response": "Settle a reserved payment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refund(self, callerReference, transactionId, refundAmount=None,\n               callerDescription=None):\n        \"\"\"\n        Refund a transaction. This refunds the full amount by default\n        unless 'refundAmount' is specified.\n        \"\"\"\n        params = {}\n        params['CallerReference'] = callerReference\n        params['TransactionId'] = transactionId\n        if(refundAmount != None):\n            params['RefundAmount'] = refundAmount\n        if(callerDescription != None):\n            params['CallerDescription'] = callerDescription\n        \n        response = self.make_request(\"Refund\", params)\n        body = response.read()\n        if(response.status == 200):\n            rs = ResultSet()\n            h = handler.XmlHandler(rs, self)\n            xml.sax.parseString(body, h)\n            return rs\n        else:\n            raise FPSResponseError(response.status, response.reason, body)", "response": "Refund a single resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a resource to the set.", "response": "def add(self, resource, replace=False):\n        \"\"\"Add just a single resource.\"\"\"\n        uri = resource.uri\n        if (uri in self and not replace):\n            raise ResourceSetDupeError(\n                \"Attempt to add resource already in this set\")\n        self[uri] = resource"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_pdf(path_jinja2, template_name, path_outfile, template_kwargs=None):\n    '''Helper function for building a pdf from a latex jinja2 template\n\n    :param path_jinja2: the root directory for latex jinja2 templates\n    :param template_name: the relative path, to path_jinja2, to the desired\n        jinja2 Latex template\n    :param path_outfile: the full path to the desired final output file\n        Must contain the same file extension as files generated by\n        cmd_wo_infile, otherwise the process will fail\n    :param template_kwargs: a dictionary of key/values for jinja2 variables\n    '''\n    latex_template_object = LatexBuild(\n            path_jinja2,\n            template_name,\n            template_kwargs,\n            )\n    return latex_template_object.build_pdf(path_outfile)", "response": "This function is used to build a pdf from a latex jinja2 template"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_html(path_jinja2, template_name, path_outfile, template_kwargs=None):\n    '''Helper function for building an html from a latex jinja2 template\n\n    :param path_jinja2: the root directory for latex jinja2 templates\n    :param template_name: the relative path, to path_jinja2, to the desired\n        jinja2 Latex template\n    :param path_outfile: the full path to the desired final output file\n        Must contain the same file extension as files generated by\n        cmd_wo_infile, otherwise the process will fail\n    :param template_kwargs: a dictionary of key/values for jinja2 variables\n    '''\n    latex_template_object = LatexBuild(\n            path_jinja2,\n            template_name,\n            template_kwargs,\n            )\n    return latex_template_object.build_html(path_outfile)", "response": "This function is used to build an html from a latex jinja2 template"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading a sitemap from a URI.", "response": "def read(self, uri=None, resources=None, index_only=False):\n        \"\"\"Read sitemap from a URI including handling sitemapindexes.\n\n        If index_only is True then individual sitemaps references in a sitemapindex\n        will not be read. This will result in no resources being returned and is\n        useful only to read the metadata and links listed in the sitemapindex.\n\n        Includes the subtlety that if the input URI is a local file and is a\n        sitemapindex which contains URIs for the individual sitemaps, then these\n        are mapped to the filesystem also.\n        \"\"\"\n        try:\n            fh = URLopener().open(uri)\n            self.num_files += 1\n        except IOError as e:\n            raise IOError(\n                \"Failed to load sitemap/sitemapindex from %s (%s)\" %\n                (uri, str(e)))\n        # Get the Content-Length if we can (works fine for local files)\n        try:\n            self.content_length = int(fh.info()['Content-Length'])\n            self.bytes_read += self.content_length\n            self.logger.debug(\n                \"Read %d bytes from %s\" %\n                (self.content_length, uri))\n        except KeyError:\n            # If we don't get a length then c'est la vie\n            self.logger.debug(\"Read ????? bytes from %s\" % (uri))\n            pass\n        self.logger.info(\"Read sitemap/sitemapindex from %s\" % (uri))\n        s = self.new_sitemap()\n        s.parse_xml(fh=fh, resources=self, capability=self.capability_name)\n        # what did we read? sitemap or sitemapindex?\n        if (s.parsed_index):\n            # sitemapindex\n            if (not self.allow_multifile):\n                raise ListBaseIndexError(\n                    \"Got sitemapindex from %s but support for sitemapindex disabled\" %\n                    (uri))\n            self.logger.info(\n                \"Parsed as sitemapindex, %d sitemaps\" %\n                (len(\n                    self.resources)))\n            sitemapindex_is_file = self.is_file_uri(uri)\n            if (index_only):\n                # don't read the component sitemaps\n                self.sitemapindex = True\n                return\n            # now loop over all entries to read each sitemap and add to\n            # resources\n            sitemaps = self.resources\n            self.resources = self.resources_class()\n            self.logger.info(\"Now reading %d sitemaps\" % len(sitemaps.uris()))\n            for sitemap_uri in sorted(sitemaps.uris()):\n                self.read_component_sitemap(\n                    uri, sitemap_uri, s, sitemapindex_is_file)\n        else:\n            # sitemap\n            self.logger.info(\"Parsed as sitemap, %d resources\" %\n                             (len(self.resources)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a component sitemap of a Resource List with index.", "response": "def read_component_sitemap(\n            self, sitemapindex_uri, sitemap_uri, sitemap, sitemapindex_is_file):\n        \"\"\"Read a component sitemap of a Resource List with index.\n\n        Each component must be a sitemap with the\n        \"\"\"\n        if (sitemapindex_is_file):\n            if (not self.is_file_uri(sitemap_uri)):\n                # Attempt to map URI to local file\n                remote_uri = sitemap_uri\n                sitemap_uri = self.mapper.src_to_dst(remote_uri)\n                self.logger.info(\n                    \"Mapped %s to local file %s\" %\n                    (remote_uri, sitemap_uri))\n            else:\n                # The individual sitemaps should be at a URL (scheme/server/path)\n                # that the sitemapindex URL can speak authoritatively about\n                if (self.check_url_authority and\n                        not UrlAuthority(sitemapindex_uri).has_authority_over(sitemap_uri)):\n                    raise ListBaseIndexError(\n                        \"The sitemapindex (%s) refers to sitemap at a location it does not have authority over (%s)\" %\n                        (sitemapindex_uri, sitemap_uri))\n        try:\n            fh = URLopener().open(sitemap_uri)\n            self.num_files += 1\n        except IOError as e:\n            raise ListBaseIndexError(\n                \"Failed to load sitemap from %s listed in sitemap index %s (%s)\" %\n                (sitemap_uri, sitemapindex_uri, str(e)))\n        # Get the Content-Length if we can (works fine for local files)\n        try:\n            self.content_length = int(fh.info()['Content-Length'])\n            self.bytes_read += self.content_length\n        except KeyError:\n            # If we don't get a length then c'est la vie\n            pass\n        self.logger.info(\n            \"Reading sitemap from %s (%d bytes)\" %\n            (sitemap_uri, self.content_length))\n        component = sitemap.parse_xml(fh=fh, sitemapindex=False)\n        # Copy resources into self, check any metadata\n        for r in component:\n            self.resources.add(r)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True or the number of component sitemaps required.", "response": "def requires_multifile(self):\n        \"\"\"Return False or the number of component sitemaps required.\n\n        In the case that no len() is available for self.resources then\n        then self.count must be set beforehand to avoid an exception.\n        \"\"\"\n        if (self.max_sitemap_entries is None or\n                len(self) <= self.max_sitemap_entries):\n            return(False)\n        return(int(math.ceil(len(self) / float(self.max_sitemap_entries))))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef as_xml(self, allow_multifile=False, basename=\"/tmp/sitemap.xml\"):\n        if (not self.requires_multifile()):\n            return super(ListBaseWithIndex, self).as_xml()\n        elif (allow_multifile):\n            return self.as_xml_index(basename)\n        else:\n            raise ListBaseIndexError(\n                \"Attempt to write single XML string for list with %d entries when max_sitemap_entries is set to %d\" %\n                (len(self), self.max_sitemap_entries))", "response": "Return XML string representation of this list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_xml_index(self, basename=\"/tmp/sitemap.xml\"):\n        num_parts = self.requires_multifile()\n        if (not num_parts):\n            raise ListBaseIndexError(\n                \"Request for sitemapindex for list with only %d entries when max_sitemap_entries is set to %s\" %\n                (len(self), str(\n                    self.max_sitemap_entries)))\n        index = ListBase()\n        index.sitemapindex = True\n        index.capability_name = self.capability_name\n        index.default_capability()\n        for n in range(num_parts):\n            r = Resource(uri=self.part_name(basename, n))\n            index.add(r)\n        return(index.as_xml())", "response": "Return a string of the index for a large list that is split."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef as_xml_part(self, basename=\"/tmp/sitemap.xml\", part_number=0):\n        if (not self.requires_multifile()):\n            raise ListBaseIndexError(\n                \"Request for component sitemap for list with only %d entries when max_sitemap_entries is set to %s\" %\n                (len(self), str(\n                    self.max_sitemap_entries)))\n        start = part_number * self.max_sitemap_entries\n        if (start > len(self)):\n            raise ListBaseIndexError(\n                \"Request for component sitemap with part_number too high, would start at entry %d yet the list has only %d entries\" %\n                (start, len(self)))\n        stop = start + self.max_sitemap_entries\n        if (stop > len(self)):\n            stop = len(self)\n        part = ListBase(itertools.islice(self.resources, start, stop))\n        part.capability_name = self.capability_name\n        part.default_capability()\n        part.index = basename\n        s = self.new_sitemap()\n        return(s.resources_as_xml(part))", "response": "Return a string of component sitemap with the given part_number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite one or more sitemap files to disk.", "response": "def write(self, basename='/tmp/sitemap.xml'):\n        \"\"\"Write one or a set of sitemap files to disk.\n\n        resources is a ResourceContainer that may be an ResourceList or\n        a ChangeList. This may be a generator so data is read as needed\n        and length is determined at the end.\n\n        basename is used as the name of the single sitemap file or the\n        sitemapindex for a set of sitemap files.\n\n        Uses self.max_sitemap_entries to determine whether the resource_list can\n        be written as one sitemap. If there are more entries and\n        self.allow_multifile is set True then a set of sitemap files,\n        with an sitemapindex, will be written.\n        \"\"\"\n        # Access resources through iterator only\n        resources_iter = iter(self.resources)\n        (chunk, nxt) = self.get_resources_chunk(resources_iter)\n        s = self.new_sitemap()\n        if (nxt is not None):\n            # Have more than self.max_sitemap_entries => sitemapindex\n            if (not self.allow_multifile):\n                raise ListBaseIndexError(\n                    \"Too many entries for a single sitemap but multifile disabled\")\n            # Work out URI of sitemapindex so that we can link up to\n            # it from the individual sitemap files\n            try:\n                index_uri = self.mapper.dst_to_src(basename)\n            except MapperError as e:\n                raise ListBaseIndexError(\n                    \"Cannot map sitemapindex filename to URI (%s)\" %\n                    str(e))\n            # Use iterator over all resources and count off sets of\n            # max_sitemap_entries to go into each sitemap, store the\n            # names of the sitemaps as we go. Copy md from self into\n            # the index and use this for all chunks also\n            index = ListBase(md=self.md.copy(), ln=list(self.ln))\n            index.capability_name = self.capability_name\n            index.default_capability()\n            while (len(chunk) > 0):\n                file = self.part_name(basename, len(index))\n                # Check that we can map the filename of this sitemap into\n                # URI space for the sitemapindex\n                try:\n                    uri = self.mapper.dst_to_src(file)\n                except MapperError as e:\n                    raise ListBaseIndexError(\n                        \"Cannot map sitemap filename to URI (%s)\" % str(e))\n                self.logger.info(\"Writing sitemap %s...\" % (file))\n                f = open(file, 'w')\n                chunk.index = index_uri\n                chunk.md = index.md\n                s.resources_as_xml(chunk, fh=f)\n                f.close()\n                # Record information about this sitemap for index\n                r = Resource(uri=uri,\n                             timestamp=os.stat(file).st_mtime,\n                             md5=Hashes(['md5'], file).md5)\n                index.add(r)\n                # Get next chunk\n                (chunk, nxt) = self.get_resources_chunk(resources_iter, nxt)\n            self.logger.info(\"Wrote %d sitemaps\" % (len(index)))\n            f = open(basename, 'w')\n            self.logger.info(\"Writing sitemapindex %s...\" % (basename))\n            s.resources_as_xml(index, sitemapindex=True, fh=f)\n            f.close()\n            self.logger.info(\"Wrote sitemapindex %s\" % (basename))\n        elif self.sitemapindex:\n            f = open(basename, 'w')\n            self.logger.info(\"Writing sitemapindex %s...\" % (basename))\n            s.resources_as_xml(chunk, sitemapindex=True, fh=f)\n            f.close()\n            self.logger.info(\"Wrote sitemapindex %s\" % (basename))\n        else:\n            f = open(basename, 'w')\n            self.logger.info(\"Writing sitemap %s...\" % (basename))\n            s.resources_as_xml(chunk, fh=f)\n            f.close()\n            self.logger.info(\"Wrote sitemap %s\" % (basename))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns next chunk of resources from resource_iter and next item.", "response": "def get_resources_chunk(self, resource_iter, first=None):\n        \"\"\"Return next chunk of resources from resource_iter, and next item.\n\n        If first parameter is specified then this will be prepended to\n        the list.\n\n        The chunk will contain self.max_sitemap_entries if the iterator\n        returns that many. next will have the value of the next value from\n        the iterator, providing indication of whether more is available.\n        Use this as first when asking for the following chunk.\n        \"\"\"\n        chunk = ListBase(md=self.md.copy(), ln=list(self.ln))\n        chunk.capability_name = self.capability_name\n        chunk.default_capability()\n        if (first is not None):\n            chunk.add(first)\n        for r in resource_iter:\n            chunk.add(r)\n            if (len(chunk) >= self.max_sitemap_entries):\n                break\n        # Get next to see whether there are more resources\n        try:\n            nxt = next(resource_iter)\n        except StopIteration:\n            nxt = None\n        return(chunk, nxt)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef part_name(self, basename='/tmp/sitemap.xml', part_number=0):\n        # Work out how to name the sitemaps, attempt to add %05d before\n        # \".xml$\", else append\n        sitemap_prefix = basename\n        sitemap_suffix = '.xml'\n        if (basename[-4:] == '.xml'):\n            sitemap_prefix = basename[:-4]\n        return(sitemap_prefix + (\"%05d\" % (part_number)) + sitemap_suffix)", "response": "Name for one component sitemap."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a B - Spline given some coefficients.", "response": "def _basis_spline_factory(coef, degree, knots, der, ext):\n        \"\"\"Return a B-Spline given some coefficients.\"\"\"\n        return functools.partial(interpolate.splev, tck=(knots, coef, degree), der=der, ext=ext)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef derivatives_factory(cls, coef, degree, knots, ext, **kwargs):\n        return cls._basis_spline_factory(coef, degree, knots, 1, ext)", "response": "Returns a derivative of a B - spline."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef functions_factory(cls, coef, degree, knots, ext, **kwargs):\n        return cls._basis_spline_factory(coef, degree, knots, 0, ext)", "response": "Factory function for creating a B - spline."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_master(self, url):\n        m = urlparse(url)\n        self.master_scheme = m.scheme\n        self.master_netloc = m.netloc\n        self.master_path = os.path.dirname(m.path)", "response": "Set the master url that this object works with."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_authority_over(self, url):\n        s = urlparse(url)\n        if (s.scheme != self.master_scheme):\n            return(False)\n        if (s.netloc != self.master_netloc):\n            if (not s.netloc.endswith('.' + self.master_netloc)):\n                return(False)\n            # Maybe should allow parallel for 3+ components, eg. a.example.org,\n            # b.example.org\n        path = os.path.dirname(s.path)\n        if (self.strict and\n                path != self.master_path and\n                not path.startswith(self.master_path)):\n            return(False)\n        return(True)", "response": "Return True of the current master has authority over url."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef admin_permission_factory(admin_view):\n    try:\n        pkg_resources.get_distribution('invenio-access')\n        from invenio_access import Permission\n    except pkg_resources.DistributionNotFound:\n        from flask_principal import Permission\n\n    return Permission(action_admin_access)", "response": "Default factory for creating a permission for an admin."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncollects node data asynchronously using gevent lib.", "response": "def get_conns(cred, providers):\n    \"\"\"Collect node data asynchronously using gevent lib.\"\"\"\n    cld_svc_map = {\"aws\": conn_aws,\n                   \"azure\": conn_az,\n                   \"gcp\": conn_gcp,\n                   \"alicloud\": conn_ali}\n    sys.stdout.write(\"\\rEstablishing Connections:  \")\n    sys.stdout.flush()\n    busy_obj = busy_disp_on()\n    conn_fn = [[cld_svc_map[x.rstrip('1234567890')], cred[x], x]\n               for x in providers]\n    cgroup = Group()\n    conn_res = []\n    conn_res = cgroup.map(get_conn, conn_fn)\n    cgroup.join()\n    conn_objs = {}\n    for item in conn_res:\n        conn_objs.update(item)\n    busy_disp_off(dobj=busy_obj)\n    sys.stdout.write(\"\\r                                                 \\r\")\n    sys.stdout.write(\"\\033[?25h\")  # cursor back on\n    sys.stdout.flush()\n    return conn_objs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrefreshing node data using existing connection - objects.", "response": "def get_data(conn_objs, providers):\n    \"\"\"Refresh node data using existing connection-objects.\"\"\"\n    cld_svc_map = {\"aws\": nodes_aws,\n                   \"azure\": nodes_az,\n                   \"gcp\": nodes_gcp,\n                   \"alicloud\": nodes_ali}\n    sys.stdout.write(\"\\rCollecting Info:  \")\n    sys.stdout.flush()\n    busy_obj = busy_disp_on()\n    collec_fn = [[cld_svc_map[x.rstrip('1234567890')], conn_objs[x]]\n                 for x in providers]\n    ngroup = Group()\n    node_list = []\n    node_list = ngroup.map(get_nodes, collec_fn)\n    ngroup.join()\n    busy_disp_off(dobj=busy_obj)\n    sys.stdout.write(\"\\r                                                 \\r\")\n    sys.stdout.write(\"\\033[?25h\")  # cursor back on\n    sys.stdout.flush()\n    return node_list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nturning OFF busy_display to indicate completion.", "response": "def busy_disp_off(dobj):\n    \"\"\"Turn OFF busy_display to indicate completion.\"\"\"\n    dobj.kill(block=False)\n    sys.stdout.write(\"\\033[D \\033[D\")\n    sys.stdout.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef busy_display():\n    sys.stdout.write(\"\\033[?25l\")  # cursor off\n    sys.stdout.flush()\n    for x in range(1800):\n        symb = ['\\\\', '|', '/', '-']\n        sys.stdout.write(\"\\033[D{}\".format(symb[x % 4]))\n        sys.stdout.flush()\n        gevent.sleep(0.1)", "response": "Display animation to show activity."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nestablish connection to AWS service.", "response": "def conn_aws(cred, crid):\n    \"\"\"Establish connection to AWS service.\"\"\"\n    driver = get_driver(Provider.EC2)\n    try:\n        aws_obj = driver(cred['aws_access_key_id'],\n                         cred['aws_secret_access_key'],\n                         region=cred['aws_default_region'])\n    except SSLError as e:\n        abort_err(\"\\r SSL Error with AWS: {}\".format(e))\n    except InvalidCredsError as e:\n        abort_err(\"\\r Error with AWS Credentials: {}\".format(e))\n    return {crid: aws_obj}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets node objects from AWS.", "response": "def nodes_aws(c_obj):\n    \"\"\"Get node objects from AWS.\"\"\"\n    aws_nodes = []\n    try:\n        aws_nodes = c_obj.list_nodes()\n    except BaseHTTPError as e:\n        abort_err(\"\\r HTTP Error with AWS: {}\".format(e))\n    aws_nodes = adj_nodes_aws(aws_nodes)\n    return aws_nodes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadjust details specific to AWS.", "response": "def adj_nodes_aws(aws_nodes):\n    \"\"\"Adjust details specific to AWS.\"\"\"\n    for node in aws_nodes:\n        node.cloud = \"aws\"\n        node.cloud_disp = \"AWS\"\n        node.private_ips = ip_to_str(node.private_ips)\n        node.public_ips = ip_to_str(node.public_ips)\n        node.zone = node.extra['availability']\n        node.size = node.extra['instance_type']\n        node.type = node.extra['instance_lifecycle']\n    return aws_nodes"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nestablishes connection to Azure service.", "response": "def conn_az(cred, crid):\n    \"\"\"Establish connection to Azure service.\"\"\"\n    driver = get_driver(Provider.AZURE_ARM)\n    try:\n        az_obj = driver(tenant_id=cred['az_tenant_id'],\n                        subscription_id=cred['az_sub_id'],\n                        key=cred['az_app_id'],\n                        secret=cred['az_app_sec'])\n    except SSLError as e:\n        abort_err(\"\\r SSL Error with Azure: {}\".format(e))\n    except InvalidCredsError as e:\n        abort_err(\"\\r Error with Azure Credentials: {}\".format(e))\n    return {crid: az_obj}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef nodes_az(c_obj):\n    az_nodes = []\n    try:\n        az_nodes = c_obj.list_nodes()\n    except BaseHTTPError as e:\n        abort_err(\"\\r HTTP Error with Azure: {}\".format(e))\n    az_nodes = adj_nodes_az(az_nodes)\n    return az_nodes", "response": "Get node objects from Azure."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef adj_nodes_az(az_nodes):\n    for node in az_nodes:\n        node.cloud = \"azure\"\n        node.cloud_disp = \"Azure\"\n        node.private_ips = ip_to_str(node.private_ips)\n        node.public_ips = ip_to_str(node.public_ips)\n        node.zone = node.extra['location']\n        node.size = node.extra['properties']['hardwareProfile']['vmSize']\n        group_raw = node.id\n        unnsc, group_end = group_raw.split(\"resourceGroups/\", 1)\n        group, unnsc = group_end.split(\"/\", 1)\n        node.group = group\n    return az_nodes", "response": "Adjust details specific to Azure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef conn_gcp(cred, crid):\n    gcp_auth_type = cred.get('gcp_auth_type', \"S\")\n    if gcp_auth_type == \"A\":  # Application Auth\n        gcp_crd_ia = CONFIG_DIR + \".gcp_libcloud_a_auth.\" + cred['gcp_proj_id']\n        gcp_crd = {'user_id': cred['gcp_client_id'],\n                   'key': cred['gcp_client_sec'],\n                   'project': cred['gcp_proj_id'],\n                   'auth_type': \"IA\",\n                   'credential_file': gcp_crd_ia}\n    else:  # Service Account Auth\n        gcp_pem = CONFIG_DIR + cred['gcp_pem_file']\n        gcp_crd_sa = CONFIG_DIR + \".gcp_libcloud_s_auth.\" + cred['gcp_proj_id']\n        gcp_crd = {'user_id': cred['gcp_svc_acct_email'],\n                   'key': gcp_pem,\n                   'project': cred['gcp_proj_id'],\n                   'credential_file': gcp_crd_sa}\n    driver = get_driver(Provider.GCE)\n    try:\n        gcp_obj = driver(**gcp_crd)\n    except SSLError as e:\n        abort_err(\"\\r SSL Error with GCP: {}\".format(e))\n    except (InvalidCredsError, ValueError) as e:\n        abort_err(\"\\r Error with GCP Credentials: {}\".format(e))\n    return {crid: gcp_obj}", "response": "Establish connection to GCP."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget node objects from GCP.", "response": "def nodes_gcp(c_obj):\n    \"\"\"Get node objects from GCP.\"\"\"\n    gcp_nodes = []\n    try:\n        gcp_nodes = c_obj.list_nodes(ex_use_disk_cache=True)\n    except BaseHTTPError as e:\n        abort_err(\"\\r HTTP Error with GCP: {}\".format(e))\n    gcp_nodes = adj_nodes_gcp(gcp_nodes)\n    return gcp_nodes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef adj_nodes_gcp(gcp_nodes):\n    for node in gcp_nodes:\n        node.cloud = \"gcp\"\n        node.cloud_disp = \"GCP\"\n        node.private_ips = ip_to_str(node.private_ips)\n        node.public_ips = ip_to_str(node.public_ips)\n        node.zone = node.extra['zone'].name\n    return gcp_nodes", "response": "Adjust details specific to GCP."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nestablish connection to AliCloud service.", "response": "def conn_ali(cred, crid):\n    \"\"\"Establish connection to AliCloud service.\"\"\"\n    driver = get_driver(Provider.ALIYUN_ECS)\n    try:\n        ali_obj = driver(cred['ali_access_key_id'],\n                         cred['ali_access_key_secret'],\n                         region=cred['ali_region'])\n    except SSLError as e:\n        abort_err(\"\\r SSL Error with AliCloud: {}\".format(e))\n    except InvalidCredsError as e:\n        abort_err(\"\\r Error with AliCloud Credentials: {}\".format(e))\n    return {crid: ali_obj}"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget node objects from AliCloud.", "response": "def nodes_ali(c_obj):\n    \"\"\"Get node objects from AliCloud.\"\"\"\n    ali_nodes = []\n    try:\n        ali_nodes = c_obj.list_nodes()\n    except BaseHTTPError as e:\n        abort_err(\"\\r HTTP Error with AliCloud: {}\".format(e))\n    ali_nodes = adj_nodes_ali(ali_nodes)\n    return ali_nodes"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadjusts details specific to AliCloud.", "response": "def adj_nodes_ali(ali_nodes):\n    \"\"\"Adjust details specific to AliCloud.\"\"\"\n    for node in ali_nodes:\n        node.cloud = \"alicloud\"\n        node.cloud_disp = \"AliCloud\"\n        node.private_ips = ip_to_str(node.extra['vpc_attributes']['private_ip_address'])\n        node.public_ips = ip_to_str(node.public_ips)\n        node.zone = node.extra['zone_id']\n        node.size = node.extra['instance_type']\n        if node.size.startswith('ecs.'):\n            node.size = node.size[len('ecs.'):]\n    return ali_nodes"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds an instance of FigcaptionProcessor to the Markdown parser.", "response": "def extendMarkdown(self, md, md_globals):\n        \"\"\" Add an instance of FigcaptionProcessor to BlockParser. \"\"\"\n\n        # def_list = 'def_list' in md.registeredExtensions\n        md.parser.blockprocessors.add(\n            'figcaption', FigcaptionProcessor(md.parser), '<ulist')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a single XML document for this list.", "response": "def parse(self, uri=None, fh=None, str_data=None, **kwargs):\n        \"\"\"Parse a single XML document for this list.\n\n        Accepts either a uri (uri or default if parameter not specified),\n        or a filehandle (fh) or a string (str_data). Note that this method\n        does not handle the case of a sitemapindex+sitemaps.\n\n        LEGACY SUPPORT - the parameter str may be used in place of str_data\n        but is deprecated and will be removed in a later version.\n        \"\"\"\n        if (uri is not None):\n            try:\n                fh = URLopener().open(uri)\n            except IOError as e:\n                raise Exception(\n                    \"Failed to load sitemap/sitemapindex from %s (%s)\" %\n                    (uri, str(e)))\n        elif (str_data is not None):\n            fh = io.StringIO(str_data)\n        elif ('str' in kwargs):\n            # Legacy support for str argument, see\n            # https://github.com/resync/resync/pull/21\n            # One test for this in tests/test_list_base.py\n            self.logger.warn(\n                \"Legacy parse(str=...), use parse(str_data=...) instead\")\n            fh = io.StringIO(kwargs['str'])\n        if (fh is None):\n            raise Exception(\"Nothing to parse\")\n        s = self.new_sitemap()\n        s.parse_xml(\n            fh=fh,\n            resources=self,\n            capability=self.capability_name,\n            sitemapindex=False)\n        self.parsed_index = s.parsed_index"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn XML serialization of this list.", "response": "def as_xml(self):\n        \"\"\"Return XML serialization of this list.\n\n        This code does not support the case where the list is too big for\n        a single XML document.\n        \"\"\"\n        self.default_capability()\n        s = self.new_sitemap()\n        return s.resources_as_xml(self, sitemapindex=self.sitemapindex)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites a single sitemap or sitemapindex XML document.", "response": "def write(self, basename=\"/tmp/resynclist.xml\"):\n        \"\"\"Write a single sitemap or sitemapindex XML document.\n\n        Must be overridden to support multi-file lists.\n        \"\"\"\n        self.default_capability()\n        fh = open(basename, 'w')\n        s = self.new_sitemap()\n        s.resources_as_xml(self, fh=fh, sitemapindex=self.sitemapindex)\n        fh.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds resource if change is not None else ChangeTypeError.", "response": "def add_if_changed(self, resource):\n        \"\"\"Add resource if change is not None else ChangeTypeError.\"\"\"\n        if (resource.change is not None):\n            self.resources.append(resource)\n        else:\n            raise ChangeTypeError(resource.change)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, resource):\n        if isinstance(resource, collections.Iterable):\n            for r in resource:\n                self.add_if_changed(r)\n        else:\n            self.add_if_changed(resource)", "response": "Add a resource change or an iterable collection of resources."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd items from a ResourceContainer resources.", "response": "def add_changed_resources(self, resources, change=None):\n        \"\"\"Add items from a ResourceContainer resources.\n\n        If change is specified then the attribute is set in the Resource\n        objects created.\n        \"\"\"\n        for resource in resources:\n            rc = Resource(resource=resource, change=change)\n            self.add(rc)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef retrieve_config(element):\n        '''retrieve_config\n\n        High-level api: Retrive config from rpc-reply.\n\n        Parameters\n        ----------\n\n        element : `Element`\n            A rpc-reply or content of Config instance.\n\n        Returns\n        -------\n\n        Element\n            A new element which represents config data.\n        '''\n\n        if not etree.iselement(element):\n            raise TypeError(\"argument 'element' must be Element not '{}'\" \\\n                            .format(type(element)))\n        ret = etree.Element(config_tag, nsmap={'nc': nc_url})\n        ret.extend(deepcopy(element.xpath('/nc:rpc-reply/nc:data/*',\n                            namespaces={'nc': nc_url})))\n        ret.extend(deepcopy(element.xpath('/nc:data/*',\n                            namespaces={'nc': nc_url})))\n        ret.extend(deepcopy(element.xpath('/nc:config/*',\n                            namespaces={'nc': nc_url})))\n        ret.extend(deepcopy(element.xpath('/nc:rpc/nc:edit-config/nc:config/*',\n                            namespaces={'nc': nc_url})))\n        ret.extend(deepcopy(element.xpath('/nc:edit-config/nc:config/*',\n                            namespaces={'nc': nc_url})))\n        return ret", "response": "retrieve_config High - level api : Retrive config from rpc - reply."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef node_add(self, node_sum, node_other):\n        '''node_add\n\n        High-level api: Combine two configs or apply an instance of ConfigDelta\n        to a config. This method is recursive. node_sum will be modified during\n        the process, and it becomes the result at the end.\n\n        Parameters\n        ----------\n\n        node_sum : `Element`\n            A config node in a config tree.\n\n        node_other : `Element`\n            A config node in another config tree.\n\n        Returns\n        -------\n\n        None\n            There is no return of this method.\n        '''\n\n        supported_node_type = [\n            'leaf',\n            'leaf-list',\n            'container',\n            'list',\n            ]\n        in_s_not_in_o, in_o_not_in_s, in_s_and_in_o = \\\n            self._group_kids(node_sum, node_other)\n        for child_self in in_s_not_in_o:\n            pass\n        for child_other in in_o_not_in_s:\n            # delete\n            if child_other.get(operation_tag) == 'delete':\n                raise ConfigDeltaError('data-missing: try to delete node {} ' \\\n                                       'but it does not exist in config' \\\n                                       .format(self.device \\\n                                                   .get_xpath(child_other)))\n            # remove\n            elif child_other.get(operation_tag) == 'remove':\n                pass\n            # merge, replace, create or none\n            else:\n                s_node = self.device.get_schema_node(child_other)\n                if s_node.get('type') in supported_node_type:\n                    getattr(self,\n                            '_node_add_without_peer_{}' \\\n                            .format(s_node.get('type').replace('-', ''))) \\\n                            (node_sum, child_other)\n        for child_self, child_other in in_s_and_in_o:\n            s_node = self.device.get_schema_node(child_self)\n            if s_node.get('type') in supported_node_type:\n                getattr(self,\n                        '_node_add_with_peer_{}' \\\n                        .format(s_node.get('type').replace('-', ''))) \\\n                        (child_self, child_other)", "response": "This method adds a node to a config tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _node_add_without_peer_container(self, node_sum, child_other):\n        '''_node_add_without_peer_container\n\n        Low-level api: Apply delta child_other to node_sum when there is no peer\n        of child_other can be found under node_sum. child_other is a container\n        node. Element node_sum will be modified during the process.\n\n        Parameters\n        ----------\n\n        node_sum : `Element`\n            A config node in a config tree.\n\n        child_other : `Element`\n            A child of a config node in another config tree. This child has no\n            peer under node_sum.\n\n        Returns\n        -------\n\n        None\n            There is no return of this method.\n        '''\n\n        e = deepcopy(child_other)\n        node_sum.append(self._del_attrib(e))", "response": "Internal method that adds delta child_other to node_sum when there is no peer containing node_sum of child_other."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _node_add_without_peer_list(self, node_sum, child_other):\n        '''_node_add_without_peer_list\n\n        Low-level api: Apply delta child_other to node_sum when there is no peer\n        of child_other can be found under node_sum. child_other is a list node.\n        Element node_sum will be modified during the process.\n\n        Parameters\n        ----------\n\n        node_sum : `Element`\n            A config node in a config tree.\n\n        child_other : `Element`\n            A child of a config node in another config tree. This child has no\n            peer under node_sum.\n\n        Returns\n        -------\n\n        None\n            There is no return of this method.\n        '''\n\n        s_node = self.device.get_schema_node(child_other)\n        e = deepcopy(child_other)\n        scope = node_sum.getchildren()\n        siblings = self._get_sequence(scope, child_other.tag, node_sum)\n        if s_node.get('ordered-by') == 'user' and \\\n           child_other.get(insert_tag) is not None:\n            if child_other.get(insert_tag) == 'first':\n                if siblings:\n                    siblings[0].addprevious(self._del_attrib(e))\n                else:\n                    node_sum.append(self._del_attrib(e))\n            elif child_other.get(insert_tag) == 'last':\n                if siblings:\n                    siblings[-1].addnext(self._del_attrib(e))\n                else:\n                    node_sum.append(self._del_attrib(e))\n            elif child_other.get(insert_tag) == 'before':\n                if child_other.get(key_tag) is None:\n                    _inserterror('before', self.device.get_xpath(child_other),\n                                 'key')\n                sibling = node_sum.find(child_other.tag +\n                                        child_other.get(key_tag),\n                                        namespaces=child_other.nsmap)\n                if sibling is None:\n                    path = self.device.get_xpath(child_other)\n                    key = child_other.get(key_tag)\n                    _inserterror('before', path, 'key', key)\n                sibling.addprevious(self._del_attrib(e))\n            elif child_other.get(insert_tag) == 'after':\n                if child_other.get(key_tag) is None:\n                    _inserterror('after', self.device.get_xpath(child_other),\n                                 'key')\n                sibling = node_sum.find(child_other.tag +\n                                        child_other.get(key_tag),\n                                        namespaces=child_other.nsmap)\n                if sibling is None:\n                    path = self.device.get_xpath(child_other)\n                    key = child_other.get(key_tag)\n                    _inserterror('after', path, 'key', key)\n                sibling.addnext(self._del_attrib(e))\n        else:\n            if siblings:\n                siblings[-1].addnext(self._del_attrib(e))\n            else:\n                node_sum.append(self._del_attrib(e))", "response": "Internal method that applies delta child_other to node_sum when there is no peer list of child_other can be found under node_sum."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _node_add_with_peer_leaf(self, child_self, child_other):\n        '''_node_add_with_peer_leaf\n\n        Low-level api: Apply delta child_other to child_self when child_self is\n        the peer of child_other. Element child_self and child_other are leaf\n        nodes. Element child_self will be modified during the process. RFC6020\n        section 7.6.7 is a reference of this method.\n\n        Parameters\n        ----------\n\n        child_self : `Element`\n            A child of a config node in a config tree.\n\n        child_other : `Element`\n            A child of a config node in another config tree. child_self is\n            the peer of child_other.\n\n        Returns\n        -------\n\n        None\n            There is no return of this method.\n        '''\n\n        if child_other.get(operation_tag) is None:\n            child_self.text = child_other.text\n        elif child_other.get(operation_tag) == 'merge':\n            child_self.text = child_other.text\n        elif child_other.get(operation_tag) == 'replace':\n            child_self.text = child_other.text\n        elif child_other.get(operation_tag) == 'create':\n            raise ConfigDeltaError('data-exists: try to create node {} but ' \\\n                                   'it already exists' \\\n                                   .format(self.device.get_xpath(child_other)))\n        elif child_other.get(operation_tag) == 'delete' or \\\n             child_other.get(operation_tag) == 'remove':\n            parent_self = child_self.getparent()\n            parent_self.remove(child_self)\n        else:\n            raise ConfigDeltaError(\"unknown operation: node {} contains \" \\\n                                   \"operation '{}'\" \\\n                                   .format(self.device.get_xpath(child_other),\n                                           child_other.get(operation_tag)))", "response": "Internal method for adding a new leaf node to the config tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _node_add_with_peer_leaflist(self, child_self, child_other):\n        '''_node_add_with_peer_leaflist\n\n        Low-level api: Apply delta child_other to child_self when child_self is\n        the peer of child_other. Element child_self and child_other are\n        leaf-list nodes. Element child_self will be modified during the process.\n        RFC6020 section 7.7.7 is a reference of this method.\n\n        Parameters\n        ----------\n\n        child_self : `Element`\n            A child of a config node in a config tree.\n\n        child_other : `Element`\n            A child of a config node in another config tree. child_self is\n            the peer of child_other.\n\n        Returns\n        -------\n\n        None\n            There is no return of this method.\n        '''\n\n        parent_self = child_self.getparent()\n        s_node = self.device.get_schema_node(child_self)\n        if child_other.get(operation_tag) is None or \\\n           child_other.get(operation_tag) == 'merge' or \\\n           child_other.get(operation_tag) == 'replace':\n            if s_node.get('ordered-by') == 'user' and \\\n               child_other.get(insert_tag) is not None:\n                if child_other.get(insert_tag) == 'first':\n                    scope = parent_self.getchildren()\n                    siblings = self._get_sequence(scope, child_other.tag,\n                                                  parent_self)\n                    if siblings[0] != child_self:\n                        siblings[0].addprevious(child_self)\n                elif child_other.get(insert_tag) == 'last':\n                    scope = parent_self.getchildren()\n                    siblings = self._get_sequence(scope, child_other.tag,\n                                                  parent_self)\n                    if siblings[-1] != child_self:\n                        siblings[-1].addnext(child_self)\n                elif child_other.get(insert_tag) == 'before':\n                    if child_other.get(value_tag) is None:\n                        _inserterror('before',\n                                     self.device.get_xpath(child_other),\n                                     'value')\n                    siblings = parent_self.findall(child_other.tag)\n                    sibling = [s for s in siblings\n                               if s.text == child_other.get(value_tag)]\n                    if not sibling:\n                        path = self.device.get_xpath(child_other)\n                        value = child_other.get(value_tag)\n                        _inserterror('before', path, 'value', value)\n                    if sibling[0] != child_self:\n                        sibling[0].addprevious(child_self)\n                elif child_other.get(insert_tag) == 'after':\n                    if child_other.get(value_tag) is None:\n                        _inserterror('after',\n                                     self.device.get_xpath(child_other),\n                                     'value')\n                    siblings = parent_self.findall(child_other.tag)\n                    sibling = [s for s in siblings\n                               if s.text == child_other.get(value_tag)]\n                    if not sibling:\n                        path = self.device.get_xpath(child_other)\n                        value = child_other.get(value_tag)\n                        _inserterror('after', path, 'value', value)\n                    if sibling[0] != child_self:\n                        sibling[0].addnext(child_self)\n        elif child_other.get(operation_tag) == 'create':\n            raise ConfigDeltaError('data-exists: try to create node {} but ' \\\n                                   'it already exists' \\\n                                   .format(self.device.get_xpath(child_other)))\n        elif child_other.get(operation_tag) == 'delete' or \\\n             child_other.get(operation_tag) == 'remove':\n            parent_self.remove(child_self)\n        else:\n            raise ConfigDeltaError(\"unknown operation: node {} contains \" \\\n                                   \"operation '{}'\" \\\n                                   .format(self.device.get_xpath(child_other),\n                                           child_other.get(operation_tag)))", "response": "Internal method to add a new node to the leaf - list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _node_add_with_peer_list(self, child_self, child_other):\n        '''_node_add_with_peer_list\n\n        Low-level api: Apply delta child_other to child_self when child_self is\n        the peer of child_other. Element child_self and child_other are list\n        nodes. Element child_self will be modified during the process. RFC6020\n        section 7.8.6 is a reference of this method.\n\n        Parameters\n        ----------\n\n        child_self : `Element`\n            A child of a config node in a config tree.\n\n        child_other : `Element`\n            A child of a config node in another config tree. child_self is\n            the peer of child_other.\n\n        Returns\n        -------\n\n        None\n            There is no return of this method.\n        '''\n\n        parent_self = child_self.getparent()\n        s_node = self.device.get_schema_node(child_self)\n        if child_other.get(operation_tag) != 'delete' and \\\n           child_other.get(operation_tag) != 'remove' and \\\n           s_node.get('ordered-by') == 'user' and \\\n           child_other.get(insert_tag) is not None:\n            if child_other.get(insert_tag) == 'first':\n                scope = parent_self.getchildren()\n                siblings = self._get_sequence(scope, child_other.tag,\n                                              parent_self)\n                if siblings[0] != child_self:\n                    siblings[0].addprevious(child_self)\n            elif child_other.get(insert_tag) == 'last':\n                scope = parent_self.getchildren()\n                siblings = self._get_sequence(scope, child_other.tag,\n                                              parent_self)\n                if siblings[-1] != child_self:\n                    siblings[-1].addnext(child_self)\n            elif child_other.get(insert_tag) == 'before':\n                if child_other.get(key_tag) is None:\n                    _inserterror('before', self.device.get_xpath(child_other),\n                                 'key')\n                sibling = parent_self.find(child_other.tag +\n                                           child_other.get(key_tag),\n                                           namespaces=child_other.nsmap)\n                if sibling is None:\n                    path = self.device.get_xpath(child_other)\n                    key = child_other.get(key_tag)\n                    _inserterror('before', path, 'key', key)\n                if sibling != child_self:\n                    sibling.addprevious(child_self)\n            elif child_other.get(insert_tag) == 'after':\n                if child_other.get(key_tag) is None:\n                    _inserterror('after', self.device.get_xpath(child_other),\n                                 'key')\n                sibling = parent_self.find(child_other.tag +\n                                           child_other.get(key_tag),\n                                           namespaces=child_other.nsmap)\n                if sibling is None:\n                    path = self.device.get_xpath(child_other)\n                    key = child_other.get(key_tag)\n                    _inserterror('after', path, 'key', key)\n                if sibling != child_self:\n                    sibling.addnext(child_self)\n        if child_other.get(operation_tag) is None or \\\n           child_other.get(operation_tag) == 'merge':\n            self.node_add(child_self, child_other)\n        elif child_other.get(operation_tag) == 'replace':\n            e = deepcopy(child_other)\n            parent_self.replace(child_self, self._del_attrib(e))\n        elif child_other.get(operation_tag) == 'create':\n            raise ConfigDeltaError('data-exists: try to create node {} but ' \\\n                                   'it already exists' \\\n                                   .format(self.device.get_xpath(child_other)))\n        elif child_other.get(operation_tag) == 'delete' or \\\n             child_other.get(operation_tag) == 'remove':\n            parent_self.remove(child_self)\n        else:\n            raise ConfigDeltaError(\"unknown operation: node {} contains \" \\\n                                   \"operation '{}'\" \\\n                                   .format(self.device.get_xpath(child_other),\n                                           child_other.get(operation_tag)))", "response": "Internal method that applies delta child_self to child_self when child_self is child_other and then apply delta child_other to child_self when child_self is child_other."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef node_sub(self, node_self, node_other):\n        '''node_sub\n\n        Low-level api: Compute the delta of two configs. This method is\n        recursive. Assume two configs are different.\n\n        Parameters\n        ----------\n\n        node_self : `Element`\n            A config node in a config tree that is being processed. node_self\n            cannot be a leaf node.\n\n        node_other : `Element`\n            A config node in another config tree that is being processed.\n\n        Returns\n        -------\n\n        None\n            There is no return of this method.\n        '''\n\n        def same_leaf_list(tag):\n            list_self = [c for c in list(node_self) if c.tag == tag]\n            list_other = [c for c in list(node_other) if c.tag == tag]\n            s_node = self.device.get_schema_node((list_self + list_other)[0])\n            if s_node.get('ordered-by') == 'user':\n                if [i.text for i in list_self] == [i.text for i in list_other]:\n                    return True\n                else:\n                    return False\n            else:\n                if set([i.text for i in list_self]) == \\\n                   set([i.text for i in list_other]):\n                    return True\n                else:\n                    return False\n\n        if self.preferred_replace != 'merge':\n            t_self = [c.tag for c in list(node_self) \\\n                      if self.device.get_schema_node(c).get('type') == \\\n                         'leaf-list']\n            t_other = [c.tag for c in list(node_other) \\\n                       if self.device.get_schema_node(c).get('type') == \\\n                          'leaf-list']\n            commonalities = set(t_self) & set(t_other)\n            for commonality in commonalities:\n                if not same_leaf_list(commonality):\n                    node_self.set(operation_tag, 'replace')\n                    node_other.set(operation_tag, 'replace')\n                    return\n\n        in_s_not_in_o, in_o_not_in_s, in_s_and_in_o = \\\n            self._group_kids(node_self, node_other)\n        ordered_by_user = {}\n        for child_self in in_s_not_in_o:\n            child_other = etree.Element(child_self.tag,\n                                        {operation_tag: self.preferred_delete},\n                                        nsmap=child_self.nsmap)\n            if self.preferred_create != 'merge':\n                child_self.set(operation_tag, self.preferred_create)\n            siblings = list(node_other.iterchildren(tag=child_self.tag))\n            if siblings:\n                siblings[-1].addnext(child_other)\n            else:\n                node_other.append(child_other)\n            s_node = self.device.get_schema_node(child_self)\n            if s_node.get('type') == 'leaf-list':\n                if s_node.get('ordered-by') == 'user' and \\\n                   s_node.tag not in ordered_by_user:\n                    ordered_by_user[s_node.tag] = 'leaf-list'\n                child_other.text = child_self.text\n            elif s_node.get('type') == 'list':\n                keys = self._get_list_keys(s_node)\n                if s_node.get('ordered-by') == 'user' and \\\n                   s_node.tag not in ordered_by_user:\n                    ordered_by_user[s_node.tag] = keys\n                for key in keys:\n                    key_node = child_self.find(key)\n                    e = etree.SubElement(child_other, key, nsmap=key_node.nsmap)\n                    e.text = key_node.text\n        for child_other in in_o_not_in_s:\n            child_self = etree.Element(child_other.tag,\n                                       {operation_tag: self.preferred_delete},\n                                       nsmap=child_other.nsmap)\n            if self.preferred_create != 'merge':\n                child_other.set(operation_tag, self.preferred_create)\n            siblings = list(node_self.iterchildren(tag=child_other.tag))\n            if siblings:\n                siblings[-1].addnext(child_self)\n            else:\n                node_self.append(child_self)\n            s_node = self.device.get_schema_node(child_other)\n            if s_node.get('type') == 'leaf-list':\n                if s_node.get('ordered-by') == 'user' and \\\n                   s_node.tag not in ordered_by_user:\n                    ordered_by_user[s_node.tag] = 'leaf-list'\n                child_self.text = child_other.text\n            elif s_node.get('type') == 'list':\n                keys = self._get_list_keys(s_node)\n                if s_node.get('ordered-by') == 'user' and \\\n                   s_node.tag not in ordered_by_user:\n                    ordered_by_user[s_node.tag] = keys\n                for key in keys:\n                    key_node = child_other.find(key)\n                    e = etree.SubElement(child_self, key, nsmap=key_node.nsmap)\n                    e.text = key_node.text\n        for child_self, child_other in in_s_and_in_o:\n            s_node = self.device.get_schema_node(child_self)\n            if s_node.get('type') == 'leaf':\n                if child_self.text == child_other.text:\n                    if not s_node.get('is_key'):\n                        node_self.remove(child_self)\n                        node_other.remove(child_other)\n                else:\n                    if self.preferred_replace != 'merge':\n                        child_self.set(operation_tag, self.preferred_replace)\n                        child_other.set(operation_tag, self.preferred_replace)\n            elif s_node.get('type') == 'leaf-list':\n                if s_node.get('ordered-by') == 'user':\n                    if s_node.tag not in ordered_by_user:\n                        ordered_by_user[s_node.tag] = 'leaf-list'\n                else:\n                    node_self.remove(child_self)\n                    node_other.remove(child_other)\n            elif s_node.get('type') == 'container':\n                if self._node_le(child_self, child_other) and \\\n                   self._node_le(child_other, child_self):\n                    node_self.remove(child_self)\n                    node_other.remove(child_other)\n                else:\n                    self.node_sub(child_self, child_other)\n            elif s_node.get('type') == 'list':\n                if s_node.get('ordered-by') == 'user' and \\\n                   s_node.tag not in ordered_by_user:\n                    ordered_by_user[s_node.tag] = self._get_list_keys(s_node)\n                if self._node_le(child_self, child_other) and \\\n                   self._node_le(child_other, child_self):\n                    if s_node.get('ordered-by') == 'user':\n                        for child in child_self.getchildren():\n                            schema_node = self.device.get_schema_node(child)\n                            if not schema_node.get('is_key'):\n                                child_self.remove(child)\n                        for child in child_other.getchildren():\n                            schema_node = self.device.get_schema_node(child)\n                            if not schema_node.get('is_key'):\n                                child_other.remove(child)\n                    else:\n                        node_self.remove(child_self)\n                        node_other.remove(child_other)\n                else:\n                    self.node_sub(child_self, child_other)\n            else:\n                path = self.device.get_xpath(s_node)\n                raise ModelError(\"unknown schema node type: type of node {}\" \\\n                                 \"is '{}'\".format(path, s_node.get('type')))\n        for tag in ordered_by_user:\n            scope_s = in_s_not_in_o + in_s_and_in_o\n            scope_o = in_o_not_in_s + in_s_and_in_o\n            for sequence in self._get_sequence(scope_s, tag, node_self), \\\n                            self._get_sequence(scope_o, tag, node_other):\n                for item in sequence:\n                    # modifying the namespace mapping of a node is not possible\n                    # in lxml. See https://bugs.launchpad.net/lxml/+bug/555602\n                    # if 'yang' not in item.nsmap:\n                    #     item.nsmap['yang'] = yang_url\n                    i = sequence.index(item)\n                    if i == 0:\n                        item.set(insert_tag, 'first')\n                    else:\n                        item.set(insert_tag, 'after')\n                        precursor = sequence[i - 1]\n                        if ordered_by_user[tag] == 'leaf-list':\n                            item.set(value_tag, precursor.text)\n                        else:\n                            keys = ordered_by_user[tag]\n                            key_nodes = {k: precursor.find(k) for k in keys}\n                            ids = {k: self._url_to_prefix(n, k) \\\n                                   for k, n in key_nodes.items()}\n                            l = [\"[{}='{}']\".format(ids[k], key_nodes[k].text) \\\n                                 for k in keys]\n                            item.set(key_tag, ''.join(l))", "response": "This method is used to compute the delta of two config trees. This method is used to compute the delta of two config trees."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _url_to_prefix(node, id):\n        '''_url_to_prefix\n\n        Low-level api: Convert an identifier from `{namespace}tagname` notation\n        to `prefix:tagname` notation by looking at nsmap of the node. If the\n        identifier does not have a namespace, the identifier is simply returned\n        without modification.\n\n        Parameters\n        ----------\n\n        node : `str`\n            A config node. Its identifier will be converted.\n\n        id : `str`\n            Identifier in `{namespace}tagname` notation.\n\n        Returns\n        -------\n\n        str\n            Identifier in `prefix:tagname` notation.\n        '''\n\n        prefixes = {v: k for k, v in node.nsmap.items()}\n        ret = re.search('^{(.+)}(.+)$', id)\n        if ret:\n            if ret.group(1) in prefixes:\n                if prefixes[ret.group(1)] is None:\n                    return ret.group(2)\n                else:\n                    return prefixes[ret.group(1)] + ':' + ret.group(2)\n        return id", "response": "Convert an identifier from the node s namespace to the prefix."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhighlighting the source code with the given language.", "response": "def highlight_syntax(src, lang, linenums=False):\n    \"\"\"Pass code to the [Pygments](http://pygments.pocoo.org/) highliter\n    with optional line numbers. The output should then be styled with CSS\n    to  your liking. No styles are applied by default - only styling hooks\n    (i.e.: <span class=\"k\">).\n    \"\"\"\n    src = src.strip('\\n')\n    if not lang:\n        lexer = TextLexer()\n    else:\n        try:\n            lexer = get_lexer_by_name(lang, stripall=True)\n        except ValueError:\n            lexer = TextLexer()\n    formatter = HtmlFormatter(linenos=linenums, tab_length=TAB_LENGTH)\n    html = highlight(src, lexer, formatter)\n\n    if lang:\n        open_code = OPEN_CODE % (LANG_TAG % (lang, ), )\n    else:\n        open_code = OPEN_CODE % u''\n    html = html.replace('<div class=\"highlight\"><pre>', open_code, 1)\n    html = html.replace('</pre></div>', CLOSE_CODE)\n    return html"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self, lines):\n        text = \"\\n\".join(lines)\n        while 1:\n            m = FENCED_BLOCK_RE.search(text)\n            if not m:\n                break\n            lang = m.group('lang')\n            linenums = bool(m.group('linenums'))\n            html = highlight_syntax(m.group('code'), lang, linenums=linenums)\n            placeholder = self.markdown.htmlStash.store(html, safe=True)\n            text = '{}\\n{}\\n{}'.format(\n                text[:m.start()],\n                placeholder,\n                text[m.end():]\n            )\n\n        return text.split(\"\\n\")", "response": "Match and store Fenced Code Blocks in the HtmlStash."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initialize_hashes(self):\n        if ('md5' in self.hashes):\n            self.md5_calc = hashlib.md5()\n        if ('sha-1' in self.hashes):\n            self.sha1_calc = hashlib.sha1()\n        if ('sha-256' in self.hashes):\n            self.sha256_calc = hashlib.sha256()", "response": "Create new hashlib objects for each hash we are going to calculate."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compute_for_file(self, file, block_size=2**14):\n        self.initialize_hashes()\n        f = open(file, 'rb')\n        while True:\n            data = f.read(block_size)\n            if not data:\n                break\n            if (self.md5_calc is not None):\n                self.md5_calc.update(data)\n            if (self.sha1_calc is not None):\n                self.sha1_calc.update(data)\n            if (self.sha256_calc is not None):\n                self.sha256_calc.update(data)\n        f.close()", "response": "Compute the hash digests for a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pre_save(self, model_instance, add):\n        value = getattr(model_instance, self.attname)\n        if self.clean_isbn and value not in EMPTY_VALUES:\n            cleaned_isbn = value.replace(' ', '').replace('-', '').upper()\n            setattr(model_instance, self.attname, cleaned_isbn)\n        return super(ISBNField, self).pre_save(model_instance, add)", "response": "Remove dashes spaces and convert isbn to uppercase before saving\n        when clean_isbn is enabled"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconfigures and add cocos layers and random level", "response": "def generate_random_level(self):\n        \"\"\"\n        Configure and add cocos layers\n        \"\"\"\n\n        # build !\n        width = self.width\n        height = self.height\n        tiles_w = self.tiles_w\n        tiles_h = self.tiles_h\n        self.z = 0\n\n        # add walls\n        #self.map_layer = ti.load(os.path.join(script_dir, 'test.tmx'))['map0']\n        self.map_layer = self.generator.map(tiles_w, tiles_h)\n        self.map_layer.set_view(0, 0, self.map_layer.px_width, self.map_layer.px_height)\n        # FIXME: Both `scale_x` and `scale_y`\n        self.map_layer.scale = config.scale_x\n        self.add(self.map_layer, z=self.z)\n        self.z += 1\n\n        # add floor\n        # TODO: Move to `Generator.inverse(map)`\n        self.visit_layer = ti.load(os.path.join(script_dir, 'assets', 'ones.tmx'))['map0']\n        for i in xrange(0, len(self.map_layer.cells)):\n            for j in xrange(0, len(self.map_layer.cells[i])):\n                col = self.map_layer.cells[i][j]\n                # If wall exists, remove floor\n                if col.tile and col.tile.id > 0:\n                    self.visit_layer.cells[i][j].tile = None\n\n        self.visit_layer.set_view(0, 0, self.visit_layer.px_width, self.visit_layer.px_height)\n        # FIXME: Both `scale_x` and `scale_y`\n        self.visit_layer.scale = config.scale_x\n        self.add(self.visit_layer, z=-1)\n\n        # add player\n        # Start in random corner\n        corner = randint(0,3)\n        padding = eu.Vector2(self.map_layer.tw*1.5, self.map_layer.th*1.5)\n        corners = [\n            eu.Vector2(padding.x, padding.y), # Bottom left\n            eu.Vector2(((tiles_w+1)*self.map_layer.tw)-padding.x, padding.y), # Bottom right\n            eu.Vector2(padding.x, ((tiles_h+1)*self.map_layer.th)-padding.y), # Top right\n            eu.Vector2(((tiles_w+1)*self.map_layer.tw)-padding.x, ((tiles_h+1)*self.map_layer.th)-padding.y) # Top left\n        ]\n        rotations = [\n            45,\n            -45,\n            135,\n            -135\n        ]\n        self.spawn = corners[corner]\n        self.player = Player(self.spawn.x, self.spawn.y)\n        self.player.rotation = rotations[corner]\n        self.add(self.player, z=self.z)\n        self.z += 1\n\n        self.score = ScoreLayer(self.player.stats)\n        self.add(self.score, z=self.z)\n        self.z += 1\n\n        # Draw sensors\n        # TODO: Decouple into view rendering\n        a = math.radians(self.player.rotation)\n        for sensor in self.player.sensors:\n            rad = a + sensor.angle\n            start = self.player.cshape.center\n            end = start.copy()\n            end.x += math.sin(rad) * sensor.proximity;\n            end.y += math.cos(rad) * sensor.proximity;\n            sensor.line = draw.Line(start, end, self.player.palette['wall'] + (int(255*0.5),))\n            self.map_layer.add(sensor.line)\n\n        # Generate obstacles\n        self.create_items()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, dt):\n        # if not playing dont update model\n        if self.win_status != 'undecided':\n            return\n\n        # Step known time for agents\n        if self.force_fps > 0:\n            dt = 1 / self.force_fps\n\n        # update target\n        self.player.update_rotation(dt, self.buttons)\n\n        # Get planned update\n        newVel = self.player.do_move(dt, self.buttons)\n\n        # Position collision rects\n        oldRect = self.player.get_rect()\n        newRect = oldRect.copy()\n\n        oldPos = self.player.cshape.center\n        remaining_dt = dt\n        newPos = oldPos.copy()\n\n        # So WorldLayer is given `bumped` attributes at startup.\n        if dt == 0:\n            newVel.x, newVel.y = self.collide_map(self.map_layer, oldRect, oldRect, newVel.x, newVel.y)\n\n        # Get planned velocity result\n        def get_new_rect(pos, width, height, dt, velocity):\n            targetPos = pos + dt * velocity\n            x = targetPos.x - width/2\n            y = targetPos.y - height/2\n            return x, y\n\n        while remaining_dt > 1.e-6:\n            #print('remaining_dt', remaining_dt)\n            newRect.x, newRect.y = get_new_rect(oldPos, newRect.width, newRect.height, remaining_dt, newVel)\n            newVel.x, newVel.y = self.collide_map(self.map_layer, oldRect, newRect, newVel.x, newVel.y)\n\n            remaining_dt -= self.consumed_dt\n\n        newRect.x, newRect.y = get_new_rect(oldPos, newRect.width, newRect.height, dt, newVel)\n\n        # Ensure player can't escape borders\n        border = False\n        if newRect.top > self.height:\n            newRect.top = self.height\n            border = True\n        if newRect.bottom < self.map_layer.th:\n            newRect.bottom = self.map_layer.th\n            border = True\n        if newRect.left < self.map_layer.th:\n            newRect.left = self.map_layer.th\n            border = True\n        if newRect.right > self.width:\n            newRect.right = self.width\n            border = True\n\n        newPos = self.player.cshape.center\n        newPos.x, newPos.y = newRect.center\n        self.player.velocity = newVel\n        self.player.update_center(newPos)\n\n        # Collision detected\n        if border or self.bumped_x or self.bumped_y:\n            #print('bumped')\n            self.reward_wall()\n\n        # In WorldLayer so we can access map\n        self.update_visited()\n        self.update_sensors()\n\n        self.reward_battery()\n        self.reward_proximity()\n\n        # TODO: Display messages for humans at some point\n        #if self.player.game_over:\n        #    self.level_losed()\n\n        self.update_collisions()", "response": "Update the game engine each tick and update the model with the new values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the visited status of the visited cells in the visit layer.", "response": "def update_visited(self):\n        \"\"\"\n        Updates exploration map visited status\n        \"\"\"\n        assert isinstance(self.player.cshape.center, eu.Vector2)\n        pos = self.player.cshape.center\n\n        # Helper function\n        def set_visited(layer, cell):\n            if cell and not cell.properties.get('visited') and cell.tile and cell.tile.id > 0:\n                cell.properties['visited'] = True\n\n                self.reward_explore()\n\n                # TODO: Decouple into view rendering\n                # Change colour of visited cells\n                key = layer.get_key_at_pixel(cell.x, cell.y)\n                #layer.set_cell_color(key[0], key[1], [155,155,155])\n                layer.set_cell_opacity(key[0], key[1], 255*0.8)\n        # End Helper\n\n        # Get the current tile under player\n        current = self.visit_layer.get_at_pixel(pos.x, pos.y)\n\n        if current:\n            # In spawn square\n            if current == self.visit_layer.get_at_pixel(self.spawn.x, self.spawn.y):\n                self.reward_goal()\n\n            # Only record/reward exploration when battery is above 50%\n            #if self.player.stats['battery'] > 50:\n            set_visited(self.visit_layer, current)\n            neighbours = self.visit_layer.get_neighbors(current)\n            for cell in neighbours:\n                neighbour = neighbours[cell]\n                set_visited(self.visit_layer, neighbour)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating sensors with new values.", "response": "def update_sensors(self):\n        \"\"\"\n        Check path for each sensor and record wall proximity\n        \"\"\"\n        assert isinstance(self.player.cshape.center, eu.Vector2)\n        pos = self.player.cshape.center\n\n        a = math.radians(self.player.rotation)\n        for sensor in self.player.sensors:\n            sensor.sensed_type = 'wall'\n            rad = a + sensor.angle\n            dis = min(self.distance_to_tile(pos, rad), sensor.max_range)\n\n            # Keep state of sensed range, `dis` is from center\n            sensor.proximity = dis - self.player.radius\n\n            # Check for collisions with items\n            # List of items within sensor range, do for each sensor's range\n            if self.mode['items'] and len(self.mode['items']) > 0:\n                nears = self.collman.ranked_objs_near(self.player, sensor.max_range)\n                for near in nears:\n                    other, other_dis = near\n                    # Distances are from edge to edge see #2\n                    other_dis += self.player.radius\n                    # Skip if further\n                    if other_dis > dis:\n                        continue\n\n                    # Determine if within `fov`\n                    other_rad = math.atan2(other.x - self.player.x, other.y - self.player.y)\n                    # Round to bearing within one revolution\n                    other_rad = other_rad % (math.pi*2)\n                    round_rad = rad % (math.pi*2)\n                    if abs(other_rad - round_rad) < (sensor.fov/2):\n                        sensor.proximity = other_dis - self.player.radius\n                        sensor.sensed_type = other.btype\n                        dis = other_dis\n\n            # Redirect sensor lines\n            # TODO: Decouple into view rendering\n            end = pos.copy()\n            end.x += math.sin(rad) * dis\n            end.y += math.cos(rad) * dis\n            sensor.line.start = pos\n            sensor.line.end = end\n            sensor.line.color = self.player.palette[sensor.sensed_type] + (int(255*0.5),)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_state(self):\n        # Include battery level in state\n        battery = self.player.stats['battery']/100\n        # Create observation from sensor proximities\n        # TODO: Have state persist, then update columns by `sensed_type`\n\n        # Multi-channel; detecting `items`\n        if len(self.mode['items']) > 0:\n            observation = []\n            for sensor in self.player.sensors:\n                col = []\n                # Always include range in channel 0\n                col.append(sensor.proximity_norm())\n                for item_type in self.mode['items']:\n                    if sensor.sensed_type == item_type:\n                        col.append(sensor.proximity_norm())\n                    else:\n                        # Default to 1 (`max_range/max_range`)\n                        col.append(1)\n                observation.append(col)\n            if 'battery' in self.mode:\n                observation.append([battery,1,1])\n\n        # Single-channel; walls only\n        else:\n            observation = [o.proximity_norm() for o in self.player.sensors]\n            if 'battery' in self.mode:\n                observation.append(battery)\n\n        return observation", "response": "Create state from sensors and battery levels and state columns."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_rotation(self, dt, buttons):\n        assert isinstance(buttons, dict)\n\n        ma = buttons['right'] - buttons['left']\n        if ma != 0:\n            self.stats['battery'] -= self.battery_use['angular']\n            self.rotation += ma * dt * self.angular_velocity\n\n        # Redirect velocity in new direction\n        a = math.radians(self.rotation)\n        self.impulse_dir = eu.Vector2(math.sin(a), math.cos(a))", "response": "Updates rotation and impulse direction"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmove the current time - vector to the new location.", "response": "def do_move(self, dt, buttons):\n        \"\"\"\n        Updates velocity and returns Rects for start/finish positions\n        \"\"\"\n        assert isinstance(dt, int) or isinstance(dt, float)\n        assert isinstance(buttons, dict)\n\n        newVel = self.velocity\n\n        # Redirect existing vel to new direction.\n        nv = newVel.magnitude()\n        newVel = nv * self.impulse_dir\n\n        mv = buttons['up']\n        if mv != 0:\n            self.stats['battery'] -= self.battery_use['linear']\n            newVel += dt * mv * self.accel * self.impulse_dir\n        else:\n            brake = dt * self.deaccel\n            if nv < brake:\n                newVel *= 0\n            else:\n                newVel += brake * -self.impulse_dir\n\n        nv = newVel.magnitude()\n        if nv > self.top_speed:\n            newVel *= self.top_speed / nv\n\n        return newVel"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread and return txt content of file", "response": "def read(*paths):\n    '''read and return txt content of file'''\n    with open(os.path.join(os.path.dirname(__file__), *paths)) as fp:\n        return fp.read()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_version(*paths):\n    '''reads a file and returns the defined __version__ value'''\n    version_match = re.search(r\"^__version__ ?= ?['\\\"]([^'\\\"]*)['\\\"]\",\n                              read(*paths), re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")", "response": "reads a file and returns the defined __version__ value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compile_excludes(self):\n        self.compiled_exclude_files = []\n        for pattern in self.exclude_files:\n            try:\n                self.compiled_exclude_files.append(re.compile(pattern))\n            except re.error as e:\n                raise ValueError(\n                    \"Bad python regex in exclude '%s': %s\" % (pattern, str(e)))", "response": "Compile a set of regexps for files to be exlcuded from scans."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntruing if file should be excluded based on name pattern.", "response": "def exclude_file(self, file):\n        \"\"\"True if file should be exclude based on name pattern.\"\"\"\n        for pattern in self.compiled_exclude_files:\n            if (pattern.match(file)):\n                return(True)\n        return(False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate or extend resource_list with resources from disk scan.", "response": "def from_disk(self, resource_list=None, paths=None):\n        \"\"\"Create or extend resource_list with resources from disk scan.\n\n        Assumes very simple disk path to URL mapping (in self.mapping): chop\n        path and replace with url_path. Returns the new or extended ResourceList\n        object.\n\n        If a resource_list is specified then items are added to that rather\n        than creating a new one.\n\n        If paths is specified then these are used instead of the set\n        of local paths in self.mapping.\n\n        Example usage with mapping start paths:\n\n        mapper=Mapper('http://example.org/path','/path/to/files')\n        rlb = ResourceListBuilder(mapper=mapper)\n        m = rlb.from_disk()\n\n        Example usage with explicit paths:\n\n        mapper=Mapper('http://example.org/path','/path/to/files')\n        rlb = ResourceListBuilder(mapper=mapper)\n        m = rlb.from_disk(paths=['/path/to/files/a','/path/to/files/b'])\n        \"\"\"\n        num = 0\n        # Either use resource_list passed in or make a new one\n        if (resource_list is None):\n            resource_list = ResourceList()\n        # Compile exclude pattern matches\n        self.compile_excludes()\n        # Work out start paths from map if not explicitly specified\n        if (paths is None):\n            paths = []\n            for map in self.mapper.mappings:\n                paths.append(map.dst_path)\n        # Set start time unless already set (perhaps because building in\n        # chunks)\n        if (resource_list.md_at is None):\n            resource_list.md_at = datetime_to_str()\n        # Run for each map in the mappings\n        for path in paths:\n            self.logger.info(\"Scanning disk from %s\" % (path))\n            self.from_disk_add_path(path=path, resource_list=resource_list)\n        # Set end time\n        resource_list.md_completed = datetime_to_str()\n        return(resource_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd resources from disk scan starting at path.", "response": "def from_disk_add_path(self, path=None, resource_list=None):\n        \"\"\"Add to resource_list with resources from disk scan starting at path.\"\"\"\n        # sanity\n        if (path is None or resource_list is None or self.mapper is None):\n            raise ValueError(\"Must specify path, resource_list and mapper\")\n        # is path a directory or a file? for each file: create Resource object,\n        # add, increment counter\n        if (sys.version_info < (3, 0)):\n            path = path.decode('utf-8')\n        if os.path.isdir(path):\n            num_files = 0\n            for dirpath, dirs, files in os.walk(path, topdown=True):\n                for file_in_dirpath in files:\n                    num_files += 1\n                    if (num_files % 50000 == 0):\n                        self.logger.info(\n                            \"ResourceListBuilder.from_disk_add_path: %d files...\" % (num_files))\n                    self.add_file(resource_list=resource_list,\n                                  dir=dirpath, file=file_in_dirpath)\n                    # prune list of dirs based on self.exclude_dirs\n                    for exclude in self.exclude_dirs:\n                        if exclude in dirs:\n                            self.logger.debug(\"Excluding dir %s\" % (exclude))\n                            dirs.remove(exclude)\n        else:\n            # single file\n            self.add_file(resource_list=resource_list, file=path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_file(self, resource_list=None, dir=None, file=None):\n        try:\n            if self.exclude_file(file):\n                self.logger.debug(\"Excluding file %s\" % (file))\n                return\n            # get abs filename and also URL\n            if (dir is not None):\n                file = os.path.join(dir, file)\n            if (not os.path.isfile(file) or not (\n                    self.include_symlinks or not os.path.islink(file))):\n                return\n            uri = self.mapper.dst_to_src(file)\n            if (uri is None):\n                raise Exception(\"Internal error, mapping failed\")\n            file_stat = os.stat(file)\n        except OSError as e:\n            sys.stderr.write(\"Ignoring file %s (error: %s)\" % (file, str(e)))\n            return\n        timestamp = file_stat.st_mtime  # UTC\n        r = Resource(uri=uri, timestamp=timestamp)\n        if (self.set_path):\n            # add full local path\n            r.path = file\n        if (self.set_hashes):\n            hasher = Hashes(self.set_hashes, file)\n            if ('md5' in self.set_hashes):\n                r.md5 = hasher.md5\n            if ('sha-1' in self.set_hashes):\n                r.sha1 = hasher.sha1\n            if ('sha-256' in self.set_hashes):\n                r.sha256 = hasher.sha256\n        if (self.set_length):\n            # add length\n            r.length = file_stat.st_size\n        resource_list.add(r)", "response": "Add a single file to the resource_list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_file_extension(filepath, ext_required):\n    '''Assert that a filepath has the required file extension\n\n    :param filepath: string filepath presumably containing a file extension\n    :param ext_required: the expected file extension\n        examples: \".pdf\", \".html\", \".tex\"\n    '''\n    ext = os.path.splitext(filepath)[-1]\n    if ext != ext_required:\n        msg_tmpl = \"The extension for {}, which is {}, does not equal {}\"\n        msg_format = msg_tmpl.format(filepath, ext, ext_required)\n        raise ValueError(msg_format)\n    return True", "response": "Assert that a filepath has the required file extension\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_binary(system_binary_str):\n    '''Assert that a string represents a system binary\n\n    Return true if a string represents a system binary\n    Raise TypeError if the system_binary_str is not a string\n    Raise ValueError if the system_binary_str is not a system binary\n\n    :param system_binary_str: STR string representing a system binary\n    '''\n    if not isinstance(system_binary_str, str):\n        raise TypeError(\"{} must be of type STR\".format(system_binary_str))\n    binary_str = shutil.which(system_binary_str)\n    if not binary_str:\n        msg = \"{} is not valid system binary\".format(system_binary_str)\n        raise ValueError(msg)\n    return True", "response": "Assert that a string represents a system binary"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_is_type(ls, t):\n    '''Assert that a list contains only elements of type t\n\n    Return True if list contains elements of type t\n    Raise TypeError if t is not a class\n    Raise TypeError if ls is not a list\n    Raise TypeError if ls contains non-t elements\n\n    :param ls: LIST\n    :param t: python class\n    '''\n    if not isclass(t):\n        raise TypeError(\"{} is not a class\".format(t))\n    elif not isinstance(ls, list):\n        raise TypeError(\"{} is not a list\".format(ls))\n    else:\n        ls_bad_types = [i for i in ls if not isinstance(i, t)]\n        if len(ls_bad_types) > 0:\n            raise TypeError(\"{} are not {}\".format(ls_bad_types, t))\n    return True", "response": "Assert that a list contains only elements of type t"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting a table for dict = formatted list conditionally include numbers.", "response": "def indx_table(node_dict, tbl_mode=False):\n    \"\"\"Print Table for dict=formatted list conditionally include numbers.\"\"\"\n    nt = PrettyTable()\n    nt.header = False\n    nt.padding_width = 2\n    nt.border = False\n    clr_num = C_TI + \"NUM\"\n    clr_name = C_TI + \"NAME\"\n    clr_state = \"STATE\" + C_NORM\n    t_lu = {True: [clr_num, \"NAME\", \"REGION\", \"CLOUD\",\n                   \"SIZE\", \"PUBLIC IP\", clr_state],\n            False: [clr_name, \"REGION\", \"CLOUD\", \"SIZE\",\n                    \"PUBLIC IP\", clr_state]}\n    nt.add_row(t_lu[tbl_mode])\n    for i, node in node_dict.items():\n        state = C_STAT[node.state] + node.state + C_NORM\n        inum = C_WARN + str(i) + C_NORM\n        if node.public_ips:\n            n_ip = node.public_ips\n        else:\n            n_ip = \"-\"\n        r_lu = {True: [inum, node.name, node.zone, node.cloud,\n                       node.size, n_ip, state],\n                False: [node.name, node.zone, node.cloud,\n                        node.size, n_ip, state]}\n        nt.add_row(r_lu[tbl_mode])\n    if not tbl_mode:\n        print(nt)\n    else:\n        idx_tbl = nt.get_string()\n        return idx_tbl"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef new(path='.', template=None):\n    path = abspath(path.rstrip(sep))\n    template = template or DEFAULT_TEMPLATE_URL\n    render_skeleton(\n        template, path,\n        include_this=['.gitignore'],\n        filter_this=[\n            '~*', '*.py[co]',\n            '__pycache__', '__pycache__/*',\n            '.git', '.git/*',\n            '.hg', '.hg/*',\n            '.svn', '.svn/*',\n        ]\n    )\n    print(HELP_MSG % (path,))", "response": "Creates a new project\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(host=DEFAULT_HOST, port=DEFAULT_PORT, path='.'):\n    path = abspath(path)\n    c = Clay(path)\n    c.run(host=host, port=port)", "response": "Run the development server"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a static copy of the sources", "response": "def build(pattern=None, path='.'):\n    \"\"\"Generates a static copy of the sources\n    \"\"\"\n    path = abspath(path)\n    c = Clay(path)\n    c.build(pattern)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransforms a frequency_map into a map of probability using the sum of all frequencies as the total.", "response": "def frequency_to_probability(frequency_map, decorator=lambda f: f):\n    \"\"\"Transform a ``frequency_map`` into a map of probability using the sum of all frequencies as the total.\n\n    Example:\n        >>> frequency_to_probability({'a': 2, 'b': 2})\n        {'a': 0.5, 'b': 0.5}\n\n    Args:\n        frequency_map (dict): The dictionary to transform\n        decorator (function): A function to manipulate the probability\n\n    Returns:\n        Dictionary of ngrams to probability\n    \"\"\"\n    total = sum(frequency_map.values())\n    return {k: decorator(v / total) for k, v in frequency_map.items()}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the index of coincidence for one or more texts.", "response": "def index_of_coincidence(*texts):\n    \"\"\"Calculate the index of coincidence for one or more ``texts``.\n    The results are averaged over multiple texts to return the delta index of coincidence.\n\n    Examples:\n        >>> index_of_coincidence(\"aabbc\")\n        0.2\n\n        >>> index_of_coincidence(\"aabbc\", \"abbcc\")\n        0.2\n\n    Args:\n        *texts (variable length argument list): The texts to analyze\n\n    Returns:\n        Decimal value of the index of coincidence\n\n    Raises:\n        ValueError: If texts is empty\n        ValueError: If any text is less that 2 character long\n    \"\"\"\n    if not texts:\n        raise ValueError(\"texts must not be empty\")\n\n    return statistics.mean(_calculate_index_of_coincidence(frequency_analyze(text), len(text)) for text in texts)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _calculate_index_of_coincidence(frequency_map, length):\n    if length <= 1:\n        return 0\n        # We cannot error here as length can legitimiately be 1.\n        # Imagine a ciphertext of length 3 and a key of length 2.\n        # Spliting this text up and calculating the index of coincidence results in ['AC', 'B']\n        # IOC of B will be calcuated for the 2nd column of the key. We could represent the same\n        # encryption with a key of length 3 but then we encounter the same problem. This is also\n        # legitimiate encryption scheme we cannot ignore. Hence we have to deal with this fact here\n        # A value of 0 will impact the overall mean, however it does make some sense when you ask the question\n        # How many ways to choose 2 letters from the text, if theres only 1 letter then the answer is 0.\n\n    # Mathemtical combination, number of ways to choose 2 letters, no replacement, order doesnt matter\n    combination_of_letters = sum(freq * (freq - 1) for freq in frequency_map.values())\n    return combination_of_letters / (length * (length - 1))", "response": "Calculates the index of the coincidence of the given frequency_map."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef chi_squared(source_frequency, target_frequency):\n    # Ignore any symbols from source that are not in target.\n    # TODO: raise Error if source_len is 0?\n    target_prob = frequency_to_probability(target_frequency)\n    source_len = sum(v for k, v in source_frequency.items() if k in target_frequency)\n\n    result = 0\n    for symbol, prob in target_prob.items():\n        symbol_frequency = source_frequency.get(symbol, 0)  # Frequecy is 0 if it doesnt appear in source\n        result += _calculate_chi_squared(symbol_frequency, prob, source_len)\n\n    return result", "response": "Calculates the Chi Squared statistic by comparing source_frequency with target_frequency."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_ngram(name):\n    module = importlib.import_module('lantern.analysis.english_ngrams.{}'.format(name))\n    return getattr(module, name)", "response": "Dynamically import the python module with the ngram defined as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nscoring text using score_functions.", "response": "def score(text, *score_functions):\n    \"\"\"Score ``text`` using ``score_functions``.\n\n    Examples:\n        >>> score(\"abc\", function_a)\n        >>> score(\"abc\", function_a, function_b)\n\n    Args:\n        text (str): The text to score\n        *score_functions (variable length argument list): functions to score with\n\n    Returns:\n        Arithmetic mean of scores\n\n    Raises:\n        ValueError: If score_functions is empty\n    \"\"\"\n    if not score_functions:\n        raise ValueError(\"score_functions must not be empty\")\n\n    return statistics.mean(func(text) for func in score_functions)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef PatternMatch(regex):\n    pattern = re.compile(regex)\n    return lambda text: -1 if pattern.search(text) is None else 0", "response": "Compute the score of a text by determing if a pattern matches."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _request(self, url, params={}):\n        r = self._session.get(url=url, params=params, headers=DEFAULT_ORIGIN)\n        return r", "response": "Makes a request using the currently open session."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend out an event and call it s associated functions", "response": "def emit(self, event, *args, **kwargs):\n        \"\"\"Send out an event and call it's associated functions\n\n        :param event: Name of the event to trigger\n        \"\"\"\n        for func in self._registered_events[event].values():\n            func(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_all_listeners(self, event=None):\n        if event is not None:\n            self._registered_events[event] = OrderedDict()\n        else:\n            self._registered_events = defaultdict(OrderedDict)", "response": "Remove all functions for all events or one event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the current state of the local spotify client", "response": "def get_current_status(self):\n        \"\"\"Returns the current state of the local spotify client\"\"\"\n        url = get_url(\"/remote/status.json\")\n        params = {\"oauth\": self._oauth_token, \"csrf\": self._csrf_token}\n        r = self._request(url=url, params=params)\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npauses the spotify player s current state.", "response": "def pause(self, pause=True):\n        \"\"\"Pauses the spotify player\n\n        :param pause: boolean value to choose the pause/play state\n        \"\"\"\n        url: str = get_url(\"/remote/pause.json\")\n        params = {\n            \"oauth\": self._oauth_token,\n            \"csrf\": self._csrf_token,\n            \"pause\": \"true\" if pause else \"false\",\n        }\n        self._request(url=url, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplays a Spotify uri for example spotify : track : 5Yn8WCB4Dqm8snemB5Mu4K", "response": "def playURI(self, uri):\n        \"\"\"Play a Spotify uri, for example spotify:track:5Yn8WCB4Dqm8snemB5Mu4K\n\n        :param uri: Playlist, Artist, Album, or Song Uri\n        \"\"\"\n        url: str = get_url(\"/remote/play.json\")\n        params = {\n            \"oauth\": self._oauth_token,\n            \"csrf\": self._csrf_token,\n            \"uri\": uri,\n            \"context\": uri,\n        }\n        r = self._request(url=url, params=params)\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef listen(self, wait=60, blocking=True):\n        url = get_url(\"/remote/status.json\")\n\n        def listen_for_status_change():\n            params = {\"oauth\": self._oauth_token, \"csrf\": self._csrf_token}\n            r = self._request(url=url, params=params)\n            old = r.json()\n            self.emit(\"status_change\", old)\n            params = {\n                \"oauth\": self._oauth_token,\n                \"csrf\": self._csrf_token,\n                \"returnon\": \"play,pause,error,ap\",\n                \"returnafter\": wait,\n            }\n            while True:\n                r = self._request(url=url, params=params)\n                new = r.json()\n\n                if new != old:\n                    self.emit(\"status_change\", new)\n\n                if new[\"playing\"] != old[\"playing\"]:\n                    self.emit(\"play_state_change\", new)\n\n                if (\n                    new[\"track\"][\"track_resource\"][\"uri\"]\n                    != old[\"track\"][\"track_resource\"][\"uri\"]\n                ):\n                    self.emit(\"track_change\", new)\n\n                old = new\n\n        if blocking:\n            listen_for_status_change()\n        else:\n            thread = Thread(target=listen_for_status_change)\n            thread.daemon = True\n            thread.start()", "response": "Listen for events and call any associated callbacks when there is an event."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef authenticate(self):\n        resp = self.session.get(self.api_url, auth=self.auth)\n        resp = self._process_response(resp)\n        return resp", "response": "Authenticate with the api_url"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_os_and_browsers(self):\n        resp = self.session.get(os.path.join(self.api_url, 'browsers.json'))\n        resp = self._process_response(resp)\n        return resp.json()", "response": "Get all supported OS and browser combinations JSON response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating screenshots for the current user", "response": "def generate_screenshots(self):\n        \"\"\"\n        Take a config file as input and generate screenshots\n        \"\"\"\n        headers = {'content-type': 'application/json', 'Accept': 'application/json'}\n        resp = requests.post(self.api_url, data=json.dumps(self.config), \\\n                             headers=headers, auth=self.auth)\n        resp = self._process_response(resp)\n        return resp.json()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning true if the screenshots job is done", "response": "def screenshots_done(self, jobid):\n        \"\"\"\n        Return true if the screenshots job is done\n        \"\"\"\n        resp = self.session.get(os.path.join(self.api_url, '{0}.json'.format(jobid)))\n        resp = self._process_response(resp)\n        return True if resp.json()['state'] == 'done' else False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_items(self):\n        if not self.mode['items'] or len(self.mode['items']) == 0: return\n\n        # FIXME: Check if already contains\n        self.collman.add(self.player)\n\n        for k in self.mode['items']:\n            item = self.mode['items'][k]\n            #{'terminal': False, 'num': 50, 'scale': 1.0, 'reward': 2.0}\n            radius = item['scale'] * self.player.radius\n            for i in range(item['num']):\n                self.add_item(radius, k)", "response": "Create collidable items\n        Create items with radius and size of items"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_item(self, radius, item_type):\n        assert isinstance(radius, int) or isinstance(radius, float)\n        assert isinstance(item_type, str)\n\n        separation_scale = 1.1\n        min_separation = separation_scale * radius\n\n        # Removable item\n        item = Collidable(0, 0, radius, item_type, self.pics[item_type], True)\n        cntTrys = 0\n        while cntTrys < 100:\n            cx = radius + random.random() * (self.width - 2.0 * radius)\n            cy = radius + random.random() * (self.height - 2.0 * radius)\n\n            # Test if colliding with wall.\n            # Top left\n            cells = []\n            cells.append(self.map_layer.get_at_pixel(cx-radius, cy-radius))\n            # Top right\n            cells.append(self.map_layer.get_at_pixel(cx+radius, cy-radius))\n            # Bottom  left\n            cells.append(self.map_layer.get_at_pixel(cx-radius, cy+radius))\n            # Bottom  right\n            cells.append(self.map_layer.get_at_pixel(cx+radius, cy+radius))\n\n            wall = False\n            for cell in cells:\n                wall = cell and cell.tile and cell.tile.id > 0\n                if wall:\n                    break\n\n            if wall:\n                continue\n\n            item.update_center(eu.Vector2(cx, cy))\n            if self.collman.any_near(item, min_separation) is None:\n                self.add(item, z=self.z)\n                self.z += 1\n                self.collman.add(item)\n                break\n            cntTrys += 1", "response": "Add a single item in random open position."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_collisions(self):\n        if not self.mode['items'] or len(self.mode['items']) == 0: return\n\n        # update collman\n        # FIXME: Why update each frame?\n        self.collman.clear()\n        for z, node in self.children:\n            if hasattr(node, 'cshape') and type(node.cshape) == cm.CircleShape:\n                self.collman.add(node)\n\n        # interactions player - others\n        for other in self.collman.iter_colliding(self.player):\n            typeball = other.btype\n            self.logger.debug('collision', typeball)\n\n            # TODO: Limit player position on non-removable items\n            #if not other.removable:\n            #    pass\n\n            if other.removable:\n                self.to_remove.append(other)\n\n            self.reward_item(typeball)\n\n        #\n        #    elif (typeball == 'wall' or\n        #          typeball == 'gate' and self.cnt_food > 0):\n        #        self.level_losed()\n        #\n        #    elif typeball == 'gate':\n        #        self.level_conquered()\n\n        self.remove_items()", "response": "Update the collman with items that are not in the player."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_view(self, view_class, *args, **kwargs):\n        protected_view_class = self.view_class_factory(view_class)\n        if 'endpoint' not in kwargs:\n            kwargs['endpoint'] = view_class(*args, **kwargs).endpoint\n        self.admin.add_view(protected_view_class(*args, **kwargs))", "response": "Register an admin view on this admin instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads administration interface from entry point group.", "response": "def load_entry_point_group(self, entry_point_group):\n        \"\"\"Load administration interface from entry point group.\n\n        :param str entry_point_group: Name of the entry point group.\n        \"\"\"\n        for ep in pkg_resources.iter_entry_points(group=entry_point_group):\n            admin_ep = dict(ep.load())\n            keys = tuple(\n                k in admin_ep for k in ('model', 'modelview', 'view_class'))\n\n            if keys == (False, False, True):\n                self.register_view(\n                    admin_ep.pop('view_class'),\n                    *admin_ep.pop('args', []),\n                    **admin_ep.pop('kwargs', {})\n                )\n            elif keys == (True, True, False):\n                warnings.warn(\n                    'Usage of model and modelview kwargs are deprecated in '\n                    'favor of view_class, args and kwargs.',\n                    PendingDeprecationWarning\n                )\n                self.register_view(\n                    admin_ep.pop('modelview'),\n                    admin_ep.pop('model'),\n                    admin_ep.pop('session', db.session),\n                    **admin_ep\n                )\n            else:\n                raise Exception(\n                    'Admin entry point dictionary must contain '\n                    'either \"view_class\" OR \"model\" and \"modelview\" keys.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the Flask application.", "response": "def init_app(self,\n                 app,\n                 entry_point_group='invenio_admin.views',\n                 permission_factory=None,\n                 view_class_factory=protected_adminview_factory,\n                 index_view_class=AdminIndexView):\n        \"\"\"Flask application initialization.\n\n        :param app: The Flask application.\n        :param entry_point_group: Name of entry point group to load\n            views/models from. (Default: ``'invenio_admin.views'``)\n        :param permission_factory: Default permission factory to use when\n            protecting an admin view. (Default:\n            :func:`~.permissions.admin_permission_factory`)\n        :param view_class_factory: Factory for creating admin view classes on\n            the fly. Used to protect admin views with authentication and\n            authorization. (Default:\n            :func:`~.views.protected_adminview_factory`)\n        :param index_view_class: Specify administrative interface index page.\n            (Default: :class:`flask_admin.base.AdminIndexView`)\n        :param kwargs: Passed to :class:`flask_admin.base.Admin`.\n        :returns: Extension state.\n        \"\"\"\n        self.init_config(app)\n\n        default_permission_factory = app.config['ADMIN_PERMISSION_FACTORY']\n        permission_factory = permission_factory or \\\n            import_string(default_permission_factory)\n\n        # Create administration app.\n\n        admin = Admin(\n            app,\n            name=app.config['ADMIN_APPNAME'],\n            template_mode=app.config['ADMIN_TEMPLATE_MODE'],\n            index_view=view_class_factory(index_view_class)(),\n        )\n\n        @app.before_first_request\n        def lazy_base_template():\n            \"\"\"Initialize admin base template lazily.\"\"\"\n            base_template = app.config.get('ADMIN_BASE_TEMPLATE')\n            if base_template:\n                admin.base_template = base_template\n\n        # Create admin state\n        state = _AdminState(app, admin, permission_factory, view_class_factory)\n        if entry_point_group:\n            state.load_entry_point_group(entry_point_group)\n\n        app.extensions['invenio-admin'] = state\n        return state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_url(url):\n    sub = \"{0}.spotilocal.com\".format(\"\".join(choices(ascii_lowercase, k=10)))\n    return \"http://{0}:{1}{2}\".format(sub, DEFAULT_PORT, url)", "response": "Ranomdly generates a url for use in requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves a simple OAuth Token for use with the local http client.", "response": "def get_oauth_token():\n    \"\"\"Retrieve a simple OAuth Token for use with the local http client.\"\"\"\n    url = \"{0}/token\".format(DEFAULT_ORIGIN[\"Origin\"])\n    r = s.get(url=url)\n    return r.json()[\"t\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_csrf_token():\n    url = get_url(\"/simplecsrf/token.json\")\n    r = s.get(url=url, headers=DEFAULT_ORIGIN)\n    return r.json()[\"token\"]", "response": "Retrieve a simple csrf token for to prevent cross site request forgery."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_menu():\n    # Register settings menu\n    item = current_menu.submenu('settings.admin')\n    item.register(\n        \"admin.index\",\n        # NOTE: Menu item text (icon replaced by a cogs icon).\n        _('%(icon)s Administration', icon='<i class=\"fa fa-cogs fa-fw\"></i>'),\n        visible_when=_has_admin_access,\n        order=100)", "response": "Initialize menu before first request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef protected_adminview_factory(base_class):\n    class ProtectedAdminView(base_class):\n        \"\"\"Admin view class protected by authentication.\"\"\"\n\n        def _handle_view(self, name, **kwargs):\n            \"\"\"Override Talisman CSP header configuration for admin views.\n\n            Flask-Admin extension is not CSP compliant (see:\n            https://github.com/flask-admin/flask-admin/issues/1135).\n            To avoid UI malfunctions, the CSP header (globally set on each\n            request by Talisman extension) must be overridden and removed.\n            Remove this code if and when Flask-Admin will be completely CSP\n            compliant.\n            \"\"\"\n            invenio_app = current_app.extensions.get('invenio-app', None)\n            if invenio_app:\n                setattr(invenio_app.talisman.local_options,\n                        'content_security_policy', None)\n            return super(ProtectedAdminView, self)._handle_view(name, **kwargs)\n\n        def is_accessible(self):\n            \"\"\"Require authentication and authorization.\"\"\"\n            return current_user.is_authenticated and \\\n                   current_admin.permission_factory(self).can() and \\\n                   super(ProtectedAdminView, self).is_accessible()\n\n        def inaccessible_callback(self, name, **kwargs):\n            \"\"\"Redirect to login if user is not logged in.\n\n            :param name: View function name.\n            :param kwargs: Passed to the superclass' `inaccessible_callback`.\n            \"\"\"\n            if not current_user.is_authenticated:\n                # Redirect to login page if user is not logged in.\n                return redirect(url_for(\n                    current_app.config['ADMIN_LOGIN_ENDPOINT'],\n                    next=request.url))\n            super(ProtectedAdminView, self).inaccessible_callback(\n                name, **kwargs)\n\n    return ProtectedAdminView", "response": "Factory for creating protected admin view classes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating config against models.", "response": "def validate_config(self):\n        '''validate_config\n\n        High-level api: Validate config against models. ConfigError is raised\n        if the config has issues.\n\n        Returns\n        -------\n\n        None\n            There is no return of this method.\n\n        Raises\n        ------\n\n        ConfigError\n            If config contains error.\n        '''\n\n        self.roots\n        for child in self.ele.getchildren():\n            self._validate_node(child)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef xpath(self, *args, **kwargs):\n        '''xpath\n\n        High-level api: It is a wrapper of xpath method in lxml package. If\n        namespaces is not given, self.ns is used by default.\n\n        Returns\n        -------\n\n        boolean or float or str or list\n            Refer to http://lxml.de/xpathxslt.html#xpath-return-values\n        '''\n\n        if 'namespaces' not in kwargs:\n            kwargs['namespaces'] = {i[1]: i[2] for i in self.device.namespaces\n                                    if i[1] is not None}\n        return self.ele.xpath(*args, **kwargs)", "response": "Wrapper for xpath method in lxml package."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfilter the config using xpath method.", "response": "def filter(self, *args, **kwargs):\n        '''filter\n\n        High-level api: Filter the config using xpath method. If namespaces is\n        not given, self.ns is used by default.\n\n        Returns\n        -------\n\n        Config\n            A new Config instance which has less content according to your\n            filter xpath expression.\n        '''\n\n        ancestors = set()\n        filtrates = set()\n        config = type(self)(self.device,  deepcopy(self.ele))\n        results = config.xpath(*args, **kwargs)\n        if isinstance(results, list):\n            for node in results:\n                if etree.iselement(node):\n                    ancestors |= set(list(node.iterancestors()))\n                    filtrates.add(node)\n            if filtrates:\n                config._node_filter(config.ele, ancestors, filtrates)\n            else:\n                config.ele = etree.Element(config_tag, nsmap={'nc': nc_url})\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating one config node. This method is a recursive method. This method is a recursive method. This method is a recursive method. This method is a recursive method. This method is a recursive method.", "response": "def _validate_node(self, node):\n        '''_validate_node\n\n        Low-level api: Validate one config node. This is a recursive method. An\n        exception will be raised if validation fails.\n\n        Parameters\n        ----------\n\n        node : `Element`\n            An Element node in config tree.\n\n        Returns\n        -------\n\n        None\n            There is no return of this method.\n        '''\n\n        c = Composer(self.device, node)\n        if c.schema_node is None:\n            p = self.device.get_xpath(node, instance=False)\n            raise ConfigError('schema node of the config node not ' \\\n                              'found: {}'.format(p))\n        if c.schema_node.get('type') == 'list':\n            for key in c.keys:\n                if node.find(key) is None:\n                    p = self.device.get_xpath(node, instance=False)\n                    raise ConfigError(\"missing key '{}' of the config \" \\\n                                      \"node {}\".format(key, p))\n\n        for tag in operation_tag, insert_tag, value_tag, key_tag:\n            if node.get(tag):\n                raise ConfigError(\"the config node contains invalid \" \\\n                                  \"attribute '{}': {}\" \\\n                                  .format(tag, self.device.get_xpath(node)))\n\n        for child in node.getchildren():\n            if len(child) > 0:\n                self._validate_node(child)\n\n            # clean up empty containers\n            child_schema_node = self.device.get_schema_node(child)\n            if child_schema_node is None:\n                raise ConfigError(\"schema node of the config node {} cannot \" \\\n                                  \"be found:\\n{}\" \\\n                                  .format(self.device.get_xpath(child), self))\n            if len(child) == 0 and \\\n               child_schema_node.get('type') == 'container' and \\\n               child_schema_node.get('presence') != 'true':\n                node.remove(child)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef client_getter():\n    def wrapper(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            if 'client_id' not in kwargs:\n                abort(500)\n\n            client = Client.query.filter_by(\n                client_id=kwargs.pop('client_id'),\n                user_id=current_user.get_id(),\n            ).first()\n\n            if client is None:\n                abort(404)\n\n            return f(client, *args, **kwargs)\n        return decorated\n    return wrapper", "response": "Decorator to retrieve Client object and check user permission."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef token_getter(is_personal=True, is_internal=False):\n    def wrapper(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            if 'token_id' not in kwargs:\n                abort(500)\n\n            token = Token.query.filter_by(\n                id=kwargs.pop('token_id'),\n                user_id=current_user.get_id(),\n                is_personal=is_personal,\n                is_internal=is_internal,\n            ).first()\n\n            if token is None:\n                abort(404)\n\n            return f(token, *args, **kwargs)\n        return decorated\n    return wrapper", "response": "Decorator to retrieve Token object and check user permission."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef client_view(client):\n    if request.method == 'POST' and 'delete' in request.form:\n        db.session.delete(client)\n        db.session.commit()\n        return redirect(url_for('.index'))\n\n    form = ClientForm(request.form, obj=client)\n    if form.validate_on_submit():\n        form.populate_obj(client)\n        db.session.commit()\n\n    return render_template(\n        'invenio_oauth2server/settings/client_view.html',\n        client=client,\n        form=form,\n    )", "response": "Show client s detail."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreset client s secret.", "response": "def client_reset(client):\n    \"\"\"Reset client's secret.\"\"\"\n    if request.form.get('reset') == 'yes':\n        client.reset_client_secret()\n        db.session.commit()\n    return redirect(url_for('.client_view', client_id=client.client_id))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrevokes an authorized application token.", "response": "def token_revoke(token):\n    \"\"\"Revoke Authorized Application token.\"\"\"\n    db.session.delete(token)\n    db.session.commit()\n    return redirect(url_for('.index'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshows permission garanted to authorized application token.", "response": "def token_permission_view(token):\n    \"\"\"Show permission garanted to authorized application token.\"\"\"\n    scopes = [current_oauth2server.scopes[x] for x in token.scopes]\n    return render_template(\n        \"invenio_oauth2server/settings/token_permission_view.html\",\n        token=token,\n        scopes=scopes,\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_state(self, site, timestamp=None):\n        parser = ConfigParser()\n        parser.read(self.status_file)\n        status_section = 'incremental'\n        if (not parser.has_section(status_section)):\n            parser.add_section(status_section)\n        if (timestamp is None):\n            parser.remove_option(\n                status_section,\n                self.config_site_to_name(site))\n        else:\n            parser.set(\n                status_section,\n                self.config_site_to_name(site),\n                str(timestamp))\n        with open(self.status_file, 'w') as configfile:\n            parser.write(configfile)\n            configfile.close()", "response": "Write status dict to client status file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads client status file and return dict.", "response": "def get_state(self, site):\n        \"\"\"Read client status file and return dict.\"\"\"\n        parser = ConfigParser()\n        status_section = 'incremental'\n        parser.read(self.status_file)\n        timestamp = None\n        try:\n            timestamp = float(\n                parser.get(\n                    status_section,\n                    self.config_site_to_name(site)))\n        except NoSectionError as e:\n            pass\n        except NoOptionError as e:\n            pass\n        return(timestamp)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef escape_latex_str_if_str(value):\n    '''Escape a latex string'''\n    if not isinstance(value, str):\n        return value\n    for regex, replace_text in REGEX_ESCAPE_CHARS:\n        value = re.sub(regex, replace_text, value)\n    value = re.sub(REGEX_BACKSLASH, r'\\\\\\\\', value)\n    return value", "response": "Escape a latex string if it is a string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resources_as_xml(self, resources, sitemapindex=False, fh=None):\n        # element names depending on sitemapindex or not\n        root_element = ('sitemapindex' if (sitemapindex) else 'urlset')\n        item_element = ('sitemap' if (sitemapindex) else 'url')\n        # namespaces and other settings\n        namespaces = {'xmlns': SITEMAP_NS, 'xmlns:rs': RS_NS}\n        root = Element(root_element, namespaces)\n        if (self.pretty_xml):\n            root.text = \"\\n\"\n        # <rs:ln>\n        if (hasattr(resources, 'ln')):\n            for ln in resources.ln:\n                self.add_element_with_atts_to_etree(root, 'rs:ln', ln)\n        # <rs:md>\n        if (hasattr(resources, 'md')):\n            self.add_element_with_atts_to_etree(root, 'rs:md', resources.md)\n        # <url> entries from either an iterable or an iterator\n        for r in resources:\n            e = self.resource_etree_element(r, element_name=item_element)\n            root.append(e)\n        # have tree, now serialize\n        tree = ElementTree(root)\n        xml_buf = None\n        if (fh is None):\n            xml_buf = io.StringIO()\n            fh = xml_buf\n        if (sys.version_info >= (3, 0)):\n            tree.write(\n                fh,\n                encoding='unicode',\n                xml_declaration=True,\n                method='xml')\n        elif (sys.version_info >= (2, 7)):\n            tree.write(\n                fh,\n                encoding='UTF-8',\n                xml_declaration=True,\n                method='xml')\n        else:  # python2.6\n            tree.write(fh, encoding='UTF-8')\n        if (xml_buf is not None):\n            if (sys.version_info >= (3, 0)):\n                return(xml_buf.getvalue())\n            else:\n                return(xml_buf.getvalue().decode('utf-8'))", "response": "Write or return XML for a set of resources in sitemap format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing an XML Sitemap and add it to the resources object.", "response": "def parse_xml(self, fh=None, etree=None, resources=None,\n                  capability=None, sitemapindex=None):\n        \"\"\"Parse XML Sitemap and add to resources object.\n\n        Reads from fh or etree and adds resources to a resorces object\n        (which must support the add method). Returns the resources object.\n\n        Also sets self.resources_created to be the number of resources created.\n        We adopt a very lax approach here. The parsing is properly namespace\n        aware but we search just for the elements wanted and leave everything\n        else alone.\n\n        This method will read either sitemap or sitemapindex documents. Behavior\n        depends on the sitemapindex parameter:\n        - None - will read either\n        - False - SitemapIndexError exception if sitemapindex detected\n        - True - SitemapIndexError exception if sitemap detected\n\n        Will set self.parsed_index based on whether a sitemap or sitemapindex\n        document was read:\n        - False - sitemap\n        - True - sitemapindex\n        \"\"\"\n        if (resources is None):\n            resources = ResourceContainer()\n        if (fh is not None):\n            etree = parse(fh)\n        elif (etree is None):\n            raise ValueError(\"Neither fh or etree set\")\n        # check root element: urlset (for sitemap), sitemapindex or bad\n        root_tag = etree.getroot().tag\n        resource_tag = None  # will be <url> or <sitemap> depending on type\n        self.parsed_index = None\n        if (root_tag == '{' + SITEMAP_NS + \"}urlset\"):\n            self.parsed_index = False\n            if (sitemapindex is not None and sitemapindex):\n                raise SitemapIndexError(\n                    \"Got sitemap when expecting sitemapindex\", etree)\n            resource_tag = '{' + SITEMAP_NS + \"}url\"\n        elif (root_tag == '{' + SITEMAP_NS + \"}sitemapindex\"):\n            self.parsed_index = True\n            if (sitemapindex is not None and not sitemapindex):\n                raise SitemapIndexError(\n                    \"Got sitemapindex when expecting sitemap\", etree)\n            resource_tag = '{' + SITEMAP_NS + \"}sitemap\"\n        else:\n            raise SitemapParseError(\n                \"XML is not sitemap or sitemapindex (root element is <%s>)\" %\n                root_tag)\n\n        # have what we expect, read it\n        in_preamble = True\n        self.resources_created = 0\n        seen_top_level_md = False\n        for e in etree.getroot().getchildren():\n            # look for <rs:md> and <rs:ln>, first <url> ends\n            # then look for resources in <url> blocks\n            if (e.tag == resource_tag):\n                in_preamble = False  # any later rs:md or rs:ln is error\n                r = self.resource_from_etree(e, self.resource_class)\n                try:\n                    resources.add(r)\n                except SitemapDupeError:\n                    self.logger.warning(\n                        \"dupe of: %s (lastmod=%s)\" %\n                        (r.uri, r.lastmod))\n                self.resources_created += 1\n            elif (e.tag == \"{\" + RS_NS + \"}md\"):\n                if (in_preamble):\n                    if (seen_top_level_md):\n                        raise SitemapParseError(\n                            \"Multiple <rs:md> at top level of sitemap\")\n                    else:\n                        resources.md = self.md_from_etree(e, 'preamble')\n                        seen_top_level_md = True\n                else:\n                    raise SitemapParseError(\n                        \"Found <rs:md> after first <url> in sitemap\")\n            elif (e.tag == \"{\" + RS_NS + \"}ln\"):\n                if (in_preamble):\n                    resources.ln.append(self.ln_from_etree(e, 'preamble'))\n                else:\n                    raise SitemapParseError(\n                        \"Found <rs:ln> after first <url> in sitemap\")\n            else:\n                # element we don't recognize, ignore\n                pass\n        # check that we read to right capability document\n        if (capability is not None):\n            if ('capability' not in resources.md):\n                if (capability == 'resourcelist'):\n                    self.logger.warning(\n                        'No capability specified in sitemap, assuming resourcelist')\n                    resources.md['capability'] = 'resourcelist'\n                else:\n                    raise SitemapParseError(\"Expected to read a %s document, but no capability specified in sitemap\" %\n                                            (capability))\n            if (resources.md['capability'] != capability):\n                raise SitemapParseError(\"Expected to read a %s document, got %s\" %\n                                        (capability, resources.md['capability']))\n        # return the resource container object\n        return(resources)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resource_etree_element(self, resource, element_name='url'):\n        e = Element(element_name)\n        sub = Element('loc')\n        sub.text = resource.uri\n        e.append(sub)\n        if (resource.timestamp is not None):\n            # Create appriate element for timestamp\n            sub = Element('lastmod')\n            sub.text = str(resource.lastmod)  # W3C Datetime in UTC\n            e.append(sub)\n        md_atts = {}\n        for att in ('capability', 'change', 'hash', 'length', 'path', 'mime_type',\n                    'md_at', 'md_completed', 'md_from', 'md_until'):\n            val = getattr(resource, att, None)\n            if (val is not None):\n                md_atts[self._xml_att_name(att)] = str(val)\n        if (len(md_atts) > 0):\n            md = Element('rs:md', md_atts)\n            e.append(md)\n        # add any <rs:ln>\n        if (hasattr(resource, 'ln') and\n                resource.ln is not None):\n            for ln in resource.ln:\n                self.add_element_with_atts_to_etree(e, 'rs:ln', ln)\n        if (self.pretty_xml):\n            e.tail = \"\\n\"\n        return(e)", "response": "Return an xml. etree. Element representing the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef resource_as_xml(self, resource):\n        e = self.resource_etree_element(resource)\n        if (sys.version_info >= (3, 0)):\n            # python3.x\n            return(tostring(e, encoding='unicode', method='xml'))\n        elif (sys.version_info >= (2, 7)):\n            s = tostring(e, encoding='UTF-8', method='xml')\n        else:\n            # must not specify method='xml' in python2.6\n            s = tostring(e, encoding='UTF-8')\n        # Chop off XML declaration that is added in 2.x... sigh\n        return(s.replace(\"<?xml version='1.0' encoding='UTF-8'?>\\n\", ''))", "response": "Return the XML string for the resource as part of an XML sitemap."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resource_from_etree(self, etree, resource_class):\n        loc_elements = etree.findall('{' + SITEMAP_NS + \"}loc\")\n        if (len(loc_elements) > 1):\n            raise SitemapParseError(\n                \"Multiple <loc> elements while parsing <url> in sitemap\")\n        elif (len(loc_elements) == 0):\n            raise SitemapParseError(\n                \"Missing <loc> element while parsing <url> in sitemap\")\n        else:\n            loc = loc_elements[0].text\n        if (loc is None or loc == ''):\n            raise SitemapParseError(\n                \"Bad <loc> element with no content while parsing <url> in sitemap\")\n        # must at least have a URI, make this object\n        resource = resource_class(uri=loc)\n        # and hopefully a lastmod datetime (but none is OK)\n        lastmod_elements = etree.findall('{' + SITEMAP_NS + \"}lastmod\")\n        if (len(lastmod_elements) > 1):\n            raise SitemapParseError(\n                \"Multiple <lastmod> elements while parsing <url> in sitemap\")\n        elif (len(lastmod_elements) == 1):\n            resource.lastmod = lastmod_elements[0].text\n        # proceed to look for other resource attributes in an rs:md element\n        md_elements = etree.findall('{' + RS_NS + \"}md\")\n        if (len(md_elements) > 1):\n            raise SitemapParseError(\n                \"Found multiple (%d) <rs:md> elements for %s\", (len(md_elements), loc))\n        elif (len(md_elements) == 1):\n            # have on element, look at attributes\n            md = self.md_from_etree(md_elements[0], context=loc)\n            # simple attributes that map directly to Resource object attributes\n            for att in ('capability', 'change', 'length', 'path', 'mime_type'):\n                if (att in md):\n                    setattr(resource, att, md[att])\n            # The ResourceSync beta spec lists md5, sha-1 and sha-256 fixity\n            # digest types. Parse and warn of errors ignored.\n            if ('hash' in md):\n                try:\n                    resource.hash = md['hash']\n                except ValueError as e:\n                    self.logger.warning(\"%s in <rs:md> for %s\" % (str(e), loc))\n        # look for rs:ln elements (optional)\n        ln_elements = etree.findall('{' + RS_NS + \"}ln\")\n        if (len(ln_elements) > 0):\n            resource.ln = []\n            for ln_element in ln_elements:\n                resource.ln.append(self.ln_from_etree(ln_element, loc))\n        return(resource)", "response": "Construct a Resource object from an etree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef md_from_etree(self, md_element, context=''):\n        md = {}\n        # grab all understood attributes into md dict\n        for att in ('capability', 'change', 'hash', 'length', 'path', 'mime_type',\n                    'md_at', 'md_completed', 'md_from', 'md_until'):\n            xml_att = self._xml_att_name(att)\n            val = md_element.attrib.get(xml_att, None)\n            if (val is not None):\n                md[att] = val\n        # capability. Allow this to be missing but do a very simple syntax\n        # check on plausible values if present\n        if ('capability' in md):\n            if (re.match(r\"^[\\w\\-]+$\", md['capability']) is None):\n                raise SitemapParseError(\n                    \"Bad capability name '%s' in %s\" %\n                    (capability, context))\n        # change should be one of defined values\n        if ('change' in md):\n            if (md['change'] not in ['created', 'updated', 'deleted']):\n                self.logger.warning(\n                    \"Bad change attribute in <rs:md> for %s\" %\n                    (context))\n        # length should be an integer\n        if ('length' in md):\n            try:\n                md['length'] = int(md['length'])\n            except ValueError as e:\n                raise SitemapParseError(\n                    \"Invalid length element in <rs:md> for %s\" %\n                    (context))\n        return(md)", "response": "Parse the rs : md attributes returning a dict of the data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ln_from_etree(self, ln_element, context=''):\n        ln = {}\n        # grab all understood attributes into ln dict\n        for att in ('hash', 'href', 'length', 'modified',\n                    'path', 'rel', 'pri', 'mime_type'):\n            xml_att = self._xml_att_name(att)\n            val = ln_element.attrib.get(xml_att, None)\n            if (val is not None):\n                ln[att] = val\n        # now do some checks and conversions...\n        # href (MANDATORY)\n        if ('href' not in ln):\n            raise SitemapParseError(\n                \"Missing href in <rs:ln> in %s\" %\n                (context))\n        # rel (MANDATORY)\n        if ('rel' not in ln):\n            raise SitemapParseError(\"Missing rel in <rs:ln> in %s\" % (context))\n        # length in bytes\n        if ('length' in ln):\n            try:\n                ln['length'] = int(ln['length'])\n            except ValueError as e:\n                raise SitemapParseError(\n                    \"Invalid length attribute value in <rs:ln> for %s\" %\n                    (context))\n        # pri - priority, must be a number between 1 and 999999\n        if ('pri' in ln):\n            try:\n                ln['pri'] = int(ln['pri'])\n            except ValueError as e:\n                raise SitemapParseError(\n                    \"Invalid pri attribute in <rs:ln> for %s\" %\n                    (context))\n            if (ln['pri'] < 1 or ln['pri'] > 999999):\n                raise SitemapParseError(\n                    \"Bad pri attribute value in <rs:ln> for %s\" %\n                    (context))\n        return(ln)", "response": "Parse rs : ln element into a dict of the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds element with name and atts to etree iff there are any atts.", "response": "def add_element_with_atts_to_etree(self, etree, name, atts):\n        \"\"\"Add element with name and atts to etree iff there are any atts.\n\n        Parameters:\n            etree - an etree object\n            name  - XML element name\n            atts  - dicts of attribute values. Attribute names are transformed\n        \"\"\"\n        xml_atts = {}\n        for att in atts.keys():\n            val = atts[att]\n            if (val is not None):\n                xml_atts[self._xml_att_name(att)] = str(val)\n        if (len(xml_atts) > 0):\n            e = Element(name, xml_atts)\n            if (self.pretty_xml):\n                e.tail = \"\\n\"\n            etree.append(e)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a list of mappings and return a new set of mappings.", "response": "def parse(self, mappings, use_default_path=False):\n        \"\"\"Parse a list of map strings (mappings).\n\n        Accepts two distinct formats:\n        1. If there are exactly two entries then these may be the source\n        base URI and the destination base path. Neither may contain an\n        equals (=) sign.\n        2. For any number of mapping stings interpret each as a mapping\n        URI=path. These are in the order they will be tried.\n\n        And if use_default_path is True then a third:\n        3. If there is exactly one entry and it does not contain an\n        equals (=) sign then a safe local path is created based on the\n        source base URI. In the case that the source base URI is a local\n        path already then an indentity mapping is used.\n        \"\"\"\n        if (use_default_path and\n                len(mappings) == 1 and\n                re.search(r\"=\", mappings[0]) is None):\n            path = self.path_from_uri(mappings[0])\n            self.logger.warning(\"Using URI mapping: %s -> %s\" %\n                                (mappings[0], path))\n            self.mappings.append(Map(mappings[0], path))\n        elif (len(mappings) == 2 and\n              re.search(r\"=\", mappings[0]) is None and\n              re.search(r\"=\", mappings[1]) is None):\n            self.mappings.append(Map(mappings[0], mappings[1]))\n        else:\n            for mapping in mappings:\n                l = mapping.split('=')\n                if (len(l) != 2):\n                    raise MapperError(\n                        \"Bad mapping argument (%s), got %s\" %\n                        (mapping, str(l)))\n                (src_uri, dst_path) = l\n                # Check for dupes\n                for map in self.mappings:\n                    if (src_uri == map.src_uri):\n                        raise MapperError(\n                            \"Attempt to set duplicate mapping for \"\n                            \"source URI %s (with destination path %s)\" %\n                            (src_uri, dst_path))\n                    if (dst_path == map.dst_path):\n                        raise MapperError(\n                            \"Attempt to set duplicate mapping for \"\n                            \"destination path %s (with source URI %s)\" %\n                            (dst_path, src_uri))\n                self.mappings.append(Map(src_uri, dst_path))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmaps destination path to source URI.", "response": "def dst_to_src(self, dst_file):\n        \"\"\"Map destination path to source URI.\"\"\"\n        for map in self.mappings:\n            src_uri = map.dst_to_src(dst_file)\n            if (src_uri is not None):\n                return(src_uri)\n        # Must have failed if loop exited\n        raise MapperError(\n            \"Unable to translate destination path (%s) \"\n            \"into a source URI.\" % (dst_file))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef src_to_dst(self, src_uri):\n        for map in self.mappings:\n            dst_path = map.src_to_dst(src_uri)\n            if (dst_path is not None):\n                return(dst_path)\n        # Must have failed if loop exited\n        raise MapperError(\n            \"Unable to translate source URI (%s) into \"\n            \"a destination path.\" % (src_uri))", "response": "Map source URI to destination path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking a safe path name from a URI.", "response": "def path_from_uri(self, uri):\n        \"\"\"Make a safe path name from uri.\n\n        In the case that uri is already a local path then the\n        same path is returned.\n        \"\"\"\n        (scheme, netloc, path, params, query, frag) = urlparse(uri)\n        if (netloc == ''):\n            return(uri)\n        path = '/'.join([netloc, path])\n        path = re.sub('[^\\w\\-\\.]', '_', path)\n        path = re.sub('__+', '_', path)\n        path = re.sub('[_\\.]+$', '', path)\n        path = re.sub('^[_\\.]+', '', path)\n        return(path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns input path minus any trailing slashes.", "response": "def strip_trailing_slashes(self, path):\n        \"\"\"Return input path minus any trailing slashes.\"\"\"\n        m = re.match(r\"(.*)/+$\", path)\n        if (m is None):\n            return(path)\n        return(m.group(1))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dst_to_src(self, dst_file):\n        m = re.match(self.dst_path + \"/(.*)$\", dst_file)\n        if (m is None):\n            return(None)\n        rel_path = m.group(1)\n        return(self.src_uri + '/' + rel_path)", "response": "Return the src URI from the dst filepath."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the dst filepath from the src URI.", "response": "def src_to_dst(self, src_uri):\n        \"\"\"Return the dst filepath from the src URI.\n\n        Returns None on failure, destination path on success.\n        \"\"\"\n        m = re.match(self.src_uri + \"/(.*)$\", src_uri)\n        if (m is None):\n            return(None)\n        rel_path = m.group(1)\n        return(self.dst_path + '/' + rel_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if the mapping is unsafe for an update.", "response": "def unsafe(self):\n        \"\"\"True if the mapping is unsafe for an update.\n\n        Applies only to local source. Returns True if the paths for source and\n        destination are the same, or if one is a component of the other path.\n        \"\"\"\n        (scheme, netloc, path, params, query, frag) = urlparse(self.src_uri)\n        if (scheme != ''):\n            return(False)\n        s = os.path.normpath(self.src_uri)\n        d = os.path.normpath(self.dst_path)\n        lcp = os.path.commonprefix([s, d])\n        return(s == lcp or d == lcp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove(text, exclude):\n    exclude = ''.join(str(symbol) for symbol in exclude)\n    return text.translate(str.maketrans('', '', exclude))", "response": "Removes the symbols from the text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsplitting text into n_columns many columns.", "response": "def split_columns(text, n_columns):\n    \"\"\"Split ``text`` into ``n_columns`` many columns.\n\n    Example:\n        >>> split_columns(\"example\", 2)\n        ['eape', 'xml']\n\n    Args:\n        text (str): The text to split\n        n_columns (int): The number of columns to create\n\n    Returns:\n        List of columns\n\n    Raises:\n        ValueError: If n_cols is <= 0 or >= len(text)\n    \"\"\"\n    if n_columns <= 0 or n_columns > len(text):\n        raise ValueError(\"n_columns must be within the bounds of 1 and text length\")\n\n    return [text[i::n_columns] for i in range(n_columns)]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef combine_columns(columns):\n    columns_zipped = itertools.zip_longest(*columns)\n    return ''.join(x for zipped in columns_zipped for x in zipped if x)", "response": "Combine columns into a single string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iterate_ngrams(text, n):\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return [text[i: i + n] for i in range(len(text) - n + 1)]", "response": "Generator to yield ngrams in text."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngroup text into n - sized blocks of size.", "response": "def group(text, size):\n    \"\"\"Group ``text`` into blocks of ``size``.\n\n    Example:\n        >>> group(\"test\", 2)\n        ['te', 'st']\n\n    Args:\n        text (str): text to separate\n        size (int): size of groups to split the text into\n\n    Returns:\n        List of n-sized groups of text\n\n    Raises:\n        ValueError: If n is non positive\n    \"\"\"\n    if size <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    return [text[i:i + size] for i in range(0, len(text), size)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _evaluate_rhs(cls, funcs, nodes, problem):\n        evald_funcs = cls._evaluate_functions(funcs, nodes)\n        evald_rhs = problem.rhs(nodes, *evald_funcs, **problem.params)\n        return evald_rhs", "response": "Compute the right - hand side of the system of ODEs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing the approximate intersection and boundary residuals for a set of derivatives and functions.", "response": "def _assess_approximation(self, boundary_points, derivs, funcs, nodes, problem):\n        \"\"\"\n        Parameters\n        ----------\n        basis_derivs : list(function)\n        basis_funcs : list(function)\n        problem : TwoPointBVPLike\n\n        Returns\n        -------\n        resids : numpy.ndarray\n\n        \"\"\"\n        interior_residuals = self._compute_interior_residuals(derivs, funcs,\n                                                              nodes, problem)\n        boundary_residuals = self._compute_boundary_residuals(boundary_points,\n                                                              funcs, problem)\n        return np.hstack(interior_residuals + boundary_residuals)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns collocation residuals. Parameters ---------- coefs_array : numpy.ndarray basis_kwargs : dict problem : TwoPointBVPLike Returns ------- resids : numpy.ndarray", "response": "def _compute_residuals(self, coefs_array, basis_kwargs, boundary_points, nodes, problem):\n        \"\"\"\n        Return collocation residuals.\n\n        Parameters\n        ----------\n        coefs_array : numpy.ndarray\n        basis_kwargs : dict\n        problem : TwoPointBVPLike\n\n        Returns\n        -------\n        resids : numpy.ndarray\n\n        \"\"\"\n        coefs_list = self._array_to_list(coefs_array, problem.number_odes)\n        derivs, funcs = self._construct_approximation(basis_kwargs, coefs_list)\n        resids = self._assess_approximation(boundary_points, derivs, funcs,\n                                            nodes, problem)\n        return resids"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconstructs a collection of derivatives and functions that approximate the solution to the boundary value problem.", "response": "def _construct_approximation(self, basis_kwargs, coefs_list):\n        \"\"\"\n        Construct a collection of derivatives and functions that approximate\n        the solution to the boundary value problem.\n\n        Parameters\n        ----------\n        basis_kwargs : dict(str: )\n        coefs_list : list(numpy.ndarray)\n\n        Returns\n        -------\n        basis_derivs : list(function)\n        basis_funcs : list(function)\n\n        \"\"\"\n        derivs = self._construct_derivatives(coefs_list, **basis_kwargs)\n        funcs = self._construct_functions(coefs_list, **basis_kwargs)\n        return derivs, funcs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of derivatives given a list of coefficients.", "response": "def _construct_derivatives(self, coefs, **kwargs):\n        \"\"\"Return a list of derivatives given a list of coefficients.\"\"\"\n        return [self.basis_functions.derivatives_factory(coef, **kwargs) for coef in coefs]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _construct_functions(self, coefs, **kwargs):\n        return [self.basis_functions.functions_factory(coef, **kwargs) for coef in coefs]", "response": "Return a list of functions given a list of coefficients."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconstructing a representation of the solution to the boundary value problem.", "response": "def _solution_factory(self, basis_kwargs, coefs_array, nodes, problem, result):\n        \"\"\"\n        Construct a representation of the solution to the boundary value problem.\n\n        Parameters\n        ----------\n        basis_kwargs : dict(str : )\n        coefs_array : numpy.ndarray\n        problem : TwoPointBVPLike\n        result : OptimizeResult\n\n        Returns\n        -------\n        solution : SolutionLike\n\n        \"\"\"\n        soln_coefs = self._array_to_list(coefs_array, problem.number_odes)\n        soln_derivs = self._construct_derivatives(soln_coefs, **basis_kwargs)\n        soln_funcs = self._construct_functions(soln_coefs, **basis_kwargs)\n        soln_residual_func = self._interior_residuals_factory(soln_derivs,\n                                                              soln_funcs,\n                                                              problem)\n        solution = solutions.Solution(basis_kwargs, soln_funcs, nodes, problem,\n                                      soln_residual_func, result)\n        return solution"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef solve(self, basis_kwargs, boundary_points, coefs_array, nodes, problem,\n              **solver_options):\n        \"\"\"\n        Solve a boundary value problem using the collocation method.\n\n        Parameters\n        ----------\n        basis_kwargs : dict\n            Dictionary of keyword arguments used to build basis functions.\n        coefs_array : numpy.ndarray\n            Array of coefficients for basis functions defining the initial\n            condition.\n        problem : bvp.TwoPointBVPLike\n            A two-point boundary value problem (BVP) to solve.\n        solver_options : dict\n            Dictionary of options to pass to the non-linear equation solver.\n\n        Return\n        ------\n        solution: solutions.SolutionLike\n            An instance of the SolutionLike class representing the solution to\n            the two-point boundary value problem (BVP)\n\n        Notes\n        -----\n\n        \"\"\"\n        result = optimize.root(self._compute_residuals,\n                               x0=coefs_array,\n                               args=(basis_kwargs, boundary_points, nodes, problem),\n                               **solver_options)\n        solution = self._solution_factory(basis_kwargs, result.x, nodes,\n                                          problem, result)\n        return solution", "response": "Solve a two - point boundary value problem using the collocation method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_logging(to_file=False, logfile=None, default_logfile='/tmp/resync.log',\n                 human=True, verbose=False, eval_mode=False,\n                 default_logger='client', extra_loggers=None):\n    \"\"\"Initialize logging.\n\n    Use of log levels:\n    DEBUG - very verbose, for evaluation of output (-e)\n    INFO - verbose, only seen by users if they ask for it (-v)\n    WARNING - messages output messages to console\n\n    Logging to a file: If to_file is True then output will be written to\n    a file. This will be logfile if set, else default_logfile (which may\n    also be overridden).\n    \"\"\"\n    fmt = '%(asctime)s | %(name)s | %(levelname)s | %(message)s'\n    formatter = UTCFormatter(fmt)\n\n    if human:\n        # Create a special handler designed just for human readable output\n        hh = logging.StreamHandler()\n        hh.setLevel(logging.INFO if (verbose) else logging.WARNING)\n        hh.setFormatter(logging.Formatter(fmt='%(message)s'))\n    if to_file:\n        if (logfile is None):\n            logfile = default_logfile\n        fh = logging.FileHandler(filename=logfile, mode='a')\n        fh.setFormatter(formatter)\n        fh.setLevel(logging.DEBUG if (eval_mode) else logging.INFO)\n\n    loggers = [default_logger, 'resync']\n    if (extra_loggers is not None):\n        for logger in extra_loggers:\n            loggers.append(logger)\n    for logger in loggers:\n        log = logging.getLogger(logger)\n        log.setLevel(logging.DEBUG)  # control at handler instead\n        if human:\n            log.addHandler(hh)\n        if to_file:\n            log.addHandler(fh)\n\n    log = logging.getLogger(default_logger)\n    if (to_file):\n        log.info(\"Writing detailed log to %s\" % (logfile))", "response": "Initialize logging.\n\n    Use of log levels:\n    DEBUG - very verbose, for evaluation of output (-e)\n    INFO - verbose, only seen by users if they ask for it (-v)\n    WARNING - messages output messages to console\n\n    Logging to a file: If to_file is True then output will be written to\n    a file. This will be logfile if set, else default_logfile (which may\n    also be overridden)."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_links(args_link):\n    links = []\n    if (args_link is not None):\n        for link_str in args_link:\n            try:\n                links.append(parse_link(link_str))\n            except ClientFatalError as e:\n                raise ClientFatalError(\n                    \"Bad --link option '%s' (%s)\" %\n                    (link_str, str(e)))\n    return(links)", "response": "Parse the list of links from the command line."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_link(link_str):\n    atts = {}\n    help_str = \"--link option '%s' (format rel,href,att1=val1...)\" % (link_str)\n    try:\n        segs = link_str.split(',')\n        # First segments are relation and subject\n        atts['rel'] = segs.pop(0)\n        atts['href'] = segs.pop(0)\n        if (atts['href'] == ''):\n            raise ClientFatalError(\"Missing uri in \" + help_str)\n        # Remaining segments are attributes\n        for term in segs:\n            (k, v) = term.split('=')\n            if (k == '' or v == ''):\n                raise ClientFatalError(\n                    \"Bad attribute (%s) in \" %\n                    (term) + help_str)\n            atts[k] = v\n    except ValueError as e:\n        raise ClientFatalError(\"Bad component of \" + help_str)\n    except IndexError as e:\n        raise ClientFatalError(\"Incomplete component of \" + help_str)\n\n    return(atts)", "response": "Parse one - line option to add to a new list of links."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses list of capabilities in -- capabilitylist option.", "response": "def parse_capabilities(caps_str):\n    \"\"\"Parse list of capabilities in --capabilitylist option.\n\n    Input string of the form: cap_name=uri,cap_name=uri\n    \"\"\"\n    capabilities = {}\n    try:\n        segs = caps_str.split(',')\n        for term in segs:\n            (k, v) = term.split('=')\n            capabilities[k] = v\n    except ValueError as e:\n        raise ClientFatalError(\n            \"Bad component of --capabilitylist option '%s' (%s)\" %\n            (caps_str, str(e)))\n    return(capabilities)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping around urlopen to prepend file if no scheme provided.", "response": "def url_or_file_open(uri):\n    \"\"\"Wrapper around urlopen() to prepend file: if no scheme provided.\"\"\"\n    if (not re.match(r'''\\w+:''', uri)):\n        uri = 'file:' + uri\n    return(urlopen(uri))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef datetime_to_str(dt='now', no_fractions=False):\n    if (dt is None):\n        return None\n    elif (dt == 'now'):\n        dt = time.time()\n    if (no_fractions):\n        dt = int(dt)\n    else:\n        dt += 0.0000001  # improve rounding to microseconds\n    return datetime.utcfromtimestamp(dt).isoformat() + 'Z'", "response": "Returns a string representation of the given datetime."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset timestamp from an ISO8601 - formatted string.", "response": "def str_to_datetime(s, context='datetime'):\n    \"\"\"Set timestamp from an W3C Datetime Last-Modified value.\n\n    The sitemaps.org specification says that <lastmod> values\n    must comply with the W3C Datetime format\n    (http://www.w3.org/TR/NOTE-datetime). This is a restricted\n    subset of ISO8601. In particular, all forms that include a\n    time must include a timezone indication so there is no\n    notion of local time (which would be tricky on the web). The\n    forms allowed are:\n\n        Year:\n          YYYY (eg 1997)\n        Year and month:\n          YYYY-MM (eg 1997-07)\n        Complete date:\n          YYYY-MM-DD (eg 1997-07-16)\n        Complete date plus hours and minutes:\n          YYYY-MM-DDThh:mmTZD (eg 1997-07-16T19:20+01:00)\n        Complete date plus hours, minutes and seconds:\n          YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)\n        Complete date plus hours, minutes, seconds and a decimal fraction\n        of a second\n          YYYY-MM-DDThh:mm:ss.sTZD (eg 1997-07-16T19:20:30.45+01:00)\n        where:\n          TZD  = time zone designator (Z or +hh:mm or -hh:mm)\n\n    We do not anticipate the YYYY and YYYY-MM forms being used but\n    interpret them as YYYY-01-01 and YYYY-MM-01 respectively. All\n    dates are interpreted as having time 00:00:00.0 UTC.\n\n    Datetimes not specified to the level of seconds are intepreted\n    as 00.0 seconds.\n    \"\"\"\n    t = None\n    if (s is None):\n        return(t)\n    if (s == ''):\n        raise ValueError('Attempt to set empty %s' % (context))\n    # Make a date into a full datetime\n    m = re.match(r\"\\d\\d\\d\\d(\\-\\d\\d(\\-\\d\\d)?)?$\", s)\n    if (m is not None):\n        if (m.group(1) is None):\n            s += '-01-01'\n        elif (m.group(2) is None):\n            s += '-01'\n        s += 'T00:00:00Z'\n    # Now have datetime with timezone info\n    m = re.match(r\"(.*\\d{2}:\\d{2}:\\d{2})(\\.\\d+)([^\\d].*)?$\", s)\n    # Chop out fractional seconds if present\n    fractional_seconds = 0\n    if (m is not None):\n        s = m.group(1)\n        if (m.group(3) is not None):\n            s += m.group(3)\n        fractional_seconds = float(m.group(2))\n    # Now check that only allowed formats supplied (the parse\n    # function in dateutil is rather lax) and separate out\n    # timezone information to be handled separately\n    #\n    # Seems that one should be able to handle timezone offset\n    # with dt.tzinfo module but this has variation in behavior\n    # between python 2.6 and 2.7... so do here for now\n    m = re.match(r\"(\\d\\d\\d\\d\\-\\d\\d\\-\\d\\dT\\d\\d:\\d\\d(:\\d\\d)?)(Z|([+-])\"\n                 \"(\\d\\d):(\\d\\d))$\", s)\n    if (m is None):\n        raise ValueError(\"Bad datetime format (%s)\" % s)\n    str = m.group(1) + 'Z'\n    dt = dateutil_parser.parse(str)\n    offset_seconds = 0\n    if (m.group(3) != 'Z'):\n        hh = int(m.group(5))\n        mm = int(m.group(6))\n        if (hh > 23 or mm > 59):\n            raise ValueError(\"Bad timezone offset (%s)\" % s)\n        offset_seconds = hh * 3600 + mm * 60\n        if (m.group(4) == '-'):\n            offset_seconds = -offset_seconds\n    # timetuple() ignores timezone information so we have to add in\n    # the offset here, and any fractional component of the seconds\n    return(timegm(dt.timetuple()) + offset_seconds + fractional_seconds)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef need_geocoding(self):\n        need_geocoding = False\n        for attribute, component in self.required_address_components.items():\n            if not getattr(self, attribute):\n                need_geocoding = True\n                break  # skip extra loops\n        return need_geocoding", "response": "Returns True if any of the required address components are missing."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef geocode(self, commit=False, force=False):\n        if self.need_geocoding() or force:\n            result = get_cached(getattr(self, self.geocoded_by), provider='google')\n            if result.status == 'OK':\n                for attribute, components in self.required_address_components.items():\n                    for component in components:\n                        if not getattr(self, attribute) or force:\n                            attr_val = getattr(result, component, None)\n                            if attr_val:\n                                setattr(self, attribute, attr_val)\n\n            if commit:\n                self.save()", "response": "Do a backend geocoding if needed"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextend the save method to allow dynamic geocoding", "response": "def save(self, *args, **kwargs):\n        \"\"\"\n        Extends model ``save()`` to allow dynamic geocoding\n        \"\"\"\n        self.geocode()\n        return super(GeoMixin, self).save(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlook for link with specified rel return if found None.", "response": "def link(self, rel):\n        \"\"\"Look for link with specified rel, return else None.\"\"\"\n        for link in self.ln:\n            if ('rel' in link and\n                    link['rel'] == rel):\n                return(link)\n        return(None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef link_href(self, rel):\n        link = self.link(rel)\n        if (link is not None):\n            link = link['href']\n        return(link)", "response": "Look for link with specified rel return href from it or None."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the default capability name in the md.", "response": "def default_capability(self):\n        \"\"\"Set capability name in md.\n\n        Every ResourceSync document should have the top-level\n        capability attributes.\n        \"\"\"\n        if ('capability' not in self.md and self.capability_name is not None):\n            self.md['capability'] = self.capability_name"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add(self, resource):\n        if isinstance(resource, collections.Iterable):\n            for r in resource:\n                self.resources.append(r)\n        else:\n            self.resources.append(resource)", "response": "Add a resource or an iterable collection of resources to this container."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef prune_before(self, timestamp):\n        n = 0\n        pruned = []\n        for r in self.resources:\n            if (r.timestamp is None):\n                raise Exception(\"Entry %s has no timestamp\" % (r.uri))\n            elif (r.timestamp >= timestamp):\n                pruned.append(r)\n            else:\n                n += 1\n        self.resources = pruned\n        return(n)", "response": "Remove all resources with timestamp earlier than a given timestamp."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prune_dupes(self):\n        n = 0\n        pruned1 = []\n        seen = set()\n        deletes = {}\n        for r in reversed(self.resources):\n            if (r.uri in seen):\n                n += 1\n                if (r.uri in deletes):\n                    deletes[r.uri] = r.change\n            else:\n                pruned1.append(r)\n                seen.add(r.uri)\n                if (r.change == 'deleted'):\n                    deletes[r.uri] = r.change\n        # go through all deletes and prune if first was create\n        pruned2 = []\n        for r in reversed(pruned1):\n            if (r.uri in deletes and deletes[r.uri] == 'created'):\n                n += 1\n            else:\n                pruned2.append(r)\n        self.resources = pruned2\n        return(n)", "response": "Remove all but the last entry for a given resource URI. Returns the number of entries removed."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _str_datetime_now(self, x=None):\n        if (x == 'now'):\n            # Now, this is wht datetime_to_str() with no arg gives\n            return(datetime_to_str())\n        try:\n            # Test for number\n            junk = x + 0.0\n            return datetime_to_str(x)\n        except TypeError:\n            # Didn't look like a number, treat as string\n            return x", "response": "Return datetime string for use with time attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_cached(location, **kwargs):\n    result = cache.get(location)\n\n    # Result is not cached or wrong\n    if not result or not result.ok:\n        result = geocoder.get(location, **kwargs)\n        if result.ok:\n            cache.set(location, result)\n\n    return result", "response": "Simple wrapper that adds Django caching support to geocoder. get."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef map(self, width, height):\n        template = ti.load(os.path.join(script_dir, 'assets', 'template.tmx'))['map0']\n        #template.set_view(0, 0, template.px_width, template.px_height)\n        template.set_view(0, 0, width*template.tw, height*template.th)\n\n        # TODO: Save the generated map.\n        #epoch = int(time.time())\n        #filename = 'map_' + str(epoch) + '.tmx'\n\n        # Draw borders\n        border_x = template.cells[width]\n        for y in xrange(0,height+1):\n            border_x[y].tile = template.cells[0][0].tile\n\n        for x in xrange(0,width):\n            template.cells[x][height].tile = template.cells[0][0].tile\n\n        # Start within borders\n        #self.recursive_division(template.cells, 3, (template.px_width/template.tw)-1, (template.px_height/template.th)-1, 0, 0)\n        self.recursive_division(template.cells, 3, width, height, 0, 0)\n\n        return template", "response": "Creates and returns a randomly generated map."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncommands - Mode : Retrieve and display data then process commands.", "response": "def main():\n    \"\"\"Command-Mode: Retrieve and display data then process commands.\"\"\"\n    (cred, providers) = config_read()\n    cmd_mode = True\n    conn_objs = cld.get_conns(cred, providers)\n    while cmd_mode:\n        nodes = cld.get_data(conn_objs, providers)\n        node_dict = make_node_dict(nodes, \"name\")\n        idx_tbl = table.indx_table(node_dict, True)\n        cmd_mode = ui.ui_main(idx_tbl, node_dict)\n    print(\"\\033[?25h\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting - Mode : Retrieve and display data then exit.", "response": "def list_only():\n    \"\"\"List-Mode: Retrieve and display data then exit.\"\"\"\n    (cred, providers) = config_read()\n    conn_objs = cld.get_conns(cred, providers)\n    nodes = cld.get_data(conn_objs, providers)\n    node_dict = make_node_dict(nodes, \"name\")\n    table.indx_table(node_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_node_dict(outer_list, sort=\"zone\"):\n    raw_dict = {}\n    x = 1\n    for inner_list in outer_list:\n        for node in inner_list:\n            raw_dict[x] = node\n            x += 1\n    if sort == \"name\":  # sort by provider - name\n        srt_dict = OrderedDict(sorted(raw_dict.items(), key=lambda k:\n                               (k[1].cloud, k[1].name.lower())))\n    else:  # sort by provider - zone - name\n        srt_dict = OrderedDict(sorted(raw_dict.items(), key=lambda k:\n                               (k[1].cloud, k[1].zone, k[1].name.lower())))\n    x = 1\n    node_dict = {}\n    for i, v in srt_dict.items():\n        node_dict[x] = v\n        x += 1\n    return node_dict", "response": "Convert node data from nested - list to sorted dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef config_read():\n    config_file = (u\"{0}config.ini\".format(CONFIG_DIR))\n    if not os.path.isfile(config_file):\n        config_make(config_file)\n    config = configparser.ConfigParser(allow_no_value=True)\n    try:\n        config.read(config_file, encoding='utf-8')\n    except IOError:\n        print(\"Error reading config file: {}\".format(config_file))\n        sys.exit()\n    # De-duplicate provider-list\n    providers = config_prov(config)\n    # Read credentials for listed providers\n    (cred, to_remove) = config_cred(config, providers)\n    # remove unsupported and credential-less providers\n    for item in to_remove:\n        providers.remove(item)\n    return cred, providers", "response": "Read config info from config file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading providers from configfile and de - duplicate it.", "response": "def config_prov(config):\n    \"\"\"Read providers from configfile and de-duplicate it.\"\"\"\n    try:\n        providers = [e.strip() for e in (config['info']\n                                         ['providers']).split(',')]\n    except KeyError as e:\n        print(\"Error reading config item: {}\".format(e))\n        sys.exit()\n    providers = list(OrderedDict.fromkeys(providers))\n    return providers"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef config_cred(config, providers):\n    expected = ['aws', 'azure', 'gcp', 'alicloud']\n    cred = {}\n    to_remove = []\n    for item in providers:\n        if any(item.startswith(itemb) for itemb in expected):\n            try:\n                cred[item] = dict(list(config[item].items()))\n            except KeyError as e:\n                print(\"No credentials section in config file for {} -\"\n                      \" provider will be skipped.\".format(e))\n                to_remove.append(item)\n        else:\n            print(\"Unsupported provider: '{}' listed in config - ignoring\"\n                  .format(item))\n            to_remove.append(item)\n    return cred, to_remove", "response": "Read credentials from configfile."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef config_make(config_file):\n    from pkg_resources import resource_filename\n    import shutil\n    if not os.path.exists(CONFIG_DIR):\n        os.makedirs(CONFIG_DIR)\n    filename = resource_filename(\"mcc\", \"config.ini\")\n    try:\n        shutil.copyfile(filename, config_file)\n    except IOError:\n        print(\"Error copying sample config file: {}\".format(config_file))\n        sys.exit()\n    print(\"Please add credential information to {}\".format(config_file))\n    sys.exit()", "response": "Create config. ini on first use make dir and copy sample."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprovide access to the complete hash string.", "response": "def hash(self):\n        \"\"\"Provide access to the complete hash string.\n\n        The hash string may have zero or more hash values with\n        appropriate prefixes. All hash values are assumed to be\n        strings\n        \"\"\"\n        hashvals = []\n        if (self.md5 is not None):\n            hashvals.append('md5:' + self.md5)\n        if (self.sha1 is not None):\n            hashvals.append('sha-1:' + self.sha1)\n        if (self.sha256 is not None):\n            hashvals.append('sha-256:' + self.sha256)\n        if (len(hashvals) > 0):\n            return(' '.join(hashvals))\n        return(None)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse space separated set of values.", "response": "def hash(self, hash):\n        \"\"\"Parse space separated set of values.\n\n        See specification at:\n        http://tools.ietf.org/html/draft-snell-atompub-link-extensions-09\n        which defines many types. We implement md5, sha-1, sha-256\n        \"\"\"\n        self.md5 = None\n        self.sha1 = None\n        self.sha256 = None\n        if (hash is None):\n            return\n        hash_seen = set()\n        errors = []\n        for entry in hash.split():\n            (hash_type, value) = entry.split(':', 1)\n            if (hash_type in hash_seen):\n                errors.append(\"Ignored duplicate hash type %s\" % (hash_type))\n            else:\n                hash_seen.add(hash_type)\n                if (hash_type == 'md5'):\n                    self.md5 = value\n                elif (hash_type == 'sha-1'):\n                    self.sha1 = value\n                elif (hash_type == 'sha-256'):\n                    self.sha256 = value\n                else:\n                    errors.append(\"Ignored unsupported hash type (%s)\" %\n                                  (hash_type))\n        if (len(errors) > 0):\n            raise ValueError(\". \".join(errors))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef link_set(self, rel, href, allow_duplicates=False, **atts):\n        if (self.ln is None):\n            # automagically create a self.ln list\n            self.ln = []\n            link = None\n        else:\n            link = self.link(rel)\n        if (link is not None and not allow_duplicates):\n            # overwrite current value\n            link['href'] = href\n        else:\n            # create new link\n            link = {'rel': rel, 'href': href}\n            self.ln.append(link)\n        for k in atts:\n            link[k] = atts[k]", "response": "Set or create a link with specified rel set href and any other attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef link_add(self, rel, href, **atts):\n        self.link_set(rel, href, allow_duplicates=True, **atts)", "response": "Create an empty link with specified rel."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef equal(self, other, delta=0.0):\n        if (other is None):\n            return False\n        if (self.uri != other.uri):\n            return(False)\n        if (self.timestamp is not None or other.timestamp is not None):\n            # not equal if only one timestamp specified\n            if (self.timestamp is None or\n                    other.timestamp is None or\n                    abs(self.timestamp - other.timestamp) >= delta):\n                return(False)\n        if ((self.md5 is not None and other.md5 is not None) and\n                self.md5 != other.md5):\n            return(False)\n        if ((self.length is not None and other.length is not None) and\n                self.length != other.length):\n            return(False)\n        return(True)", "response": "Equality test for resources."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nscoring a text by comparing its frequency distribution against another.", "response": "def ChiSquared(target_frequency):\n    \"\"\"Score a text by comparing its frequency distribution against another.\n\n    Note:\n        It is easy to be penalised without knowing it when using this scorer.\n        English frequency ngrams are capital letters, meaning when using it\n        any text you score against must be all capitals for it to give correct results.\n        I am aware of the issue and will work on a fix.\n\n    Todo:\n        Maybe include paramter for ngram size. Havent had a use case for this yet.\n        Once there is evidence it is needed, I will add it.\n\n    Example:\n        >>> fitness = ChiSquared(english.unigrams)\n        >>> fitness(\"ABC\")\n        -32.2\n\n    Args:\n        target_frequency (dict): symbol to frequency mapping of the distribution to compare with\n    \"\"\"\n    def inner(text):\n        text = ''.join(text)\n        return -chi_squared(frequency_analyze(text), target_frequency)\n\n    return inner"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef translate(otp, to=MODHEX):\n    if PY3:\n        if isinstance(otp, bytes):\n            raise ValueError(\"otp must be unicode\")\n        if isinstance(to, bytes):\n            raise ValueError(\"to must be unicode\")\n    else:\n        if not isinstance(otp, unicode):\n            raise ValueError(\"otp must be unicode\")\n        if not isinstance(to, unicode):\n            raise ValueError(\"to must be unicode\")\n\n    possible = (set(index[c]) for c in set(otp))\n    possible = reduce(lambda a, b: a.intersection(b), possible)\n    translated = set()\n    for i in possible:\n        a = alphabets[i]\n        translation = dict(zip((ord(c) for c in a), to))\n        translated.add(otp.translate(translation))\n\n    return translated", "response": "Translate a Yubikey to modhex interpretations."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef my_resource_list():\n    rl = ResourceList( resources=iter(my_resources), count=len(my_resources) )\n    rl.max_sitemap_entries = max_sitemap_entries\n    return(rl)", "response": "Simulate the generator used by simulator"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, resource, replace=False):\n        uri = resource.uri\n        if (uri in self and not replace):\n            raise ResourceListDupeError(\n                \"Attempt to add resource already in resource_list\")\n        self[uri] = resource", "response": "Add a resource to the resource list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef uris(self):\n        uris = []\n        for r in self:\n            uris.append(r.uri)\n        return(uris)", "response": "Extract list of all resource URIs in the order added."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, resource, replace=False):\n        uri = resource.uri\n        for r in self:\n            if (uri == r.uri):\n                if (replace):\n                    r = resource\n                    return\n                else:\n                    raise ResourceListDupeError(\n                        \"Attempt to add resource already in resource_list\")\n        # didn't find it in list, add to end\n        self.append(resource)", "response": "Add a single resource to the resource list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add(self, resource, replace=False):\n        if isinstance(resource, collections.Iterable):\n            for r in resource:\n                self.resources.add(r, replace)\n        else:\n            self.resources.add(resource, replace)", "response": "Add a resource or an iterable of resources."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compare(self, src):\n        dst_iter = iter(self.resources)\n        src_iter = iter(src.resources)\n        same = ResourceList()\n        updated = ResourceList()\n        deleted = ResourceList()\n        created = ResourceList()\n        dst_cur = next(dst_iter, None)\n        src_cur = next(src_iter, None)\n        while ((dst_cur is not None) and (src_cur is not None)):\n            # print 'dst='+dst_cur+'  src='+src_cur\n            if (dst_cur.uri == src_cur.uri):\n                if (dst_cur == src_cur):\n                    same.add(dst_cur)\n                else:\n                    updated.add(src_cur)\n                dst_cur = next(dst_iter, None)\n                src_cur = next(src_iter, None)\n            elif (not src_cur or dst_cur.uri < src_cur.uri):\n                deleted.add(dst_cur)\n                dst_cur = next(dst_iter, None)\n            elif (not dst_cur or dst_cur.uri > src_cur.uri):\n                created.add(src_cur)\n                src_cur = next(src_iter, None)\n            else:\n                raise Exception(\"this should not be possible\")\n        # what do we have leftover in src or dst lists?\n        while (dst_cur is not None):\n            deleted.add(dst_cur)\n            dst_cur = next(dst_iter, None)\n        while (src_cur is not None):\n            created.add(src_cur)\n            src_cur = next(src_iter, None)\n        # have now gone through both lists\n        return(same, updated, deleted, created)", "response": "This method compares this ResourceList object with that specified as src."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hashes(self):\n        hashes = set()\n        if (self.resources is not None):\n            for resource in self:\n                if (resource.md5 is not None):\n                    hashes.add('md5')\n                if (resource.sha1 is not None):\n                    hashes.add('sha-1')\n                if (resource.sha256 is not None):\n                    hashes.add('sha-256')\n        return(hashes)", "response": "Return set of hashes used in this resource_list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting XML string value to None boolean int or float.", "response": "def _fromstring(value):\n    '''_fromstring\n\n    Convert XML string value to None, boolean, int or float.\n    '''\n\n    if not value:\n        return None\n    std_value = value.strip().lower()\n    if std_value == 'true':\n        return 'true'\n    elif std_value == 'false':\n        return 'false'\n#     try:\n#         return int(std_value)\n#     except ValueError:\n#         pass\n#     try:\n#         return float(std_value)\n#     except ValueError:\n#         pass\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_config_nodes(self):\n        '''get_config_nodes\n\n        High-level api: get_config_nodes returns a list of config nodes. Each\n        config node is an Element node in the config tree, which is\n        corresponding to one 'update' in the gNMI GetResponse.\n\n        Returns\n        -------\n\n        list\n            A list of config nodes.\n        Config\n            A Config object.\n        '''\n\n        from .config import Config\n\n        config = Config(self.device, config=None)\n        for notification in self.reply.notification:\n            updates = []\n            for update in notification.update:\n                config += self.build_config_node(Config(self.device, config=None),\n                                                 notification.prefix,\n                                                 update.path, update.val)\n        return config", "response": "get_config_nodes returns a list of config nodes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_json(self, instance=True, origin='openconfig'):\n        '''get_json\n\n        High-level api: get_json returns json_val of the config node.\n\n        Parameters\n        ----------\n\n        instance : `bool`\n            True if only one instance of list or leaf-list is required. False if\n            all instances of list or leaf-list are needed.\n\n        Returns\n        -------\n\n        str\n            A string in JSON format.\n        '''\n\n        def get_json_instance(node):\n            pk = Parker(xml_fromstring=_fromstring, dict_type=OrderedDict)\n            default_ns = {}\n            for item in node.iter():\n                parents = [p for p in node.iter() if item in p]\n                if parents and id(parents[0]) in default_ns:\n                    ns, tag = self.device.convert_tag(default_ns[id(parents[0])],\n                                                      item.tag,\n                                                      dst=ns_spec[origin]['val_name'])\n                else:\n                    ns, tag = self.device.convert_tag('',\n                                                      item.tag,\n                                                      dst=ns_spec[origin]['val_name'])\n                default_ns[id(item)] = ns\n                item.tag = tag\n                if item.text:\n                    text = self.device.convert_tag(self._url_to_prefix[ns],\n                                                   item.text,\n                                                   src=Tag.JSON_PREFIX,\n                                                   dst=ns_spec[origin]['val_val'])[1]\n                    item.text = text\n            return pk.data(node)\n\n        def convert_node(node):\n            # lxml.etree does not allow tag name like oc-if:enable\n            # so it is converted to xml.etree.ElementTree\n            string = etree.tostring(node, encoding='unicode',\n                                    pretty_print=False)\n            return ElementTree.fromstring(string)\n\n        if instance:\n            return json.dumps(get_json_instance(convert_node(self.node)))\n        else:\n            nodes = [n for n in\n                     self.node.getparent().iterchildren(tag=self.node.tag)]\n            if len(nodes) > 1:\n                return json.dumps([get_json_instance(convert_node(n))\n                                   for n in nodes])\n            else:\n                return json.dumps(get_json_instance(convert_node(nodes[0])))", "response": "High - level api to get json_val of the config node."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a filepath for a phantomcss file.", "response": "def _build_sliced_filepath(filename, slice_count):\n    \"\"\" append slice_count to the end of a filename \"\"\"\n    root = os.path.splitext(filename)[0]\n    ext = os.path.splitext(filename)[1]\n    new_filepath = ''.join((root, str(slice_count), ext))\n    return _build_filepath_for_phantomcss(new_filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _build_filepath_for_phantomcss(filepath):\n    try:\n        if os.path.exists(filepath):\n            new_root = '.'.join((os.path.splitext(filepath)[0], 'diff'))\n            ext = os.path.splitext(filepath)[1]\n            diff_filepath = ''.join((new_root, ext))\n            if os.path.exists(diff_filepath):\n                print 'removing stale diff: {0}'.format(diff_filepath)\n                os.remove(diff_filepath)\n            return diff_filepath\n        else:\n            return filepath\n    except OSError, e:\n        print e", "response": "Build filepath for phantomcss."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a useful filename for an image from the browserstack json metadata", "response": "def _build_filename_from_browserstack_json(j):\n    \"\"\" Build a useful filename for an image from the screenshot json metadata \"\"\"\n    filename = ''\n    device = j['device'] if j['device'] else 'Desktop'\n    if j['state'] == 'done' and j['image_url']:\n        detail = [device, j['os'], j['os_version'],\n                  j['browser'], j['browser_version'], '.jpg']\n        filename = '_'.join(item.replace(\" \", \"_\") for item in detail if item)\n    else:\n        print 'screenshot timed out, ignoring this result'\n    return filename"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nslice an image into parts slice_size tall.", "response": "def _long_image_slice(in_filepath, out_filepath, slice_size):\n    \"\"\" Slice an image into parts slice_size tall. \"\"\"\n    print 'slicing image: {0}'.format(in_filepath)\n    img = Image.open(in_filepath)\n    width, height = img.size\n    upper = 0\n    left = 0\n    slices = int(math.ceil(height / slice_size))\n\n    count = 1\n    for slice in range(slices):\n        # if we are at the end, set the lower bound to be the bottom of the image\n        if count == slices:\n            lower = height\n        else:\n            lower = int(count * slice_size)\n        # set the bounding box! The important bit\n        bbox = (left, upper, width, lower)\n        working_slice = img.crop(bbox)\n        upper += slice_size\n        # save the slice\n        new_filepath = _build_sliced_filepath(out_filepath, count)\n        working_slice.save(new_filepath)\n        count += 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _purge(dir, pattern, reason=''):\n    for f in os.listdir(dir):\n        if re.search(pattern, f):\n            print \"Purging file {0}. {1}\".format(f, reason)\n            os.remove(os.path.join(dir, f))", "response": "Delete files in dir that match pattern"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef retry(tries, delay=3, backoff=2):\n\n    if backoff <= 1:\n        raise ValueError(\"backoff must be greater than 1\")\n\n    tries = math.floor(tries)\n    if tries < 0:\n        raise ValueError(\"tries must be 0 or greater\")\n\n    if delay <= 0:\n        raise ValueError(\"delay must be greater than 0\")\n\n    def deco_retry(f):\n        def f_retry(*args, **kwargs):\n            mtries, mdelay = tries, delay\n\n            rv = f(*args, **kwargs)  # first attempt\n            while mtries > 0:\n                if rv is True:\n                    return True\n\n                mtries -= 1\n                time.sleep(mdelay)\n                mdelay *= backoff\n\n                rv = f(*args, **kwargs)  # Try again\n            print str(tries) + \" attempts. Abandoning.\"\n            return False  # Ran out of tries\n\n        return f_retry\n\n    return deco_retry", "response": "Returns a function or method that retries a function or method until it returns True."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbreak ``ciphertext`` using hill climbing. Note: Currently ntrails and nswaps default to magic numbers. Generally the trend is, the longer the text, the lower the number of trials you need to run, because the hill climbing will lead to the best answer faster. Because randomness is involved, there is the possibility of the correct decryption not being found. In this circumstance you just need to run the code again. Example: >>> decryptions = crack(\"XUOOB\", fitness.english.quadgrams) >>> print(decryptions[0]) HELLO Args: ciphertext (str): The text to decrypt *fitness_functions (variable length argument list): Functions to score decryption with Keyword Args: ntrials (int): The number of times to run the hill climbing algorithm nswaps (int): The number of rounds to find a local maximum Returns: Sorted list of decryptions Raises: ValueError: If nswaps or ntrails are not positive integers ValueError: If no fitness_functions are given", "response": "def crack(ciphertext, *fitness_functions, ntrials=30, nswaps=3000):\n    \"\"\"Break ``ciphertext`` using hill climbing.\n\n    Note:\n        Currently ntrails and nswaps default to magic numbers.\n        Generally the trend is, the longer the text, the lower the number of trials\n        you need to run, because the hill climbing will lead to the best answer faster.\n        Because randomness is involved, there is the possibility of the correct decryption\n        not being found. In this circumstance you just need to run the code again.\n\n    Example:\n        >>> decryptions = crack(\"XUOOB\", fitness.english.quadgrams)\n        >>> print(decryptions[0])\n        HELLO\n\n    Args:\n        ciphertext (str): The text to decrypt\n        *fitness_functions (variable length argument list): Functions to score decryption with\n\n    Keyword Args:\n        ntrials (int): The number of times to run the hill climbing algorithm\n        nswaps (int): The number of rounds to find a local maximum\n\n    Returns:\n        Sorted list of decryptions\n\n    Raises:\n        ValueError: If nswaps or ntrails are not positive integers\n        ValueError: If no fitness_functions are given\n    \"\"\"\n    if ntrials <= 0 or nswaps <= 0:\n        raise ValueError(\"ntrials and nswaps must be positive integers\")\n\n    # Find a local maximum by swapping two letters and scoring the decryption\n    def next_node_inner_climb(node):\n        # Swap 2 characters in the key\n        a, b = random.sample(range(len(node)), 2)\n        node[a], node[b] = node[b], node[a]\n        plaintext = decrypt(node, ciphertext)\n        node_score = score(plaintext, *fitness_functions)\n        return node, node_score, Decryption(plaintext, ''.join(node), node_score)\n\n    # Outer climb rereuns hill climb ntrials number of times each time at a different start location\n    def next_node_outer_climb(node):\n        random.shuffle(node)\n        key, best_score, outputs = hill_climb(nswaps, node[:], next_node_inner_climb)\n        return key, best_score, outputs[-1]  # The last item in this list is the item with the highest score\n\n    _, _, decryptions = hill_climb(ntrials, list(string.ascii_uppercase), next_node_outer_climb)\n    return sorted(decryptions, reverse=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_device_name(self, newname):\n        return self.write(request.SetDeviceName(self.seq, *self.prep_str(newname)))", "response": "Sets the bluetooth device name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_heading(self, value):\n        return self.write(request.SetHeading(self.seq, value))", "response": "set the heading of the log entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_rotation_rate(self, val):\n        return self.write(request.SetRotationRate(self.seq, val))", "response": "set the rotation rate of the current user"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets backled output value", "response": "def set_back_led_output(self, value):\n        \"\"\"value can be between 0x00 and 0xFF\"\"\"\n        return self.write(request.SetBackLEDOutput(self.seq, value))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef roll(self, speed, heading, state=1):\n        return self.write(request.Roll(self.seq, speed, heading, state ))", "response": "speed can have value between 0x00 and 0xFF \n        heading can have value between 0 and 359"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ISBNValidator(raw_isbn):\n    isbn_to_check = raw_isbn.replace('-', '').replace(' ', '')\n\n    if not isinstance(isbn_to_check, string_types):\n        raise ValidationError(_(u'Invalid ISBN: Not a string'))\n\n    if len(isbn_to_check) != 10 and len(isbn_to_check) != 13:\n        raise ValidationError(_(u'Invalid ISBN: Wrong length'))\n    \n    if not isbn.is_valid(isbn_to_check):\n        raise ValidationError(_(u'Invalid ISBN: Failed checksum'))\n\n    if isbn_to_check != isbn_to_check.upper():\n        raise ValidationError(_(u'Invalid ISBN: Only upper case allowed'))\n\n    return True", "response": "Check string is a valid ISBN number"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _is_peer(self, keys, node_self, node_other):\n        '''_is_peer\n\n        Low-level api: Return True if node_self and node_other are considered\n        as peer with regards to a set of keys.\n\n        Parameters\n        ----------\n\n        keys : `list`\n            A list of keys in `{url}tagname` notation.\n\n        node_self : `Element`\n            An Element node on this side.\n\n        node_other : `Element`\n            An Element node on the other side.\n\n        Returns\n        -------\n\n        list\n            True if node_self is a peer of node_other, otherwise, return False.\n        '''\n\n        for key in keys:\n            s = list(node_self.iterchildren(tag=key))\n            o = list(node_other.iterchildren(tag=key))\n            if len(s) < 1 or len(o) < 1:\n                raise ConfigError(\"cannot find key '{}' in node {}\" \\\n                                  .format(key,\n                                          self.device.get_xpath(node_self)))\n            if len(s) > 1 or len(o) > 1:\n                raise ConfigError(\"not unique key '{}' in node {}\" \\\n                                  .format(key,\n                                          self.device.get_xpath(node_self)))\n            if s[0].text != o[0].text:\n                return False\n        return True", "response": "Internal function to check if a set of keys is a peer of a set of keys."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a battery level reward", "response": "def reward_battery(self):\n        \"\"\"\n        Add a battery level reward\n        \"\"\"\n        if not 'battery' in self.mode:\n            return\n        mode = self.mode['battery']\n        if mode and mode and self.__test_cond(mode):\n            self.logger.debug('Battery out')\n            self.player.stats['reward'] += mode['reward']\n\n            self.player.game_over = self.player.game_over or mode['terminal']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a food collision reward", "response": "def reward_item(self, item_type):\n        \"\"\"\n        Add a food collision reward\n        \"\"\"\n        assert isinstance(item_type, str)\n\n        if not 'items' in self.mode:\n            return\n        mode = self.mode['items']\n        if mode and mode[item_type] and self.__test_cond(mode[item_type]):\n            self.logger.debug(\"{item_type} consumed\".format(item_type=item_type))\n            self.player.stats['reward'] += mode[item_type]['reward']\n            self.player.stats['score'] += mode[item_type]['reward']\n\n            self.player.game_over = self.player.game_over or mode[item_type]['terminal']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a wall collision reward", "response": "def reward_wall(self):\n        \"\"\"\n        Add a wall collision reward\n        \"\"\"\n        if not 'wall' in self.mode:\n            return\n        mode = self.mode['wall']\n        if mode and mode and self.__test_cond(mode):\n            self.logger.debug(\"Wall {x}/{y}'\".format(x=self.bumped_x, y=self.bumped_y))\n            self.player.stats['reward'] += mode['reward']\n\n            self.player.game_over = self.player.game_over or mode['terminal']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reward_explore(self):\n        if not 'explore' in self.mode:\n            return\n        mode = self.mode['explore']\n        if mode and mode['reward'] and self.__test_cond(mode):\n            self.player.stats['reward'] += mode['reward']\n            self.player.stats['score'] += mode['reward']\n\n            self.player.game_over = self.player.game_over or mode['terminal']", "response": "Add an exploration reward to the player"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an end goal reward to the current state.", "response": "def reward_goal(self):\n        \"\"\"\n        Add an end goal reward\n        \"\"\"\n        if not 'goal' in self.mode:\n            return\n        mode = self.mode['goal']\n        if mode and mode['reward'] and self.__test_cond(mode):\n            if mode['reward'] > 0:\n                self.logger.info(\"Escaped!!\")\n            self.player.stats['reward'] += mode['reward']\n            self.player.stats['score'] += mode['reward']\n\n            self.player.game_over = self.player.game_over or mode['terminal']"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reward_proximity(self):\n        if not 'proximity' in self.mode:\n            return\n        mode = self.mode['proximity']\n\n        # Calculate proximity reward\n        reward = 0\n        for sensor in self.player.sensors:\n            if sensor.sensed_type == 'wall':\n                reward += sensor.proximity_norm()\n            else:\n                reward += 1\n\n        reward /= len(self.player.sensors)\n        #reward = min(1.0, reward * 2)\n        reward = min(1.0, reward * reward)\n        # TODO: Configurable bonus reward threshold. Pass extra args to `__test_cond`?\n        #if mode and mode and reward > 0.75 and self.__test_cond(mode):\n        if mode and mode and self.__test_cond(mode):\n            # Apply bonus\n            reward *= mode['reward']\n\n        self.player.stats['reward'] += reward", "response": "Adds a wall proximity reward"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, dt):\n        for key, value in self.labels.iteritems():\n            str_val = str(int(self.stats[key]))\n            self.msgs[key][0].element.text = self.labels[key] + str_val\n            self.msgs[key][1].element.text = self.labels[key] + str_val", "response": "Updates game engine each tick\n            Copies new stats into labels\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sitemap_uri(self, basename):\n        if (re.match(r\"\\w+:\", basename)):\n            # looks like URI\n            return(basename)\n        elif (re.match(r\"/\", basename)):\n            # looks like full path\n            return(basename)\n        else:\n            # build from mapping with name appended\n            return(self.mapper.default_src_uri() + '/' + basename)", "response": "Get full URI for sitemap based on basename."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sitemap(self):\n        if (self.sitemap_name is not None):\n            return(self.sitemap_name)\n        return(self.sitemap_uri(self.resource_list_name))", "response": "Return the sitemap URI based on maps or explicit settings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_resource_list(self, uri):\n        self.logger.info(\"Reading resource list %s\" % (uri))\n        try:\n            resource_list = ResourceList(allow_multifile=self.allow_multifile,\n                                         mapper=self.mapper)\n            resource_list.read(uri=uri)\n        except Exception as e:\n            raise ClientError(\"Can't read source resource list from %s (%s)\" %\n                              (uri, str(e)))\n        self.logger.debug(\"Finished reading resource list\")\n        return(resource_list)", "response": "Read resource list from specified URI."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_resource_list_from_source_description(self, uri):\n        self.logger.info(\"Reading source description %s\" % (uri))\n        try:\n            sd = SourceDescription()\n            sd.read(uri=uri)\n        except Exception as e:\n            raise ClientError(\n                \"Can't read source description from %s (%s)\" %\n                (uri, str(e)))\n        if (len(sd) == 0):\n            raise ClientFatalError(\n                \"Source description %s has no sources\" % (uri))\n        elif (len(sd) > 1):\n            raise ClientFatalError(\n                \"Source description %s has multiple sources, specify one \"\n                \"with --capabilitylist\" % (uri))\n        self.logger.info(\"Finished reading source description\")\n        cluri = sd.resources.first().uri\n        uri = urljoin(uri, cluri)  # FIXME - Should relative URI handling be elsewhere?\n        return(self.find_resource_list_from_capability_list(uri))", "response": "Read source description to find resource list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_resource_list_from_capability_list(self, uri):\n        self.logger.info(\"Reading capability list %s\" % (uri))\n        try:\n            cl = CapabilityList()\n            cl.read(uri=uri)\n        except Exception as e:\n            raise ClientError(\n                \"Can't read capability list from %s (%s)\" %\n                (uri, str(e)))\n        if (not cl.has_capability('resourcelist')):\n            raise ClientFatalError(\n                \"Capability list %s does not describe a resource list\" % (uri))\n        rluri = cl.capability_info('resourcelist').uri\n        return(urljoin(uri, rluri))", "response": "Read the capability list to find the resource list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_resource_list(self):\n        # 1 & 2\n        if (self.sitemap_name is not None):\n            return(self.read_resource_list(self.sitemap_name))\n        if (self.capability_list_uri is not None):\n            rluri = self.find_resource_list_from_capability_list(self.capability_list_uri)\n            return(self.read_resource_list(rluri))\n        # 3 & 4\n        parts = urlsplit(self.sitemap)\n        uri_host = urlunsplit([parts[0], parts[1], '', '', ''])\n        errors = []\n        for uri in [urljoin(self.sitemap, '.well-known/resourcesync'),\n                    urljoin(uri_host, '.well-known/resourcesync')]:\n            uri = uri.lstrip('file:///')  # urljoin adds this for local files\n            try:\n                rluri = self.find_resource_list_from_source_description(uri)\n                return(self.read_resource_list(rluri))\n            except ClientError as e:\n                errors.append(str(e))\n        # 5, 6 & 7\n        for uri in [urljoin(self.sitemap, 'resourcelist.xml'),\n                    urljoin(self.sitemap, 'sitemap.xml'),\n                    urljoin(uri_host, 'sitemap.xml')]:\n            uri = uri.lstrip('file:///')  # urljoin adds this for local files\n            try:\n                return(self.read_resource_list(uri))\n            except ClientError as e:\n                errors.append(str(e))\n        raise ClientFatalError(\n            \"Failed to find source resource list from common patterns (%s)\" %\n            \". \".join(errors))", "response": "Figures out the resource list by hueristics."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_resource_list(self, paths=None, set_path=False):\n        # 0. Sanity checks, parse paths is specified\n        if (len(self.mapper) < 1):\n            raise ClientFatalError(\n                \"No source to destination mapping specified\")\n        if (paths is not None):\n            # Expect comma separated list of paths\n            paths = paths.split(',')\n        # 1. Build from disk\n        rlb = ResourceListBuilder(set_hashes=self.hashes, mapper=self.mapper)\n        rlb.set_path = set_path\n        try:\n            rlb.add_exclude_files(self.exclude_patterns)\n            rl = rlb.from_disk(paths=paths)\n        except ValueError as e:\n            raise ClientFatalError(str(e))\n        # 2. Set defaults and overrides\n        rl.allow_multifile = self.allow_multifile\n        rl.pretty_xml = self.pretty_xml\n        rl.mapper = self.mapper\n        if (self.max_sitemap_entries is not None):\n            rl.max_sitemap_entries = self.max_sitemap_entries\n        return(rl)", "response": "Build a resource list from the paths specified in the current mappings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_resource(self, resource, filename, change=None):\n        path = os.path.dirname(filename)\n        distutils.dir_util.mkpath(path)\n        num_updated = 0\n        if (self.dryrun):\n            self.logger.info(\n                \"dryrun: would GET %s --> %s\" %\n                (resource.uri, filename))\n        else:\n            # 1. GET\n            for try_i in range(1, self.tries + 1):\n                try:\n                    r = requests.get(resource.uri, timeout=self.timeout, stream=True)\n                    # Fail on 4xx or 5xx\n                    r.raise_for_status()\n                    with open(filename, 'wb') as fd:\n                        for chunk in r.iter_content(chunk_size=1024):\n                            fd.write(chunk)\n                    num_updated += 1\n                    break\n                except requests.Timeout as e:\n                    if try_i < self.tries:\n                        msg = 'Download timed out, retrying...'\n                        self.logger.info(msg)\n                        # Continue loop\n                    else:\n                        # No more tries left, so fail\n                        msg = \"Failed to GET %s after %s tries -- %s\" % (resource.uri, self.tries, str(e))\n                        if (self.ignore_failures):\n                            self.logger.warning(msg)\n                            return(num_updated)\n                        else:\n                            raise ClientFatalError(msg)\n                except (requests.RequestException, IOError) as e:\n                    msg = \"Failed to GET %s -- %s\" % (resource.uri, str(e))\n                    if (self.ignore_failures):\n                        self.logger.warning(msg)\n                        return(num_updated)\n                    else:\n                        raise ClientFatalError(msg)\n            # 2. set timestamp if we have one\n            if (resource.timestamp is not None):\n                unixtime = int(resource.timestamp)  # no fractional\n                os.utime(filename, (unixtime, unixtime))\n                if (resource.timestamp > self.last_timestamp):\n                    self.last_timestamp = resource.timestamp\n            self.log_event(Resource(resource=resource, change=change))\n            # 3. sanity check\n            length = os.stat(filename).st_size\n            if (resource.length is not None and resource.length != length):\n                self.logger.info(\n                    \"Downloaded size for %s of %d bytes does not match expected %d bytes\" %\n                    (resource.uri, length, resource.length))\n            if (len(self.hashes) > 0):\n                self.check_hashes(filename, resource)\n        return(num_updated)", "response": "Update resource from uri to filename on local system."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks all hashes present in self. hashes and report them to the logger.", "response": "def check_hashes(self, filename, resource):\n        \"\"\"Check all hashes present in self.hashes _and_ resource object.\n\n        Simply shows warning for mismatch, does not raise exception or\n        otherwise stop process.\n        \"\"\"\n        # which hashes to calculate?\n        hashes = []\n        if ('md5' in self.hashes and resource.md5 is not None):\n            hashes.append('md5')\n        if ('sha-1' in self.hashes and resource.sha1 is not None):\n            hashes.append('sha-1')\n        if ('sha-256' in self.hashes and resource.sha256 is not None):\n            hashes.append('sha-256')\n        # calculate\n        hasher = Hashes(hashes, filename)\n        # check and report\n        if ('md5' in hashes and resource.md5 != hasher.md5):\n            self.logger.info(\n                \"MD5 mismatch for %s, got %s but expected %s\" %\n                (resource.uri, hasher.md5, resource.md5))\n        if ('sha-1' in hashes and resource.sha1 != hasher.sha1):\n            self.logger.info(\n                \"SHA-1 mismatch for %s, got %s but expected %s\" %\n                (resource.uri, hasher.sha1, resource.sha1))\n        if ('sha-256' in hashes and resource.sha256 != hasher.sha256):\n            self.logger.info(\n                \"SHA-256 mismatch for %s, got %s but expected %s\" %\n                (resource.uri, hasher.sha256, resource.sha256))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_resource(self, resource, filename, allow_deletion=False):\n        num_deleted = 0\n        uri = resource.uri\n        if (resource.timestamp is not None and\n                resource.timestamp > self.last_timestamp):\n            self.last_timestamp = resource.timestamp\n        if (allow_deletion):\n            if (self.dryrun):\n                self.logger.info(\n                    \"dryrun: would delete %s -> %s\" %\n                    (uri, filename))\n            else:\n                try:\n                    os.unlink(filename)\n                    num_deleted += 1\n                    self.logger.info(\"deleted: %s -> %s\" % (uri, filename))\n                    self.log_event(\n                        Resource(\n                            resource=resource,\n                            change=\"deleted\"))\n                except OSError as e:\n                    msg = \"Failed to DELETE %s -> %s : %s\" % (\n                        uri, filename, str(e))\n                    # if (self.ignore_failures):\n                    self.logger.warning(msg)\n                    #    return\n                    # else:\n                    #    raise ClientFatalError(msg)\n        else:\n            self.logger.info(\n                \"nodelete: would delete %s (--delete to enable)\" %\n                uri)\n        return(num_deleted)", "response": "Delete a resource from the local system."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses any ResourceSync document and show information.", "response": "def parse_document(self):\n        \"\"\"Parse any ResourceSync document and show information.\n\n        Will use sitemap URI taken either from explicit self.sitemap_name\n        or derived from the mappings supplied.\n        \"\"\"\n        s = Sitemap()\n        self.logger.info(\"Reading sitemap(s) from %s ...\" % (self.sitemap))\n        try:\n            list = s.parse_xml(url_or_file_open(self.sitemap))\n        except IOError as e:\n            raise ClientFatalError(\"Cannot read document (%s)\" % str(e))\n        num_entries = len(list.resources)\n        capability = '(unknown capability)'\n        if ('capability' in list.md):\n            capability = list.md['capability']\n        print(\"Parsed %s document with %d entries\" % (capability, num_entries))\n        if (self.verbose):\n            to_show = 100\n            override_str = ' (override with --max-sitemap-entries)'\n            if (self.max_sitemap_entries):\n                to_show = self.max_sitemap_entries\n                override_str = ''\n            if (num_entries > to_show):\n                print(\n                    \"Showing first %d entries sorted by URI%s...\" %\n                    (to_show, override_str))\n            n = 0\n            for resource in list:\n                print('[%d] %s' % (n, str(resource)))\n                n += 1\n                if (n >= to_show):\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite a Resource List or a Resource Dump for files on local disk.", "response": "def write_resource_list(\n            self, paths=None, outfile=None, links=None, dump=None):\n        \"\"\"Write a Resource List or a Resource Dump for files on local disk.\n\n        Set of resources included is based on paths setting or else the mappings.\n        Optionally links can be added. Output will be to stdout unless outfile\n        is specified.\n\n        If dump is true then a Resource Dump is written instead of a Resource\n        List. If outfile is not set then self.default_resource_dump will be used.\n        \"\"\"\n        rl = self.build_resource_list(paths=paths, set_path=dump)\n        if (links is not None):\n            rl.ln = links\n        if (dump):\n            if (outfile is None):\n                outfile = self.default_resource_dump\n            self.logger.info(\"Writing resource dump to %s...\" % (dump))\n            d = Dump(resources=rl, format=self.dump_format)\n            d.write(basename=outfile)\n        else:\n            if (outfile is None):\n                try:\n                    print(rl.as_xml())\n                except ListBaseIndexError as e:\n                    raise ClientFatalError(\n                        \"%s. Use --output option to specify base name for output files.\" %\n                        str(e))\n            else:\n                rl.write(basename=outfile)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_change_list(self, paths=None, outfile=None, ref_sitemap=None, newref_sitemap=None,\n                          empty=None, links=None, dump=None):\n        \"\"\"Write a change list.\n\n        Unless the both ref_sitemap and newref_sitemap are specified then the Change\n        List is calculated between the reference an the current state of files on\n        disk. The files on disk are scanned based either on the paths setting or\n        else on the mappings.\n        \"\"\"\n        cl = ChangeList(ln=links)\n        if (not empty):\n            # 1. Get and parse reference sitemap\n            old_rl = self.read_reference_resource_list(ref_sitemap)\n            # 2. Depending on whether a newref_sitemap was specified, either read that\n            # or build resource list from files on disk\n            if (newref_sitemap is None):\n                # Get resource list from disk\n                new_rl = self.build_resource_list(paths=paths, set_path=dump)\n            else:\n                new_rl = self.read_reference_resource_list(\n                    newref_sitemap, name='new reference')\n            # 3. Calculate change list\n            (same, updated, deleted, created) = old_rl.compare(new_rl)\n            cl.add_changed_resources(updated, change='updated')\n            cl.add_changed_resources(deleted, change='deleted')\n            cl.add_changed_resources(created, change='created')\n        # 4. Write out change list\n        cl.mapper = self.mapper\n        cl.pretty_xml = self.pretty_xml\n        if (self.max_sitemap_entries is not None):\n            cl.max_sitemap_entries = self.max_sitemap_entries\n        if (outfile is None):\n            print(cl.as_xml())\n        else:\n            cl.write(basename=outfile)\n        self.write_dump_if_requested(cl, dump)", "response": "Write a change list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite a Capability List to outfile or STDOUT.", "response": "def write_capability_list(self, capabilities=None,\n                              outfile=None, links=None):\n        \"\"\"Write a Capability List to outfile or STDOUT.\"\"\"\n        capl = CapabilityList(ln=links)\n        capl.pretty_xml = self.pretty_xml\n        if (capabilities is not None):\n            for name in capabilities.keys():\n                capl.add_capability(name=name, uri=capabilities[name])\n        if (outfile is None):\n            print(capl.as_xml())\n        else:\n            capl.write(basename=outfile)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_source_description(\n            self, capability_lists=None, outfile=None, links=None):\n        \"\"\"Write a ResourceSync Description document to outfile or STDOUT.\"\"\"\n        rsd = SourceDescription(ln=links)\n        rsd.pretty_xml = self.pretty_xml\n        if (capability_lists is not None):\n            for uri in capability_lists:\n                rsd.add_capability_list(uri)\n        if (outfile is None):\n            print(rsd.as_xml())\n        else:\n            rsd.write(basename=outfile)", "response": "Write a ResourceSync Description document to outfile or STDOUT."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the reference resource list and return the ResourceList object.", "response": "def read_reference_resource_list(self, ref_sitemap, name='reference'):\n        \"\"\"Read reference resource list and return the ResourceList object.\n\n        The name parameter is used just in output messages to say what type\n        of resource list is being read.\n        \"\"\"\n        rl = ResourceList()\n        self.logger.info(\n            \"Reading %s resource list from %s ...\" %\n            (name, ref_sitemap))\n        rl.mapper = self.mapper\n        rl.read(uri=ref_sitemap, index_only=(not self.allow_multifile))\n        num_entries = len(rl.resources)\n        self.logger.info(\n            \"Read %s resource list with %d entries in %d sitemaps\" %\n            (name, num_entries, rl.num_files))\n        if (self.verbose):\n            to_show = 100\n            override_str = ' (override with --max-sitemap-entries)'\n            if (self.max_sitemap_entries):\n                to_show = self.max_sitemap_entries\n                override_str = ''\n            if (num_entries > to_show):\n                print(\n                    \"Showing first %d entries sorted by URI%s...\" %\n                    (to_show, override_str))\n            n = 0\n            for r in rl.resources:\n                print(r)\n                n += 1\n                if (n >= to_show):\n                    break\n        return(rl)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npruning any hashes not in source resource or change list.", "response": "def prune_hashes(self, hashes, list_type):\n        \"\"\"Prune any hashes not in source resource or change list.\"\"\"\n        discarded = []\n        for hash in hashes:\n            if (hash in self.hashes):\n                self.hashes.discard(hash)\n                discarded.append(hash)\n        self.logger.info(\"Not calculating %s hash(es) on destination as not present \"\n                         \"in source %s list\" % (', '.join(sorted(discarded)), list_type))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite log message regarding status of the current object.", "response": "def log_status(self, in_sync=True, incremental=False, audit=False,\n                   same=None, created=0, updated=0, deleted=0, to_delete=0):\n        \"\"\"Write log message regarding status in standard form.\n\n        Split this off so all messages from baseline/audit/incremental\n        are written in a consistent form.\n        \"\"\"\n        if (audit):\n            words = {'created': 'to create',\n                     'updated': 'to update',\n                     'deleted': 'to delete'}\n        else:\n            words = {'created': 'created',\n                     'updated': 'updated',\n                     'deleted': 'deleted'}\n        if in_sync:\n            # status rather than action\n            status = \"NO CHANGES\" if incremental else \"IN SYNC\"\n        else:\n            if audit:\n                status = \"NOT IN SYNC\"\n            elif (to_delete > deleted):\n                # will need --delete\n                status = \"PART APPLIED\" if incremental else\"PART SYNCED\"\n                words['deleted'] = 'to delete (--delete)'\n                deleted = to_delete\n            else:\n                status = \"CHANGES APPLIED\" if incremental else \"SYNCED\"\n        same = \"\" if (same is None) else (\"same=%d, \" % same)\n        self.logger.warning(\"Status: %15s (%s%s=%d, %s=%d, %s=%d)\" %\n                            (status, same, words['created'], created,\n                             words['updated'], updated, words['deleted'], deleted))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _fromstring(value):\n    '''_fromstring\n\n    Convert XML string value to None, boolean, int or float.\n    '''\n\n    if not value:\n        return [None]\n    std_value = value.strip().lower()\n    if std_value == 'true':\n        return True\n    elif std_value == 'false':\n        return False\n    try:\n        return int(std_value)\n    except ValueError:\n        pass\n    try:\n        return float(std_value)\n    except ValueError:\n        pass\n    return value", "response": "_fromstring\n    Convert XML string value to None boolean int or float."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_config_node(self):\n        '''get_config_node\n\n        High-level api: get_config_node returns an Element node in the config\n        tree, which is corresponding to the URL in the Restconf GET reply.\n\n        Returns\n        -------\n\n        Element\n            A config node.\n        '''\n\n        default_ns = ''\n        config_node = etree.Element(config_tag, nsmap={'nc': nc_url})\n        for index, url_piece in enumerate(self._url_pieces):\n            if index == len(self._url_pieces)-1:\n                config_node_parent = self.copy(config_node)\n            node_name, values = self.parse_url_piece(url_piece)\n            default_ns, tag = self.convert_tag(default_ns, node_name,\n                                               src=Tag.JSON_NAME,\n                                               dst=Tag.LXML_ETREE)\n            config_node = self.subelement(config_node, tag, None)\n            schema_node = self.device.get_schema_node(config_node)\n            if schema_node.get('type') == 'leaf-list' and len(values) > 0:\n                model_name, text_value = self.get_name(values[0])\n                if model_name:\n                    prefix = self._name_to_prefix[model_name]\n                    config_node.text = '{}:{}'.format(prefix, text_value)\n                else:\n                    config_node.text = text_value\n            elif schema_node.get('type') == 'list' and len(values) > 0:\n                key_tags = BaseCalculator._get_list_keys(schema_node)\n                for key_tag, value in zip(key_tags, values):\n                    key = self.subelement(config_node, key_tag, value)\n        return config_node_parent, config_node", "response": "High - level api to get a config node in the config tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_json(self, instance=True):\n        '''get_json\n\n        High-level api: get_json returns json_val of the config node.\n\n        Parameters\n        ----------\n\n        instance : `bool`\n            True if only one instance of list or leaf-list is required. False if\n            all instances of list or leaf-list are needed.\n\n        Returns\n        -------\n\n        str\n            A string in JSON format.\n        '''\n\n        def get_json_instance(node):\n            pk = Parker(xml_fromstring=_fromstring, dict_type=OrderedDict)\n            default_ns = {}\n            nodes = [node] + node.findall('.//')\n            for item in nodes:\n                parents = [p for p in node.findall('.//{}/..'.format(item.tag))\n                          if item in p.findall('*')]\n                if parents and id(parents[0]) in default_ns:\n                    default_url = default_ns[id(parents[0])]\n                    ns, tag = self.device.convert_tag(default_url, item.tag,\n                                                      dst=Tag.JSON_NAME)\n                else:\n                    ns, tag = self.device.convert_tag('', item.tag,\n                                                      dst=Tag.JSON_NAME)\n                default_ns[id(item)] = ns\n                item.tag = tag\n            return pk.data(node, preserve_root=True)\n\n        def convert_node(node):\n            # lxml.etree does not allow tag name like oc-if:enable\n            # so it is converted to xml.etree.ElementTree\n            string = etree.tostring(node, encoding='unicode',\n                                    pretty_print=False)\n            return ElementTree.fromstring(string)\n\n        if instance:\n            return json.dumps(get_json_instance(convert_node(self.node)))\n        else:\n            nodes = [n for n in self.node.getparent() \\\n                                         .iterchildren(tag=self.node.tag)]\n            if len(nodes) > 1:\n                return json.dumps([get_json_instance(convert_node(n))\n                                   for n in nodes])\n            else:\n                return json.dumps(get_json_instance(convert_node(nodes[0])))", "response": "High - level api to get_json returns json_val of the config node."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef node_sub(self, node_self, node_other):\n        '''node_sub\n\n        High-level api: Compute the delta of two config nodes. This method is\n        recursive. Assume two config nodes are different.\n\n        Parameters\n        ----------\n\n        node_self : `Element`\n            A config node in the destination config that is being processed.\n            node_self cannot be a leaf node.\n\n        node_other : `Element`\n            A config node in the source config that is being processed.\n\n        Returns\n        -------\n\n        tuple\n            There are three elements in the tuple: a list of Restconf DELETE\n            Requests, a list of Restconf PUT Requests, and a list of Restconf\n            PATCH Requests.\n        '''\n\n        deletes = []\n        puts = []\n        patches = []\n\n        # if a leaf-list node, delete the leaf-list totally\n        # if a list node, by default delete the list instance\n        # if a list node and delete_whole=True, delete the list totally\n        def generate_delete(node, instance=True):\n            composer = RestconfComposer(self.device, node)\n            url = 'https://{}:{}'.format(self.ip, self.port)\n            url += composer.get_url(instance=instance)\n            deletes.append(requests.Request('DELETE', url, headers=header_json))\n\n        # if a leaf-list node, replace the leaf-list totally\n        # if a list node, replace the list totally\n        def generate_put(node, instance=True):\n            composer = RestconfComposer(self.device, node)\n            url = 'https://{}:{}'.format(self.ip, self.port)\n            url += composer.get_url(instance=instance)\n            data_json = composer.get_json(instance=instance)\n            puts.append(requests.Request('PUT', url, headers=header_json,\n                                         data=data_json))\n\n        # if a leaf-list node, update the leaf-list totally\n        # if a list node, by default update the list instance\n        # if a list node and update_whole=True, update the list totally\n        def generate_patch(node, instance=True):\n            composer = RestconfComposer(self.device, node)\n            url = 'https://{}:{}'.format(self.ip, self.port)\n            url += composer.get_url(instance=instance)\n            data_json = composer.get_json(instance=instance)\n            patches.append(requests.Request('PATCH', url, headers=header_json,\n                                            data=data_json))\n\n        # the sequence of list instances under node_self is different from the\n        # one under node_other\n        def list_seq_is_different(tag):\n            s_list = [i for i in node_self.iterchildren(tag=tag)]\n            o_list = [i for i in node_other.iterchildren(tag=tag)]\n            if [self.device.get_xpath(n) for n in s_list] == \\\n               [self.device.get_xpath(n) for n in o_list]:\n                return False\n            else:\n                return True\n\n        # all list instances under node_self have peers under node_other, and\n        # the sequence of list instances under node_self that have peers under\n        # node_other is same as the sequence of list instances under node_other\n        def list_seq_is_inclusive(tag):\n            s_list = [i for i in node_self.iterchildren(tag=tag)]\n            o_list = [i for i in node_other.iterchildren(tag=tag)]\n            s_seq = [self.device.get_xpath(n) for n in s_list]\n            o_seq = [self.device.get_xpath(n) for n in o_list]\n            if set(s_seq) <= set(o_seq) and \\\n               [i for i in s_seq if i in o_seq] == o_seq:\n                return True\n            else:\n                return False\n\n        in_s_not_in_o, in_o_not_in_s, in_s_and_in_o = \\\n            self._group_kids(node_self, node_other)\n        for child_s in in_s_not_in_o:\n            schema_node = self.device.get_schema_node(child_s)\n            if schema_node.get('type') == 'leaf' or \\\n               schema_node.get('type') == 'container':\n                generate_patch(child_s)\n            elif schema_node.get('type') == 'leaf-list' or \\\n                 schema_node.get('type') == 'list':\n                if schema_node.get('ordered-by') == 'user':\n                    return ([], [generate_put(node_self, instance=True)], [])\n                else:\n                    generate_put(child_s, instance=True)\n        for child_o in in_o_not_in_s:\n            schema_node = self.device.get_schema_node(child_o)\n            if schema_node.get('type') == 'leaf' or \\\n               schema_node.get('type') == 'container':\n                generate_delete(child_o)\n            elif schema_node.get('type') == 'leaf-list' or \\\n                 schema_node.get('type') == 'list':\n                if schema_node.get('ordered-by') == 'user':\n                    if list_seq_is_inclusive(child_o.tag):\n                        generate_delete(child_o, instance=True)\n                    else:\n                        return ([], [generate_put(node_self, instance=True)],\n                                [])\n                else:\n                    generate_delete(child_o, instance=True)\n        for child_s, child_o in in_s_and_in_o:\n            schema_node = self.device.get_schema_node(child_s)\n            if schema_node.get('type') == 'leaf':\n                if child_s.text != child_o.text:\n                    generate_patch(child_s)\n            elif schema_node.get('type') == 'leaf-list':\n                if schema_node.get('ordered-by') == 'user':\n                    if list_seq_is_different(child_s.tag):\n                        return ([], [generate_put(node_self, instance=True)],\n                                [])\n            elif schema_node.get('type') == 'container':\n                if BaseCalculator(self.device, child_s, child_o).ne:\n                    x, y, z = self.node_sub(child_s, child_o)\n                    deletes += x\n                    puts += y\n                    patches += z\n            elif schema_node.get('type') == 'list':\n                if schema_node.get('ordered-by') == 'user':\n                    if list_seq_is_different(child_s.tag):\n                        return ([], [generate_put(node_self, instance=True)],\n                                [])\n                    else:\n                        if BaseCalculator(self.device, child_s, child_o).ne:\n                            x, y, z = self.node_sub(child_s, child_o)\n                            deletes += x\n                            puts += y\n                            patches += z\n                else:\n                    if BaseCalculator(self.device, child_s, child_o).ne:\n                        x, y, z = self.node_sub(child_s, child_o)\n                        deletes += x\n                        puts += y\n                        patches += z\n        return (deletes, puts, patches)", "response": "This method is used to compute the delta of two config nodes. This method is used to compute the delta of two config nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrenders a latex template", "response": "def render_latex_template(path_templates, template_filename,\n        template_vars=None):\n    '''Render a latex template, filling in its template variables\n\n    :param path_templates: the path to the template directory\n    :param template_filename: the name, rooted at the path_template_directory,\n        of the desired template for rendering\n    :param template_vars: dictionary of key:val for jinja2 variables\n        defaults to None for case when no values need to be passed\n    '''\n    var_dict = template_vars if template_vars else {}\n    var_dict_escape = recursive_apply(var_dict, escape_latex_str_if_str)\n    j2_env = jinja2.Environment(\n            loader=jinja2.FileSystemLoader(path_templates), **J2_ARGS\n            )\n    template = j2_env.get_template(template_filename)\n    return template.render(**var_dict_escape)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _normalize_day(year, month, day):\n    if year < MIN_YEAR or year > MAX_YEAR:\n        raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n    if month < 1 or month > 12:\n        raise ValueError(\"Month out of range (1..12)\")\n    days_in_month = DAYS_IN_MONTH[(year, month)]\n    if day in (days_in_month, -1):\n        return year, month, -1\n    if day in (days_in_month - 1, -2):\n        return year, month, -2\n    if day in (days_in_month - 2, -3):\n        return year, month, -3\n    if 1 <= day <= days_in_month - 3:\n        return year, month, int(day)\n    # TODO improve this error message\n    raise ValueError(\"Day %d out of range (1..%d, -1, -2 ,-3)\" % (day, days_in_month))", "response": "Coerce the day of the month to an internal value that may or may not match the public value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_ordinal(cls, ordinal):\n        if ordinal == 0:\n            return ZeroDate\n        if ordinal >= 736695:\n            year = 2018     # Project release year\n            month = 1\n            day = int(ordinal - 736694)\n        elif ordinal >= 719163:\n            year = 1970     # Unix epoch\n            month = 1\n            day = int(ordinal - 719162)\n        else:\n            year = 1\n            month = 1\n            day = int(ordinal)\n        if day < 1 or day > 3652059:\n            # Note: this requires a maximum of 22 bits for storage\n            # Could be transferred in 3 bytes.\n            raise ValueError(\"Ordinal out of range (1..3652059)\")\n        if year < MIN_YEAR or year > MAX_YEAR:\n            raise ValueError(\"Year out of range (%d..%d)\" % (MIN_YEAR, MAX_YEAR))\n        days_in_year = DAYS_IN_YEAR[year]\n        while day > days_in_year:\n            day -= days_in_year\n            year += 1\n            days_in_year = DAYS_IN_YEAR[year]\n        days_in_month = DAYS_IN_MONTH[(year, month)]\n        while day > days_in_month:\n            day -= days_in_month\n            month += 1\n            days_in_month = DAYS_IN_MONTH[(year, month)]\n        year, month, day = _normalize_day(year, month, day)\n        return cls.__new(ordinal, year, month, day)", "response": "Return a new instance of the class with the given ordinal."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse(cls, s):\n        try:\n            numbers = map(int, s.split(\"-\"))\n        except (ValueError, AttributeError):\n            raise ValueError(\"Date string must be in format YYYY-MM-DD\")\n        else:\n            numbers = list(numbers)\n            if len(numbers) == 3:\n                return cls(*numbers)\n            raise ValueError(\"Date string must be in format YYYY-MM-DD\")", "response": "Parse a string to produce a : class :. Date object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_clock_time(cls, clock_time, epoch):\n        try:\n            clock_time = ClockTime(*clock_time)\n        except (TypeError, ValueError):\n            raise ValueError(\"Clock time must be a 2-tuple of (s, ns)\")\n        else:\n            ordinal = clock_time.seconds // 86400\n            return Date.from_ordinal(ordinal + epoch.date().to_ordinal())", "response": "Convert a ClockTime relative to a given epoch."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef replace(self, **kwargs):\n        return Date(kwargs.get(\"year\", self.__year),\n                    kwargs.get(\"month\", self.__month),\n                    kwargs.get(\"day\", self.__day))", "response": "Return a new Date with one or more components replaced\n        with new values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a native Python datetime. time value.", "response": "def from_native(cls, t):\n        \"\"\" Convert from a native Python `datetime.time` value.\n        \"\"\"\n        second = (1000000 * t.second + t.microsecond) / 1000000\n        return Time(t.hour, t.minute, second, t.tzinfo)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_clock_time(cls, clock_time, epoch):\n        clock_time = ClockTime(*clock_time)\n        ts = clock_time.seconds % 86400\n        nanoseconds = int(1000000000 * ts + clock_time.nanoseconds)\n        return Time.from_ticks(epoch.time().ticks + nanoseconds / 1000000000)", "response": "Convert a. ClockTime relative to a given epoch."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new Time with one or more components replaced with new values.", "response": "def replace(self, **kwargs):\n        \"\"\" Return a :class:`.Time` with one or more components replaced\n        with new values.\n        \"\"\"\n        return Time(kwargs.get(\"hour\", self.__hour),\n                    kwargs.get(\"minute\", self.__minute),\n                    kwargs.get(\"second\", self.__second),\n                    kwargs.get(\"tzinfo\", self.__tzinfo))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_native(self):\n        h, m, s = self.hour_minute_second\n        s, ns = nano_divmod(s, 1)\n        ms = int(nano_mul(ns, 1000000))\n        return time(h, m, s, ms)", "response": "Convert to a native Python time value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_user(ctx, param, value):\n    if value:\n        if value.isdigit():\n            user = User.query.get(str(value))\n        else:\n            user = User.query.filter(User.email == value).one_or_none()\n        return user", "response": "Return a user if exists."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tokens_create(name, user, scopes, internal):\n    token = Token.create_personal(\n        name, user.id, scopes=scopes, is_internal=internal)\n    db.session.commit()\n    click.secho(token.access_token, fg='blue')", "response": "Create a personal OAuth token."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes a personal OAuth token.", "response": "def tokens_delete(name=None, user=None, read_access_token=None, force=False):\n    \"\"\"Delete a personal OAuth token.\"\"\"\n    if not (name or user) and not read_access_token:\n        click.get_current_context().fail(\n            'You have to pass either a \"name\" and \"user\" or the \"token\"')\n    if name and user:\n        client = Client.query.filter(\n            Client.user_id == user.id,\n            Client.name == name,\n            Client.is_internal.is_(True)).one()\n        token = Token.query.filter(\n            Token.user_id == user.id,\n            Token.is_personal.is_(True),\n            Token.client_id == client.client_id).one()\n    elif read_access_token:\n        access_token = click.prompt('Token', hide_input=True)\n        token = Token.query.filter(Token.access_token == access_token).one()\n    else:\n        click.get_current_context().fail('No token was found with provided')\n    if force or click.confirm('Are you sure you want to delete the token?'):\n        db.session.delete(token)\n        db.session.commit()\n        click.secho(\n            'Token \"{}\" deleted.'.format(token.access_token), fg='yellow')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef normalize_residuals(self, points):\n        residuals = self.evaluate_residual(points)\n        solutions = self.evaluate_solution(points)\n        return [resid / soln for resid, soln in zip(residuals, solutions)]", "response": "Normalize residuals by the level of the variable."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef apply(self, query, value, alias):\n        try:\n            value = uuid.UUID(value)\n            return query.filter(self.column == value)\n        except ValueError:\n            return query", "response": "Convert UUID value to SQLAlchemy query object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify(self, otp, timestamp=False, sl=None, timeout=None,\n               return_response=False):\n        \"\"\"\n        Verify a provided OTP.\n\n        :param otp: OTP to verify.\n        :type otp: ``str``\n\n        :param timestamp: True to include request timestamp and session counter\n                          in the response. Defaults to False.\n        :type timestamp: ``bool``\n\n        :param sl: A value indicating percentage of syncing required by client.\n        :type sl: ``int`` or ``str``\n\n        :param timeout: Number of seconds to wait for sync responses.\n        :type timeout: ``int``\n\n        :param return_response: True to return a response object instead of the\n                                status code. Defaults to False.\n        :type return_response: ``bool``\n\n        :return: True is the provided OTP is valid, False if the\n        REPLAYED_OTP status value is returned or the response message signature\n        verification failed and None for the rest of the status values.\n        \"\"\"\n        ca_bundle_path = self._get_ca_bundle_path()\n\n        otp = OTP(otp, self.translate_otp)\n        rand_str = b(os.urandom(30))\n        nonce = base64.b64encode(rand_str, b('xz'))[:25].decode('utf-8')\n        query_string = self.generate_query_string(otp.otp, nonce, timestamp,\n                                                  sl, timeout)\n\n        threads = []\n        timeout = timeout or DEFAULT_TIMEOUT\n        for url in self.api_urls:\n            thread = URLThread('%s?%s' % (url, query_string), timeout,\n                               self.verify_cert, ca_bundle_path)\n            thread.start()\n            threads.append(thread)\n\n        # Wait for a first positive or negative response\n        start_time = time.time()\n        while threads and (start_time + timeout) > time.time():\n            for thread in threads:\n                if not thread.is_alive():\n                    if thread.exception:\n                        raise thread.exception\n                    elif thread.response:\n                        status = self.verify_response(thread.response,\n                                                      otp.otp, nonce,\n                                                      return_response)\n\n                        if status:\n                            if return_response:\n                                return status\n                            else:\n                                return True\n                    threads.remove(thread)\n            time.sleep(0.1)\n\n        # Timeout or no valid response received\n        raise Exception('NO_VALID_ANSWERS')", "response": "Verify a provided OTP."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef verify_multi(self, otp_list, max_time_window=DEFAULT_MAX_TIME_WINDOW,\n                     sl=None, timeout=None):\n        \"\"\"\n        Verify a provided list of OTPs.\n\n        :param max_time_window: Maximum number of seconds which can pass\n                                between the first and last OTP generation for\n                                the OTP to still be considered valid.\n        :type max_time_window: ``int``\n        \"\"\"\n\n        # Create the OTP objects\n        otps = []\n        for otp in otp_list:\n            otps.append(OTP(otp, self.translate_otp))\n\n        if len(otp_list) < 2:\n            raise ValueError('otp_list needs to contain at least two OTPs')\n\n        device_ids = set()\n        for otp in otps:\n            device_ids.add(otp.device_id)\n\n        # Check that all the OTPs contain same device id\n        if len(device_ids) != 1:\n            raise Exception('OTPs contain different device ids')\n\n        # Now we verify the OTPs and save the server response for each OTP.\n        # We need the server response, to retrieve the timestamp.\n        # It's possible to retrieve this value locally, without querying the\n        # server but in this case, user would need to provide his AES key.\n        for otp in otps:\n            response = self.verify(otp.otp, True, sl, timeout,\n                                   return_response=True)\n\n            if not response:\n                return False\n\n            otp.timestamp = int(response['timestamp'])\n\n        count = len(otps)\n        delta = otps[count - 1].timestamp - otps[0].timestamp\n\n        # OTPs have an 8Hz timestamp counter so we need to divide it to get\n        # seconds\n        delta = delta / 8\n\n        if delta < 0:\n            raise Exception('delta is smaller than zero. First OTP appears to '\n                            'be older than the last one')\n\n        if delta > max_time_window:\n            raise Exception(('More than %s seconds have passed between '\n                            'generating the first and the last OTP.') %\n                            (max_time_window))\n\n        return True", "response": "Verify a list of OTPs and save the server response."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef verify_response(self, response, otp, nonce, return_response=False):\n        try:\n            status = re.search(r'status=([A-Z0-9_]+)', response) \\\n                       .groups()\n\n            if len(status) > 1:\n                message = 'More than one status= returned. Possible attack!'\n                raise InvalidValidationResponse(message, response)\n\n            status = status[0]\n        except (AttributeError, IndexError):\n            return False\n\n        signature, parameters = \\\n            self.parse_parameters_from_response(response)\n\n        # Secret key is specified, so we verify the response message\n        # signature\n        if self.key:\n            generated_signature = \\\n                self.generate_message_signature(parameters)\n\n            # Signature located in the response does not match the one we\n            # have generated\n            if signature != generated_signature:\n                logger.warn(\"signature mismatch for parameters=%r\", parameters)\n                raise SignatureVerificationError(generated_signature,\n                                                 signature)\n        param_dict = self.get_parameters_as_dictionary(parameters)\n\n        if 'otp' in param_dict and param_dict['otp'] != otp:\n            message = 'Unexpected OTP in response. Possible attack!'\n            raise InvalidValidationResponse(message, response, param_dict)\n\n        if 'nonce' in param_dict and param_dict['nonce'] != nonce:\n            message = 'Unexpected nonce in response. Possible attack!'\n            raise InvalidValidationResponse(message, response, param_dict)\n\n        if status == 'OK':\n            if return_response:\n                return param_dict\n            else:\n                return True\n        elif status == 'NO_SUCH_CLIENT':\n            raise InvalidClientIdError(self.client_id)\n        elif status == 'REPLAYED_OTP':\n            raise StatusCodeError(status)\n\n        return False", "response": "Verify the response for the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a query string which is sent to the validation servers.", "response": "def generate_query_string(self, otp, nonce, timestamp=False, sl=None,\n                              timeout=None):\n        \"\"\"\n        Returns a query string which is sent to the validation servers.\n        \"\"\"\n        data = [('id', self.client_id),\n                ('otp', otp),\n                ('nonce', nonce)]\n\n        if timestamp:\n            data.append(('timestamp', '1'))\n\n        if sl is not None:\n            if sl not in range(0, 101) and sl not in ['fast', 'secure']:\n                raise Exception('sl parameter value must be between 0 and '\n                                '100 or string \"fast\" or \"secure\"')\n\n            data.append(('sl', sl))\n\n        if timeout:\n            data.append(('timeout', timeout))\n\n        query_string = urlencode(data)\n\n        if self.key:\n            hmac_signature = self.generate_message_signature(query_string)\n            hmac_signature = hmac_signature\n            query_string += '&h=%s' % (hmac_signature.replace('+', '%2B'))\n\n        return query_string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a HMAC - SHA - 1 signature for the given query string.", "response": "def generate_message_signature(self, query_string):\n        \"\"\"\n        Returns a HMAC-SHA-1 signature for the given query string.\n        http://goo.gl/R4O0E\n        \"\"\"\n        # split for sorting\n        pairs = query_string.split('&')\n        pairs = [pair.split('=', 1) for pair in pairs]\n        pairs_sorted = sorted(pairs)\n        pairs_string = '&' . join(['=' . join(pair) for pair in pairs_sorted])\n\n        digest = hmac.new(self.key, b(pairs_string), hashlib.sha1).digest()\n        signature = base64.b64encode(digest).decode('utf-8')\n\n        return signature"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the response signature and query string from the server response.", "response": "def parse_parameters_from_response(self, response):\n        \"\"\"\n        Returns a response signature and query string generated from the\n        server response. 'h' aka signature argument is stripped from the\n        returned query string.\n        \"\"\"\n        lines = response.splitlines()\n        pairs = [line.strip().split('=', 1) for line in lines if '=' in line]\n        pairs = sorted(pairs)\n        signature = ([unquote(v) for k, v in pairs if k == 'h'] or [None])[0]\n        # already quoted\n        query_string = '&' . join([k + '=' + v for k, v in pairs if k != 'h'])\n\n        return (signature, query_string)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_parameters_as_dictionary(self, query_string):\n        pairs = (x.split('=', 1) for x in query_string.split('&'))\n        return dict((k, unquote(v)) for k, v in pairs)", "response": "Returns the query string parameters as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the list of API URLs.", "response": "def _init_request_urls(self, api_urls):\n        \"\"\"\n        Returns a list of the API URLs.\n        \"\"\"\n        if not isinstance(api_urls, (str, list, tuple)):\n            raise TypeError('api_urls needs to be string or iterable!')\n\n        if isinstance(api_urls, str):\n            api_urls = (api_urls,)\n\n        api_urls = list(api_urls)\n\n        for url in api_urls:\n            if not url.startswith('http://') and \\\n               not url.startswith('https://'):\n                raise ValueError(('URL \"%s\" contains an invalid or missing'\n                                 ' scheme' % (url)))\n\n        return list(api_urls)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the path to the CA bundle which is used for verifying the hosts SSL certificate.", "response": "def _get_ca_bundle_path(self):\n        \"\"\"\n        Return a path to the CA bundle which is used for verifying the hosts\n        SSL certificate.\n        \"\"\"\n        if self.ca_certs_bundle_path:\n            # User provided a custom path\n            return self.ca_certs_bundle_path\n\n        # Return first bundle which is available\n        for file_path in COMMON_CA_LOCATIONS:\n            if self._is_valid_ca_bundle_file(file_path=file_path):\n                return file_path\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self):\n        '''connect\n\n        High-level api: opens the NetConf connection and exchanges\n        capabilities. Since topology YAML file is parsed by BaseConnection,\n        the following parameters can be specified in your YAML file.\n\n        Parameters\n        ----------\n\n        host : `string`\n            Hostname or IP address to connect to.\n        port : `int`, optional\n            By default port is 830, but some devices use the default SSH port\n            of 22 so this may need to be specified.\n        timeout : `int`, optional\n            An optional keyed argument to set timeout value in seconds. By\n            default this value is 30 seconds.\n        username : `string`\n            The username to use for SSH authentication.\n        password : `string`\n            The password used if using password authentication, or the\n            passphrase to use for unlocking keys that require it.\n        key_filename : `string`\n            a filename where a the private key to be used can be found.\n        allow_agent : `boolean`\n            Enables querying SSH agent (if found) for keys. The default value\n            is True.\n        hostkey_verify : `boolean`\n            Enables hostkey verification from ~/.ssh/known_hosts. The default\n            value is False.\n        look_for_keys : `boolean`\n            Enables looking in the usual locations for ssh keys\n            (e.g. ~/.ssh/id_*). The default value is True.\n        ssh_config : `string`\n            Enables parsing of an OpenSSH configuration file, if set to its\n            path, e.g. ~/.ssh/config or to True. If the value is True,\n            ncclient uses ~/.ssh/config. The default value is None.\n\n        Raises\n        ------\n\n        Exception\n            If the YAML file does not have correct connections section, or\n            establishing transport to ip:port is failed, ssh authentication is\n            failed, or other transport failures.\n\n        Note\n        ----\n\n        There is no return from this method. If something goes wrong, an\n        exception will be raised.\n\n\n        YAML Example::\n\n            devices:\n                asr22:\n                    type: 'ASR'\n                    tacacs:\n                        login_prompt: \"login:\"\n                        password_prompt: \"Password:\"\n                        username: \"admin\"\n                    passwords:\n                        tacacs: admin\n                        enable: admin\n                        line: admin\n                    connections:\n                        a:\n                            protocol: telnet\n                            ip: \"1.2.3.4\"\n                            port: 2004\n                        vty:\n                            protocol : telnet\n                            ip : \"2.3.4.5\"\n                        netconf:\n                            class: yang.connector.Netconf\n                            ip : \"2.3.4.5\"\n                            port: 830\n                            username: admin\n                            password: admin\n\n        Code Example::\n\n            >>> from pyats.topology import loader\n            >>> testbed = loader.load('/users/xxx/xxx/asr22.yaml')\n            >>> device = testbed.devices['asr22']\n            >>> device.connect(alias='nc', via='netconf')\n            >>>\n\n        Expected Results::\n\n            >>> device.nc.connected\n            True\n            >>> for iter in device.nc.server_capabilities:\n            ...     print(iter)\n            ...\n            urn:ietf:params:xml:ns:yang:smiv2:RFC-1215?module=RFC-1215\n            urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC?module=SNMPv2-TC\n            ...\n            >>>\n        '''\n\n        if self.connected:\n            return\n\n        logger.debug(self.session)\n        if not self.session.is_alive():\n            self._session = transport.SSHSession(self._device_handler)\n\n        # default values\n        defaults = {\n            'host': None,\n            'port': 830,\n            'timeout': 30,\n            'username': None,\n            'password': None,\n            'key_filename': None,\n            'allow_agent': False,\n            'hostkey_verify': False,\n            'look_for_keys': False,\n            'ssh_config': None,\n            }\n        defaults.update(self.connection_info)\n\n        # remove items\n        disregards = ['class', 'model', 'protocol', 'async_mode', 'raise_mode']\n        defaults = {k: v for k, v in defaults.items() if k not in disregards}\n\n        # rename ip -> host, cast to str type\n        if 'ip' in defaults:\n            defaults['host'] = str(defaults.pop('ip'))\n\n        # rename user -> username\n        if 'user' in defaults:\n            defaults['username'] = str(defaults.pop('user'))\n\n        defaults = {k: getattr(self, k, v) for k, v in defaults.items()}\n\n        try:\n            self.session.connect(**defaults)\n        except Exception:\n            if self.session.transport:\n                self.session.close()\n            raise\n\n        @atexit.register\n        def cleanup():\n            if self.session.transport:\n                self.session.close()", "response": "Connect to the given base connection and exchanges base connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(self, operation, *args, **kwargs):\n        '''execute\n\n        High-level api: The fact that most connection classes implement\n        execute method lead us to add this method here as well.\n        Supported operations are get, get_config, get_schema, dispatch,\n        edit_config, copy_config, validate, commit, discard_changes,\n        delete_config, lock, unlock, close_session, kill_session,\n        poweroff_machine and reboot_machine. Refer to ncclient document for\n        more details.\n        '''\n\n        # allow for operation string type\n        if type(operation) is str:\n            try:\n                cls = manager.OPERATIONS[operation]\n            except KeyError:\n                raise ValueError('No such operation \"%s\".\\n'\n                                 'Supported operations are: %s' %\n                                 (operation, list(manager.OPERATIONS.keys())))\n        else:\n            cls = operation\n\n        return super().execute(cls, *args, **kwargs)", "response": "Execute the specified operation on the ncclient connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request(self, msg, timeout=30):\n        '''request\n\n        High-level api: sends message through NetConf session and returns with\n        a reply. Exception is thrown out either the reply is in wrong\n        format or timout. Users can modify timeout value (in seconds) by\n        passing parameter timeout. Users may want to set a larger timeout when\n        making a large query.\n\n        Parameters\n        ----------\n\n        msg : `str`\n            Any message need to be sent out in XML format. The message can be\n            in wrong format if it is a negative test case. Because ncclient\n            tracks same message-id in both rpc and rpc-reply, missing\n            message-id in your rpc may cause exception when receiving\n            rpc-reply. Most other wrong format rpc's can be sent without\n            exception.\n        timeout : `int`, optional\n            An optional keyed argument to set timeout value in seconds. Its\n            default value is 30 seconds.\n\n        Returns\n        -------\n\n        str\n            The reply from the device in string. If something goes wrong, an\n            exception will be raised.\n\n\n        Raises\n        ------\n\n        Exception\n            If NetConf is not connected, or there is a timeout when receiving\n            reply.\n\n\n        Code Example::\n\n            >>> from pyats.topology import loader\n            >>> testbed = loader.load('/users/xxx/xxx/asr_20_22.yaml')\n            >>> device = testbed.devices['asr22']\n            >>> device.connect(alias='nc', via='netconf')\n            >>> netconf_request = \"\"\"\n            ...     <rpc message-id=\"101\"\n            ...      xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n            ...     <get>\n            ...     <filter>\n            ...     <native xmlns=\"http://cisco.com/ns/yang/ned/ios\">\n            ...     <version>\n            ...     </version>\n            ...     </native>\n            ...     </filter>\n            ...     </get>\n            ...     </rpc>\n            ...     \"\"\"\n            >>> reply = device.nc.request(netconf_request)\n            >>>\n\n        Expected Results::\n\n            >>> print(reply)\n            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <rpc-reply xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n            message-id=\"101\"><data>\n            <native xmlns=\"http://cisco.com/ns/yang/ned/ios\">\n            <version>16.3</version></native></data></rpc-reply>\n            >>>\n        '''\n\n        rpc = RawRPC(session = self.session,\n                     device_handler = self._device_handler,\n                     timeout = timeout,\n                     raise_mode = operations.rpc.RaiseMode.NONE)\n\n        # identify message-id\n        m = re.search(r'message-id=\"([A-Za-z0-9_\\-:# ]*)\"', msg)\n        if m:\n            rpc._id = m.group(1)\n            rpc._listener.register(rpc._id, rpc)\n            logger.debug('Found message-id=\"%s\" in your rpc, which is good.', rpc._id)\n        else:\n            logger.warning('Cannot find message-id in your rpc. You may '\n                           'expect an exception when receiving rpc-reply '\n                           'due to missing message-id.')\n\n        return rpc._request(msg).xml", "response": "Send a message through NetConf and returns reply."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _request(self, msg):\n        '''_request\n\n        Override method _request in class ncclient.operations.RPC, so it can\n        handle raw rpc requests in string format without validating your rpc\n        request syntax. When your rpc-reply is received, in most cases, it\n        simply returns rpc-reply again in string format, except one scenario:\n        If message-id is missing or message-id received does not match that in\n        rpc request, ncclient will raise an OperationError.\n        '''\n\n        logger.debug('Requesting %r' % self.__class__.__name__)\n        logger.info('Sending rpc...')\n        logger.info(msg)\n        time1 = time.time()\n        self._session.send(msg)\n        if not self._async:\n            logger.debug('Sync request, will wait for timeout=%r' %\n                         self._timeout)\n            self._event.wait(self._timeout)\n            if self._event.isSet():\n                time2 = time.time()\n                reply_time = \"{:.3f}\".format(time2 - time1)\n                logger.info('Receiving rpc-reply after {} sec...'.\n                            format(reply_time))\n                logger.info(self._reply)\n                return self._reply\n            else:\n                logger.info('Timeout. No rpc-reply received.')\n                raise TimeoutExpiredError('ncclient timed out while waiting '\n                                          'for an rpc-reply.')", "response": "This method is used to send a message to the ncclient and wait for the reply."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef random_str_uuid(string_length):\n    if not isinstance(string_length, int) or not 1 <= string_length <= 32:\n        msg = \"string_length must be type int where 1 <= string_length <= 32\"\n        raise ValueError(msg)\n    random = str(uuid.uuid4()).upper().replace('-', '')\n    return random[0:string_length]", "response": "Returns a random string of length string_length"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef random_name_filepath(path_full, length_random=5):\n    '''Take a filepath, add randome characters to its basename,\n    and return the new filepath\n\n    :param filename: either a filename or filepath\n    :param length_random: length of random string to be generated\n    '''\n    path_full_pre_extension, extension = os.path.splitext(path_full)\n    random_str = random_str_uuid(length_random)\n    return \"{}{}{}\".format(path_full_pre_extension, random_str, extension)", "response": "Take a filepath add randome characters to its basename and return the new filepath\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_filepathes_with_predicate(path_dir, predicate):\n    '''List all filepathes in a directory that begin with predicate\n\n    :param path_dir: the directory whose top-level contents you wish to list\n    :param predicate: the predicate you want to test the directory's\n        found files against\n    '''\n    if not os.path.isdir(path_dir):\n        raise ValueError(\"{} is not a directory\".format(path_dir))\n    contents = (os.path.join(path_dir, a) for a in os.listdir(path_dir))\n    files = (c for c in contents if os.path.isfile(c))\n    return [f for f in files if f.startswith(predicate)]", "response": "List all filepathes in a directory that begin with predicate\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef recursive_apply(inval, func):\n    '''Recursively apply a function to all levels of nested iterables\n\n    :param inval: the object to run the function on\n    :param func: the function that will be run on the inval\n    '''\n    if isinstance(inval, dict):\n        return {k: recursive_apply(v, func) for k, v in inval.items()}\n    elif isinstance(inval, list):\n        return [recursive_apply(v, func) for v in inval]\n    else:\n        return func(inval)", "response": "Recursively apply a function to all levels of nested iterables\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting one or more dump files to complete this dump.", "response": "def write(self, basename=None, write_separate_manifests=True):\n        \"\"\"Write one or more dump files to complete this dump.\n\n        Returns the number of dump/archive files written.\n        \"\"\"\n        self.check_files()\n        n = 0\n        for manifest in self.partition_dumps():\n            dumpbase = \"%s%05d\" % (basename, n)\n            dumpfile = \"%s.%s\" % (dumpbase, self.format)\n            if (write_separate_manifests):\n                manifest.write(basename=dumpbase + '.xml')\n            if (self.format == 'zip'):\n                self.write_zip(manifest.resources, dumpfile)\n            elif (self.format == 'warc'):\n                self.write_warc(manifest.resources, dumpfile)\n            else:\n                raise DumpError(\n                    \"Unknown dump format requested (%s)\" %\n                    (self.format))\n            n += 1\n        self.logger.info(\"Wrote %d dump files\" % (n))\n        return(n)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites a ZIP format dump file.", "response": "def write_zip(self, resources=None, dumpfile=None):\n        \"\"\"Write a ZIP format dump file.\n\n        Writes a ZIP file containing the resources in the iterable resources along with\n        a manifest file manifest.xml (written first). No checks on the size of files\n        or total size are performed, this is expected to have been done beforehand.\n        \"\"\"\n        compression = (ZIP_DEFLATED if self.compress else ZIP_STORED)\n        zf = ZipFile(\n            dumpfile,\n            mode=\"w\",\n            compression=compression,\n            allowZip64=True)\n        # Write resources first\n        rdm = ResourceDumpManifest(resources=resources)\n        real_path = {}\n        for resource in resources:\n            archive_path = self.archive_path(resource.path)\n            real_path[archive_path] = resource.path\n            resource.path = archive_path\n        zf.writestr('manifest.xml', rdm.as_xml())\n        # Add all files in the resources\n        for resource in resources:\n            zf.write(real_path[resource.path], arcname=resource.path)\n        zf.close()\n        zipsize = os.path.getsize(dumpfile)\n        self.logger.info(\n            \"Wrote ZIP file dump %s with size %d bytes\" %\n            (dumpfile, zipsize))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_warc(self, resources=None, dumpfile=None):\n        # Load library late as we want to be able to run rest of code\n        # without this installed\n        try:\n            from warc import WARCFile, WARCHeader, WARCRecord\n        except:\n            raise DumpError(\"Failed to load WARC library\")\n        wf = WARCFile(dumpfile, mode=\"w\", compress=self.compress)\n        # Add all files in the resources\n        for resource in resources:\n            wh = WARCHeader({})\n            wh.url = resource.uri\n            wh.ip_address = None\n            wh.date = resource.lastmod\n            wh.content_type = 'text/plain'\n            wh.result_code = 200\n            wh.checksum = 'aabbcc'\n            wh.location = self.archive_path(resource.path)\n            wf.write_record(WARCRecord(header=wh, payload=resource.path))\n        wf.close()\n        warcsize = os.path.getsize(dumpfile)\n        self.logging.info(\n            \"Wrote WARC file dump %s with size %d bytes\" %\n            (dumpfile, warcsize))", "response": "Write a WARC dump file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_files(self, set_length=True, check_length=True):\n        total_size = 0  # total size of all files in bytes\n        path_prefix = None\n        for resource in self.resources:\n            if (resource.path is None):\n                # explicit test because exception raised by getsize otherwise\n                # confusing\n                raise DumpError(\n                    \"No file path defined for resource %s\" %\n                    resource.uri)\n            if (path_prefix is None):\n                path_prefix = os.path.dirname(resource.path)\n            else:\n                path_prefix = os.path.commonprefix(\n                    [path_prefix, os.path.dirname(resource.path)])\n            size = os.path.getsize(resource.path)\n            if (resource.length is not None):\n                if (check_length and resource.length != size):\n                    raise DumpError(\"Size of resource %s is %d on disk, not %d as specified\" %\n                                    (resource.uri, size, resource.length))\n            elif (set_length):\n                resource.length = size\n            if (size > self.max_size):\n                raise DumpError(\n                    \"Size of file (%s, %d) exceeds maximum (%d) dump size\" %\n                    (resource.path, size, self.max_size))\n            total_size += size\n        self.path_prefix = path_prefix\n        self.total_size = total_size\n        self.logger.info(\n            \"Total size of files to include in dump %d bytes\" %\n            (total_size))\n        return True", "response": "Check all files in the dump file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef partition_dumps(self):\n        manifest = self.manifest_class()\n        manifest_size = 0\n        manifest_files = 0\n        for resource in self.resources:\n            manifest.add(resource)\n            manifest_size += resource.length\n            manifest_files += 1\n            if (manifest_size >= self.max_size or\n                    manifest_files >= self.max_files):\n                yield(manifest)\n                # Need to start a new manifest\n                manifest = self.manifest_class()\n                manifest_size = 0\n                manifest_files = 0\n        if (manifest_files > 0):\n            yield(manifest)", "response": "Yields the set of manifest objects that parition the dumps."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef archive_path(self, real_path):\n        if (not self.path_prefix):\n            return(real_path)\n        else:\n            return(os.path.relpath(real_path, self.path_prefix))", "response": "Return the archive path for the file with real_path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reset(self):\n        self.scene = cocos.scene.Scene()\n        self.z = 0\n\n        palette = config.settings['view']['palette']\n        #Player.palette = palette\n        r, g, b = palette['bg']\n        self.scene.add(cocos.layer.ColorLayer(r, g, b, 255), z=self.z)\n        self.z += 1\n        message_layer = MessageLayer()\n        self.scene.add(message_layer, z=self.z)\n        self.z += 1\n        self.world_layer = WorldLayer(self.mode_id, fn_show_message=message_layer.show_message)\n        self.scene.add(self.world_layer, z=self.z)\n        self.z += 1\n\n        self.director._set_scene(self.scene)\n\n        # Step once to refresh before `act`\n        self.step()\n\n        # TODO: Reset to `ones`?\n        return self.world_layer.get_state()", "response": "Attach a new engine to director and return the current state"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nact in the environment and return the state reward terminal info", "response": "def act(self, action):\n        \"\"\"\n        Take one action for one step\n        \"\"\"\n        # FIXME: Hack to change in return type\n        action = int(action)\n        assert isinstance(action, int)\n        assert action < self.actions_num, \"%r (%s) invalid\"%(action, type(action))\n\n        # Reset buttons\n        for k in self.world_layer.buttons:\n            self.world_layer.buttons[k] = 0\n\n        # Apply each button defined in action config\n        for key in self.world_layer.player.controls[action]:\n            if key in self.world_layer.buttons:\n                self.world_layer.buttons[key] = 1\n\n        # Act in the environment\n        self.step()\n\n        observation = self.world_layer.get_state()\n        reward = self.world_layer.player.get_reward()\n        terminal = self.world_layer.player.game_over\n        info = {}\n\n        return observation, reward, terminal, info"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef step(self):\n        self.director.window.switch_to()\n        self.director.window.dispatch_events()\n        self.director.window.dispatch_event('on_draw')\n        self.director.window.flip()\n\n        # Ticking before events caused glitches.\n        pyglet.clock.tick()", "response": "Step the engine one tick\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_latex(self, cmd_wo_infile, path_outfile):\n        '''Main runner for latex build\n\n        Should compile the object's Latex template using a list of latex\n        shell commands, along with an output file location. Runs the latex\n        shell command until the process's .aux file remains unchanged.\n\n        :return: STR template text that is ultimately rendered\n\n        :param cmd_wo_infile: a list of subprocess commands omitting the\n            input file (example: ['pdflatex'])\n        :param path_outfile: the full path to the desired final output file\n            Must contain the same file extension as files generated by\n            cmd_wo_infile, otherwise the process will fail\n        '''\n        # Generate path variables\n        text_template = self.get_text_template()\n        path_template_random = random_name_filepath(self.path_template)\n        path_template_dir = os.path.dirname(path_template_random)\n        path_template_random_no_ext = os.path.splitext(path_template_random)[0]\n        path_template_random_aux = path_template_random_no_ext + \".aux\"\n        ext_outfile = os.path.splitext(path_outfile)[-1]\n        path_outfile_initial = \"{}{}\".format(\n                path_template_random_no_ext, ext_outfile)\n\n        # Handle special case of MS Word\n        if cmd_wo_infile[0] == 'latex2rtf' and len(cmd_wo_infile) == 1:\n            cmd_docx = cmd_wo_infile + ['-o', path_outfile_initial]\n            # Need to run pdf2latex to generate aux file\n            cmd_wo_infile = ['pdflatex']\n        else:\n            cmd_docx = None\n\n        try:\n            # Write template variable to a temporary file\n            with open(path_template_random, 'w') as temp_file:\n                temp_file.write(text_template)\n            cmd = cmd_wo_infile + [path_template_random]\n            old_aux, new_aux = random_str_uuid(1), random_str_uuid(2)\n            while old_aux != new_aux:\n                # Run the relevant Latex command until old aux != new aux\n                stdout = check_output_cwd(cmd, path_template_dir)\n                LOGGER.debug('\\n'.join(stdout))\n                old_aux, new_aux = new_aux, read_file(path_template_random_aux)\n\n            # Handle special case of MS Word\n            if cmd_docx:\n                cmd_word = cmd_docx + [path_template_random]\n                stdout = check_output_cwd(cmd_word, path_template_dir)\n                LOGGER.debug('\\n'.join(stdout))\n\n            shutil.move(path_outfile_initial, path_outfile)\n            LOGGER.info(\"Built {} from {}\".format(\n                path_outfile, self.path_template))\n        except Exception:\n            LOGGER.exception(\"Failed during latex build\")\n        finally:\n            # Clean up all temporary files associated with the\n            # random file identifier for the process files\n            path_gen = list_filepathes_with_predicate(\n                    path_template_dir, path_template_random_no_ext)\n            for path_gen_file in path_gen:\n                os.remove(path_gen_file)\n        return text_template", "response": "Main runner for latex build\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef world_to_view(v):\n    return v.x * config.scale_x, v.y * config.scale_y", "response": "world coords to view coords ; v an eu. Vector2 returns ( float )"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the center of the skeleton.", "response": "def update_center(self, cshape_center):\n        \"\"\"cshape_center must be eu.Vector2\"\"\"\n        assert isinstance(cshape_center, eu.Vector2)\n\n        self.position = world_to_view(cshape_center)\n        self.cshape.center = cshape_center"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has(cls):\n    deps = {}\n    for i in dir(cls):\n        if i.startswith('__') and i.endswith('__'):\n            continue\n        val = getattr(cls, i, None)\n        if isinstance(val, Dependency):\n            deps[i] = val\n            if val.name is None:\n                val.name = i\n    cls.__injections__ = deps\n    return cls", "response": "Class decorator that declares dependencies"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninjecting dependencies and propagates dependency injector", "response": "def inject(self, inst, **renames):\n        \"\"\"Injects dependencies and propagates dependency injector\"\"\"\n        if renames:\n            di = self.clone(**renames)\n        else:\n            di = self\n        pro = di._provides\n        inst.__injections_source__ = di\n        deps = getattr(inst, '__injections__', None)\n        if deps:\n            for attr, dep in deps.items():\n                val = pro.get(dep.name)\n                if val is None:\n                    raise MissingDependencyError(dep.name)\n\n                if not isinstance(val, dep.type):\n                    raise TypeError(\"Wrong provider for {!r}\".format(val))\n                setattr(inst, attr, val)\n        meth = getattr(inst, '__injected__', None)\n        if meth is not None:\n            meth()\n        return inst"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npropagating dependencies for all provided instances", "response": "def interconnect_all(self):\n        \"\"\"Propagate dependencies for provided instances\"\"\"\n        for dep in topologically_sorted(self._provides):\n            if hasattr(dep, '__injections__') and not hasattr(dep, '__injections_source__'):\n                self.inject(dep)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _basis_polynomial_factory(cls, kind):\n        valid_kind = cls._validate(kind)\n        basis_polynomial = getattr(np.polynomial, valid_kind)\n        return basis_polynomial", "response": "Return a polynomial given some coefficients."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _validate(cls, kind):\n        if kind not in cls._valid_kinds:\n            mesg = \"'kind' must be one of {}, {}, {}, or {}.\"\n            raise ValueError(mesg.format(*cls._valid_kinds))\n        else:\n            return kind", "response": "Validate the kind argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a derivative of a certain kind of species orthogonal polynomial defined over a specific domain.", "response": "def derivatives_factory(cls, coef, domain, kind, **kwargs):\n        \"\"\"\n        Given some coefficients, return a the derivative of a certain kind of\n        orthogonal polynomial defined over a specific domain.\n\n        \"\"\"\n        basis_polynomial = cls._basis_polynomial_factory(kind)\n        return basis_polynomial(coef, domain).deriv()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a certain kind of orthogonal polynomial that is defined over a specific domain.", "response": "def functions_factory(cls, coef, domain, kind, **kwargs):\n        \"\"\"\n        Given some coefficients, return a certain kind of orthogonal polynomial\n        defined over a specific domain.\n\n        \"\"\"\n        basis_polynomial = cls._basis_polynomial_factory(kind)\n        return basis_polynomial(coef, domain)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef roots(cls, degree, domain, kind):\n        basis_coefs = cls._basis_monomial_coefs(degree)\n        basis_poly = cls.functions_factory(basis_coefs, domain, kind)\n        return basis_poly.roots()", "response": "Return optimal collocation nodes for some orthogonal polynomial."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_capability_list(self, capability_list=None):\n        if (hasattr(capability_list, 'uri')):\n            r = Resource(uri=capability_list.uri,\n                         capability=capability_list.capability_name)\n            if (capability_list.describedby is not None):\n                r.link_set(rel='describedby', href=capability_list.describedby)\n        else:\n            r = Resource(uri=capability_list,\n                         capability='capabilitylist')\n        self.add(r)", "response": "Adds either a CapabiltyList object specified in capability_list\n        or creates a Resource with the URI given in capability_list\n        and adds that to the Source Description\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nverifying OAuth token and set current user on request stack.", "response": "def verify_oauth_token_and_set_current_user():\n    \"\"\"Verify OAuth token and set current user on request stack.\n\n    This function should be used **only** on REST application.\n\n    .. code-block:: python\n\n        app.before_request(verify_oauth_token_and_set_current_user)\n    \"\"\"\n    for func in oauth2._before_request_funcs:\n        func()\n\n    if not hasattr(request, 'oauth') or not request.oauth:\n        scopes = []\n        try:\n            valid, req = oauth2.verify_request(scopes)\n        except ValueError:\n            abort(400, 'Error trying to decode a non urlencoded string.')\n\n        for func in oauth2._after_request_funcs:\n            valid, req = func(valid, req)\n\n        if valid:\n            request.oauth = req"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning list of tuples id scope.", "response": "def scope_choices(self, exclude_internal=True):\n        \"\"\"Return list of scope choices.\n\n        :param exclude_internal: Exclude internal scopes or not.\n            (Default: ``True``)\n        :returns: A list of tuples (id, scope).\n        \"\"\"\n        return [\n            (k, scope) for k, scope in sorted(self.scopes.items())\n            if not exclude_internal or not scope.is_internal\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_scope(self, scope):\n        if not isinstance(scope, Scope):\n            raise TypeError(\"Invalid scope type.\")\n        assert scope.id not in self.scopes\n        self.scopes[scope.id] = scope", "response": "Register a scope.\n\n        :param scope: A :class:`invenio_oauth2server.models.Scope` instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload actions from an entry point group.", "response": "def load_entry_point_group(self, entry_point_group):\n        \"\"\"Load actions from an entry point group.\n\n        :param entry_point_group: The entrypoint group name to load plugins.\n        \"\"\"\n        for ep in pkg_resources.iter_entry_points(group=entry_point_group):\n            self.register_scope(ep.load())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_obj_or_import_string(self, value):\n        imp = self.app.config.get(value)\n        if isinstance(imp, six.string_types):\n            return import_string(imp)\n        elif imp:\n            return imp", "response": "Load object or import string or return object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_app(self, app, entry_point_group='invenio_oauth2server.scopes',\n                 **kwargs):\n        \"\"\"Flask application initialization.\n\n        :param app: An instance of :class:`flask.Flask`.\n        :param entry_point_group: The entrypoint group name to load plugins.\n            (Default: ``'invenio_oauth2server.scopes'``)\n        \"\"\"\n        self.init_config(app)\n\n        state = _OAuth2ServerState(app, entry_point_group=entry_point_group)\n\n        app.extensions['invenio-oauth2server'] = state\n        return state", "response": "Initialize the Flask application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the Flask application.", "response": "def init_app(self, app, **kwargs):\n        \"\"\"Flask application initialization.\n\n        :param app: An instance of :class:`flask.Flask`.\n        \"\"\"\n        self.init_config(app)\n\n        allowed_urlencode_chars = app.config.get(\n            'OAUTH2SERVER_ALLOWED_URLENCODE_CHARACTERS')\n        if allowed_urlencode_chars:\n            InvenioOAuth2ServerREST.monkeypatch_oauthlib_urlencode_chars(\n                allowed_urlencode_chars)\n        app.before_request(verify_oauth_token_and_set_current_user)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef distance_to_tile(self, point, direction, length = 50):\n        assert isinstance(point, eu.Vector2)\n        assert isinstance(direction, int) or isinstance(direction, float)\n        assert isinstance(length, int) or isinstance(length, float)\n\n        # Recursive dead-reckoning to next tile\n        # Given `point`, look for where intersects with next boundary (`y % 10`) in `direction`\n        def search_grid(search, rad, distance = 0, depth = 10):\n            assert isinstance(search, eu.Vector2)\n            assert isinstance(rad, float)\n\n            if depth == 0:\n                return distance\n            depth -= 1\n\n            # Exit if outside window.\n            if abs(search.x) > self.width or abs(search.y) > self.height:\n                return distance\n\n            m = math.tan(rad) # Slope\n            sin = math.sin(rad)\n            cos = math.cos(rad)\n            #print(sin, cos)\n\n            top    = (cos > 0)\n            bottom = (cos < 0)\n            left   = (sin < 0)\n            right  = (sin > 0)\n\n            start  = eu.Vector2(search.x, search.y)\n            ends   = eu.Vector2()\n\n            # Helper function\n            # FIXME: Does MapLayer provide something better? Neighbours?\n            # Find next grid on given axis\n            def get_boundary(axis, increasing):\n                assert (isinstance(axis, str) or isinstance(axis, unicode)) and (axis == 'x' or axis == 'y')\n\n                if axis == 'x':\n                    tile = self.map_layer.tw\n                    position = search.x\n                elif axis == 'y':\n                    tile = self.map_layer.th\n                    position = search.y\n\n                # Set bound to next tile on axis\n                # Offset next search by one pixel into tile\n                bound = (position % tile)\n                if increasing:\n                    bound = tile - bound\n                    bound = position + bound\n                    offset = 1\n                else:\n                    bound = position - bound\n                    offset = -1\n\n                # Find intersect\n                if axis == 'x':\n                    intersect = ((bound - search.x) / m) + search.y\n                    return eu.Vector2(bound+offset, intersect)\n                elif axis == 'y':\n                    intersect = -m * (search.y - bound) + search.x\n                    return eu.Vector2(intersect, bound+offset)\n            # End Helper\n\n            if top or bottom:\n                ends.y = get_boundary('y', top)\n                ends.y.y = min(ends.y.y, self.height)\n\n            if left or right:\n                ends.x = get_boundary('x', right)\n                ends.x.x = min(ends.x.x, self.width)\n\n            # Get shortest collision between axis\n            lengths = eu.Vector2(0, 0)\n            if type(ends.x) == eu.Vector2:\n                diff = start - ends.x\n                lengths.x = math.sqrt(diff.dot(diff))\n            if type(ends.y) == eu.Vector2:\n                diff = start - ends.y\n                lengths.y = math.sqrt(diff.dot(diff))\n\n            end = None\n\n            # Find shortest boundary intersect\n            index_min = min(xrange(len(lengths)), key=lengths.__getitem__)\n\n            if lengths[index_min] > 0:\n                distance += lengths[index_min]\n                end = ends[index_min]\n\n            if end:\n                cell = self.map_layer.get_at_pixel(end.x, end.y)\n                if not cell or not cell.tile or not cell.tile.id > 0:\n                    # Recurse\n                    return search_grid(end, rad, distance, depth)\n\n            return distance\n        # End Helper\n\n        # Start at `point`, check tile under each pixel\n        return search_grid(point, direction)", "response": "Find nearest wall on a given bearing."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the score of a text by using the frequencies of ngrams. Example: >>> fitness = NgramScorer(english.unigrams) >>> fitness(\"ABC\") -4.3622319742618245 Args: frequency_map (dict): ngram to frequency mapping", "response": "def NgramScorer(frequency_map):\n    \"\"\"Compute the score of a text by using the frequencies of ngrams.\n\n    Example:\n        >>> fitness = NgramScorer(english.unigrams)\n        >>> fitness(\"ABC\")\n        -4.3622319742618245\n\n    Args:\n        frequency_map (dict): ngram to frequency mapping\n    \"\"\"\n    # Calculate the log probability\n    length = len(next(iter(frequency_map)))\n    # TODO: 0.01 is a magic number. Needs to be better than that.\n    floor = math.log10(0.01 / sum(frequency_map.values()))\n    ngrams = frequency.frequency_to_probability(frequency_map, decorator=math.log10)\n\n    def inner(text):\n        # I dont like this, it is only for the .upper() to work,\n        # But I feel as though this can be removed in later refactoring\n        text = ''.join(text)\n        text = remove(text.upper(), string.whitespace + string.punctuation)\n        return sum(ngrams.get(ngram, floor) for ngram in iterate_ngrams(text, length))\n\n    return inner"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_capability(self, capability=None, uri=None, name=None):\n        if (capability is not None):\n            name = capability.capability_name\n            if (capability.uri is not None):\n                uri = capability.uri\n        self.add(Resource(uri=uri, capability=name))", "response": "Specific add function for capabilities."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning information about the requested capability from this list. Will return None if there is no information about the requested capability.", "response": "def capability_info(self, name=None):\n        \"\"\"Return information about the requested capability from this list.\n\n        Will return None if there is no information about the requested capability.\n        \"\"\"\n        for r in self.resources:\n            if (r.capability == name):\n                return(r)\n        return(None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef emit_children(self, type='other'):\n        '''emit_children\n\n        High-level api: Emit a string presentation of the model.\n\n        Parameters\n        ----------\n\n        type : `str`\n            Type of model content required. Its value can be 'other', 'rpc', or\n            'notification'.\n\n        Returns\n        -------\n\n        str\n            A string presentation of the model that is very similar to the\n            output of 'pyang -f tree'\n        '''\n\n        def is_type(element, type):\n            type_info = element.get('type')\n            if type == type_info:\n                return True\n            if type == 'rpc' or type == 'notification':\n                return False\n            if type_info == 'rpc' or type_info == 'notification':\n                return False\n            return True\n\n        ret = []\n        for root in [i for i in self.tree.getchildren() if is_type(i, type)]:\n            for i in root.iter():\n                line = self.get_depth_str(i, type=type)\n                name_str = self.get_name_str(i)\n                room_consumed = len(name_str)\n                line += name_str\n                if i.get('type') == 'anyxml' or \\\n                   i.get('type') == 'anydata' or \\\n                   i.get('datatype') is not None or \\\n                   i.get('if-feature') is not None:\n                    line += self.get_datatype_str(i, room_consumed)\n                ret.append(line)\n        return ret", "response": "Emit the children of the tree."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_width(self, element):\n        '''get_width\n\n        High-level api: Calculate how much indent is needed for a node.\n\n        Parameters\n        ----------\n\n        element : `Element`\n            A node in model tree.\n\n        Returns\n        -------\n\n        int\n            Start position from the left margin.\n        '''\n\n        parent = element.getparent()\n        if parent in self.width:\n            return self.width[parent]\n        ret = 0\n        for sibling in parent.getchildren():\n            w = len(self.get_name_str(sibling))\n            if w > ret:\n                ret = w\n        self.width[parent] = math.ceil((ret + 3) / 3.0) * 3\n        return self.width[parent]", "response": "get_width High - level api : Calculate how much indent is needed for a node."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_name_str(self, element):\n        '''get_name_str\n\n        High-level api: Produce a string that represents the name of a node.\n\n        Parameters\n        ----------\n\n        element : `Element`\n            A node in model tree.\n\n        Returns\n        -------\n\n        str\n            A string that represents the name of a node.\n        '''\n\n        name = self.remove_model_prefix(self.url_to_prefix(element.tag))\n        flags = self.get_flags_str(element)\n        type_info = element.get('type')\n        if type_info is None:\n            pass\n        elif type_info == 'choice':\n            if element.get('mandatory') == 'true':\n                return flags + ' ({})'.format(name)\n            else:\n                return flags + ' ({})?'.format(name)\n        elif type_info == 'case':\n            return ':({})'.format(name)\n        elif type_info == 'container':\n            return flags + ' {}'.format(name)\n        elif type_info == 'leaf' or \\\n             type_info == 'anyxml' or \\\n             type_info == 'anydata':\n            if element.get('mandatory') == 'true':\n                return flags + ' {}'.format(name)\n            else:\n                return flags + ' {}?'.format(name)\n        elif type_info == 'list':\n            if element.get('key') is not None:\n                return flags + ' {}* [{}]'.format(name, element.get('key'))\n            else:\n                return flags + ' {}*'.format(name)\n        elif type_info == 'leaf-list':\n            return flags + ' {}*'.format(name)\n        else:\n            return flags + ' {}'.format(name)", "response": "get_name_str - Produce a string that represents the name of a node."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_datatype_str(self, element, length):\n        '''get_datatype_str\n\n        High-level api: Produce a string that indicates the data type of a node.\n\n        Parameters\n        ----------\n\n        element : `Element`\n            A node in model tree.\n\n        length : `int`\n            String length that has been consumed.\n\n        Returns\n        -------\n\n        str\n            A string that indicates the data type of a node.\n        '''\n\n        spaces = ' '*(self.get_width(element) - length)\n        type_info = element.get('type')\n        ret = ''\n        if type_info == 'anyxml' or type_info == 'anydata':\n            ret = spaces + '<{}>'.format(type_info)\n        elif element.get('datatype') is not None:\n            ret = spaces + element.get('datatype')\n        if element.get('if-feature') is not None:\n            return ret + ' {' + element.get('if-feature') + '}?'\n        else:\n            return ret", "response": "get_datatype_str returns a string that indicates the data type of a node in model tree."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prefix_to_url(self, id):\n        '''prefix_to_url\n\n        High-level api: Convert an identifier from `prefix:tagname` notation to\n        `{namespace}tagname` notation. If the identifier does not have a\n        prefix, it is assumed that the whole identifier is a tag name.\n\n        Parameters\n        ----------\n\n        id : `str`\n            Identifier in `prefix:tagname` notation.\n\n        Returns\n        -------\n\n        str\n            Identifier in `{namespace}tagname` notation.\n        '''\n\n        parts = id.split(':')\n        if len(parts) > 1:\n            return '{' + self.prefixes[parts[0]] + '}' + parts[1]\n        else:\n            return '{' + self.url + '}' + id", "response": "Convert an identifier from prefix to url."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef url_to_prefix(self, id):\n        '''url_to_prefix\n\n        High-level api: Convert an identifier from `{namespace}tagname` notation\n        to `prefix:tagname` notation. If the identifier does not have a\n        namespace, it is assumed that the whole identifier is a tag name.\n\n        Parameters\n        ----------\n\n        id : `str`\n            Identifier in `{namespace}tagname` notation.\n\n        Returns\n        -------\n\n        str\n            Identifier in `prefix:tagname` notation.\n        '''\n\n        ret = re.search('^{(.+)}(.+)$', id)\n        if ret:\n            return self.urls[ret.group(1)] + ':' + ret.group(2)\n        else:\n            return id", "response": "Convert an identifier from the tagname notation\n        to the prefix."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove model prefix from the tag name.", "response": "def remove_model_prefix(self, id):\n        '''remove_model_prefix\n\n        High-level api: If prefix is the model prefix, return tagname without\n        prefix. If prefix is not the model prefix, simply return the identifier\n        without modification.\n\n        Parameters\n        ----------\n\n        id : `str`\n            Identifier in `prefix:tagname` notation.\n\n        Returns\n        -------\n\n        str\n            Identifier in `prefix:tagname` notation if prefix is not the model\n            prefix. Or identifier in `tagname` notation if prefix is the model\n            prefix.\n        '''\n\n        reg_str = '^' + self.prefix + ':(.+)$'\n        ret = re.search(reg_str, id)\n        if ret:\n            return ret.group(1)\n        else:\n            return id"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts cxml tree to internal schema tree.", "response": "def convert_tree(self, element1, element2=None):\n        '''convert_tree\n\n        High-level api: Convert cxml tree to an internal schema tree. This\n        method is recursive.\n\n        Parameters\n        ----------\n\n        element1 : `Element`\n            The node to be converted.\n\n        element2 : `Element`\n            A new node being constructed.\n\n        Returns\n        -------\n\n        Element\n            This is element2 after convertion.\n        '''\n\n        if element2 is None:\n            attributes = deepcopy(element1.attrib)\n            tag = attributes['name']\n            del attributes['name']\n            element2 = etree.Element(tag, attributes)\n        for e1 in element1.findall('node'):\n            attributes = deepcopy(e1.attrib)\n            tag = self.prefix_to_url(attributes['name'])\n            del attributes['name']\n            e2 = etree.SubElement(element2, tag, attributes)\n            self.convert_tree(e1, e2)\n        return element2"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads all cxml files in the current directory.", "response": "def download_all(self, check_before_download=True):\n        '''download_all\n\n        High-level api: Convert cxml tree to an internal schema tree. This\n        method is recursive.\n\n        Parameters\n        ----------\n\n        check_before_download : `bool`\n            True if checking capabilities.txt file is required.\n\n        Returns\n        -------\n\n        None\n            Nothing returns.\n        '''\n\n        # check the content of self.yang_capabilities\n        if check_before_download:\n            if not self.need_download:\n                logger.info('Skip downloading as the content of {} matches ' \\\n                            'device hello message' \\\n                            .format(self.yang_capabilities))\n                return\n\n        # clean up folder self.dir_yang\n        for root, dirs, files in os.walk(self.dir_yang):\n            for f in files:\n                os.remove(os.path.join(root, f))\n\n        # download all\n        self.to_be_downloaded = set(self.device.models_loadable)\n        self.downloaded = set()\n        while self.to_be_downloaded:\n            self.download(self.to_be_downloaded.pop())\n\n        # write self.yang_capabilities\n        with open(self.yang_capabilities, 'w') as f:\n            f.write('\\n'.join(sorted(list(self.device.server_capabilities))))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef download(self, module):\n        '''download\n\n        High-level api: Download a module schema.\n\n        Parameters\n        ----------\n\n        module : `str`\n            Module name that will be downloaded.\n\n        Returns\n        -------\n\n        None\n            Nothing returns.\n        '''\n\n        import_r = '^[ |\\t]+import[ |\\t]+([a-zA-Z0-9-]+)[ |\\t]+[;{][ |\\t]*$'\n        include_r = '^[ |\\t]+include[ |\\t]+([a-zA-Z0-9-]+)[ |\\t]*[;{][ |\\t]*$'\n\n        logger.debug('Downloading {}.yang...'.format(module))\n        try:\n            from .device import ModelDevice\n            reply = super(ModelDevice, self.device) \\\n                    .execute(operations.retrieve.GetSchema, module)\n        except operations.rpc.RPCError:\n            logger.warning(\"Module or submodule '{}' cannot be downloaded\" \\\n                           .format(module))\n            return\n        if reply.ok:\n            fname = self.dir_yang + '/' + module + '.yang'\n            with open(fname, 'w') as f:\n                f.write(reply.data)\n            self.downloaded.add(module)\n            imports = set()\n            includes = set()\n            for line in reply.data.splitlines():\n                match = re.search(import_r, line)\n                if match:\n                    imports.add(match.group(1).strip())\n                    continue\n                match = re.search(include_r, line)\n                if match:\n                    includes.add(match.group(1).strip())\n                    continue\n            s = (imports | includes) - self.downloaded - self.to_be_downloaded\n            if s:\n                logger.info('{} requires submodules: {}' \\\n                            .format(module, ', '.join(s)))\n                self.to_be_downloaded.update(s)\n        else:\n            logger.warning(\"module or submodule '{}' cannot be downloaded:\\n{}\" \\\n                           .format(module, reply._raw))", "response": "Download a module schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_dependencies(self):\n        '''build_dependencies\n\n        High-level api: Briefly compile all yang files and find out dependency\n        infomation of all modules.\n\n        Returns\n        -------\n\n        None\n            Nothing returns.\n        '''\n\n        cmd_list = ['pyang', '--plugindir', self.pyang_plugins]\n        cmd_list += ['-p', self.dir_yang]\n        cmd_list += ['-f', 'pyimport']\n        cmd_list += [self.dir_yang + '/*.yang']\n        logger.info('Building dependencies: {}'.format(' '.join(cmd_list)))\n        p = Popen(' '.join(cmd_list), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        logger.info('pyang return code is {}'.format(p.returncode))\n        logger.debug(stderr.decode())\n        parser = etree.XMLParser(remove_blank_text=True)\n        self.dependencies = etree.XML(stdout.decode(), parser)", "response": "Build the dependency XML file for this module."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_dependencies(self, module):\n        '''get_dependencies\n\n        High-level api: Get dependency infomationa of a module.\n\n        Parameters\n        ----------\n\n        module : `str`\n            Module name that is inquired about.\n\n        Returns\n        -------\n\n        tuple\n            A tuple with two elements: a set of imports and a set of depends.\n        '''\n\n        imports = set()\n        for m in list(filter(lambda i: i.get('id') == module,\n                             self.dependencies.findall('./module'))):\n            imports.update(set(i.get('module')\n                               for i in m.findall('./imports/import')))\n        depends = set()\n        for m in self.dependencies.getchildren():\n            if list(filter(lambda i: i.get('module') == module,\n                           m.findall('./imports/import'))):\n                depends.add(m.get('id'))\n            if list(filter(lambda i: i.get('module') == module,\n                           m.findall('./includes/include'))):\n                depends.add(m.get('id'))\n        return (imports, depends)", "response": "get_dependencies\n            High - level api : Get dependency infomationa of a module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compile(self, module):\n        '''compile\n\n        High-level api: Compile a module.\n\n        Parameters\n        ----------\n\n        module : `str`\n            Module name that is inquired about.\n\n        Returns\n        -------\n\n        Model\n            A Model object.\n        '''\n\n        imports, depends = self.get_dependencies(module)\n        file_list = list(imports | depends) + [module]\n        cmd_list = ['pyang', '-f', 'cxml', '--plugindir', self.pyang_plugins]\n        cmd_list += ['-p', self.dir_yang]\n        cmd_list += [self.dir_yang + '/' + f + '.yang' for f in file_list]\n        logger.info('Compiling {}.yang: {}'.format(module,\n                                                   ' '.join(cmd_list)))\n        p = Popen(' '.join(cmd_list), shell=True, stdout=PIPE, stderr=PIPE)\n        stdout, stderr = p.communicate()\n        logger.info('pyang return code is {}'.format(p.returncode))\n        if p.returncode == 0:\n            logger.debug(stderr.decode())\n        else:\n            logger.error(stderr.decode())\n        parser = etree.XMLParser(remove_blank_text=True)\n        tree = etree.XML(stdout.decode(), parser)\n        return Model(tree)", "response": "Compile a module into a Model object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_name_str(self, element):\n        '''get_name_str\n\n        High-level api: Produce a string that represents the name of a node.\n\n        Parameters\n        ----------\n\n        element : `Element`\n            A node in model tree.\n\n        Returns\n        -------\n\n        str\n            A string that represents the name of a node.\n        '''\n\n        if element.get('diff') == 'added':\n            return self.model2.get_name_str(element)\n        else:\n            return self.model1.get_name_str(element)", "response": "get_name_str - Produce a string that represents the name of a node in model tree."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compare_nodes(node1, node2, ret):\n        '''compare_nodes\n\n        High-level api: Compare node1 and node2 and put the result in ret.\n\n        Parameters\n        ----------\n\n        node1 : `Element`\n            A node in a model tree.\n\n        node2 : `Element`\n            A node in another model tree.\n\n        ret : `Element`\n            A node in self.tree.\n\n        Returns\n        -------\n\n        None\n            Nothing returns.\n        '''\n\n        for child in node2.getchildren():\n            peer = ModelDiff.get_peer(child.tag, node1)\n            if peer is None:\n                ModelDiff.copy_subtree(ret, child, 'added')\n            else:\n                if ModelDiff.node_equal(peer, child):\n                    continue\n                else:\n                    if child.attrib['type'] in ['leaf-list', 'leaf']:\n                        ModelDiff.copy_node(ret, child, 'modified')\n                    else:\n                        ret_child = ModelDiff.copy_node(ret, child, '')\n                        ModelDiff.compare_nodes(peer, child, ret_child)\n        for child in node1.getchildren():\n            peer = ModelDiff.get_peer(child.tag, node2)\n            if peer is None:\n                ModelDiff.copy_subtree(ret, child, 'deleted')", "response": "Compare two nodes and put the result in ret."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef copy_subtree(ret, element, msg):\n        '''copy_subtree\n\n        High-level api: Copy element as a subtree and put it as a child of ret.\n\n        Parameters\n        ----------\n\n        element : `Element`\n            A node in a model tree.\n\n        msg : `str`\n            Message to be added.\n\n        ret : `Element`\n            A node in self.tree.\n\n        Returns\n        -------\n\n        None\n            Nothing returns.\n        '''\n\n        sub_element = ModelDiff.process_attrib(deepcopy(element), msg)\n        ret.append(sub_element)\n        return sub_element", "response": "Copy element as a subtree and put it as a child of ret."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_node(ret, element, msg):\n        '''copy_node\n\n        High-level api: Copy element as a node without its children and put it\n        as a child of ret.\n\n        Parameters\n        ----------\n\n        element : `Element`\n            A node in a model tree.\n\n        msg : `str`\n            Message to be added.\n\n        ret : `Element`\n            A node in self.tree.\n\n        Returns\n        -------\n\n        None\n            Nothing returns.\n        '''\n        sub_element = etree.SubElement(ret, element.tag, attrib=element.attrib)\n        ModelDiff.process_attrib(sub_element, msg)\n        return sub_element", "response": "Copy element as a node without its children and put it\n            as a child of ret."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process_attrib(element, msg):\n        '''process_attrib\n\n        High-level api: Delete four attributes from an ElementTree node if they\n        exist: operation, insert, value and key. Then a new attribute 'diff' is\n        added.\n\n        Parameters\n        ----------\n\n        element : `Element`\n            A node needs to be looked at.\n\n        msg : `str`\n            Message to be added in attribute 'diff'.\n\n        Returns\n        -------\n\n        Element\n            Argument 'element' is returned after processing.\n        '''\n\n        attrib_required = ['type', 'access', 'mandatory']\n        for node in element.iter():\n            for attrib in node.attrib.keys():\n                if attrib not in attrib_required:\n                    del node.attrib[attrib]\n            if msg:\n                node.attrib['diff'] = msg\n        return element", "response": "This function deletes four attributes from an ElementTree node if they exist and insert value and key. Then a new attribute is added."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef node_equal(node1, node2):\n        '''node_equal\n\n        High-level api: Evaluate whether two nodes are equal.\n\n        Parameters\n        ----------\n\n        node1 : `Element`\n            A node in a model tree.\n\n        node2 : `Element`\n            A node in another model tree.\n\n        Returns\n        -------\n\n        bool\n            True if node1 and node2 are equal.\n        '''\n\n        if ModelDiff.node_less(node1, node2) and \\\n           ModelDiff.node_less(node2, node1):\n            return True\n        else:\n            return False", "response": "Evaluate whether two nodes are equal."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef node_less(node1, node2):\n        '''node_less\n\n        Low-level api: Return True if all descendants of node1 exist in node2.\n        Otherwise False. This is a recursive method.\n\n        Parameters\n        ----------\n\n        node1 : `Element`\n            A node in a model tree.\n\n        node2 : `Element`\n            A node in another model tree.\n\n        Returns\n        -------\n\n        bool\n            True if all descendants of node1 exist in node2, otherwise False.\n        '''\n\n        for x in ['tag', 'text', 'tail']:\n            if node1.__getattribute__(x) != node2.__getattribute__(x):\n                return False\n        for a in node1.attrib:\n            if a not in node2.attrib or \\\n               node1.attrib[a] != node2.attrib[a]:\n                return False\n        for child in node1.getchildren():\n            peers = node2.findall(child.tag)\n            if len(peers) < 1:\n                return False\n            elif len(peers) > 1:\n                raise ModelError(\"not unique peer '{}'\".format(child.tag))\n            else:\n                if not ModelDiff.node_less(child, peers[0]):\n                    return False\n        return True", "response": "Return True if all descendants of node1 exist in node2 otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ui_main(fmt_table, node_dict):\n    cmd_funct = {\"quit\": False,\n                 \"run\": node_cmd,\n                 \"stop\": node_cmd,\n                 \"connect\": node_cmd,\n                 \"details\": node_cmd,\n                 \"update\": True}\n    ui_print(\"\\033[?25l\")  # cursor off\n    print(\"{}\\n\".format(fmt_table))\n    sys.stdout.flush()\n    # refresh_main values:\n    #   None = loop main-cmd, True = refresh-list, False = exit-program\n    refresh_main = None\n    while refresh_main is None:\n        cmd_name = get_user_cmd(node_dict)\n        if callable(cmd_funct[cmd_name]):\n            refresh_main = cmd_funct[cmd_name](cmd_name, node_dict)\n        else:\n            refresh_main = cmd_funct[cmd_name]\n    if cmd_name != \"connect\" and refresh_main:\n        ui_clear(len(node_dict) + 2)\n    return refresh_main", "response": "Create the base UI in command mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets main command selection.", "response": "def get_user_cmd(node_dict):\n    \"\"\"Get main command selection.\"\"\"\n    key_lu = {\"q\": [\"quit\", True], \"r\": [\"run\", True],\n              \"s\": [\"stop\", True], \"u\": [\"update\", True],\n              \"c\": [\"connect\", True], \"d\": [\"details\", True]}\n    ui_cmd_bar()\n    cmd_valid = False\n    input_flush()\n    with term.cbreak():\n        while not cmd_valid:\n            val = input_by_key()\n            cmd_name, cmd_valid = key_lu.get(val.lower(), [\"invalid\", False])\n            if not cmd_valid:\n                ui_print(\" - {0}Invalid Entry{1}\".format(C_ERR, C_NORM))\n                sleep(0.5)\n                ui_cmd_bar()\n    return cmd_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef node_cmd(cmd_name, node_dict):\n    sc = {\"run\": cmd_startstop, \"stop\": cmd_startstop,\n          \"connect\": cmd_connect, \"details\": cmd_details}\n    node_num = node_selection(cmd_name, len(node_dict))\n    refresh_main = None\n    if node_num != 0:\n        (node_valid, node_info) = node_validate(node_dict, node_num, cmd_name)\n        if node_valid:\n            sub_cmd = sc[cmd_name]  # get sub-command\n            refresh_main = sub_cmd(node_dict[node_num], cmd_name, node_info)\n        else:  # invalid target\n            ui_print_suffix(node_info, C_ERR)\n            sleep(1.5)\n    else:  # '0' entered - exit command but not program\n        ui_print(\" - Exit Command\")\n        sleep(0.5)\n    return refresh_main", "response": "Process commands that target specific nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef node_selection(cmd_name, node_qty):\n    cmd_disp = cmd_name.upper()\n    cmd_title = (\"\\r{1}{0} NODE{2} - Enter {3}#{2}\"\n                 \" ({4}0 = Exit Command{2}): \".\n                 format(cmd_disp, C_TI, C_NORM, C_WARN, C_HEAD2))\n    ui_cmd_title(cmd_title)\n    selection_valid = False\n    input_flush()\n    with term.cbreak():\n        while not selection_valid:\n            node_num = input_by_key()\n            try:\n                node_num = int(node_num)\n            except ValueError:\n                node_num = 99999\n            if node_num <= node_qty:\n                selection_valid = True\n            else:\n                ui_print_suffix(\"Invalid Entry\", C_ERR)\n                sleep(0.5)\n                ui_cmd_title(cmd_title)\n    return node_num", "response": "Determine Node via alternate input method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate that command can be performed on target node.", "response": "def node_validate(node_dict, node_num, cmd_name):\n    \"\"\"Validate that command can be performed on target node.\"\"\"\n    # cmd: [required-state, action-to-displayed, error-statement]\n    req_lu = {\"run\": [\"stopped\", \"Already Running\"],\n              \"stop\": [\"running\", \"Already Stopped\"],\n              \"connect\": [\"running\", \"Can't Connect, Node Not Running\"],\n              \"details\": [node_dict[node_num].state, \"\"]}\n    tm = {True: (\"Node {1}{2}{0} ({5}{3}{0} on {1}{4}{0})\".\n                 format(C_NORM, C_WARN, node_num,\n                        node_dict[node_num].name,\n                        node_dict[node_num].cloud_disp, C_TI)),\n          False: req_lu[cmd_name][1]}\n    node_valid = bool(req_lu[cmd_name][0] == node_dict[node_num].state)\n    node_info = tm[node_valid]\n    return node_valid, node_info"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconfirm command and execute it.", "response": "def cmd_startstop(node, cmd_name, node_info):\n    \"\"\"Confirm command and execute it.\"\"\"\n    cmd_lu = {\"run\": [\"ex_start_node\", \"wait_until_running\", \"RUNNING\"],\n              \"stop\": [\"ex_stop_node\", \"\", \"STOPPING\"]}\n    # specific delay & message {provider: {command: [delay, message]}}\n    cld_lu = {\"azure\": {\"stop\": [6, \"Initiated\"]},\n              \"aws\": {\"stop\": [6, \"Initiated\"]}}\n    conf_mess = (\"\\r{0}{1}{2} {3} - Confirm [y/N]: \".\n                 format(C_STAT[cmd_name.upper()], cmd_name.upper(), C_NORM,\n                        node_info))\n    cmd_result = None\n    if input_yn(conf_mess):\n        exec_mess = (\"\\r{0}{1}{2} {3}:  \".\n                     format(C_STAT[cmd_name.upper()], cmd_lu[cmd_name][2],\n                            C_NORM, node_info))\n        ui_erase_ln()\n        ui_print(exec_mess)\n        busy_obj = busy_disp_on()  # busy indicator ON\n        node_drv = getattr(node, \"driver\")\n        main_cmd = getattr(node_drv, cmd_lu[cmd_name][0])\n        response = main_cmd(node)  # noqa\n        cmd_wait = cmd_lu[cmd_name][1]\n        if cmd_wait:\n            seccmd = getattr(node_drv, cmd_wait)\n            response = seccmd([node])  # noqa\n        delay, cmd_end = cld_lu.get(node.cloud,\n                                    {}).get(cmd_name, [0, \"Successful\"])\n        sleep(delay)\n        busy_disp_off(busy_obj)  # busy indicator OFF\n        ui_print(\"\\033[D\")  # remove extra space\n        cmd_result = True\n        ui_print_suffix(\"{0} {1}\".format(cmd_name.title(), cmd_end), C_GOOD)\n        sleep(1.5)\n    else:\n        ui_print_suffix(\"Command Aborted\")\n        sleep(0.75)\n    return cmd_result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining ssh - user and ssh - key for node.", "response": "def ssh_get_info(node):\n    \"\"\"Determine ssh-user and ssh-key for node.\"\"\"\n    ssh_key = \"\"\n    if node.cloud == \"aws\":\n        raw_key = node.extra['key_name']\n        ssh_key = \"-i {0}{1}.pem \".format(CONFIG_DIR, raw_key)\n        ssh_user = ssh_calc_aws(node)\n    elif node.cloud == \"azure\":\n        ssh_user = node.extra['properties']['osProfile']['adminUsername']\n    elif node.cloud == \"gcp\":\n        items = node.extra['metadata'].get('items', [{}])\n        keyname = items['key' == 'ssh-keys'].get('value', \"\")\n        pos = keyname.find(\":\")\n        ssh_user = keyname[0:pos]\n    elif node.cloud == \"alicloud\":\n        ssh_user = \"\"\n    return ssh_user, ssh_key"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ssh_calc_aws(node):\n    userlu = {\"ubunt\": \"ubuntu\", \"debia\": \"admin\", \"fedor\": \"root\",\n              \"cento\": \"centos\", \"openb\": \"root\"}\n    image_name = node.driver.get_image(node.extra['image_id']).name\n    if not image_name:\n        image_name = node.name\n    usertemp = ['name'] + [value for key, value in list(userlu.items())\n                           if key in image_name.lower()]\n    usertemp = dict(zip(usertemp[::2], usertemp[1::2]))\n    username = usertemp.get('name', 'ec2-user')\n    return username", "response": "Calculate default ssh - user based on image - if of AWS instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef input_flush():\n    try:\n        import sys, termios  # noqa\n        termios.tcflush(sys.stdin, termios.TCIFLUSH)\n    except ImportError:\n        import msvcrt\n        while msvcrt.kbhit():\n            msvcrt.getch()", "response": "Flush the input buffer on posix and windows."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef input_by_key():\n    usr_inp = ''\n    input_valid = True\n    input_flush()\n    with term.cbreak():\n        while input_valid:\n            ui_print(\"\\033[?25h\")  # cursor on\n            key_raw = term.inkey()\n            if key_raw.name == \"KEY_ENTER\":\n                input_valid = False\n                ui_print(\"\\033[?25l\")  # cursor off\n                break\n            if key_raw.name == 'KEY_DELETE':\n                ui_del_char(len(usr_inp))\n                usr_inp = usr_inp[:-1]\n            if not key_raw.is_sequence:\n                usr_inp += key_raw\n                ui_print(key_raw)\n    if not usr_inp:\n        ui_print(\"\\033[D\")\n    return usr_inp", "response": "Get user input using term. ichey to prevent / n printing at end."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef input_yn(conf_mess):\n    ui_erase_ln()\n    ui_print(conf_mess)\n    with term.cbreak():\n        input_flush()\n        val = input_by_key()\n    return bool(val.lower() == 'y')", "response": "Print Confirmation Message and Get YN response from user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_user(email, password, *args, **kwargs):\n    user = datastore.find_user(email=email)\n    if user and user.active and verify_password(password, user.password):\n        return user", "response": "Get user for grant type password."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_token(access_token=None, refresh_token=None):\n    if access_token:\n        t = Token.query.filter_by(access_token=access_token).first()\n        if t and t.is_personal and t.user.active:\n            t.expires = datetime.utcnow() + timedelta(\n                seconds=int(current_app.config.get(\n                    'OAUTH2_PROVIDER_TOKEN_EXPIRES_IN'\n                ))\n            )\n    elif refresh_token:\n        t = Token.query.join(Token.client).filter(\n            Token.refresh_token == refresh_token,\n            Token.is_personal == False,  # noqa\n            Client.is_confidential == True,\n        ).first()\n    else:\n        return None\n    return t if t and t.user.active else None", "response": "Load an access token."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading the client. Needed for grant_type client_credentials. Add support for OAuth client_credentials access type, with user inactivation support. :param client_id: The client ID. :returns: The client instance or ``None``.", "response": "def get_client(client_id):\n    \"\"\"Load the client.\n\n    Needed for grant_type client_credentials.\n\n    Add support for OAuth client_credentials access type, with user\n    inactivation support.\n\n    :param client_id: The client ID.\n    :returns: The client instance or ``None``.\n    \"\"\"\n    client = Client.query.get(client_id)\n    if client and client.user.active:\n        return client"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving the token to the database.", "response": "def save_token(token, request, *args, **kwargs):\n    \"\"\"Token persistence.\n\n    :param token: A dictionary with the token data.\n    :param request: The request instance.\n    :returns: A :class:`invenio_oauth2server.models.Token` instance.\n    \"\"\"\n    # Exclude the personal access tokens which doesn't expire.\n    user = request.user if request.user else current_user\n\n    # Add user information in token endpoint response.\n    # Currently, this is the only way to have the access to the user of the\n    # token as well as the token response.\n    token.update(user={'id': user.get_id()})\n\n    # Add email if scope granted.\n    if email_scope.id in token.scopes:\n        token['user'].update(\n            email=user.email,\n            email_verified=user.confirmed_at is not None,\n        )\n\n    tokens = Token.query.filter_by(\n        client_id=request.client.client_id,\n        user_id=user.id,\n        is_personal=False,\n    )\n\n    # make sure that every client has only one token connected to a user\n    if tokens:\n        for tk in tokens:\n            db.session.delete(tk)\n        db.session.commit()\n\n    expires_in = token.get('expires_in')\n    expires = datetime.utcnow() + timedelta(seconds=int(expires_in))\n\n    tok = Token(\n        access_token=token['access_token'],\n        refresh_token=token.get('refresh_token'),\n        token_type=token['token_type'],\n        _scopes=token['scope'],\n        expires=expires,\n        client_id=request.client.client_id,\n        user_id=user.id,\n        is_personal=False,\n    )\n    db.session.add(tok)\n    db.session.commit()\n    return tok"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef login_oauth2_user(valid, oauth):\n    if valid:\n        oauth.user.login_via_oauth2 = True\n        _request_ctx_stack.top.user = oauth.user\n        identity_changed.send(current_app._get_current_object(),\n                              identity=Identity(oauth.user.id))\n    return valid, oauth", "response": "Log in a user after having been verified."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_body(self, environ=None):\n        body = dict(\n            status=self.code,\n            message=self.description,\n        )\n\n        errors = self.get_errors()\n        if self.errors:\n            body['errors'] = errors\n\n        return json.dumps(body)", "response": "Get the request body."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef jwt_verify_token(headers):\n    # Get the token from headers\n    token = headers.get(\n        current_app.config['OAUTH2SERVER_JWT_AUTH_HEADER']\n    )\n    if token is None:\n        raise JWTInvalidHeaderError\n    # Get authentication type\n    authentication_type = \\\n        current_app.config['OAUTH2SERVER_JWT_AUTH_HEADER_TYPE']\n    # Check if the type should be checked\n    if authentication_type is not None:\n        # Get the prefix and the token\n        prefix, token = token.split()\n        # Check if the type matches\n        if prefix != authentication_type:\n            raise JWTInvalidHeaderError\n\n    try:\n        # Get the token data\n        decode = jwt_decode_token(token)\n        # Check the integrity of the user\n        if current_user.get_id() != decode.get('sub'):\n            raise JWTInvalidIssuer\n        return decode\n    except _JWTDecodeError as exc:\n        raise_from(JWTDecodeError(), exc)\n    except _JWTExpiredToken as exc:\n        raise_from(JWTExpiredToken(), exc)", "response": "Verify the JWT token."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles uncaught OAuth errors.", "response": "def error_handler(f):\n    \"\"\"Handle uncaught OAuth errors.\"\"\"\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        try:\n            return f(*args, **kwargs)\n        except OAuth2Error as e:\n            # Only FatalClientError are handled by Flask-OAuthlib (as these\n            # errors should not be redirect back to the client - see\n            # http://tools.ietf.org/html/rfc6749#section-4.2.2.1)\n            if hasattr(e, 'redirect_uri'):\n                return redirect(e.in_uri(e.redirect_uri))\n            else:\n                return redirect(e.in_uri(oauth2.error_uri))\n    return decorated"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nviews for rendering authorization request.", "response": "def authorize(*args, **kwargs):\n    \"\"\"View for rendering authorization request.\"\"\"\n    if request.method == 'GET':\n        client = Client.query.filter_by(\n            client_id=kwargs.get('client_id')\n        ).first()\n\n        if not client:\n            abort(404)\n\n        scopes = current_oauth2server.scopes\n        ctx = dict(\n            client=client,\n            oauth_request=kwargs.get('request'),\n            scopes=[scopes[x] for x in kwargs.get('scopes', [])],\n        )\n        return render_template('invenio_oauth2server/authorize.html', **ctx)\n\n    confirm = request.form.get('confirm', 'no')\n    return confirm == 'yes'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef errors():\n    from oauthlib.oauth2.rfc6749.errors import raise_from_error\n    try:\n        error = None\n        raise_from_error(request.values.get('error'), params=dict())\n    except OAuth2Error as raised:\n        error = raised\n    return render_template('invenio_oauth2server/errors.html', error=error)", "response": "Error view in case of invalid oauth requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntests to verify that you have been authenticated.", "response": "def info():\n    \"\"\"Test to verify that you have been authenticated.\"\"\"\n    if current_app.testing or current_app.debug:\n        return jsonify(dict(\n            user=request.oauth.user.id,\n            client=request.oauth.client.client_id,\n            scopes=list(request.oauth.scopes)\n        ))\n    else:\n        abort(404)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef crack(ciphertext, *fitness_functions, key_period=None, max_key_period=30):\n    if max_key_period <= 0 or (key_period is not None and key_period <= 0):\n        raise ValueError(\"Period values must be positive integers\")\n\n    original_text = ciphertext\n    # Make the assumption that non alphabet characters have not been encrypted\n    # TODO: This is fairly poor code. Once languages are a thing, there should be some nice abstractions for this stuff\n    ciphertext = remove(ciphertext, string.punctuation + string.whitespace + string.digits)\n    periods = [int(key_period)] if key_period else key_periods(ciphertext, max_key_period)\n\n    # Decrypt for every valid period\n    period_decryptions = []\n    for period in periods:\n        if period >= len(ciphertext):\n            continue\n\n        # Collect the best decryptions for every column\n        column_decryptions = [shift.crack(col, *fitness_functions)[0] for col in split_columns(ciphertext, period)]\n        key = _build_key(decrypt.key for decrypt in column_decryptions)\n\n        plaintext = decrypt(key, original_text)\n        period_decryptions.append(Decryption(plaintext, key, score(plaintext, *fitness_functions)))\n\n    return sorted(period_decryptions, reverse=True)", "response": "Break a ciphertext into many Caesar cipher sets and return a list of decryptions for each key_period."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrank all key periods for a given ciphertext up to and including max_key_period.", "response": "def key_periods(ciphertext, max_key_period):\n    \"\"\"Rank all key periods for ``ciphertext`` up to and including ``max_key_period``\n\n    Example:\n        >>> key_periods(ciphertext, 30)\n        [2, 4, 8, 3, ...]\n\n    Args:\n        ciphertext (str): The text to analyze\n        max_key_period (int): The maximum period the key could be\n\n    Returns:\n        Sorted list of keys\n\n    Raises:\n        ValueError: If max_key_period is less than or equal to 0\n    \"\"\"\n    if max_key_period <= 0:\n        raise ValueError(\"max_key_period must be a positive integer\")\n\n    key_scores = []\n    for period in range(1, min(max_key_period, len(ciphertext)) + 1):\n        score = abs(ENGLISH_IC - index_of_coincidence(*split_columns(ciphertext, period)))\n        key_scores.append((period, score))\n\n    return [p[0] for p in sorted(key_scores, key=lambda x: x[1])]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decrypt(key, ciphertext):\n    index = 0\n    decrypted = \"\"\n    for char in ciphertext:\n        if char in string.punctuation + string.whitespace + string.digits:\n            decrypted += char\n            continue  # Not part of the decryption\n\n        # Rotate character by the alphabet position of the letter in the key\n        alphabet = string.ascii_uppercase if key[index].isupper() else string.ascii_lowercase\n        decrypted += ''.join(shift.decrypt(int(alphabet.index(key[index])), char))\n        index = (index + 1) % len(key)\n\n    return decrypted", "response": "Decrypts the ciphertext using the key."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef explore_uri(self, explorer_resource, show_back=True):\n        uri = explorer_resource.uri\n        caps = explorer_resource.acceptable_capabilities\n        checks = explorer_resource.checks\n        print(\"Reading %s\" % (uri))\n        options = {}\n        capability = None\n        try:\n            if (caps == 'resource'):\n                # Not expecting a capability document\n                self.explore_show_head(uri, check_headers=checks)\n            else:\n                s = Sitemap()\n                list = s.parse_xml(url_or_file_open(uri))\n                (options, capability) = self.explore_show_summary(\n                    list, s.parsed_index, caps, context=uri)\n        except IOError as e:\n            print(\"Cannot read %s (%s)\" % (uri, str(e)))\n        except Exception as e:\n            print(\"Cannot parse %s (%s)\" % (uri, str(e)))\n        #\n        # Loop until we have some valid input\n        #\n        while (True):\n            # don't offer number option for no resources/capabilities\n            num_prompt = '' if (len(options) == 0) else 'number, '\n            up_prompt = 'b(ack), ' if (show_back) else ''\n            if (self.fake_input):\n                inp = self.fake_input\n            else:\n                inp = input(\"Follow [%s%sq(uit)]?\" % (num_prompt, up_prompt))\n            if (inp in options.keys()):\n                break\n            if (inp == 'q'):\n                raise ExplorerQuit()\n            if (inp == 'b'):\n                return(None)\n        #\n        # Got input that is one of the options\n        #\n        checks = {}\n        r = options[inp]\n        if (r.capability is None):\n            if (capability in ['resourcelist', 'changelist',\n                               'resourcedump', 'changedump']):\n                caps = 'resource'\n            else:\n                caps = self.allowed_entries(capability)\n        elif (r.capability is 'resource'):\n            caps = r.capability\n        else:\n            caps = [r.capability]\n        # Record anything we know about the resource to check\n        if (r.length is not None):\n            checks['content-length'] = r.length\n        if (r.lastmod is not None):\n            checks['last-modified'] = r.lastmod\n        if (r.mime_type is not None):\n            checks['content-type'] = r.mime_type\n        # FIXME - could add fixity checks here too\n        return(XResource(r.uri, caps, checks))", "response": "INTERACTIVE exploration of a given URI."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef explore_show_summary(self, list, index=False,\n                             expected=None, context=None):\n        \"\"\"Show summary of one capability document.\n\n        Given a capability document or index (in list, index True if it is an\n        index), write out a simply textual summary of the document with all\n        related documents shown as numbered options (of the form\n        [#] ...description...) which will then form a menu for the next\n        exploration.\n\n        If expected is not None then it should be a list of expected document\n        types. If this is set then a warning will be printed if list is not\n        one of these document types.\n\n        Look for certain top-level link types including rel=\"up\".\n        \"\"\"\n        num_entries = len(list.resources)\n        capability = '(unknown capability)'\n        if ('capability' in list.md):\n            capability = list.md['capability']\n        if (index):\n            capability += 'index'\n        print(\n            \"Parsed %s document with %d entries:\" %\n            (capability, num_entries))\n        if (expected is not None and capability not in expected):\n            print(\"WARNING - expected a %s document\" % (','.join(expected)))\n        if (capability not in ['description', 'descriptionoindex', 'capabilitylist',\n                               'resourcelist', 'resourcelistindex', 'changelist', 'changelistindex',\n                               'resourcedump', 'resourcedumpindex', 'changedump', 'changedumpindex',\n                               'resourcelist-archive', 'resourcedump-archive',\n                               'changelist-archive', 'changedump-archive']):\n            print(\"WARNING - unknown %s document type\" % (capability))\n        to_show = num_entries\n        if (num_entries > 21):\n            to_show = 20\n        # What capability entries are allowed/expected?\n        entry_caps = self.allowed_entries(capability)\n        options = {}\n        n = 0\n        # Look for <rs:ln> elements in this document\n        ln_describedby = list.link('describedby')\n        if (ln_describedby):\n            if ('href' in ln_describedby):\n                uri = ln_describedby['href']\n                print(\"[%s] rel='describedby' link to %s\" % ('d', uri))\n                uri = self.expand_relative_uri(context, uri)\n                options['d'] = Resource(uri, capability='resource')\n            else:\n                print(\"WARNING - describedby link with no href, ignoring\")\n        ln_up = list.link('up')\n        if (ln_up):\n            if ('href' in ln_up):\n                uri = ln_up['href']\n                print(\"[%s] rel='up' link to %s\" % ('u', uri))\n                uri = self.expand_relative_uri(context, uri)\n                options['u'] = Resource(uri)\n            else:\n                print(\"WARNING - up link with no href, ignoring\")\n        ln_index = list.link('index')\n        if (ln_index):\n            if ('href' in ln_index):\n                uri = ln_index['href']\n                print(\"[%s] rel='index' link to %s\" % ('i', uri))\n                uri = self.expand_relative_uri(context, uri)\n                options['i'] = Resource(uri)\n            else:\n                print(\"WARNING - index link with no href, ignoring\")\n        # Show listed resources as numbered options\n        for r in list.resources:\n            if (n >= to_show):\n                print(\"(not showing remaining %d entries)\" % (num_entries - n))\n                break\n            n += 1\n            options[str(n)] = r\n            print(\"[%d] %s\" % (n, r.uri))\n            if (self.verbose):\n                print(\"  \" + str(r))\n            r.uri = self.expand_relative_uri(context, r.uri)\n            if (r.capability is not None):\n                warning = ''\n                if (r.capability not in entry_caps):\n                    warning = \" (EXPECTED %s)\" % (' or '.join(entry_caps))\n                print(\"  %s%s\" % (r.capability, warning))\n            elif (len(entry_caps) == 1):\n                r.capability = entry_caps[0]\n                print(\n                    \"  capability not specified, should be %s\" %\n                    (r.capability))\n        return(options, capability)", "response": "Show summary of one capability document."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef explore_show_head(self, uri, check_headers=None):\n        print(\"HEAD %s\" % (uri))\n        if (re.match(r'^\\w+:', uri)):\n            # Looks like a URI\n            response = requests.head(uri)\n        else:\n            # Mock up response if we have a local file\n            response = self.head_on_file(uri)\n        print(\"  status: %s\" % (response.status_code))\n        if (response.status_code == '200'):\n            # print some of the headers\n            for header in ['content-length', 'last-modified',\n                           'lastmod', 'content-type', 'etag']:\n                if header in response.headers:\n                    check_str = ''\n                    if (check_headers is not None and\n                            header in check_headers):\n                        if (response.headers[header] == check_headers[header]):\n                            check_str = ' MATCHES EXPECTED VALUE'\n                        else:\n                            check_str = ' EXPECTED %s' % (\n                                check_headers[header])\n                    print(\n                        \"  %s: %s%s\" %\n                        (header, response.headers[header], check_str))", "response": "Do HEAD on a URI and show infomation."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmock up requests. head response on local file.", "response": "def head_on_file(self, file):\n        \"\"\"Mock up requests.head(..) response on local file.\"\"\"\n        response = HeadResponse()\n        if (not os.path.isfile(file)):\n            response.status_code = '404'\n        else:\n            response.status_code = '200'\n            response.headers[\n                'last-modified'] = datetime_to_str(os.path.getmtime(file))\n            response.headers['content-length'] = os.path.getsize(file)\n        return(response)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef allowed_entries(self, capability):\n        index = re.match(r'(.+)index$', capability)\n        archive = re.match(r'(.+)\\-archive$', capability)\n        if (capability == 'capabilitylistindex'):\n            return([])  # not allowed so no valid references\n        elif (index):\n            return([index.group(1)])  # name without index ending\n        elif (archive):\n            return([archive.group(1)])  # name without -archive ending\n        elif (capability == 'description'):\n            return(['capabilitylist'])\n        elif (capability == 'capabilitylist'):\n            return(['resourcelist', 'resourcedump',\n                    'changelist', 'changedump',\n                    'resourcelist-archive', 'resourcedump-archive',\n                    'changelist-archive', 'changedump-archive'])\n        return([])", "response": "Return list of allowed entries for given capability document."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expand_relative_uri(self, context, uri):\n        full_uri = urljoin(context, uri)\n        if (full_uri != uri):\n            print(\"  WARNING - expanded relative URI to %s\" % (full_uri))\n            uri = full_uri\n        return(uri)", "response": "Expand the given URI in context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scan_models(self, folder='./yang', download='check'):\n        '''scan_models\n\n        High-level api: Download models from the device by <get-schema>\n        operation defined in RFC6022, and analyze dependencies among models\n        using pyang package.\n\n        Parameters\n        ----------\n\n        folder : `str`\n            A path to a folder that stores YANG files downloaded.\n\n        download : `str`\n            A string is either `check` or `force`. If it is `check`, the content\n            in the folder is compared with self.server_capabilities. Downloading\n            will be skipped if the checking says good. If it is `force`,\n            downloading starts without checking.\n\n        Returns\n        -------\n\n        None\n            Nothing returns.\n\n\n        YAML Example::\n\n            devices:\n                asr22:\n                    type: 'ASR'\n                    tacacs:\n                        login_prompt: \"login:\"\n                        password_prompt: \"Password:\"\n                        username: \"admin\"\n                    passwords:\n                        tacacs: admin\n                        enable: admin\n                        line: admin\n                    connections:\n                        a:\n                            protocol: telnet\n                            ip: \"1.2.3.4\"\n                            port: 2004\n                        vty:\n                            protocol : telnet\n                            ip : \"2.3.4.5\"\n                        netconf:\n                            class: yang.ncdiff.ModelDevice\n                            ip : \"2.3.4.5\"\n                            port: 830\n                            username: admin\n                            password: admin\n\n        Code Example::\n\n            >>> from pyats.topology import loader\n            >>> testbed = loader.load('/users/yuekyang/projects/asr21.yaml')\n            >>> device = testbed.devices['asr21']\n            >>> device.connect(alias='nc', via='netconf')\n            >>>\n            >>> device.nc.scan_models()\n            ...\n            >>>\n        '''\n\n        d = ModelDownloader(self, folder)\n        if download == 'force':\n            d.download_all(check_before_download=False)\n        elif download == 'check':\n            d.download_all(check_before_download=True)\n        self.compiler = ModelCompiler(folder)", "response": "Download YANG files from the device and check if they are available."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_model(self, model):\n        '''load_model\n\n        High-level api: Load schema information by compiling the model using\n        pyang package.\n\n        Parameters\n        ----------\n\n        model : `str`\n            Model name.\n\n        Returns\n        -------\n\n        Model\n            An instance of Model.\n\n\n        YAML Example::\n\n            devices:\n                asr22:\n                    type: 'ASR'\n                    tacacs:\n                        login_prompt: \"login:\"\n                        password_prompt: \"Password:\"\n                        username: \"admin\"\n                    passwords:\n                        tacacs: admin\n                        enable: admin\n                        line: admin\n                    connections:\n                        a:\n                            protocol: telnet\n                            ip: \"1.2.3.4\"\n                            port: 2004\n                        vty:\n                            protocol : telnet\n                            ip : \"2.3.4.5\"\n                        netconf:\n                            class: yang.ncdiff.ModelDevice\n                            ip : \"2.3.4.5\"\n                            port: 830\n                            username: admin\n                            password: admin\n\n        Code Example::\n\n            >>> from pyats.topology import loader\n            >>> testbed = loader.load('/users/yuekyang/projects/asr21.yaml')\n            >>> device = testbed.devices['asr21']\n            >>> device.connect(alias='nc', via='netconf')\n            >>> device.nc.scan_models()\n            >>>\n            >>> m = device.nc.load_model('openconfig-system')\n            >>> print(m)\n            ...\n            >>>\n        '''\n\n        if os.path.isfile(model):\n            file_name, file_ext = os.path.splitext(model)\n            if file_ext.lower() == '.xml':\n                logger.debug('Read model file {}'.format(model))\n                with open(model, 'r') as f:\n                    xml = f.read()\n                parser = etree.XMLParser(remove_blank_text=True)\n                tree = etree.XML(xml, parser)\n            else:\n                raise ValueError(\"'{}' is not a file with extension 'xml'\" \\\n                                 .format(model))\n        elif model in self.models_loadable:\n            if self.compiler is None:\n                raise ValueError('please first call scan_models() to build ' \\\n                                 'up supported namespaces of a device')\n            else:\n                m = self.compiler.compile(model)\n        else:\n            raise ValueError(\"argument 'model' {} needs to be either a model \" \\\n                             \"name or a compiled model xml file\".format(model))\n        if m.name in self.models:\n            self.nodes = {k: v for k, v in self.nodes.items()\n                          if self.roots[k.split(' ')[0]] != m.name}\n            logger.info('Model {} is reloaded'.format(m.name))\n        else:\n            logger.info('Model {} is loaded'.format(m.name))\n        self.models[m.name] = m\n        return m", "response": "Load model using High - level api."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute the specified operation on the current object.", "response": "def execute(self, operation, *args, **kwargs):\n        '''execute\n\n        High-level api: Supported operations are get, get_config, get_schema,\n        dispatch, edit_config, copy_config, validate, commit, discard_changes,\n        delete_config, lock, unlock, close_session, kill_session,\n        poweroff_machine and reboot_machine. Since ModelDevice is a subclass of\n        manager in ncclient package, any method supported by ncclient is\n        available here. Refer to ncclient document for more details.\n        '''\n\n        def pop_models():\n            models = kwargs.pop('models', None)\n            if models is None:\n                return None\n            else:\n                if isinstance(models, str):\n                    return [models]\n                else:\n                    return models\n\n        def check_models(models):\n            missing_models = set(models) - set(self.models_loaded)\n            if missing_models:\n                raise ModelMissing('please load model {} by calling ' \\\n                                   'method load_model() of device {}' \\\n                                   .format(str(list(missing_models))[1:-1],\n                                           self))\n\n        def build_filter(models, roots):\n            if 'filter' in kwargs:\n                logger.warning(\"argument 'filter' is ignored as argument \"\n                               \"'models' is specified\")\n            if isinstance(models, str):\n                models = [models]\n            check_models(models)\n            filter_ele = etree.Element(filter_tag, type='subtree')\n            for root in roots:\n                etree.SubElement(filter_ele, root)\n            filter_xml = etree.tostring(filter_ele,\n                                        encoding='unicode',\n                                        pretty_print=False)\n            logger.debug(\"argument 'filter' is set to '{}'\".format(filter_xml))\n            return filter_ele\n\n        def get_access_type(model_name, root):\n            check_models([model_name])\n            node = list(self.models[model_name].tree.iterchildren(tag=root))[0]\n            return node.get('access')\n\n        # allow for operation string type\n        if type(operation) is str:\n            try:\n                cls = manager.OPERATIONS[operation]\n            except KeyError:\n                supported_operations = list(manager.OPERATIONS.keys())\n                raise ValueError(\"supported operations are {}, but not '{}'\" \\\n                                 .format(str(supported_operations)[1:-1],\n                                         operation))\n        else:\n            cls = operation\n        if cls == operations.retrieve.Get:\n            models = pop_models()\n            if models is not None:\n                check_models(models)\n                roots = [k for k, v in self.roots.items()\n                         if v in models and\n                            (get_access_type(v, k) == 'read-write' or\n                             get_access_type(v, k) == 'read-only')]\n                if not roots:\n                    raise ValueError('no readable roots found in your ' \\\n                                     'models: {}'.format(str(models)[1:-1]))\n                kwargs['filter'] = build_filter(models, roots)\n        elif cls == operations.retrieve.GetConfig:\n            if not args and 'source' not in kwargs:\n                args = tuple(['running'])\n            models = pop_models()\n            if models is not None:\n                check_models(models)\n                roots = [k for k, v in self.roots.items()\n                         if v in models and\n                            get_access_type(v, k) == 'read-write']\n                if not roots:\n                    raise ValueError('no writable roots found in your ' \\\n                                     'models: {}'.format(str(models)[1:-1]))\n                kwargs['filter'] = build_filter(models, roots)\n        elif cls == operations.edit.EditConfig:\n            if args and isinstance(args[0], Config):\n                args_list = list(args)\n                args_list[0] = args[0].ele\n                args = tuple(args_list)\n            if 'target' not in kwargs and \\\n               'urn:ietf:params:netconf:capability:candidate:1.0' not in \\\n               self.server_capabilities and \\\n               'urn:ietf:params:netconf:capability:writable-running:1.0' in \\\n               self.server_capabilities:\n                kwargs['target'] = 'running'\n        reply = super().execute(cls, *args, **kwargs)\n        if isinstance(reply, operations.rpc.RPCReply):\n            reply.ns = self._get_ns(reply._root)\n        if getattr(transport, 'notify', None) and \\\n           isinstance(reply, transport.notify.Notification):\n            reply.ns = self._get_ns(reply._root_ele)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a notification from the device.", "response": "def take_notification(self, block=True, timeout=None):\n        '''take_notification\n\n        High-level api: Receive notification messages.\n\n        Parameters\n        ----------\n\n        block : `bool`\n            True if this is a blocking call.\n\n        timeout : `int`\n            Timeout value in seconds.\n\n        Returns\n        -------\n\n        Notification\n            An instance of Notification in ncclient package.\n\n\n        Code Example::\n\n            >>> reply = device.nc.take_notification(block=True, timeout=60)\n            >>> assert(reply.ok)\n            >>> print(reply)\n            >>>\n        '''\n\n        reply = super().take_notification(block=block, timeout=timeout)\n        if isinstance(reply, operations.rpc.RPCReply):\n            reply.ns = self._get_ns(reply._root)\n        if getattr(transport, 'notify', None) and \\\n           isinstance(reply, transport.notify.Notification):\n            reply.ns = self._get_ns(reply._root_ele)\n        return reply"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting config from a rpc - reply of get - config or get - config or get - config message.", "response": "def extract_config(self, reply, type='netconf'):\n        '''extract_config\n\n        High-level api: Extract config from a rpc-reply of get-config or get\n        message.\n\n        Parameters\n        ----------\n\n        reply : `RPCReply`\n            An instance of RPCReply in ncclient package. It has to be a\n            successful reply in order to extract config, since there is no\n            config data in an errored reply.\n\n        Returns\n        -------\n\n        Config\n            An instance of Config, which represents a config state of the\n            device.\n\n\n        Code Example::\n\n            >>> reply = device.nc.get_config(models='openconfig-interfaces')\n            >>> assert(reply.ok)\n            >>> config1 = device.nc.extract_config(reply)\n            >>>\n            >>> reply = device.nc.get(models='openconfig-interfaces')\n            >>> assert(reply.ok)\n            >>> config2 = device.nc.extract_config(reply)\n            >>>\n            >>> config1 == config2\n            True\n            >>>\n        '''\n\n        def remove_read_only(parent):\n            for child in parent.getchildren():\n                schema_node = self.get_schema_node(child)\n                if schema_node.get('access') == 'read-only':\n                    parent.remove(child)\n                elif len(child) > 0:\n                    remove_read_only(child)\n\n        config = Config(self, reply)\n        remove_read_only(config.ele)\n        return config"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives an Element node in config returns a schema node which is a schema node.", "response": "def get_schema_node(self, config_node):\n        '''get_schema_node\n\n        High-level api: Given an Element node in config, get_schema_node returns\n        a schema node (defined in RFC 6020), which is an Element node in the\n        schema tree.\n\n        Parameters\n        ----------\n\n        config_node : `Element`\n            An Element node in config tree.\n\n        Returns\n        -------\n\n        Element\n            A schema node, or None when nothing can be found.\n\n        Raises\n        ------\n\n        ModelError\n            If identifier is not unique in a namespace.\n\n\n        Code Example::\n\n            >>> device.nc.load_model('openconfig-interfaces')\n            >>> reply = device.nc.get_config(models='openconfig-interfaces')\n            >>> config = device.nc.extract_config(reply)\n            >>> print(config)\n            ...\n            >>> config.ns\n            ...\n            >>> config_nodes = config.xpath('/nc:config/oc-if:interfaces/oc-if:interface[oc-if:name=\"GigabitEthernet0/0\"]')\n            >>> config_node = config_nodes[0]\n            >>>\n            >>> device.nc.get_schema_node(config_node)\n            <Element {http://openconfig.net/yang/interfaces}interface at 0xf11acfcc>\n            >>>\n        '''\n\n        def get_child(parent, tag):\n            children = [i for i in parent.iter(tag=tag) \\\n                        if i.attrib['type'] != 'choice' and \\\n                           i.attrib['type'] != 'case' and \\\n                           is_parent(parent, i)]\n            if len(children) == 1:\n                return children[0]\n            elif len(children) > 1:\n                if parent.getparent() is None:\n                    raise ModelError(\"more than one root has tag '{}'\" \\\n                                     .format(tag))\n                else:\n                    raise ModelError(\"node {} has more than one child with \" \\\n                                     \"tag '{}'\" \\\n                                     .format(self.get_xpath(parent), tag))\n            else:\n                return None\n\n        def is_parent(node1, node2):\n            ancestors = {id(a): a for a in node2.iterancestors()}\n            ids_1 = set([id(a) for a in node1.iterancestors()])\n            ids_2 = set([id(a) for a in node2.iterancestors()])\n            if not ids_1 < ids_2:\n                return False\n            for i in ids_2 - ids_1:\n                if ancestors[i] is not node1 and \\\n                   ancestors[i].attrib['type'] != 'choice' and \\\n                   ancestors[i].attrib['type'] != 'case':\n                    return False\n            return True\n\n        n = Composer(self, config_node)\n        config_path = n.path\n        if ' '.join(config_path) in self.nodes:\n            return self.nodes[' '.join(config_path)]\n        if len(config_path) > 1:\n            parent = self.get_schema_node(config_node.getparent())\n            if parent is None:\n                return None\n            else:\n                child = get_child(parent, config_node.tag)\n                if child is not None:\n                    self.nodes[' '.join(config_path)] = child\n                return child\n        else:\n            tree = self.models[n.model_name].tree\n            child = get_child(tree, config_node.tag)\n            if child is not None:\n                self.nodes[' '.join(config_path)] = child\n            return child"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a config or schema node get an xpath of the node which starts from the model root.", "response": "def get_xpath(self, node, type=Tag.XPATH, instance=True):\n        '''get_xpath\n\n        High-level api: Given a config or schema node, get_xpath returns an\n        xpath of the node, which starts from the model root. Each identifier\n        uses the `prefix:tagname` notation if argument 'type' is not specified.\n\n        Parameters\n        ----------\n\n        node : `Element`\n            A config or schema node.\n\n        type : `tuple`\n            A tuple constant defined in yang.ncdiff.Tag. Most commonly it could\n            be Tag.XPATH or Tag.LXML_XPATH.\n\n        instance : `bool`\n            True if the xpath returned points to an instance. The xpath could\n            point to a list or leaf-list when instance=False.\n\n        Returns\n        -------\n\n        str\n            An xpath of the config or schema node, which starts from the model\n            root.\n\n\n        Code Example::\n\n            >>> device.nc.get_xpath(config_node)\n            '/oc-if:interfaces/interface[name=\"GigabitEthernet0/0\"]'\n            >>> device.nc.get_xpath(config_node, type=Tag.LXML_XPATH)\n            '/oc-if:interfaces/oc-if:interface[oc-if:name=\"GigabitEthernet0/0\"]'\n            >>>\n            >>> device.nc.get_xpath(schema_node)\n            '/oc-if:interfaces/interface'\n            >>>\n        '''\n\n        return Composer(self, node).get_xpath(type, instance=instance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef convert_tag(self, default_ns, tag, src=Tag.LXML_ETREE, dst=Tag.YTOOL):\n        '''convert_tag\n\n        High-level api: Convert a tag or an identifier from one notation to\n        another. Notations are defined by tuple constants in yang.ncdiff.Tag.\n\n        Parameters\n        ----------\n\n        default_ns : `str`\n            The default namespace. Usually it's the namespace of parent node. It\n            could be a model name, a model prefix, or a model URL, depending on\n            your argument 'src'. An empty string is considered as none default\n            namespace.\n\n        tag : `str`\n            A tag or an identifier of a config node or a schema node.\n\n        src : `tuple`\n            The type of notation the input tag is, which is a tuple constant\n            defined in yang.ncdiff.Tag. Most commonly it could be Tag.XPATH or\n            Tag.LXML_XPATH.\n\n        dst : `tuple`\n            The type of notation we want, which is a tuple constant defined in\n            yang.ncdiff.Tag. Most commonly it could be Tag.XPATH or\n            Tag.LXML_XPATH.\n\n        Returns\n        -------\n\n        tuple\n            A tuple that has two elements: The first element is the namespace of\n            argument 'tag'. It could be a model name, a model prefix, or a model\n            URL, depending on your argument 'src'. The second element is the\n            converted tag or identifier, which is in notation specified by\n            argument 'dst'.\n\n\n        Code Example::\n\n            >>> device.nc.convert_tag('',\n                                      '{http://openconfig.net/yang/interfaces}interface',\n                                      dst=Tag.JSON_NAME)\n            ('http://openconfig.net/yang/interfaces', 'openconfig-interfaces:interface')\n            >>>\n        '''\n\n        def possible_part1():\n            if src[0] == Tag.NAME:\n                return [i[0] for i in self.namespaces]\n            elif src[0] == Tag.PREFIX:\n                return [i[1] for i in self.namespaces] + \\\n                       list(special_prefixes.values())\n            else:\n                return [i[2] for i in self.namespaces] + \\\n                       list(special_prefixes.keys())\n\n        def split_tag(tag):\n            ret = re.search(src[2][0], tag)\n            if ret:\n                if ret.group(1) in possible_part1():\n                    return (ret.group(1), ret.group(2))\n                else:\n                    return ('', tag)\n            else:\n                return ('', tag)\n\n        def format_tag(tag_ns, tag_name):\n            if tag_ns:\n                return dst[2][1].format(tag_ns, tag_name)\n            else:\n                return tag_name\n\n        def convert(ns):\n            matches = [i for i in self.namespaces if i[src[0]] == ns]\n            c = len(matches)\n            if c > 1:\n                raise ModelError(\"device supports more than one {} '{}': {}\" \\\n                                 .format(Tag.STR[src[0]], ns, matches))\n            if c == 1:\n                return matches[0][dst[0]]\n            if src[0] != Tag.NAME and dst[0] != Tag.NAME:\n                special = [('', v, k) for k, v in special_prefixes.items()]\n                matches = [i for i in special if i[src[0]] == ns]\n                if len(matches) == 1:\n                    return matches[0][dst[0]]\n            raise ValueError(\"device does not support {} '{}' \" \\\n                             \"when parsing tag '{}'\" \\\n                             .format(Tag.STR[src[0]], ns, tag))\n\n        tag_ns, tag_name = split_tag(tag)\n        if src[1] == Tag.NO_OMIT and not tag_ns:\n            raise ValueError(\"tag '{}' does not contain prefix or namespace \" \\\n                             \"but it is supposed to be Tag.NO_OMIT\" \\\n                             .format(tag))\n        elif not tag_ns:\n            tag_ns = default_ns\n        if dst[1] == Tag.NO_OMIT:\n            return tag_ns, format_tag(convert(tag_ns), tag_name)\n        elif dst[1] == Tag.OMIT_BY_INHERITANCE:\n            if default_ns == tag_ns:\n                return default_ns, format_tag('', tag_name)\n            else:\n                return tag_ns, format_tag(convert(tag_ns), tag_name)\n        elif dst[1] == Tag.OMIT_BY_MODULE:\n            if default_ns == tag_ns:\n                return default_ns, format_tag('', tag_name)\n            else:\n                return default_ns, format_tag(convert(tag_ns), tag_name)\n        else:\n            raise ValueError(\"unknown value '{}' in class Tag\".format(dst[1]))", "response": "Convert a tag or identifier from one notation to another."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrenders multi checkbox widget.", "response": "def scopes_multi_checkbox(field, **kwargs):\n    \"\"\"Render multi checkbox widget.\"\"\"\n    kwargs.setdefault('type', 'checkbox')\n    field_id = kwargs.pop('id', field.id)\n\n    html = [u'<div class=\"row\">']\n\n    for value, label, checked in field.iter_choices():\n        choice_id = u'%s-%s' % (field_id, value)\n\n        options = dict(\n            kwargs,\n            name=field.name,\n            value=value,\n            id=choice_id,\n            class_=' ',\n        )\n\n        if checked:\n            options['checked'] = 'checked'\n\n        html.append(u'<div class=\"col-md-3\">')\n        html.append(u'<label for=\"{0}\" class=\"checkbox-inline\">'.format(\n            choice_id\n        ))\n        html.append(u'<input {0} /> '.format(widgets.html_params(**options)))\n        html.append(u'{0} <br/><small class=\"text-muted\">{1}</small>'.format(\n            value, label.help_text\n        ))\n        html.append(u'</label></div>')\n    html.append(u'</div>')\n\n    return HTMLString(u''.join(html))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates and store redirect URIs for client.", "response": "def redirect_uris(self, value):\n        \"\"\"Validate and store redirect URIs for client.\"\"\"\n        if isinstance(value, six.text_type):\n            value = value.split(\"\\n\")\n\n        value = [v.strip() for v in value]\n\n        for v in value:\n            validate_redirect_uri(v)\n\n        self._redirect_uris = \"\\n\".join(value) or \"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef default_scopes(self, scopes):\n        validate_scopes(scopes)\n        self._default_scopes = \" \".join(set(scopes)) if scopes else \"\"", "response": "Set default scopes for client."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_users(self):\n        no_users = Token.query.filter_by(\n            client_id=self.client_id,\n            is_personal=False,\n            is_internal=False\n        ).count()\n        return no_users", "response": "Get number of users."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef scopes(self, scopes):\n        validate_scopes(scopes)\n        self._scopes = \" \".join(set(scopes)) if scopes else \"\"", "response": "Set the list of scopes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget list of non - internal scopes for token.", "response": "def get_visible_scopes(self):\n        \"\"\"Get list of non-internal scopes for token.\n\n        :returns: A list of scopes.\n        \"\"\"\n        return [k for k, s in current_oauth2server.scope_choices()\n                if k in self.scopes]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a personal access token.", "response": "def create_personal(cls, name, user_id, scopes=None, is_internal=False):\n        \"\"\"Create a personal access token.\n\n        A token that is bound to a specific user and which doesn't expire, i.e.\n        similar to the concept of an API key.\n\n        :param name: Client name.\n        :param user_id: User ID.\n        :param scopes: The list of permitted scopes. (Default: ``None``)\n        :param is_internal: If ``True`` it's a internal access token.\n             (Default: ``False``)\n        :returns: A new access token.\n        \"\"\"\n        with db.session.begin_nested():\n            scopes = \" \".join(scopes) if scopes else \"\"\n\n            c = Client(\n                name=name,\n                user_id=user_id,\n                is_internal=True,\n                is_confidential=False,\n                _default_scopes=scopes\n            )\n            c.gen_salt()\n\n            t = Token(\n                client_id=c.client_id,\n                user_id=user_id,\n                access_token=gen_salt(\n                    current_app.config.get(\n                        'OAUTH2SERVER_TOKEN_PERSONAL_SALT_LEN')\n                ),\n                expires=None,\n                _scopes=scopes,\n                is_personal=True,\n                is_internal=is_internal,\n            )\n\n            db.session.add(c)\n            db.session.add(t)\n\n        return t"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating a redirect URI.", "response": "def validate_redirect_uri(value):\n    \"\"\"Validate a redirect URI.\n\n    Redirect URIs must be a valid URL and use https unless the host is\n    localhost for which http is accepted.\n\n    :param value: The redirect URI.\n    \"\"\"\n    sch, netloc, path, par, query, fra = urlparse(value)\n    if not (sch and netloc):\n        raise InvalidRedirectURIError()\n    if sch != 'https':\n        if ':' in netloc:\n            netloc, port = netloc.split(':', 1)\n        if not (netloc in ('localhost', '127.0.0.1') and sch == 'http'):\n            raise InsecureTransportError()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate_scopes(value_list):\n    for value in value_list:\n        if value not in current_oauth2server.scopes:\n            raise ScopeDoesNotExists(value)\n    return True", "response": "Validate that each element in a list is a registered scope."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening a subprocess in another working directory and return the standard output and standard error.", "response": "def check_output_cwd(args, cwd, timeout=None):\n    '''Open a subprocess in another working directory\n\n    Raises ValueError if system binary does not exist\n    Raises CalledProcessError if the return code is non-zero\n\n    :returns: list of standard output and standard error from subprocess\n\n    :param args: a list of command line arguments for subprocess\n    :param cwd: the working directory for the subprocess\n    :param timeout: number of seconds before giving up\n    '''\n    assertions.list_is_type(args, str)\n    assertions.is_binary(args[0])\n    stdout_stderr = []\n    with Popen(args, cwd=cwd, stdout=PIPE, stderr=STDOUT) as active_subprocess:\n        for line in iter(active_subprocess.stdout.readline, b''):\n            line_str = line.decode().strip()\n            stdout_stderr.append(line_str)\n            print(line_str)\n        active_subprocess.wait(timeout=timeout)\n        returncode = active_subprocess.returncode\n    if returncode != 0:\n        raise CalledProcessError(returncode, args, output=None)\n    else:\n        return stdout_stderr"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_otp_modehex_interpretation(self, otp):\n        try:\n            interpretations = translate(u(otp))\n        except Exception:\n            return otp\n\n        if len(interpretations) == 0:\n            return otp\n        elif len(interpretations) > 1:\n            # If there are multiple interpretations first try to use the same\n            # translation as the input OTP. If the one is not found, use the\n            # random interpretation.\n            if u(otp) in interpretations:\n                return otp\n\n        return interpretations.pop()", "response": "Returns the modhex interpretation of the OTP."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs a shift function from an iterable of strings representing separate cases of a single language.", "response": "def make_shift_function(alphabet):\n    \"\"\"Construct a shift function from an alphabet.\n\n    Examples:\n        Shift cases independently\n\n        >>> make_shift_function([string.ascii_uppercase, string.ascii_lowercase])\n        <function make_shift_function.<locals>.shift_case_sensitive>\n\n        Additionally shift punctuation characters\n\n        >>> make_shift_function([string.ascii_uppercase, string.ascii_lowercase, string.punctuation])\n        <function make_shift_function.<locals>.shift_case_sensitive>\n\n        Shift entire ASCII range, overflowing cases\n\n        >>> make_shift_function([''.join(chr(x) for x in range(32, 127))])\n        <function make_shift_function.<locals>.shift_case_sensitive>\n\n    Args:\n        alphabet (iterable): Ordered iterable of strings representing separate cases of an alphabet\n\n    Returns:\n        Function (shift, symbol)\n    \"\"\"\n    def shift_case_sensitive(shift, symbol):\n        case = [case for case in alphabet if symbol in case]\n        if not case:\n            return symbol\n\n        case = case[0]\n        index = case.index(symbol)\n        return case[(index - shift) % len(case)]\n\n    return shift_case_sensitive"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbreak a list of ciphertext into a list of decryptions.", "response": "def crack(ciphertext, *fitness_functions, min_key=0, max_key=26, shift_function=shift_case_english):\n    \"\"\"Break ``ciphertext`` by enumerating keys between ``min_key`` and ``max_key``.\n\n    Example:\n        >>> decryptions = crack(\"KHOOR\", fitness.english.quadgrams)\n        >>> print(''.join(decryptions[0].plaintext))\n        HELLO\n\n    Args:\n        ciphertext (iterable): The symbols to decrypt\n        *fitness_functions (variable length argument list): Functions to score decryption with\n\n    Keyword Args:\n        min_key (int): Key to start with\n        max_key (int): Key to stop at (exclusive)\n        shift_function (function(shift, symbol)): Shift function to use\n\n    Returns:\n        Sorted list of decryptions\n\n    Raises:\n        ValueError: If min_key exceeds max_key\n        ValueError: If no fitness_functions are given\n    \"\"\"\n    if min_key >= max_key:\n        raise ValueError(\"min_key cannot exceed max_key\")\n\n    decryptions = []\n    for key in range(min_key, max_key):\n        plaintext = decrypt(key, ciphertext, shift_function=shift_function)\n        decryptions.append(Decryption(plaintext, key, score(plaintext, *fitness_functions)))\n\n    return sorted(decryptions, reverse=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decrypt(key, ciphertext, shift_function=shift_case_english):\n    return [shift_function(key, symbol) for symbol in ciphertext]", "response": "Decrypt the ciphertext using the key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, task_id):\n        '''taobao.topats.result.get \u83b7\u53d6\u5f02\u6b65\u4efb\u52a1\u7ed3\u679c\n        \n        \u4f7f\u7528\u6307\u5357\uff1ahttp://open.taobao.com/doc/detail.htm?id=30 \n        \n        - 1.\u6b64\u63a5\u53e3\u7528\u4e8e\u83b7\u53d6\u5f02\u6b65\u4efb\u52a1\u5904\u7406\u7684\u7ed3\u679c\uff0c\u4f20\u5165\u7684task_id\u5fc5\u9700\u5c5e\u4e8e\u5f53\u524d\u7684appKey\u624d\u53ef\u4ee5 \n        - 2.\u6b64\u63a5\u53e3\u53ea\u8fd4\u56de\u6267\u884c\u5b8c\u6210\u7684\u4efb\u52a1\u7ed3\u679c\uff0c\u672a\u6267\u884c\u5b8c\u7684\u8fd4\u56de\u7ed3\u679c\u91cc\u9762\u4e0d\u5305\u542b\u4efb\u52a1\u7ed3\u679c\uff0c\u53ea\u6709\u4efb\u52a1id\uff0c\u6267\u884c\u72b6\u6001 \n        - 3.\u6267\u884c\u5b8c\u6210\u7684\u6bcf\u4e2atask\u7684\u5b50\u4efb\u52a1\u7ed3\u679c\u5185\u5bb9\u4e0e\u5355\u4e2a\u4efb\u52a1\u7684\u7ed3\u679c\u7ed3\u6784\u4e00\u81f4\u3002\u5982\uff1ataobao.topats.trades.fullinfo.get\u8fd4\u56de\u7684\u5b50\u4efb\u52a1\u7ed3\u679c\u5c31\u4f1a\u662fTrade\u7684\u7ed3\u6784\u4f53\u3002'''\n        request = TOPRequest('taobao.topats.result.get')\n        request['task_id'] = task_id\n        self.create(self.execute(request)['task'])\n        return self", "response": "TAOBAO. result. get \u83b7\u53d6\u5f02\u6b65\u4efb\u52a1\u7ed3\u679c."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef accountreport_get(self, start_created, end_created, session, fields=[]):\n        '''taobao.topats.trade.accountreport.get \u5f02\u6b65\u83b7\u53d6\u6dd8\u5b9d\u5356\u5bb6\u7ed1\u5b9a\u7684\u652f\u4ed8\u5b9d\u8d26\u6237\u7684\u8d22\u52a1\u660e\u7ec6\n        \n        - 1.\u63d0\u4f9b\u5f02\u6b65\u4e0b\u8f7d\u7528\u6237\u652f\u4ed8\u5b9d\u5bf9\u8d26\u4fe1\u606f\u63a5\u53e3 \n        - 2.\u4e00\u6b21\u8c03\u7528\u6700\u591a\u652f\u6301\u4e0b\u8f7d3\u4e2a\u6708\u7684\u5bf9\u8d26\u4fe1\u606f \n        - 3.\u4ec5\u80fd\u83b7\u53d62010\u5e746\u670810\u65e5\u4ee5\u540e\u7684\u4fe1\u606f \n        - 4.\u63d0\u4ea4\u4efb\u52a1\u4f1a\u8fdb\u884c\u521d\u6b65\u4efb\u52a1\u6821\u9a8c\uff0c\u5982\u679c\u6210\u529f\u4f1a\u8fd4\u56de\u4efb\u52a1\u53f7\u548c\u521b\u5efa\u65f6\u95f4\uff0c\u5982\u679c\u5931\u8d25\u5c31\u62a5\u9519 \n        - 5.\u53ef\u4ee5\u63a5\u6536\u6dd8\u5b9d\u53d1\u51fa\u7684\u4efb\u52a1\u5b8c\u6210\u6d88\u606f\uff0c\u4e5f\u53ef\u4ee5\u8fc7\u4e00\u6bb5\u65f6\u95f4\u6765\u53d6\u7ed3\u679c\u3002\u83b7\u53d6\u7ed3\u679c\u63a5\u53e3\u4e3ataobao.topats.result.get \n        - 6.\u652f\u4ed8\u5b9d\u8bc1\u4e66\u7b7e\u540d\u65b9\u6cd5\u89c1\u6587\u6863\uff1a\u201chttp://open.taobao.com/dev/index.php/\u5982\u4f55\u6570\u5b57\u8bc1\u4e66\u7b7e\u540d\u201d \n        - 7.\u6b64api\u6267\u884c\u5b8c\u6210\u53d1\u9001\u7684\u901a\u77e5\u6d88\u606f\u683c\u5f0f\u4e3a{\"task\":{\"task_id\":123456,\"created\":\"2010-8-19\"}} \n        - 8.\u6b64\u4efb\u52a1\u662f\u5927\u6570\u636e\u4efb\u52a1\uff0c\u83b7\u53d6\u4efb\u52a1\u7ed3\u679c\u65f6\u53ea\u80fd\u5f97\u5230\u4e0b\u8f7durl \n        - 9.\u5b50\u4efb\u52a1\u7ed3\u679c\u89e3\u6790\u89c1TradeAccountDetail\u7ed3\u6784\u4f53\u8bf4\u660e \n        - 10.\u6b64\u63a5\u53e3\u6267\u884c\u4efb\u52a1\u65f6\u95f4\u6bb5\u4e3a\uff1a00:00:00-09:30:00;11:00:00-14:00:00;17:00:00-20:00:00;22:30:00-23:59:59\uff0c\u53ea\u6709\u5728\u8fd9\u6bb5\u65f6\u95f4\u5185\u624d\u80fd\u8fd4\u56de\u67e5\u8be2\u7ed3\u679c'''\n        request = TOPRequest('taobao.topats.trade.accountreport.get')\n        request['start_created'] = start_created\n        request['end_created'] = end_created\n        if not fields:\n            tradeAccountDetail = TradeAccountDetail()\n            fields = tradeAccountDetail.fields\n        request['fields'] = fields\n        self.create(self.execute(request, session)['task'])\n        return self", "response": "TAOBAO \u83b7\u53d6 accountreport. get"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fullinfo_get(self, tid, session, fields=[]):\n        '''taobao.trade.fullinfo.get \u83b7\u53d6\u5355\u7b14\u4ea4\u6613\u7684\u8be6\u7ec6\u4fe1\u606f\n        \n        \u83b7\u53d6\u5355\u7b14\u4ea4\u6613\u7684\u8be6\u7ec6\u4fe1\u606f \n        \n        - 1.\u53ea\u6709\u5728\u4ea4\u6613\u6210\u529f\u7684\u72b6\u6001\u4e0b\u624d\u80fd\u53d6\u5230\u4ea4\u6613\u4f63\u91d1\uff0c\u5176\u5b83\u72b6\u6001\u4e0b\u53d6\u5230\u7684\u90fd\u662f\u96f6\u6216\u7a7a\u503c \n        - 2.\u53ea\u6709\u5355\u7b14\u8ba2\u5355\u7684\u60c5\u51b5\u4e0bTrade\u6570\u636e\u7ed3\u6784\u4e2d\u624d\u5305\u542b\u5546\u54c1\u76f8\u5173\u7684\u4fe1\u606f \n        - 3.\u83b7\u53d6\u5230\u7684Order\u4e2d\u7684payment\u5b57\u6bb5\u5728\u5355\u7b14\u5b50\u8ba2\u5355\u65f6\u5305\u542b\u7269\u6d41\u8d39\u7528\uff0c\u591a\u7b14\u5b50\u8ba2\u5355\u65f6\u4e0d\u5305\u542b\u7269\u6d41\u8d39\u7528 \u6ce8\uff1a\u5305\u542b\u4ee5\u4e0b\u5b57\u6bb5\u7684\u8fd4\u56de\u4f1a\u589e\u52a0TOP\u7684\u540e\u53f0\u538b\u529b\uff0c\u8bf7\u4ec5\u5728\u786e\u5b9e\u9700\u8981\u7684\u60c5\u51b5\u4e0b\u624d\u53bb\u83b7\u53d6\uff1acommission_fee, buyer_alipay_no, seller_alipay_no, buyer_email, seller_mobile, seller_phone, seller_name, seller_email, timeout_action_time, item_memo, trade_memo, title, available_confirm_fee'''\n        request = TOPRequest('taobao.trade.fullinfo.get')\n        request['tid'] = tid\n        if not fields:\n            fields = self.fields\n        request['fields'] = fields\n        self.create(self.execute(request, session)['trade'])\n        return self", "response": "TAOBAO fullinfo. get \u83b7\u53d6\u5355\u7b14\u4ea4\u6613\u7684\u8be6\u7ec6\u4fe1\u606f"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a memo to a session", "response": "def memo_add(self, tid, memo, session, flag=None):\n        '''taobao.trade.memo.add \u5bf9\u4e00\u7b14\u4ea4\u6613\u6dfb\u52a0\u5907\u6ce8\n        \n        \u6839\u636e\u767b\u5f55\u7528\u6237\u7684\u8eab\u4efd\uff08\u4e70\u5bb6\u6216\u5356\u5bb6\uff09\uff0c\u81ea\u52a8\u6dfb\u52a0\u76f8\u5e94\u7684\u4ea4\u6613\u5907\u6ce8,\u4e0d\u80fd\u91cd\u590d\u8c03\u7528\u4e9b\u63a5\u53e3\u6dfb\u52a0\u5907\u6ce8\uff0c\u9700\u8981\u66f4\u65b0\u5907\u6ce8\u8bf7\u7528taobao.trade.memo.update'''\n        request = TOPRequest('taobao.trade.memo.add')\n        request['tid'] = tid\n        request['memo'] = memo\n        if flag!=None: request['flag'] = flag\n        self.create(self.execute(request, session)['trade'])\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef postage_update(self, tid, post_fee, session):\n        '''taobao.trade.postage.update \u4fee\u6539\u8ba2\u5355\u90ae\u8d39\u4ef7\u683c\n        \n        \u4fee\u6539\u8ba2\u5355\u90ae\u8d39\u63a5\u53e3\uff0c\u901a\u8fc7\u4f20\u5165\u8ba2\u5355\u7f16\u53f7\u548c\u90ae\u8d39\u4ef7\u683c\uff0c\u4fee\u6539\u8ba2\u5355\u7684\u90ae\u8d39\uff0c\u8fd4\u56de\u4fee\u6539\u65f6\u95f4modified,\u90ae\u8d39post_fee,\u603b\u8d39\u7528total_fee\u3002'''\n        request = TOPRequest('taobao.trade.postage.update')\n        request['tid'] = tid\n        request['post_fee'] = post_fee\n        self.create(self.execute(request, session)['trade'])\n        return self", "response": "TAOBAO. trade. postage. update \u4fee\u6539\u8ba2\u5355\u90ae\u8d39\u63a5\u53e3\uff0c\u901a\u8fc7\u4f20\u5165\u8ba2\u5355\u7684\u90ae\u8d39\u4ef7\u683c\uff0c\u901a\u8fc7\u4f20\u5165\u8ba2\u5355\u90ae\u8d39"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef shippingaddress_update(self, tid, session, **kwargs):\n        '''taobao.trade.shippingaddress.update \u66f4\u6539\u4ea4\u6613\u7684\u6536\u8d27\u5730\u5740'''\n        request = TOPRequest('taobao.trade.shippingaddress.update')\n        request['tid'] = tid\n        for k, v in kwargs.iteritems():\n            if k not in ('receiver_name','receiver_phone','receiver_mobile','receiver_state','receiver_city','receiver_district','receiver_address','receiver_zip') or v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session)['trade'])\n        return self", "response": "TAOBAO. trade. shippingaddress. update \u66f4\u6539\u4ea4\u6613\u7684\u6536\u8d27\u5730\u5740"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, tid, is_detail, session):\n        '''taobao.trade.confirmfee.get \u83b7\u53d6\u4ea4\u6613\u786e\u8ba4\u6536\u8d27\u8d39\u7528\n        \n        \u83b7\u53d6\u4ea4\u6613\u786e\u8ba4\u6536\u8d27\u8d39\u7528 \u53ef\u4ee5\u83b7\u53d6\u4e3b\u8ba2\u5355\u6216\u5b50\u8ba2\u5355\u7684\u786e\u8ba4\u6536\u8d27\u8d39\u7528'''\n        request = TOPRequest('taobao.trade.confirmfee.get')\n        request['tid'] = tid\n        request['is_detail'] = is_detail\n        self.create(self.execute(request, session)['trade_confirm_fee'])\n        return self", "response": "TAOBAO. trade. confirmfee. get \u83b7\u53d6\u4ea4\u6613\u786e\u8ba4\u6536\u8d27\u8d39\u7528\u53ef\u4ee5\u83b7\u53d6\u4e3b\u8ba2\u5355\u7684\u786e\u8ba2\u5355"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexpand a dictionary of HTTP Header values into a string.", "response": "def header_expand(headers):\n    \"\"\"Returns an HTTP Header value string from a dictionary.\n\n    Example expansion::\n\n        {'text/x-dvi': {'q': '.8', 'mxb': '100000', 'mxt': '5.0'}, 'text/x-c': {}}\n        # Accept: text/x-dvi; q=.8; mxb=100000; mxt=5.0, text/x-c\n\n        (('text/x-dvi', {'q': '.8', 'mxb': '100000', 'mxt': '5.0'}), ('text/x-c', {}))\n        # Accept: text/x-dvi; q=.8; mxb=100000; mxt=5.0, text/x-c\n    \"\"\"\n\n    collector = []\n\n    if isinstance(headers, dict):\n        headers = headers.items()\n\n    elif isinstance(headers, basestring):\n        return headers\n\n    for i, (value, params) in enumerate(headers):\n\n        _params = []\n\n        for (p_k, p_v) in params.items():\n\n            _params.append('%s=%s' % (p_k, p_v))\n\n        collector.append(value)\n        collector.append('; ')\n\n        if len(params):\n\n            collector.append('; '.join(_params))\n\n            if not len(headers) == i+1:\n                collector.append(', ')\n\n\n    # Remove trailing separators.\n    if collector[-1] in (', ', '; '):\n        del collector[-1]\n\n    return ''.join(collector)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn n random bytes.", "response": "def randombytes(n):\n    \"\"\"Return n random bytes.\"\"\"\n    # Use /dev/urandom if it is available.  Fall back to random module\n    # if not.  It might be worthwhile to extend this function to use\n    # other platform-specific mechanisms for getting random bytes.\n    if os.path.exists(\"/dev/urandom\"):\n        f = open(\"/dev/urandom\")\n        s = f.read(n)\n        f.close()\n        return s\n    else:\n        L = [chr(random.randrange(0, 256)) for i in range(n)]\n        return \"\".join(L)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a key - value dictionary from a CookieJar object.", "response": "def dict_from_cookiejar(cj):\n    \"\"\"Returns a key/value dictionary from a CookieJar.\n\n    :param cj: CookieJar object to extract cookies from.\n    \"\"\"\n\n    cookie_dict = {}\n\n    for _, cookies in cj._cookies.items():\n        for _, cookies in cookies.items():\n            for cookie in cookies.values():\n                # print cookie\n                cookie_dict[cookie.name] = cookie.value\n\n    return cookie_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a CookieJar from a key - value dictionary.", "response": "def cookiejar_from_dict(cookie_dict):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    \"\"\"\n\n    # return cookiejar if one was passed in\n    if isinstance(cookie_dict, cookielib.CookieJar):\n        return cookie_dict\n\n    # create cookiejar\n    cj = cookielib.CookieJar()\n\n    cj = add_dict_to_cookiejar(cj, cookie_dict)\n\n    return cj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a CookieJar from a key - value dictionary.", "response": "def add_dict_to_cookiejar(cj, cookie_dict):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n\n    :param cj: CookieJar to insert cookies into.\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    \"\"\"\n\n    for k, v in cookie_dict.items():\n\n        cookie = cookielib.Cookie(\n            version=0,\n            name=k,\n            value=v,\n            port=None,\n            port_specified=False,\n            domain='',\n            domain_specified=False,\n            domain_initial_dot=False,\n            path='/',\n            path_specified=True,\n            secure=False,\n            expires=None,\n            discard=True,\n            comment=None,\n            comment_url=None,\n            rest={'HttpOnly': None},\n            rfc2109=False\n        )\n\n        # add cookie to cookiejar\n        cj.set_cookie(cookie)\n\n    return cj"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_encodings_from_content(content):\n\n    charset_re = re.compile(r'<meta.*?charset=[\"\\']*(.+?)[\"\\'>]', flags=re.I)\n\n    return charset_re.findall(content)", "response": "Returns a list of encodings from given content string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn encodings from given HTTP Header Dict.", "response": "def get_encoding_from_headers(headers):\n    \"\"\"Returns encodings from given HTTP Header Dict.\n\n    :param headers: dictionary to extract encoding from.\n    \"\"\"\n\n    content_type = headers.get('content-type')\n\n    if not content_type:\n        return None\n\n    content_type, params = cgi.parse_header(content_type)\n\n    if 'charset' in params:\n        return params['charset'].strip(\"'\\\"\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nattempting to decode an HTML string into unicode.", "response": "def unicode_from_html(content):\n    \"\"\"Attempts to decode an HTML string into unicode.\n    If unsuccessful, the original content is returned.\n    \"\"\"\n\n    encodings = get_encodings_from_content(content)\n\n    for encoding in encodings:\n\n        try:\n            return unicode(content, encoding)\n        except (UnicodeError, TypeError):\n            pass\n\n        return content"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stream_decode_response_unicode(iterator, r):\n    encoding = get_encoding_from_headers(r.headers)\n    if encoding is None:\n        for item in iterator:\n            yield item\n        return\n\n    decoder = codecs.getincrementaldecoder(encoding)(errors='replace')\n    for chunk in iterator:\n        rv = decoder.decode(chunk)\n        if rv:\n            yield rv\n    rv = decoder.decode('', final=True)\n    if rv:\n        yield rv", "response": "Stream decodes a response object into unicode strings."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stream_decode_gzip(iterator):\n    try:\n        dec = zlib.decompressobj(16 + zlib.MAX_WBITS)\n        for chunk in iterator:\n            rv = dec.decompress(chunk)\n            if rv:\n                yield rv\n        buf = dec.decompress('')\n        rv = buf + dec.flush()\n        if rv:\n            yield rv\n    except zlib.error:\n        pass", "response": "Stream decodes a gzip - encoded iterator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading your libspotify application key file.", "response": "def load_application_key_file(self, filename=b'spotify_appkey.key'):\n        \"\"\"Load your libspotify application key file.\n\n        If called without arguments, it tries to read ``spotify_appkey.key``\n        from the current working directory.\n\n        This is an alternative to setting :attr:`application_key` yourself. The\n        file must be a binary key file, not the C code key file that can be\n        compiled into an application.\n        \"\"\"\n        with open(filename, 'rb') as fh:\n            self.app_key = fh.read()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _do_layout(self, data):\n        c = data['output']\n        word_space = c.text_width(\n            ' ',\n            font_name=self.font_name,\n            font_size=self.font_size)\n\n        # Arrange the text as words on lines\n        self._layout = [[]]\n        x = self.font_size if self.paragraph_indent else 0\n        for word in self.text.split():\n            ww = c.text_width(\n                word,\n                font_name=self.font_name,\n                font_size=self.font_size)\n            if x + ww > self.width:\n                # Newline\n                x = 0\n                self._layout.append([])\n            self._layout[-1].append(word)\n            x += ww + word_space\n\n        # Work out the height we need\n        num_lines = len(self._layout)\n        self.height = (\n            num_lines * self.font_size +\n            (num_lines-1)*(self.font_size * (self.leading - 1.0))\n            )", "response": "This method is called by the _layout method of the base class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _build_response(self, resp, is_error=False):\n\n\n        def build(resp):\n\n            response = Response()\n\n            # Pass settings over.\n            response.config = self.config\n\n            if resp:\n\n                # Fallback to None if there's no staus_code, for whatever reason.\n                response.status_code = getattr(resp, 'status', None)\n\n                # Make headers case-insensitive.\n                response.headers = CaseInsensitiveDict(getattr(resp, 'headers', None))\n\n                # Start off with our local cookies.\n                cookies = self.cookies or dict()\n\n                # Add new cookies from the server.\n                if 'set-cookie' in response.headers:\n                    cookie_header = response.headers['set-cookie']\n\n                    c = SimpleCookie()\n                    c.load(cookie_header)\n\n                    for k,v in c.items():\n                        cookies.update({k: v.value})\n\n                # Save cookies in Response.\n                response.cookies = cookies\n\n            # Save original resopnse for later.\n            response.raw = resp\n\n            if is_error:\n                response.error = resp\n\n            response.url = self.full_url\n\n            return response\n\n\n        history = []\n\n        r = build(resp)\n        cookies = self.cookies\n        self.cookies.update(r.cookies)\n\n        if r.status_code in REDIRECT_STATI and not self.redirect:\n\n            while (\n                ('location' in r.headers) and\n                ((r.status_code is codes.see_other) or (self.allow_redirects))\n            ):\n\n                if not len(history) < self.config.get('max_redirects'):\n                    raise TooManyRedirects()\n\n                history.append(r)\n\n                url = r.headers['location']\n\n                # Handle redirection without scheme (see: RFC 1808 Section 4)\n                if url.startswith('//'):\n                    parsed_rurl = urlparse(r.url)\n                    url = '%s:%s' % (parsed_rurl.scheme, url)\n\n                # Facilitate non-RFC2616-compliant 'location' headers\n                # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n                if not urlparse(url).netloc:\n                    url = urljoin(r.url, urllib.quote(urllib.unquote(url)))\n\n                # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n                if r.status_code is codes.see_other:\n                    method = 'GET'\n                else:\n                    method = self.method\n\n                # Remove the cookie headers that were sent.\n                headers = self.headers\n                try:\n                    del headers['Cookie']\n                except KeyError:\n                    pass\n\n                request = Request(\n                    url=url,\n                    headers=headers,\n                    files=self.files,\n                    method=method,\n                    params=self.session.params,\n                    auth=self._auth,\n                    cookies=cookies,\n                    redirect=True,\n                    config=self.config,\n                    timeout=self.timeout,\n                    _poolmanager=self._poolmanager,\n                    proxies = self.proxies,\n                )\n\n                request.send()\n                cookies.update(request.response.cookies)\n                r = request.response\n                self.cookies.update(r.cookies)\n\n            r.history = history\n\n        self.response = r\n        self.response.request = self\n        self.response.cookies.update(self.cookies)", "response": "Build internal Response object from response object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _encode_params(data):\n\n        if hasattr(data, '__iter__'):\n            data = dict(data)\n\n        if hasattr(data, 'items'):\n            result = []\n            for k, vs in data.items():\n                for v in isinstance(vs, list) and vs or [vs]:\n                    result.append((k.encode('utf-8') if isinstance(k, unicode) else k,\n                                   v.encode('utf-8') if isinstance(v, unicode) else v))\n            return result, urllib.urlencode(result, doseq=True)\n        else:\n            return data, data", "response": "Encode parameters in a piece of data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef full_url(self):\n\n        if not self.url:\n            raise URLRequired()\n\n        # Support for unicode domain names and paths.\n        scheme, netloc, path, params, query, fragment = urlparse(self.url)\n\n        if not scheme:\n            raise ValueError()\n\n        netloc = netloc.encode('idna')\n\n        if isinstance(path, unicode):\n            path = path.encode('utf-8')\n\n        path = urllib.quote(urllib.unquote(path))\n\n        url = str(urlunparse([ scheme, netloc, path, params, query, fragment ]))\n\n        if self._enc_params:\n            if urlparse(url).query:\n                return '%s&%s' % (url, self._enc_params)\n            else:\n                return '%s?%s' % (url, self._enc_params)\n        else:\n            return url", "response": "Build the actual URL to use."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef path_url(self):\n\n        url = []\n\n        p = urlsplit(self.full_url)\n\n        # Proxies use full URLs.\n        if p.scheme in self.proxies:\n            return self.full_url\n\n        path = p.path\n        if not path:\n            path = '/'\n        url.append(path)\n\n        query = p.query\n        if query:\n            url.append('?')\n            url.append(query)\n\n        return ''.join(url)", "response": "Build the path URL to use."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(self, anyway=False, prefetch=False):\n\n        # Logging\n        if self.config.get('verbose'):\n            self.config.get('verbose').write('%s   %s   %s\\n' % (\n                datetime.now().isoformat(), self.method, self.url\n            ))\n\n        # Build the URL\n        url = self.full_url\n\n        # Nottin' on you.\n        body = None\n        content_type = None\n\n        # Multi-part file uploads.\n        if self.files:\n            if not isinstance(self.data, basestring):\n\n                try:\n                    fields = self.data.copy()\n                except AttributeError:\n                    fields = dict(self.data)\n\n                for (k, v) in self.files.items():\n                    fields.update({k: (guess_filename(k) or k, v.read())})\n\n                (body, content_type) = encode_multipart_formdata(fields)\n            else:\n                pass\n                # TODO: Conflict?\n        else:\n            if self.data:\n\n                body = self._enc_data\n                if isinstance(self.data, basestring):\n                    content_type = None\n                else:\n                    content_type = 'application/x-www-form-urlencoded'\n\n        # Add content-type if it wasn't explicitly provided.\n        if (content_type) and (not 'content-type' in self.headers):\n            self.headers['Content-Type'] = content_type\n\n\n        if self.auth:\n            auth_func, auth_args = self.auth\n\n            # Allow auth to make its changes.\n            r = auth_func(self, *auth_args)\n\n            # Update self to reflect the auth changes.\n            self.__dict__.update(r.__dict__)\n\n        _p = urlparse(url)\n        proxy = self.proxies.get(_p.scheme)\n\n        if proxy:\n            conn = poolmanager.proxy_from_url(proxy)\n        else:\n            # Check to see if keep_alive is allowed.\n            if self.config.get('keep_alive'):\n                conn = self._poolmanager.connection_from_url(url)\n            else:\n                conn = connectionpool.connection_from_url(url)\n\n        if not self.sent or anyway:\n\n            if self.cookies:\n\n                # Skip if 'cookie' header is explicitly set.\n                if 'cookie' not in self.headers:\n\n                    # Simple cookie with our dict.\n                    c = SimpleCookie()\n                    for (k, v) in self.cookies.items():\n                        c[k] = v\n\n                    # Turn it into a header.\n                    cookie_header = c.output(header='').strip()\n\n                    # Attach Cookie header to request.\n                    self.headers['Cookie'] = cookie_header\n\n            try:\n                # Send the request.\n                r = conn.urlopen(\n                    method=self.method,\n                    url=self.path_url,\n                    body=body,\n                    headers=self.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=prefetch,\n                    decode_content=False,\n                    retries=self.config.get('max_retries', 0),\n                    timeout=self.timeout,\n                )\n\n\n            except MaxRetryError, e:\n                if not self.config.get('safe_mode', False):\n                    raise ConnectionError(e)\n                else:\n                    r = None\n\n            except (_SSLError, _HTTPError), e:\n                if not self.config.get('safe_mode', False):\n                    raise Timeout('Request timed out.')\n\n            self._build_response(r)\n\n            # Response manipulation hook.\n            self.response = dispatch_hook('response', self.hooks, self.response)\n\n            # Post-request hook.\n            r = dispatch_hook('post_request', self.hooks, self)\n            self.__dict__.update(r.__dict__)\n\n            # If prefetch is True, mark content as consumed.\n            if prefetch:\n                self.response._content_consumed = True\n\n            return self.sent", "response": "Sends the request. Returns True if successful False if not."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\niterating over the content of the response.", "response": "def iter_content(self, chunk_size=10 * 1024, decode_unicode=None):\n        \"\"\"Iterates over the response data.  This avoids reading the content\n        at once into memory for large responses.  The chunk size is the number\n        of bytes it should read into memory.  This is not necessarily the\n        length of each item returned as decoding can take place.\n        \"\"\"\n        if self._content_consumed:\n            raise RuntimeError(\n                'The content for this response was already consumed'\n            )\n\n        def generate():\n            while 1:\n                chunk = self.raw.read(chunk_size)\n                if not chunk:\n                    break\n                yield chunk\n            self._content_consumed = True\n\n        gen = generate()\n\n        if 'gzip' in self.headers.get('content-encoding', ''):\n            gen = stream_decode_gzip(gen)\n\n        if decode_unicode is None:\n            decode_unicode = self.config.get('decode_unicode')\n\n        if decode_unicode:\n            gen = stream_decode_response_unicode(gen, self)\n\n        return gen"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the content of the response.", "response": "def content(self):\n        \"\"\"Content of the response, in bytes or unicode\n        (if available).\n        \"\"\"\n\n        if self._content is not None:\n            return self._content\n\n        if self._content_consumed:\n            raise RuntimeError('The content for this response was '\n                               'already consumed')\n\n        # Read the contents.\n        try:\n            self._content = self.raw.read()\n        except AttributeError:\n            return None\n\n\n        # Decode GZip'd content.\n        if 'gzip' in self.headers.get('content-encoding', ''):\n            try:\n                self._content = decode_gzip(self._content)\n            except zlib.error:\n                pass\n\n        # Decode unicode content.\n        if self.config.get('decode_unicode'):\n            self._content = get_unicode_from_response(self)\n\n        self._content_consumed = True\n        return self._content"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nraising HTTPError or URLError if one occurred.", "response": "def raise_for_status(self):\n        \"\"\"Raises stored :class:`HTTPError` or :class:`URLError`, if one occurred.\"\"\"\n\n        if self.error:\n            raise self.error\n\n        if (self.status_code >= 300) and (self.status_code < 400):\n            raise HTTPError('%s Redirection' % self.status_code)\n\n        elif (self.status_code >= 400) and (self.status_code < 500):\n            raise HTTPError('%s Client Error' % self.status_code)\n\n        elif (self.status_code >= 500) and (self.status_code < 600):\n            raise HTTPError('%s Server Error' % self.status_code)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_fd(fileobj):\n    if isinstance(fileobj, int):\n        fd = fileobj\n    else:\n        try:\n            fd = fileobj.fileno()\n        except AttributeError:\n            fd = None\n    if fd is None or fd < 0:\n        raise ValueError(\"invalid fileobj: {!r}\".format(fileobj))\n    return fd", "response": "Get a file descriptor number out of a file object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new _EpollSelectorEvents instance from an epoll_events bit mask.", "response": "def from_epoll_events(cls, epoll_events):\n        \"\"\"\n        Create a :class:`_EpollSelectorEvents` instance out of a bit mask using\n        ``EPOLL*`` family of constants.\n        \"\"\"\n        self = cls()\n        if epoll_events & select.EPOLLIN:\n            self |= EVENT_READ\n        if epoll_events & select.EPOLLOUT:\n            self |= EVENT_WRITE\n        # Treat EPOLLHUP specially, as both 'read and write ready' so that on\n        # the outside this can be interpreted as EOF\n        if epoll_events & select.EPOLLHUP:\n            self |= EVENT_READ | EVENT_WRITE\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a bit mask of the events that are set for this event.", "response": "def get_epoll_events(self):\n        \"\"\"\n        Create a bit mask using ``EPOLL*`` family of constants.\n        \"\"\"\n        epoll_events = 0\n        if self & EVENT_READ:\n            epoll_events |= select.EPOLLIN\n        if self & EVENT_WRITE:\n            epoll_events |= select.EPOLLOUT\n        return epoll_events"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves interest in IO events from the specified fileobj.", "response": "def unregister(self, fileobj):\n        \"\"\"\n        Remove interest in IO events from the specified fileobj\n\n        :param fileobj:\n            Any existing file-like object that has a fileno() method and was\n            previously registered with :meth:`register()`\n        :raises ValueError:\n            if `fileobj` is invalid or not supported\n        :raises KeyError:\n            if the descriptor associated with `fileobj` is not registered.\n        :returns:\n            A :class:`SelectorKey` associated with the passed arguments\n        \"\"\"\n        fd = _get_fd(fileobj)\n        key = self._fd_map[fd]\n        try:\n            self._epoll.unregister(fd)\n        except OSError:\n            pass\n        del self._fd_map[fd]\n        return key"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmodify interest in specified IO events on the specified file - like object.", "response": "def modify(self, fileobj, events, data=None):\n        \"\"\"\n        Modify interest in specified IO events on the specified file object\n\n        :param fileobj:\n            Any existing file-like object that has a fileno() method\n        :param events:\n            A bitmask composed of EVENT_READ and EVENT_WRITE\n        :param data:\n            (optional) Arbitrary data\n        :raises ValueError:\n            if `fileobj` is invalid or not supported\n        :raises KeyError:\n            if the descriptor associated with `fileobj` is not registered.\n        :returns:\n            The new :class:`SelectorKey` associated with the passed arguments\n        \"\"\"\n        fd = _get_fd(fileobj)\n        epoll_events = _EpollSelectorEvents(events).get_epoll_events()\n        if fd not in self._fd_map:\n            raise KeyError(\"{!r} is not registered\".format(fileobj))\n        key = SelectorKey(fileobj, fd, events, data)\n        self._fd_map[fd] = key\n        self._epoll.modify(fd, epoll_events)\n        return key"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef select(self, timeout=None):\n        if timeout is None:\n            epoll_timeout = -1\n        elif timeout <= 0:\n            epoll_timeout = 0\n        else:\n            epoll_timeout = timeout\n        max_events = len(self._fd_map) or -1\n        result = []\n        for fd, epoll_events in self._epoll.poll(epoll_timeout, max_events):\n            key = self._fd_map.get(fd)\n            events = _EpollSelectorEvents.from_epoll_events(epoll_events)\n            events &= key.events\n            if key:\n                result.append((key, _EpollSelectorEvents(events)))\n        return result", "response": "Wait until one or more file objects become ready or until the timeout expires."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, campaign_id, budget, nick=None):\n        '''xxxxx.xxxxx.campaign.budget.update\n        ===================================\n        \u66f4\u65b0\u4e00\u4e2a\u63a8\u5e7f\u8ba1\u5212\u7684\u65e5\u9650\u989d'''\n        request = TOPRequest('xxxxx.xxxxx.campaign.budget.update')\n        request['campaign_id'] = campaign_id\n        request['budget'] = budget\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), fields=['success','result','success','result_code','result_message'], models={'result':CampaignBudget})\n        return self.result", "response": "xxxxx. xxxxxx. campaign. budget. update\n        =================================== update\n        \u66f4\u65b0\u4e00\u4e2a\u63a8\u5e7f\u8ba1\u5212\u7684\u65e5\u9650\u989d"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, campaign_id, area, nick=None):\n        '''xxxxx.xxxxx.campaign.area.update\n        ===================================\n        \u66f4\u65b0\u4e00\u4e2a\u63a8\u5e7f\u8ba1\u5212\u7684\u6295\u653e\u5730\u57df'''\n        request = TOPRequest('xxxxx.xxxxx.campaign.area.update')\n        request['campaign_id'] = campaign_id\n        request['area'] = area\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), fields=['success','result','success','result_code','result_message'], models={'result':CampaignArea})\n        return self.result", "response": "xxxxx. xxxxxx. campaign. area. update\n        =================================== update\n        \u66f4\u65b0\u4e00\u4e2a\u63a8\u5e7f\u8ba1\u5212\u7684\u6295\u653e\u5730\u57df"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, campaign_id, schedule, nick=None):\n        '''xxxxx.xxxxx.campaign.schedule.update\n        ===================================\n        \u66f4\u65b0\u4e00\u4e2a\u63a8\u5e7f\u8ba1\u5212\u7684\u5206\u65f6\u6298\u6263\u8bbe\u7f6e'''\n        request = TOPRequest('xxxxx.xxxxx.campaign.schedule.update')\n        request['campaign_id'] = campaign_id\n        request['schedule'] = schedule\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), fields=['success','result','success','result_code','result_message'], models={'result':CampaignSchedule})\n        return self.result", "response": "xxxxx. xxxxxx. campaign. schedule. update\n        =================================== update\n        \u66f4\u65b0\u4e00\u4e2a\u63a8\u5e7f\u8ba1\u5212\u7684\u5206\u65f6\u6298\u6263\u8bbe\u7f6e"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, adgroup_id, catmatch_id, max_price, is_default_price, online_status, nick=None):\n        '''xxxxx.xxxxx.adgroup.catmatch.update\n        ===================================\n        \u66f4\u65b0\u4e00\u4e2a\u63a8\u5e7f\u7ec4\u7684\u7c7b\u76ee\u51fa\u4ef7\uff0c\u53ef\u4ee5\u8bbe\u7f6e\u7c7b\u76ee\u51fa\u4ef7\u3001\u662f\u5426\u4f7f\u7528\u9ed8\u8ba4\u51fa\u4ef7\u3001\u662f\u5426\u6253\u5f00\u7c7b\u76ee\u51fa\u4ef7'''\n        request = TOPRequest('xxxxx.xxxxx.adgroup.catmatch.update')\n        request['adgroup_id'] = adgroup_id\n        request['catmatch_id'] = catmatch_id\n        request['max_price'] = max_price\n        request['is_default_price'] = is_default_price\n        request['online_status'] = online_status\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), fields=['success','result','success','result_code','result_message'], models={'result':ADGroupCatmatch})\n        return self.result", "response": "xxxxx. xxxxxx. adgroup. catmatch. update\n        \u53ef\u4ee5\u8bbe\u7f6e\u7c7b\u76ee\u51fa\u4ef7\uff0c\u53ef\u4ee5\u8bbe\u7f6e\u7c7b\u76ee\u51fa\u4ef7\uff0c\u53ef\u4ee5\u8bbe\u7f6e\u7c7b\u76ee\u51fa\u4ef7\uff0c\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, adgroup_id, title, img_url, nick=None):\n        '''xxxxx.xxxxx.creative.add\n        ===================================\n        \u521b\u5efa\u4e00\u4e2a\u521b\u610f'''\n        request = TOPRequest('xxxxx.xxxxx.creative.add')\n        request['adgroup_id'] = adgroup_id\n        request['title'] = title\n        request['img_url'] = img_url\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), fields=['success','result','success','result_code','result_message'], models = {'result':Creative})\n        return self.result", "response": "xxxxx. xxxxxx. creative. add\n        ==================================="}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self):\n        '''xxxxx.xxxxx.campaign.areaoptions.get\n        ===================================\n        \u53d6\u5f97\u63a8\u5e7f\u8ba1\u5212\u7684\u53ef\u8bbe\u7f6e\u6295\u653e\u5730\u57df\u5217\u8868'''\n        request = TOPRequest('xxxxx.xxxxx.campaign.areaoptions.get')\n        self.create(self.execute(request), fields=['success','result'], models={'result':AreaOption})\n        return self.result", "response": "xxxxx. xxxxxx. campaign. areaoptions. get \u53d6\u5f97\u63a8\u5e7f\u8ba1\u5212\u7684\u53ef\u8bbe\u7f6e\u6295\u653e\u5730\u57df\u5217\u8868"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, campaign_id, item_id, default_price, title, img_url, nick=None):\n        '''xxxxx.xxxxx.adgroup.add\n        ===================================\n        \u521b\u5efa\u4e00\u4e2a\u63a8\u5e7f\u7ec4'''\n        request = TOPRequest('xxxxx.xxxxx.adgroup.add')\n        request['campaign_id'] = campaign_id\n        request['item_id'] = item_id\n        request['default_price'] = default_price\n        request['title'] = title\n        request['img_url'] = img_url\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), fields=['success','result','success','result_code','result_message'], models={'result':ADGroup})\n        return self.result", "response": "xxxxx. xxxxxx. adgroup. add\n        =================================== \u521b\u5efa\u4e00\u4e2a\u63a8\u5e7f\u7ec4"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, adgroup_id, default_price, nonsearch_max_price, is_nonsearch_default_price, online_status, campaign_id, nick=None):\n        '''xxxxx.xxxxx.adgroup.update\n        ===================================\n        \u66f4\u65b0\u4e00\u4e2a\u63a8\u5e7f\u7ec4\u7684\u4fe1\u606f\uff0c\u53ef\u4ee5\u8bbe\u7f6e\u9ed8\u8ba4\u51fa\u4ef7\u3001\u662f\u5426\u4e0a\u7ebf\u3001\u975e\u641c\u7d22\u51fa\u4ef7\u3001\u975e\u641c\u7d22\u662f\u5426\u4f7f\u7528\u9ed8\u8ba4\u51fa\u4ef7'''\n        request = TOPRequest('xxxxx.xxxxx.adgroup.update')\n        request['adgroup_id'] = adgroup_id\n        request['default_price'] = default_price\n        request['nonsearch_max_price'] = nonsearch_max_price\n        request['is_nonsearch_default_price'] = is_nonsearch_default_price\n        request['online_status'] = online_status\n        request['campaign_id'] = campaign_id\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), fields=['success','result','success','result_code','result_message'], models={'result':ADGroup})\n        return self.result", "response": "xxxxx. xxxxxx. adgroup. update \u4fe1\u606f\uff0c\u53ef\u4ee5\u8bbe\u7f6e\u9ed8\u8ba4\u51fa\u4ef7\u3001\u975e\u641c\u7d22\u51fa\u4ef7\u3001\u975e\u641c\u7d22\u51fa\u4ef7\u3001\u975e\u641c\u7d22\u51fa\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef login(self, username, password=None, blob=None, zeroconf=None):\n\n        username = utils.to_char(username)\n\n        if password is not None:\n            password = utils.to_char(password)\n            spotifyconnect.Error.maybe_raise(\n                lib.SpConnectionLoginPassword(\n                    username, password))\n        elif blob is not None:\n            blob = utils.to_char(blob)\n            spotifyconnect.Error.maybe_raise(\n                lib.SpConnectionLoginBlob(username, blob))\n        elif zeroconf is not None:\n            spotifyconnect.Error.maybe_raise(\n                lib.SpConnectionLoginZeroConf(\n                    username, *zeroconf))\n        else:\n            raise AttributeError(\n                \"Must specify a login method (password, blob or zeroconf)\")", "response": "Authenticate to Spotify s servers."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nturns on the alsa_sink sink.", "response": "def on(self):\n        \"\"\"Turn on the alsa_sink sink.\n\n        This is done automatically when the sink is instantiated, so you'll\n        only need to call this method if you ever call :meth:`off` and want to\n        turn the sink back on.\n        \"\"\"\n        assert spotifyconnect._session_instance.player.num_listeners(\n            spotifyconnect.PlayerEvent.MUSIC_DELIVERY) == 0\n        spotifyconnect._session_instance.player.on(\n            spotifyconnect.PlayerEvent.MUSIC_DELIVERY, self._on_music_delivery)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef off(self):\n        spotifyconnect._session_instance.player.off(\n            spotifyconnect.PlayerEvent.MUSIC_DELIVERY, self._on_music_delivery)\n        assert spotifyconnect._session_instance.player.num_listeners(\n            spotifyconnect.PlayerEvent.MUSIC_DELIVERY) == 0\n        self._close()", "response": "Turn off the alsa_sink sink."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\npatches a given API function to not send.", "response": "def patched(f):\n    \"\"\"Patches a given API function to not send.\"\"\"\n\n    def wrapped(*args, **kwargs):\n\n        kwargs['return_response'] = False\n        kwargs['prefetch'] = True\n\n        return f(*args, **kwargs)\n\n    return wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send(r, pools=None):\n\n    if pools:\n        r._pools = pools\n\n    r.send()\n\n    return r.response", "response": "Sends a given Request object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef map(requests, prefetch=True, size=None):\n\n    if size:\n        pool = Pool(size)\n        pool.map(send, requests)\n        pool.join()\n    else:\n        jobs = [gevent.spawn(send, r) for r in requests]\n        gevent.joinall(jobs)\n\n    if prefetch:\n        [r.response.content for r in requests]\n\n    return [r.response for r in requests]", "response": "Concurrently converts a list of Requests to Responses."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _print_debug(self, *args):\n        if self.debuglevel > 1:\n            print(datetime.datetime.now().time(), *args, file=sys.stderr)\n        else:\n            print(*args, file=sys.stderr)", "response": "Method output debug message into stderr"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing provided hostname and extract port number", "response": "def _parse_host(cls, host='localhost', port=0):\n        \"\"\" Parse provided hostname and extract port number\n\n        :param host: Server hostname\n        :type host: string\n        :param port: Server port\n        :return: Tuple of (host, port)\n        :rtype: tuple\n        \"\"\"\n        if not port and (host.find(':') == host.rfind(':')):\n            i = host.rfind(':')\n            if i >= 0:\n                host, port = host[:i], host[i + 1:]\n                try:\n                    port = int(port)\n                except ValueError:\n                    raise OSError('nonnumeric port')\n        return host, port"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting to a host on a given port via a given proxy server.", "response": "def connect_proxy(self, proxy_host='localhost', proxy_port=0, proxy_type=socks.HTTP,\n                      host='localhost', port=0):\n        \"\"\"Connect to a host on a given port via proxy server\n\n        If the hostname ends with a colon (`:') followed by a number, and\n        there is no port specified, that suffix will be stripped off and the\n        number interpreted as the port number to use.\n\n        Note: This method is automatically invoked by __init__, if a host and proxy server are\n        specified during instantiation.\n\n        :param proxy_host: Hostname of proxy server\n        :type proxy_host: string\n\n        :param proxy_port: Port of proxy server, by default port for specified  proxy type is used\n        :type proxy_port: int\n\n        :param proxy_type: Proxy type to use (see socks.PROXY_TYPES for details)\n        :type proxy_type: int\n\n        :param host: Hostname of SMTP server\n        :type host: string\n\n        :param port: Port of SMTP server, by default smtplib.SMTP_PORT is used\n        :type port: int\n\n        :return: Tuple of (code, msg)\n        :rtype: tuple\n        \"\"\"\n        if proxy_type not in socks.DEFAULT_PORTS.keys():\n            raise NotSupportedProxyType\n        (proxy_host, proxy_port) = self._parse_host(host=proxy_host, port=proxy_port)\n        if not proxy_port:\n            proxy_port = socks.DEFAULT_PORTS[proxy_type]\n        (host, port) = self._parse_host(host=host, port=port)\n        if self.debuglevel > 0:\n            self._print_debug('connect: via proxy', proxy_host, proxy_port)\n        s = socks.socksocket()\n        s.set_proxy(proxy_type=proxy_type, addr=proxy_host, port=proxy_port)\n        s.settimeout(self.timeout)\n        if self.source_address is not None:\n            s.bind(self.source_address)\n        s.connect((host, port))\n        # todo\n        # Send CRLF in order to get first response from destination server.\n        # Probably it's needed only for HTTP proxies. Further investigation required.\n        s.sendall(bCRLF)\n        self.sock = s\n        (code, msg) = self.getreply()\n        if self.debuglevel > 0:\n            self._print_debug('connect:', repr(msg))\n        return code, msg"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef enabled(self):\n        if self._status == self.SR_UNSUPPORTED:\n            return False\n        status = c_int()\n        try:\n            prctl(PR_GET_CHILD_SUBREAPER, addressof(status), 0, 0, 0)\n        except OSError:\n            self._status = self.SR_UNSUPPORTED\n        else:\n            self._status = self.SR_ENABLED if status else self.SR_DISABLED\n            return self._status == self.SR_ENABLED", "response": "Returns True if the child sub - reaper flag of the current process is set to True."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _sign(self,params):\n        '''\n        Generate API sign code\n        '''\n        for k, v in params.iteritems():\n            if type(v) == int: v = str(v)\n            elif type(v) == float: v = '%.2f'%v\n            elif type(v) in (list, set): \n                v = ','.join([str(i) for i in v])\n            elif type(v) == bool: v = 'true' if v else 'false'\n            elif type(v) == datetime.datetime: v = v.strftime('%Y-%m-%d %X')\n            if type(v) == unicode:\n                params[k] = v.encode('utf-8')\n            else:\n                params[k] = v\n        src = self.APP_SECRET + ''.join([\"%s%s\" % (k, v) for k, v in sorted(params.iteritems())])\n        return md5(src).hexdigest().upper()", "response": "Generate API sign code\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexecutes a single request and return the response.", "response": "def execute(self, request, session=None, method='post'):\n        '''\n        pyTOP.API -- TOPRequest instance\n        '''\n        params = {\n            'app_key' : self.API_KEY,  \n            'v'       : self.API_VERSION,\n            'format'  : self.FORMAT,\n            #'sign_method' : self.SIGN_METHOD,\n            'partner_id'  : self.SDK_VERSON\n        }\n        api_params = request.get_api_params()\n        params['timestamp'] = self._get_timestamp()\n        params['method'] = request.get_method_name()\n        if session is not None :\n            params['session'] = session\n        params.update(api_params)\n        params['sign'] = self._sign(params)\n        #print params\n        method = method.lower()\n        if method == 'get':\n            form_data = urllib.urlencode(params)\n            rsp = requests.get('%s?%s'%(self.GATEWAY, form_data))\n        elif method == 'post':\n            rsp = requests.post(self.GATEWAY, data=params)\n        rsp = json.loads(rsp.content)\n        if rsp.has_key('error_response'):\n            error_code = rsp['error_response']['code']\n            if 'sub_msg' in rsp['error_response']:\n                msg = '%s [%s]'%(rsp['error_response']['sub_msg'], rsp['error_response']['msg'])\n            else:\n                msg = rsp['error_response']['msg']\n            raise TOPException(error_code, msg)\n        else:\n            #pprint(rsp)\n            rsp = rsp[request.get_method_name().replace('.','_')[7:] + '_response']\n            if not rsp: return None\n            return rsp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, data, fields=[], models={}):\n        '''\n        Create model attributes\n        '''\n        if not fields: fields = self.fields\n        if not models and hasattr(self, 'models'): models = self.models\n        for field in fields:\n            setattr(self,field,None)\n        if not data: return None\n        for k, v in data.iteritems():\n            if type(v) in (str, unicode):\n                v = v.strip()\n            if models and k in models:\n                if type(v) == dict:\n                    lists = []\n                    for k2, v2 in v.iteritems():\n                        if type(v2) == list:\n                            for d in v2:\n                                model = models[k]()\n                                lists.append(model.create(d))\n                    if not lists:\n                        model = models[k]()\n                        v = model.create(v)\n                    else:\n                        v = lists\n                else:\n                    model = models[k]()\n                    v = model.create(v)\n            setattr(self,k,v)\n        return self", "response": "Create a new instance of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the rotated minimum size.", "response": "def get_minimum_size(self, data):\n        \"\"\"Returns the rotated minimum size.\"\"\"\n        size = self.element.get_minimum_size(data)\n        if self.angle in (RotateLM.NORMAL, RotateLM.UPSIDE_DOWN):\n            return size\n        else:\n            return datatypes.Point(size.y, size.x)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _calculate_ms_from_base(self, size):\n        hw = size.x * 0.5\n        hh = size.y * 0.5\n\n        a = datatypes.Point(hw, hh).get_rotated(self.angle)\n        b = datatypes.Point(-hw, hh).get_rotated(self.angle)\n        c = datatypes.Point(hw, -hh).get_rotated(self.angle)\n        d = datatypes.Point(-hw, -hh).get_rotated(self.angle)\n\n        minp = a.get_minimum(b).get_minimum(c).get_minimum(d)\n        maxp = a.get_maximum(b).get_maximum(c).get_maximum(d)\n        return maxp - minp", "response": "Calculates the rotated minimum size from the given base minimum\n        size."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, name):\n        # read the attribute\n        attr = getattr(self.context, name, None)\n        if callable(attr):\n            return attr()\n        return attr", "response": "Get a JSON compatible structure for the named attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a JSON compatible value of the field name", "response": "def json_data(self, name, default=None):\n        \"\"\"Get a JSON compatible value of the field\n        \"\"\"\n        value = self.get(name)\n        if value is Missing.Value:\n            return default\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the value by name", "response": "def get(self, name):\n        \"\"\"Get the value by name\n        \"\"\"\n\n        # check read permission\n        sm = getSecurityManager()\n        permission = permissions.View\n        if not sm.checkPermission(permission, self.context):\n            raise Unauthorized(\"Not allowed to view the Plone portal\")\n\n        # read the attribute\n        attr = getattr(self.context, name, None)\n        if callable(attr):\n            return attr()\n\n        # XXX no really nice, but we want the portal to behave like an ordinary\n        # content type. Therefore we need to inject the neccessary data.\n        if name == \"uid\":\n            return \"0\"\n        if name == \"path\":\n            return \"/%s\" % self.context.getId()\n        return attr"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the attribute to the given value.", "response": "def set(self, name, value, **kw):\n        \"\"\"Set the attribute to the given value.\n\n        The keyword arguments represent the other attribute values\n        to integrate constraints to other values.\n        \"\"\"\n\n        # check write permission\n        sm = getSecurityManager()\n        permission = permissions.ManagePortal\n        if not sm.checkPermission(permission, self.context):\n            raise Unauthorized(\"Not allowed to modify the Plone portal\")\n\n        # set the attribute\n        if not hasattr(self.context, name):\n            return False\n        self.context[name] = value\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, name, value, **kw):\n\n        # fetch the field by name\n        field = api.get_field(self.context, name)\n\n        # bail out if we have no field\n        if not field:\n            return False\n\n        # call the field adapter and set the value\n        fieldmanager = IFieldManager(field)\n        return fieldmanager.set(self.context, value, **kw)", "response": "Set the value of the given field."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef json_data(self, name):\n\n        # Check the write permission of the context\n        # XXX: This should be done on field level by the field manager adapter\n        if not self.can_write():\n            raise Unauthorized(\"You are not allowed to modify this content\")\n\n        # fetch the field by name\n        field = api.get_field(self.context, name)\n\n        # bail out if we have no field\n        if not field:\n            return None\n\n        fieldmanager = IFieldManager(field)\n        return fieldmanager.json_data(self.context)", "response": "Get a JSON compatible structure for the named attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef can_write(self):\n        sm = getSecurityManager()\n        permission = permissions.ModifyPortalContent\n\n        if not sm.checkPermission(permission, self.context):\n            return False\n        return True", "response": "Check if the field is writeable by the current user"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef can_read(self):\n        sm = getSecurityManager()\n        if not sm.checkPermission(permissions.View, self.context):\n            return False\n        return True", "response": "Check if the field is readable"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_s3(self, bucket, element):  # pragma: no cover\n        session = boto3.Session(profile_name=self.profile_name)\n        s3 = session.resource('s3')\n\n        try:\n            s3.meta.client.head_bucket(Bucket=bucket)\n        except ClientError:\n            # If the bucket does not exists then simply use the original\n            # I silently fail returning everything as it is in the url\n            return False\n        try:\n            # If the key does not exists do not return False, but try to\n            # create a readonly user in order to not have problems into the\n            # travis environment.\n            s3.Object(bucket, element).load()\n        except ClientError:\n            return False\n        else:\n            return True", "response": "Check if the object exists in S3."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cache_s3(self, url, named):  # pragma: no cover\n        # **Technical Notes:**\n        #\n        # Even if the tries are looking nested, this is perfect valid for\n        # this case:\n        # https://docs.python.org/3/glossary.html#term-eafp.\n        #\n        # The Coverage was excluded in order to avoid decrease it because an\n        # unused tool.\n        url_parsed = urlparse(url)\n        if self.domain == urlparse(url).netloc:\n            # If I am asking for the same domain it is probably because it\n            # exists BTW\n            return url\n\n        # Get the service resource\n        session = boto3.Session(profile_name=self.profile_name)\n        s3 = session.resource('s3')\n        client = session.client('s3')\n        element = url_parsed.path[1:]\n\n        # Get the bucket object (I am not connected yet this is setting a\n        # local object in memory only)\n        bucket = s3.Bucket(self.domain)\n\n        # Dear future me there MUST be a more elegant way to do this.\n        new_url = 'http://%s/%s' % (self.domain, element)\n\n        if self.check_s3(bucket.name, element):\n            return new_url\n\n        # Look a way this code is not tested in coverage because this MUST run\n        # locally due to s3 credentials.\n        try:  # pragma: no cover\n            # No coverage code unreachable on travis 'intentionally'\n            transfer = S3Transfer(client)\n            # Making the object public\n            transfer.upload_file(named, bucket.name, element,\n                                 extra_args={'ACL': 'public-read'})\n        except ClientError as inst:  # pragma: no cover\n            # No coverage code unreachable on travis 'intentionally'\n            print(inst.message)\n            return url\n        else:  # pragma: no cover\n            # No coverage code unreachable on travis 'intentionally'\n            return new_url", "response": "This method is used to cache the file at the specified location in S3."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes an url which deliver a plain document and convert it to a temporary file", "response": "def cache_it(self, url):\n        \"\"\"Take an url which deliver a plain document  and convert it to a\n        temporary file, this document is an xslt file expecting contains all\n        xslt definitions, then the cache process is recursive.\n\n        :param url: document origin url\n        :type url: str\n\n        :return file_path: local new absolute path\n        :rtype file_path: str\n        \"\"\"\n        # TODO: Use directly the file object instead of the name of the file\n        #       with seek(0)\n        cached = self._cache_it(url)\n        if not isfile(cached.name):\n            # If /tmp files are deleted\n            self._cache_it.cache_clear()\n            cached = self._cache_it(url)\n        return cached.name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the original chain given document path and xslt local path", "response": "def get_original(document, xslt):\n        \"\"\"Get the original chain given document path and xslt local path\n\n        :param str document: local absolute path to document\n        :param str xslt: local absolute path to xst file\n        :return: new chain generated.\n        :rtype: str\n        \"\"\"\n        dom = etree.parse(document)  # TODO: cuando este probando -\n        # fuente:\n        # http://stackoverflow.com/questions/16698935/how-to-transform-an-xml-file-using-xslt-in-python\n        xslt = etree.parse(xslt)\n        transform = etree.XSLT(xslt)\n        newdom = transform(dom)\n        return newdom"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncloses the internal signalfd file descriptor if it isn t closed.", "response": "def close(self):\n        \"\"\"\n        Close the internal signalfd file descriptor if it isn't closed\n\n        :raises OSError:\n            If the underlying ``close(2)`` fails. The error message matches\n            those found in the manual page.\n        \"\"\"\n        with self._close_lock:\n            sfd = self._sfd\n            if sfd >= 0:\n                self._sfd = -1\n                self._signals = frozenset()\n                close(sfd)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fromfd(cls, fd, signals):\n        if fd < 0:\n            _err_closed()\n        self = cls.__new__()\n        object.__init__(self)\n        self._sfd = fd\n        self._signals = signals\n        return self", "response": "Create a new signalfd object from a given file descriptor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the mask of signals this signalfd reacts to", "response": "def update(self, signals):\n        \"\"\"\n        Update the mask of signals this signalfd reacts to\n\n        :param signals:\n            A replacement set of signal numbers to monitor\n        :raises ValueError:\n            If :meth:`closed()` is True\n        \"\"\"\n        if self._sfd < 0:\n            _err_closed()\n        mask = sigset_t()\n        sigemptyset(mask)\n        if signals is not None:\n            for signal in signals:\n                sigaddset(mask, signal)\n        # flags are ignored when sfd is not -1\n        _signalfd(self._sfd, mask, 0)\n        self._signals = frozenset(signals)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads information about currently pending signals.", "response": "def read(self, maxsignals=None):\n        \"\"\"\n        Read information about currently pending signals.\n\n        :param maxsignals:\n            Maximum number of signals to read. By default this is the same\n            as the number of signals registered with this signalfd.\n        :returns:\n            A list of signalfd_siginfo object with information about most\n            recently read signals. This list may be empty (in non-blocking\n            mode).\n        :raises ValueError:\n            If :meth:`closed()` is True\n\n        Read up to maxsignals recent pending singals ouf of the set of signals\n        being monitored by this signalfd. If there are no signals yet and\n        SFD_NONBLOCK was not passed to flags in :meth:`__init__()` then this\n        call blocks until such signal is ready.\n        \"\"\"\n        if maxsignals is None:\n            maxsignals = len(self._signals)\n        if maxsignals <= 0:\n            raise ValueError(\"maxsignals must be greater than 0\")\n        info_list = (signalfd_siginfo * maxsignals)()\n        num_read = read(self._sfd, byref(info_list), sizeof(info_list))\n        return info_list[:num_read // sizeof(signalfd_siginfo)]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_curie(self, name, href):\n        self.draft.set_curie(self, name, href)\n        return self", "response": "Adds a CURIE link with the given name and href to the current CURIE document."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_link(self, rel, target, wrap=False, **kwargs):\n        if isinstance(target, bytes):\n            target = target.decode('utf-8')\n        if isinstance(target, str) or isinstance(target, unicode):\n            new_link = dict(href=target, **kwargs)\n        else:\n            new_link = dict(href=target.url(), **kwargs)\n\n        self._add_rel('_links', rel, new_link, wrap)\n        return self", "response": "Adds a link to the given target URL or target Builder object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nembed a document in this document with the given link relation type and target.", "response": "def embed(self, rel, target, wrap=False):\n        \"\"\"Embeds a document inside this document.\n\n        This method embeds the given document in this document with the given\n        ``rel``. If one or more documents have already been embedded for that\n        ``rel``, the new document will be embedded in addition to those\n        documents.\n\n        This method returns self, allowing it to be chained with additional\n        method calls.\n\n        Arguments:\n\n        - ``rel``: a string specifying the link relationship type of the\n          embedded resource. ``rel`` should be a well-known link relation name\n          from the IANA registry\n          (http://www.iana.org/assignments/link-relations/link-relations.xml),\n          a full URI, or a CURIE.\n        - ``target``: a ``Builder`` instance or a ``dougrain.Document``\n          instance that will be embedded in this document.\n        - ``wrap``: Defaults to False, but if True, specifies that the embedded\n          resource object should be initally wrapped in a JSON array even if it\n          is the first embedded resource for the given ``rel``.\n\n        Unlike ``dougrain.Document.embed``, this method does not detect\n        equivalence between relationship types with different representations.\n\n        WARNING: ``target`` should not be identical to ``self`` or any document\n        that embeds ``self``.\n        \"\"\"\n        new_embed = target.as_object()\n        self._add_rel('_embedded', rel, new_embed, wrap)\n\n        if self.draft.automatic_link:\n            self.add_link(rel, target, wrap)\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_rel(self, key, rel, thing, wrap):\n        self.o.setdefault(key, {})\n\n        if wrap:\n            self.o[key].setdefault(rel, [])\n\n        if rel not in self.o[key]:\n            self.o[key][rel] = thing\n            return\n\n        existing = self.o[key].get(rel)\n        if isinstance(existing, list):\n            existing.append(thing)\n            return\n\n        self.o[key][rel] = [existing, thing]", "response": "Adds thing to links or embedded resources."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsign the document with a third party signatory.", "response": "def sign(self, xml_doc):\n        \"\"\"Sign the document with a third party signatory.\n\n        :param str xml_doc: Document self signed in plain xml\n        :returns answer: Answer is given from the signatory\n            itself if connected.\n        \"\"\"\n        try:\n            self.client = Client(self.url)\n        except ValueError as e:\n            self.message = e.message\n        except URLError:\n            self.message = 'The url you provided: ' + \\\n                '%s could not be reached' % self.url"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dispatch_hook(key, hooks, hook_data):\n\n    hooks = hooks or dict()\n\n    if key in hooks:\n        try:\n            return hooks.get(key).__call__(hook_data) or hook_data\n\n        except Exception, why:\n            warnings.warn(str(why))\n\n    return hook_data", "response": "Dispatches a hook dictionary on a given piece of data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisable CSRF protection for the current page.", "response": "def disable_csrf_protection():\n    \"\"\" disables the CSRF protection\n        https://pypi.python.org/pypi/plone.protect\n    \"\"\"\n    if not HAS_PLONE_PROTECT:\n        logger.warn(\n            \"Can not disable CSRF protection \u2013 please install plone.protect\"\n        )\n        return False\n    request = get_request()\n    interface.alsoProvides(request, IDisableCSRFProtection)\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the key from the request", "response": "def get(key, default=None):\n    \"\"\" return the key from the request\n    \"\"\"\n    data = get_form() or get_query_string()\n    return data.get(key, default)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_true(key, default=False):\n    value = get(key, default)\n    if isinstance(value, list):\n        value = value[0]\n    if isinstance(value, bool):\n        return value\n    if value is default:\n        return default\n    return value.lower() in TRUE_VALUES", "response": "Check if the value is in TRUE_VALUES"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the sort_limit from the request", "response": "def get_sort_limit():\n    \"\"\" returns the 'sort_limit' from the request\n    \"\"\"\n    limit = _.convert(get(\"sort_limit\"), _.to_int)\n    if (limit < 1):\n        limit = None  # catalog raises IndexError if limit < 1\n    return limit"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_sort_on(allowed_indexes=None):\n    sort_on = get(\"sort_on\")\n    if allowed_indexes and sort_on not in allowed_indexes:\n        logger.warn(\"Index '{}' is not in allowed_indexes\".format(sort_on))\n        return None\n    return sort_on", "response": "returns the sort_on from the request\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the query from the request", "response": "def get_query():\n    \"\"\" returns the 'query' from the request\n    \"\"\"\n    q = get(\"q\", \"\")\n\n    qs = q.lstrip(\"*.!$%&/()=#-+:'`\u00b4^\")\n    if qs and not qs.endswith(\"*\"):\n        qs += \"*\"\n    return qs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract and convert the json data from the request returns a list of dictionaries", "response": "def get_request_data():\n    \"\"\" extract and convert the json data from the request\n\n    returns a list of dictionaries\n    \"\"\"\n    request = get_request()\n    data = request.get(\"BODY\", \"{}\")\n    if not is_json_deserializable(data):\n        from plone.jsonapi.routes.exceptions import APIError\n        raise APIError(400, \"Request Data is not JSON deserializable \u2013 Check JSON Syntax!\")\n    return _.convert(json.loads(data), _.to_list)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting json item on the fly", "response": "def set_json_item(key, value):\n    \"\"\" manipulate json data on the fly\n    \"\"\"\n    data = get_json()\n    data[key] = value\n\n    request = get_request()\n    request[\"BODY\"] = json.dumps(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_url(self, url, fields=None, **urlopen_kw):\n        return self.request_encode_url('GET', url, fields=fields,\n                                       **urlopen_kw)", "response": "Get the URL for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post_url(self, url, fields=None, headers=None, **urlopen_kw):\n        return self.request_encode_body('POST', url, fields=fields,\n                                        headers=headers,\n                                        **urlopen_kw)", "response": ".. deprecated:: 1.0\n           Use :meth:`request` instead."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef block(self):\n        if self._is_active:\n            return\n        if self._setmask:\n            self._old_mask = sigset_t()\n            sigemptyset(self._old_mask)\n            self._do_mask(SIG_SETMASK, self._mask, self._old_mask)\n        else:\n            self._do_mask(SIG_BLOCK, self._mask, None)\n        self._is_active = True", "response": "Sets or blocks the current state of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunblock the current state of the current object.", "response": "def unblock(self):\n        \"\"\"\n        Use the masking function (``sigprocmask(2)`` or ``pthread_sigmask(3)``)\n        to unblock signals.\n\n        :raises ValueError:\n            If the old mask is not obtained yet. This only happens in when\n            ``setmask=True`` was passed to the initializer and ``unblock()`` is\n            called before ``block()`` was called.\n\n        This method uses either ``SIG_SETMASK`` or ``SIG_UNBLOCK``, depending\n        on how the object was constructed. Actual behavior differs as explained\n        below. In both cases the term *old mask* refers to the effective mask\n        that was obtained at the time :meth:`block()` was called.\n\n        - In the ``SIG_SETMASK`` mode the old mask is restored (overwrite)\n        - In the ``SIG_UNBLOCK`` mode the old mask is ignored and the desired\n          signals are unblocked (incremental change)\n\n        .. note::\n            This method is a no-op if signal blocking is currently inactive (as\n            determined by :meth:`is_active` returning False).\n        \"\"\"\n        if not self._is_active:\n            return\n        if self._setmask:\n            if self._old_mask is None:\n                raise ValueError(\"block() wasn't called yet!\")\n            self._do_mask(SIG_SETMASK, self._old_mask, None)\n            self._old_mask = None\n        else:\n            self._do_mask(SIG_UNBLOCK, self._mask, None)\n        self._is_active = False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a new instance of the class cls with the current set of blocked signals.", "response": "def get(cls):\n        \"\"\"\n        Use the masking function (``sigprocmask(2)`` or ``pthread_sigmask(3)``)\n        to obtain the mask of blocked signals\n\n        :returns:\n            A fresh :class:`sigprocmask` object.\n\n        The returned object behaves as it was constructed with the list of\n        currently blocked signals, ``setmask=False`` and as if the\n        :meth:`block()` was immediately called.\n\n        That is, calling :meth:`unblock()` will will cause those signals not to\n        be blocked anymore while calling :meth:`block()` will re-block them (if\n        they were unblocked after this method returns).\n        \"\"\"\n        mask = sigset_t()\n        sigemptyset(mask)\n        cls._do_mask(0, None, mask)\n        signals = []\n        for sig_num in range(1, NSIG):\n            if sigismember(mask, sig_num):\n                signals.append(sig_num)\n        self = cls(signals)\n        self._is_active = True\n        self._old_mask = mask\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a rounded rectangle", "response": "def rounded_rectangle_region(width, height, radius):\n  \"\"\"\n  Returns a rounded rectangle wx.Region\n  \"\"\"\n  bmp = wx.Bitmap.FromRGBA(width, height) # Mask color is #000000\n  dc = wx.MemoryDC(bmp)\n  dc.Brush = wx.Brush((255,) * 3) # Any non-black would do\n  dc.DrawRoundedRectangle(0, 0, width, height, radius)\n  dc.SelectObject(wx.NullBitmap)\n  bmp.SetMaskColour((0,) * 3)\n  return wx.Region(bmp)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call_after(lag):\n  def decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n      wrapper.timer.cancel() # Debounce\n      wrapper.timer = threading.Timer(lag, func, args=args, kwargs=kwargs)\n      wrapper.timer.start()\n    wrapper.timer = threading.Timer(0, lambda: None) # timer.cancel now exists\n    return wrapper\n  return decorator", "response": "A decorator for creating a function that cancels simultaneous calls."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef on_timer(self, evt):\n    ctrl_is_down = wx.GetKeyState(wx.WXK_CONTROL)\n    shift_is_down = wx.GetKeyState(wx.WXK_SHIFT)\n    ms = wx.GetMouseState()\n    new_pos = None\n\n    # New initialization when keys pressed change\n    if self._key_state != (ctrl_is_down, shift_is_down):\n      self._key_state = (ctrl_is_down, shift_is_down)\n\n      # Keep state at click\n      self._click_ms_x, self._click_ms_y = ms.x, ms.y\n      self._click_frame_x, self._click_frame_y = self.pos\n      self._click_frame_width, self._click_frame_height = self.size\n      self._click_opacity = self.opacity\n\n      # Avoids refresh when there's no move (stores last mouse state)\n      self._last_ms = ms.x, ms.y\n\n      # Quadrant at click (need to know how to resize)\n      width, height = self.size\n      self._quad_signal_x = 1 if (self._click_ms_x -\n                                  self._click_frame_x) / width > .5 else -1\n      self._quad_signal_y = 1 if (self._click_ms_y -\n                                  self._click_frame_y) / height > .5 else -1\n\n    # \"Polling watcher\" for mouse left button while it's kept down\n    if (wx.__version__ >= \"3\" and ms.leftIsDown) or \\\n       (wx.__version__ <  \"3\" and ms.leftDown):\n      if self._last_ms != (ms.x, ms.y): # Moved?\n        self._last_ms = (ms.x, ms.y)\n        delta_x = ms.x - self._click_ms_x\n        delta_y = ms.y - self._click_ms_y\n\n        # Change transparency / opacity\n        if shift_is_down:\n          self.opacity = max(MIN_OPACITY,\n                             min(MAX_OPACITY, self._click_opacity - delta_y)\n                            )\n\n        # Resize\n        if ctrl_is_down:\n          # New size\n          new_w = max(MIN_WIDTH, self._click_frame_width +\n                                 2 * delta_x * self._quad_signal_x\n                     )\n          new_h = max(MIN_HEIGHT, self._click_frame_height +\n                                  2 * delta_y * self._quad_signal_y\n                     )\n          self.size = new_w, new_h\n\n          # Center should be kept\n          center_x = self._click_frame_x + self._click_frame_width / 2\n          center_y = self._click_frame_y + self._click_frame_height / 2\n          new_pos = (center_x - new_w / 2,\n                     center_y - new_h / 2)\n\n        # Move the window\n        if not (ctrl_is_down or shift_is_down):\n          new_pos = (self._click_frame_x + delta_x,\n                     self._click_frame_y + delta_y)\n\n      if new_pos is not None:\n        self.pos = new_pos\n\n      # Since left button is kept down, there should be another one shot\n      # timer event again, without creating many timers like wx.CallLater\n      self._timer.Start(MOUSE_TIMER_WATCH, True)", "response": "Called when the mouse is moved or released."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start(self):\n    assert not self.watching\n\n    def selector(evt):\n      if evt.is_directory:\n        return False\n      path = evt.path\n      if path in self._last_fnames: # Detected a \"killing cycle\"\n        return False\n      for pattern in self.skip_pattern.split(\";\"):\n        if fnmatch(path, pattern.strip()):\n          return False\n      return True\n\n    def watchdog_handler(evt):\n      wx.CallAfter(self._watchdog_handler, evt)\n\n    # Force a first event\n    self._watching = True\n    self._last_fnames = []\n    self._evts = [None]\n    self._run_subprocess()\n\n    # Starts the watchdog observer\n    from .watcher import watcher\n    self._watcher = watcher(path=self.directory,\n                            selector=selector, handler=watchdog_handler)\n    self._watcher.__enter__()", "response": "Starts watching the path and running the test jobs."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncloses the popup menu and dose watcher", "response": "def on_close(self, evt):\n    \"\"\"\n    Pop-up menu and wx.EVT_CLOSE closing event\n    \"\"\"\n    self.stop() # DoseWatcher\n    if evt.EventObject is not self: # Avoid deadlocks\n      self.Close() # wx.Frame\n    evt.Skip()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the canonical key for the given key.", "response": "def canonical_key(self, key):\n        \"\"\"Returns the canonical key for the given ``key``.\"\"\"\n        if key.startswith('/'):\n            return urlparse.urljoin(self.base_uri, key)\n        else:\n            return self.curies.expand(key)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef url(self):\n        if not 'self' in self.links:\n            return None\n\n        self_link = self.links['self']\n\n        if isinstance(self_link, list):\n            for link in self_link:\n                return link.url()\n\n        return self_link.url()", "response": "Returns the URL for the resource based on the self link."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset a property on the document.", "response": "def set_property(self, key, value):\n        \"\"\"Set a property on the document.\n\n        Calling code should use this method to add and modify properties\n        on the document instead of modifying ``properties`` directly.\n\n        If ``key`` is ``\"_links\"`` or ``\"_embedded\"`` this method will silently\n        fail.\n\n        If there is no property with the name in ``key``, a new property is\n        created with the name from ``key`` and the value from ``value``. If\n        the document already has a property with that name, it's value\n        is replaced with the value in ``value``.\n\n        \"\"\"\n        if key in self.RESERVED_ATTRIBUTE_NAMES:\n            return\n        self.o[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_property(self, key):\n        if key in self.RESERVED_ATTRIBUTE_NAMES:\n            raise KeyError(key)\n        del self.o[key]", "response": "Remove a property from the document."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a link to the document with the given rel to the given target.", "response": "def add_link(self, rel, target, wrap=False, **kwargs):\n        \"\"\"Adds a link to the document.\n\n        Calling code should use this method to add links instead of\n        modifying ``links`` directly.\n\n        This method adds a link to the given ``target`` to the document with\n        the given ``rel``. If one or more links are already present for that\n        link relationship type, the new link will be added to the existing\n        links for that link relationship type.\n\n        If ``target`` is a string, a link is added with ``target`` as its\n        ``href`` property and other properties from the keyword arguments.\n\n        If ``target`` is a ``Link`` object, it is added to the document and the\n        keyword arguments are ignored.\n\n        If ``target`` is a ``Document`` object, ``target``'s ``self`` link is\n        added to this document and the keyword arguments are ignored.\n\n        If ``target`` is a ``Builder`` object, ``target``'s ``self`` link is\n        added to this document and the keyword arguments are ignored.\n\n        Arguments:\n\n        - ``rel``: a string specifying the link relationship type of the link.\n          It should be a well-known link relation name from the IANA registry\n          (http://www.iana.org/assignments/link-relations/link-relations.xml),\n          a full URI, or a CURIE.\n        - ``target``: the destination of the link.\n        - ``wrap``: Defaults to False, but if True, specifies that the link\n          object should be initally wrapped in a JSON array even if it is the\n          first link for the given ``rel``.\n\n        \"\"\"\n        if hasattr(target, 'as_link'):\n            link = target.as_link()\n        else:\n            link = self.link(target, **kwargs)\n\n        links = self.o.setdefault(LINKS_KEY, {})\n\n        new_link = link.as_object()\n        collected_links = CanonicalRels(links, self.curies, self.base_uri)\n        if rel not in collected_links:\n            if wrap:\n                links[rel] = [new_link]\n            else:\n                links[rel] = new_link\n            return\n\n        original_rel = collected_links.original_key(rel)\n\n        current_links = links[original_rel]\n        if isinstance(current_links, list):\n            current_links.append(new_link)\n        else:\n            links[original_rel] = [current_links, new_link]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting links from the document.", "response": "def delete_link(self, rel=None, href=lambda _: True):\n        \"\"\"Deletes links from the document.\n\n        Calling code should use this method to remove links instead of\n        modyfying ``links`` directly.\n\n        The optional arguments, ``rel`` and ``href`` are used to select the\n        links that will be deleted. If neither of the optional arguments are\n        given, this method deletes every link in the document. If ``rel`` is\n        given, only links for the matching link relationship type are deleted.\n        If ``href`` is given, only links with a matching ``href`` are deleted.\n        If both ``rel`` and ``href`` are given, only links with matching\n        ``href`` for the matching link relationship type are delted.\n\n        Arguments:\n\n        - ``rel``: an optional string specifying the link relationship type of\n                   the links to be deleted.\n        - ``href``: optionally, a string specifying the ``href`` of the links\n                    to be deleted, or a callable that returns true when its\n                    single argument is in the set of ``href``s to be deleted.\n\n        \"\"\"\n        if not LINKS_KEY in self.o:\n            return\n\n        links = self.o[LINKS_KEY]\n        if rel is None:\n            for rel in list(links.keys()):\n                self.delete_link(rel, href)\n            return\n\n        if callable(href):\n            href_filter = href\n        else:\n            href_filter = lambda x: x == href\n\n        links_for_rel = links.setdefault(rel, [])\n        if isinstance(links_for_rel, dict):\n            links_for_rel = [links_for_rel]\n\n        new_links_for_rel = []\n        for link in links_for_rel:\n            if not href_filter(link['href']):\n                new_links_for_rel.append(link)\n\n        if new_links_for_rel:\n            if len(new_links_for_rel) == 1:\n                new_links_for_rel = new_links_for_rel[0]\n\n            links[rel] = new_links_for_rel\n        else:\n            del links[rel]\n\n        if not self.o[LINKS_KEY]:\n            del self.o[LINKS_KEY]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new Document instance based on a dictionary containing the deserialized JSON.", "response": "def from_object(cls, o, base_uri=None, parent_curies=None, draft=AUTO):\n        \"\"\"Returns a new ``Document`` based on a JSON object or array.\n\n        Arguments:\n\n        - ``o``: a dictionary holding the deserializated JSON for the new\n                 ``Document``, or a ``list`` of such documents.\n        - ``base_uri``: optional URL used as the basis when expanding\n                               relative URLs in the document.\n        - ``parent_curies``: optional ``CurieCollection`` instance holding the\n                             CURIEs of the parent document in which the new\n                             document is to be embedded. Calling code should\n                             not normally provide this argument.\n        - ``draft``: a ``Draft`` instance that selects the version of the spec\n                     to which the document should conform. Defaults to\n                     ``drafts.AUTO``.\n\n        \"\"\"\n\n        if isinstance(o, list):\n            return [cls.from_object(x, base_uri, parent_curies, draft)\n                    for x in o]\n\n        return cls(o, base_uri, parent_curies, draft)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an empty Document instance.", "response": "def empty(cls, base_uri=None, draft=AUTO):\n        \"\"\"Returns an empty ``Document``.\n\n        Arguments:\n\n        - ``base_uri``: optional URL used as the basis when expanding\n                               relative URLs in the document.\n        - ``draft``: a ``Draft`` instance that selects the version of the spec\n                     to which the document should conform. Defaults to\n                     ``drafts.AUTO``.\n        \"\"\"\n        return cls.from_object({}, base_uri=base_uri, draft=draft)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef embed(self, rel, other, wrap=False):\n\n        if other == self:\n            return\n\n        embedded = self.o.setdefault(EMBEDDED_KEY, {})\n        collected_embedded = CanonicalRels(embedded,\n                                           self.curies,\n                                           self.base_uri)\n\n        if rel not in collected_embedded:\n            if wrap:\n                embedded[rel] = [other.as_object()]\n            else:\n                embedded[rel] = other.as_object()\n        else:\n            original_rel = collected_embedded.original_key(rel)\n\n            current_embedded = embedded[original_rel]\n            if isinstance(current_embedded, list):\n                current_embedded.append(other.as_object())\n            else:\n                embedded[original_rel] = [current_embedded, other.as_object()]\n\n        if not self.draft.automatic_link:\n            return\n\n        url = other.url()\n        if not url:\n            return\n\n        if url in (link.url() for link in self.links.get(rel, [])):\n            return\n\n        self.add_link(rel, other, wrap=wrap)", "response": "Embeds a document inside another document."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_embedded(self, rel=None, href=lambda _: True):\n        if EMBEDDED_KEY not in self.o:\n            return\n\n        if rel is None:\n            for rel in list(self.o[EMBEDDED_KEY].keys()):\n                self.delete_embedded(rel, href)\n            return\n\n        if rel not in self.o[EMBEDDED_KEY]:\n            return\n\n        if callable(href):\n            url_filter = href\n        else:\n            url_filter = lambda x: x == href\n\n        rel_embeds = self.o[EMBEDDED_KEY][rel]\n\n        if isinstance(rel_embeds, dict):\n            del self.o[EMBEDDED_KEY][rel]\n\n            if not self.o[EMBEDDED_KEY]:\n                del self.o[EMBEDDED_KEY]\n            return\n\n        new_rel_embeds = []\n        for embedded in list(rel_embeds):\n            embedded_doc = Document(embedded, self.base_uri)\n            if not url_filter(embedded_doc.url()):\n                new_rel_embeds.append(embedded)\n\n        if not new_rel_embeds:\n            del self.o[EMBEDDED_KEY][rel]\n        elif len(new_rel_embeds) == 1:\n            self.o[EMBEDDED_KEY][rel] = new_rel_embeds[0]\n        else:\n            self.o[EMBEDDED_KEY][rel] = new_rel_embeds\n\n        if not self.o[EMBEDDED_KEY]:\n            del self.o[EMBEDDED_KEY]", "response": "Removes an embedded resource from this document."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves a CURIE. The CURIE link with the given name is removed from the document.", "response": "def drop_curie(self, name):\n        \"\"\"Removes a CURIE.\n\n        The CURIE link with the given name is removed from the document.\n\n        \"\"\"\n        curies = self.o[LINKS_KEY][self.draft.curies_rel]\n        if isinstance(curies, dict) and curies['name'] == name:\n            del self.o[LINKS_KEY][self.draft.curies_rel]\n            return\n\n        for i, curie in enumerate(curies):\n            if curie['name'] == name:\n                del curies[i]\n                break\n\n            continue"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef customer_permit(self, session):\n        '''taobao.increment.customer.permit \u5f00\u901a\u589e\u91cf\u6d88\u606f\u670d\u52a1\n        \n        \u63d0\u4f9bapp\u4e3a\u81ea\u5df1\u7684\u7528\u6237\u5f00\u901a\u589e\u91cf\u6d88\u606f\u670d\u52a1\u529f\u80fd'''\n        request = TOPRequest('taobao.increment.customer.permit')\n        self.create(self.execute(request, session), fields=['app_customer',], models={'app_customer':AppCustomer})\n        return self.app_customer", "response": "TAOBAO. increment. customer. permit \u5f00\u901a\u589e\u91cf\u6d88\u606f\u670d\u52a1\u529f\u80fd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refunds_get(self, **kwargs):\n        '''taobao.increment.refunds.get \u83b7\u53d6\u9000\u6b3e\u53d8\u66f4\u901a\u77e5\u4fe1\u606f\n        \n        \u5f00\u901a\u4e3b\u52a8\u901a\u77e5\u4e1a\u52a1\u7684APP\u53ef\u4ee5\u901a\u8fc7\u8be5\u63a5\u53e3\u83b7\u53d6\u7528\u6237\u7684\u9000\u6b3e\u53d8\u66f4\u901a\u77e5\u4fe1\u606f \u5efa\u8bae\u5728\u83b7\u53d6\u589e\u91cf\u6d88\u606f\u7684\u65f6\u95f4\u95f4\u9694\u662f\uff1a\u534a\u4e2a\u5c0f\u65f6'''\n        request = TOPRequest('taobao.increment.refunds.get')\n        for k, v in kwargs.iteritems():\n            if k not in ('status', 'nick', 'start_modified', 'end_modified', 'page_no', 'page_size') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request), fields=['notify_refunds', 'total_results'], models={'notify_refunds':NotifyRefund})\n        return self.notify_refunds", "response": "TAOBAO. increment. refunds. get \u83b7\u53d6\u9000\u6b3e\u53d8\u66f4\u901a\u77e5\u4fe1\u606f \u53d6\u9000\u6b3e\u53d8\u66f4\u901a\u77e5\u4fe1\u606f "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a new Cigar object with all of the like operations.", "response": "def merge_like_ops(self):\n        \"\"\"\n        >>> Cigar(\"1S20M\").merge_like_ops()\n        Cigar('1S20M')\n        >>> Cigar(\"1S1S20M\").merge_like_ops()\n        Cigar('2S20M')\n        >>> Cigar(\"1S1S1S20M\").merge_like_ops()\n        Cigar('3S20M')\n        >>> Cigar(\"1S1S1S20M1S1S\").merge_like_ops()\n        Cigar('3S20M2S')\n        \"\"\"\n\n        cigs = []\n        for op, grps in groupby(self.items(), itemgetter(1)):\n            cigs.append((sum(g[0] for g in grps), op))\n\n        return Cigar(self.string_from_elements(cigs))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef runner(test_command, work_dir=None):\n    process = subprocess.Popen(test_command, bufsize=0, shell=True,\n                               cwd=work_dir,\n                               stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    with flush_stream_threads(process):\n        try:\n            yield process\n        finally:\n            if process.poll() is None:\n                process.terminate()", "response": "A context manager that runs a given test command in a subprocess and returns the process that was spawned."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nkilling the test job.", "response": "def kill(self, sig=signal.SIGTERM):\n        \"\"\"\n        Terminate the test job.\n\n        Kill the subprocess if it was spawned, abort the spawning\n        process otherwise. This information can be collected afterwards\n        by reading the self.killed and self.spawned flags.\n\n        Also join the 3 related threads to the caller thread. This can\n        be safely called from any thread.\n\n        This method behaves as self.join() when the thread isn't alive,\n        i.e., it doesn't raise an exception.\n\n        The ``sig`` parameter should be either:\n\n        * ``signal.SIGKILL`` (``9``), on Linux or OSX;\n        * ``signal.SIGTERM`` (``15``), the default value. On Windows\n          this one calls the ``TerminateProcess`` Win32 API function.\n        \"\"\"\n        while self.is_alive():\n            self.killed = True\n            time.sleep(POLLING_DELAY) # \"Was a process spawned?\" polling\n            if not self.spawned:\n                continue # Either self.run returns or runner yields\n            if self.process.poll() is None: # It's running\n                self.process.send_signal(sig)\n                try: # There's no os.WNOHANG in Windows\n                    os.waitpid(self.process.pid, getattr(os, \"WNOHANG\", 1))\n                except OSError: # Ignore \"No child processes\" error\n                    pass\n            break # We already either killed or finished it\n        self.join()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a load function based on schema dict and Validator class.", "response": "def loader(schema, validator=CerberusValidator, update=None):\n    \"\"\"Create a load function based on schema dict and Validator class.\n\n    :param schema: a Cerberus schema dict.\n    :param validator: the validator class which must be a subclass of\n        more.cerberus.CerberusValidator which is the default.\n    :param update: will pass the update flag to the validator, when ``True``\n        the ``required`` rules will not be checked.\n        By default it will be set for PUT and PATCH requests to ``True``\n        and for other requests to ``False``.\n\n    You can plug this ``load`` function into a json view.\n\n    Returns a ``load`` function that takes a request JSON body\n    and uses the schema to validate it. This function raises\n    :class:`more.cerberus.ValidationError` if validation is not successful.\n    \"\"\"\n    if not issubclass(validator, CerberusValidator):\n        raise TypeError(\n            \"Validator must be a subclass of more.cerberus.CerberusValidator\"\n        )\n    return partial(load, schema, validator, update)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmap a symbolic factorization to a block - diagonal structure with coupling constraints.", "response": "def symb_to_block(symb, coupling = 'full'):\n    \"\"\"\n    Maps a symbolic factorization to a block-diagonal structure with\n    coupling constraints.\n\n    :param symb:               :py:class:`symbolic`\n    :param coupling:           optional \n    :return dims:              list of block dimensions\n    :return sparse_to_block:   dictionary\n    :return constraints:       list of coupling constraints\n    \"\"\"\n\n    n = len(symb.snode)             # order of block\n    Ncliques = len(symb.snpar)      # number of cliques\n\n    # compute clique orders\n    dims = [symb.sncolptr[j+1]-symb.sncolptr[j] for j in range(Ncliques)]\n\n    # compute offsets in block-diagonal structure\n    offsets = [0]\n    for i in range(Ncliques): offsets.append(offsets[-1] + dims[i]**2)\n\n    constraints = []        # list of coupling constraints\n    sparse_to_block = {}    # conversion dictionary\n\n    for k in range(Ncliques):\n        # map nonzeros in {Jk,Nk} part of clique k to block-diagonal structure\n        nodes = symb.snode[symb.snptr[k]:symb.snptr[k+1]]\n        rows = symb.snrowidx[symb.sncolptr[k]:symb.sncolptr[k+1]]\n        nk = len(nodes)    # number of nodes in supernode\n        wk = len(rows)     # number of nodes in clique\n        for j in range(nk):\n            for i in range(j,wk):\n                if i == j:\n                    sparse_to_block[nodes[j]*n + rows[i]] = (offsets[k] + j*wk + i,)\n                else:\n                    sparse_to_block[nodes[j]*n + rows[i]] =(offsets[k] + j*wk + i, offsets[k] + i*wk + j)\n\n        # add coupling constraints to list of constraints\n        if symb.snpar[k] == k: continue   # skip if supernode k is a root supernode\n        p = symb.snpar[k]\n        np = len(symb.snode[symb.snptr[p]:symb.snptr[p+1]])\n        wp = symb.sncolptr[p+1] - symb.sncolptr[p]\n        ri = symb.relidx[symb.relptr[k]:symb.relptr[k+1]]\n\n        if type(coupling) is spmatrix:           \n            tmp = coupling[rows[nk:],rows[nk:]]\n            for i,j in zip(tmp.I,tmp.J):\n                if j == i:\n                    constraints.append((offsets[k] + (j+nk)*wk + i+nk,\n                                        offsets[p] + ri[j]*wp + ri[i]))\n                else:\n                    constraints.append((offsets[k] + (j+nk)*wk + i+nk,\n                                        offsets[p] + ri[j]*wp + ri[i],\n                                        offsets[k] + (i+nk)*wk + j+nk,\n                                        offsets[p] + ri[i]*wp + ri[j]))   \n                     \n        elif coupling == 'full':\n            for j in range(len(ri)):\n                for i in range(j,len(ri)):\n                    if j == i:\n                        constraints.append((offsets[k] + (j+nk)*wk + i+nk,\n                                            offsets[p] + ri[j]*wp + ri[i]))\n                    else:\n                        constraints.append((offsets[k] + (j+nk)*wk + i+nk,\n                                            offsets[p] + ri[j]*wp + ri[i],\n                                            offsets[k] + (i+nk)*wk + j+nk,\n                                            offsets[p] + ri[i]*wp + ri[j]))\n\n    return dims, sparse_to_block, constraints"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying the clique conversion method of Fukuda et al. to positive semidefinite blocks of a cone LP.", "response": "def convert_conelp(c, G, h, dims, A = None, b = None, **kwargs):\n    \"\"\"\n    Applies the clique conversion method of Fukuda et al. to the positive semidefinite blocks of a cone LP.\n\n    :param c:                 :py:class:`matrix`\n    :param G:                 :py:class:`spmatrix`\n    :param h:                 :py:class:`matrix`\n    :param dims:              dictionary\n    :param A:                 :py:class:`spmatrix` or :py:class:`matrix`\n    :param b:                 :py:class:`matrix`\n\n    The following example illustrates how to convert a cone LP:\n    \n    .. code-block:: python\n\n        prob = (c,G,h,dims,A,b)\n        probc, blk2sparse, symbs = convert_conelp(*prob)\n    \n    The return value `blk2sparse` is a list of 4-tuples\n    (`blki,I,J,n`) that each defines a mapping between the sparse\n    matrix representation and the converted block-diagonal\n    representation, and `symbs` is a list of symbolic factorizations\n    corresponding to each of the semidefinite blocks in the original cone LP.\n    \n    .. seealso::\n\n         M. Fukuda, M. Kojima, K. Murota, and K. Nakata, `Exploiting Sparsity\n         in Semidefinite Programming via Matrix Completion I: General Framework\n         <http://dx.doi.org/10.1137/S1052623400366218>`_,\n         SIAM Journal on Optimization, 11:3, 2001, pp. 647-674.\n\n         S. Kim, M. Kojima, M. Mevissen, and M. Yamashita, `Exploiting Sparsity\n         in Linear and Nonlinear Matrix Inequalities via Positive Semidefinite\n         Matrix Completion <http://dx.doi.org/10.1007/s10107-010-0402-6>`_,\n         Mathematical Programming, 129:1, 2011, pp.. 33-68.\n\n    \"\"\"\n\n    # extract linear and socp constraints\n    offsets = dims['l'] + sum(dims['q'])\n    G_lq = G[:offsets,:]\n    h_lq = h[:offsets,0]\n\n    # extract semidefinite blocks\n    G_s = G[offsets:,:]\n    h_s = h[offsets:,0]\n\n    G_converted = [G_lq]; h_converted = [h_lq]\n    G_coupling = []\n    dims_list = []\n    symbs = []\n    \n    offset = 0\n    block_to_sparse = []\n    for k, si in enumerate(dims['s']):\n        # extract block\n        G_b = G_s[offset:offset+si**2,:]\n        h_b = h_s[offset:offset+si**2,0]\n        offset += si**2\n\n        # convert block\n        blkk, b2s, F = convert_block(G_b, h_b, si, **kwargs)\n        G1, h1, G2, blkdims = blkk\n        G_converted.append(G1)\n        h_converted.append(h1)\n        dims_list.extend(blkdims)\n        block_to_sparse.append(b2s)\n        symbs.append(F)\n        if G2 is not None: G_coupling.append(G2)\n\n    G1 = sparse(G_converted)\n\n    I,J,V = [],[],[]\n    offset = [G_lq.size[0], 0]\n    for Gcpl in G_coupling:\n        I.append(Gcpl.I + offset[0])\n        J.append(Gcpl.J + offset[1])\n        V.append(Gcpl.V)\n        offset[0] += Gcpl.size[0]\n        offset[1] += Gcpl.size[1]\n    G2 = spmatrix([v for v in itertools.chain(*V)],\n                  [v for v in itertools.chain(*I)],\n                  [v for v in itertools.chain(*J)],tuple(offset))\n    \n    if offset[0] == 0 or offset[1] == 0:\n        G = G1\n    else:\n        G = sparse([[G1],[G2]])\n\n    ct = matrix([c,matrix(0.0,(G2.size[1],1))])\n    if A is not None:\n        return (ct, G, matrix(h_converted),\\\n          {'l':dims['l'],'q':dims['q'],'s':dims_list},\\\n          sparse([[A],[spmatrix([],[],[],(A.size[0],G2.size[1]))]]),\\\n          b), block_to_sparse\n    else:\n        return (ct, G, matrix(h_converted),\\\n          {'l':dims['l'],'q':dims['q'],'s':dims_list}), block_to_sparse, symbs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef order_search(self, article_code, **kwargs):\n        '''taobao.vas.order.search \u8ba2\u5355\u8bb0\u5f55\u5bfc\u51fa\n        \n        \u7528\u4e8eISV\u67e5\u8be2\u81ea\u5df1\u540d\u4e0b\u7684\u5e94\u7528\u53ca\u6536\u8d39\u9879\u76ee\u7684\u8ba2\u5355\u8bb0\u5f55\u3002\u76ee\u524d\u6240\u6709\u5e94\u7528\u8c03\u7528\u6b64\u63a5\u53e3\u7684\u9891\u7387\u9650\u5236\u4e3a200\u6b21/\u5206\u949f\uff0c\u5373\u6bcf\u5206\u949f\u5185\uff0c\u6240\u6709\u5e94\u7528\u8c03\u7528\u6b64\u63a5\u53e3\u7684\u6b21\u6570\u52a0\u8d77\u6765\u6700\u591a\u4e3a200\u6b21\u3002'''\n        request = TOPRequest('taobao.vas.order.search')\n        request['article_code'] = article_code\n        for k, v in kwargs.iteritems():\n            if k not in ('item_code', 'nick', 'start_created', 'end_created', 'biz_type', 'biz_order_id', 'order_id', 'page_size','page_no') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request), fields=['article_biz_orders','total_item'], models={'article_biz_orders':ArticleBizOrder})\n        return self.article_biz_orders", "response": "TAOBAO VAS. order. search \u8ba2\u5355\u8bb0\u5f55\u5bfc\u51fa\n        \n        \u7528\u4e8e ISV\u67e5\u8be2\u81ea\u5df1\u540d\u4e0b\u7684\u8ba2\u5355\u8bb0\u5f55\u5bfc\u51fa\n        \n        \u7528\u4e8eISV\u67e5\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef subsc_search(self, article_code, **kwargs):\n        '''taobao.vas.subsc.search \u8ba2\u8d2d\u8bb0\u5f55\u5bfc\u51fa\n        \n        \u7528\u4e8eISV\u67e5\u8be2\u81ea\u5df1\u540d\u4e0b\u7684\u5e94\u7528\u53ca\u6536\u8d39\u9879\u76ee\u7684\u8ba2\u8d2d\u8bb0\u5f55'''\n        request = TOPRequest('taobao.vas.subsc.search')\n        request['article_code'] = article_code\n        for k, v in kwargs.iteritems():\n            if k not in ('item_code', 'nick', 'start_deadline', 'end_deadline', 'status', 'autosub', 'expire_notice', 'page_size','page_no') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request), fields=['article_subs','total_item'], models={'article_subs':ArticleSub})\n        return self.article_subs", "response": "TAOBAO VAS subsc. search \u8ba2\u8d2d\u8bb0\u5f55\u5bfc\u51fa\n        \n        \u7528\u4e8e ISV. search \u8be2\u81ea\u5df1\u540d\u4e0b\u7684\u8ba2\u8d2d\u8bb0\u5f55\u5bfc\u51fa\n        \n        \u7528\u4e8e ISV. search \ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef subscribe_get(self, nick, article_code):\n        '''taobao.vas.subscribe.get \u8ba2\u8d2d\u5173\u7cfb\u67e5\u8be2\n        \n        \u7528\u4e8eISV\u6839\u636e\u767b\u5f55\u8fdb\u6765\u7684\u6dd8\u5b9d\u4f1a\u5458\u540d\u67e5\u8be2\u8be5\u4e3a\u8be5\u4f1a\u5458\u5f00\u901a\u54ea\u4e9b\u6536\u8d39\u9879\u76ee\uff0cISV\u53ea\u80fd\u67e5\u8be2\u81ea\u5df1\u540d\u4e0b\u7684\u5e94\u7528\u53ca\u6536\u8d39\u9879\u76ee\u7684\u8ba2\u8d2d\u60c5\u51b5'''\n        request = TOPRequest('taobao.vas.subscribe.get')\n        request['nick'] = nick\n        request['article_code'] = article_code\n        self.create(self.execute(request), fields=['article_user_subscribes',], models={'article_user_subscribes':ArticleUserSubscribe})\n        return self.article_user_subscribes", "response": "TAOBAO. vas. subscribe. get \u8ba2\u8d2d\u5173\u7cfb\u67e5\u8be2\u8fdb\u6765\u7684\u6dd8\u5b9d\u4f1a\u5458\u5f00\u901a\u54ea\u4e9b\u6536\u8d39\u9879\u76ee\uff0cISV \u53ea\u80fd\u67e5\u8be2\u81ea\u5df1"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the Cholesky factor of the maximum determinant positive definite matrix completion of a multifrontal maximum determinant positive definite matrix.", "response": "def completion(X, factored_updates = True):\n    \"\"\"\n    Supernodal multifrontal maximum determinant positive definite\n    matrix completion. The routine computes the Cholesky factor\n    :math:`L` of the inverse of the maximum determinant positive\n    definite matrix completion of :math:`X`:, i.e.,\n\n    .. math::\n         P( S^{-1} ) = X\n\n    where :math:`S = LL^T`. On exit, the argument `X` contains the\n    lower-triangular Cholesky factor :math:`L`.\n\n    The optional argument `factored_updates` can be used to enable (if\n    True) or disable (if False) updating of intermediate\n    factorizations.\n\n    :param X:                 :py:class:`cspmatrix`\n    :param factored_updates:  boolean\n    \"\"\"\n\n    assert isinstance(X, cspmatrix) and X.is_factor is False, \"X must be a cspmatrix\"\n\n    n = X.symb.n\n    snpost = X.symb.snpost\n    snptr = X.symb.snptr\n    chptr = X.symb.chptr\n    chidx = X.symb.chidx\n\n    relptr = X.symb.relptr\n    relidx = X.symb.relidx\n    blkptr = X.symb.blkptr\n    blkval = X.blkval\n\n    stack = []\n\n    for k in reversed(list(snpost)):\n\n        nn = snptr[k+1]-snptr[k]       # |Nk|\n        na = relptr[k+1]-relptr[k]     # |Ak|\n        nj = na + nn\n\n        # allocate F and copy X_{Jk,Nk} to leading columns of F\n        F = matrix(0.0, (nj,nj))\n        lapack.lacpy(blkval, F, offsetA = blkptr[k], ldA = nj, m = nj, n = nn, uplo = 'L')\n\n        # if supernode k is not a root node:\n        if na > 0:\n            # copy Vk to 2,2 block of F\n            Vk = stack.pop()\n            lapack.lacpy(Vk, F, offsetB = nn*nj+nn, m = na, n = na, uplo = 'L')\n\n        # if supernode k has any children:\n        for ii in range(chptr[k],chptr[k+1]):\n            i = chidx[ii]       \n            if factored_updates:\n                r = relidx[relptr[i]:relptr[i+1]]\n                stack.append(frontal_get_update_factor(F,r,nn,na))\n            else:\n                stack.append(frontal_get_update(F,relidx,relptr,i))\n\n        # if supernode k is not a root node:\n        if na > 0:\n            if factored_updates:\n                # In this case we have Vk = Lk'*Lk\n                trL1 = 'T'\n                trL2 = 'N'                \n            else:\n                # factorize Vk \n                lapack.potrf(F, offsetA = nj*nn+nn, n = na, ldA = nj)\n                # In this case we have Vk = Lk*Lk'\n                trL1 = 'N'  \n                trL2 = 'T'  \n\n            # compute L_{Ak,Nk} and inv(D_{Nk,Nk}) = S_{Nk,Nk} - S_{Ak,Nk}'*L_{Ak,Nk}\n            lapack.trtrs(F, blkval, offsetA = nj*nn+nn, trans = trL1,\\\n                         offsetB = blkptr[k]+nn, ldB = nj, n = na, nrhs = nn)\n            blas.syrk(blkval, blkval, n = nn, k = na, trans= 'T', alpha = -1.0, beta = 1.0,\n                      offsetA = blkptr[k]+nn, offsetC = blkptr[k], ldA = nj, ldC = nj)\n            lapack.trtrs(F, blkval, offsetA = nj*nn+nn, trans = trL2,\\\n                         offsetB = blkptr[k]+nn, ldB = nj, n = na, nrhs = nn)                \n            for i in range(nn):\n                blas.scal(-1.0, blkval, n = na, offset = blkptr[k] + i*nj + nn)\n\n\n        # factorize inv(D_{Nk,Nk}) as R*R' so that D_{Nk,Nk} = L*L' with L = inv(R)'\n        lapack.lacpy(blkval, F, offsetA = blkptr[k], ldA = nj,\\\n                     ldB = nj, m = nn, n = nn, uplo = 'L') # copy    -- FIX!\n        F[:nn,:nn] = matrix(F[:nn,:nn][::-1],(nn,nn))      # reverse -- FIX!\n        lapack.potrf(F, ldA = nj, n = nn, uplo = 'U')      # factorize\n        F[:nn,:nn] = matrix(F[:nn,:nn][::-1],(nn,nn))      # reverse -- FIX!\n        lapack.lacpy(F, blkval, offsetB = blkptr[k], ldA = nj,\\\n                     ldB = nj, m = nn, n = nn, uplo = 'L') # copy    -- FIX!\n\n        # compute L = inv(R')\n        lapack.trtri(blkval, offsetA = blkptr[k], ldA = nj, n = nn)\n\n    X._is_factor = True\n\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef psdcompletion(A, reordered = True, **kwargs):\n    assert isinstance(A, cspmatrix) and A.is_factor is False, \"A must be a cspmatrix\"\n    \n    tol = kwargs.get('tol',1e-15)\n    X = matrix(A.spmatrix(reordered = True, symmetric = True))\n\n    symb = A.symb\n    n = symb.n\n    snptr = symb.snptr\n    sncolptr = symb.sncolptr\n    snrowidx = symb.snrowidx\n\n    # visit supernodes in reverse (descending) order\n    for k in range(symb.Nsn-1,-1,-1):\n\n        nn = snptr[k+1]-snptr[k]\n        beta = snrowidx[sncolptr[k]:sncolptr[k+1]]\n        nj = len(beta)\n        if nj-nn == 0: continue\n        alpha = beta[nn:]\n        nu = beta[:nn]\n        eta = matrix([matrix(range(beta[kk]+1,beta[kk+1])) for kk in range(nj-1)] + [matrix(range(beta[-1]+1,n))])\n\n        try:\n            # Try Cholesky factorization first\n            Xaa = X[alpha,alpha]\n            lapack.potrf(Xaa)\n            Xan = X[alpha,nu]\n            lapack.trtrs(Xaa, Xan, trans = 'N')\n            XeaT = X[eta,alpha].T\n            lapack.trtrs(Xaa, XeaT, trans = 'N')\n\n            # Compute update\n            tmp = XeaT.T*Xan\n            \n        except:\n            # If Cholesky fact. fails, switch to EVD: Xaa = Z*diag(w)*Z.T\n            Xaa = X[alpha,alpha]\n            w = matrix(0.0,(Xaa.size[0],1))\n            Z = matrix(0.0,Xaa.size)\n            lapack.syevr(Xaa, w, jobz='V', range='A', uplo='L', Z=Z)\n\n            # Pseudo-inverse: Xp = pinv(Xaa)\n            lambda_max = max(w)\n            Xp = Z*spmatrix([1.0/wi if wi > lambda_max*tol else 0.0 for wi in w],range(len(w)),range(len(w)))*Z.T\n                    \n            # Compute update\n            tmp = X[eta,alpha]*Xp*X[alpha,nu]\n\n        X[eta,nu] = tmp\n        X[nu,eta] = tmp.T\n\n    if reordered:\n        return X\n    else:\n        return X[symb.ip,symb.ip]", "response": "The psdcompletion routine takes a cspmatrix A and returns the maximum determinant positive semidefinite matrix completion."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render(self, rectangle, data):\n\n        size = (1.0 - 2.0*self.margin) * rectangle.h\n        offset = self.margin * rectangle.h\n        per_mark = 1.0 / float(self.total)\n        bottom = offset + size * float(self.index) * per_mark\n        top = bottom + per_mark * size\n\n        c = data['output']\n        with c:\n            c.translate(rectangle.x, rectangle.y)\n            c.draw_polygon(\n                0, top, -self.width, bottom, self.width, bottom,\n                fill=self.color\n                )", "response": "Draws the signature mark. A new rectangle is created and the new size is calculated."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_route(route, endpoint=None, **kw):\n    def wrapper(f):\n        try:\n            router.DefaultRouter.add_url_rule(route,\n                                              endpoint=endpoint,\n                                              view_func=f,\n                                              options=kw)\n        except AssertionError, e:\n            logger.warn(\"Failed to register route {}: {}\".format(route, e))\n        return f\n    return wrapper", "response": "Decorator to add a new route to the default router"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlook up the API URL for the given endpoint.", "response": "def url_for(endpoint, default=\"senaite.jsonapi.get\", **values):\n    \"\"\"Looks up the API URL for the given endpoint\n\n    :param endpoint: The name of the registered route (aka endpoint)\n    :type endpoint: string\n    :returns: External URL for this endpoint\n    :rtype: string/None\n    \"\"\"\n\n    try:\n        return router.url_for(endpoint, force_external=True, values=values)\n    except Exception:\n        # XXX plone.jsonapi.core should catch the BuildError of Werkzeug and\n        #     throw another error which can be handled here.\n        logger.debug(\"Could not build API URL for endpoint '%s'. \"\n                     \"No route provider registered?\" % endpoint)\n\n        # build generic API URL\n        return router.url_for(default, force_external=True, values=values)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef projected_inverse(L):\n\n    assert isinstance(L, cspmatrix) and L.is_factor is True, \"L must be a cspmatrix factor\"\n\n    n = L.symb.n\n    snpost = L.symb.snpost\n    snptr = L.symb.snptr\n    chptr = L.symb.chptr\n    chidx = L.symb.chidx\n\n    relptr = L.symb.relptr\n    relidx = L.symb.relidx\n    blkptr = L.symb.blkptr\n    blkval = L.blkval\n\n    stack = []\n\n    for k in reversed(list(snpost)):\n\n        nn = snptr[k+1]-snptr[k]       # |Nk|\n        na = relptr[k+1]-relptr[k]     # |Ak|\n        nj = na + nn\n\n        # invert factor of D_{Nk,Nk}\n        lapack.trtri(blkval, offsetA = blkptr[k], ldA = nj, n = nn)\n\n        # zero-out strict upper triangular part of {Nj,Nj} block (just in case!)\n        for i in range(1,nn): blas.scal(0.0, blkval, offset = blkptr[k] + nj*i, n = i)   \n\n        # compute inv(D_{Nk,Nk}) (store in 1,1 block of F)\n        F = matrix(0.0, (nj,nj))\n        blas.syrk(blkval, F, trans = 'T', offsetA = blkptr[k], ldA = nj, n = nn, k = nn)   \n\n        # if supernode k is not a root node:\n        if na > 0:\n\n            # copy \"update matrix\" to 2,2 block of F\n            Vk = stack.pop()\n            lapack.lacpy(Vk, F, ldB = nj, offsetB = nn*nj+nn, m = na, n = na, uplo = 'L')\n\n            # compute S_{Ak,Nk} = -Vk*L_{Ak,Nk}; store in 2,1 block of F\n            blas.symm(Vk, blkval, F, m = na, n = nn, offsetB = blkptr[k]+nn,\\\n                      ldB = nj, offsetC = nn, ldC = nj, alpha = -1.0)\n\n            # compute S_nn = inv(D_{Nk,Nk}) - S_{Ak,Nk}'*L_{Ak,Nk}; store in 1,1 block of F\n            blas.gemm(F, blkval, F, transA = 'T', m = nn, n = nn, k = na,\\\n                      offsetA = nn, alpha = -1.0, beta = 1.0,\\\n                      offsetB = blkptr[k]+nn, ldB = nj)\n\n        # extract update matrices if supernode k has any children\n        for ii in range(chptr[k],chptr[k+1]):\n            i = chidx[ii]\n            stack.append(frontal_get_update(F, relidx, relptr, i))\n\n        # copy S_{Jk,Nk} (i.e., 1,1 and 2,1 blocks of F) to blkval\n        lapack.lacpy(F, blkval, m = nj, n = nn, offsetB = blkptr[k], ldB = nj, uplo = 'L')\n\n    L._is_factor = False\n\n    return", "response": "This routine computes the projected inverse of the multifrontal multifontal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nappend the parser arguments for the system commands", "response": "def define_system_args(subparsers):\n    \"\"\"Append the parser arguments for the 'system' commands\"\"\"\n    system_parser = subparsers.add_parser(\"system\", help='Available commands: \\'info\\'')\n    system_subparsers = system_parser.add_subparsers(help='System commands')\n\n    # system info arguments\n    info_parser = system_subparsers.add_parser('info', help='Get system status information')\n    info_parser.add_argument('--src', required=True, dest='src', metavar='src',\n                             help='The instance name of the target SDC (must match the name in sdc-hosts.yml)')\n    info_parser.set_defaults(func=info_command)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the user information", "response": "def get_user_info(user):\n    \"\"\"Get the user information\n    \"\"\"\n    user = api.get_user(user)\n    current = api.get_current_user()\n\n    if api.is_anonymous():\n        return {\n            \"username\": current.getUserName(),\n            \"authenticated\": False,\n            \"roles\": current.getRoles(),\n            \"api_url\": api.url_for(\"plone.jsonapi.routes.users\", username=\"current\"),\n        }\n\n    # nothing to do\n    if user is None:\n        logger.warn(\"No user found for {}\".format(user))\n        return None\n\n    # plone user\n    pu = user.getUser()\n\n    info = {\n        \"username\": user.getUserName(),\n        \"roles\": user.getRoles(),\n        \"groups\": pu.getGroups(),\n        \"authenticated\": current == user,\n        \"api_url\": api.url_for(\"senaite.jsonapi.v1.users\", username=user.getId()),\n    }\n\n    for k, v in api.get_user_properties(user).items():\n        if api.is_date(v):\n            v = api.to_iso_date(v)\n        if not api.is_json_serializable(v):\n            logger.warn(\"User property '{}' is not JSON serializable\".format(k))\n            continue\n        info[k] = v\n\n    return info"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(context, request, username=None):\n    user_ids = []\n\n    # Don't allow anonymous users to query a user other than themselves\n    if api.is_anonymous():\n        username = \"current\"\n\n    # query all users if no username was given\n    if username is None:\n        user_ids = api.get_member_ids()\n    elif username == \"current\":\n        current_user = api.get_current_user()\n        user_ids = [current_user.getId()]\n    else:\n        user_ids = [username]\n\n    # Prepare batch\n    size = req.get_batch_size()\n    start = req.get_batch_start()\n    batch = api.make_batch(user_ids, size, start)\n\n    # get the user info for the user ids in the current batch\n    users = map(get_user_info, batch.get_batch())\n\n    return {\n        \"pagesize\": batch.get_pagesize(),\n        \"next\": batch.make_next_url(),\n        \"previous\": batch.make_prev_url(),\n        \"page\": batch.get_pagenumber(),\n        \"pages\": batch.get_numpages(),\n        \"count\": batch.get_sequence_length(),\n        \"items\": users,\n    }", "response": "Get the user info for a given user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef login(context, request):\n    # extract the data\n    __ac_name = request.get(\"__ac_name\", None)\n    __ac_password = request.get(\"__ac_password\", None)\n\n    logger.info(\"*** LOGIN %s ***\" % __ac_name)\n\n    if __ac_name is None:\n        api.fail(400, \"__ac_name is missing\")\n    if __ac_password is None:\n        api.fail(400, \"__ac_password is missing\")\n\n    acl_users = api.get_tool(\"acl_users\")\n\n    # XXX hard coded\n    acl_users.credentials_cookie_auth.login()\n\n    # XXX amin user won't be logged in if I use this approach\n    # acl_users.login()\n    # response = request.response\n    # acl_users.updateCredentials(request, response, __ac_name, __ac_password)\n\n    if api.is_anonymous():\n        api.fail(401, \"Invalid Credentials\")\n\n    # return the JSON in the same format like the user route\n    return get(context, request, username=__ac_name)", "response": "Login Route\n    Login route to authenticate a user against Plone."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tril(A):\n    if isinstance(A,spmatrix):\n        idx = [i for i,ij in enumerate(zip(A.I,A.J)) if ij[0]>=ij[1]]\n        return spmatrix(A.V[idx],A.I[idx],A.J[idx],A.size)\n    elif isinstance(A,matrix):\n        B = matrix(0.0, A.size)\n        lapack.lacpy(A, B, uplo = 'L')\n        return B\n    else:\n        raise TypeError", "response": "Returns the lower triangular part of A."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a symmetric matrix from a sparse square matrix A. Only the lower triangular entries of A are accessed.", "response": "def symmetrize(A):\n    \"\"\"\n    Returns a symmetric matrix from a sparse square matrix :math:`A`. Only the\n    lower triangular entries of :math:`A` are accessed.\n    \"\"\"\n    assert type(A) is spmatrix, \"argument must be a sparse matrix\"\n    assert A.size[0] == A.size[1], \"argument must me a square matrix\"\n    idx = [i for i,ij in enumerate(zip(A.I,A.J)) if ij[0] > ij[1]]\n    return tril(A) + spmatrix(A.V[idx], A.J[idx], A.I[idx], A.size)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef frontal_get_update_factor(F, r, nn, na):\n\n    N = len(r)\n\n    # allocate storage for lower triangular factor\n    Li = matrix(0.0,(N,N))\n\n    # Compute:\n    #   N1 = number of entries in r such that r[i] < nn\n    #   N2 = number of entries in r such that r[i] >= nn\n    N1 = 0\n    for i in range(len(r)):\n        if r[i] >= nn: break\n        else: N1 += 1\n    N2 = N-N1\n\n    # extract A and B from F; copy to leading N1 columns of Li\n    Li[:,:N1] = F[r,r[:N1]]\n\n    if N2 > 0:\n        # extract C and reduce C to lower triangular from\n        C = F[nn:,r[N1:]]\n        for ii in range(N2):\n            col = r[N-1-ii] - nn       # index of column in C\n            t = (na - col) - (ii + 1)  # number of nonzeros to zero out\n            if t == 0: continue        \n\n            # compute and apply Householder reflector\n            tau = lapack.larfg(C, C, n = t+1, offseta = na*(N2-ii)-1-ii, offsetx = na*(N2-ii)-1-ii-t)\n            tmp = C[na*(N2-ii)-1-ii]\n            C[na*(N2-ii)-1-ii] = 1.0\n            lapack.larfx(C, tau, C, m = t+1, n = N2-1-ii, ldC = na, offsetv = na*(N2-ii)-1-ii-t, offsetC = na-1-ii-t)\n            C[na*(N2-ii)-1-ii] = tmp\n\n        # copy lower triangular matrix from C to 2,2 block of Li\n        lapack.lacpy(C, Li, uplo = 'L', m = N2, n = N2, offsetA = na-N2, ldA = na, offsetB = (N+1)*N1, ldB = N)\n\n        # compute Li_{21} by solving L_{22}'*L_{21} = B\n        lapack.trtrs(Li, Li, trans = 'T', n = N2, nrhs = N1,\\\n                     ldA = N, ldB = N, offsetB = N1, offsetA = N1*N+N1)\n\n        # compute A - Li_{21}'*Li_{21}\n        blas.syrk(Li, Li, trans = 'T', n = N1, k = N2,\\\n                  ldA = N, ldC = N, offsetA = N1, alpha = -1.0, beta = 1.0)\n\n    # compute Li_{11}  [reverse -- factorize -- reverse]\n    At = matrix(Li[:N1,:N1][::-1],(N1,N1)) \n    lapack.potrf(At, uplo = 'U')\n    Li[:N1,:N1] = matrix(At[::-1],(N1,N1))\n    \n    return Li", "response": "This function computes the update factor of the frontal."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, session, **kwargs):\n        '''taobao.fenxiao.discount.update \u4fee\u6539\u7b49\u7ea7\u6298\u6263\n        \n        \u4fee\u6539\u7b49\u7ea7\u6298\u6263'''\n        request = TOPRequest('taobao.fenxiao.discount.update')\n        for k, v in kwargs.iteritems():\n            if k not in ('discount_id', 'discount_name', 'discount_status', 'detail_ids', 'target_types', 'target_ids', 'discount_types', 'discount_values', 'detail_statuss') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session), fields=['is_success',])\n        return self.is_success", "response": "TAOBAO. fenxiao. discount. update \u4fee\u6539\u7b49\u7ea7\u6298\u6263\n \n \u4fee\u6539\u7b49\u7ea7\u6298\u6263\n \u4fee\u6539\u7b49\u7ea7\u6298\u6263\n"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, distributor_id, grade_id, session, trade_type=None):\n        '''taobao.fenxiao.cooperation.update \u66f4\u65b0\u5408\u4f5c\u5173\u7cfb\u7b49\u7ea7\n        \n        \u4f9b\u5e94\u5546\u66f4\u65b0\u5408\u4f5c\u7684\u5206\u9500\u5546\u7b49\u7ea7'''\n        request = TOPRequest('taobao.fenxiao.cooperation.update')\n        request['distributor_id'] = distributor_id\n        request['grade_id'] = grade_id\n        if trade_type!=None: request['trade_type'] = trade_type\n        self.create(self.execute(request, session), fields=['is_success'])\n        return self.is_success", "response": "TAOBAO. fenxiao. cooperation. update \u66f4\u65b0\u5408\u4f5c\u5173\u7cfb\u7b49\u7ea7\n        \n        \u4f9b\u5e94\u5546\u7b49\u7ea7\n        \n        \u4f9b\u5e94\u5546\u7b49\u7ea7\n 69 \u4f9b\u5e94\u5546\u7b49\u7ea7\n"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef items_get(self, session, **kwargs):\n        '''taobao.fenxiao.distributor.items.get \u67e5\u8be2\u5546\u54c1\u4e0b\u8f7d\u8bb0\u5f55\n        \n        \u4f9b\u5e94\u5546\u67e5\u8be2\u5206\u9500\u5546\u5546\u54c1\u4e0b\u8f7d\u8bb0\u5f55\u3002'''\n        request = TOPRequest('taobao.fenxiao.distributor.items.get')\n        for k, v in kwargs.iteritems():\n            if k not in ('distributor_id', 'start_modified', 'end_modified', 'page_no', 'page_size', 'product_id') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session), fields=['total_results','records'], models={'records':FenxiaoItemRecord})\n        return self.records", "response": "TAOBAO. fenxiao. distributor. items. get \u67e5\u8be2\u5546\u54c1\u4e0b\u8f7d\u8bb0\u5f55\n        \n        \u4f9b\u5e94\u5546\u67e5\u8be2\u5546\u54c1\u4e0b\u8f7d\u8bb0\u5f55\n        \n        \u4f9b\u5e94\u5546\u67e5\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add(self, name, productcat_id, standard_price, retail_price_low, retail_price_high, category_id, quantity, alarm_number, desc, prov, city, postage_type, have_invoice, have_guarantee, session, **kwargs):\n        '''taobao.fenxiao.product.add \u6dfb\u52a0\u4ea7\u54c1\n        \n        \u6dfb\u52a0\u5206\u9500\u5e73\u53f0\u4ea7\u54c1\u6570\u636e\u3002\u4e1a\u52a1\u903b\u8f91\u4e0e\u5206\u9500\u7cfb\u7edf\u524d\u53f0\u9875\u9762\u4e00\u81f4\n        \n        - \u4ea7\u54c1\u56fe\u7247\u9ed8\u8ba4\u4e3a\u7a7a \n        - \u4ea7\u54c1\u53d1\u5e03\u540e\u9ed8\u8ba4\u4e3a\u4e0b\u67b6\u72b6\u6001'''\n        request = TOPRequest('taobao.fenxiao.product.add')\n        request['name'] = name\n        request['productcat_id'] = productcat_id\n        request['standard_price'] = standard_price\n        request['retail_price_low'] = retail_price_low\n        request['retail_price_high'] = retail_price_high\n        request['category_id'] = category_id\n        request['quantity'] = quantity\n        request['alarm_number'] = alarm_number\n        request['desc'] = desc\n        request['prov'] = prov\n        request['city'] = city\n        request['postage_type'] = postage_type\n        request['have_invoice'] = have_invoice\n        request['have_guarantee'] = have_guarantee\n        for k, v in kwargs.iteritems():\n            if k not in ('cost_price', 'outer_id', 'postage_id', 'postage_ordinary', 'postage_fast', 'postage_ems', 'discount_id', 'trade_type','is_authz','pic_path','image','properties','property_alias','input_properties','sku_standard_prices','sku_cost_prices','sku_outer_ids','sku_quantitys','sku_properties','dealer_cost_price','sku_dealer_cost_prices') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session), fields=['pid','created'], models={'created':TOPDate})\n        return self", "response": "taobao. fenxiao. product. add \u6dfb\u52a0\u4ea7\u54c1\u56fe\u7247\u9ed8\u8ba4\u4e3a\u7a7a\uff0c\u53d1\u9001\u53d1\u9001\u53d1\u9001\u53d1\u9001\u53d1\u9001\u53d1\u9001\u53d1\u9001\u53d1\u9001\u53d1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef image_upload(self, product_id, position, session, pic_path=None, image=None):\n        '''taobao.fenxiao.product.image.upload \u4ea7\u54c1\u56fe\u7247\u4e0a\u4f20\n        \n        \u4ea7\u54c1\u4e3b\u56fe\u56fe\u7247\u7a7a\u95f4\u76f8\u5bf9\u8def\u5f84\u6216\u7edd\u5bf9\u8def\u5f84\u6dfb\u52a0\u6216\u66f4\u65b0\uff0c\u6216\u8005\u662f\u56fe\u7247\u4e0a\u4f20\u3002\u5982\u679c\u6307\u5b9a\u4f4d\u7f6e\u7684\u56fe\u7247\u5df2\u5b58\u5728\uff0c\u5219\u8986\u76d6\u539f\u6709\u4fe1\u606f\uff0c\u5982\u679c\u4f4d\u7f6e\u4e3a1,\u81ea\u52a8\u8bbe\u4e3a\u4e3b\u56fe\u3002'''\n        request = TOPRequest('taobao.fenxiao.product.image.upload')\n        request['product_id'] = product_id\n        request['position'] = position\n        if pic_path!=None: request['pic_path'] = pic_path\n        if image!=None: request['image'] = image\n        self.create(self.execute(request, session), fields=['result','created'], models={'created':TOPDate})\n        return self", "response": "A method to upload an image to a product."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sku_update(self, product_id, properties, session, **kwargs):\n        '''taobao.fenxiao.product.sku.update \u4ea7\u54c1sku\u7f16\u8f91\u63a5\u53e3\n        \n        \u4ea7\u54c1SKU\u4fe1\u606f\u66f4\u65b0'''\n        request = TOPRequest('taobao.fenxiao.product.sku.update')\n        request['product_id'] = product_id\n        request['properties'] = properties\n        for k, v in kwargs.iteritems():\n            if k not in ('quantity', 'standard_price', 'agent_cost_price', 'sku_number', 'dealer_cost_price') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session), fields=['result','created'], models={'created':TOPDate})\n        return self", "response": "TAOBAO. fenxiao. product. sku. update \u4ea7\u54c1SKU\u7f16\u8f91\u63a5\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\u53e3\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, pid, session, **kwargs):\n        '''taobao.fenxiao.product.update \u66f4\u65b0\u4ea7\u54c1\n        \n        - \u66f4\u65b0\u5206\u9500\u5e73\u53f0\u4ea7\u54c1\u6570\u636e\uff0c\u4e0d\u4f20\u66f4\u65b0\u6570\u636e\u8fd4\u56de\u5931\u8d25\n        - \u5bf9sku\u8fdb\u884c\u589e\u3001\u5220\u64cd\u4f5c\u65f6\uff0c\u539f\u6709\u7684sku_ids\u5b57\u6bb5\u4f1a\u88ab\u5ffd\u7565\uff0c\u8bf7\u4f7f\u7528sku_properties\u548csku_properties_del\u3002'''\n        request = TOPRequest('taobao.fenxiao.product.update')\n        request['pid'] = pid\n        for k, v in kwargs.iteritems():\n            if k not in ('name', 'standard_price', 'cost_price', 'retail_price_low', 'retail_price_high', 'outer_id', 'quantity', 'alarm_number','desc','prov','city','postage_type','postage_id','postage_ordinary','postage_fast','postage_ems','status','sku_ids','sku_cost_prices','sku_quantitys','sku_outer_ids','have_invoice','have_guarantee','discount_id','sku_standard_prices','sku_properties','sku_properties_del','is_authz','pic_path','image','properties','property_alias','input_properties','dealer_cost_price','sku_dealer_cost_prices','category_id') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session), fields=['pid','modified'], models={'modified':TOPDate})\n        return self", "response": "TAOBAO. fenxiao. product. update \u66f4\u65b0\u4ea7\u54c1\u6570\u636e\uff0c\u4e0d\u4f20\u66f4\u65b0\u4ea7\u54c1\u6570\u636e\uff0c\u4e0d\u4f20\u66f4\u65b0\u4ea7\u54c1\u6570\u636e\uff0c\u4e0d\u4f20\u66f4"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nidentifies the HAL draft level of a given JSON object.", "response": "def detect(self, obj):\n        \"\"\"Identifies the HAL draft level of a given JSON object.\"\"\"\n        links = obj.get(LINKS_KEY, {})\n\n        for detector in [LATEST, DRAFT_3]:\n            if detector.draft.curies_rel in links:\n                return detector.detect(obj)\n\n        return LATEST.detect(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_list(thing):\n    if thing is None:\n        return []\n    if isinstance(thing, set):\n        return list(thing)\n    if isinstance(thing, types.StringTypes):\n        if thing.startswith(\"[\"):\n            # handle a list inside a string coming from the batch navigation\n            return ast.literal_eval(thing)\n    if not (is_list(thing) or is_tuple(thing)):\n        return [thing]\n    return list(thing)", "response": "converts an object to a list of items"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pluck(col, key, default=None):\n    if not (is_list(col) or is_tuple(col)):\n        fail(\"First argument must be a list or tuple\")\n\n    def _block(dct):\n        if not is_dict(dct):\n            return []\n        return dct.get(key, default)\n\n    return map(_block, col)", "response": "Returns a list of values from a collection of dictionaries."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pick(dct, *keys):\n    copy = dict()\n    for key in keys:\n        if key in dct.keys():\n            copy[key] = dct[key]\n    return copy", "response": "Returns a copy of the dictionary filtered to only have values for the\n        whitelisted keys or list of valid keys"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a copy of the dictionary with keys removed", "response": "def omit(dct, *keys):\n    \"\"\" Returns a copy of the dictionary filtered to omit the blacklisted keys\n        (or list of keys)\n\n        >>> omit({\"name\": \"moe\", \"age\": 50, \"userid\": \"moe1\"}, \"userid\", \"age\")\n        {'name': 'moe'}\n    \"\"\"\n    copy = dict()\n    for key in dct:\n        if key not in keys:\n            copy[key] = dct[key]\n    return copy"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrename the keys of a dictionary with the given mapping", "response": "def rename(dct, mapping):\n    \"\"\" Rename the keys of a dictionary with the given mapping\n\n        >>> rename({\"a\": 1, \"BBB\": 2}, {\"a\": \"AAA\"})\n        {'AAA': 1, 'BBB': 2}\n    \"\"\"\n\n    def _block(memo, key):\n        if key in dct:\n            memo[mapping[key]] = dct[key]\n            return memo\n        else:\n            return memo\n    return reduce(_block, mapping, omit(dct, *mapping.keys()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a collection of dictionaries with the keys renamed according to the mapping is returned", "response": "def alias(col, mapping):\n    \"\"\" Returns a collection of dictionaries with the keys renamed according to\n        the mapping\n\n        >>> libraries = [{\"isbn\": 1, \"ed\": 1}, {\"isbn\": 2, \"ed\": 2}]\n        >>> alias(libraries, {\"ed\": \"edition\"})\n        [{'edition': 1, 'isbn': 1}, {'edition': 2, 'isbn': 2}]\n\n        >>> alias({\"a\": 1}, {\"a\": \"b\"})\n        [{'b': 1}]\n    \"\"\"\n    if not is_list(col):\n        col = [col]\n\n    def _block(dct):\n        return rename(dct, mapping)\n\n    return map(_block, col)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the first element of a list of key value pairs", "response": "def first(thing, n=0):\n    \"\"\" get the first element of a list\n\n        >>> lst = [1, 2, 3, 4, 5]\n        >>> first(lst)\n        1\n        >>> first(lst, 3)\n        [1, 2, 3]\n        >>> first(lst, 10)\n        [1, 2, 3, 4, 5]\n        >>> first({\"key\": \"value\"})\n        {'key': 'value'}\n        >>> first((\"a\", \"b\", \"c\"))\n        'a'\n        >>> first([''])\n        ''\n        >>> first([''], 5)\n        ['']\n        >>> first(['', ''])\n        ''\n        >>> first(False)\n        False\n        >>> first(\"\")\n        ''\n        >>> first(None)\n        >>> first([])\n    \"\"\"\n    n = to_int(n)\n    if is_list(thing) or is_tuple(thing):\n        if len(thing) == 0:\n            return None\n        if n > 0:\n            return thing[0:n]\n        return thing[0]\n    return thing"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def discover(ignore_list=[], max_wait=30, loop=None):\n    stbs = []\n    try:\n        async with timeout(max_wait, loop=loop):\n            def responses_callback(notify):\n                \"\"\"Queue notify messages.\"\"\"\n                _LOGGER.debug(\"Found: %s\", notify.ip_address)\n                stbs.append(notify.ip_address)\n\n            mr_protocol = await install_mediaroom_protocol(responses_callback=responses_callback)\n            await asyncio.sleep(max_wait)\n    except asyncio.TimeoutError:\n        mr_protocol.close()\n        _LOGGER.debug(\"discover() timeout!\")\n\n    return list(set([stb for stb in stbs if stb not in ignore_list]))", "response": "Discover all STBs in the network."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a command to the STB.", "response": "async def send_cmd(self, cmd, loop=None):\n        \"\"\"Send remote command to STB.\"\"\"\n        _LOGGER.info(\"Send cmd = %s\", cmd)\n\n        if cmd not in COMMANDS and cmd not in range(0, 999):\n            _LOGGER.error(\"Unknown command\")\n            raise PyMediaroomError(\"Unknown commands\")\n\n        keys = []\n        if cmd in range(0, 999):\n            for character in str(cmd):\n                keys.append(COMMANDS[\"Number\"+str(character)])\n            if len(keys) < 3:\n                keys.append(COMMANDS[\"OK\"])\n            self.current_channel = cmd\n        else:\n            keys = [COMMANDS[cmd]]\n\n        try:\n            async with timeout(OPEN_CONTROL_TIMEOUT, loop=loop):\n                async with self.lock:\n                    _LOGGER.debug(\"Connecting to %s:%s\", self.stb_ip, REMOTE_CONTROL_PORT)\n                    stb_recv, stb_send = await asyncio.open_connection(self.stb_ip,\n                                                                       REMOTE_CONTROL_PORT,\n                                                                       loop=loop)\n                    await stb_recv.read(6)\n                    _LOGGER.info(\"Connected to %s:%s\", self.stb_ip, REMOTE_CONTROL_PORT)\n\n                    for key in keys:\n                        _LOGGER.debug(\"%s key=%s\", cmd, key)\n                        stb_send.write(\"key={}\\n\".format(key).encode('UTF-8'))\n                        _ = await stb_recv.read(3)\n                        await asyncio.sleep(0.300)\n\n        except asyncio.TimeoutError as error:\n            _LOGGER.warning(error)\n            raise PyMediaroomError(\"Timeout connecting to {}\".format(self.stb_ip))\n        except ConnectionRefusedError as error:\n            _LOGGER.warning(error)\n            raise PyMediaroomError(\"Connection refused to {}\".format(self.stb_ip))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nturning on media player.", "response": "async def turn_on(self):\n        \"\"\"Turn off media player.\"\"\"\n        _LOGGER.debug(\"turn_on while %s\", self._state)\n        if self._state in [State.STANDBY, State.OFF, State.UNKNOWN]:\n            await self.send_cmd('Power')\n            self._state = State.PLAYING_LIVE_TV\n        return self._state"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nturn off media player.", "response": "async def turn_off(self):\n        \"\"\"Turn off media player.\"\"\"\n        _LOGGER.debug(\"turn_off while %s\", self._state)\n        if self._state in [State.PLAYING_LIVE_TV, State.PLAYING_RECORDED_TV,\n                          State.PLAYING_TIMESHIFT_TV, State.UNKNOWN]:\n            await self.send_cmd('Power')\n            self._state = State.OFF\n        return self._state"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess State from a NOTIFY message.", "response": "def notify_callback(self, notify):\n        \"\"\"Process State from NOTIFY message.\"\"\"\n        _LOGGER.debug(notify)\n        if notify.ip_address != self.stb_ip:\n            return\n\n        if notify.tune:\n            self._state = State.PLAYING_LIVE_TV \n            self.tune_src = notify.tune['@src']\n            try:\n                if notify.stopped:\n                    self._state = State.STOPPED\n                elif notify.timeshift:\n                    self._state = State.PLAYING_TIMESHIFT_TV\n                elif notify.recorded:\n                    self._state = State.PLAYING_RECORDED_TV\n            except PyMediaroomError as e:\n                _LOGGER.debug(\"%s please report at https://github.com/dgomes/pymediaroom/issues\", e)\n        else:\n            self._state = State.STANDBY\n        \n        _LOGGER.debug(\"%s is %s\", self.stb_ip, self._state)\n        return self._state"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_index(self, name):\n        catalog = self.get_catalog()\n        index = catalog._catalog.getIndex(name)\n        logger.debug(\"get_index={} of catalog '{}' --> {}\".format(\n            name, catalog.__name__, index))\n        return index", "response": "get an index by name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts the value for a given index to a list of values.", "response": "def to_index_value(self, value, index):\n        \"\"\"Convert the value for a given index\n        \"\"\"\n\n        # ZPublisher records can be passed to the catalog as is.\n        if isinstance(value, HTTPRequest.record):\n            return value\n\n        if isinstance(index, basestring):\n            index = self.get_index(index)\n\n        if index.id == \"portal_type\":\n            return filter(lambda x: x, _.to_list(value))\n        if index.meta_type == \"DateIndex\":\n            return DateTime(value)\n        if index.meta_type == \"BooleanIndex\":\n            return bool(value)\n        if index.meta_type == \"KeywordIndex\":\n            return value.split(\",\")\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a query suitable for the catalog", "response": "def make_query(self, **kw):\n        \"\"\"create a query suitable for the catalog\n        \"\"\"\n        query = kw.pop(\"query\", {})\n\n        query.update(self.get_request_query())\n        query.update(self.get_custom_query())\n        query.update(self.get_keyword_query(**kw))\n\n        sort_on, sort_order = self.get_sort_spec()\n        if sort_on and \"sort_on\" not in query:\n            query.update({\"sort_on\": sort_on})\n        if sort_order and \"sort_order\" not in query:\n            query.update({\"sort_order\": sort_order})\n\n        logger.info(\"make_query:: query={} | catalog={}\".format(\n            query, self.catalog))\n\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_request_query(self):\n        query = {}\n\n        # only known indexes get observed\n        indexes = self.catalog.get_indexes()\n\n        for index in indexes:\n            # Check if the request contains a parameter named like the index\n            value = req.get(index)\n            # No value found, continue\n            if value is None:\n                continue\n            # Convert the found value to format understandable by the index\n            index_value = self.catalog.to_index_value(value, index)\n            # Conversion returned None, continue\n            if index_value is None:\n                continue\n            # Append the found value to the query\n            query[index] = index_value\n\n        return query", "response": "Checks the request for known catalog indexes and converts the found values to fit the type of the catalog index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract custom query keys from the index.", "response": "def get_custom_query(self):\n        \"\"\"Extracts custom query keys from the index.\n\n        Parameters which get extracted from the request:\n\n            `q`: Passes the value to the `SearchableText`\n            `path`: Creates a path query\n            `recent_created`: Creates a date query\n            `recent_modified`: Creates a date query\n\n        :param catalog: The catalog to build the query for\n        :type catalog: ZCatalog\n        :returns: Catalog query\n        :rtype: dict\n        \"\"\"\n        query = {}\n\n        # searchable text queries\n        q = req.get_query()\n        if q:\n            query[\"SearchableText\"] = q\n\n        # physical path queries\n        path = req.get_path()\n        if path:\n            query[\"path\"] = {'query': path, 'depth': req.get_depth()}\n\n        # special handling for recent created/modified\n        recent_created = req.get_recent_created()\n        if recent_created:\n            date = api.calculate_delta_date(recent_created)\n            query[\"created\"] = {'query': date, 'range': 'min'}\n\n        recent_modified = req.get_recent_modified()\n        if recent_modified:\n            date = api.calculate_delta_date(recent_modified)\n            query[\"modified\"] = {'query': date, 'range': 'min'}\n\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a query from the given keywords.", "response": "def get_keyword_query(self, **kw):\n        \"\"\"Generates a query from the given keywords.\n        Only known indexes make it into the generated query.\n\n        :returns: Catalog query\n        :rtype: dict\n        \"\"\"\n        query = dict()\n\n        # Only known indexes get observed\n        indexes = self.catalog.get_indexes()\n\n        # Handle additional keyword parameters\n        for k, v in kw.iteritems():\n            # handle uid in keywords\n            if k.lower() == \"uid\":\n                k = \"UID\"\n            # handle portal_type in keywords\n            if k.lower() == \"portal_type\":\n                if v:\n                    v = _.to_list(v)\n            if k not in indexes:\n                logger.warn(\"Skipping unknown keyword parameter '%s=%s'\" % (k, v))\n                continue\n            if v is None:\n                logger.warn(\"Skip None value in kw parameter '%s=%s'\" % (k, v))\n                continue\n            logger.debug(\"Adding '%s=%s' to query\" % (k, v))\n            query[k] = v\n\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef trsm(self,B,trans='N'):\n        \n        if trans=='N':\n            cp.trsm(self._L0,B)\n            pftrsm(self._V,self._L,self._B,B,trans='N')\n        elif trans=='T':\n            pftrsm(self._V,self._L,self._B,B,trans='T')\n            cp.trsm(self._L0,B,trans='T')\n        elif type(trans) is str:\n            raise ValueError(\"trans must be 'N' or 'T'\")\n        else:\n            raise TypeError(\"trans must be 'N' or 'T'\")\n        return", "response": "r Solves a triangular system of equations with multiple righthand\n        sides."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs and sends a new request object.", "response": "def request(method, url,\n    params=None,\n    data=None,\n    headers=None,\n    cookies=None,\n    files=None,\n    auth=None,\n    timeout=None,\n    allow_redirects=False,\n    proxies=None,\n    hooks=None,\n    return_response=True,\n    prefetch=False,\n    config=None):\n    \"\"\"Constructs and sends a :class:`Request <Request>`.\n    Returns :class:`Response <Response>` object.\n\n    :param method: method for the new :class:`Request` object.\n    :param url: URL for the new :class:`Request` object.\n    :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.\n    :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n    :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n    :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n    :param auth: (optional) Auth typle to enable Basic/Digest/Custom HTTP Auth.\n    :param timeout: (optional) Float describing the timeout of the request.\n    :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n    :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n    :param return_response: (optional) If False, an un-sent Request object will returned.\n    :param config: (optional) A configuration dictionary.\n    \"\"\"\n\n    s = session()\n    return s.request(\n        method=method,\n        url=url,\n        params=params,\n        data=data,\n        headers=headers,\n        cookies=cookies,\n        files=files,\n        auth=auth,\n        timeout=timeout,\n        allow_redirects=allow_redirects,\n        proxies=proxies,\n        hooks=hooks,\n        return_response=return_response,\n        config=config,\n        prefetch=prefetch\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render_to_reportlab_canvas(rl_canvas, papersize_tuple, layout):\n    rl_canvas.setPageSize(papersize_tuple)\n    layout.render(\n        Rectangle(0, 0, *papersize_tuple),\n        dict(output=ReportlabOutput(rl_canvas))\n        )", "response": "Renders the given layout manager on a page of the given canvas."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate and save a document with contents of the given layout manager.", "response": "def render_to_reportlab_document(output_filename, papersize_tuple, layout):\n    \"\"\"Create and save a document with contents of the given layout manager.\"\"\"\n    c = Canvas(output_filename, papersize_tuple)\n    render_to_reportlab_canvas(c, papersize_tuple, layout)\n    c.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef draw_polygon(\n            self,\n            *pts,\n            close_path=True,\n            stroke=None,\n            stroke_width=1,\n            stroke_dash=None,\n            fill=None\n            ) -> None:\n        \"\"\"Draws the given polygon.\"\"\"\n        c = self.c\n        c.saveState()\n\n        if stroke is not None:\n            c.setStrokeColorRGB(*stroke)\n            c.setLineWidth(stroke_width)\n            c.setDash(stroke_dash)\n        if fill is not None:\n            c.setFillColorRGB(*fill)\n\n        p = c.beginPath()\n        fn = p.moveTo\n        for x,y in zip(*[iter(pts)]*2):\n            fn(x, y)\n            fn = p.lineTo\n        if close_path:\n            p.close()\n\n        c.drawPath(p, stroke=(stroke is not None), fill=(fill is not None))\n        c.restoreState()", "response": "Draws the given polygon."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nattach HTTP Basic Authentication to the given Request object.", "response": "def http_basic(r, username, password):\n    \"\"\"Attaches HTTP Basic Authentication to the given Request object.\n    Arguments should be considered non-positional.\n\n    \"\"\"\n    username = str(username)\n    password = str(password)\n\n    auth_s = b64encode('%s:%s' % (username, password))\n    r.headers['Authorization'] = ('Basic %s' % auth_s)\n\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef http_digest(r, username, password):\n\n    def handle_401(r):\n        \"\"\"Takes the given response and tries digest-auth, if needed.\"\"\"\n\n        s_auth = r.headers.get('www-authenticate', '')\n\n        if 'digest' in s_auth.lower():\n\n            last_nonce = ''\n            nonce_count = 0\n\n            chal = parse_dict_header(s_auth.replace('Digest ', ''))\n\n            realm = chal['realm']\n            nonce = chal['nonce']\n            qop = chal.get('qop')\n            algorithm = chal.get('algorithm', 'MD5')\n            opaque = chal.get('opaque', None)\n\n            algorithm = algorithm.upper()\n            # lambdas assume digest modules are imported at the top level\n            if algorithm == 'MD5':\n                H = lambda x: hashlib.md5(x).hexdigest()\n            elif algorithm == 'SHA':\n                H = lambda x: hashlib.sha1(x).hexdigest()\n            # XXX MD5-sess\n            KD = lambda s, d: H(\"%s:%s\" % (s, d))\n\n            if H is None:\n                return None\n\n            # XXX not implemented yet\n            entdig = None\n            p_parsed = urlparse(r.request.url)\n            path = p_parsed.path + p_parsed.query\n\n            A1 = \"%s:%s:%s\" % (username, realm, password)\n            A2 = \"%s:%s\" % (r.request.method, path)\n\n            if qop == 'auth':\n                if nonce == last_nonce:\n                    nonce_count += 1\n                else:\n                    nonce_count = 1\n                    last_nonce = nonce\n\n                ncvalue = '%08x' % nonce_count\n                cnonce = (hashlib.sha1(\"%s:%s:%s:%s\" % (\n                    nonce_count, nonce, time.ctime(), randombytes(8)))\n                    .hexdigest()[:16]\n                )\n                noncebit = \"%s:%s:%s:%s:%s\" % (nonce, ncvalue, cnonce, qop, H(A2))\n                respdig = KD(H(A1), noncebit)\n            elif qop is None:\n                respdig = KD(H(A1), \"%s:%s\" % (nonce, H(A2)))\n            else:\n                # XXX handle auth-int.\n                return None\n\n            # XXX should the partial digests be encoded too?\n            base = 'username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", ' \\\n                   'response=\"%s\"' % (username, realm, nonce, path, respdig)\n            if opaque:\n                base += ', opaque=\"%s\"' % opaque\n            if entdig:\n                base += ', digest=\"%s\"' % entdig\n            base += ', algorithm=\"%s\"' % algorithm\n            if qop:\n                base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n\n\n            r.request.headers['Authorization'] = 'Digest %s' % (base)\n            r.request.send(anyway=True)\n            _r = r.request.response\n            _r.history.append(r)\n\n            return _r\n\n        return r\n\n    r.hooks['response'] = handle_401\n    return r", "response": "Attaches HTTP Digest Authentication to the given Request object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dispatch(t):\n\n    if not t:\n        return t\n    else:\n        t = list(t)\n\n    # Make sure they're passing in something.\n    assert len(t) >= 2\n\n    # If only two items are passed in, assume HTTPBasic.\n    if (len(t) == 2):\n        t.insert(0, 'basic')\n\n    # Allow built-in string referenced auths.\n    if isinstance(t[0], basestring):\n        if t[0] in ('basic', 'forced_basic'):\n            t[0] = http_basic\n        elif t[0] in ('digest',):\n            t[0] = http_digest\n\n    # Return a custom callable.\n    return (t[0], tuple(t[1:]))", "response": "Given an auth tuple return an expanded version."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_help_html():\n    remove_from_help = [\"not-in-help\", \"copyright\"]\n    if sys.platform in [\"win32\", \"cygwin\"]:\n        remove_from_help.extend([\"osx\", \"linux\"])\n    elif sys.platform == \"darwin\":\n        remove_from_help.extend([\"linux\", \"windows\", \"linux-windows\"])\n    else:\n        remove_from_help.extend([\"osx\", \"windows\"])\n    readme_part_gen = all_but_blocks(remove_from_help, README, newline=None)\n    rst_body = \"\\n\".join(list(readme_part_gen) + CHANGES)\n    doctree = docutils.core.publish_doctree(rst_body)\n    visitor = Doctree2HtmlForWx(doctree)\n    doctree.walkabout(visitor) # Fills visitor.body and visitor.toc\n    return ( # wx.html.HtmlWindow only renders a HTML subset\n      u'<body bgcolor=\"{bg}\" text=\"{fg}\" link=\"{link}\">'\n      u'<a name=\"0\"><h1>{title}</h1></a>'\n      u\"{sectionless}\"\n      u\"{toc}\"\n      u\"<p>This help was generated using selected information from the\\n\"\n      u\"Dose <tt>README.rst</tt> and <tt>CHANGES.rst</tt> project files.</p>\"\n      u'<p><a href=\"{url}\">{url}</a></p><hr/>'\n      u\"{body}</body>\"\n    ).format(bg=HELP_BG_COLOR, fg=HELP_FG_COLOR, link=HELP_LINK_COLOR,\n             title=HELP_TITLE, sectionless=u\"\".join(visitor.sectionless),\n             toc=u\"\".join(visitor.toc), url=__url__,\n             body=u\"\".join(visitor.body))", "response": "Build the help HTML using the shared resources."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncloses the stream. Performs cleanup.", "response": "def close_stream(self):\n\t\t\"\"\" Closes the stream. Performs cleanup. \"\"\"\n\t\tself.keep_listening = False\n\t\tself.stream.stop()\n\t\tself.stream.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the component product of this vector and the given other vector.", "response": "def get_component_product(self, other):\n        \"\"\"Returns the component product of this vector and the given\n        other vector.\"\"\"\n        return Point(self.x * other.x, self.y * other.y)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a vector of unit length unless it is the zero ArcGIS vector.", "response": "def get_normalized(self):\n        \"\"\"Returns a vector of unit length, unless it is the zero\n        vector, in which case it is left as is.\"\"\"\n        magnitude = self.get_magnitude()\n        if magnitude > 0:\n            magnitude = 1.0 / magnitude\n            return Point(self.x * magnitude, self.y * magnitude)\n        else:\n            return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_rotated(self, angle):\n        ca = math.cos(angle)\n        sa = math.sin(angle)\n        return Point(self.x*ca-self.y*sa, self.x*sa+self.y*ca)", "response": "Rotates this vector through the given anti - clockwise anglein radians."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_magnitude(self):\n        return math.sqrt(self.x*self.x + self.y*self.y)", "response": "Returns the magnitude of this vector."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_magnitude_squared(self):\n        return self.x*self.x + self.y*self.y", "response": "Returns the square of the magnitude of this vector."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_scalar_product(self, other):\n        return self.x*other.x+self.y*other.y", "response": "Returns the scalar product of this vector with the given\n        other vector."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_angle_between(self, other):\n        # The scalar product is the sum of the squares of the\n        # magnitude times the cosine of the angle - so normalizing the\n        # vectors first means the scalar product is just the cosine of\n        # the angle.\n        normself = self.get_normalized()\n        normother = other.get_normalized()\n        sp = normself.get_scalar_product(normother)\n        return math.acos(sp)", "response": "Returns the smallest angle between this vector and the given other vector."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_minimum(self, other):\n        return Point(min(self.x, other.x), min(self.y, other.y))", "response": "Updates this vector so its components are the lower of its\n        current components and those of the given other value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate this vector so its components are the higher of its current components and those of the given other value.", "response": "def get_maximum(self, other):\n        \"\"\"Updates this vector so its components are the higher of its\n        current components and those of the given other value.\"\"\"\n        return Point(max(self.x, other.x), max(self.y, other.y))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a random vector in the given range.", "response": "def get_random(min_pt, max_pt):\n        \"\"\"Returns a random vector in the given range.\"\"\"\n        result = Point(random.random(), random.random())\n        return result.get_component_product(max_pt - min_pt) + min_pt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the x y w h data as a tuple.", "response": "def get_data(self):\n        \"\"\"Returns the x, y, w, h, data as a tuple.\"\"\"\n        return self.x, self.y, self.w, self.h"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a list of candidate temporary directories which _get_default_tempdir will try.", "response": "def _candidate_tempdir_list():\n    \"\"\"Generate a list of candidate temporary directories which\n    _get_default_tempdir will try.\"\"\"\n\n    dirlist = []\n\n    # First, try the environment.\n    for envname in 'TMPDIR', 'TEMP', 'TMP':\n        dirname = _os.getenv(envname)\n        if dirname: dirlist.append(dirname)\n\n    # Failing that, try OS-specific locations.\n    if _os.name == 'nt':\n        dirlist.extend([ r'c:\\temp', r'c:\\tmp', r'\\temp', r'\\tmp' ])\n    else:\n        dirlist.extend([ '/tmp', '/var/tmp', '/usr/tmp' ])\n\n    # As a last resort, the current directory.\n    try:\n        dirlist.append(_os.getcwd())\n    except (AttributeError, OSError):\n        dirlist.append(_os.curdir)\n\n    return dirlist"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the default directory to use for temporary files.", "response": "def _get_default_tempdir():\n    \"\"\"Calculate the default directory to use for temporary files.\n    This routine should be called exactly once.\n\n    We determine whether or not a candidate temp dir is usable by\n    trying to create and write to a file in that directory.  If this\n    is successful, the test file is deleted.  To prevent denial of\n    service, the name of the test file must be randomized.\"\"\"\n\n    namer = _RandomNameSequence()\n    dirlist = _candidate_tempdir_list()\n\n    for dir in dirlist:\n        if dir != _os.curdir:\n            dir = _os.path.abspath(dir)\n        # Try only a few names per directory.\n        for seq in range(100):\n            name = next(namer)\n            filename = _os.path.join(dir, name)\n            try:\n                fd = _os.open(filename, _bin_openflags, 0o600)\n                try:\n                    try:\n                        with _io.open(fd, 'wb', closefd=False) as fp:\n                            fp.write(b'blat')\n                    finally:\n                        _os.close(fd)\n                finally:\n                    _os.unlink(filename)\n                return dir\n            except FileExistsError:\n                pass\n            except OSError:\n                break   # no point trying more names in this directory\n    raise FileNotFoundError(_errno.ENOENT,\n                            \"No usable temporary directory found in %s\" %\n                            dirlist)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncodes common to mkstemp TemporaryFile and NamedTemporaryFile.", "response": "def _mkstemp_inner(dir, pre, suf, flags):\n    \"\"\"Code common to mkstemp, TemporaryFile, and NamedTemporaryFile.\"\"\"\n\n    names = _get_candidate_names()\n\n    for seq in range(TMP_MAX):\n        name = next(names)\n        file = _os.path.join(dir, pre + name + suf)\n        try:\n            fd = _os.open(file, flags, 0o600)\n            return (fd, _os.path.abspath(file))\n        except FileExistsError:\n            continue    # try again\n        except PermissionError:\n            # This exception is thrown when a directory with the chosen name\n            # already exists on windows.\n            if _os.name == 'nt':\n                continue\n            else:\n                raise\n\n    raise FileExistsError(_errno.EEXIST,\n                          \"No usable temporary file name found\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef gettempdir():\n    global tempdir\n    if tempdir is None:\n        _once_lock.acquire()\n        try:\n            if tempdir is None:\n                tempdir = _get_default_tempdir()\n        finally:\n            _once_lock.release()\n    return tempdir", "response": "Accessor for tempfile. tempdir."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate and return a unique temporary file.", "response": "def mkstemp(suffix=\"\", prefix=template, dir=None, text=False):\n    \"\"\"User-callable function to create and return a unique temporary\n    file.  The return value is a pair (fd, name) where fd is the\n    file descriptor returned by os.open, and name is the filename.\n\n    If 'suffix' is specified, the file name will end with that suffix,\n    otherwise there will be no suffix.\n\n    If 'prefix' is specified, the file name will begin with that prefix,\n    otherwise a default prefix is used.\n\n    If 'dir' is specified, the file will be created in that directory,\n    otherwise a default directory is used.\n\n    If 'text' is specified and true, the file is opened in text\n    mode.  Else (the default) the file is opened in binary mode.  On\n    some operating systems, this makes no difference.\n\n    The file is readable and writable only by the creating user ID.\n    If the operating system uses permission bits to indicate whether a\n    file is executable, the file is executable by no one. The file\n    descriptor is not inherited by children of this process.\n\n    Caller is responsible for deleting the file when done with it.\n    \"\"\"\n\n    if dir is None:\n        dir = gettempdir()\n\n    if text:\n        flags = _text_openflags\n    else:\n        flags = _bin_openflags\n\n    return _mkstemp_inner(dir, prefix, suffix, flags)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mkdtemp(suffix=\"\", prefix=template, dir=None):\n\n    if dir is None:\n        dir = gettempdir()\n\n    names = _get_candidate_names()\n\n    for seq in range(TMP_MAX):\n        name = next(names)\n        file = _os.path.join(dir, prefix + name + suffix)\n        try:\n            _os.mkdir(file, 0o700)\n            return file\n        except FileExistsError:\n            continue    # try again\n\n    raise FileExistsError(_errno.EEXIST,\n                          \"No usable temporary directory name found\")", "response": "Create a temporary directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef NamedTemporaryFile(mode='w+b', buffering=-1, encoding=None,\n                       newline=None, suffix=\"\", prefix=template,\n                       dir=None, delete=True):\n    \"\"\"Create and return a temporary file.\n    Arguments:\n    'prefix', 'suffix', 'dir' -- as for mkstemp.\n    'mode' -- the mode argument to io.open (default \"w+b\").\n    'buffering' -- the buffer size argument to io.open (default -1).\n    'encoding' -- the encoding argument to io.open (default None)\n    'newline' -- the newline argument to io.open (default None)\n    'delete' -- whether the file is deleted on close (default True).\n    The file is created as mkstemp() would do it.\n\n    Returns an object with a file-like interface; the name of the file\n    is accessible as file.name.  The file will be automatically deleted\n    when it is closed unless the 'delete' argument is set to False.\n    \"\"\"\n\n    if dir is None:\n        dir = gettempdir()\n\n    flags = _bin_openflags\n\n    # Setting O_TEMPORARY in the flags causes the OS to delete\n    # the file when it is closed.  This is only supported by Windows.\n    if _os.name == 'nt' and delete:\n        flags |= _os.O_TEMPORARY\n\n    (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags)\n    try:\n        file = _io.open(fd, mode, buffering=buffering,\n                        newline=newline, encoding=encoding)\n\n        return _TemporaryFileWrapper(file, name, delete)\n    except Exception:\n        _os.close(fd)\n        raise", "response": "Create and return a temporary file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connection_from_host(self, host, port=80, scheme='http'):\n        pool_key = (scheme, host, port)\n\n        # If the scheme, host, or port doesn't match existing open connections,\n        # open a new ConnectionPool.\n        pool = self.pools.get(pool_key)\n        if pool:\n            return pool\n\n        # Make a fresh ConnectionPool of the desired type\n        pool_cls = pool_classes_by_scheme[scheme]\n        pool = pool_cls(host, port, **self.connection_pool_kw)\n\n        self.pools[pool_key] = pool\n\n        return pool", "response": "Get a ConnectionPool based on the host and port and scheme."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef urlopen(self, method, url, **kw):\n        conn = self.connection_from_url(url)\n        return conn.urlopen(method, url, assert_same_host=False, **kw)", "response": "Same as urllib3. urlopen. urlopen."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef syr2(X, u, v, alpha = 1.0, beta = 1.0, reordered=False):\n    assert X.is_factor is False, \"cspmatrix factor object\"\n    symb = X.symb\n    n = symb.n\n    snptr = symb.snptr\n    snode = symb.snode\n    blkval = X.blkval\n    blkptr = symb.blkptr\n    relptr = symb.relptr\n    snrowidx = symb.snrowidx\n    sncolptr = symb.sncolptr\n\n    if symb.p is not None and reordered is False:\n        up = u[symb.p]\n        vp = v[symb.p]\n    else:\n        up = u\n        vp = v\n            \n    for k in range(symb.Nsn):\n        nn = snptr[k+1]-snptr[k]     \n        na = relptr[k+1]-relptr[k] \n        nj = na + nn\n\n        for i in range(nn): blas.scal(beta, blkval, n = nj-i, offset = blkptr[k]+(nj+1)*i)\n\n        uk = up[snrowidx[sncolptr[k]:sncolptr[k+1]]]\n        vk = vp[snrowidx[sncolptr[k]:sncolptr[k+1]]]\n\n        blas.syr2(uk, vk, blkval, n = nn, offsetA = blkptr[k], ldA = nj, alpha = alpha)\n        blas.ger(uk, vk, blkval, m = na, n = nn, offsetx = nn, offsetA = blkptr[k]+nn, ldA = nj, alpha = alpha)\n        blas.ger(vk, uk, blkval, m = na, n = nn, offsetx = nn, offsetA = blkptr[k]+nn, ldA = nj, alpha = alpha)\n        \n    return", "response": "r Computes the projected rank 2 update of a cspmatrix X."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _ensure_5args(func):\n    if func is None:\n        return None\n\n    self_arg = 1 if inspect.ismethod(func) else 0\n    if len(inspect.getargspec(func)[0]) == 5 + self_arg:\n        return func\n    if len(inspect.getargspec(func)[0]) == 4 + self_arg:\n        return lambda t, y, J, dfdt, fy=None: func(t, y, J, dfdt)\n    else:\n        raise ValueError(\"Incorrect numer of arguments\")", "response": "Conditionally wrap function to ensure 5 positional arguments are passed."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshadows a module with an instance of LazyModule.", "response": "def shadow_normal_module(cls, mod_name=None):\n        \"\"\"\n        Shadow a module with an instance of LazyModule\n\n        :param mod_name:\n            Name of the module to shadow. By default this is the module that is\n            making the call into this method. This is not hard-coded as that\n            module might be called '__main__' if it is executed via 'python -m'\n        :returns:\n            A fresh instance of :class:`LazyModule`.\n        \"\"\"\n        if mod_name is None:\n            frame = inspect.currentframe()\n            try:\n                mod_name = frame.f_back.f_locals['__name__']\n            finally:\n                del frame\n        orig_mod = sys.modules[mod_name]\n        lazy_mod = cls(orig_mod.__name__, orig_mod.__doc__, orig_mod)\n        for attr in dir(orig_mod):\n            setattr(lazy_mod, attr, getattr(orig_mod, attr))\n        sys.modules[mod_name] = lazy_mod\n        return lazy_mod"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef immediate(self, name, value):\n        setattr(self, name, value)\n        self._all.add(name)", "response": "Set a name to value immediately."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, group_name, session):\n        '''taobao.crm.group.add \u5356\u5bb6\u521b\u5efa\u4e00\u4e2a\u5206\u7ec4\n        \n        \u5356\u5bb6\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5206\u7ec4\uff0c\u63a5\u53e3\u8fd4\u56de\u4e00\u4e2a\u521b\u5efa\u6210\u529f\u7684\u5206\u7ec4\u7684id'''\n        request = TOPRequest('taobao.crm.group.add')\n        request['group_name'] = group_name\n        self.create(self.execute(request, session), fields=['is_success', 'group_id'])\n        return self.is_success, self.group_id", "response": "A method to add a new group to the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, from_group_id, to_group_id, session):\n        '''taobao.crm.group.append \u5c06\u4e00\u4e2a\u5206\u7ec4\u6dfb\u52a0\u5230\u53e6\u5916\u4e00\u4e2a\u5206\u7ec4\n        \n        \u5c06\u67d0\u5206\u7ec4\u4e0b\u7684\u6240\u6709\u4f1a\u5458\u6dfb\u52a0\u5230\u53e6\u4e00\u4e2a\u5206\u7ec4,\u6ce8\n        \n        - 1.\u8be5\u64cd\u4f5c\u4e3a\u5f02\u6b65\u4efb\u52a1\uff0c\u5efa\u8bae\u5148\u8c03\u7528taobao.crm.grouptask.check \u786e\u4fdd\u6d89\u53ca\u5206\u7ec4\u4e0a\u6ca1\u6709\u4efb\u52a1\uff1b\n        - 2.\u82e5\u5206\u7ec4\u4e0b\u67d0\u4f1a\u5458\u5206\u7ec4\u6570\u8d85\u6700\u5927\u9650\u989d\uff0c\u5219\u8be5\u4f1a\u5458\u4e0d\u4f1a\u88ab\u6dfb\u52a0\u5230\u65b0\u5206\u7ec4\uff0c\u540c\u65f6\u4e0d\u5f71\u54cd\u5176\u4f59\u4f1a\u5458\u6dfb\u52a0\u5206\u7ec4\uff0c\u63a5\u53e3\u8c03\u7528\u4f9d\u7136\u8fd4\u56de\u6210\u529f\u3002'''\n        request = TOPRequest('taobao.crm.group.append')\n        request['from_group_id'] = from_group_id\n        request['to_group_id'] = to_group_id\n        self.create(self.execute(request, session), fields=['is_success',])\n        return self.is_success", "response": "TAOBAO. crm. group. append \u5c06 from_group_id to_group_id session \u53ef\u4ee5\u53ca\u65b0\u5206\u7ec4\u4e2d\u7684\u6dfb\u52a0\u5230\u53e6\u5916\u4e00\u4e2a\u5206\u7ec4\u4e2d\u7684\u65b0\u5206\u7ec4 \u5c06\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self, group_id, session):\n        '''taobao.crm.group.delete \u5220\u9664\u5206\u7ec4\n        \n        \u5c06\u8be5\u5206\u7ec4\u4e0b\u7684\u6240\u6709\u4f1a\u5458\u79fb\u9664\u51fa\u8be5\u7ec4\uff0c\u540c\u65f6\u5220\u9664\u8be5\u5206\u7ec4\u3002\u6ce8\uff1a\u5220\u9664\u5206\u7ec4\u4e3a\u5f02\u6b65\u4efb\u52a1\uff0c\u5fc5\u987b\u5148\u8c03\u7528taobao.crm.grouptask.check \u786e\u4fdd\u6d89\u53ca\u5c5e\u6027\u4e0a\u6ca1\u6709\u4efb\u52a1\u3002'''\n        request = TOPRequest('taobao.crm.group.delete')\n        request['group_id'] = group_id\n        self.create(self.execute(request, session), fields=['is_success',])\n        return self.is_success", "response": "TAOBAO API. delete \u5220\u9664\u5206\u7ec4\u4e0b\u7684\u6240\u6709\u4f1a\u5458\u79fb\u9664\u8be5\u7ec4\uff0c\u540c\u65f6\u5220\u9664\u8be5\u7ec4\u4e3a\u5f00\u5934"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check(self, group_id, session):\n        '''taobao.crm.grouptask.check \u67e5\u8be2\u5206\u7ec4\u4efb\u52a1\u662f\u5426\u5b8c\u6210\n        \n        \u68c0\u67e5\u4e00\u4e2a\u5206\u7ec4\u4e0a\u662f\u5426\u6709\u5f02\u6b65\u4efb\u52a1,\u5f02\u6b65\u4efb\u52a1\u5305\u62ec\n        \n        - 1.\u5c06\u4e00\u4e2a\u5206\u7ec4\u4e0b\u7684\u6240\u6709\u7528\u6237\u6dfb\u52a0\u5230\u53e6\u5916\u4e00\u4e2a\u5206\u7ec4\n        - 2.\u5c06\u4e00\u4e2a\u5206\u7ec4\u4e0b\u7684\u6240\u6709\u7528\u6237\u79fb\u52a8\u5230\u53e6\u5916\u4e00\u4e2a\u5206\u7ec4\n        - 3.\u5220\u9664\u67d0\u4e2a\u5206\u7ec4 \u82e5\u5206\u7ec4\u4e0a\u6709\u4efb\u52a1\u5219\u8be5\u5c5e\u6027\u4e0d\u80fd\u88ab\u64cd\u4f5c\u3002'''\n        request = TOPRequest('taobao.crm.grouptask.check')\n        request['group_id'] = group_id\n        self.create(self.execute(request, session))\n        return self.is_finished", "response": "Tests if a group has finished or not."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, buyer_nick, status, session, grade=None, province=None, city=None):\n        '''taobao.crm.memberinfo.update \u7f16\u8f91\u4f1a\u5458\u8d44\u6599\n        \n        \u68c0\u67e5\u4e00\u4e2a\u5206\u7ec4\u4e0a\u662f\u5426\u6709\u5f02\u6b65\u4efb\u52a1,\u5f02\u6b65\u4efb\u52a1\u5305\u62ec\n        \n        - 1.\u5c06\u4e00\u4e2a\u5206\u7ec4\u4e0b\u7684\u6240\u6709\u7528\u6237\u6dfb\u52a0\u5230\u53e6\u5916\u4e00\u4e2a\u5206\u7ec4\n        - 2.\u5c06\u4e00\u4e2a\u5206\u7ec4\u4e0b\u7684\u6240\u6709\u7528\u6237\u79fb\u52a8\u5230\u53e6\u5916\u4e00\u4e2a\u5206\u7ec4\n        - 3.\u5220\u9664\u67d0\u4e2a\u5206\u7ec4 \u82e5\u5206\u7ec4\u4e0a\u6709\u4efb\u52a1\u5219\u8be5\u5c5e\u6027\u4e0d\u80fd\u88ab\u64cd\u4f5c\u3002'''\n        request = TOPRequest('taobao.crm.memberinfo.update')\n        request['buyer_nick'] = buyer_nick\n        request['status'] = status\n        if grade!=None: request['grade'] = grade\n        if province!=None: request['province'] = province\n        if city!=None: request['city'] = city\n        self.create(self.execute(request, session))\n        return self.is_success", "response": "TAOBAO. crm. memberinfo. update \u7f16\u8f91\u4f1a\u5458\u8d44\u6599\n 69 \u68c0\u67e5\u4efb\u52a1 \u5206\u7ec4\u4e0a\u662f\u5426\u6709\u5f16\u8f91\u4f1a\u5458\u8d44\u6599\n 69 \u68c0\u67e5\u4efb\u52a1 "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef increment_get(self, current_page, session, **kwargs):\n        '''taobao.crm.members.increment.get \u589e\u91cf\u83b7\u53d6\u5356\u5bb6\u4f1a\u5458\uff09\n        \n        \u589e\u91cf\u83b7\u53d6\u4f1a\u5458\u5217\u8868\uff0c\u63a5\u53e3\u8fd4\u56de\u7b26\u5408\u67e5\u8be2\u6761\u4ef6\u7684\u6240\u6709\u4f1a\u5458\u3002\u4efb\u4f55\u72b6\u6001\u66f4\u6539\u90fd\u4f1a\u8fd4\u56de'''\n        request = TOPRequest('taobao.crm.members.increment.get')\n        request['current_page'] = current_page\n        for k, v in kwargs.iteritems():\n            if k not in ('grade', 'start_modify', 'end_modify', 'page_size') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session))\n        return self.members", "response": "TAOBAO. crm. members. increment. get \u589e\u91cf\u83b7\u53d6\u5356\u5bb6\u4f1a\u5458\uff09\n        \n        \u589e\u91cf\u83b7\u53d6\u4f1a\u5458\u5217\u8868\uff0c\u63a5\u53e3\u8fd4\u56de\u7b26\u5408\u67e5\u8be2\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search(self, current_page, session, **kwargs):\n        '''taobao.crm.members.search \u83b7\u53d6\u5356\u5bb6\u4f1a\u5458\uff08\u9ad8\u7ea7\u67e5\u8be2\uff09\uff09\n        \n        \u4f1a\u5458\u5217\u8868\u7684\u9ad8\u7ea7\u67e5\u8be2\uff0c\u63a5\u53e3\u8fd4\u56de\u7b26\u5408\u6761\u4ef6\u7684\u4f1a\u5458\u5217\u8868'''\n        request = TOPRequest('taobao.crm.members.search')\n        request['current_page'] = current_page\n        for k, v in kwargs.iteritems():\n            if k not in ('buyer_nick', 'grade', 'min_trade_amount', 'max_trade_amount', 'min_trade_count', 'max_trade_count', 'min_last_trade_time', 'max_last_trade_time', 'relation_source', 'min_item_num', 'min_avg_price', 'min_close_trade_num', 'province', 'city', 'group_id', 'page_size', 'order', 'max_avg_price', 'max_item_num', 'max_close_trade_num', 'sort') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session), models={'members':CrmMember})\n        return self.members", "response": "TAOBAO. crm. members. search \u83b7\u53d6\u5356\u5bb6\u4f1a\u5458\uff08\u9ad8\u7ea7\u67e5\u8be2\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09\uff09"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds rule to a session", "response": "def add(self, rule_name, session, **kwargs):\n        '''taobao.crm.rule.add \u5206\u7ec4\u89c4\u5219\u6dfb\u52a0\n        \n        \u6dfb\u52a0\u5206\u7ec4\u89c4\u5219\uff0c\u89c4\u5219\u53ef\u7528\u4e8e\u7b5b\u9009\u4e00\u5b9a\u6761\u4ef6\u7684\u4f1a\u5458\u3002\u8fc7\u6ee4\u6761\u4ef6\u53ef\u4ee5\u9009\u62e9\u5ba2\u6237\u6765\u6e90\u3001\u4f1a\u5458\u7ea7\u522b \u3001\u4ea4\u6613\u7b14\u6570\u3001\u4ea4\u6613\u989d\u3001\u4e0a\u6b21\u4ea4\u6613\u65f6\u95f4\u3001\u5e73\u5747\u5ba2\u5355\u4ef7\u3001\u5b9d\u8d1d\u4ef6\u6570\u3001\u7701\u4efd\u3001\u5173\u95ed\u4ea4\u6613\u6570\u7b49\uff0c\u65b0\u5efa\u89c4\u5219\u65f6\u5fc5\u987b\u81f3\u5c11\u9009\u62e9\u4e00\u4e2a\u4ee5\u4e0a\u7b5b\u9009\u6761\u4ef6\u3002\u5982\u679c\u8f93\u5165\u7684\u89c4\u5219\u7684\u7b5b\u9009\u6761\u4ef6\u4e0d\u6b63\u786e\u5219\u4e0d\u4f1a\u8fdb\u884c\u5904\u7406\uff0c\u53ef\u4ee5\u5c06\u67d0\u4e9b\u5206\u7ec4\u6302\u5728\u8fd9\u4e2a\u89c4\u5219\u4e0b\uff0c\u5bf9\u88ab\u6302\u5728\u8be5\u89c4\u5219\u4e0b\u7684\u5206\u7ec4\uff0c\u7cfb\u7edf\u5bf9\u73b0\u6709\u6ee1\u8db3\u89c4\u5219\u7684\u5ba2\u6237\u90fd\u5212\u5206\u5230\u8fd9\u4e2a\u5206\u7ec4\uff08\u5f02\u6b65\u4efb\u52a1\uff09\uff0c\u82e5\u67d0\u4e9b\u4f1a\u5458\u5206\u7ec4\u6570\u6216\u89c4\u5219\u6570\u8d85\u6700\u5927\u9650\u989d\uff0c\u5219\u8be5\u4f1a\u5458\u4e0d\u88ab\u64cd\u4f5c\uff0c\u540c\u65f6\u4e0d\u5f71\u54cd\u5176\u4f59\u4f1a\u5458\u64cd\u4f5c\uff0c\u63a5\u53e3\u8c03\u7528\u4f9d\u7136\u8fd4\u56de\u6210\u529f\u3002\u6bcf\u4e2a\u89c4\u5219\u53ef\u4ee5\u5e94\u7528\u5230\u591a\u4e2a\u5206\u7ec4\uff0c\u4e00\u4e2a\u7528\u6237\u7684\u89c4\u5219\u4e0a\u9650\u4e3a5\u4e2a\u3002'''\n        request = TOPRequest('taobao.crm.rule.add')\n        request['rule_name'] = rule_name\n        for k, v in kwargs.iteritems():\n            if k not in ('relation_source', 'grade', 'min_trade_amount', 'max_trade_amount', 'min_trade_count', 'max_trade_count', 'min_last_trade_time', 'max_last_trade_time', 'min_item_num', 'min_avg_price', 'min_close_trade_num', 'province', 'group_ids', 'max_avg_price', 'max_item_num', 'max_close_trade_num') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session))\n        return self.is_success, self.rule_id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, rule_id, session):\n        '''taobao.crm.rule.delete \u5206\u7ec4\u89c4\u5219\u5220\u9664\n        \n        \u5206\u7ec4\u89c4\u5219\u5220\u9664'''\n        request = TOPRequest('taobao.crm.rule.delete')\n        request['rule_id'] = rule_id\n        self.create(self.execute(request, session))\n        return self.is_success", "response": "TAOBAO. crm. rule. delete \u5206\u7ec4\u89c4\u5219\u5220\u9664\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef group_set(self, rule_id, session, add_groups=None, delete_groups=None):\n        '''taobao.crm.rule.group.set \u8bbe\u7f6e\u89c4\u5219\u9002\u7528\u7684\u5206\u7ec4\n        \n        \u5c06\u89c4\u5219\u5e94\u7528\u6216\u53d6\u6d88\u5e94\u7528\u5230\u5206\u7ec4\u4e0a\uff0cadd_groups\u548cdelete_groups\uff0c\u4e24\u4e2a\u53c2\u6570\u6700\u5c11\u586b\u5199\u4e00\u4e2a\u3002'''\n        request = TOPRequest('taobao.crm.rule.delete')\n        request['rule_id'] = rule_id\n        if add_groups!=None: request['add_groups'] = add_groups\n        if delete_groups!=None: request['delete_groups'] = delete_groups\n        self.create(self.execute(request, session))\n        return self.is_success", "response": "TAOBAO. crm. rule. group. set \u8bbe\u7f6e\u89c4\u5219\u901a\u8fc7\u6d88\u5e94\u7528\u5230\u5206\u7ec4\u4e0a"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cancel(self, session):\n        '''taobao.crm.shopvip.cancel \u5356\u5bb6\u53d6\u6d88\u5e97\u94favip\u7684\u4f18\u60e0\n        \n        \u6b64\u63a5\u53e3\u7528\u4e8e\u53d6\u6d88VIP\u4f18\u60e0'''\n        request = TOPRequest('taobao.crm.shopvip.cancel')\n        self.create(self.execute(request, session))\n        return self.is_success", "response": "TAOBAO. shopvip. cancel \u5356\u5bb6\u53d6\u6d88VIP\u4f18\u60e0"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, cid, session, name=None, pict_url=None, sort_order=None):\n        '''taobao.sellercats.list.update \u66f4\u65b0\u5356\u5bb6\u81ea\u5b9a\u4e49\u7c7b\u76ee\n        \n        \u6b64API\u66f4\u65b0\u5356\u5bb6\u5e97\u94fa\u5185\u81ea\u5b9a\u4e49\u7c7b\u76ee \u6ce8\uff1a\u56e0\u4e3a\u7f13\u5b58\u7684\u5173\u7cfb\uff0c\u6dfb\u52a0\u7684\u65b0\u7c7b\u76ee\u97008\u4e2a\u5c0f\u65f6\u540e\u624d\u53ef\u4ee5\u5728\u6dd8\u5b9d\u9875\u9762\u4e0a\u6b63\u5e38\u663e\u793a\uff0c\u4f46\u662f\u4e0d\u5f71\u54cd\u5728\u8be5\u7c7b\u76ee\u4e0b\u5546\u54c1\u53d1\u5e03'''\n        request = TOPRequest('taobao.sellercats.list.update')\n        request['cid'] = cid\n        if name!=None: request['name'] = name\n        if pict_url!=None: request['pict_url'] = pict_url\n        if sort_order!=None: request['sort_order'] = sort_order\n        self.create(self.execute(request, session)['seller_cat'])\n        return self", "response": "TAOBAO. sellercats. list. update \u66f4\u65b0\u5356\u5bb6\u81ea\u5b9a\u4e49\u7c7b\u76ee\u5e97\u94fa\u5185\u81ea\u5b9a\u4e49\u7c7b\u76ee\u5e97\u94fa\u5185\u81ea\u5b9a\u4e49\u7c7b\u76ee\u5e97\u94fa\u5185\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, nick):\n        '''taobao.sellercats.list.get \u83b7\u53d6\u524d\u53f0\u5c55\u793a\u7684\u5e97\u94fa\u5185\u5356\u5bb6\u81ea\u5b9a\u4e49\u5546\u54c1\u7c7b\u76ee\n        \n        \u6b64API\u6dfb\u52a0\u5356\u5bb6\u5e97\u94fa\u5185\u81ea\u5b9a\u4e49\u7c7b\u76ee \u7236\u7c7b\u76eeparent_cid\u503c\u7b49\u4e8e0\uff1a\u8868\u793a\u6b64\u7c7b\u76ee\u4e3a\u5e97\u94fa\u4e0b\u7684\u4e00\u7ea7\u7c7b\u76ee\uff0c\u503c\u4e0d\u7b49\u4e8e0\uff1a\u8868\u793a\u6b64\u7c7b\u76ee\u6709\u7236\u7c7b\u76ee \u6ce8\uff1a\u56e0\u4e3a\u7f13\u5b58\u7684\u5173\u7cfb,\u6dfb\u52a0\u7684\u65b0\u7c7b\u76ee\u97008\u4e2a\u5c0f\u65f6\u540e\u624d\u53ef\u4ee5\u5728\u6dd8\u5b9d\u9875\u9762\u4e0a\u6b63\u5e38\u663e\u793a\uff0c\u4f46\u662f\u4e0d\u5f71\u54cd\u5728\u8be5\u7c7b\u76ee\u4e0b\u5546\u54c1\u53d1\u5e03'''\n        request = TOPRequest('taobao.sellercats.list.get')\n        request['nick'] = nick\n        self.create(self.execute(request))\n        return self.seller_cats", "response": "TAOBAO. sellercats. list. get \u83b7\u53d6\u524d\u53f0\u5c55\u793a\u7684\u5e97\u94fa\u5185\u5356\u5bb6\u81ea\u5b9a\u4e49\u7c7b\u76ee parent_cid \u83b7\u53d6\u524d\u53f0\u5c55\u793a\u7684\u5e97\u94fa\u5185\u5b9a"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self):\n\t\tif not hasattr(self, 'queue'):\n\t\t\traise RuntimeError(\"Audio queue is not intialized.\")\n\t\tself.keep_listening = True\n\t\tself.stream.start()\n\t\t\n\t\twhile self.keep_listening:\n\t\t\ttry:\n\t\t\t\tchunk = self.queue.get(timeout=queue_timeout)\n\t\t\t\tunderflowed = self.stream.write(chunk)\n\t\t\t\tif underflowed:\n\t\t\t\t\tlogger.debug(\"Buffer underrun\")\n\t\t\texcept Empty:\n\t\t\t\tpass\n\n\t\tself.stream.stop()\n\t\tself.stream.close()", "response": "Starts the audio stream."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_dimension(text):\n    size, unit = _split_dimension(text)\n    factor = _unit_lookup[unit]\n    return size*factor", "response": "Parses the given text into one dimension and returns its equivalent size in points."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a set of dimensions into a tuple of values representing the sizes in points in units.", "response": "def parse_dimensions(text):\n    \"\"\"\n    Parses a set of dimensions into tuple of values representing the\n    sizes in points.\n\n    The dimensions that this method supports are exactly as for\n    parse_dimension. It supports multiple dimensions, separated by\n    whitespace, comma, semicolon, hyphen, or the letter x. The units\n    may follow each dimension (in which case they can be different in\n    each case) or only after the last one. Because no-units also means\n    points, if you have some dimensions in the middle of the set with\n    units and some without, then those without will be interpreted as\n    points: i.e. the 2 in \"1in, 2, 3mm\" will be treated as 2 points,\n    where as the 1 and 2 in \"1, 2, 3mm\" will be treated as\n    millimeters.\n    \"\"\"\n    components = _dimension_separator.split(text)\n    if len(components) == 0:\n        raise DimensionError(\"No dimensions found in string.\")\n\n    # Split each component into size and units\n    pairs = []\n    units = 0\n    for component in components:\n        value, unit = _split_dimension(component)\n        pairs.append((value, unit))\n        if unit is not None: units += 1\n\n    # Work out what to do with empty units\n    if units == 1 and pairs[-1][1]:\n        # We need to infer the units\n        empty_unit = _unit_lookup[pairs[-1][1]]\n    else:\n        empty_unit = 1\n\n    # Compile and return the result\n    result = []\n    for value, unit in pairs:\n        if unit: result.append(value * _unit_lookup[unit])\n        else: result.append(value * empty_unit)\n    return tuple(result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the number and unit from the given piece of text as a pair.", "response": "def _split_dimension(text):\n    \"\"\"\n    Returns the number and unit from the given piece of text as a pair.\n\n    >>> _split_dimension('1pt')\n    (1, 'pt')\n    >>> _split_dimension('1 pt')\n    (1, 'pt')\n    >>> _split_dimension('1  \\tpt')\n    (1, 'pt')\n    >>> _split_dimension('1  \\tpt  ')\n    (1, 'pt')\n    >>> _split_dimension(' 1  \\tpt  ')\n    (1, 'pt')\n    >>> _split_dimension('3')\n    (3, None)\n    >>> _split_dimension('-12.43mm')\n    (-12.43, 'mm')\n    >>> _split_dimension('-12.43\"')\n    (-12.43, '\"')\n    \"\"\"\n    match = _dimension_finder.match(text)\n    if not match:\n        raise DimensionError(\"Can't parse dimension '%s'.\" % text)\n    number = match.group(1)\n    unit = match.group(4)\n    if '.' in number:\n        return (float(number), unit)\n    else:\n        return (int(number), unit)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encode_multipart_formdata(fields, boundary=None):\n    body = StringIO()\n    if boundary is None:\n        boundary = mimetools.choose_boundary()\n\n    for fieldname, value in fields.iteritems():\n        body.write('--%s\\r\\n' % (boundary))\n\n        if isinstance(value, tuple):\n            filename, data = value\n            writer(body).write('Content-Disposition: form-data; name=\"%s\"; '\n                               'filename=\"%s\"\\r\\n' % (fieldname, filename))\n            body.write('Content-Type: %s\\r\\n\\r\\n' %\n                       (get_content_type(filename)))\n        else:\n            data = value\n            writer(body).write('Content-Disposition: form-data; name=\"%s\"\\r\\n'\n                               % (fieldname))\n            body.write('Content-Type: text/plain\\r\\n\\r\\n')\n\n        if isinstance(data, int):\n            data = str(data)  # Backwards compatibility\n\n        if isinstance(data, unicode):\n            writer(body).write(data)\n        else:\n            body.write(data)\n\n        body.write('\\r\\n')\n\n    body.write('--%s--\\r\\n' % (boundary))\n\n    content_type = 'multipart/form-data; boundary=%s' % boundary\n\n    return body.getvalue(), content_type", "response": "Encode a dictionary of fields using the multipart - form - data mime format."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef maybe_raise(cls, error_type, ignores=None):\n        ignores = set(ignores or [])\n        ignores.add(ErrorType.Ok)\n        if error_type not in ignores:\n            raise LibError(error_type)", "response": "Raise an exception if the error_type is not ok."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the audioqueue. Queue object that is used to set the audioqueue. Queue object.", "response": "def queue(self, value):\n\t\t\"\"\" Sets the audioqueue.\n\n\t\tParameters\n\t\t----------\n\t\tvalue : queue.Queue\n\t\t\tThe buffer from which audioframes are received.\n\t\t\"\"\"\n\t\tif not isinstance(value, Queue):\n\t\t\traise TypeError(\"queue is not a Queue object\")\n\t\tself._queue = value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_minimum_size(self, data):\n        size = self.element.get_minimum_size(data)\n        return datatypes.Point(\n            max(size.x, self.min_width),\n            max(size.y, self.min_height)\n            )", "response": "Returns the minimum size of the managed element as long as\n        it is larger than any manually set minima."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndraws the managed element in the correct alignment.", "response": "def render(self, rect, data):\n        \"\"\"Draws the managed element in the correct alignment.\"\"\"\n        # We can't use our get minimum size, because that enforces\n        # the size limits.\n        size = self.element.get_minimum_size(data)\n\n        # Assume we're bottom left at our natural size.\n        x = rect.x\n        y = rect.y\n        w = size.x\n        h = size.y\n\n        extra_width = rect.w - w\n        extra_height = rect.h - h\n\n        if self.horizontal_align == AlignLM.ALIGN_CENTER:\n            x += extra_width * 0.5\n        elif self.horizontal_align == AlignLM.ALIGN_RIGHT:\n            x += extra_width\n        elif self.horizontal_align == AlignLM.GROW_X:\n            w = rect.w\n\n        if self.vertical_align == AlignLM.ALIGN_MIDDLE:\n            y += extra_height * 0.5\n        elif self.vertical_align == AlignLM.ALIGN_TOP:\n            y += extra_height\n        elif self.vertical_align == AlignLM.GROW_Y:\n            h = rect.h\n\n        self.element.render(datatypes.Rectangle(x, y, w, h), data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a copy of the graph G with all the data removed", "response": "def create_copy_without_data(G):\n    \"\"\"Return a copy of the graph G with all the data removed\"\"\"\n    H = nx.Graph()\n    for i in H.nodes_iter():\n        H.node[i] = {}\n    return H"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstore an object to a pickled file by pickling it.", "response": "def dump(stuff, filename, verbose=True, protocol=3):\n    \"\"\"Store an object to file by pickling\n\n    Parameters\n    ----------\n    stuff : object to be pickled\n    filename : path\n    verbose : bool\n    protocol : 1,2,3 (default = 3)\n        Protocol used by Pickler, higher number means more recent version of Python is needed to read the pickle\n        produced. Default is protocol=3, which only works with Python 3+\n\n    Return\n    ------\n    path\n        Path where pickled object was saved.\n    \"\"\"\n    filename = os.path.normcase(filename)\n    dir_path = os.path.dirname(filename)\n    if not os.path.exists(dir_path): os.makedirs(dir_path)\n    with open(filename, 'wb') as f:\n        p = pickle.Pickler(f, protocol=protocol)\n        p.dump(stuff)\n    if verbose:\n        print('Written {} items to pickled binary file: {}'.format(len(stuff), filename))\n    return filename"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading a pickled object from a file.", "response": "def load(filename):\n    \"\"\"Retrieve a pickled object\n\n    Parameter\n    ---------\n    filename : path\n\n    Return\n    ------\n    object\n        Unpickled object\n    \"\"\"\n    filename = os.path.normcase(filename)\n    try:\n        with open(filename, 'rb') as f:\n            u = pickle.Unpickler(f)\n            return u.load()\n    except IOError:\n        raise LogOpeningError('No file found for %s' % filename, filename)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_bind_address(address, default=('localhost', 8080)):\n    if ':' in address:\n        host, port = address.split(':', 1)\n        port = int(port)\n    elif re.match('^\\d+$', address):\n        host = default[0]\n        port = int(address)\n    else:\n        host = address\n        port = default[1]\n    return host, port", "response": "Parse an address into host and port tuple."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sign_envelope(envelope, key_file):\n    doc = etree.fromstring(envelope)\n    body = get_body(doc)\n\n    queue = SignQueue()\n    queue.push_and_mark(body)\n\n    security_node = ensure_security_header(doc, queue)\n    security_token_node = create_binary_security_token(key_file)\n    signature_node = Signature(\n        xmlsec.TransformExclC14N, xmlsec.TransformRsaSha1)\n\n    security_node.append(security_token_node)\n    security_node.append(signature_node)\n    queue.insert_references(signature_node)\n\n    key_info = create_key_info_node(security_token_node)\n    signature_node.append(key_info)\n\n    # Sign the generated xml\n    xmlsec.addIDs(doc, ['Id'])\n    dsigCtx = xmlsec.DSigCtx()\n    dsigCtx.signKey = xmlsec.Key.load(key_file, xmlsec.KeyDataFormatPem, None)\n    dsigCtx.sign(signature_node)\n    return etree.tostring(doc)", "response": "Sign the given soap request with the given key"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nverifies that the given soap request is signed with the certificate", "response": "def verify_envelope(reply, key_file):\n    \"\"\"Verify that the given soap request is signed with the certificate\"\"\"\n    doc = etree.fromstring(reply)\n    node = doc.find(\".//{%s}Signature\" % xmlsec.DSigNs)\n    if node is None:\n        raise CertificationError(\"No signature node found\")\n    dsigCtx = xmlsec.DSigCtx()\n\n    xmlsec.addIDs(doc, ['Id'])\n    signKey = xmlsec.Key.load(key_file, xmlsec.KeyDataFormatPem)\n    signKey.name = os.path.basename(key_file)\n\n    dsigCtx.signKey = signKey\n    try:\n        dsigCtx.verify(node)\n    except xmlsec.VerificationError:\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate the KeyInfo node for the WSSE.", "response": "def create_key_info_node(security_token):\n    \"\"\"Create the KeyInfo node for WSSE.\n\n    Note that this currently only supports BinarySecurityTokens\n\n    Example of the generated XML:\n\n        <ds:KeyInfo Id=\"KI-24C56C5B3448F4BE9D141094243396829\">\n            <wsse:SecurityTokenReference\n                wsse11:TokenType=\"{{ BINARY_TOKEN_TYPE }}\">\n                <wsse:Reference\n                    URI=\"#X509-24C56C5B3448F4BE9D141094243396828\"\n                    ValueType=\"{{ BINARY_TOKEN_TYPE }}\"/>\n           </wsse:SecurityTokenReference>\n        </ds:KeyInfo>\n\n    \"\"\"\n    key_info = etree.Element(ns_id('KeyInfo', ns.dsns))\n\n    sec_token_ref = etree.SubElement(\n        key_info, ns_id('SecurityTokenReference', ns.wssens))\n    sec_token_ref.set(\n        ns_id('TokenType', ns.wssens), security_token.get('ValueType'))\n\n    reference = etree.SubElement(sec_token_ref, ns_id('Reference', ns.wssens))\n    reference.set('ValueType', security_token.get('ValueType'))\n    reference.set('URI', '#%s' % security_token.get(WSU_ID))\n    return key_info"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the BinarySecurityToken node containing the x509 certificate.", "response": "def create_binary_security_token(key_file):\n    \"\"\"Create the BinarySecurityToken node containing the x509 certificate.\n\n    \"\"\"\n    node = etree.Element(\n        ns_id('BinarySecurityToken', ns.wssens),\n        nsmap={ns.wssens[0]: ns.wssens[1]})\n    node.set(ns_id('Id', ns.wsuns), get_unique_id())\n    node.set('EncodingType', ns.wssns[1] + 'Base64Binary')\n    node.set('ValueType', BINARY_TOKEN_TYPE)\n\n    with open(key_file) as fh:\n        cert = crypto.load_certificate(crypto.FILETYPE_PEM, fh.read())\n        node.text = base64.b64encode(\n            crypto.dump_certificate(crypto.FILETYPE_ASN1, cert))\n    return node"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ensure_security_header(envelope, queue):\n    (header,) = HEADER_XPATH(envelope)\n    security = SECURITY_XPATH(header)\n    if security:\n        for timestamp in TIMESTAMP_XPATH(security[0]):\n            queue.push_and_mark(timestamp)\n        return security[0]\n    else:\n        nsmap = {\n            'wsu': ns.wsuns[1],\n            'wsse': ns.wssens[1],\n        }\n        return _create_element(header, 'wsse:Security', nsmap)", "response": "Insert a security XML node if it doesn t exist otherwise update it."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef checkParametersInputFile(filename):\n    fin = open(filename, 'r')\n    line = fin.readline()\n    line2 = fin.readline()\n    fin.close()\n\n    temp = re.split('\\s+', line)\n    temp2 = re.split('\\s+', line2)\n\n    if temp[0] == '#Minor':\n        return groovesParameters\n\n    if temp[0] == '#Shift':\n        return baseStepParameters\n\n    if temp[0] == '#X-disp':\n        return helicalBaseStepParameters\n\n    if temp[0] == '#Shear':\n        return basePairParameters\n\n    if temp[0] == '#Position':\n        return helicalAxisParameters\n\n    if temp2[0] == '#P':\n        return helicalRadiusParameters\n\n    if temp2[0] == '#alpha':\n        return backboneDihedrals", "response": "Check the do_x3dna output file and return list of parameters present in the file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setParametersFromFile(dna, filename, parameters=None, bp=None):\n\n    gotParameterList = False\n    param_type = None\n\n    # In case of none try to determine from file\n    if parameters is None:\n        parameters = checkParametersInputFile(filename)\n        if parameters is None:\n            raise AssertionError(\" Cannot determine the parameters name from file {0}.\".format(filename))\n\n    if isinstance(parameters, list) or isinstance(parameters, np.ndarray):\n        gotParameterList = True\n        parameter = list(parameters)\n        param_type = getParameterType(parameter[0])\n    else:\n        param_type = getParameterType(parameters)\n\n    if bp is None:\n        if param_type == 'bps':\n            bp = [dna.startBP, dna.num_step]\n        else:\n            bp = [dna.startBP, dna.num_bp]\n\n    if len(bp) == 1:\n        bp_range = False\n    else:\n        bp_range = True\n\n    if not gotParameterList:\n        tempParamName = parameters\n        inputParameter = [ parameters ]\n    else:\n        tempParamName = parameters[0]\n        inputParameter = parameter\n\n    sys.stdout.write('\\nLoading parameters: {0}'.format(inputParameter))\n\n    success = False\n    if tempParamName in basePairParameters:\n        dna.set_base_pair_parameters(filename, bp, parameters=inputParameter, bp_range=bp_range)\n        success = True\n\n    if tempParamName in baseStepParameters:\n        dna.set_base_step_parameters(filename, bp, parameters=inputParameter, step_range=bp_range, helical=False)\n        success = True\n\n    if tempParamName in helicalBaseStepParameters:\n        dna.set_base_step_parameters(filename, bp, parameters=inputParameter, step_range=bp_range, helical=True)\n        success = True\n\n    if tempParamName in groovesParameters:\n        dna.set_major_minor_groove(filename, bp, parameters=inputParameter, step_range=bp_range)\n        success = True\n\n    if tempParamName in backboneDihedrals:\n        dna.set_backbone_dihedrals(filename, bp, parameters=inputParameter, bp_range=bp_range)\n        success = True\n\n    if tempParamName in helicalRadiusParameters:\n        dna.set_helical_radius(filename, bp, full=True, bp_range=bp_range)\n        success = True\n\n    if tempParamName in helicalAxisParameters:\n        if len(bp) == 1:\n            raise AssertionError(\"Axis cannot be read for a single base-step.\\n Use a segment spanned over several basepairs.\")\n        dna.set_helical_axis(filename, step_range=True, step=bp)\n        success = True\n\n    if not success:\n        raise ValueError ('Not able to load these parameters: {0}... '.format(parameter))", "response": "Read a specific parameter from the do_x3dna output file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dev_parameters_vs_axis(dnaRef, dnaSubj, parameter, bp, axis='Z', bp_range=True, windows=10, err_type='block', tool='gmx analyze'):\n    RefParam, ref_bp_idx = dnaRef.get_parameters(parameter, bp, bp_range)\n    RefAxis, dummy = dnaRef.get_parameters(\n        'Helical {0}-axis' .format(axis), bp, bp_range)\n    SubjParam, subj_bp_idx = dnaSubj.get_parameters(parameter, bp, bp_range)\n\n    mean_axis = np.mean(RefAxis, axis=1)\n    meanRefParam = np.mean(RefParam, axis=1)\n    meanSubjParam = np.mean(SubjParam, axis=1)\n\n    maxAxis = np.amax(mean_axis)\n    minAxis = np.amin(mean_axis)\n    axis_range = (maxAxis - minAxis) / windows\n\n    Ref_param_error = get_error(dnaRef.time, RefParam, len(ref_bp_idx), err_type=err_type, tool=tool)\n    Ref_axis_error = get_error(dnaRef.time, RefAxis, len(ref_bp_idx), err_type=err_type, tool=tool)\n    subj_param_error = get_error(dnaSubj.time, SubjParam, len(subj_bp_idx), err_type=err_type, tool=tool)\n\n    merged_ref_param = []\n    merged_subj_Param = []\n    merged_Ref_param_error = []\n    merged_Ref_axis_error = []\n    merged_subj_param_error = []\n\n    final_axis = []\n\n    for i in range(windows):\n        start = minAxis + (i * axis_range)\n        end = start + axis_range\n        idx = []\n        for j in range(len(mean_axis)):\n            if((start <= mean_axis[j]) and (end > mean_axis[j])):\n                idx.append(j)\n        if(len(idx) > 0):\n            merged_ref_param.append(meanRefParam[idx])\n            merged_subj_Param.append(meanSubjParam[idx])\n            final_axis.append(start + (end - start) / 2)\n            merged_Ref_param_error.append(Ref_param_error[idx])\n            merged_Ref_axis_error.append(Ref_axis_error[idx])\n            merged_subj_param_error.append(subj_param_error[idx])\n\n    final_ref_param = []\n    final_subj_param = []\n    final_ref_param_error = []\n    final_ref_axis_error = []\n    final_subj_param_error = []\n    for i in range(len(merged_ref_param)):\n        final_ref_param.append(np.sum(merged_ref_param[i]))\n        final_subj_param.append(np.sum(merged_subj_Param[i]))\n\n        final_ref_axis_error.append(\n            np.sqrt((merged_Ref_axis_error[i]**2).sum()))\n        final_ref_param_error.append(\n            np.sqrt((merged_Ref_param_error[i]**2).sum()))\n        final_subj_param_error.append(\n            np.sqrt((merged_subj_param_error[i]**2).sum()))\n\n    deviation, error = get_deviation(\n        final_ref_param, final_ref_param_error, final_subj_param, final_subj_param_error)\n\n    return deviation, error, final_axis, final_ref_axis_error", "response": "This function calculates the deviation in the given parameters of a Reference DNA to a Subject DNA along a given axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef frenet_serret(xyz):\n    ''' Frenet-Serret Space Curve Invariants\n\n    Taken from \"Diffusion Imaging in Python\" `DiPy package<http://nipy.org/dipy/>`_\n\n    Calculates the 3 vector and 2 scalar invariants of a space curve defined by vectors r = (x,y,z).  If z is omitted (i.e. the array xyz has shape (N,2), then the curve is only 2D (planar), but the equations are still valid.\n\n    Similar to http://www.mathworks.com/matlabcentral/fileexchange/11169\n\n    In the following equations the prime ($'$) indicates differentiation with respect to the parameter $s$ of a parametrised curve $\\mathbf{r}(s)$.\n\n    - $\\mathbf{T}=\\mathbf{r'}/|\\mathbf{r'}|\\qquad$ (Tangent vector)}\n\n    - $\\mathbf{N}=\\mathbf{T'}/|\\mathbf{T'}|\\qquad$ (Normal vector)\n\n    - $\\mathbf{B}=\\mathbf{T}\\times\\mathbf{N}\\qquad$ (Binormal vector)\n\n    - $\\kappa=|\\mathbf{T'}|\\qquad$ (Curvature)\n\n    - $\\mathrm{\\tau}=-\\mathbf{B'}\\cdot\\mathbf{N}$ (Torsion)\n\n    **Arguments:**\n\n            * xyz : array-like shape (N,3)\n                            array representing x,y,z of N points in a track\n\n    **Returns:**\n\n                    * T : array shape (N,3)\n                            array representing the tangent of the curve xyz\n                    * N : array shape (N,3)\n                            array representing the normal of the curve xyz\n            * B : array shape (N,3)\n                    array representing the binormal of the curve xyz\n            * k : array shape (N,1)\n                    array representing the curvature of the curve xyz\n            * t : array shape (N,1)\n                    array representing the torsion of the curve xyz\n\n    Examples:\n\n    Create a helix and calculate its tangent, normal, binormal, curvature and torsion\n\n    >>> from dipy.tracking import metrics as tm\n    >>> import numpy as np\n    >>> theta = 2*np.pi*np.linspace(0,2,100)\n    >>> x=np.cos(theta)\n    >>> y=np.sin(theta)\n    >>> z=theta/(2*np.pi)\n    >>> xyz=np.vstack((x,y,z)).T\n    >>> T,N,B,k,t=tm.frenet_serret(xyz)\n\n    '''\n\n    def magn(xyz, n=1):\n        ''' magnitude of vector\n\n\n        '''\n        mag = np.sum(xyz**2, axis=1)**0.5\n        imag = np.where(mag == 0)\n        mag[imag] = np.finfo(float).eps\n\n        if n > 1:\n            return np.tile(mag, (n, 1)).T\n\n        return mag.reshape(len(mag), 1)\n\n    xyz = np.asarray(xyz)\n    n_pts = xyz.shape[0]\n\n    if n_pts == 0:\n        raise ValueError('xyz array cannot be empty')\n\n    dxyz = np.gradient(xyz)[0]\n    ddxyz = np.gradient(dxyz)[0]\n\n    # Tangent\n    T = np.divide(dxyz, magn(dxyz, 3))\n\n    # Derivative of Tangent\n    dT = np.gradient(T)[0]\n\n    # Normal\n    N = np.divide(dT, magn(dT, 3))\n\n    # Binormal\n    B = np.cross(T, N)\n\n    # Curvature\n    k = magn(np.cross(dxyz, ddxyz), 1) / (magn(dxyz, 1)**3)\n\n    # Torsion\n    #(In matlab was t=dot(-B,N,2))\n    t = np.sum(-B * N, axis=1)\n    # return T,N,B,k,t,dxyz,ddxyz,dT\n\n    return T, N, B, k, t", "response": "Frenet - Serret Space Curve Invariants of a given 3D array."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads parameters from do_x3dna output files.", "response": "def read_param_file(FileName, parameters, bp, bp_range, word=False, startBP=1):\n    \"\"\" Read parameters from do_x3dna file.\n\n    It is the main function, which is used to read and extract the parameters\n    values from the do_x3dna output files.\n\n    Parameters\n    ----------\n    FileName : str\n        Parameter file produced from do_x3dna.\n    parameters : list\n        List of column indices that has to be extracted. indices here start\n        with one.\n\n    bp : 1D list or array\n        base-pairs to analyze\n        Example: ::\n\n            bp = [6]                                # bp_range = False\n            bp = [4,15]                             # bp_range = True\n            bp = range(4,15)                        # bp_range = False\n            bp = np.arange(4,15)                    # bp_range = False\n            bp = [2,5,6,7,9,12,18]                  # bp_range = False\n    bp_range : bool\n        ``Default=True``: As shown above, if ``True``, bp is taken as a range otherwise list or numpy array.\n    word : bool\n        In some parameters, in place of value, ``'---'`` is present in the file.\n        If parameter values contain this, use ``True``.\n    startBP : int\n        Number ID of first base-pair.\n\n    Returns\n    -------\n    data : 3D array\n        Extracted parameters as a 3D array of shape (bp, parameters, time).\n    time : 1D array\n        Time of each frame\n    \"\"\"\n\n    sys.stdout.write(\"\\nReading file : %s\\n\" % FileName)\n    sys.stdout.flush()\n\n    def get_frame_data(block, parameters, bp_idx):\n        block = np.array(block).T\n        temp_data = (block[parameters, :])[:, bp_idx].copy()\n        return temp_data\n\n    def get_time(line):\n        dummy, temp_time = line.split('=')\n        return float( temp_time )\n\n    infile = open(FileName, 'r')\n    data = []\n    time = []\n    frame_number = 0\n\n    bp_idx, param_idx = get_idx_of_bp_parameters(bp, parameters, bp_range, startBP=startBP)\n\n    block = []\n    for line in infile:\n\n        # Removing last new line character\n        line = line.rstrip('\\n')\n\n        # Skipping blank/empty line\n        if not line.strip():\n            continue\n\n        # Getting Time tag and time => Starting of new frame\n        if(re.match('# Time', line) != None):\n\n            if((frame_number < 100) and (frame_number % 10 == 0)) or ((frame_number < 1000) and (frame_number % 100 == 0)) or ((frame_number < 10000) and (frame_number % 1000 == 0)) or ((frame_number < 100000) and (frame_number % 10000 == 0)) or ((frame_number < 1000000) and (frame_number % 100000 == 0)):\n                sys.stdout.write(\"\\rReading frame %d\" % frame_number)\n                sys.stdout.flush()\n\n            frame_number += 1\n\n            # if(frame_number==5000):\n            # break\n\n            # Getting time\n            time.append(get_time(line))\n\n            # Getting parameters/values for base-pairs\n            if(len(block) > 0):\n                data.append(get_frame_data(block, param_idx, bp_idx))\n            block = []\n            continue\n\n        # Skipping other lines starting with '#' tag\n        if(re.match('#', line) != None):\n            continue\n\n        if not word:\n            block.append(list(map(float, line.split())))\n        else:\n            temp = []\n            split_line = line.split()\n            for word in split_line:\n                if word != '---':\n                    temp.append(float(word))\n                else:\n                    temp.append(None)\n            block.append(temp)\n\n    # For last frame\n    data.append(get_frame_data(block, param_idx, bp_idx))\n    block = []\n    data_transpose = np.array(data).T\n\n    sys.stdout.write(\n        \"\\nFinished reading.... Total number of frame read =  %d\\n\" % frame_number)\n    sys.stdout.flush()\n\n    return data_transpose, time"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vector_angle(x, y, multiple=True, norm=None):\n    x = np.asarray(x)\n    y = np.asarray(y)\n\n    angle = []\n    if multiple:\n        # Element-wise angle between arrays of vectors. Taken from following links\n        # http://codereview.stackexchange.com/questions/54347/calculating-element-wise-the-angles-between-two-lists-of-vectors\n        dot_x_y = np.einsum('ij, ij->i', x, y)\n        dot_x_x = np.einsum('ij, ij->i', x, x)\n        dot_y_y = np.einsum('ij, ij->i', y, y)\n        angle = np.arccos(dot_x_y / (np.sqrt(dot_x_x) * np.sqrt(dot_y_y)))\n\n        if norm is not None:\n            cross_x_y = np.cross(x, y)\n            sign = np.einsum('ij, ij->i', cross_x_y, np.tile(norm, (x.shape[0], 1)))\n            angle = angle * np.sign(sign)\n    else:\n        # Angle between two vectors\n        dot = np.dot(x, y)\n        cross = np.cross(x, y)\n        cross_modulus = np.sqrt((cross * cross).sum())\n        angle = np.arctan2(cross_modulus, dot)\n    return angle", "response": "Calculates the angle between two vectors."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen the HDF5 file for reading and writing.", "response": "def _openFile(self):\n        \"\"\" Open the HDF5 file for reading/writing.\n\n        This methad is called during the initialization of this class.\n        \"\"\"\n        if self.filename is not None:\n            self.h5 = h5py.File(self.filename)\n        else:\n            return\n\n        if 'bp' not in self.h5:\n            self.h5.create_group('bp')\n\n        if 'bps' not in self.h5:\n            self.h5.create_group('bps')\n\n        for bp_type in ['bp', 'bps']:\n            for bp_num in self.data[bp_type]:\n\n                # Create group in case if new hdf5 file is opened\n                if bp_num not in self.h5[bp_type]:\n                    self.h5[bp_type].create_group(bp_num)\n\n                # Sync data if old file is opened\n                for parameters in self.h5[bp_type][bp_num]:\n                    self.data[bp_type][bp_num][parameters] = self.h5[bp_type][bp_num][parameters]\n\n        if 'mask' in self.h5:\n            self.mask = self.h5['mask'][:]\n\n        if 'time' in self.h5:\n            self.time = self.h5['time'][:]\n\n        if 'num_bp' in self.h5.attrs:\n            self.num_bp = self.h5.attrs['num_bp']\n        else:\n            self.h5.attrs['num_bp'] = self.num_bp\n\n        if 'num_step' in self.h5.attrs:\n            self.num_step = self.h5.attrs['num_step']\n        else:\n            self.h5.attrs['num_step'] = self.num_step\n\n        if 'startBP' in self.h5.attrs:\n            self.startBP = self.h5.attrs['startBP']\n        else:\n            self.h5.attrs['startBP'] = self.startBP"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _set_time(self, time):\n        if len(self.time) == 0 :\n            self.time = np.array(time)\n            if self.h5 is not None:\n                self.h5.create_dataset('time', self.time.shape, dtype=self.time.dtype, data=self.time, compression=\"gzip\", shuffle=True, scaleoffset=3)\n        else:\n            if(len(time) != len(self.time)):\n                raise AssertionError(\"\\nTime or number of frame mismatch in input files.\\n Exiting...\\n\")", "response": "Set time in both class and hdf5 file"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets mask array in both class and hdf5 file", "response": "def _set_mask(self, mask):\n        \"\"\" Set mask array in both class and hdf5 file\n        \"\"\"\n        self.mask = mask.copy()\n        if self.h5 is not None:\n            if 'mask' in self.h5:\n                self.h5.pop('mask')\n            self.h5.create_dataset('mask', mask.shape, dtype=self.mask.dtype, data=mask, compression=\"gzip\", shuffle=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_helical_radius(self, filename, bp, atomname='P', full=False, bp_range=True):\n        if not (isinstance(bp, list) or isinstance(bp, np.ndarray)):\n            raise AssertionError(\n                \"type %s is not list or np.ndarray\" % type(bp))\n\n        if not ((atomname == 'P') or (atomname == 'O4*') or (atomname == 'C1*') or (atomname == 'O4\\'') or (atomname == 'C1\\'')):\n            print (\n                '\\n This atomname {0} is not implemented... Exiting\\n' .format(atomname))\n\n        # Check if requested parameters found within input file\n        gotParametersInputFile = checkParametersInputFile(filename)\n        if gotParametersInputFile is None:\n            raise IOError(' Something wrong in input file {0}.\\n Cannot read parameters.\\n File should be an output from do_x3dna.'.format(filename))\n        for p in helicalRadiusParameters:\n            if p not in gotParametersInputFile:\n                raise ValueError(' Helical radius not found in input file. \\n This file contains following parameters: \\n {0}'.format(gotParametersInputFile))\n\n        parameter = []\n        if (atomname == 'P') or (full):\n            parameter = [1, 4]\n\n        if (atomname == 'O4*' or atomname == 'O4\\'') and (not full):\n            parameter = [2, 5]\n\n        if (atomname == 'C1*' or atomname == 'C1\\'') and (not full):\n            parameter = [3, 6]\n\n\n        data, time = read_param_file(filename, [1, 2, 3, 4, 5, 6], bp, bp_range, startBP=self.startBP)\n        self._set_time(time)\n\n        bp_idx, param_idx = get_idx_of_bp_parameters(bp, parameter, bp_range, startBP=self.startBP)\n\n        if full:\n            data = np.add(data, 1.0)\n\n        for i in range(len(data)):\n            bp_num = str( bp_idx[i]+self.startBP )\n            if (atomname == 'P') or (full):\n                self._set_data(data[i][0], 'bps', bp_num, 'radius s-1', scaleoffset=1)\n                self._set_data(data[i][3], 'bps', bp_num, 'radius s-2', scaleoffset=1)\n\n            if (atomname == 'O4*' or atomname == 'O4\\''):\n                self._set_data(data[i][1], 'bps', bp_num, 'radius s-1', scaleoffset=1)\n                self._set_data(data[i][4], 'bps', bp_num, 'radius s-2', scaleoffset=1)\n\n            if (atomname == 'C1*' or atomname == 'C1\\''):\n                self._set_data(data[i][2], 'bps', bp_num, 'radius s-1', scaleoffset=1)\n                self._set_data(data[i][5], 'bps', bp_num, 'radius s-2', scaleoffset=1)", "response": "This function will read and set the local helical radius of a single DNA helical entry in the database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_base_step_parameters(self, filename, bp_step, parameters='all', step_range=True, helical=False):\n        if not (isinstance(bp_step, list) or isinstance(bp_step, np.ndarray)):\n            raise AssertionError(\n                \"type %s is not list or np.ndarray\" % type(bp_step))\n\n        if not (isinstance(parameters, list) or isinstance(parameters, np.ndarray)):\n            if parameters == 'all' and not helical:\n                parameters = ['shift', 'slide', 'rise', 'tilt', 'roll', 'twist']\n            elif parameters == 'all' and helical:\n                parameters = ['x-disp', 'y-disp', 'h-rise', 'inclination', 'tip', 'h-twist']\n            else:\n                raise ValueError(\" ERROR: {0} is not accepted parameters!!! It should be either \\\"all\\\" or list of parameter names.\".format(parameters) )\n\n        targetParameters = None\n        targetParametersReverse = None\n        if helical:\n            targetParameters = { 1:'x-disp', 2:'y-disp', 3:'h-rise', 4:'inclination', 5:'tip', 6:'h-twist' }\n        else:\n            targetParameters = { 1:'shift', 2:'slide', 3:'rise', 4:'tilt', 5:'roll', 6:'twist' }\n        targetParametersReverse = dict((v,k) for k,v in targetParameters.items())\n\n        # Check if requested parameters found within input file\n        gotParametersInputFile = checkParametersInputFile(filename)\n        if gotParametersInputFile is None:\n            raise IOError(' Something wrong in input file {0}.\\n Cannot read parameters.\\n File should be an output from do_x3dna.'.format(filename))\n        for parameter in parameters:\n            if parameter not in gotParametersInputFile:\n                raise ValueError(' Parameter {0} not found in input file. \\n This file contains following parameters: \\n {1}'.format(parameter, gotParametersInputFile))\n\n        InputParamIndex = []\n        for parameter in parameters:\n            if parameter in targetParameters.values():\n                InputParamIndex.append( targetParametersReverse[parameter] )\n            else:\n                print('\\nWARNING: base pair parameters \\\"{0}\\\" not accepted. Skipping it !!\\n' .format(parameter))\n\n        if not InputParamIndex:\n            raise ValueError(\"No acceptable base-pair parameters found!!!\")\n\n        data, time = read_param_file(filename, InputParamIndex, bp_step, step_range, startBP=self.startBP)\n        self._set_time(time)\n\n        bpIndex, OutParamIndex = get_idx_of_bp_parameters(bp_step, InputParamIndex, step_range, startBP=self.startBP)\n\n        for i in range(len(data)):\n            for j in range(len(data[i])):\n                bp_num = str( bpIndex[i]+self.startBP )\n                param = targetParameters[OutParamIndex[j]+1]\n                self._set_data(data[i][j], 'bps', bp_num, param, scaleoffset=2)", "response": "Set base - step parameters in file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread and sets local helical axis positions from an input file.", "response": "def set_helical_axis(self, filename, step_range=False, step=None):\n        \"\"\"\n        To read and set local helical-axis positions from an input file.\n\n        Parameters\n        ----------\n        filename : str\n            Input file, which is generated from do_x3dna. e.g. HelAxis_g.dat\n        step_range : bool\n            * ``step_range = True`` : read axis coordinates of base-steps for the given range of base-steps\n            * ``step_range = False``: read axis coordinates of all base-steps\n        step : list\n            List containing lower and higher limit of base-steps range.\n                * This option only works with ``step_range=True``.\n                * This list should not contain more than two number.\n                * First number should be less than second number.\n\n            Example for base-step 4 to 15:\n                ``step = [4,15]         # step_range = True``\n\n        \"\"\"\n\n        if (step_range):\n            if not isinstance(step, list):\n                raise AssertionError(\"type %s is not list\" % type(step))\n            if (len(step) > 2):\n                print (\n                    \"ERROR: Range for helical axis should be list of two numbers, e.g. step=[1, 20] \\n\")\n                exit(1)\n\n        if (step_range) and (step == None):\n            raise ValueError(\n                \"See, documentation for step  and step_range usage!!!\")\n\n        # Check if requested parameters found within input file\n        gotParametersInputFile = checkParametersInputFile(filename)\n        if gotParametersInputFile is None:\n            raise IOError(' Something wrong in input file {0}.\\n Cannot read parameters.\\n File should be an output from do_x3dna.'.format(filename))\n        for p in helicalAxisParameters:\n            if p not in gotParametersInputFile:\n                raise ValueError(' Helical axis not found in input file. \\n This file contains following parameters: \\n {0}'.format(gotParametersInputFile))\n\n        targetParameters = { 1:'helical x-axis', 2:'helical y-axis', 3:'helical z-axis' }\n\n        if (step_range):\n            if (len(step) != 2):\n                raise ValueError(\"See, documentation for step usage!!!\")\n\n            if step[0] > step[1]:\n                raise ValueError(\"See, documentation for step usage!!!\")\n            data, time = read_param_file(filename, [1, 2, 3], step, True, startBP=self.startBP)\n        else:\n            data, time = read_param_file(filename, [1, 2, 3], [1, self.num_step], True, startBP=self.startBP)\n\n        self._set_time(time)\n\n        if (step_range):\n            bp_idx, param_idx = get_idx_of_bp_parameters(step, [], True, startBP=self.startBP)\n        else:\n            bp_idx, param_idx = get_idx_of_bp_parameters([1, self.num_step], [], True, startBP=self.startBP)\n\n        for i in range(len(data)):\n            for j in range(len(data[i])):\n                bp_num = str( bp_idx[i]+self.startBP )\n                param = targetParameters[j+1]\n                self._set_data(data[i][j], 'bps', bp_num, param, scaleoffset=2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a new array of boolean values that can be used to mask the local helical axis of the inaccurate base - in - accurate base - in - accurate base - in - accurate base - in - accurate base - in - accurate base - in - accurate base - in - accurate base - in - accurate base - in - accurate base - in - accurate base - in - a.", "response": "def generate_smooth_axis(self, step_range=False, step=None, smooth=500.0, spline=3, fill_point=6, cut_off_angle=20):\n        \"\"\"To determine the global helical axis by smoothing local axis using spline interpolation.\n\n        .. note::\n            A 3D curve is fitted on local helical axis that are calculated using\n            ``do_x3dna`` tool. Sometimes in few frames, fitting **may not** be\n            accurate and produces artifact. To record these frames, ``DNA.mask``\n            array containing boolean values are generated. If value is ``True``,\n            fitting might not be correct and vice versa. This array could be\n            used in later analysis to skip/mask the frames containing inaccurate\n            axis.\n\n        .. warning::\n                This function requires `SciPy package <http://www.scipy.org/>`_.\n\n        Parameters\n        ----------\n        step_range : bool\n            * ``step_range = True`` : Make axis smooth for the given range of base-steps\n            * ``step_range = False``: Make axis smooth for for entire DNA. If original helical-axis of any base-step\n                will be found to be not available, error will be raised.\n\n        step : list\n            List containing lower and higher limit of base-steps range.\n                * This option only works with ``step_range=True``.\n                * This list should not contain more than two number.\n                * First number should be less than second number.\n\n            Example for base-step 4 to 15:\n                ``step = [4,15]         # step_range = True``\n\n        smooth : float\n            A smoothing condition. For more details, see about ``s = None``, which is passed into\n            `scipy.interpolate.splprep() <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.interpolate.splprep.html>`_ method.\n\n            .. warning ::\n                * Lower value may lead to an artifact of local sharp kink in the smoothed axis.\n                * Higher value may lead to the calculation of wrong helical axis.\n\n        spline : int\n            Degree of spline. For more details, see about ``k = 3``, which is passed into\n            `scipy.interpolate.splprep() <https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.interpolate.splprep.html>`_ method.\n\n        fill_point : int\n            Number of intrapolated points between two adjacent helical-axis coordinates.\n\n        cut_off_angle : float\n            Cut-off bending angle to define sharp kink in fitted curve. If angle\n            in fitted curve is larger than this cut-off, refitting will be performed\n            after deleting few of the original helical axis positions. If after\n            this deletions, bending angle will not reduce below cut-off angle,\n            value of ``smooth`` will be increased by 100 and entire cycle of\n            fitting-refitting will be performed. When, value of ``smooth`` increases\n            to more than 10000 during this fitting-refitting cycles, fitting process\n            will be stopped with a warning message.\n\n            To record the frames with bad fitting, ``True`` value will be\n            stored in ``DNA.mask`` array for respective frame.\n\n        \"\"\"\n\n        if not scipy_imported:\n            raise ImportError(\n                \"SciPy package is not available. Please visit http://www.scipy.org/install.html for download and installation instructions.\\n\")\n\n        if (step_range) and (step == None):\n            raise ValueError(\n                \"See, documentation for step  and step_range usage!!!\")\n\n        bp_idx = []\n\n        if step_range:\n            if (len(step) != 2):\n                raise ValueError(\"See, documentation for step usage!!!\")\n\n            if step[0] > step[1]:\n                raise ValueError(\"See, documentation for step usage!!!\")\n            RawX, bp_idx = self.get_parameters( 'helical x-axis', step, bp_range=True)\n            RawY, dummy = self.get_parameters( 'helical y-axis', step, bp_range=True)\n            RawZ, dummy = self.get_parameters( 'helical z-axis', step, bp_range=True)\n        else:\n            RawX, bp_idx = self.get_parameters( 'helical x-axis', [1, self.num_step], bp_range=True)\n            RawY, dummy = self.get_parameters( 'helical y-axis', [1, self.num_step], bp_range=True)\n            RawZ, dummy = self.get_parameters( 'helical z-axis', [1, self.num_step], bp_range=True)\n\n        RawX = np.array(RawX).T\n        RawY = np.array(RawY).T\n        RawZ = np.array(RawZ).T\n\n        smoothX, smoothY, smoothZ = [], [], []\n\n        nframes = len(self.time)\n\n        maskArray = np.zeros(nframes, dtype=bool)\n\n        for i in range(nframes):\n\n            frame_number = i + 1\n            if((frame_number < 100) and (frame_number % 10 == 0)) or ((frame_number < 1000) and (frame_number % 100 == 0)) or (frame_number % 1000 == 0):\n                sys.stdout.write(\"\\rFitting spline curve on helical axis of frame %d out of %d frames\" % (\n                    frame_number, nframes))\n                sys.stdout.flush()\n\n            xsmooth, ysmooth, zsmooth, mask = fit_axis(bp_idx, frame_number, RawX[i], RawY[i], RawZ[i], smooth, spline, fill_point, cut_off_angle)\n            maskArray[i] = mask\n\n            smoothX.append(xsmooth)\n            smoothY.append(ysmooth)\n            smoothZ.append(zsmooth)\n\n        sys.stdout.write(\"\\nFinished spline curve fitting...\\n\")\n        sys.stdout.flush()\n\n        smoothX = np.asarray(smoothX).T\n        smoothY = np.asarray(smoothY).T\n        smoothZ = np.asarray(smoothZ).T\n\n        self.smooth_axis = True\n        for i in range(len(bp_idx)):\n            bp_num = str( bp_idx[i]+self.startBP )\n            self._set_data(smoothX[i], 'bps', bp_num, 'helical x-axis smooth', scaleoffset=2)\n            self._set_data(smoothY[i], 'bps', bp_num, 'helical y-axis smooth', scaleoffset=2)\n            self._set_data(smoothZ[i], 'bps', bp_num, 'helical z-axis smooth', scaleoffset=2)\n\n        # Set mask array\n        self._set_mask(maskArray)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting a trajectory of helical - axis to a PDB file.", "response": "def write_haxis_pdb(self, filename='helical_axis.pdb', step_range=False, step=None, write_smooth_axis=True, write_orig_axis=False, write_curv=False, scale_curv=1):\n        \"\"\"To write trajectory of helcial-axis as a PDB format file.\n\n        Both local helical axis and global (smoothed) axis can be written to PDB file.\n        For global axis, curvature could be written in B-factor field of PDB file.\n\n        Parameters\n        ----------\n        filename : str\n            Name of the output PDB format file.\n\n        step_range : bool\n            * ``step_range = True`` : Make axis smooth for the given range of base-steps\n            * ``step_range = False``: Make axis smooth for entire DNA. If original helical-axis of any base-step will\n                be found to be not available, error will be raised.\n\n        step : list\n            List containing lower and higher limit of base-steps range.\n                * This option only works with ``step_range=True``.\n                * This list should not contain more than two number.\n                * First number should be less than second number.\n\n            Example for base-step 4 to 15:\n                ``step = [4,15]         # step_range = True``\n\n        write_smooth_axis : bool\n            Write coordinates of smoothed helical axis as chain A.\n\n        write_orig_axis : bool\n            Write coordinates of original helical axis (output from do_x3dna) as chain B.\n\n        write_curv : bool\n            Write curvature of smoothed helical axis in B-factor column of PDB file.\n\n        scale_curv : int\n            Scaling of curvature. ``curvature * scale_curv`` is written in  B-factor column of PDB file.\n\n        \"\"\"\n\n        if (step_range) and (step == None):\n            raise ValueError(\n                \"See, documentation for step  and step_range usage!!!\")\n\n        if not write_orig_axis and not write_smooth_axis:\n            raise ValueError(\n                \"Nothing to write as both \\\"write_orig_axis=False\\\" and \\\"write_smooth_axis=False\\\" !!!\")\n\n        if step_range:\n            if (len(step) != 2):\n                raise ValueError(\"See, documentation for step usage!!!\")\n\n            if step[0] > step[1]:\n                raise ValueError(\"See, documentation for step usage!!!\")\n\n            # Original helical axis\n            if (write_orig_axis):\n                RawX, bp_idx = self.get_parameters(\n                    'helical x-axis', step, bp_range=True)\n                RawY, dummy = self.get_parameters(\n                    'helical y-axis', step, bp_range=True)\n                RawZ, dummy = self.get_parameters(\n                    'helical z-axis', step, bp_range=True)\n\n            # Smoothed helical axis\n            if (write_smooth_axis):\n                SmoothX, bp_idx = self.get_parameters(\n                    'helical x-axis smooth', step, bp_range=True)\n                SmoothY, bp_idx = self.get_parameters(\n                    'helical y-axis smooth', step, bp_range=True)\n                SmoothZ, bp_idx = self.get_parameters(\n                    'helical z-axis smooth', step, bp_range=True)\n\n            # curvature\n            if (write_curv):\n                curvature, bp_idx = self.get_parameters(\n                    'curvature', step, bp_range=True)\n\n        else:\n\n            # Original helical axis\n            if (write_orig_axis):\n                RawX, bp_idx = self.get_parameters(\n                    'helical x-axis', [1, self.num_step], bp_range=True)\n                RawY, dummy = self.get_parameters(\n                    'helical y-axis', [1, self.num_step], bp_range=True)\n                RawZ, dummy = self.get_parameters(\n                    'helical z-axis', [1, self.num_step], bp_range=True)\n\n            # Smoothed helical axis\n            if (write_smooth_axis):\n                SmoothX, bp_idx = self.get_parameters(\n                    'helical x-axis smooth', [1, self.num_step], bp_range=True)\n                SmoothY, bp_idx = self.get_parameters(\n                    'helical y-axis smooth', [1, self.num_step], bp_range=True)\n                SmoothZ, bp_idx = self.get_parameters(\n                    'helical z-axis smooth', [1, self.num_step], bp_range=True)\n\n            # curvature\n            if (write_curv):\n                curvature, bp_idx = self.get_parameters(\n                    'curvature', [1, self.num_step], bp_range=True)\n\n        if (write_orig_axis):\n            RawX = np.array(RawX).T\n            RawY = np.array(RawY).T\n            RawZ = np.array(RawZ).T\n\n        if (write_smooth_axis):\n            SmoothX = np.array(SmoothX).T\n            SmoothY = np.array(SmoothY).T\n            SmoothZ = np.array(SmoothZ).T\n\n        if (write_curv):\n            curvature = np.array(curvature).T\n\n        f = open(filename, 'w')\n\n        for i in range(len(self.time)):\n            f.write('%-6s    %4d\\n' % (\"MODEL\", i + 1))\n\n            bfactor = 0.00\n\n            if (write_smooth_axis):\n                for j in range(len(SmoothX[i])):\n\n                    if (write_curv):\n                        bfactor = curvature[i][j] * scale_curv\n\n                    f.write('%-6s%5d %4s%1s%3s %1s%4d%1s   %8.3f%8.3f%8.3f%6.2f%6.2f\\n' % (\"ATOM\", j + 1, \"CA\",\n                                                                                           \" \", \"AXS\", \"A\", j + 1, \" \", SmoothX[i][j], SmoothY[i][j], SmoothZ[i][j], 1.00, bfactor))\n\n                for j in range(len(SmoothX[i]) - 1):\n                    f.write('CONECT %4d %4d\\n' % (j + 1, j + 2))\n\n                f.write(\"TER\\n\")\n\n            if (write_orig_axis):\n                atomstart = 0\n                if (write_smooth_axis):\n                    atomstart = len(SmoothX[i])\n\n                for j in range(len(RawX[i])):\n                    f.write('%-6s%5d %4s%1s%3s %1s%4d%1s   %8.3f%8.3f%8.3f%6.2f%6.2f\\n' % (\"ATOM\", j + 1 +\n                                                                                           atomstart, \"O\", \" \", \"AXS\", \"B\", j + 1, \" \", RawX[i][j], RawY[i][j], RawZ[i][j], 1.00, 0.00))\n\n                for j in range(len(RawX[i]) - 1):\n                    f.write('CONECT %4d %4d\\n' %\n                            (j + 1 + atomstart, j + 2 + atomstart))\n\n                f.write(\"TER\\n\")\n\n            f.write(\"ENDMDL\\n\")\n\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculate_curvature_tangent(self, step_range=False, step=None, store_tangent=False):\n\n        if not self.smooth_axis:\n            raise ValueError(\n                \"The helical axis is not smooth. At first, smooth the axis using generate_smooth_axis() method as described in http://rjdkmr.github.io/do_x3dna/apidoc.html#dnaMD.DNA.generate_smooth_axis.\")\n\n        if (step_range) and (step == None):\n            raise ValueError(\n                \"See, documentation for step  and step_range usage!!!\")\n\n        if step_range:\n            if (len(step) != 2):\n                raise ValueError(\"See, documentation for step usage!!!\")\n\n            if step[0] > step[1]:\n                raise ValueError(\"See, documentation for step usage!!!\")\n\n            X, bp_idx = self.get_parameters(\n                'helical x-axis smooth', step, bp_range=True)\n            Y, bp_idx = self.get_parameters(\n                'helical y-axis smooth', step, bp_range=True)\n            Z, bp_idx = self.get_parameters(\n                'helical z-axis smooth', step, bp_range=True)\n        else:\n            X, bp_idx = self.get_parameters(\n                'helical x-axis smooth', [1, self.num_step], bp_range=True)\n            Y, bp_idx = self.get_parameters(\n                'helical y-axis smooth', [1, self.num_step], bp_range=True)\n            Z, bp_idx = self.get_parameters(\n                'helical z-axis smooth', [1, self.num_step], bp_range=True)\n\n        X = np.asarray(X).T\n        Y = np.asarray(Y).T\n        Z = np.asarray(Z).T\n\n        curvature, tangent = [], []\n\n        for i in range(len(self.time)):\n\n            # Curvature calculation\n            xyz = np.vstack((X[i], Y[i], Z[i])).T\n            T, N, B, k_temp, t_temp = frenet_serret(xyz)\n\n            curvature.append(k_temp.flatten())\n\n            if(store_tangent):\n                tangent.append(T)\n\n        curvature = np.asarray(curvature).T\n        for i in range(len(bp_idx)):\n            bp_num = str( bp_idx[i]+self.startBP )\n            self._set_data(curvature[i], 'bps', bp_num, 'curvature',  scaleoffset=3)\n\n        if(store_tangent):\n            tangent = np.asarray(tangent)\n            final_tan = []\n            for i in range(len(tangent[0])):\n                temp = []\n                for j in range(len(tangent)):\n                    temp.append(tangent[j][i])\n                final_tan.append(np.asarray(temp))\n\n            for i in range(len(bp_idx)):\n                bp_num = str( bp_idx[i]+self.startBP )\n                self._set_data(np.asarray(final_tan[i]), 'bps', bp_num, 'tangent',  scaleoffset=3)", "response": "Calculates the curvature and tangent vectors along the helical axis."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the angle between two tangent vectors of global helical axis and the total number of frames.", "response": "def calculate_angle_bw_tangents(self, base_step, cumulative=False, masked=False):\n        \"\"\"To calculate angle (Radian) between two tangent vectors of global helical axis.\n\n        Parameters\n        ----------\n        base_step : 1D list\n            List of two base-steps for which angle will be calculated.\n            For example: **base_step** = ``[5, 50]`` either of following can be calculated.\n\n                (1) angle between tangent vector 5th and 50th base-steps.\n                (2) summation over 44 angles that are formed between adjacent tangent\n                    vectors of 5-50 bp DNA segment.\n\n            See below two choose between these two types.\n\n        cumulative : bool)\n            ``Default: False``: If it is false, first type of angle is calculated\n            otherwise second type of angle is calculated as explained in the above\n            example of option ``base_step``.\n\n        masked : bool\n            ``Default=False``. To skip specific frames/snapshots.\n            ``DNA.mask`` array should be set to use this functionality.\n            This array contains boolean (either ``True`` or ``False``) value\n            for each frame to mask the frames. Presently, mask array is\n            automatically generated during :meth:`DNA.generate_smooth_axis` to\n            skip those frames where 3D fitting curve was not successful within\n            the given criteria.\n\n        Returns\n        -------\n        angle : 1D array\n            Array of calculated angle of length is equal to number of frames.\n            When ``masked`` is applied, length of this array can be smaller than\n            total number of frames.\n\n        \"\"\"\n\n        if (len(base_step) != 2):\n            raise ValueError(\"See, documentation for step usage!!!\")\n\n        if base_step[0] > base_step[1]:\n            raise ValueError(\"See, documentation for step usage!!!\")\n\n        angle = []\n        if cumulative:\n            angle_tmp = []\n            tangent, idx = self.get_parameters(\n                'tangent', bp=base_step, bp_range=True, masked=masked)\n            for i in range(len(idx) - 1):\n                angle_tmp.append(vector_angle(tangent[i], tangent[i + 1]))\n            angle = np.asarray(angle_tmp).sum(axis=0)\n\n        else:\n            tangent1, idx1 = self.get_parameters(\n                'tangent', bp=[base_step[0]], bp_range=False, masked=masked)\n            tangent2, idx2 = self.get_parameters(\n                'tangent', bp=[base_step[1]], bp_range=False, masked=masked)\n            angle = vector_angle(tangent1[0], tangent2[0])\n\n        return np.asarray(angle)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the 2D angles of the 2D helical tangents of the local entry in the DNA system.", "response": "def calculate_2D_angles_bw_tangents(self, paxis, base_step, masked=True):\n        \"\"\" To calculate angles (Radian) in 2D plane between two tangent vectors of global helical axis.\n\n        .. list-table::  Principal axis and respective 2D planes\n            :widths: 1, 4\n            :header-rows: 1\n            :name: gui-table\n\n            * - Principal Axis\n              - 2D planes\n\n            * - X-axis\n              - XY and XZ planes\n\n            * - Y-axis\n              - XY and YZ planes\n\n            * - Z-axis\n              - XZ and YZ planes\n\n        Parameters\n        ----------\n        paxis : str\n            Principal axis parallel to the DNA axis. For example, IF DNA helical\n            axis is parallel or aligned with Z-axis, paxis should be ``'Z'``.\n        base_step : 1D list\n            List of two base-steps for which angle will be calculated.\n            For example: **base_step** = ``[5, 50]`` angle between tangent vector\n            5th and 50th base-steps will be calculated.\n        masked : bool\n            ``Default=False``. To skip specific frames/snapshots.\n            ``DNA.mask`` array should be set to use this functionality.\n            This array contains boolean (either ``True`` or ``False``) value\n            for each frame to mask the frames. Presently, mask array is\n            automatically generated during :meth:`DNA.generate_smooth_axis` to\n            skip those frames where 3D fitting curve was not successful within\n            the given criteria.\n\n        Returns\n        -------\n        angle-one : 1D array\n            Array of calculated angle in first plane of length is equal to\n            number of frames. When ``masked`` is applied, length of this array\n            can be smaller than total number of frames.\n        angle-two : 1D array\n            Array of calculated angle in second plane of length is equal to\n            number of frames. When ``masked`` is applied, length of this array\n            can be smaller than total number of frames.\n\n        \"\"\"\n\n        if (len(base_step) != 2):\n            raise ValueError(\"See, documentation for step usage!!!\")\n\n        if base_step[0] > base_step[1]:\n            raise ValueError(\"See, documentation for step usage!!!\")\n\n        axisDict = {'X': 0, 'Y': 1, 'Z': 2 }\n\n        if paxis == 'Z':\n            planes = [0, 1]\n        elif paxis == 'X':\n            planes = [1, 2]\n        elif paxis == 'Y':\n            planes = [0, 2]\n        else:\n            raise ValueError('{0} is not accepted keyword. USE: X Y or Z for DNA-axis.')\n\n        tangent1, idx1 = self.get_parameters('tangent', bp=[base_step[0]], bp_range=False, masked=masked)\n        tangent2, idx2 = self.get_parameters('tangent', bp=[base_step[1]], bp_range=False, masked=masked)\n\n\n        angles = []\n        for plane in planes:\n            if plane == 0:\n                norm = [1, 0, 0]\n            elif plane == 1:\n                norm = [0, 1, 0]\n            else:\n                norm = [0, 0, 1]\n\n            temp1 = tangent1[0].T[plane].copy()\n            temp2 = tangent2[0].T[plane].copy()\n\n            tangent1[0].T[plane] = np.zeros(tangent1[0].T[plane].shape)\n            tangent2[0].T[plane] = np.zeros(tangent2[0].T[plane].shape)\n\n            angle = vector_angle(tangent1[0], tangent2[0], norm=norm)\n\n            tangent1[0].T[plane]  = temp1\n            tangent2[0].T[plane]  = temp2\n\n            angles.append(angle)\n        '''\n        angles = []\n        shape = (tangent1[0].shape[0], 2)\n        for plane in planes:\n            if plane == 0:\n                norm = [1, 0, 0]\n            elif plane == 1:\n                norm = [0, 1, 0]\n            else:\n                norm = [0, 0, 1]\n\n            temp1 = np.zeros(shape)\n            temp2 = np.zeros(shape)\n\n            print(tangent1[0].T.shape, temp1.T.shape)\n\n            temp1[:, 0] = tangent1[0].T[plane][:]\n            temp1[:, 1] = tangent1[0].T[axisDict[paxis]][:]\n            temp2[:, 0] = tangent2[0].T[plane][:]\n            temp2[:, 1] = tangent2[0].T[axisDict[paxis]][:]\n\n\n            #tangent1[0].T[plane] = np.zeros(tangent1[0].T[plane].shape)\n            #tangent2[0].T[plane] = np.zeros(tangent2[0].T[plane].shape)\n\n            #angle = vector_angle(temp1, temp2)\n            angle = []\n            #print(np.linalg.det([temp1.T,temp2.T]).shape)\n            for i in range(temp1.shape[0]):\n                a = np.math.atan2(np.linalg.det([temp1[i],temp2[1]]), np.dot(temp1[i],temp2[1]))\n                angle.append(a)\n            angle = np.asarray(angle)\n\n            #tangent1[0].T[plane]  = temp1\n            #tangent2[0].T[plane]  = temp2\n\n            angles.append(angle)\n        '''\n\n\n\n        return np.asarray(angles[0]), np.asarray(angles[1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing as main setter for rgb", "response": "def rgb(self, color_tuple):\n        \"\"\"Used as main setter (rgb256, hls, hls256, hsv, hsv256)\"\"\"\n        # Check bounds\n        self.color = tuple(map(self._apply_float_bounds, color_tuple[:3]))\n\n        # Include alpha if necessary\n        if len(color_tuple) > 3:\n            self.alpha = self._apply_float_bounds(color_tuple[3])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hls(self):\n        r, g, b = self.color\n        hls = colorsys.rgb_to_hls(r, g, b)\n        hls = (int(round(hls[0] * 360)), hls[1], hls[2])\n        return self._append_alpha_if_necessary(hls)", "response": "Return a new HLS tuple."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmy(self):\n        r, g, b = self.color\n        c = 1 - r\n        m = 1 - g\n        y = 1 - b\n\n        return (c, m, y)", "response": "Return the CMY color and other components of the current color set."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmyk(self):\n        c, m, y = self.cmy\n        k = min(c, m, y)\n\n        # Handle division by zero in case of black = 1\n        if k != 1:\n            c = (c - k) / (1 - k)\n            m = (m - k) / (1 - k)\n            y = (y - k) / (1 - k)\n        else:\n            c, m, y = 1, 1, 1\n\n        cmyk = (c, m, y, k)\n\n        # Apply bound and return\n        return tuple(map(lambda x: self._apply_float_bounds(x), cmyk))", "response": "CMYK - all returned in range 0. 0 - 1. 0"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add(self, num, price, aType, stuff_status, title, desc, location_state, location_city, cid, session, **kwargs):\n        '''taobao.item.add \u6dfb\u52a0\u4e00\u4e2a\u5546\u54c1\n        \n        \u6b64\u63a5\u53e3\u7528\u4e8e\u65b0\u589e\u4e00\u4e2a\u5546\u54c1 \u5546\u54c1\u6240\u5c5e\u7684\u5356\u5bb6\u662f\u5f53\u524d\u4f1a\u8bdd\u7684\u7528\u6237 \u5546\u54c1\u7684\u5c5e\u6027\u548csku\u7684\u5c5e\u6027\u6709\u5305\u542b\u7684\u5173\u7cfb\uff0c\u5546\u54c1\u7684\u4ef7\u683c\u8981\u4f4d\u4e8esku\u7684\u4ef7\u683c\u533a\u95f4\u4e4b\u4e2d\uff08\u4f8b\u5982\uff0csku\u4ef7\u683c\u67095\u5143\u300110\u5143\u4e24\u79cd\uff0c\u90a3\u4e48\u5546\u54c1\u7684\u4ef7\u683c\u5c31\u9700\u8981\u5927\u4e8e\u7b49\u4e8e5\u5143\uff0c\u5c0f\u4e8e\u7b49\u4e8e10\u5143\uff0c\u5426\u5219\u65b0\u589e\u5546\u54c1\u4f1a\u5931\u8d25\uff09 \u5546\u54c1\u7684\u7c7b\u76ee\u548c\u5546\u54c1\u7684\u4ef7\u683c\u3001sku\u7684\u4ef7\u683c\u90fd\u6709\u4e00\u5b9a\u7684\u76f8\u5173\u6027\uff08\u5177\u4f53\u7684\u5173\u7cfb\u8981\u901a\u8fc7\u7c7b\u76ee\u5c5e\u6027\u67e5\u8be2\u63a5\u53e3\u83b7\u5f97\uff09 \u5546\u54c1\u7684\u8fd0\u8d39\u627f\u62c5\u65b9\u5f0f\u548c\u90ae\u8d39\u8bbe\u7f6e\u6709\u76f8\u5173\u6027\uff0c\u5356\u5bb6\u627f\u62c5\u8fd0\u8d39\u4e0d\u7528\u8bbe\u7f6e\u90ae\u8d39\uff0c\u4e70\u5bb6\u627f\u62c5\u8fd0\u8d39\u9700\u8981\u8bbe\u7f6e\u90ae\u8d39 \u5f53\u5173\u952e\u5c5e\u6027\u503c\u9009\u62e9\u4e86\u201c\u5176\u4ed6\u201d\u7684\u65f6\u5019\uff0c\u9700\u8981\u8f93\u5165input_pids\u548cinput_str\u5546\u54c1\u624d\u80fd\u6dfb\u52a0\u6210\u529f\u3002'''\n        request = TOPRequest('taobao.item.add')\n        request['num'] = num\n        request['price'] = price\n        request['type'] = aType\n        request['stuff_status'] = stuff_status\n        request['title'] = title\n        request['desc'] = desc\n        request['location.state'] = location_state\n        request['location.city'] = location_city\n        request['cid'] = cid\n        for k, v in kwargs.iteritems():\n            if k not in ('props', 'approve_status', 'freight_payer', 'valid_thru', 'has_invoice', 'has_warranty', 'has_showcase', 'seller_cids', 'has_discount', 'post_fee', 'express_fee', 'ems_fee', 'list_time', 'increment', 'image', 'postage_id', 'auction_point', 'property_alias', 'input_pids', 'sku_properties', 'sku_prices', 'sku_outer_ids', 'lang', 'outer_id', 'product_id', 'pic_path', 'auto_fill', 'input_str', 'is_taobao', 'is_ex', 'is_3D', 'sell_promise', 'after_sale_id', 'cod_postage_id', 'is_lightning_consignment', 'weight', 'is_xinpin', 'sub_stock') and v==None: continue\n            request[k] = v\n        \n        self.create(self.execute(request, session)['item'])\n        return self", "response": "taobao.item.add \u6dfb\u52a0\u4e00\u4e2a\u5546\u54c1\n        \n        \u6b64\u63a5\u53e3\u7528\u4e8e\u65b0\u589e\u4e00\u4e2a\u5546\u54c1 \u5546\u54c1\u6240\u5c5e\u7684\u5356\u5bb6\u662f\u5f53\u524d\u4f1a\u8bdd\u7684\u7528\u6237 \u5546\u54c1\u7684\u5c5e\u6027\u548csku\u7684\u5c5e\u6027\u6709\u5305\u542b\u7684\u5173\u7cfb\uff0c\u5546\u54c1\u7684\u4ef7\u683c\u8981\u4f4d\u4e8esku\u7684\u4ef7\u683c\u533a\u95f4\u4e4b\u4e2d\uff08\u4f8b\u5982\uff0csku\u4ef7\u683c\u67095\u5143\u300110\u5143\u4e24\u79cd\uff0c\u90a3\u4e48\u5546\u54c1\u7684\u4ef7\u683c\u5c31\u9700\u8981\u5927\u4e8e\u7b49\u4e8e5\u5143\uff0c\u5c0f\u4e8e\u7b49\u4e8e10\u5143\uff0c\u5426\u5219\u65b0\u589e\u5546\u54c1\u4f1a\u5931\u8d25\uff09 \u5546\u54c1\u7684\u7c7b\u76ee\u548c\u5546\u54c1\u7684\u4ef7\u683c\u3001sku\u7684\u4ef7\u683c\u90fd\u6709\u4e00\u5b9a\u7684\u76f8\u5173\u6027\uff08\u5177\u4f53\u7684\u5173\u7cfb\u8981\u901a\u8fc7\u7c7b\u76ee\u5c5e\u6027\u67e5\u8be2\u63a5\u53e3\u83b7\u5f97\uff09 \u5546\u54c1\u7684\u8fd0\u8d39\u627f\u62c5\u65b9\u5f0f\u548c\u90ae\u8d39\u8bbe\u7f6e\u6709\u76f8\u5173\u6027\uff0c\u5356\u5bb6\u627f\u62c5\u8fd0\u8d39\u4e0d\u7528\u8bbe\u7f6e\u90ae\u8d39\uff0c\u4e70\u5bb6\u627f\u62c5\u8fd0\u8d39\u9700\u8981\u8bbe\u7f6e\u90ae\u8d39 \u5f53\u5173\u952e\u5c5e\u6027\u503c\u9009\u62e9\u4e86\u201c\u5176\u4ed6\u201d\u7684\u65f6\u5019\uff0c\u9700\u8981\u8f93\u5165input_pids\u548cinput_str\u5546\u54c1\u624d\u80fd\u6dfb\u52a0\u6210\u529f\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update(self, num_iid, session, **kwargs):\n        '''taobao.item.update \u66f4\u65b0\u5546\u54c1\u4fe1\u606f\n        \n        \u6839\u636e\u4f20\u5165\u7684num_iid\u66f4\u65b0\u5bf9\u5e94\u7684\u5546\u54c1\u7684\u6570\u636e \u4f20\u5165\u7684num_iid\u6240\u5bf9\u5e94\u7684\u5546\u54c1\u5fc5\u987b\u5c5e\u4e8e\u5f53\u524d\u4f1a\u8bdd\u7684\u7528\u6237 \u5546\u54c1\u7684\u5c5e\u6027\u548csku\u7684\u5c5e\u6027\u6709\u5305\u542b\u7684\u5173\u7cfb\uff0c\u5546\u54c1\u7684\u4ef7\u683c\u8981\u4f4d\u4e8esku\u7684\u4ef7\u683c\u533a\u95f4\u4e4b\u4e2d\uff08\u4f8b\u5982\uff0csku\u4ef7\u683c\u67095\u5143\u300110\u5143\u4e24\u79cd\uff0c\u90a3\u4e48\u5546\u54c1\u7684\u4ef7\u683c\u5c31\u9700\u8981\u5927\u4e8e\u7b49\u4e8e5\u5143\uff0c\u5c0f\u4e8e\u7b49\u4e8e10\u5143\uff0c\u5426\u5219\u66f4\u65b0\u5546\u54c1\u4f1a\u5931\u8d25\uff09 \u5546\u54c1\u7684\u7c7b\u76ee\u548c\u5546\u54c1\u7684\u4ef7\u683c\u3001sku\u7684\u4ef7\u683c\u90fd\u6709\u4e00\u5b9a\u7684\u76f8\u5173\u6027\uff08\u5177\u4f53\u7684\u5173\u7cfb\u8981\u901a\u8fc7\u7c7b\u76ee\u5c5e\u6027\u67e5\u8be2\u63a5\u53e3\u83b7\u5f97\uff09 \u5f53\u5173\u952e\u5c5e\u6027\u503c\u66f4\u65b0\u4e3a\u201c\u5176\u4ed6\u201d\u7684\u65f6\u5019\uff0c\u9700\u8981\u8f93\u5165input_pids\u548cinput_str\u5546\u54c1\u624d\u80fd\u66f4\u65b0\u6210\u529f\u3002'''\n        request = TOPRequest('taobao.item.update')\n        request['num_iid'] = num_iid\n        for k, v in kwargs.iteritems():\n            if k not in ('cid', 'props', 'num', 'price', 'title', 'desc', 'location_state', 'location_city', 'post_fee', 'express_fee', 'ems_fee', 'list_time', 'increment', 'image', 'stuff_status', 'auction_point', 'property_alias', 'input_pids', 'sku_quantities', 'sku_prices', 'sku_properties', 'seller_cids', 'postage_id', 'outer_id', 'product_id', 'pic_path', 'auto_fill', 'sku_outer_ids', 'is_taobao', 'is_ex', 'is_3D', 'is_replace_sku', 'input_str', 'lang', 'has_discount', 'has_showcase', 'approve_status', 'freight_payer', 'valid_thru', 'has_invoice', 'has_warranty', 'after_sale_id', 'sell_promise', 'cod_postage_id', 'is_lightning_consignment', 'weight', 'is_xinpin', 'sub_stock') and v==None: continue\n            if k == 'location_state': k = 'location.state'\n            if k == 'location_city': k = 'location.city'\n            request[k] = v\n        \n        self.create(self.execute(request, session)['item'])\n        return self", "response": "Update a item in a resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_listing(self, num_iid, num, session):\n        '''taobao.item.update.listing \u4e00\u53e3\u4ef7\u5546\u54c1\u4e0a\u67b6\n        \n        \u5355\u4e2a\u5546\u54c1\u4e0a\u67b6 \n        \u8f93\u5165\u7684num_iid\u5fc5\u987b\u5c5e\u4e8e\u5f53\u524d\u4f1a\u8bdd\u7528\u6237'''\n        request = TOPRequest('taobao.item.update.listing')\n        request['num_iid'] = num_iid\n        request['num'] = num\n        self.create(self.execute(request, session)['item'])\n        return self", "response": "TAOBAO. item. update. listing \u4e00\u53e3\u4ef7\u5546\u54c1\u4e0a\u67b6\n        \n        \u8f93\u5165\u7684num_iid\u5fc5\u987b\u5c5e\u6027"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef quantity_update(self, num_iid, quantity, session, sku_id=None, outer_id=None, aType=None):\n        '''taobao.item.quantity.update \u5b9d\u8d1d/SKU\u5e93\u5b58\u4fee\u6539\n        \n        \u63d0\u4f9b\u6309\u7167\u5168\u91cf\u6216\u589e\u91cf\u5f62\u5f0f\u4fee\u6539\u5b9d\u8d1d/SKU\u5e93\u5b58\u7684\u529f\u80fd'''\n        request = TOPRequest('taobao.item.quantity.update')\n        request['num_iid'] = num_iid\n        request['quantity'] = quantity\n        if sku_id!=None:\n            request['sku_id'] = sku_id\n        if outer_id!=None:\n            request['outer_id'] = outer_id\n        if aType!=None:\n            request['type'] = aType\n        self.create(self.execute(request, session)['item'])\n        return self", "response": "TAOBAO. item. quantity. update \u5b9d\u8d1d \u53d6\u5f97\u5230 \u5b9d\u8d1d \u53d6\u5f97\u5230 \u5b9d\u8d1d \u53d6\u5f97\u5230 \u5b9d\u8d1d \u53d6\u5f97\u5230 \u5b9d\u8d1d \u53d6\u5f97\u5230 \u5b9d"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, session, fields=[], **kwargs):\n        '''taobao.items.get \u641c\u7d22\u5546\u54c1\u4fe1\u606f\n        \n        \u6839\u636e\u4f20\u5165\u7684\u641c\u7d22\u6761\u4ef6\uff0c\u83b7\u53d6\u5546\u54c1\u5217\u8868\uff08\u7c7b\u4f3c\u4e8e\u6dd8\u5b9d\u9875\u9762\u4e0a\u7684\u5546\u54c1\u641c\u7d22\u529f\u80fd\uff0c\u4f46\u662f\u53ea\u6709\u641c\u7d22\u5230\u7684\u5546\u54c1\u5217\u8868\uff0c\u4e0d\u5305\u542b\u5546\u54c1\u7684ItemCategory\u5217\u8868\uff09 \u53ea\u80fd\u83b7\u5f97\u5546\u54c1\u7684\u90e8\u5206\u4fe1\u606f\uff0c\u5546\u54c1\u7684\u8be6\u7ec6\u4fe1\u606f\u8bf7\u901a\u8fc7taobao.item.get\u83b7\u53d6 \u5982\u679c\u53ea\u8f93\u5165fields\u5176\u4ed6\u6761\u4ef6\u90fd\u4e0d\u8f93\u5165\uff0c\u7cfb\u7edf\u4f1a\u56e0\u4e3a\u641c\u7d22\u6761\u4ef6\u4e0d\u8db3\u800c\u62a5\u9519\u3002 \u4e0d\u80fd\u901a\u8fc7\u8bbe\u7f6ecid=0\u6765\u67e5\u8be2\u3002'''\n        request = TOPRequest('taobao.items.get')\n        if not fields:\n            item = Item()\n            fields = item.fields\n        request['fields'] = fields\n        for k, v in kwargs.iteritems():\n            if k not in ('q', 'nicks', 'cid', 'props', 'product_id', 'page_no', 'order_by', 'ww_status', 'post_free', 'location_state', 'location_city', 'is_3D', 'start_score', 'end_score', 'start_volume', 'end_volume', 'one_station', 'is_cod', 'is_mall', 'is_prepay', 'genuine_security', 'stuff_status', 'start_price', 'end_price', 'page_size', 'promoted_service', 'is_xinpin') and v==None: continue\n            if k == 'location_state': k = 'location.state'\n            if k == 'location_city': k = 'location.city'\n            request[k] = v\n        \n        self.create(self.execute(request, session))\n        return self.items", "response": "TAOBAO. items. get \u83b7\u53d6\u5546\u54c1\u5217\u8868"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search(self, fields=[], **kwargs):\n        '''taobao.items.search \u641c\u7d22\u5546\u54c1\u4fe1\u606f\n        \n        - \u6839\u636e\u4f20\u5165\u7684\u641c\u7d22\u6761\u4ef6\uff0c\u83b7\u53d6\u5546\u54c1\u5217\u8868\u548c\u5546\u54c1\u7c7b\u76ee\u4fe1\u606fItemCategory\u5217\u8868\uff08\u7c7b\u4f3c\u4e8e\u6dd8\u5b9d\u9875\u9762\u4e0a\u7684\u5546\u54c1\u641c\u7d22\u529f\u80fd\uff0c\u4e0e taobao.items.get\u7684\u533a\u522b\u5728\u4e8e\uff1a\u8fd9\u4e2a\u65b9\u6cd5\u5f97\u5230\u7684\u7ed3\u679c\u65e2\u6709\u5546\u54c1\u5217\u8868\uff0c\u53c8\u6709\u7c7b\u76ee\u4fe1\u606f\u5217\u8868\uff09 \n        - \u5546\u54c1\u5217\u8868\u91cc\u53ea\u80fd\u83b7\u5f97\u5546\u54c1\u7684\u90e8\u5206\u4fe1\u606f\uff0c\u5546\u54c1\u7684\u8be6\u7ec6\u4fe1\u606f\u8bf7\u901a\u8fc7taobao.item.get\u83b7\u53d6 \n        - \u5546\u54c1\u7c7b\u76ee\u4fe1\u606f\u5217\u8868\u91cc\u53ea\u5305\u542b\u7c7b\u76eeid\u548c\u8be5\u7c7b\u76ee\u4e0b\u5546\u54c1\u7684\u6570\u91cf \n        - \u4e0d\u80fd\u901a\u8fc7\u8bbe\u7f6ecid=0\u6765\u67e5\u8be2'''\n        request = TOPRequest('taobao.items.search')\n        if not fields:\n            item = Item()\n            fields = item.fields\n        request['fields'] = fields\n        for k, v in kwargs.iteritems():\n            if k not in ('q', 'nicks', 'cid', 'props', 'product_id', 'order_by', 'ww_status', 'post_free', 'location_state', 'location_city', 'is_3D', 'start_score', 'end_score', 'start_volume', 'end_volume', 'one_station', 'is_cod', 'is_mall', 'is_prepay', 'genuine_security', 'promoted_service', 'stuff_status', 'start_price', 'end_price', 'page_no', 'page_size', 'auction_flag', 'auto_post', 'has_discount', 'is_xinpin') and v==None: continue\n            if k == 'location_state': k = 'location.state'\n            if k == 'location_city': k = 'location.city'\n            request[k] = v\n        \n        self.create(self.execute(request))\n        return self.item_search", "response": "TAOBAO. items. search \u641c\u7d22\u5546\u54c1\u4fe1\u606f\uff0c\u83b7\u53d6\u5546\u54c1\u7c7b\u578b\u53c2\u6570"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, num_iid, properties, quantity, price, session, outer_id=None, item_price=None, lang=None):\n        '''taobao.item.sku.add \u6dfb\u52a0SKU\n        \n        \u65b0\u589e\u4e00\u4e2asku\u5230num_iid\u6307\u5b9a\u7684\u5546\u54c1\u4e2d \u4f20\u5165\u7684iid\u6240\u5bf9\u5e94\u7684\u5546\u54c1\u5fc5\u987b\u5c5e\u4e8e\u5f53\u524d\u4f1a\u8bdd\u7684\u7528\u6237'''\n        request = TOPRequest('taobao.item.sku.add')\n        request['num_iid'] = num_iid\n        request['properties'] = properties\n        request['quantity'] = quantity\n        request['price'] = price\n        if outer_id!=None:\n            request['outer_id'] = outer_id\n        if item_price!=None:\n            request['item_price'] = item_price\n        if lang!=None:\n            request['lang'] = lang\n        self.create(self.execute(request, session)['sku'])\n        return self", "response": "TAOBAO. item. sku. add \u6dfb\u52a0SKU\n        \n        \u65b0\u589e\u4e00\u4e2aSKU\u5230num_iid \u4e2d \u4f20\u5165\u7684SKU\u5230outer_id \u4f20\u5165\u7684SKU\u5230item_price \u4f20\u5165\u7684SKU\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef custom_get(self, outer_id, session, fields=[]):\n        '''taobao.skus.custom.get \u6839\u636e\u5916\u90e8ID\u53d6\u5546\u54c1SKU\n        \n        \u8ddf\u636e\u5356\u5bb6\u8bbe\u5b9a\u7684Sku\u7684\u5916\u90e8id\u83b7\u53d6\u5546\u54c1\uff0c\u5982\u679c\u4e00\u4e2aouter_id\u5bf9\u5e94\u591a\u4e2aSku\u4f1a\u8fd4\u56de\u6240\u6709\u7b26\u5408\u6761\u4ef6\u7684sku \u8fd9\u4e2aSku\u6240\u5c5e\u5356\u5bb6\u4ece\u4f20\u5165\u7684session\u4e2d\u83b7\u53d6\uff0c\u9700\u8981session\u7ed1\u5b9a(\u6ce8\uff1aiid\u6807\u7b7e\u91cc\u662fnum_iid\u7684\u503c\uff0c\u53ef\u4ee5\u7528\u4f5cnum_iid\u4f7f\u7528)'''\n        request = TOPRequest('taobao.skus.custom.get')\n        request['outer_id'] = outer_id\n        if not fields:\n            item = Item()\n            fields = item.fields\n        request['fields'] = fields\n        self.create(self.execute(request, session))\n        return self.skus", "response": "TAOBAO. skus. custom. get \u6839\u636e\u5916\u90e8ID\u53d6\u5546\u54c1SKU\n        \u8ddf\u636e\u5916\u90e8id\u53d6\u5546\u54c1SKU\n        \u8ddf\u636e\u5916\u90e8id\u8ddf\u636e\u5916\u90e8\u5356\u54c1SKU\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef joint_img(self, num_iid, pic_path, session, id=None, position=None, is_major=None):\n        '''taobao.item.joint.img \u5546\u54c1\u5173\u8054\u5b50\u56fe\n        \n        - \u5173\u8054\u4e00\u5f20\u5546\u54c1\u56fe\u7247\u5230num_iid\u6307\u5b9a\u7684\u5546\u54c1\u4e2d \n        - \u4f20\u5165\u7684num_iid\u6240\u5bf9\u5e94\u7684\u5546\u54c1\u5fc5\u987b\u5c5e\u4e8e\u5f53\u524d\u4f1a\u8bdd\u7684\u7528\u6237 \n        - \u5546\u54c1\u56fe\u7247\u5173\u8054\u5728\u5356\u5bb6\u8eab\u4efd\u548c\u56fe\u7247\u6765\u6e90\u4e0a\u7684\u9650\u5236\uff0c\u5356\u5bb6\u8981\u662fB\u5356\u5bb6\u6216\u8ba2\u8d2d\u4e86\u591a\u56fe\u670d\u52a1\u624d\u80fd\u5173\u8054\u56fe\u7247\uff0c\u5e76\u4e14\u56fe\u7247\u8981\u6765\u81ea\u4e8e\u5356\u5bb6\u81ea\u5df1\u7684\u56fe\u7247\u7a7a\u95f4\u624d\u884c \n        - \u5546\u54c1\u56fe\u7247\u6570\u91cf\u6709\u9650\u5236\u3002\u4e0d\u7ba1\u662f\u4e0a\u4f20\u7684\u56fe\u7247\u8fd8\u662f\u5173\u8054\u7684\u56fe\u7247\uff0c\u4ed6\u4eec\u7684\u603b\u6570\u4e0d\u80fd\u8d85\u8fc7\u4e00\u5b9a\u9650\u989d'''\n        request = TOPRequest('taobao.item.joint.img')\n        request['num_iid'] = num_iid\n        request['pic_path'] = pic_path\n        if id!=None:\n            request['id'] = id\n        if position!=None:\n            request['position'] = position\n        if is_major!=None:\n            request['is_major'] = is_major\n        self.create(self.execute(request, session)['item_img'])\n        return self", "response": "This method returns a joint image."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef joint_prop(self, properties, pic_path, num_iid, session, id=None, position=None):\n        '''taobao.item.joint.propimg \u5546\u54c1\u5173\u8054\u5c5e\u6027\u56fe\n        \n        - \u5173\u8054\u4e00\u5f20\u5546\u54c1\u5c5e\u6027\u56fe\u7247\u5230num_iid\u6307\u5b9a\u7684\u5546\u54c1\u4e2d \n        - \u4f20\u5165\u7684num_iid\u6240\u5bf9\u5e94\u7684\u5546\u54c1\u5fc5\u987b\u5c5e\u4e8e\u5f53\u524d\u4f1a\u8bdd\u7684\u7528\u6237 \n        - \u56fe\u7247\u7684\u5c5e\u6027\u5fc5\u987b\u8981\u662f\u989c\u8272\u7684\u5c5e\u6027\uff0c\u8fd9\u4e2a\u5728\u524d\u53f0\u663e\u793a\u7684\u65f6\u5019\u9700\u8981\u548csku\u8fdb\u884c\u5173\u8054\u7684 \n        - \u5546\u54c1\u56fe\u7247\u5173\u8054\u5728\u5356\u5bb6\u8eab\u4efd\u548c\u56fe\u7247\u6765\u6e90\u4e0a\u7684\u9650\u5236\uff0c\u5356\u5bb6\u8981\u662fB\u5356\u5bb6\u6216\u8ba2\u8d2d\u4e86\u591a\u56fe\u670d\u52a1\u624d\u80fd\u5173\u8054\u56fe\u7247\uff0c\u5e76\u4e14\u56fe\u7247\u8981\u6765\u81ea\u4e8e\u5356\u5bb6\u81ea\u5df1\u7684\u56fe\u7247\u7a7a\u95f4\u624d\u884c \n        - \u5546\u54c1\u56fe\u7247\u6570\u91cf\u6709\u9650\u5236\u3002\u4e0d\u7ba1\u662f\u4e0a\u4f20\u7684\u56fe\u7247\u8fd8\u662f\u5173\u8054\u7684\u56fe\u7247\uff0c\u4ed6\u4eec\u7684\u603b\u6570\u4e0d\u80fd\u8d85\u8fc7\u4e00\u5b9a\u9650\u989d\uff0c\u6700\u591a\u4e0d\u80fd\u8d85\u8fc724\u5f20\uff08\u6bcf\u4e2a\u989c\u8272\u5c5e\u6027\u90fd\u6709\u4e00\u5f20\uff09'''\n        request = TOPRequest('taobao.item.joint.prop')\n        request['num_iid'] = num_iid\n        request['pic_path'] = pic_path\n        request['properties'] = properties\n        if id!=None:\n            request['id'] = id\n        if position!=None:\n            request['position'] = position\n        self.create(self.execute(request, session)['prop_img'])\n        return self", "response": "This method is used to create a new joint property."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload(self, num_iid, properties, session, id=None, image=None, position=None):\n        '''taobao.item.propimg.upload \u6dfb\u52a0\u6216\u4fee\u6539\u5c5e\u6027\u56fe\u7247\n        \n        \u6dfb\u52a0\u4e00\u5f20\u5546\u54c1\u5c5e\u6027\u56fe\u7247\u5230num_iid\u6307\u5b9a\u7684\u5546\u54c1\u4e2d \u4f20\u5165\u7684num_iid\u6240\u5bf9\u5e94\u7684\u5546\u54c1\u5fc5\u987b\u5c5e\u4e8e\u5f53\u524d\u4f1a\u8bdd\u7684\u7528\u6237 \u56fe\u7247\u7684\u5c5e\u6027\u5fc5\u987b\u8981\u662f\u989c\u8272\u7684\u5c5e\u6027\uff0c\u8fd9\u4e2a\u5728\u524d\u53f0\u663e\u793a\u7684\u65f6\u5019\u9700\u8981\u548csku\u8fdb\u884c\u5173\u8054\u7684 \u5546\u54c1\u5c5e\u6027\u56fe\u7247\u53ea\u6709\u4eab\u6709\u670d\u52a1\u7684\u5356\u5bb6\uff08\u5982\uff1a\u6dd8\u5b9d\u5927\u5356\u5bb6\u3001\u8ba2\u8d2d\u4e86\u6dd8\u5b9d\u591a\u56fe\u670d\u52a1\u7684\u5356\u5bb6\uff09\u624d\u80fd\u4e0a\u4f20 \u5546\u54c1\u5c5e\u6027\u56fe\u7247\u6709\u6570\u91cf\u548c\u5927\u5c0f\u4e0a\u7684\u9650\u5236\uff0c\u6700\u591a\u4e0d\u80fd\u8d85\u8fc724\u5f20\uff08\u6bcf\u4e2a\u989c\u8272\u5c5e\u6027\u90fd\u6709\u4e00\u5f20\uff09\u3002'''\n        request = TOPRequest('taobao.item.propimg.upload')\n        request['num_iid'] = num_iid\n        request['properties'] = properties\n        if id!=None:\n            request['id'] = id\n        if position!=None:\n            request['position'] = position\n        if image!=None:\n            request['image'] = image\n        self.create(self.execute(request, session)['prop_img'])\n        return self", "response": "Upload a new image to a new item."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, id, product_id, session):\n        '''taobao.product.img.delete \u5220\u9664\u4ea7\u54c1\u975e\u4e3b\u56fe\n        \n        1.\u4f20\u5165\u975e\u4e3b\u56feID 2.\u4f20\u5165\u4ea7\u54c1ID \u5220\u9664\u4ea7\u54c1\u975e\u4e3b\u56fe'''\n        request = TOPRequest('taobao.product.img.delete')\n        request['id'] = id\n        request['product_id'] = product_id\n        self.create(self.execute(request, session)['product_img'])\n        return self", "response": "TAOBAO product. img. delete \u5220\u9664\u4ea7\u54c1\u975e\u4e3b\u56feID 2. \u4f20\u5165\u975e\u4e3b\u56feID 3. \u4f20\u5165\u4ea7\u54c1ID 2. \u4f20\u5165\u4ea7\u54c1ID 3. \u4f20\u5165\u4ea7\u54c1ID"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, session):\n        '''taobao.aftersale.get \u67e5\u8be2\u7528\u6237\u552e\u540e\u670d\u52a1\u6a21\u677f\n        \n        \u67e5\u8be2\u7528\u6237\u8bbe\u7f6e\u7684\u552e\u540e\u670d\u52a1\u6a21\u677f\uff0c\u4ec5\u8fd4\u56de\u6807\u9898\u548cid'''\n        request = TOPRequest('taobao.aftersale.get')\n        self.create(self.execute(request, session))\n        return self.after_sales", "response": "TAOBAO. aftersale. get \u67e5\u8be2\u7528\u6237\u8bbe\u7f6e\u7684\u552e\u540e\u670d\u52a1\u6a21\u677f\n        \n        \u67e5\u8be2\u7528\u6237\u8bbe\u7f6e\u7684\u552e\u540e\u670d\u52a1\u6a21\u677f\n        \n        "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the loop flag.", "response": "def loop(self, value):\n\t\t\"\"\" Indicates whether the playback should loop. \n\n\t\tParameters\n\t\t----------\n\t\tvalue : bool\n\t\t\tTrue if playback should loop, False if not.\n\n\t\t\"\"\"\n\t\tif not type(value) == bool:\n\t\t\traise TypeError(\"can only be True or False\")\n\t\tself._loop = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreset the player and discards loaded data.", "response": "def reset(self):\n\t\t\"\"\" Resets the player and discards loaded data. \"\"\"\n\t\tself.clip = None\n\t\tself.loaded_file = None\n\n\t\tself.fps = None\n\t\tself.duration = None\n\n\t\tself.status = UNINITIALIZED\n\t\tself.clock.reset()\n\n\t\tself.loop_count = 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading a video file into a dictionary.", "response": "def load_media(self, mediafile, play_audio=True):\n\t\t\"\"\" Loads a media file to decode. \n\n\t\tIf an audiostream is detected, its parameters will be stored in a\n\t\tdictionary in the variable `audioformat`. This contains the fields \n\n\t\t:nbytes: the number of bytes in the stream (2 is 16-bit sound).\n\t\t:nchannels: the channels (2 for stereo, 1 for mono)\n\t\t:fps: the frames per sec/sampling rate of the sound (e.g. 44100 KhZ).\n\t\t:buffersize: the audioframes per buffer.\n\t\t\n\t\tIf play_audio was set to False, or the video does not have an audiotrack,\n\t\t`audioformat` will be None.\n\n\t\tParameters\n\t\t----------\n\t\tmediafile : str\n\t\t\tThe path to the media file to load.\n\t\tplay_audio : bool, optional\n\t\t\tIndicates whether the audio of a movie should be played.\n\n\t\tRaises\n\t\t------\n\t\tIOError\n\t\t\tWhen the file could not be found or loaded.\n\t\t\"\"\"\n\t\tif not mediafile is None:\n\t\t\tif os.path.isfile(mediafile):\n\t\t\t\tself.clip = VideoFileClip(mediafile, audio=play_audio)\n\n\t\t\t\tself.loaded_file = os.path.split(mediafile)[1]\n\n\t\t\t\t## Timing variables\n\t\t\t\t# Clip duration\n\t\t\t\tself.duration = self.clip.duration\n\t\t\t\tself.clock.max_duration = self.clip.duration\n\t\t\t\tlogger.debug(\"Video clip duration: {}s\".format(self.duration))\n\n\t\t\t\t# Frames per second of clip\n\t\t\t\tself.fps = self.clip.fps\n\t\t\t\tself.clock.fps = self.clip.fps\n\t\t\t\tlogger.debug(\"Video clip FPS: {}\".format(self.fps))\n\n\t\t\t\tif play_audio and self.clip.audio:\n\t\t\t\t\tbuffersize = int(self.frame_interval*self.clip.audio.fps)\n\t\t\t\t\tself.audioformat = {\n\t\t\t\t\t\t'nbytes':  \t  \t2,\n\t\t\t\t\t\t'nchannels':\tself.clip.audio.nchannels,\n\t\t\t\t\t\t'fps':\t \t  \tself.clip.audio.fps,\n\t\t\t\t\t\t'buffersize':\tbuffersize\n\t\t\t\t\t}\n\t\t\t\t\tlogger.debug(\"Audio loaded: \\n{}\".format(self.audioformat))\n\t\t\t\t\tlogger.debug(\"Creating audio buffer of length: \"\n\t\t\t\t\t\t\" {}\".format(queue_length))\n\t\t\t\t\tself.audioqueue = Queue(queue_length)\n\t\t\t\telse:\n\t\t\t\t\tself.audioformat = None\n\n\t\t\t\tlogger.debug('Loaded {0}'.format(mediafile))\n\t\t\t\tself.status = READY\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\traise IOError(\"File not found: {0}\".format(mediafile))\n\t\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_videoframerender_callback(self, func):\n\n\t\t# Check if renderfunc is indeed a function\n\t\tif not func is None and not callable(func):\n\t\t\traise TypeError(\"The object passed for videorenderfunc is not a function\")\n\t\tself.__videorenderfunc = func", "response": "Sets the function to call when a new frame is available."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_audiorenderer(self, renderer):\n\t\tif not hasattr(self, 'audioqueue') or self.audioqueue is None:\n\t\t\traise RuntimeError(\"No video has been loaded, or no audiostream \"\n\t\t\t\t\"was detected.\")\n\t\tif not isinstance(renderer, SoundRenderer):\n\t\t\traise TypeError(\"Invalid renderer object. Not a subclass of \"\n\t\t\t\t\"SoundRenderer\")\n\t\tself.soundrenderer = renderer\n\t\tself.soundrenderer.queue = self.audioqueue", "response": "Sets the SoundRenderer object that will be used to render the audio."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef play(self):\n\t\t### First do some status checks\n\n\t\t# Make sure a file is loaded\n\t\tif self.status == UNINITIALIZED or self.clip is None:\n\t\t\traise RuntimeError(\"Player uninitialized or no file loaded\")\n\n\t\t# Check if playback has already finished (rewind needs to be called first)\n\t\tif self.status == EOS:\n\t\t\tlogger.debug(\"End of stream has already been reached\")\n\t\t\treturn\n\n\t\t# Check if playback hasn't already been started (and thus if play()\n\t\t# has not been called before from another thread for instance)\n\t\tif self.status in [PLAYING,PAUSED]:\n\t\t\tlogger.warning(\"Video already started\")\n\t\t\treturn\n\n\t\t### If all is in order start the general playing loop\n\t\tif self.status == READY:\n\t\t\tself.status = PLAYING\n\n\t\tself.last_frame_no = 0\n\n\t\tif not hasattr(self,\"renderloop\") or not self.renderloop.isAlive():\n\t\t\tif self.audioformat:\n\t\t\t\t# Chop the total stream into separate audio chunks that are the\n\t\t\t\t# lenght of a video frame (this way the index of each chunk \n\t\t\t\t# corresponds to the video frame it belongs to.)\n\t\t\t\tself.__calculate_audio_frames()\n\t\t\t\t# Start audio handling thread. This thread places audioframes\n\t\t\t\t# into a sound buffer, untill this buffer is full.\n\t\t\t\tself.audioframe_handler = threading.Thread(\n\t\t\t\t\ttarget=self.__audiorender_thread)\n\t\t\t\tself.audioframe_handler.start()\n\n\t\t\t# Start main rendering loop.\n\t\t\tself.renderloop = threading.Thread(target=self.__render)\n\t\t\tself.renderloop.start()\n\t\telse:\n\t\t\tlogger.warning(\"Rendering thread already running!\")", "response": "Start the playback of the video."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npause or resumes the video and audio stream.", "response": "def pause(self):\n\t\t\"\"\" Pauses or resumes the video and/or audio stream. \"\"\"\n\n\t\t# Change playback status only if current status is PLAYING or PAUSED \n\t\t# (and not READY).\n\t\tlogger.debug(\"Pausing playback\")\n\t\tif self.status == PAUSED:\n\t\t\t# Recalculate audio stream position to make sure it is not out of\n\t\t\t# sync with the video\n\t\t\tself.__calculate_audio_frames()\n\t\t\tself.status = PLAYING\n\t\t\tself.clock.pause()\n\t\telif self.status == PLAYING:\n\t\t\tself.status = PAUSED\n\t\t\tself.clock.pause()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstops the video stream and resets the clock.", "response": "def stop(self):\n\t\t\"\"\" Stops the video stream and resets the clock. \"\"\"\n\n\t\tlogger.debug(\"Stopping playback\")\n\t\t# Stop the clock\n\t\tself.clock.stop()\n\t\t# Set plauyer status to ready\n\t\tself.status = READY"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nseeks to the specified time.", "response": "def seek(self, value):\n\t\t\"\"\" Seek to the specified time.\n\n\t\tParameters\n\t\t----------\n\t\tvalue : str or int\n\t\t\tThe time to seek to. Can be any of the following formats:\n\n\t\t    >>> 15.4 -> 15.4 # seconds\n\t\t    >>> (1,21.5) -> 81.5 # (min,sec)\n\t\t    >>> (1,1,2) -> 3662 # (hr, min, sec)\n\t\t    >>> '01:01:33.5' -> 3693.5  #(hr,min,sec)\n\t\t    >>> '01:01:33.045' -> 3693.045\n\t\t    >>> '01:01:33,5' #comma works too\n\t\t\"\"\"\n\t\t# Pause the stream\n\t\tself.pause()\n\t\t# Make sure the movie starts at 1s as 0s gives trouble.\n\t\tself.clock.time = max(0.5, value)\n\t\tlogger.debug(\"Seeking to {} seconds; frame {}\".format(self.clock.time, \n\t\t\tself.clock.current_frame))\n\t\tif self.audioformat:\n\t\t\tself.__calculate_audio_frames()\n\t\t# Resume the stream\n\t\tself.pause()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __calculate_audio_frames(self):\n\n\t\tif self.audioformat is None:\n\t\t\treturn\n\t\tstart_frame = self.clock.current_frame\n\t\ttotalsize = int(self.clip.audio.fps*self.clip.audio.duration)\n\t\tself.audio_times = list(range(0, totalsize, \n\t\t\tself.audioformat['buffersize'])) + [totalsize]\n\t\t# Remove audio segments up to the starting frame\n\t\tdel(self.audio_times[0:start_frame])", "response": "Aligns audio with video. \n\tThis should be called for instance after a seeking operation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __render(self):\n\n\t\t# Render first frame\n\t\tself.__render_videoframe()\n\n\t\t# Start videoclock with start of this thread\n\t\tself.clock.start()\n\n\t\tlogger.debug(\"Started rendering loop.\")\n\t\t# Main rendering loop\n\t\twhile self.status in [PLAYING,PAUSED]:\n\t\t\tcurrent_frame_no = self.clock.current_frame\n\n\t\t\t# Check if end of clip has been reached\n\t\t\tif self.clock.time >= self.duration:\n\t\t\t\tlogger.debug(\"End of stream reached at {}\".format(self.clock.time))\n\t\t\t\tif self.loop:\n\t\t\t\t\tlogger.debug(\"Looping: restarting stream\")\n\t\t\t\t\t# Seek to the start\n\t\t\t\t\tself.rewind()\n\t\t\t\t\tself.loop_count += 1\n\t\t\t\telse:\n\t\t\t\t\t# End of stream has been reached\n\t\t\t\t\tself.status = EOS\n\t\t\t\t\tbreak\n\n\t\t\tif self.last_frame_no != current_frame_no:\n\t\t\t\t# A new frame is available. Get it from te stream\n\t\t\t\tself.__render_videoframe()\n\n\t\t\tself.last_frame_no = current_frame_no\n\n\t\t\t# Sleeping is a good idea to give the other threads some breathing\n\t\t\t# space to do their work.\n\t\t\ttime.sleep(0.005)\n\n\t\t# Stop the clock.\n\t\tself.clock.stop()\n\t\tlogger.debug(\"Rendering stopped.\")", "response": "Main render loop. \n\n\t\tChecks clock if new video and audio frames need to be rendered. \n\t\tIf so, it passes the frames to functions that take care \n\t\tof rendering these frames."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrender a new videoframe from the stream.", "response": "def __render_videoframe(self):\n\t\t\"\"\" Retrieves a new videoframe from the stream.\n\n\t\tSets the frame as the __current_video_frame and passes it on to\n\t\t__videorenderfunc() if it is set. \"\"\"\n\n\t\tnew_videoframe = self.clip.get_frame(self.clock.time)\n\t\t# Pass it to the callback function if this is set\n\t\tif callable(self.__videorenderfunc):\n\t\t\tself.__videorenderfunc(new_videoframe)\n\t\t# Set current_frame to current frame (...)\n\t\tself.__current_videoframe = new_videoframe"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting your forwards methods here.", "response": "def forwards(self, orm):\n        \"Write your forwards methods here.\"\n        for instance in orm.LocationSource.objects.all():\n            try:\n                instance.user = instance.points.all()[0].user\n                instance.save()\n            except IndexError:\n                # No points for this source.\n                instance.delete()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef backwards(self, orm):\n        \"Write your backwards methods here.\"\n        for instance in orm.LocationSource.objects.all():\n            for point in instance.points.all():\n                point.user = instance.user\n                point.save()", "response": "Write your backwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self):\n\t\tif not hasattr(self, 'queue'):\n\t\t\traise RuntimeError(\"Audio queue is not intialized.\")\n\n\t\tself.stream.start_stream()\n\t\tself.keep_listening = True\t\n\t\t\n\t\twhile self.keep_listening:\n\t\t\ttry:\n\t\t\t\tframe = self.queue.get(False, timeout=queue_timeout)\n\t\t\t\tself.stream.write(frame)\n\t\t\texcept Empty:\n\t\t\t\tcontinue\n\t\t\ttime.sleep(0.01)\n\n\t\tself.stream.stop_stream()\n\t\tself.stream.close()\n\t\tself.pa.terminate()", "response": "Starts the audio stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pipe2(flags=0):\n    pair = (c_int * 2)()\n    _pipe2(byref(pair), flags)\n    return pair[0], pair[1]", "response": "Wrapper around pipe2 that returns a pair of descriptors read_end and write_end."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search(self, user_nick, collect_type, page_no, session=None):\n        '''taobao.favorite.search \u67e5\u8be2\n        \n        \u67e5\u8be2\u6dd8\u5b9d\u7528\u6237\u6536\u85cf\u7684\u5546\u54c1\u6216\u5e97\u94fa\u4fe1\u606f.(\u6536\u85cf\u6709\u516c\u5f00\u548c\u672a\u516c\u5f00\u4e24\u79cd\uff0c\u4e0d\u5165\u53c2sessionkey\u7684\u53ea\u80fd\u83b7\u5f97\u516c\u5f00\u7684\u6536\u85cf\uff0c\u800c\u5165\u53c2\u4e86sessionkey\u7684\u80fd\u83b7\u5f97\u672a\u516c\u5f00\u7684\u6536\u85cf\u3002)'''\n        request = TOPRequest('taobao.favorite.search')\n        request['user_nick'] = user_nick\n        request['collect_type'] = collect_type\n        request['page_no'] = page_no\n        self.create(self.execute(request, session))\n        return self.result", "response": "TAOBAO. favorite. search \u67e5\u8be2\u6dd8\u5b9d\u7528\u6237\u6536\u85cf\u7684\u5546\u54c1\u6216\u5e97\u94fa\u4fe1\u606f."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search(self, keyword):\n        '''Get search results for a specific keyword'''\n        if type(keyword) != unicode: q = keyword.decode('utf-8')\n        req = self.fetch(self.search_url, {'q':q.encode('gbk')})\n        if not req: return None\n        html = req.content.decode('gbk').encode('utf-8')\n        soup = BeautifulSoup(html, convertEntities=BeautifulSoup.HTML_ENTITIES, markupMassage=hexentityMassage)\n        cats = self.cats_parser(soup)\n        keywords = self.keywords_parser(soup)\n        mall_items = self.mall_items_parser(soup)\n        total = int(soup.find('div', attrs={'class':'user-easy'}).find('a').string)\n        lists = self.lists_parser(soup)\n        ads = self.ads_parser(soup)\n        return SearchResults(keyword, total, lists, mall_items, ads, cats, keywords)", "response": "Get search results for a specific keyword"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_top_keywords(self, up=True):\n        '''Get top keywords for all the categories'''\n        engine = models.postgres_engine()\n        session = models.create_session(engine)\n        #threadPool = ThreadPool(5)\n        for cat in session.query(models.Category):\n            if not cat.level: continue\n            self.cat_top_keywords(session, cat, up)", "response": "Get the top keywords for all the categories"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cat_top_keywords(self, session, cat, up=True,  offset=0, offsets=[]):\n        '''Get top keywords in a specific category'''\n        print 'CAT:%s, level:%s'%(str(cat), str(cat.level))\n        print 'OFFSET: %d'%offset\n        response = []\n        if not offsets or offset==0: \n            url = 'http://top.taobao.com/level3.php?cat=%s&level3=%s&show=focus&up=%s&offset=%d'%(cat.parent.cid, '' if cat.level==2 else str(cat.cid), 'true' if up else '', offset)\n            print url\n            rs = self.fetch(url)\n            if not rs: return response\n            soup = BeautifulSoup(rs.content, convertEntities=BeautifulSoup.HTML_ENTITIES, markupMassage=hexentityMassage)\n            response = self.parse_cat_top_keywords(soup, offset)\n        if offset==0:\n            offsets = self.get_cat_top_keywords_pages(soup, offset)\n            print 'OFFSETS: %s'%offsets\n        if offsets:\n            rs = []\n            threadPool = ThreadPool(len(offsets) if len(offsets)<=5 else 5)\n            for idx, page_offset in enumerate(offsets):\n                page_url = 'http://top.taobao.com/level3.php?cat=%s&level3=%s&show=focus&up=%s&offset=%d'%(cat.parent.cid, '' if cat.level==2 else str(cat.cid), 'true' if up else '', page_offset)\n                next_page = 'True' if idx == (len(offsets)-1) else 'False'\n                threadPool.run(self.fetch, callback=None, url=page_url, config=dict(get_next=next_page, offset=page_offset))\n            pages = threadPool.killAllWorkers(None)\n            #print 'RESPONSES: %s'%pages\n            for p in pages:\n                if not p: continue\n                soup2 = BeautifulSoup(p.content, convertEntities=BeautifulSoup.HTML_ENTITIES, markupMassage=hexentityMassage)\n                offset2 = int(p.config['offset'])\n                response += self.parse_cat_top_keywords(soup2, offset2)\n                print 'GOT: %d'%offset2\n                if p.config['get_next'] != 'True': continue\n                offsets = self.get_cat_top_keywords_pages(soup2, offset2)\n                print offsets\n                if not offsets: continue\n                response += self.cat_top_keywords(session, cat, up, offset2, offsets)\n        #return sorted(response, key=itemgetter('pos')) if response else []\n        #print \"RETURN:%d\"%offset\n        for k in response:\n            new_keyword = models.Keyword(k['name'].decode('utf-8'))\n            new_keyword.categories.append(cat)\n            session.add(new_keyword)\n            try:\n                session.commit()\n            except IntegrityError:\n                session.rollback()\n                new_keyword = session.query(models.Keyword).filter(models.Keyword.name == k['name']).first()\n                new_keyword.categories.append(cat)\n                session.commit()\n                print 'Duplicate %s'%new_keyword\n        return response", "response": "Get top keywords in a specific category"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets top keywords categories", "response": "def get_cats(self):\n        '''Get top keywords categories'''\n        start_url = 'http://top.taobao.com/index.php?from=tbsy'\n        rs = self.fetch(start_url)\n        if not rs: return None\n        soup = BeautifulSoup(rs.content, convertEntities=BeautifulSoup.HTML_ENTITIES, markupMassage=hexentityMassage)\n        cats = [{'id':'TR_%s'%li['id'].encode('utf-8').upper(), 'title':li.a.text.encode('utf-8').strip()} for li in soup.find('div', id='nav').findAll('li') if li['id']!='index']\n        threadPool = ThreadPool(len(cats) if len(cats)<=5 else 5)\n        for cat in cats:\n            threadPool.run(self.get_cats_thread, callback=None, cat=cat)\n        cats = threadPool.killAllWorkers(None)\n        return cats"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrendering the given layout manager on a page of the given context.", "response": "def render_to_cairo_context(cairo_context, papersize_tuple, layout):\n    \"\"\"Renders the given layout manager on a page of the given context.\n\n    Assumes the given context has not yet been reversed in the y-direction\n    (i.e. it is still the default for Cairo, where y increases up\n    from the bottom of the page). This method performs the reversal and\n    resets it before it returns.\n    \"\"\"\n    try:\n        cairo_context.save()\n        cairo_context.translate(0, papersize_tuple[1])\n        cairo_context.scale(1, -1)\n        layout.render(\n            Rectangle(0, 0, *papersize_tuple),\n            dict(output=CairoOutput(cairo_context))\n            )\n    finally:\n        cairo_context.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating and save a document with contents of the given layout manager.", "response": "def render_to_cairo_document(output_filename, papersize_tuple, layout):\n    \"\"\"Create and save a document with contents of the given layout manager.\"\"\"\n    doc = cairo.PDFSurface(output_filename, *papersize_tuple)\n    c = cairo.Context(doc)\n    render_to_cairo_context(c, papersize_tuple, layout)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndrawing the given polygon.", "response": "def draw_polygon(\n            self,\n            *pts,\n            close_path=True,\n            stroke=None,\n            stroke_width=1,\n            stroke_dash=None,\n            fill=None\n            ) -> None:\n        \"\"\"Draws the given polygon.\"\"\"\n        c = self.c\n        c.save()\n        c.new_path()\n        for x,y in zip(*[iter(pts)]*2):\n            c.line_to(x, y)\n        if close_path:\n            c.close_path()\n        self._fill_and_stroke(stroke, stroke_width, stroke_dash, fill)\n        c.restore()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the UTF - 8 encoded prompt string.", "response": "def prompt(self):\n        \"\"\"Returns the UTF-8 encoded prompt string.\"\"\"\n        if self.prompt_string is not None:\n            return self.prompt_string\n\n        if not self.color_enabled:\n            return (' '.join(self.command) + '>> ').encode('utf8')\n\n        color = '34'\n        sub_color = '37'\n\n        prompt_cmd = [\n            self.colorize('1;' + color, part) if part != self.cmd_sub_str else\n            self.colorize('0;' + sub_color, u'\\u2026') for part in self.command\n        ]\n\n        return ' '.join(prompt_cmd) + self.colorize('0;' + color, '>> ')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef title(self):\n        return (u'[{}] {}>>'.format(\n            os.path.split(os.path.abspath('.'))[-1],\n            u' '.join(self.command))).encode('utf8')", "response": "Returns the UTF - 8 encoded title"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform the query based on the relative values.", "response": "def query_relative(self, query, event_time=None, relative_duration_before=None, relative_duration_after=None):\n        \"\"\"Perform the query and calculate the time range based on the relative values.\"\"\"\n        assert event_time is None or isinstance(event_time, datetime.datetime)\n        assert relative_duration_before is None or isinstance(relative_duration_before, str)\n        assert relative_duration_after is None or isinstance(relative_duration_after, str)\n\n        if event_time is None:\n            # use now as the default \n            event_time = datetime.datetime.now()\n\n        # use preconfigured defaults\n        if relative_duration_before is None:\n            relative_duration_before = self.relative_duration_before\n\n        if relative_duration_after is None:\n            relative_duration_after = self.relative_duration_after\n        \n        time_start = event_time - create_timedelta(relative_duration_before)\n        time_end = event_time + create_timedelta(relative_duration_after)\n        return self.query_with_time(query, time_start, time_end)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef json(self):\n        if self.search_results is None:\n            return None\n\n        result = []\n        for row in self.search_results['rows']:\n            obj = {}\n            for index in range(0, len(self.search_results['fields'])):\n                obj[self.search_results['fields'][index]] = row[index]\n            result.append(obj)\n\n        return result", "response": "Returns the search results as a list of JSON objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef draw_text(self, text:str, x:float, y:float, *,\n                  font_name:str, font_size:float, fill:Color) -> None:\n        \"\"\"Draws the given text at x,y.\"\"\"\n        pass", "response": "Draws the given text at x y."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndraw the given line.", "response": "def draw_line(\n            self, x0:float, y0:float, x1:float, y1:float, *,\n            stroke:Color,\n            stroke_width:float=1,\n            stroke_dash:typing.Sequence=None\n            ) -> None:\n        \"\"\"Draws the given line.\"\"\"\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef draw_rect(\n            self, x:float, y:float, w:float, h:float, *,\n            stroke:Color=None,\n            stroke_width:float=1,\n            stroke_dash:typing.Sequence=None,\n            fill:Color=None\n            ) -> None:\n        \"\"\"Draws the given rectangle.\"\"\"\n        pass", "response": "Draws the given rectangle."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndraw the given image.", "response": "def draw_image(\n            self, img_filename:str, x:float, y:float, w:float, h:float\n            ) -> None:\n        \"\"\"Draws the given image.\"\"\"\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef draw_polygon(\n            self,\n            *pts,\n            close_path:bool=True,\n            stroke:Color=None,\n            stroke_width:float=1,\n            stroke_dash:typing.Sequence=None,\n            fill:Color=None\n            ) -> None:\n        \"\"\"Draws the given linear path.\"\"\"\n        pass", "response": "Draws the given linear path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclip further output to this rect.", "response": "def clip_rect(self, x:float, y:float, w:float, h:float) -> None:\n        \"\"\"Clip further output to this rect.\"\"\"\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse MANIFEST. in template lines.", "response": "def parse_manifest(template_lines):\n    \"\"\"List of file names included by the MANIFEST.in template lines.\"\"\"\n    manifest_files = distutils.filelist.FileList()\n    for line in template_lines:\n        if line.strip():\n            manifest_files.process_template_line(line)\n    return manifest_files.files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npatch wxPython Classic class to behave like a wxPython Classic Phoenix class with a 2 - step creation process.", "response": "def _wx_two_step_creation_on_classic(cls):\n    \"\"\"\n    Patch the wxPython Classic class to behave like a wxPython\n    Phoenix class on a 2-step creation process.\n\n    On wxPython Phoenix, the first step is the parameterless\n    ``__init__``, and the second step is the ``Create`` method with\n    the construction parameters, e.g.::\n\n        class CustomFrame(wx.Frame):\n            def __init__(self, parent):\n                super(CustomFrame, self).__init__() # 1st step\n                # [...]\n                self.Create(parent) # 2nd step\n                # [...]\n\n    On wxPython Classic, the same would be written as::\n\n        class CustomFrame(wx.Frame):\n            def __init__(self, parent):\n                pre = wx.PreFrame() # 1st step\n                # [... using \"pre\" instead of \"self\" ...]\n                pre.Create(parent) # 2nd step\n                self.PostCreate(pre) # \"3rd step\"\n                # [...]\n    \"\"\"\n    cls_init = cls.__init__\n    cls_create = cls.Create\n\n    @functools.wraps(cls_init)\n    def __init__(self, *args, **kwargs):\n        if args or kwargs:\n            cls_init(self, *args, **kwargs)\n        else: # 2-step creation\n            new_self = getattr(wx, \"Pre\" + cls.__name__)()\n            for pair in vars(new_self).items():\n                setattr(self, *pair)\n\n    if sys.platform == \"win32\":\n        # On Windows, the wx.Pre*.Create constructors calls the\n        # EVT_WINDOW_CREATE handler before returning (i.e, it processes\n        # the event instead of just adding a message to the queue), and\n        # that shouldn't happen before the PostCreate call in this thread\n        @functools.wraps(cls_create)\n        def create(self, *args, **kwargs):\n            self.SetEvtHandlerEnabled(False)\n            result = cls_create(self, *args, **kwargs)\n            self.SetEvtHandlerEnabled(True)\n            if result:\n                self.PostCreate(self)\n                wx.PostEvent(self, wx.WindowCreateEvent(self))\n            return result\n    else:\n        @functools.wraps(cls_create)\n        def create(self, *args, **kwargs):\n            result = cls_create(self, *args, **kwargs)\n            if result:\n                self.PostCreate(self)\n            return result\n\n    cls.__init__ = __init__\n    cls.Create = create"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfixes the backwards-incompatible PEP-0479 gotcha/bug https://www.python.org/dev/peps/pep-0479", "response": "def allow_implicit_stop(gen_func):\n    \"\"\"\n    Fix the backwards-incompatible PEP-0479 gotcha/bug\n    https://www.python.org/dev/peps/pep-0479\n    \"\"\"\n    @functools.wraps(gen_func)\n    def wrapper(*args, **kwargs):\n        with warnings.catch_warnings():\n            for cls in [DeprecationWarning, PendingDeprecationWarning]:\n                warnings.filterwarnings(\n                    action=\"ignore\",\n                    message=\".* raised StopIteration\",\n                    category=cls,\n                )\n            try:\n                for item in gen_func(*args, **kwargs):\n                    yield item\n            except RuntimeError as exc:\n                if type(exc.__cause__) is StopIteration:\n                    return\n                raise\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nintegrate an adaptive system of ordinary differential equations.", "response": "def integrate_adaptive(rhs, jac, y0, x0, xend, atol, rtol, dx0=.0, dx_max=.0,\n                       check_callable=False, check_indexing=False, **kwargs):\n    \"\"\"\n    Integrates a system of ordinary differential equations.\n\n    Parameters\n    ----------\n    rhs: callable\n        Function with signature f(t, y, fout) which modifies fout *inplace*.\n    jac: callable\n        Function with signature j(t, y, jmat_out, dfdx_out) which modifies\n        jmat_out and dfdx_out *inplace*.\n    y0: array_like\n        Initial values of the dependent variables.\n    x0: float\n        Initial value of the independent variable.\n    xend: float\n        Stopping value for the independent variable.\n    atol: float\n        Absolute tolerance.\n    rtol: float\n        Relative tolerance.\n    dx0: float\n        Initial step-size.\n    dx_max: float\n        Maximum step-size.\n    check_callable: bool (default: False)\n        Perform signature sanity checks on ``rhs`` and ``jac``.\n    check_indexing: bool (default: False)\n        Perform item setting sanity checks on ``rhs`` and ``jac``.\n    \\*\\*kwargs:\n        'method': str\n            'rosenbrock4', 'dopri5' or 'bs'\n        'return_on_error': bool\n            Returns on error without raising an excpetion (with ``'success'==False``).\n        'autorestart': int\n            Useful for autonomous systems where conditions change during integration.\n            Will restart the integration with ``x==0``.\n        'dx0cb': callable\n            Callback for calculating dx0 (make sure to pass ``dx0==0.0``) to enable.\n            Signature: ``f(x, y[:]) -> float``.\n\n    Returns\n    -------\n    (xout, yout, info):\n        xout: 1-dimensional array of values for the independent variable\n        yout: 2-dimensional array of the dependent variables (axis 1) for\n            values corresponding to xout (axis 0)\n        info: dictionary with information about the integration\n    \"\"\"\n    # Sanity checks to reduce risk of having a segfault:\n    jac = _ensure_5args(jac)\n    if check_callable:\n        _check_callable(rhs, jac, x0, y0)\n\n    if check_indexing:\n        _check_indexing(rhs, jac, x0, y0)\n\n    return adaptive(rhs, jac, np.asarray(y0, dtype=np.float64), x0, xend, atol, rtol, dx0, dx_max, **_bs(kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nintegrate a single set of ordinary differential equations with the same initial values and the same value as the one in the dependent variables.", "response": "def integrate_predefined(rhs, jac, y0, xout, atol, rtol, dx0=0.0, dx_max=0.0,\n                         check_callable=False, check_indexing=False, **kwargs):\n    \"\"\"\n    Integrates a system of ordinary differential equations.\n\n    Parameters\n    ----------\n    rhs: callable\n        Function with signature f(t, y, fout) which modifies fout *inplace*.\n    jac: callable\n        Function with signature j(t, y, jmat_out, dfdx_out) which modifies\n        jmat_out and dfdx_out *inplace*.\n    y0: array_like\n        Initial values of the dependent variables.\n    xout: array_like\n        Values of the independent variable.\n    atol: float\n        Absolute tolerance.\n    rtol: float\n        Relative tolerance.\n    dx0: float\n        Initial step-size.\n    dx_max: float\n        Maximum step-size.\n    check_callable: bool (default: False)\n        Perform signature sanity checks on ``rhs`` and ``jac``.\n    check_indexing: bool (default: False)\n        Perform item setting sanity checks on ``rhs`` and ``jac``.\n    \\*\\*kwargs:\n        'method': str\n            One in ``('rosenbrock4', 'dopri5', 'bs')``.\n        'return_on_error': bool\n            Returns on error without raising an excpetion (with ``'success'==False``).\n        'autorestart': int\n            Useful for autonomous systems where conditions change during integration.\n            Will restart the integration with ``x==0``.\n        'dx0cb': callable\n            Callback for calculating dx0 (make sure to pass ``dx0==0.0``) to enable.\n            Signature: ``f(x, y[:]) -> float``.\n\n    Returns\n    -------\n    (result, info):\n        result: 2-dimensional array of the dependent variables (axis 1) for\n            values corresponding to xout (axis 0)\n        info: dictionary with information about the integration\n    \"\"\"\n    # Sanity checks to reduce risk of having a segfault:\n    jac = _ensure_5args(jac)\n    if check_callable:\n        _check_callable(rhs, jac, xout[0], y0)\n\n    if check_indexing:\n        _check_indexing(rhs, jac, xout[0], y0)\n\n    return predefined(rhs, jac, np.asarray(y0, dtype=np.float64), np.asarray(xout, dtype=np.float64),\n                      atol, rtol, dx0, dx_max, **_bs(kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts a running pipeline.", "response": "def start_pipeline(url, pipeline_id, auth, verify_ssl, runtime_parameters={}):\n    \"\"\"Start a running pipeline. The API waits for the pipeline to be fully started.\n\n    Args:\n        url                 (str): the host url in the form 'http://host:port/'.\n        pipeline_id         (str): the ID of of the exported pipeline.\n        auth              (tuple): a tuple of username, and password.\n        runtime_parameters (dict): the desired runtime parameters for the pipeline.\n        verify_ssl         (bool): whether to verify ssl certificates\n\n    Returns:\n        dict: the response json\n    \"\"\"\n    start_result = requests.post(url + '/' + pipeline_id + '/start',\n                                 headers=X_REQ_BY, auth=auth, verify=verify_ssl, json=runtime_parameters)\n    start_result.raise_for_status()\n    logging.info('Pipeline start requested.')\n\n    poll_pipeline_status(STATUS_RUNNING, url, pipeline_id, auth, verify_ssl)\n\n    logging.info(\"Pipeline started.\")\n    return start_result.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef export_pipeline(url, pipeline_id, auth, verify_ssl):\n    export_result = requests.get(url + '/' + pipeline_id + '/export', headers=X_REQ_BY, auth=auth, verify=verify_ssl)\n    if export_result.status_code == 404:\n        logging.error('Pipeline not found: ' + pipeline_id)\n    export_result.raise_for_status()\n    return export_result.json()", "response": "Export the config and rules for a pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve the current status of a pipeline.", "response": "def pipeline_status(url, pipeline_id, auth, verify_ssl):\n    \"\"\"Retrieve the current status for a pipeline.\n\n    Args:\n        url          (str): the host url in the form 'http://host:port/'.\n        pipeline_id  (str): the ID of of the exported pipeline.\n        auth         (tuple): a tuple of username, and password.\n        verify_ssl   (bool): whether to verify ssl certificates\n\n    Returns:\n        dict: the response json\n\n    \"\"\"\n    status_result = requests.get(url + '/' + pipeline_id + '/status', headers=X_REQ_BY, auth=auth, verify=verify_ssl)\n    status_result.raise_for_status()\n    logging.debug('Status request: ' + url + '/status')\n    logging.debug(status_result.json())\n    return status_result.json()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve the current status of a preview.", "response": "def preview_status(url, pipeline_id, previewer_id, auth, verify_ssl):\n    \"\"\"Retrieve the current status for a preview.\n\n    Args:\n        url          (str): the host url in the form 'http://host:port/'.\n        pipeline_id  (str): the ID of of the exported pipeline.\n        previewer_id (str): the previewer id created by starting a preview or validation\n        auth         (tuple): a tuple of username, and password.\n        verify_ssl   (bool): whether to verify ssl certificates\n\n    Returns:\n        dict: the response json\n\n    \"\"\"\n    preview_status = requests.get(url + '/' + pipeline_id + '/preview/' + previewer_id + \"/status\", headers=X_REQ_BY, auth=auth, verify=verify_ssl)\n    preview_status.raise_for_status()\n    logging.debug(preview_status.json())\n    return preview_status.json()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stop_pipeline(url, pipeline_id, auth, verify_ssl):\n\n    stop_result = requests.post(url + '/' + pipeline_id + '/stop', headers=X_REQ_BY, auth=auth, verify=verify_ssl)\n    stop_result.raise_for_status()\n\n    logging.info(\"Pipeline stop requested.\")\n\n    poll_pipeline_status(STATUS_STOPPED, url, pipeline_id, auth, verify_ssl)\n\n    logging.info('Pipeline stopped.')\n    return stop_result.json()", "response": "Stop a running pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates a pipeline and show issues.", "response": "def validate_pipeline(url, pipeline_id, auth, verify_ssl):\n    \"\"\"Validate a pipeline and show issues.\n\n    Args:\n        url         (str): the host url in the form 'http://host:port/'.\n        pipeline_id (str): the ID of of the exported pipeline.\n        auth      (tuple): a tuple of username, and password.\n        verify_ssl (bool): whether to verify ssl certificates\n\n    Returns:\n        dict: the response json\n\n    \"\"\"\n\n    validate_result = requests.get(url + '/' + pipeline_id + '/validate', headers=X_REQ_BY, auth=auth, verify=verify_ssl)\n    validate_result.raise_for_status()\n    previewer_id = validate_result.json()['previewerId']\n    poll_validation_status(url, pipeline_id, previewer_id, auth, verify_ssl)\n\n    preview_result = requests.get(url + '/' + pipeline_id + '/preview/' + validate_result.json()['previewerId'], headers=X_REQ_BY, auth=auth, verify=verify_ssl)\n    logging.debug('result content: {}'.format(preview_result.content))\n\n    return preview_result.json()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pipeline_exists(url, pipeline_id, auth, verify_ssl):\n    '''\n    :param url: (str): the host url in the form 'http://host:port/'.\n    :param pipeline_id: (string) the pipeline identifier\n    :param auth: (tuple) a tuple of username, password\n    :return: (boolean)\n    '''\n    try:\n        pipeline_status(url, pipeline_id, auth, verify_ssl)['status']\n        return True\n    except requests.HTTPError:\n        return False", "response": "Check if a pipeline exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_pipeline(url, pipeline_id, auth, json_payload, verify_ssl, overwrite = False):\n    parameters = { 'overwrite' : overwrite }\n    import_result = requests.post(url + '/' + pipeline_id + '/import', params=parameters,\n                                  headers=X_REQ_BY, auth=auth, verify=verify_ssl, json=json_payload)\n\n    if import_result.status_code != 200:\n        logging.error('Import error response: ' + import_result.text)\n\n    import_result.raise_for_status()\n    logging.info('Pipeline import successful.')\n    return import_result.json()", "response": "This function imports a pipeline into the current pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new pipeline.", "response": "def create_pipeline(url, auth, json_payload, verify_ssl):\n    \"\"\"Create a new pipeline.\n\n    Args:\n        url           (str): the host url in the form 'http://host:port/'.\n        auth        (tuple): a tuple of username, and password.\n        json_payload (dict): the exported json paylod as a dictionary.\n        verify_ssl   (bool): whether to verify ssl certificates\n\n    Returns:\n        dict: the response json\n\n    \"\"\"\n    title = json_payload['pipelineConfig']['title']\n    description = json_payload['pipelineConfig']['description']\n    params = {'description':description, 'autoGeneratePipelineId':True}\n    logging.info('No destination pipeline ID provided.  Creating a new pipeline: ' + title)\n    put_result = requests.put(url + '/' + title, params=params, headers=X_REQ_BY, auth=auth, verify=verify_ssl)\n    put_result.raise_for_status()\n    create_json = put_result.json()\n    logging.debug(create_json)\n    logging.info('Pipeline creation successful.')\n    return create_json"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving SDC system information.", "response": "def system_info(url, auth, verify_ssl):\n    \"\"\"Retrieve SDC system information.\n\n    Args:\n        url (str): the host url.\n        auth (tuple): a tuple of username, and password.\n\n    \"\"\"\n    sysinfo_response = requests.get(url + '/info', headers=X_REQ_BY, auth=auth, verify=verify_ssl)\n    sysinfo_response.raise_for_status()\n    return sysinfo_response.json()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexporting a pipeline to json.", "response": "def export_pipeline(conf, args):\n    \"\"\"Export a pipeline to json.\"\"\"\n    # Export the source pipeline and save it to file\n    src = conf.config['instances'][args.src_instance]\n    src_url = api.build_pipeline_url(build_instance_url(src))\n    src_auth = tuple([conf.creds['instances'][args.src_instance]['user'],\n                      conf.creds['instances'][args.src_instance]['pass']])\n    verify_ssl = src.get('verify_ssl', True)\n    export_json = api.export_pipeline(src_url, args.src_pipeline_id, src_auth, verify_ssl)\n    with open(args.out, 'w') as outFile:\n        outFile.write(json.dumps(export_json, indent=4, sort_keys=False))\n        return (0, '')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nimport a pipeline from json.", "response": "def import_pipeline(conf, args):\n    \"\"\"Import a pipeline from json.\"\"\"\n    with open(args.pipeline_json) as pipeline_json:\n        dst = conf.config['instances'][args.dst_instance]\n        dst_url = api.build_pipeline_url(build_instance_url(dst))\n        dst_auth = tuple([conf.creds['instances'][args.dst_instance]['user'],\n                          conf.creds['instances'][args.dst_instance]['pass']])\n        parsed_json = json.load(pipeline_json)\n        verify_ssl = dst.get('verify_ssl', True)\n        return api.import_pipeline(dst_url, args.pipeline_id, dst_auth, parsed_json, verify_ssl, overwrite=args.overwrite)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef promote_pipeline(conf, args):\n    src = conf.config['instances'][args.src_instance]\n    src_url = api.build_pipeline_url(build_instance_url(src))\n    src_auth = tuple([conf.creds['instances'][args.src_instance]['user'], conf.creds['instances'][args.src_instance]['pass']])\n    verify_ssl = src.get('verify_ssl', True)\n    export_json = api.export_pipeline(src_url, args.src_pipeline_id, src_auth, verify_ssl)\n\n    # Import the pipeline to the destination\n    dest = conf.config['instances'][args.dest_instance]\n    dest_url = api.build_pipeline_url(build_instance_url(dest))\n    dest_auth = tuple([conf.creds['instances'][args.dest_instance]['user'], conf.creds['instances'][args.dest_instance]['pass']])\n    dest_pipeline_id = args.dest_pipeline_id\n    if dest_pipeline_id and api.pipeline_status(dest_url, dest_pipeline_id, dest_auth, verify_ssl)['status'] != api.STATUS_STOPPED:\n        api.stop_pipeline(dest_url, dest_pipeline_id, dest_auth, verify_ssl)\n    else:\n        # No destination pipeline id was provided, must be a new pipeline.\n        create_json = api.create_pipeline(dest_url, dest_auth, export_json, verify_ssl)\n        dest_pipeline_id = create_json['info']['pipelineId']\n\n    result = api.import_pipeline(dest_url, dest_pipeline_id, dest_auth, export_json, verify_ssl, overwrite=True)\n\n    # Start the imported pipeline\n    if args.start_dest:\n        api.start_pipeline(dest_url, dest_pipeline_id, dest_auth, verify_ssl)\n\n    return result", "response": "Export a pipeline from a lower environment and import into higher environment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_pipeline(conf, args):\n    host = conf.config['instances'][args.host_instance]\n    host_url = api.build_pipeline_url(build_instance_url(host))\n    host_auth = tuple([conf.creds['instances'][args.host_instance]['user'],\n                      conf.creds['instances'][args.host_instance]['pass']])\n    verify_ssl = host.get('verify_ssl', True)\n    validate_result = api.validate_pipeline(host_url, args.pipeline_id, host_auth, verify_ssl)\n    return validate_result", "response": "Validate a pipeline configuration."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nextract the parameters for calculations for the current module.", "response": "def extractGlobalParameters(self, dna, bp, frames=None, paxis='Z', masked=False):\n        \"\"\"Extract the parameters for calculations\n\n\n        .. currentmodule:: dnaMD\n\n        Parameters\n        ----------\n        dna : :class:`dnaMD.DNA`\n            Input :class:`dnaMD.DNA` instance.\n\n        bp : list\n            List of two base-steps forming the DNA segment.\n            For example: with ``bp=[5, 50]``, 5-50 base-step segment will be considered.\n\n        frames : list\n            List of two trajectory frames between which parameters will be extracted. It can be used to select portions\n            of the trajectory. For example, with ``frames=[100, 1000]``, 100th to 1000th frame of the trajectory will be\n            considered.\n\n        paxis : str\n            Axis parallel to global helical-axis(``'X'``, or ``'Y'`` or ``'Z'``). Only require when bending motions are\n            included in the calculation.\n\n        masked : bool\n            ``Default=False``. To skip specific frames/snapshots.\n            ``DNA.mask`` array should be set to use this functionality.\n            This array contains boolean (either ``True`` or ``False``) value\n            for each frame to mask the frames. Presently, mask array is\n            automatically generated during :meth:`dnaMD.DNA.generate_smooth_axis` to\n            skip those frames where 3D fitting curve was not successful within\n            the given criteria.\n\n\n        Returns\n        -------\n        time : numpy.ndarray\n            1D numpy array of shape (nframes) containing time\n        array : numpy.ndarray\n            2D numpy array of shape (parameters count, nframes) containing extracted parameters.\n        \"\"\"\n\n        frames = self._validateFrames(frames)\n        if frames[1] == -1:\n            frames[1] = None\n\n        if (len(bp) != 2):\n            raise ValueError(\"bp should be a list containing first and last bp of a segment. See, documentation!!!\")\n\n        if bp[0] > bp[1]:\n            raise ValueError(\"bp should be a list containing first and last bp of a segment. See, documentation!!!\")\n\n        time, clen = dna.time_vs_parameter('h-rise', bp=bp, merge=True, merge_method='sum', masked=masked)\n        clen = np.asarray(clen) * 0.1  # conversion to nm\n\n        time, htwist = dna.time_vs_parameter('h-twist', bp=bp, merge=True, merge_method='sum', masked=masked)\n        htwist = np.deg2rad(htwist)  # Conversion to radian\n\n        angleOne, angleTwo = None, None\n        if self.esType=='BST':\n            angleOne, angleTwo = dna.calculate_2D_angles_bw_tangents(paxis, bp, masked=masked)\n\n            # Rarely there are nan during angle calculation, remove those nan\n            nanInOne = np.isnan(angleOne[frames[0]:frames[1]])\n            nanInTwo = np.isnan(angleTwo[frames[0]:frames[1]])\n            notNan = ~(nanInOne + nanInTwo)\n            notNanIdx = np.nonzero(notNan)\n\n            array = np.array([angleOne[frames[0]:frames[1]][notNanIdx], angleTwo[frames[0]:frames[1]][notNanIdx],\n                              clen[frames[0]:frames[1]][notNanIdx], htwist[frames[0]:frames[1]][notNanIdx]])\n            time = (time[frames[0]:frames[1]])[notNanIdx]\n\n        else:\n            array = np.array([clen[frames[0]:frames[1]], htwist[frames[0]:frames[1]]])\n            time = time[frames[0]:frames[1]]\n\n        return time, array"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extractLocalParameters(self, dna, bp, helical=False, frames=None):\n\n        frames = self._validateFrames(frames)\n        if frames[1] == -1:\n            frames[1] = None\n\n        if (len(bp) != 2):\n            raise ValueError(\"bp should be a list containing first and last bp of a segment. See, documentation!!!\")\n\n        if bp[0] > bp[1]:\n            raise ValueError(\"bp should be a list containing first and last bp of a segment. See, documentation!!!\")\n\n        if (bp[1] - bp[0]) > 4:\n            print(\"WARNING: this is a local property and therefore, longer than 4 base-step may not be suitable...\" )\n\n        if not helical:\n            time, shift = dna.time_vs_parameter('shift', bp=bp, merge=True, merge_method='sum')\n            shift = np.asarray(shift) * 0.1  # conversion to nm\n\n            time, slide = dna.time_vs_parameter('slide', bp=bp, merge=True, merge_method='sum')\n            slide = np.asarray(slide) * 0.1  # conversion to nm\n\n            time, rise = dna.time_vs_parameter('rise', bp=bp, merge=True, merge_method='sum')\n            rise = np.asarray(rise) * 0.1  # conversion to nm\n\n            time, tilt = dna.time_vs_parameter('tilt', bp=bp, merge=True, merge_method='sum')\n\n            time, roll = dna.time_vs_parameter('roll', bp=bp, merge=True, merge_method='sum')\n\n            time, twist = dna.time_vs_parameter('twist', bp=bp, merge=True, merge_method='sum')\n\n            array = np.array([shift[frames[0]:frames[1]], slide[frames[0]:frames[1]], rise[frames[0]:frames[1]],\n                              tilt[frames[0]:frames[1]], roll[frames[0]:frames[1]], twist[frames[0]:frames[1]]])\n            time = time[frames[0]:frames[1]]\n\n        else:\n            time, x_disp = dna.time_vs_parameter('x-disp', bp=bp, merge=True, merge_method='sum')\n            x_disp = np.asarray(x_disp) * 0.1  # conversion to nm\n\n            time, y_disp = dna.time_vs_parameter('y-disp', bp=bp, merge=True, merge_method='sum')\n            y_disp = np.asarray(y_disp) * 0.1  # conversion to nm\n\n            time, h_rise = dna.time_vs_parameter('h-rise', bp=bp, merge=True, merge_method='sum')\n            h_rise = np.asarray(h_rise) * 0.1  # conversion to nm\n\n            time, inclination = dna.time_vs_parameter('inclination', bp=bp, merge=True, merge_method='sum')\n\n            time, tip = dna.time_vs_parameter('tip', bp=bp, merge=True, merge_method='sum')\n\n            time, h_twist = dna.time_vs_parameter('h-twist', bp=bp, merge=True, merge_method='sum')\n\n            array = np.array([x_disp[frames[0]:frames[1]], y_disp[frames[0]:frames[1]], h_rise[frames[0]:frames[1]],\n                              inclination[frames[0]:frames[1]], tip[frames[0]:frames[1]], h_twist[frames[0]:frames[1]]])\n            time = time[frames[0]:frames[1]]\n\n        return time, array", "response": "Extract the local parameters for calculations."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getModulusByTime(self, bp, frameGap, masked=False, paxis='Z', outFile=None):\n\n        if self.esType == 'BST':\n            props_name = [ 'bend-1', 'bend-2', 'stretch', 'twist', 'bend-1-bend-2',\n                           'bend-2-stretch', 'stretch-twist', 'bend-1-stretch',\n                           'bend-2-twist', 'bend-1-twist']\n        else:\n            props_name = ['stretch', 'twist', 'stretch-twist']\n\n        time, elasticity = [], OrderedDict()\n        for name in props_name:\n            elasticity[name] = []\n\n        length = len(self.dna.time[:])\n        for i in range(frameGap, length, frameGap):\n\n            props = None\n            if self.esType == 'BST':\n                mean, modulus_t = self.getStretchTwistBendModulus(bp, frames=[0, i], paxis=paxis, masked=True)\n            else:\n                mean, modulus_t = self.getStretchTwistModulus(bp, frames=[0, i], masked=masked)\n\n            modulus_t = matrixToVector(modulus_t)\n            for p in range(len(props_name)):\n                elasticity[props_name[p]].append(modulus_t[p])\n            time.append(self.dna.time[i])\n\n        # Write output file\n        if outFile is not None:\n            with open(outFile, 'w') as fout:\n                fout.write('#Time')\n                for name in props_name:\n                    fout.write(', {0}'.format(name))\n                fout.write('\\n')\n                for t in range(len(time)):\n                    fout.write('{0:.3f}'.format(time[t]))\n                    for name in props_name:\n                        fout.write(', {0:.5f}'.format(elasticity[name][t]))\n                    fout.write('\\n')\n\n        return time, elasticity", "response": "r This function calculates the moduli of the elastic properties of the current state of the current module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getGlobalDeformationEnergy(self, bp, complexDna, freeDnaFrames=None, boundDnaFrames=None, paxis='Z',\n                                   which='all', masked=False, outFile=None):\n        r\"\"\"Deformation energy of the input DNA using Global elastic properties\n\n        It can be used to calculated deformation energy of a input DNA with reference to the DNA present in the current\n        object.\n\n        The deformation free energy is calculated using elastic matrix as follows\n\n        .. math::\n\n            G = \\frac{1}{2L_0}\\mathbf{xKx^T}\n\n\n        .. math::\n            \\mathbf{x} =  \\begin{bmatrix}\n                    (\\theta^{x} - \\theta^{x}_0)    & (\\theta^{y} - \\theta^{y}_0) & (L - L_0) & (\\phi - \\phi_0)\n                          \\end{bmatrix}\n\n\n        .. currentmodule:: dnaMD\n\n\n        Parameters\n        ----------\n        bp : list\n            List of two base-steps forming the DNA segment.\n            For example: with ``bp=[5, 50]``, 5-50 base-step segment will be considered.\n        complexDna : :class:`dnaMD.DNA`\n            Input :class:`dnaMD.DNA` instance for which deformation energy will be calculated.\n        freeDnaFrames : list\n            To select a trajectory segment of current (free) DNA data.\n            List of two trajectory frames between which parameters will be extracted. It can be used to select portions\n            of the trajectory. For example, with ``frames=[100, 1000]``, 100th to 1000th frame of the trajectory will be\n            considered.\n        boundDnaFrames : list\n            To select a trajectory segment of input (bound) DNA data.\n            List of two trajectory frames between which parameters will be extracted. It can be used to select portions\n            of the trajectory. For example, with ``frames=[100, 1000]``, 100th to 1000th frame of the trajectory will be\n            considered.\n        paxis : str\n            Axis parallel to global helical-axis(``'X'``, or ``'Y'`` or ``'Z'``). Only require when bending motions are\n            included in the calculation.\n        which : str or list\n            For which motions, energy should be calculated. It should be either a list containing terms listed below or\n            \"all\" for all energy terms.\n\n            Following keywords are available:\n                * ``'full'`` : Use entire elastic matrix -- all motions with their coupling\n                * ``'diag'`` : Use diagonal of elastic matrix -- all motions but no coupling\n                * ``'b1'`` : Only bending-1 motion\n                * ``'b2'`` : Only bending-2 motion\n                * ``'stretch'`` : Only stretching motion\n                * ``'twist'`` : Only Twisting motions\n                * ``'st_coupling'`` : Only stretch-twist coupling motion\n                * ``'bs_coupling'`` : Only Bending and stretching coupling\n                * ``'bt_coupling'`` : Only Bending and Twisting coupling\n                * ``'bb_coupling'`` : Only bending-1 and bending-2 coupling\n                * ``'bend'`` : Both bending motions with their coupling\n                * ``'st'`` : Stretching and twisting motions with their coupling\n                * ``'bs'`` : Bending (b1, b2) and stretching motions with their coupling\n                * ``'bt'`` : Bending (b1, b2) and twisting motions with their coupling\n        masked : bool\n            ``Default=False``. To skip specific frames/snapshots.\n            ``DNA.mask`` array should be set to use this functionality.\n            This array contains boolean (either ``True`` or ``False``) value\n            for each frame to mask the frames. Presently, mask array is\n            automatically generated during :meth:`dnaMD.DNA.generate_smooth_axis` to\n            skip those frames where 3D fitting curve was not successful within\n            the given criteria.\n\n        outFile : str\n            Output file in csv format.\n\n        Returns\n        -------\n        time : numpy.ndarray\n            1D array containing time values.\n\n        energy : OrderedDict of numpy.ndarray\n            Dictionary of 1D array of shape (nframes) containing energy terms requested for DNA.\n\n        \"\"\"\n        if self.esType == 'BST':\n            energyTerms = self.enGlobalTypes\n        else:\n            energyTerms = self.enGlobalTypes[:5]\n\n        if isinstance(which, str):\n            if which != 'all':\n                raise ValueError('Either use \"all\" or use list of terms from this {0} list \\n.'.format(energyTerms))\n            else:\n                which = energyTerms\n        elif isinstance(which, list):\n            for key in which:\n                if key not in energyTerms:\n                    raise ValueError('{0} is not a supported keyword.\\n Use from the following list: \\n{1}'.format(\n                        which, energyTerms))\n        else:\n            raise ValueError('Either use \"all\" or use list of terms from this {0} list \\n.'.format(\n                energyTerms))\n\n        if self.esType == 'BST':\n            means, esMatrix = self.getStretchTwistBendModulus(bp, frames=freeDnaFrames, masked=masked,\n                                                              matrix=True, paxis=paxis)\n        else:\n            means, esMatrix = self.getStretchTwistModulus(bp, frames=freeDnaFrames, masked=masked, matrix=True)\n\n        esMatrix = 2.5 * esMatrix          # Convert kT to kJ/mol\n        time, array = self.extractGlobalParameters(complexDna, bp, frames=boundDnaFrames, paxis=paxis, masked=masked)\n\n        # Initialize energy dictionary\n        energyOut = OrderedDict()\n        for key in which:\n            energyOut[key] = []\n\n        for i in range(array[0].shape[0]):\n            vec = array[:, i]\n            diff = vec - means\n            for key in which:\n                if self.esType == 'BST':\n                    t_energy = self._calcEnergyBendStretchTwist(diff, esMatrix, key)\n                else:\n                    t_energy = self._calcEnergyStretchTwist(diff, esMatrix, key)\n                energyOut[key].append(t_energy)\n\n        for key in which:\n            energyOut[key] = np.asarray(energyOut[key])\n\n        # Write output file\n        if outFile is not None:\n            with open(outFile, 'w') as fout:\n                fout.write('#Time')\n                for name in which:\n                    fout.write(', {0}'.format(name))\n                fout.write('\\n')\n                for t in range(len(time)):\n                    fout.write('{0:.3f}'.format(time[t]))\n                    for name in which:\n                        fout.write(', {0:.5f}'.format(energyOut[name][t]))\n                    fout.write('\\n')\n\n        return time, energyOut", "response": "r Returns the deformation energy of the input DNA using Global elastic properties."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _calcEnergyStretchTwist(self, diff, es, which):\n\n        if which not in self.enGlobalTypes[:5]:\n            raise ValueError('{0} is not a supported energy keywords.\\n Use any of the following: \\n {1}'.format(\n                which, self.enGlobalTypes[:5]))\n\n        energy = None\n\n        if which == 'full':\n            temp = np.matrix(diff)\n            energy = 0.5 * ((temp * es) * temp.T)\n            energy = energy[0,0]\n\n        if which == 'diag':\n            energy = 0.5 * ((diff[0] ** 2 * es[0][0])\n                            + (diff[1] ** 2 * es[1][1]))\n\n        if which == 'stretch':\n            energy = 0.5 * (diff[0] ** 2 * es[0][0])\n\n        if which == 'twist':\n            energy = 0.5 * (diff[1] ** 2 * es[1][1])\n\n        if which == 'st_coupling':\n            energy = 0.5 * (diff[0] * diff[1] * es[0][1])\n\n        return energy", "response": "r Calculates the energy for the given type of motions using a difference vector."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getLocalElasticityByTime(self, bp, frameGap, helical=False, unit='kT', outFile=None):\n        if helical:\n            props_name = helical_local_props_vector\n        else:\n            props_name = local_props_vector\n\n        time, elasticity = [], OrderedDict()\n        for name in props_name:\n            elasticity[name] = []\n\n        length = len(self.dna.time[:])\n        for i in range(frameGap, length, frameGap):\n            mean, esy_t = self.calculateLocalElasticity(bp, frames=[0, i], helical=helical, unit=unit)\n            esy_t = matrixToVector(esy_t)\n            for p in range(len(props_name)):\n                elasticity[props_name[p]].append(esy_t[p])\n            time.append(self.dna.time[i])\n\n        # Write output file\n        if outFile is not None:\n            with open(outFile, 'w') as fout:\n                fout.write('#Time')\n                for name in props_name:\n                    fout.write(', {0}'.format(name))\n                fout.write('\\n')\n                for t in range(len(time)):\n                    fout.write('{0:.3f}'.format(time[t]))\n                    for name in props_name:\n                        fout.write(', {0:.5f}'.format(elasticity[name][t]))\n                    fout.write('\\n')\n\n        return time, elasticity", "response": "r Calculates local elastic properties for a given convergence check."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate local elastic properties of consecutive overlapped DNA segments.", "response": "def calculateLocalElasticitySegments(self, bp, span=2, frameGap=None, helical=False, unit='kT',\n                                         err_type='block', tool='gmx analyze', outFile=None):\n        \"\"\"Calculate local elastic properties of consecutive overlapped DNA segments\n\n        Calculate local elastic properties of consecutive overlapped DNA segments of length given by `span`.\n\n        Parameters\n        ----------\n        bp : list\n            List of two base-steps forming the global DNA segment.\n            For example: with ``bp=[5, 50]``, 5-50 base-step segment will be considered.\n\n        span : int\n            Length of overlapping (local) DNA segments. It should be less than four.\n\n        frameGap : int\n            How many frames to skip for next time-frame. Lower the number, slower will be the calculation.\n\n        helical : bool\n            If ``helical=True``, elastic matrix for **helical base-step** parameters are calculated. Otherwise,\n            by default, elastic matrix for **base-step** parameters are calculated.\n\n        unit : str\n            Unit of energy. Allowed units are: ``'kT', 'kJ/mol' and 'kcal/mol'``.\n\n        err_type : str\n            Error estimation by autocorrelation method ``err_type='acf'`` or\n            block averaging method ``err_type='block'``\n\n        tool : str\n            GROMACS tool to calculate error. In older versions it is `g_analyze` while in\n            newer versions (above 2016) it is `gmx analyze`.\n\n        outFile : str\n            Output file in csv format.\n\n        Returns\n        -------\n        segments : list\n            list of DNA segments for which local elastic properties was calculated.\n\n        elasticities : OrderedDict\n            A ordered dictionary of 1D arrays of shape (segments). The keys in dictionary are name of the elasticity in\n            the same order as listed above.\n\n        error : OrderedDict\n            A ordered dictionary of 1D arrays of shape (segments). The keys in dictionary are name of the elasticity in\n            the same order as listed above..\n\n        \"\"\"\n        if helical:\n            props_name = helical_local_props_vector\n        else:\n            props_name = local_props_vector\n\n        segments, errors, elasticities = [], OrderedDict(), OrderedDict()\n        for name in props_name:\n            elasticities[name] = []\n            errors[name] = []\n\n        for s in range(bp[0], bp[1]):\n            if s+span-1 > bp[1]:\n                break\n            time, elasticity_t = self.getLocalElasticityByTime([s, s+span-1], frameGap=frameGap, helical=helical, unit=unit)\n            error_t = dnaMD.get_error(time, list(elasticity_t.values()), len(props_name), err_type=err_type, tool=tool)\n            for i in range(len(props_name)):\n                esy_t = elasticity_t[props_name[i]][-1]           # only take last entry\n                elasticities[props_name[i]].append(esy_t)\n                errors[props_name[i]].append(error_t[i])\n            segments.append('{0}-{1}'.format(s, s+span-1))\n\n        # Write output file\n        if outFile is not None:\n            with open(outFile, 'w') as fout:\n                fout.write('#bps')\n                for name in props_name:\n                    fout.write(', {0}, {0}-error'.format(name))\n                fout.write('\\n')\n                for s in range(len(segments)):\n                    fout.write('{0}'.format(segments[s]))\n                    for name in props_name:\n                        fout.write(', {0:.5f}, {1:.5f}'.format(elasticities[name][s], errors[name][s]))\n                    fout.write('\\n')\n\n        return segments, elasticities, errors"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the deformation energy of the input DNA using local elastic properties.", "response": "def getLocalDeformationEnergy(self, bp, complexDna, freeDnaFrames=None, boundDnaFrames=None, helical=False,\n                                  unit='kT', which='all', outFile=None):\n        r\"\"\"Deformation energy of the input DNA using local elastic properties\n\n        The deformation energy of a base-step/s for probe DNA object with reference to\n        the same base-step/s DNA present in the current DNA object.\n\n        The deformation free energy is calculated using elastic matrix as follows\n\n        .. math::\n\n            G = \\frac{1}{2}\\mathbf{xKx^T}\n\n        When ``helical='False'``\n\n        .. math::\n            \\mathbf{K} = \\mathbf{K}_{base-step}\n\n        .. math::\n\n            \\mathbf{x} =  \\begin{bmatrix}\n                              (Dx_{i}-Dx_0)  &  (Dy_i - Dy_0) & (Dz_i - Dz_0) & (\\tau_i - \\tau_0) &\n                              (\\rho_i - \\rho_0) & (\\omega_i - \\omega_0)\n                          \\end{bmatrix}\n\n\n        When ``helical='True'``\n\n        .. math::\n            \\mathbf{K} = \\mathbf{K}_{helical-base-step}\n\n        .. math::\n            \\mathbf{x} =  \\begin{bmatrix}\n                              (dx_{i}-dx_0)  &  (dy_i - dy_0) & (h_i - h_0) & (\\eta_i - \\eta_0) &\n                              (\\theta_i - \\theta_0) & (\\Omega_i - \\Omega_0)\n                          \\end{bmatrix}\n\n        .. currentmodule:: dnaMD\n\n\n        Parameters\n        ----------\n        bp : list\n            List of two base-steps forming the DNA segment.\n            For example: with ``bp=[5, 50]``, 5-50 base-step segment will be considered.\n\n        complexDna : :class:`dnaMD.DNA`\n            Input :class:`dnaMD.DNA` instance for which deformation energy will be calculated.\n\n        freeDnaFrames : list\n            To select a trajectory segment of current (free) DNA data.\n            List of two trajectory frames between which parameters will be extracted. It can be used to select portions\n            of the trajectory. For example, with ``frames=[100, 1000]``, 100th to 1000th frame of the trajectory will be\n            considered.\n\n        boundDnaFrames : list\n            To select a trajectory segment of input (bound) DNA data.\n            List of two trajectory frames between which parameters will be extracted. It can be used to select portions\n            of the trajectory. For example, with ``frames=[100, 1000]``, 100th to 1000th frame of the trajectory will be\n            considered.\n\n        helical : bool\n            If ``helical=True``, elastic matrix for **helical base-step** parameters are calculated. Otherwise,\n            by default, elastic matrix for **base-step** parameters are calculated.\n\n        unit : str\n            Unit of energy. Allowed units are: ``'kT', 'kJ/mol' and 'kcal/mol'``.\n\n        which : str or list\n            For which motions (degrees of freedom), energy should be calculated. It should be either a list containing\n            terms listed below or\"all\" for all energy terms.\n\n            Following keywords are available:\n                * ``'full'`` : Use entire elastic matrix -- all parameters with their coupling\n                * ``'diag'`` : Use diagonal of elastic matrix -- all motions but no coupling\n                * ``'shift'`` or ``'x-disp'``\n                * ``'slide'`` or ``'y-idsp'``\n                * ``'rise'`` or ``'h-rise'``\n                * ``'tilt'`` or ``'inclination'``\n                * ``'roll'`` or ``'tip'``\n                * ``'twist'`` or ``'h-twist'``\n\n        outFile : str\n            Output file in csv format.\n\n        Returns\n        -------\n        time : numpy.ndarray\n            1D array containing time values.\n\n        energy : dict of numpy.ndarray\n            Dictionary of 1D array of shape (nframes) containing energy terms requested for DNA.\n\n        \"\"\"\n        if helical:\n            energyTerms =  ['full', 'diag', 'x-disp', 'y-disp', 'h-rise', 'inclination', 'tip', 'h-twist']\n        else:\n            energyTerms = ['full', 'diag', 'shift', 'slide', 'rise', 'tilt', 'roll', 'twist']\n\n        if isinstance(which, str):\n            if which != 'all':\n                raise ValueError('Either use \"all\" or use list of terms from this {0} list \\n.'.format(energyTerms))\n            else:\n                which = energyTerms\n        elif isinstance(which, list):\n            for key in which:\n                if key not in energyTerms:\n                    raise ValueError('{0} is not a supported keyword.\\n Use from the following list: \\n{1}'.format(\n                        which, energyTerms))\n        else:\n            raise ValueError('Either use \"all\" or use list of terms from this {0} list \\n.'.format(energyTerms))\n\n        means, esMatrix = self.calculateLocalElasticity(bp, frames=freeDnaFrames, helical=helical, unit=unit)\n        time, array = self.extractLocalParameters(complexDna, bp, frames=boundDnaFrames, helical=helical)\n\n        # Initialize energy dictionary\n        energyOut = OrderedDict()\n        for key in which:\n            energyOut[key] = []\n\n        for i in range(array[0].shape[0]):\n            vec = array[:, i]\n            diff = vec - means\n            for key in which:\n                t_energy = self._calcLocalEnergy(diff, esMatrix, key)\n                energyOut[key].append(t_energy)\n\n        for key in which:\n            energyOut[key] = np.asarray(energyOut[key])\n\n        # Write output file\n        if outFile is not None:\n            with open(outFile, 'w') as fout:\n                fout.write('#Time')\n                for name in which:\n                    fout.write(', {0}'.format(name))\n                fout.write('\\n')\n                for t in range(len(time)):\n                    fout.write('{0:.3f}'.format(time[t]))\n                    for name in which:\n                        fout.write(', {0:.5f}'.format(energyOut[name][t]))\n                    fout.write('\\n')\n\n        return time, energyOut"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _calcLocalEnergy(self, diff, es, which):\n\n        if which not in self.enLocalTypes:\n            raise ValueError('{0} is not a supported energy keywords.\\n Use any of the following: \\n {1}'.format(\n                which, self.enLocalTypes))\n\n        energy = None\n\n        if which == 'full':\n            temp = np.matrix(diff)\n            energy = 0.5 * ((temp * es) * temp.T)\n            energy = energy[0,0]\n\n        if which == 'diag':\n            energy = 0.5 * ((diff[0] ** 2 * es[0][0])\n                            + (diff[1] ** 2 * es[1][1])\n                            + (diff[2] ** 2 * es[2][2])\n                            + (diff[3] ** 2 * es[3][3])\n                            + (diff[4] ** 2 * es[4][4])\n                            + (diff[5] ** 2 * es[5][5]))\n\n        if which == 'shift' or which == 'x-disp':\n            energy = 0.5 * (diff[0] ** 2 * es[0][0])\n\n        if which == 'slide' or which == 'y-disp':\n            energy = 0.5 * (diff[1] ** 2 * es[1][1])\n\n        if which == 'rise' or which == 'h-rise':\n            energy = 0.5 * (diff[2] ** 2 * es[2][2])\n\n        if which == 'tilt' or which == 'inclination':\n            energy = 0.5 * (diff[3] ** 2 * es[3][3])\n\n        if which == 'roll' or which == 'tip':\n            energy = 0.5 * (diff[4] ** 2 * es[4][4])\n\n        if which == 'twist' or which == 'h-twist':\n            energy = 0.5 * (diff[5] ** 2 * es[5][5])\n\n        return energy", "response": "r Calculates the local deformation energy using a difference vector."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the Supernodal multifrontal Cholesky product of the given factor L.", "response": "def llt(L):\n    \"\"\"\n    Supernodal multifrontal Cholesky product:\n\n    .. math::\n         X = LL^T\n\n    where :math:`L` is lower-triangular. On exit, the argument `L`\n    contains the product :math:`X`.\n\n    :param L:    :py:class:`cspmatrix` (factor)\n    \"\"\"\n\n    assert isinstance(L, cspmatrix) and L.is_factor is True, \"L must be a cspmatrix factor\"\n\n    n = L.symb.n\n    snpost = L.symb.snpost\n    snptr = L.symb.snptr\n    chptr = L.symb.chptr\n    chidx = L.symb.chidx\n\n    relptr = L.symb.relptr\n    relidx = L.symb.relidx\n    blkptr = L.symb.blkptr\n    blkval = L.blkval\n\n    stack = []\n\n    for k in snpost:\n\n        nn = snptr[k+1]-snptr[k]       # |Nk|\n        na = relptr[k+1]-relptr[k]     # |Ak|\n        nj = na + nn\n\n        # compute [I; L_{Ak,Nk}]*D_k*[I;L_{Ak,Nk}]'; store in F\n        blas.trmm(blkval, blkval, side = \"R\", m = na, n = nn, ldA = nj,\\\n                  ldB = nj, offsetA = blkptr[k], offsetB = blkptr[k]+nn)\n        F = matrix(0.0, (nj, nj))\n        blas.syrk(blkval, F, n = nj, k = nn, offsetA = blkptr[k], ldA = nj)\n\n        # if supernode k has any children, subtract update matrices \n        for _ in range(chptr[k],chptr[k+1]):\n            Ui, i = stack.pop()\n            frontal_add_update(F, Ui, relidx, relptr, i)\n\n        # if supernode k is not a root node, push update matrix onto stack\n        if na > 0:\n            Uk = matrix(0.0,(na,na))\n            lapack.lacpy(F, Uk, m = na, n = na, uplo = 'L', offsetA = nn*nj+nn, ldA = nj)\n            stack.append((Uk,k))\n\n        # copy leading Nk columns of F to blkval\n        lapack.lacpy(F, blkval, m = nj, n = nn, ldA = nj, uplo = 'L',\\\n                     ldB = nj, offsetB = blkptr[k])\n\n    L._is_factor = False\n\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of variable names used in a URI template.", "response": "def extract_variables(href):\n    \"\"\"Return a list of variable names used in a URI template.\"\"\"\n\n    patterns = [re.sub(r'\\*|:\\d+', '', pattern)\n                for pattern in re.findall(r'{[\\+#\\./;\\?&]?([^}]+)*}', href)]\n    variables = []\n    for pattern in patterns:\n        for part in pattern.split(\",\"):\n            if not part in variables:\n                variables.append(part)\n\n    return variables"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a URL for the link with optional template expansion.", "response": "def url(self, **kwargs):\n        \"\"\"Returns a URL for the link with optional template expansion.\n\n        If the link is marked as templated, the href will be expanded according\n        to RFC6570, using template variables provided in the keyword arguments.\n        If the href is a valid URI Template, but the link is not marked as\n        templated, the href will not be expanded even if template variables are\n        provided.\n\n        \"\"\"\n        if self.is_templated:\n            return uritemplate.expand(self.template, kwargs)\n        else:\n            return self.template"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new Link object based on a JSON object or a list of such documents.", "response": "def from_object(cls, o, base_uri):\n        \"\"\"Returns a new ``Link`` based on a JSON object or array.\n\n        Arguments:\n\n        - ``o``: a dictionary holding the deserializated JSON for the new\n                 ``Link``, or a ``list`` of such documents.\n        - ``base_uri``: optional URL used as the basis when expanding\n                               relative URLs in the link.\n\n        \"\"\"\n        if isinstance(o, list):\n            if len(o) == 1:\n                return cls.from_object(o[0], base_uri)\n\n            return [cls.from_object(x, base_uri) for x in o]\n\n        return cls(o, base_uri)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the content of the response and return it.", "response": "def read(self, amt=None, decode_content=True, cache_content=False):\n        \"\"\"\n        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n\n        :param amt:\n            How much of the content to read. If specified, decoding and caching\n            is skipped because we can't decode partial content nor does it make\n            sense to cache partial content as the full response.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header. (Overridden if ``amt`` is set.)\n\n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        content_encoding = self.headers.get('content-encoding')\n        decoder = self.CONTENT_DECODERS.get(content_encoding)\n\n        data = self._fp and self._fp.read(amt)\n\n        try:\n\n            if amt:\n                return data\n\n            if not decode_content or not decoder:\n                if cache_content:\n                    self._body = data\n\n                return data\n\n            try:\n                data = decoder(data)\n            except IOError:\n                raise HTTPError(\"Received response with content-encoding: %s, but \"\n                                \"failed to decode it.\" % content_encoding)\n\n            if cache_content:\n                self._body = data\n\n            return data\n\n        finally:\n\n            if self._original_response and self._original_response.isclosed():\n                self.release_conn()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_httplib(r, **response_kw):\n\n        return HTTPResponse(body=r,\n                            headers=dict(r.getheaders()),\n                            status=r.status,\n                            version=r.version,\n                            reason=r.reason,\n                            strict=r.strict,\n                            original_response=r,\n                            **response_kw)", "response": "Given an httplib. HTTPResponse instance r return a new HTTPResponse object with the content - type header and content - length."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninstall an asyncio protocol to process NOTIFY messages.", "response": "async def install_mediaroom_protocol(responses_callback, box_ip=None):\n    \"\"\"Install an asyncio protocol to process NOTIFY messages.\"\"\"\n    from . import version\n    _LOGGER.debug(version)\n\n    loop = asyncio.get_event_loop()\n\n    mediaroom_protocol = MediaroomProtocol(responses_callback, box_ip)\n\n    sock = create_socket()\n\n    await loop.create_datagram_endpoint(lambda: mediaroom_protocol, sock=sock)\n\n    return mediaroom_protocol"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tune(self):\n        if self._node.get('activities'):\n            tune = self._node['activities'].get('tune')\n            if type(tune) is collections.OrderedDict:\n                return tune\n            elif type(tune) is list:\n                return tune[0]\n            return tune\n        return None", "response": "XML node representing tune."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stopped(self):\n        if self.tune and self.tune.get('@stopped'):\n            return True if self.tune.get('@stopped') == 'true' else False\n        else:\n            raise PyMediaroomError(\"No information in <node> about @stopped\")", "response": "Return if the stream is stopped."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns if the stream is a timeshift.", "response": "def timeshift(self):\n        \"\"\"Return if the stream is a timeshift.\"\"\"\n        if self.tune and self.tune.get('@src'):\n            return True if self.tune.get('@src').startswith('timeshift') else False\n        else:\n            raise PyMediaroomError(\"No information in <node> about @src\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning if the stream is a recording.", "response": "def recorded(self):\n        \"\"\"Return if the stream is a recording.\"\"\"\n        if self.tune and self.tune.get('@src'):\n            return True if self.tune.get('@src').startswith('mbr') else False\n        else:\n            raise PyMediaroomError(\"No information in <node> about @src\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, page_size, page_no=1, campaign_id=None, adgroup_ids=None, nick=None):\n        '''xxxxx.xxxxx.adgroups.get\n        ===================================\n        \u53d6\u5f97\u4e00\u4e2a\u63a8\u5e7f\u8ba1\u5212\u7684\u6240\u6709\u63a8\u5e7f\u7ec4\uff0c\u6216\u8005\u6839\u636e\u4e00\u4e2a\u63a8\u5e7f\u7ec4Id\u5217\u8868\u53d6\u5f97\u4e00\u7ec4\u63a8\u5e7f\u7ec4\uff1b\n        \u5982\u679c\u540c\u65f6\u63d0\u4f9b\u4e86\u63a8\u5e7f\u8ba1\u5212Id\u548c\u63a8\u5e7f\u7ec4id\u5217\u8868\uff0c\u5219\u4f18\u5148\u4f7f\u7528\u63a8\u5e7f\u8ba1\u5212Id\uff0c\u5f53\u4f7f\u7528\n        \u63a8\u5e7f\u8ba1\u5212ID\u83b7\u53d6\u6570\u636e\u65f6\uff0c\u8fd4\u56de\u7684\u7ed3\u679c\u662f\u6709\u5206\u9875\u7684\u3002\u5982\u679c\u662f\u7528\u63a8\u5e7f\u7ec4ID\u5217\u8868\u4f5c\u67e5\u8be2\n        \u5219\u5c06\u4e00\u6b21\u8fd4\u56de\u6240\u6709\u67e5\u8be2\u7684\u7ed3\u679c\u3002'''\n        request = TOPRequest('xxxxx.xxxxx.adgroups.get')\n        request['page_size'] = page_size\n        request['page_no'] = page_no\n        if campaign_id!=None: request['campaign_id'] = campaign_id\n        if adgroup_ids!=None: request['adgroup_ids'] = adgroup_ids\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), models = {'result':ADGroup})\n        return self.result", "response": "xxxxx. xxxxxx. adgroups. get \u83b7\u53d6\u63a8\u5e7f\u8ba1\u5212\u7684\u7ed3\u679c"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef record_get(self, creative_ids, nick=None):\n        '''xxxxx.xxxxx.creatives.record.get\n        ===================================\n        \u6839\u636e\u4e00\u4e2a\u521b\u610fId\u5217\u8868\u53d6\u5f97\u521b\u610f\u5bf9\u5e94\u7684\u4fee\u6539\u8bb0\u5f55'''\n        request = TOPRequest('xxxxx.xxxxx.creatives.record.get')\n        request['creative_ids'] = creative_ids\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), models = {'result':CreativeRecord})\n        return self.result", "response": "xxxxx. xxxxxx. creative. record. get"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, adgroup_id=None, creative_ids=None, nick=None):\n        '''xxxxx.xxxxx.creatives.get\n        ===================================\n        \u53d6\u5f97\u4e00\u4e2a\u63a8\u5e7f\u7ec4\u7684\u6240\u6709\u521b\u610f\u6216\u8005\u6839\u636e\u4e00\u4e2a\u521b\u610fId\u5217\u8868\u53d6\u5f97\u4e00\u7ec4\u521b\u610f\uff1b\n        \u5982\u679c\u540c\u65f6\u63d0\u4f9b\u4e86\u63a8\u5e7f\u7ec4Id\u548c\u521b\u610fid\u5217\u8868\uff0c\u5219\u4f18\u5148\u4f7f\u7528\u63a8\u5e7f\u7ec4Id\uff1b'''\n        request = TOPRequest('xxxxx.xxxxx.creatives.get')\n        if adgroup_id!=None: request['adgroup_id'] = adgroup_id\n        if creative_ids!=None: request['creative_ids'] = creative_ids\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), models = {'result':Creative})\n        return self.result", "response": "xxxxx. xxxxxx. creatives. get"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef price_set(self, adgroup_id, keywordId_prices, nick=None):\n        '''xxxxx.xxxxx.keywords.price.set\n        ===================================\n        \u8bbe\u7f6e\u4e00\u6279\u5173\u952e\u8bcd\u7684\u51fa\u4ef7'''\n        request = TOPRequest('xxxxx.xxxxx.keywords.price.set')\n        request['adgroup_id'] = adgroup_id\n        request['keywordId_prices'] = keywordId_prices\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request))\n        return self.result", "response": "xxxxx. xxxxxx. keywords. price. set\u8bcd\u7684\u51fa\u4ef7"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef recommend_get(self, adgroup_id, **kwargs):\n        '''xxxxx.xxxxx.keywords.recommend.get\n        ===================================\n        \u53d6\u5f97\u4e00\u4e2a\u63a8\u5e7f\u7ec4\u7684\u63a8\u8350\u5173\u952e\u8bcd\u5217\u8868'''\n        request = TOPRequest('xxxxx.xxxxx.keywords.recommend.get')\n        request['adgroup_id'] = adgroup_id\n        for k, v in kwargs.iteritems():\n            if k not in ('nick', 'order_by', 'search', 'pertinence', 'page_size', 'page_no') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request), models = {'result':RecommendWordPage})\n        return self.result", "response": "xxxxx. xxxxxx. keywords. recommend. get =================================== \u53d6\u5f97\u4e00\u4e2a\u63a8\u5e7f\u7ec4\u7684\u63a8\u8350\u5173\u952e\u8bcd\u5217\u8868 =================================== \u53d6\u5f97\u4e00\u4e2a\u63a8\u5e7f\u7ec4\u7684\u63a8\u8350\u5173"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef authorized_get(self):\n        '''xxxxx.xxxxx.customers.authorized.get\n        ===================================\n        \u53d6\u5f97\u5f53\u524d\u767b\u5f55\u7528\u6237\u7684\u6388\u6743\u8d26\u6237\u5217\u8868'''\n        request = TOPRequest('xxxxx.xxxxx.customers.authorized.get')\n        self.create(self.execute(request))\n        return self.result", "response": "xxxxx. xxxxxx. customers. authorized. get \u83b7\u53d6\u5f97\u5f53\u524d\u767b\u5f55\u7528\u6237\u7684\u6388\u6743\u8d26\u6237\u5217\u8868"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef balance_get(self, nick):\n        '''xxxxx.xxxxx.account.balance.get\n        ===================================\n        \u53d6\u5f97\u5f53\u524d\u767b\u5f55\u7528\u6237\u7684\u6388\u6743\u8d26\u6237\u5217\u8868'''\n        request = TOPRequest('xxxxx.xxxxx.account.balance.get')\n        request['nick'] = nick\n        self.create(self.execute(request))\n        return self.result", "response": "xxxxx. xxxxxx. account. balance. get"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef records_get(self, nick, start_time=None, end_time=None):\n        '''xxxxx.xxxxx.account.records.get\n        ===================================\n        \u83b7\u53d6\u8d26\u6237\u8d22\u52a1\u8bb0\u5f55'''\n        request = TOPRequest('xxxxx.xxxxx.account.records.get')\n        request['nick'] = nick\n        if start_time!=None: request['start_time'] = start_time\n        if end_time!=None: request['end_time'] = end_time\n        self.create(self.execute(request), models={'result':AccountRecord})\n        return self.result", "response": "xxxxx. xxxxxx. account. records. get"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef items_top_get(self, keyword, nick=None):\n        '''xxxxx.xxxxx.tools.items.top.get\n        ===================================\n        \u53d6\u5f97\u5f53\u524d\u767b\u5f55\u7528\u6237\u7684\u6388\u6743\u8d26\u6237\u5217\u8868'''\n        request = TOPRequest('xxxxx.xxxxx.tools.items.top.get')\n        request['keyword'] = keyword\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), models={'result':RankedItem})\n        return self.result", "response": "xxxxx. xxxxxx. tools. items. top. get"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate_session(self, session_ts):\n        '''\n        \u68c0\u67e5Session\u662f\u5426\u8fc7\u671f, \u9a8c\u8bc1Session\u53ef\u7528\u6027\n        '''\n        now = time()\n        ts = session_ts / 1000;\n        if ts > ( now + 60 * 10 ) or now > ( ts + 60 * 30 ):\n            return False\n        return True", "response": "Check if the session is valid."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, nicks=[], fields=[]):\n        '''taobao.users.get \u83b7\u53d6\u591a\u4e2a\u7528\u6237\u4fe1\u606f'''\n        request = TOPRequest('taobao.users.get')\n        request['nicks'] = ','.join(nicks)\n        if not fields:\n            user = User()\n            fields = user.fields\n        request['fields'] = ','.join(fields)\n        self.create(self.execute(request))\n        return self.users", "response": "TAOBAO. users. get \u83b7\u53d6\u591a\u4e2a\u7528\u6237\u4fe1\u606f"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pause(self):\n\t\tif self.status == RUNNING:\n\t\t\tself.status = PAUSED\n\t\t\tself.previous_intervals.append(time.time() - self.interval_start)\n\t\t\tself.current_interval_duration = 0.0\n\t\telif self.status == PAUSED:\n\t\t\tself.interval_start = time.time()\n\t\t\tself.status = RUNNING", "response": "Pauses the clock to continue running later."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start(self):\n\t\tif not hasattr(self,\"thread\") or not self.thread.isAlive():\n\t\t\tself.thread = threading.Thread(target=self.__run)\n\t\t\tself.status = RUNNING\n\t\t\tself.reset()\n\t\t\tself.thread.start()\n\t\telse:\n\t\t\tprint(\"Clock already running!\")", "response": "Starts the clock from 0. \n\t\t uses a separate thread to handle the timing functionalities."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __run(self):\n\t\tself.interval_start = time.time()\n\t\twhile self.status != STOPPED:\n\t\t\tif self.status == RUNNING:\n\t\t\t\tself.current_interval_duration = time.time() - self.interval_start\n\n\t\t\t# If max_duration is set, stop the clock if it is reached\n\t\t\tif self.max_duration and self.time > self.max_duration:\n\t\t\t\tself.status == STOPPED\n\n\t\t\t# One refresh per millisecond seems enough\n\t\t\ttime.sleep(0.001)", "response": "Internal function that is run in a separate thread. Do not call \n\tdirectly. Do not call \n\tdirectly."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the time of the clock. Useful for seeking. Parameters Parameters value - The time to seek to.", "response": "def time(self, value):\n\t\t\"\"\" Sets the time of the clock. Useful for seeking. \n\t\t\n\t\tParameters\n\t\t----------\n\t\tvalue : str or int\n\t\t\tThe time to seek to. Can be any of the following formats:\n\n\t\t    >>> 15.4 -> 15.4 # seconds\n\t\t    >>> (1,21.5) -> 81.5 # (min,sec)\n\t\t    >>> (1,1,2) -> 3662 # (hr, min, sec)\n\t\t    >>> '01:01:33.5' -> 3693.5  #(hr,min,sec)\n\t\t    >>> '01:01:33.045' -> 3693.045\n\t\t    >>> '01:01:33,5' #comma works too\n\t\t\"\"\"\n\t\tseconds = cvsecs(value)\n\t\tself.reset()\n\t\tself.previous_intervals.append(seconds)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the current frame number that should be displayed.", "response": "def current_frame(self):\n\t\t\"\"\" The current frame number that should be displayed.\"\"\"\n\t\tif not self.__fps:\n\t\t\traise RuntimeError(\"fps not set so current frame number cannot be\"\n\t\t\t\t\" calculated\")\n\t\telse:\n\t\t\treturn int(self.__fps * self.time)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the fps of the current movie.", "response": "def fps(self,value):\n\t\t\"\"\" Sets the frames per second of the current movie the clock is used for.\n\n\t\tParameters\n\t\t----------\n\t\tvalue : float\n\t\t\tThe fps value.\n\t\t\"\"\"\n\t\tif not value is None:\n\t\t\tif not type(value) == float:\n\t\t\t\traise ValueError(\"fps needs to be specified as a float\")\n\t\t\tif value<1.0:\n\t\t\t\traise ValueError(\"fps needs to be greater than 1.0\")\n\t\tself.__fps = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload the string data from a text file that was packaged as a .", "response": "def get_shared(fname, encoding=\"utf-8\"):\n    \"\"\"\n    Loads the string data from a text file that was packaged as a\n    data file in the distribution.\n\n    Uses the setuptools ``pkg_resources.resource_string`` function as\n    a fallback, as installing Dose with it directly instead of using\n    wheel/pip would store the setup.py ``data_files`` otherwhere. For\n    more information, see this:\n\n    https://github.com/pypa/setuptools/issues/130\n    \"\"\"\n    relative_path = \"share/dose/v{0}/{1}\".format(__version__, fname)\n    prefixed_path = os.path.join(sys.prefix, *relative_path.split(\"/\"))\n\n    # Look for the file directly on sys.prefix\n    try:\n        return \"\\n\".join(read_plain_text(prefixed_path, encoding=encoding))\n    except IOError:\n        pass\n\n    # Homebrew (Mac OS X) stores the data in Cellar, a directory in\n    # the system prefix. Calling \"brew --prefix\" returns that prefix,\n    # and pip installs the shared resources there\n    cellar_index = sys.prefix.find(\"/Cellar/\")\n    if cellar_index != -1: # Found!\n        outside_cellar_path = os.path.join(sys.prefix[:cellar_index],\n                                           *relative_path.split(\"/\"))\n        try:\n            return \"\\n\".join(read_plain_text(outside_cellar_path,\n                                             encoding=encoding))\n        except IOError:\n            pass\n\n    # Fallback: look for the file using setuptools (perhaps it's still\n    # compressed inside an egg file or stored otherwhere)\n    from pkg_resources import Requirement, resource_string\n    return resource_string(Requirement.parse(\"dose\"), relative_path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of agents based on their state and connectedness.", "response": "def get_agents(self, state_id=None, limit_neighbors=False):\n        \"\"\"Returns list of agents based on their state and connectedness\n\n        Parameters\n        ----------\n        state_id : int, str, or array-like, optional\n            Used to select agents that have the same specified \"state\". If state = None, returns all agents regardless\n            of its current state\n        limit_neighbors : bool, optional\n            Returns agents based on whether they are connected to this agent or not. If limit_neighbors = False,\n            returns all agents whether or not it is directly connected to this agent\n        \"\"\"\n        if limit_neighbors:\n            agents = self.global_topology.neighbors(self.id)\n        else:\n            agents = self.get_all_nodes()\n\n        if state_id is None:\n            return [self.global_topology.node[_]['agent'] for _ in agents]  # return all regardless of state\n        else:\n            return [self.global_topology.node[_]['agent'] for _ in agents\n                    if self.global_topology.node[_]['agent'].state['id'] == state_id]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_node(self, agent_type=None, state=None, name='network_process', **state_params):\n        agent_id = int(len(self.global_topology.nodes()))\n        agent = agent_type(self.env, agent_id=agent_id, state=state, name=name, **state_params)\n        self.global_topology.add_node(agent_id, {'agent': agent})\n        return agent_id", "response": "Add a new node to the current network."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_edge(self, agent_id1, agent_id2, edge_attr_dict=None, *edge_attrs):\n        if agent_id1 in self.global_topology.nodes(data=False):\n            if agent_id2 in self.global_topology.nodes(data=False):\n                self.global_topology.add_edge(agent_id1, agent_id2, edge_attr_dict=edge_attr_dict, *edge_attrs)\n            else:\n                raise ValueError('\\'agent_id2\\'[{}] not in list of existing agents in the network'.format(agent_id2))\n        else:\n            raise ValueError('\\'agent_id1\\'[{}] not in list of existing agents in the network'.format(agent_id1))", "response": "Adds an edge between agents agent_id1 and agent_id2."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionary of HTTP headers for the current request.", "response": "def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,\n                 basic_auth=None):\n    \"\"\"\n    Shortcuts for generating request headers.\n\n    :param keep_alive:\n        If ``True``, adds 'connection: keep-alive' header.\n\n    :param accept_encoding:\n        Can be a boolean, list, or string.\n        ``True`` translates to 'gzip,deflate'.\n        List will get joined by comma.\n        String will be used as provided.\n\n    :param user_agent:\n        String representing the user-agent you want, such as\n        \"python-urllib3/0.6\"\n\n    :param basic_auth:\n        Colon-separated username:password string for 'authorization: basic ...'\n        auth header.\n\n    Example: ::\n\n        >>> make_headers(keep_alive=True, user_agent=\"Batman/1.0\")\n        {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n        >>> make_headers(accept_encoding=True)\n        {'accept-encoding': 'gzip,deflate'}\n    \"\"\"\n    headers = {}\n    if accept_encoding:\n        if isinstance(accept_encoding, str):\n            pass\n        elif isinstance(accept_encoding, list):\n            accept_encoding = ','.join(accept_encoding)\n        else:\n            accept_encoding = 'gzip,deflate'\n        headers['accept-encoding'] = accept_encoding\n\n    if user_agent:\n        headers['user-agent'] = user_agent\n\n    if keep_alive:\n        headers['connection'] = 'keep-alive'\n\n    if basic_auth:\n        headers['authorization'] = 'Basic ' + \\\n            basic_auth.encode('base64').strip()\n\n    return headers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive a url return its scheme host and port.", "response": "def get_host(url):\n    \"\"\"\n    Given a url, return its scheme, host and port (None if it's not there).\n\n    For example: ::\n\n        >>> get_host('http://google.com/mail/')\n        ('http', 'google.com', None)\n        >>> get_host('google.com:80')\n        ('http', 'google.com', 80)\n    \"\"\"\n    # This code is actually similar to urlparse.urlsplit, but much\n    # simplified for our needs.\n    port = None\n    scheme = 'http'\n    if '//' in url:\n        scheme, url = url.split('://', 1)\n    if '/' in url:\n        url, _path = url.split('/', 1)\n    if ':' in url:\n        url, port = url.split(':', 1)\n        port = int(port)\n    return scheme, url, port"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a fresh HTTPConnection.", "response": "def _new_conn(self):\n        \"\"\"\n        Return a fresh :class:`httplib.HTTPConnection`.\n        \"\"\"\n        self.num_connections += 1\n        log.info(\"Starting new HTTP connection (%d): %s\" %\n                 (self.num_connections, self.host))\n        return HTTPConnection(host=self.host, port=self.port)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a connection from the pool. Will return a pooled connection if one is available and raise EmptyPoolError if no more connections are available and a new connection is returned.", "response": "def _get_conn(self, timeout=None):\n        \"\"\"\n        Get a connection. Will return a pooled connection if one is available.\n\n        If no connections are available and :prop:`.block` is ``False``, then a\n        fresh connection is returned.\n\n        :param timeout:\n            Seconds to wait before giving up and raising\n            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and\n            :prop:`.block` is ``True``.\n        \"\"\"\n        conn = None\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n\n            # If this is a persistent connection, check if it got disconnected\n            if conn and conn.sock and select([conn.sock], [], [], 0.0)[0]:\n                # Either data is buffered (bad), or the connection is dropped.\n                log.info(\"Resetting dropped connection: %s\" % self.host)\n                conn.close()\n\n        except Empty:\n            if self.block:\n                raise EmptyPoolError(\"Pool reached maximum size and no more \"\n                                     \"connections are allowed.\")\n            pass  # Oh well, we'll create a new connection then\n\n        return conn or self._new_conn()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _make_request(self, conn, method, url, timeout=_Default,\n                      **httplib_request_kw):\n        \"\"\"\n        Perform a request on a given httplib connection object taken from our\n        pool.\n        \"\"\"\n        self.num_requests += 1\n\n        if timeout is _Default:\n            timeout = self.timeout\n\n        conn.request(method, url, **httplib_request_kw)\n        conn.sock.settimeout(timeout)\n        httplib_response = conn.getresponse()\n\n        log.debug(\"\\\"%s %s %s\\\" %s %s\" %\n                  (method, url,\n                   conn._http_vsn_str, # pylint: disable-msg=W0212\n                   httplib_response.status, httplib_response.length))\n\n        return httplib_response", "response": "Perform a request on a given httplib connection object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the given url is a member of the same host as this connection pool.", "response": "def is_same_host(self, url):\n        \"\"\"\n        Check if the given ``url`` is a member of the same host as this\n        conncetion pool.\n        \"\"\"\n        # TODO: Add optional support for socket.gethostbyname checking.\n        return (url.startswith('/') or\n                get_host(url) == (self.scheme, self.host, self.port))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a connection from the pool and perform an HTTP request. This is the lowest level call for making a request, so you'll need to specify all the raw details. .. note:: More commonly, it's appropriate to use a convenience method provided by :class:`.RequestMethods`, such as :meth:`.request`. :param method: HTTP request method (such as GET, POST, PUT, etc.) :param body: Data to send in the request body (useful for creating POST requests, see HTTPConnectionPool.post_url for more convenience). :param headers: Dictionary of custom headers to send, such as User-Agent, If-None-Match, etc. If None, pool headers are used. If provided, these headers completely replace any pool-specific headers. :param retries: Number of retries to allow before raising a MaxRetryError exception. :param redirect: Automatically handle redirects (status codes 301, 302, 303, 307), each redirect counts as a retry. :param assert_same_host: If ``True``, will make sure that the host of the pool requests is consistent else will raise HostChangedError. When False, you can use the pool on an HTTP proxy and request foreign hosts. :param timeout: If specified, overrides the default timeout for this one request. :param pool_timeout: If set and the pool is set to block=True, then this method will block for ``pool_timeout`` seconds and raise EmptyPoolError if no connection is available within the time period. :param release_conn: If False, then the urlopen call will not release the connection back into the pool once a response is received. This is useful if you're not preloading the response's content immediately. You will need to call ``r.release_conn()`` on the response ``r`` to return the connection back into the pool. If None, it takes the value of ``response_kw.get('preload_content', True)``. :param \\**response_kw: Additional parameters are passed to :meth:`urllib3.response.HTTPResponse.from_httplib`", "response": "def urlopen(self, method, url, body=None, headers=None, retries=3,\n                redirect=True, assert_same_host=True, timeout=_Default,\n                pool_timeout=None, release_conn=None, **response_kw):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n\n        .. note::\n\n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`.request`.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param body:\n            Data to send in the request body (useful for creating\n            POST requests, see HTTPConnectionPool.post_url for\n            more convenience).\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param retries:\n            Number of retries to allow before raising a MaxRetryError exception.\n\n        :param redirect:\n            Automatically handle redirects (status codes 301, 302, 303, 307),\n            each redirect counts as a retry.\n\n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When False, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n\n        :param timeout:\n            If specified, overrides the default timeout for this one request.\n\n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n\n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received. This is useful if\n            you're not preloading the response's content immediately. You will\n            need to call ``r.release_conn()`` on the response ``r`` to return\n            the connection back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n\n        :param \\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n        if headers is None:\n            headers = self.headers\n\n        if retries < 0:\n            raise MaxRetryError(\"Max retries exceeded for url: %s\" % url)\n\n        if release_conn is None:\n            release_conn = response_kw.get('preload_content', True)\n\n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            host = \"%s://%s\" % (self.scheme, self.host)\n            if self.port:\n                host = \"%s:%d\" % (host, self.port)\n\n            raise HostChangedError(\"Connection pool with host '%s' tried to \"\n                                   \"open a foreign host: %s\" % (host, url))\n\n        conn = None\n\n        try:\n            # Request a connection from the queue\n            # (Could raise SocketError: Bad file descriptor)\n            conn = self._get_conn(timeout=pool_timeout)\n\n            # Make the request on the httplib connection object\n            httplib_response = self._make_request(conn, method, url,\n                                                  timeout=timeout,\n                                                  body=body, headers=headers)\n\n            # If we're going to release the connection in ``finally:``, then\n            # the request doesn't need to know about the connection. Otherwise\n            # it will also try to release it and we'll have a double-release\n            # mess.\n            response_conn = not release_conn and conn\n\n            # Import httplib's response into our own wrapper object\n            response = HTTPResponse.from_httplib(httplib_response,\n                                                 pool=self,\n                                                 connection=response_conn,\n                                                 **response_kw)\n\n            # else:\n            #     The connection will be put back into the pool when\n            #     ``response.release_conn()`` is called (implicitly by\n            #     ``response.read()``)\n\n        except (SocketTimeout, Empty), e:\n            # Timed out either by socket or queue\n            raise TimeoutError(\"Request timed out after %s seconds\" %\n                               self.timeout)\n\n        except (BaseSSLError), e:\n            # SSL certificate error\n            raise SSLError(e)\n\n        except (HTTPException, SocketError), e:\n            # Connection broken, discard. It will be replaced next _get_conn().\n            conn = None\n\n        finally:\n            if conn and release_conn:\n                # Put the connection back to be reused\n                self._put_conn(conn)\n\n        if not conn:\n            log.warn(\"Retrying (%d attempts remain) after connection \"\n                     \"broken by '%r': %s\" % (retries, e, url))\n            return self.urlopen(method, url, body, headers, retries - 1,\n                                redirect, assert_same_host)  # Try again\n\n        # Handle redirection\n        if (redirect and\n            response.status in [301, 302, 303, 307] and\n            'location' in response.headers):  # Redirect, retry\n            log.info(\"Redirecting %s -> %s\" %\n                     (url, response.headers.get('location')))\n            return self.urlopen(method, response.headers.get('location'), body,\n                                headers, retries - 1, redirect,\n                                assert_same_host)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _new_conn(self):\n        self.num_connections += 1\n        log.info(\"Starting new HTTPS connection (%d): %s\"\n                 % (self.num_connections, self.host))\n\n        if not ssl:\n            return HTTPSConnection(host=self.host, port=self.port)\n\n        connection = VerifiedHTTPSConnection(host=self.host, port=self.port)\n        connection.set_cert(key_file=self.key_file, cert_file=self.cert_file,\n                            cert_reqs=self.cert_reqs, ca_certs=self.ca_certs)\n        return connection", "response": "Return a new HTTPSConnection."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef can_document_member(cls, member, membername, isattr, parent):\n        if not super().can_document_member(member, membername, isattr, parent):\n            return False\n        return iscoroutinefunction(member)", "response": "Called to see if a member can be documented by this documenter."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self, template_id, session):\n        '''taobao.delivery.template.delete \u5220\u9664\u8fd0\u8d39\u6a21\u677f\n        \n        \u6839\u636e\u7528\u6237\u6307\u5b9a\u7684\u6a21\u677fID\u5220\u9664\u6307\u5b9a\u7684\u6a21\u677f'''\n        request = TOPRequest('taobao.delivery.template.delete')\n        request['template_id'] = template_id\n        self.create(self.execute(request, session), fields=['complete', ])\n        return self.complete", "response": "TAOBAO. delivery. template. delete \u5220\u9664\u8fd0\u8d39\u6a21\u677fID\u5220\u9664\u6307\u5b9a\u7684\u6a21\u677f ID"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, template_ids, session, fields=[]):\n        '''taobao.delivery.template.get \u83b7\u53d6\u7528\u6237\u6307\u5b9a\u8fd0\u8d39\u6a21\u677f\u4fe1\u606f\n        \n        \u83b7\u53d6\u7528\u6237\u6307\u5b9a\u8fd0\u8d39\u6a21\u677f\u4fe1\u606f'''\n        request = TOPRequest('taobao.delivery.template.get')\n        request['template_ids'] = template_ids\n        if not fields:\n            fields = self.fields\n        request['fields'] = fields\n        self.create(self.execute(request, session), fields=['delivery_templates', 'total_results'], models={'delivery_templates':DeliveryTemplate})\n        return self.delivery_templates", "response": "TAOBAO. delivery. template. get \u83b7\u53d6\u7528\u6237\u6307\u5b9a\u8fd0\u8d39\u6a21\u677f\u4fe1\u606f"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, session, is_recommended=None, order_mode=None, fields=[]):\n        '''taobao.logistics.companies.get \u67e5\u8be2\u7269\u6d41\u516c\u53f8\u4fe1\u606f\n        \n        \u67e5\u8be2\u6dd8\u5b9d\u7f51\u5408\u4f5c\u7684\u7269\u6d41\u516c\u53f8\u4fe1\u606f\uff0c\u7528\u4e8e\u53d1\u8d27\u63a5\u53e3\u3002'''\n        request = TOPRequest('taobao.logistics.companies.get')\n        if not fields:\n            lc = LogisticsCompany()\n            fields = lc.fields\n        request['fields'] = fields\n        if is_recommended!=None: request['is_recommended'] = is_recommended\n        if order_mode!=None: request['order_mode'] = order_mode\n        self.create(self.execute(request, session))\n        return self.logistics_companies", "response": "TAOBAO. logistics. companies. get \u67e5\u8be2\u7269\u6d41\u516c\u53f8\u4fe1\u606f\uff0c\u7528\u4e8e\u53d1\u8d27\u63a5\u53e3\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, name, session, **kwargs):\n        '''taobao.postage.add \u6dfb\u52a0\u90ae\u8d39\u6a21\u677f\n        \n        \u6dfb\u52a0\u90ae\u8d39\u6a21\u677f \n        \n        \u65b0\u589e\u7684\u90ae\u8d39\u6a21\u677f\u5c5e\u4e8e\u5f53\u524d\u4f1a\u8bdd\u7528\u6237 \n        \n        postage_mode_types\u3001postage_mode_dests\u3001postage_mode_prices\u3001 postage_mode_increases\u56db\u4e2a\u5b57\u6bb5\u7ec4\u5408\u8d77\u6765\u8868\u793a\u90ae\u8d39\u7684\u5b50\u6a21\u677f\u5217\u8868\u3002\u6bcf\u4e2a\u90ae\u8d39\u5b50\u6a21\u677f\u90fd\u5305\u542b\u4e86type\uff08\u90ae\u8d39\u7c7b\u578b\uff0c\u6709post\u3001 express\u3001ems\u53ef\u4ee5\u9009\u62e9\uff09\u3001dest\uff08\u90ae\u8d39\u6a21\u677f\u5e94\u7528\u5730\u533a\uff0c\u6bcf\u4e2a\u6a21\u677f\u53ef\u4ee5\u4f7f\u7528\u4e8e\u591a\u4e2a\u5730\u533a\uff0c\u6bcf\u4e2a\u5730\u533a\u586b\u5165\u4ed6\u7684\u4ee3\u7801\uff0c\u5730\u533a\u4e0e\u5730\u533a\u4e4b\u95f4\u7528\u534a\u89d2\u9017\u53f7\u5206\u9694\uff09\u3001 price\uff08\u90ae\u8d39\u57fa\u4ef7\uff09\u3001increment\uff08\u90ae\u8d39\u589e\u4ef7\uff09\u56db\u4e2a\u90e8\u5206\u3002\u5982\u679c\u6709\u591a\u4e2a\u5b50\u6a21\u677f\uff0c\u5219\u5c06\u4ed6\u4eec\u76844\u4e2a\u90e8\u5206\u5206\u522b\u7ec4\u5408\uff0c\u4e4b\u95f4\u7528\u534a\u89d2\u5206\u53f7\u9694\u5f00\uff08\u6ce8\u610f\u6bcf\u4e2a\u6a21\u677f\u7684\u6bcf\u4e2a\u90e8\u5206\u7684\u4f4d\u7f6e\u8981\u4e00\u6837\u3002\u5373\uff0c\u5b50\u6a21\u677f1\u53f7\u7684type\u3001dest\u3001price\u3001increment\u90fd\u8981\u6392\u5728\u8fd9\u56db\u4e2a\u53c2\u6570\u7684\u7b2c\u4e00\u4f4d\uff1b\u5b50\u6a21\u677f2\u53f7\u8981\u6392\u5728\u7b2c\u4e8c\u4f4d\u2026\u2026\u4ee5\u6b64\u7c7b\u63a8\uff09'''\n        request = TOPRequest('taobao.postage.add')\n        request['name'] = name\n        for k, v in kwargs.iteritems():\n            if k not in ('post_price', 'post_increase', 'express_price', 'express_increase', 'ems_price', 'ems_increase', 'memo', 'postage_mode_types', 'postage_mode_dests', 'postage_mode_prices', 'postage_mode_increases') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session)['postage'])\n        return self", "response": "taobao.postage.add \u6dfb\u52a0\u90ae\u8d39\u6a21\u677f\n        \n        \u6dfb\u52a0\u90ae\u8d39\u6a21\u677f \n        \n        \u65b0\u589e\u7684\u90ae\u8d39\u6a21\u677f\u5c5e\u4e8e\u5f53\u524d\u4f1a\u8bdd\u7528\u6237 \n        \n        postage_mode_types\u3001postage_mode_dests\u3001postage_mode_prices\u3001 postage_mode_increases\u56db\u4e2a\u5b57\u6bb5\u7ec4\u5408\u8d77\u6765\u8868\u793a\u90ae\u8d39\u7684\u5b50\u6a21\u677f\u5217\u8868\u3002\u6bcf\u4e2a\u90ae\u8d39\u5b50\u6a21\u677f\u90fd\u5305\u542b\u4e86type\uff08\u90ae\u8d39\u7c7b\u578b\uff0c\u6709post\u3001 express\u3001ems\u53ef\u4ee5\u9009\u62e9\uff09\u3001dest\uff08\u90ae\u8d39\u6a21\u677f\u5e94\u7528\u5730\u533a\uff0c\u6bcf\u4e2a\u6a21\u677f\u53ef\u4ee5\u4f7f\u7528\u4e8e\u591a\u4e2a\u5730\u533a\uff0c\u6bcf\u4e2a\u5730\u533a\u586b\u5165\u4ed6\u7684\u4ee3\u7801\uff0c\u5730\u533a\u4e0e\u5730\u533a\u4e4b\u95f4\u7528\u534a\u89d2\u9017\u53f7\u5206\u9694\uff09\u3001 price\uff08\u90ae\u8d39\u57fa\u4ef7\uff09\u3001increment\uff08\u90ae\u8d39\u589e\u4ef7\uff09\u56db\u4e2a\u90e8\u5206\u3002\u5982\u679c\u6709\u591a\u4e2a\u5b50\u6a21\u677f\uff0c\u5219\u5c06\u4ed6\u4eec\u76844\u4e2a\u90e8\u5206\u5206\u522b\u7ec4\u5408\uff0c\u4e4b\u95f4\u7528\u534a\u89d2\u5206\u53f7\u9694\u5f00\uff08\u6ce8\u610f\u6bcf\u4e2a\u6a21\u677f\u7684\u6bcf\u4e2a\u90e8\u5206\u7684\u4f4d\u7f6e\u8981\u4e00\u6837\u3002\u5373\uff0c\u5b50\u6a21\u677f1\u53f7\u7684type\u3001dest\u3001price\u3001increment\u90fd\u8981\u6392\u5728\u8fd9\u56db\u4e2a\u53c2\u6570\u7684\u7b2c\u4e00\u4f4d\uff1b\u5b50\u6a21\u677f2\u53f7\u8981\u6392\u5728\u7b2c\u4e8c\u4f4d\u2026\u2026\u4ee5\u6b64\u7c7b\u63a8\uff09"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, session, fields=[]):\n        '''taobao.postages.get \u83b7\u53d6\u5356\u5bb6\u7684\u8fd0\u8d39\u6a21\u677f\n        \n        \u83b7\u5f97\u5f53\u524d\u4f1a\u8bdd\u7528\u6237\u7684\u6240\u6709\u90ae\u8d39\u6a21\u677f'''\n        request = TOPRequest('taobao.postages.get')\n        if not fields:\n            postage = Postage()\n            fields = postage.fields\n        request['fields'] = fields\n        self.create(self.execute(request, session))\n        return self.postages", "response": "TAOBAO. postages. get \u83b7\u53d6\u5356\u5bb6\u7684\u8fd0\u8d39\u6a21\u677f\n ArcID \u83b7\u53d6\u5356\u5bb6\u7684\u8fd0\u8d39\u6a21\u677f\n ArcID \u83b7\u53d6\u5356\u5bb6\u7684\u8fd0\u8d39\u6a21\u677f"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove(self, contact_id, session):\n        '''taobao.logistics.address.remove \u5220\u9664\u5356\u5bb6\u5730\u5740\u5e93\n        \n        \u7528\u6b64\u63a5\u53e3\u5220\u9664\u5356\u5bb6\u5730\u5740\u5e93'''\n        request = TOPRequest('taobao.logistics.address.remove')\n        request['contact_id'] = contact_id\n        self.create(self.execute(request, session))\n        return self.address_result", "response": "TAOBAO. logistics. address. remove \u5220\u9664\u5356\u5bb6\u5730\u5740\u5e93 \u7528\u6b64\u63a5\u53e3\u5220\u9664\u5356\u5bb6\u5730\u5740\u5e93 \u7528\u6b64\u63a5\u53e3\u5220\u9664\u5356\u5bb6\u5730\u5740\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send(self, tid, session, feature=None):\n        '''taobao.logistics.dummy.send \u65e0\u9700\u7269\u6d41\uff08\u865a\u62df\uff09\u53d1\u8d27\u5904\u7406\n        \n        \u7528\u6237\u8c03\u7528\u8be5\u63a5\u53e3\u53ef\u5b9e\u73b0\u65e0\u9700\u7269\u6d41\uff08\u865a\u62df\uff09\u53d1\u8d27,\u4f7f\u7528\u8be5\u63a5\u53e3\u53d1\u8d27\uff0c\u4ea4\u6613\u8ba2\u5355\u72b6\u6001\u4f1a\u76f4\u63a5\u53d8\u6210\u5356\u5bb6\u5df2\u53d1\u8d27'''\n        request = TOPRequest('taobao.logistics.dummy.send')\n        request['tid'] = tid\n        if feature!=None: request['feature'] = feature\n        self.create(self.execute(request, session))\n        return self.shipping", "response": "taobao. logistics. dummy. send \u65e0\u9700\u7269\u6d41\uff08\u865a\u62df\uff09\u53d1\u8d27\u5904\u7406\u65e0\u9700\u7269\u6d41\uff09\u53d1\u8d27\u5904\u7406\u65e0\u9700\u7269\u6d41\uff08\u865a\u62df\uff09"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(self, tid, out_sid, company_code, session, sender_id=None, cancel_id=None, feature=None):\n        '''taobao.logistics.offline.send \u81ea\u5df1\u8054\u7cfb\u7269\u6d41\uff08\u7ebf\u4e0b\u7269\u6d41\uff09\u53d1\u8d27\n        \n        \u7528\u6237\u8c03\u7528\u8be5\u63a5\u53e3\u53ef\u5b9e\u73b0\u81ea\u5df1\u8054\u7cfb\u53d1\u8d27\uff08\u7ebf\u4e0b\u7269\u6d41\uff09\uff0c\u4f7f\u7528\u8be5\u63a5\u53e3\u53d1\u8d27\uff0c\u4ea4\u6613\u8ba2\u5355\u72b6\u6001\u4f1a\u76f4\u63a5\u53d8\u6210\u5356\u5bb6\u5df2\u53d1\u8d27\u3002\u4e0d\u652f\u6301\u8d27\u5230\u4ed8\u6b3e\u3001\u5728\u7ebf\u4e0b\u5355\u7c7b\u578b\u7684\u8ba2\u5355\u3002'''\n        request = TOPRequest('taobao.logistics.offline.send')\n        request['tid'] = tid\n        request['out_sid'] = out_sid\n        request['company_code'] = company_code\n        if feature!=None: request['feature'] = feature\n        if sender_id!=None: request['sender_id'] = sender_id\n        if cancel_id!=None: request['cancel_id'] = cancel_id\n        self.create(self.execute(request, session))\n        return self.shipping", "response": "Send a company code to a session."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cancel(self, tid, session):\n        '''taobao.logistics.online.cancel \u53d6\u6d88\u7269\u6d41\u8ba2\u5355\u63a5\u53e3\n        \n        \u8c03\u6b64\u63a5\u53e3\u53d6\u6d88\u53d1\u8d27\u7684\u8ba2\u5355\uff0c\u91cd\u65b0\u9009\u62e9\u7269\u6d41\u516c\u53f8\u53d1\u8d27\u3002\u524d\u63d0\u662f\u7269\u6d41\u516c\u53f8\u672a\u63fd\u6536\u8d27\u7269\u3002\u5bf9\u672a\u53d1\u8d27\u548c\u5df2\u7ecf\u88ab\u7269\u6d41\u516c\u53f8\u63fd\u6536\u7684\u7269\u6d41\u8ba2\u5355\uff0c\u662f\u4e0d\u80fd\u53d6\u6d88\u7684\u3002'''\n        request = TOPRequest('taobao.logistics.online.cancel')\n        request['tid'] = tid\n        self.create(self.execute(request, session), fields = ['is_success','modify_time','recreated_order_id'], models = {'modify_time':TOPDate})\n        return self", "response": "TAOBAO. online. cancel \u53d6\u6d88\u7269\u6d41\u8ba2\u5355"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef confirm(self, tid, out_sid, session):\n        '''taobao.logistics.online.confirm \u786e\u8ba4\u53d1\u8d27\u901a\u77e5\u63a5\u53e3\n        \n        \u786e\u8ba4\u53d1\u8d27\u7684\u76ee\u7684\u662f\u8ba9\u4ea4\u6613\u6d41\u7a0b\u7ee7\u627f\u8d70\u4e0b\u53bb\uff0c\u786e\u8ba4\u53d1\u8d27\u540e\u4ea4\u6613\u72b6\u6001\u4f1a\u7531\u3010\u4e70\u5bb6\u5df2\u4ed8\u6b3e\u3011\u53d8\u4e3a\u3010\u5356\u5bb6\u5df2\u53d1\u8d27\u3011\uff0c\u7136\u540e\u4e70\u5bb6\u624d\u53ef\u4ee5\u786e\u8ba4\u6536\u8d27\uff0c\u8d27\u6b3e\u6253\u5165\u5356\u5bb6\u8d26\u53f7\u3002\u8d27\u5230\u4ed8\u6b3e\u7684\u8ba2\u5355\u9664\u5916'''\n        request = TOPRequest('taobao.logistics.online.confirm')\n        request['tid'] = tid\n        request['out_sid'] = out_sid\n        self.create(self.execute(request, session), fields = ['shipping',], models = {'shipping':Shipping})\n        return self.shipping", "response": "TAOBAO. online. confirm \u786e\u8ba4\u53d1\u8d27\u901a\u77e5\u63a5\u53e3\u6613\u6d41\u7a0b\u7ee7\u627f\u8d70\u4e0b\u53bb"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send(self, tid, company_code, session, **kwargs):\n        '''taobao.logistics.online.send \u5728\u7ebf\u8ba2\u5355\u53d1\u8d27\u5904\u7406\uff08\u652f\u6301\u8d27\u5230\u4ed8\u6b3e\uff09\n        \n        - \u7528\u6237\u8c03\u7528\u8be5\u63a5\u53e3\u53ef\u5b9e\u73b0\u5728\u7ebf\u8ba2\u5355\u53d1\u8d27\uff08\u652f\u6301\u8d27\u5230\u4ed8\u6b3e\uff09 \n        - \u8c03\u7528\u8be5\u63a5\u53e3\u5b9e\u73b0\u5728\u7ebf\u4e0b\u5355\u53d1\u8d27\uff0c\u6709\u4e24\u79cd\u60c5\u51b5\uff1a\n        - \u5982\u679c\u4e0d\u8f93\u5165\u8fd0\u5355\u53f7\u7684\u60c5\u51b5\uff1a\u4ea4\u6613\u72b6\u6001\u4e0d\u4f1a\u6539\u53d8\uff0c\u9700\u8981\u8c03\u7528taobao.logistics.online.confirm\u786e\u8ba4\u53d1\u8d27\u540e\u4ea4\u6613\u72b6\u6001\u624d\u4f1a\u53d8\u6210\u5356\u5bb6\u5df2\u53d1\u8d27\u3002\n        - \u5982\u679c\u8f93\u5165\u8fd0\u5355\u53f7\u7684\u60c5\u51b5\u53d1\u8d27\uff1a\u4ea4\u6613\u8ba2\u5355\u72b6\u6001\u4f1a\u76f4\u63a5\u53d8\u6210\u5356\u5bb6\u5df2\u53d1\u8d27 \u3002'''\n        request = TOPRequest('taobao.logistics.online.send')\n        request['tid'] = tid\n        request['company_code'] = company_code\n        for k, v in kwargs.iteritems():\n            if k not in ('out_sid', 'sender_id', 'cancel_id', 'feature') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session), fields=['shipping', ], models={'shipping':Shipping})\n        return self.shipping", "response": "Send a message to a specific company."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef detail_get(self, session, fields=[], **kwargs):\n        '''taobao.logistics.orders.detail.get \u6279\u91cf\u67e5\u8be2\u7269\u6d41\u8ba2\u5355,\u8fd4\u56de\u8be6\u7ec6\u4fe1\u606f\n        \n        \u67e5\u8be2\u7269\u6d41\u8ba2\u5355\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u6d89\u53ca\u7528\u6237\u9690\u79c1\u5b57\u6bb5\u3002\uff08\u6ce8\uff1a\u8be5API\u4e3b\u8981\u662f\u63d0\u4f9b\u7ed9\u5356\u5bb6\u67e5\u8be2\u7269\u6d41\u8ba2\u5355\u4f7f\u7528\uff0c\u4e70\u5bb6\u67e5\u8be2\u7269\u6d41\u8ba2\u5355\uff0c\u5efa\u8bae\u4f7f\u7528taobao.logistics.trace.search\uff09'''\n        request = TOPRequest('taobao.logistics.orders.detail.get')\n        if not fields:\n            shipping = Shipping()\n            fields = shipping.fields\n        request['fields'] = fields\n        for k, v in kwargs.iteritems():\n            if k not in ('tid', 'buyer_nick', 'status', 'seller_confirm', 'receiver_name', 'start_created', 'end_created', 'freight_payer', 'type', 'page_no', 'page_size') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session))\n        return self.shippings", "response": "TAOBAO. logistics. detail. get \u6279\u91cf\u67e5\u8be2\u7269\u6d41\u8ba2\u5355 \u8fd4\u56de\u8be6\u7ec6\u4fe1\u606f\uff0c \u6ce8\uff1a API \u4e3b\u8981\u662f API\u4e3b\u8981\u662f API\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef search(self, tid, seller_nick):\n        '''taobao.logistics.trace.search \u7269\u6d41\u6d41\u8f6c\u4fe1\u606f\u67e5\u8be2\n        \n        \u7528\u6237\u6839\u636e\u6dd8\u5b9d\u4ea4\u6613\u53f7\u67e5\u8be2\u7269\u6d41\u6d41\u8f6c\u4fe1\u606f\uff0c\u59822010-8-10 15\uff1a23\uff1a00\u5230\u8fbe\u676d\u5dde\u96c6\u6563\u5730'''\n        request = TOPRequest('taobao.logistics.address.add')\n        request['tid'] = tid\n        request['seller_nick'] = seller_nick\n        self.create(self.execute(request))\n        return self", "response": "TAOBAO. logistics. trace. search \u7269\u6d41\u6d41\u8f6c\u4fe1\u606f\uff0c\u59822010 - 8 - 10 15 : 23 : 00 \u5230\u8fbe\u676d\u5dde\u96c6\u6563\u5730"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send(self, tids, session, **kwargs):\n        '''taobao.topats.delivery.send \u5f02\u6b65\u6279\u91cf\u7269\u6d41\u53d1\u8d27api\n        \n        \u4f7f\u7528\u6307\u5357\uff1ahttp://open.taobao.com/dev/index.php/ATS%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97 \n        \n        - 1.\u63d0\u4f9b\u5f02\u6b65\u6279\u91cf\u7269\u6d41\u53d1\u8d27\u529f\u80fd \n        - 2.\u4e00\u6b21\u6700\u591a\u53d1\u8d2740\u4e2a\u8ba2\u5355 \n        - 3.\u63d0\u4ea4\u4efb\u52a1\u4f1a\u8fdb\u884c\u521d\u6b65\u4efb\u52a1\u6821\u9a8c\uff0c\u5982\u679c\u6210\u529f\u4f1a\u8fd4\u56de\u4efb\u52a1\u53f7\u548c\u521b\u5efa\u65f6\u95f4\uff0c\u5982\u679c\u5931\u8d25\u5c31\u62a5\u9519 \n        - 4.\u53ef\u4ee5\u63a5\u6536\u6dd8\u5b9d\u53d1\u51fa\u7684\u4efb\u52a1\u5b8c\u6210\u6d88\u606f\uff0c\u4e5f\u53ef\u4ee5\u8fc7\u4e00\u6bb5\u65f6\u95f4\u6765\u53d6\u7ed3\u679c\u3002\u83b7\u53d6\u7ed3\u679c\u63a5\u53e3\u4e3ataobao.topats.result.get \n        - 5.\u6b64api\u6267\u884c\u5b8c\u6210\u53d1\u9001\u7684\u901a\u77e5\u6d88\u606f\u683c\u5f0f\u4e3a{\"task\":{\"task_id\":123456,\"created\":\"2010-8-19\"}}'''\n        request = TOPRequest('taobao.postage.add')\n        request['tids'] = tids\n        for k, v in kwargs.iteritems():\n            if k not in ('company_codes', 'out_sids', 'seller_name', 'seller_area_id', 'seller_address', 'seller_zip', 'seller_phone', 'seller_mobile', 'order_types', 'memos') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session))\n        return self.task", "response": "send a message to a Todoist API"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all items from the registry if key is None then try to fetch the registry key", "response": "def get(context, request, key=None):\n    \"\"\"Return all registry items if key is None, otherwise try to fetch the registry key\n    \"\"\"\n    registry_records = api.get_registry_records_by_keyword(key)\n\n    # Prepare batch\n    size = req.get_batch_size()\n    start = req.get_batch_start()\n    batch = api.make_batch(registry_records, size, start)\n\n    return {\n        \"pagesize\": batch.get_pagesize(),\n        \"next\": batch.make_next_url(),\n        \"previous\": batch.make_prev_url(),\n        \"page\": batch.get_pagenumber(),\n        \"pages\": batch.get_numpages(),\n        \"count\": batch.get_sequence_length(),\n        \"items\": [registry_records],\n        \"url\": api.url_for(\"senaite.jsonapi.v1.registry\", key=key),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef merge_kwargs(local_kwarg, default_kwarg):\n\n    if default_kwarg is None:\n        return local_kwarg\n\n    if isinstance(local_kwarg, basestring):\n        return local_kwarg\n\n    if local_kwarg is None:\n        return default_kwarg\n\n    # Bypass if not a dictionary (e.g. timeout)\n    if not hasattr(default_kwarg, 'items'):\n        return local_kwarg\n\n    # Update new values.\n    kwargs = default_kwarg.copy()\n    kwargs.update(local_kwarg)\n\n    # Remove keys that are set to None.\n    for (k,v) in local_kwarg.items():\n        if v is None:\n            del kwargs[k]\n\n    return kwargs", "response": "Merges kwarg dictionaries.\n\n    If a local key in the dictionary is set to None, it will be removed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs and sends a new HTTP request.", "response": "def request(self, method, url,\n        params=None,\n        data=None,\n        headers=None,\n        cookies=None,\n        files=None,\n        auth=None,\n        timeout=None,\n        allow_redirects=False,\n        proxies=None,\n        hooks=None,\n        return_response=True,\n        config=None,\n        prefetch=False):\n\n        \"\"\"Constructs and sends a :class:`Request <Request>`.\n        Returns :class:`Response <Response>` object.\n\n        :param method: method for the new :class:`Request` object.\n        :param url: URL for the new :class:`Request` object.\n        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.\n        :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.\n        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.\n        :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.\n        :param auth: (optional) Auth typle to enable Basic/Digest/Custom HTTP Auth.\n        :param timeout: (optional) Float describing the timeout of the request.\n        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.\n        :param return_response: (optional) If False, an un-sent Request object will returned.\n        :param config: (optional) A configuration dictionary.\n        :param prefetch: (optional) if ``True``, the response content will be immediately downloaded.\n        \"\"\"\n\n        method = str(method).upper()\n\n        # Default empty dicts for dict params.\n        cookies = {} if cookies is None else cookies\n        data = {} if data is None else data\n        files = {} if files is None else files\n        headers = {} if headers is None else headers\n        params = {} if params is None else params\n\n        # Expand header values.\n        if headers:\n            for k, v in headers.items() or {}:\n                headers[k] = header_expand(v)\n\n        args = dict(\n            method=method,\n            url=url,\n            data=data,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            files=files,\n            auth=auth,\n            hooks=hooks,\n            timeout=timeout,\n            allow_redirects=allow_redirects,\n            proxies=proxies,\n            config=config,\n            _poolmanager=self.poolmanager\n        )\n\n        # Merge local kwargs with session kwargs.\n        for attr in self.__attrs__:\n            session_val = getattr(self, attr, None)\n            local_val = args.get(attr)\n\n            args[attr] = merge_kwargs(local_val, session_val)\n\n        # Arguments manipulation hook.\n        args = dispatch_hook('args', args['hooks'], args)\n\n        # Create the (empty) response.\n        r = Request(**args)\n\n        # Give the response some context.\n        r.session = self\n\n        # Don't send if asked nicely.\n        if not return_response:\n            return r\n\n        # Send the HTTP Request.\n        r.send(prefetch=prefetch)\n\n        # Send any cookies back up the to the session.\n        self.cookies.update(r.response.cookies)\n\n        # Return the response.\n        return r.response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef head(self, url, **kwargs):\n\n        kwargs.setdefault('allow_redirects', True)\n        return self.request('head', url, **kwargs)", "response": "Sends a HEAD request. Returns a new Response object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a POST request. Returns a new Response object.", "response": "def post(self, url, data=None, **kwargs):\n        \"\"\"Sends a POST request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n        :param **kwargs: Optional arguments that ``request`` takes.\n        \"\"\"\n\n        return self.request('post', url, data=data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends a PUT request. Returns a new Response object.", "response": "def put(self, url, data=None, **kwargs):\n        \"\"\"Sends a PUT request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.\n        :param **kwargs: Optional arguments that ``request`` takes.\n        \"\"\"\n\n        return self.request('put', url, data=data, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef patch(self, url, data=None, **kwargs):\n\n        return self.request('patch', url,  data=data, **kwargs)", "response": "Sends a PATCH request. Returns a new Response object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning the complete simulation", "response": "def run_simulation(self):\n        \"\"\"Runs the complete simulation\"\"\"\n        print('Starting simulations...')\n        for i in range(self.num_trials):\n            print('---Trial {}---'.format(i))\n            self.run_trial(i)\n        print('Simulation completed.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_trial(self, trial_id=0):\n        # Set-up trial environment and graph\n        self.env = NetworkEnvironment(self.G.copy(), initial_time=0, **self.environment_params)\n        # self.G = self.initial_topology.copy()\n        # self.trial_params = deepcopy(self.global_params)\n\n        # Set up agents on nodes\n        print('Setting up agents...')\n        self.setup_network_agents()\n\n        # Set up environmental agent\n        if self.environment_agent_type:\n            env_agent = self.environment_agent_type(environment=self.env)\n\n        # Set up logging\n        logging_interval = self.logging_interval\n        logger = BaseLoggingAgent(environment=self.env, dir_path=self.dir_path, logging_interval=logging_interval)\n\n        # Run trial\n        self.env.run(until=self.until)\n\n        # Save output as pickled objects\n        logger.save_trial_state_history(trial_id=trial_id)", "response": "Run a single trial of the simulation."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes agents on nodes of graph and registers them to the SimPy environment", "response": "def setup_network_agents(self):\n        \"\"\"Initializes agents on nodes of graph and registers them to the SimPy environment\"\"\"\n        for i in self.env.G.nodes():\n            self.env.G.node[i]['agent'] = self.agent_type(environment=self.env, agent_id=i,\n                                                          state=deepcopy(self.initial_states[i]))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef maxchord(A, ve = None):\n\n    n = A.size[0]\n    assert A.size[1] == n, \"A must be a square matrix\"\n    assert type(A) is spmatrix, \"A must be a sparse matrix\"\n    if ve is None:\n        ve = n-1\n    else:\n        assert type(ve) is int and 0<=ve<n,\\\n          \"ve must be an integer between 0 and A.size[0]-1\"\n    As = symmetrize(A)\n    cp,ri,val = As.CCS\n\n    # permutation vector\n    p = matrix(0,(n,1))\n\n    # weight array\n    w = matrix(0,(n,1))\n    max_w = 0\n    S = [list(range(ve))+list(range(ve+1,n))+[ve]] + [[] for i in range(n-1)]\n\n    C = [set() for i in range(n)]\n    E = [[] for i in range(n)]     # edge list\n    V = [[] for i in range(n)]     # num. values\n\n    for i in range(n-1,-1,-1):\n        # select next node to number\n        while True:\n            if len(S[max_w]) > 0:\n                v = S[max_w].pop()\n                if w[v] >= 0: break\n            else:\n                max_w -= 1\n        p[i] = v\n        w[v] = -1   # set w[v] = -1 to mark that node v has been numbered\n\n        # loop over unnumbered neighbors of node v\n        for ii in range(cp[v],cp[v+1]):\n            u = ri[ii]\n            d = val[ii]\n            if w[u] >= 0:\n                if C[u].issubset(C[v]):\n                    C[u].update([v])\n                    w[u] += 1\n                    S[w[u]].append(u)    # bump up u to S[w[u]]\n                    max_w = max(max_w,w[u])  # update max deg.\n                    E[min(u,v)].append(max(u,v))\n                    V[min(u,v)].append(d)\n            elif u == v:\n                E[u].append(u)\n                V[u].append(d)\n\n    # build adjacency matrix of reordered max. chordal subgraph\n    Am = spmatrix([d for d in chain.from_iterable(V)],[i for i in chain.from_iterable(E)],\\\n                  [i for i in chain.from_iterable([len(Ej)*[j] for j,Ej in enumerate(E)])],(n,n))\n\n    return Am,p", "response": "Returns a lower triangular sparse matrix which is the projection of A on a maximal chordal subgraph and a perfect\n    eliminated by the given vertex."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new route to the senaite API.", "response": "def add_route(route, endpoint=None, **kw):\n    \"\"\"Add a new JSON API route\n    \"\"\"\n\n    # ensure correct amout of slashes\n    def apiurl(route):\n        return '/'.join(s.strip('/') for s in [\"\", BASE_URL, route])\n\n    return add_senaite_route(apiurl(route), endpoint, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting cfdi v3. 2 for Mexico.", "response": "def cfdv32mx(config):\n    \"\"\"Format cfdi v3.2 for Mexico.\n\n    \\b\n    File where the files will be written document.xml.\n        cfdicli --in_file /path/to/yout/json/documnt.json cfdv32mx\n\n    \\b\n    File where the files will be written from document.json.\n        cfdicli --out_file ./document.xml cfdv32mx\n    \"\"\"\n    # TODO: look for a secure option for eval.\n    #       Or simply the CLI only should manage json?\n    # TODO: Implement json option also.\n    dict_input = eval(config.in_file.read())\n    invoice = cfdv32.get_invoice(dict_input)\n    if invoice.valid:\n        config.out_file.write(invoice.document)\n        config.out_file.flush()\n        click.echo('Document %s has been created.' % config.out_file.name)\n    else:\n        click.echo(invoice.ups.message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake cache key from prefix Borrowed from Flask - Cache extension", "response": "def _make_cache_key(key_prefix):\n    \"\"\"Make cache key from prefix\n    Borrowed from Flask-Cache extension\n    \"\"\"\n    if callable(key_prefix):\n        cache_key = key_prefix()\n    elif '%s' in key_prefix:\n        cache_key = key_prefix % request.path\n    else:\n        cache_key = key_prefix\n\n    cache_key = cache_key.encode('utf-8')\n\n    return cache_key"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_frame(self, in_data, frame_count, time_info, status):\n\t\twhile self.keep_listening:\n\t\t\ttry:\n\t\t\t\tframe = self.queue.get(False, timeout=queue_timeout)\n\t\t\t\treturn (frame, pyaudio.paContinue)\n\t\t\texcept Empty:\n\t\t\t\tpass\n\t\treturn (None, pyaudio.paComplete)", "response": "Callback function for the pyaudio stream. Don t use directly."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef close_stream(self):\n\t\tself.keep_listening = False\n\t\tself.stream.stop_stream()\n\t\tself.stream.close()\n\t\tself.pa.terminate()", "response": "Closes the stream. Performs cleanup."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, tid, result, role, session, oid=None, content=None, anony=None):\n        '''taobao.traderate.add \u65b0\u589e\u5355\u4e2a\u8bc4\u4ef7\n        \n        \u65b0\u589e\u5355\u4e2a\u8bc4\u4ef7(\u6ce8\uff1a\u5728\u8bc4\u4ef7\u4e4b\u524d\u9700\u8981\u5bf9\u8ba2\u5355\u6210\u529f\u7684\u65f6\u95f4\u8fdb\u884c\u5224\u5b9a\uff08end_time\uff09,\u5982\u679c\u8d85\u8fc715\u5929\uff0c\u4e0d\u80fd\u518d\u901a\u8fc7\u8be5\u63a5\u53e3\u8fdb\u884c\u8bc4\u4ef7)'''\n        request = TOPRequest('taobao.traderate.add')\n        request['tid'] = tid\n        request['result'] = result\n        request['role'] = role\n        if oid!=None: request['oid'] = oid\n        if content!=None: request['content'] = content\n        if anony!=None: request['anony'] = anony\n        self.create(self.execute(request, session)['trade_rate'])\n        return self", "response": "TAOBAO. traaderate. add \u65b0\u589e\u5355\u4e2a\u8bc4\u4ef7 ( \u5728\u8bc4\u4ef7\u4e4b\u524d\u9700\u8981\u5728\u8bc4\u4ef7\u4e4b\u524d\u9700\u8981\u5728\u8bc4\u4ef7\u4e4b\u524d\u9700\u8981\u5728\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, rate_type, role, session, fields=[], **kwargs):\n        '''taobao.traderates.get \u641c\u7d22\u8bc4\u4ef7\u4fe1\u606f\n        \n        \u641c\u7d22\u8bc4\u4ef7\u4fe1\u606f\uff0c\u53ea\u80fd\u83b7\u53d6\u8ddd\u4eca180\u5929\u5185\u7684\u8bc4\u4ef7\u8bb0\u5f55'''\n        request = TOPRequest('taobao.traderates.get')\n        request['rate_type'] = rate_type\n        request['role'] = role\n        if not fields:\n            tradeRate = TradeRate()\n            fields = tradeRate.fields\n        request['fields'] = fields\n        for k, v in kwargs.iteritems():\n            if k not in ('result', 'page_no', 'page_size', 'start_date', 'end_date', 'tid') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request, session))\n        return self.trade_rates", "response": "TAOBAO. tradeates. get \u641c\u7d22\u8bc4\u4ef7\u4fe1\u606f\uff0ctaobao. trades. get \u641c\u7d22\u8bc4\u4ef7\u4fe1\u606f\uff0c\u53ea\u80fd\u83b7\u53d6\u8ddd\u4eca180\u5929\u5185\u7684\u8bc4\u4ef7\u8bb0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, cid, pvs=None, fields=[]):\n        '''taobao.itempropvalues.get \u83b7\u53d6\u6807\u51c6\u7c7b\u76ee\u5c5e\u6027\u503c\n        \n        \u4f20\u5165\u7c7b\u76eeID,\u5fc5\u9700\u662f\u53f6\u5b50\u7c7b\u76ee\uff0c\u901a\u8fc7taobao.itemcats.get\u83b7\u53d6\u7c7b\u76eeID \u8fd4\u56de\u5b57\u6bb5\u76ee\u524d\u652f\u6301\u6709\uff1acid,pid,prop_name,vid,name,name_alias,status,sort_order \u4f5c\u7528:\u83b7\u53d6\u6807\u51c6\u7c7b\u76ee\u5c5e\u6027\u503c'''\n        request = TOPRequest('taobao.itempropvalues.get')\n        if not fields:\n            propValue = PropValue()\n            fields = propValue.fields\n        request['fields'] = fields\n        if pvs!=None:\n            request['pvs'] = pvs\n        request['cid'] = cid\n        self.create(self.execute(request))\n        return self.prop_values", "response": "TAOBAO. itempropvalues. get \u83b7\u53d6\u7c7b\u76eeID"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsorting a list of dictionaries by dictionary key", "response": "def sort_dict(self, data, key):\n    '''Sort a list of dictionaries by dictionary key'''\n    return sorted(data, key=itemgetter(key)) if data else []"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef chatpeers_get(self, from_id, to_id, start_date, end_date, session):\n        '''taobao.wangwang.eservice.chatpeers.get \u83b7\u53d6\u804a\u5929\u5bf9\u8c61\u5217\u8868\uff0c\u67e5\u8be2\u65f6\u95f4\u6bb5<=7\u5929,\u53ea\u652f\u6301xml\u8fd4\u56de'''\n        request = TOPRequest('taobao.wangwang.eservice.chatpeers.get')\n        request['from_id'] = from_id\n        request['to_id'] = to_id\n        request['start_date'] = start_date\n        request['end_date'] = end_date\n        self.create(self.execute(request, session))\n        return self.msgs", "response": "TAOBAO. wangwang. eservice. chatpeers. get \u83b7\u53d6\u804a\u5929\u5bf9\u8c61\u5217\u8868\uff0c\u67e5\u8be2\u65f6\u95f4\u6bb5 < = 7\u5929"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef chatrecord_get(self, service_staff_id, start_date, end_date, session):\n        '''taobao.wangwang.eservice.chatrecord.get \u804a\u5929\u8bb0\u5f55\u67e5\u8be2\n        \n        \u8be5\u63a5\u53e3\u4f1a\u8fd4\u56de\u4e00\u4e2a\u804a\u5929\u8bb0\u5f55\u7684\u4e0b\u8f7d\u5730\u5740\u3002 \u8bf7\u4e8e5\u5206\u949f\u4ee5\u540e\u4f7f\u7528\u8be5\u94fe\u63a5\u4e0b\u8f7d(\u56e0\u4e3a\u6587\u4ef6\u5927\u5c0f\u7684\u4e0d\u540c\uff0c\u751f\u6210\u65e5\u5fd7\u7684\u65f6\u95f4\u4f1a\u5ef6\u957f\u523050\u5206\u949f),\u8be5\u94fe\u63a5\u6709\u5982\u4e0b\u9650\u5236\uff1a \n        \n        - 1.\u8be5\u94fe\u63a5\u7684\u6709\u6548\u671f\u4e3a3\u4e2a\u5c0f\u65f6\uff0c\u903e\u671f\u4f5c\u5e9f\u3002 \n        - 2.\u540c\u4e00\u94fe\u63a5\u53ea\u80fd\u4f7f\u7528\u4e00\u6b21\u3002\n        \n        \u7528\u6237\u70b9\u51fb\u5730\u5740\uff0c\u4e0b\u8f7d\u804a\u5929\u8bb0\u5f55\u538b\u7f29\u5305\uff08\u538b\u7f29\u5305\u4e2d\u542b\u67091\u4e2a\u6587\u4ef6\u6216\u591a\u4e2a\u6587\u4ef6\uff0c\u67e5\u8be2\u4e86\u51e0\u4e2a\u7528\u6237\u7684\u804a\u5929\u8bb0\u5f55\uff0c\u5c31\u542b\u6709\u51e0\u4e2a\u6587\u672c\u6587\u4ef6\uff09\u3002 \u5907\u6ce8\uff1a\n         \n        - 1\u3001\u5982\u679c\u662f\u64cd\u4f5c\u8005ID=\u88ab\u67e5\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u7684\"\u804a\u5929\u8bb0\u5f55\"\u3002 \n        - 2\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u7ec4\u7ba1\u7406\u5458\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u4ed6\u7684\u7ec4\u4e2d\u7684\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u804a\u5929\u8bb0\u5f55\"\u3002 \n        - 3\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u4e3b\u8d26\u6237\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u804a\u5929\u8bb0\u5f55\"\u3002 \n        - 4\u3001\u88ab\u67e5\u8005ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\uff0cid\u6570\u4e0d\u80fd\u8d85\u8fc730\u3002 \n        - 5\u3001\u5f00\u59cb\u65f6\u95f4\u4e0e\u7ed3\u675f\u65f6\u95f4\u4e4b\u95f4\u7684\u95f4\u9694\u4e0d\u80fd\u8d85\u8fc77\u5929 \n        - 6\u3001\u4e0d\u80fd\u67e5\u8be230\u5929\u4ee5\u524d\u7684\u8bb0\u5f55 \n        - 7\u3001\u4e0d\u80fd\u67e5\u8be2\u5f53\u5929\u7684\u6570\u636e'''\n        request = TOPRequest('taobao.wangwang.eservice.chatrecord.get')\n        request['service_staff_id'] = service_staff_id\n        request['start_date'] = start_date\n        request['end_date'] = end_date\n        self.create(self.execute(request, session))\n        return self.log_file_url", "response": "taobao.wangwang.eservice.chatrecord.get \u804a\u5929\u8bb0\u5f55\u67e5\u8be2\n        \n        \u8be5\u63a5\u53e3\u4f1a\u8fd4\u56de\u4e00\u4e2a\u804a\u5929\u8bb0\u5f55\u7684\u4e0b\u8f7d\u5730\u5740\u3002 \u8bf7\u4e8e5\u5206\u949f\u4ee5\u540e\u4f7f\u7528\u8be5\u94fe\u63a5\u4e0b\u8f7d(\u56e0\u4e3a\u6587\u4ef6\u5927\u5c0f\u7684\u4e0d\u540c\uff0c\u751f\u6210\u65e5\u5fd7\u7684\u65f6\u95f4\u4f1a\u5ef6\u957f\u523050\u5206\u949f),\u8be5\u94fe\u63a5\u6709\u5982\u4e0b\u9650\u5236\uff1a \n        \n        - 1.\u8be5\u94fe\u63a5\u7684\u6709\u6548\u671f\u4e3a3\u4e2a\u5c0f\u65f6\uff0c\u903e\u671f\u4f5c\u5e9f\u3002 \n        - 2.\u540c\u4e00\u94fe\u63a5\u53ea\u80fd\u4f7f\u7528\u4e00\u6b21\u3002\n        \n        \u7528\u6237\u70b9\u51fb\u5730\u5740\uff0c\u4e0b\u8f7d\u804a\u5929\u8bb0\u5f55\u538b\u7f29\u5305\uff08\u538b\u7f29\u5305\u4e2d\u542b\u67091\u4e2a\u6587\u4ef6\u6216\u591a\u4e2a\u6587\u4ef6\uff0c\u67e5\u8be2\u4e86\u51e0\u4e2a\u7528\u6237\u7684\u804a\u5929\u8bb0\u5f55\uff0c\u5c31\u542b\u6709\u51e0\u4e2a\u6587\u672c\u6587\u4ef6\uff09\u3002 \u5907\u6ce8\uff1a\n         \n        - 1\u3001\u5982\u679c\u662f\u64cd\u4f5c\u8005ID=\u88ab\u67e5\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u7684\"\u804a\u5929\u8bb0\u5f55\"\u3002 \n        - 2\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u7ec4\u7ba1\u7406\u5458\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u4ed6\u7684\u7ec4\u4e2d\u7684\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u804a\u5929\u8bb0\u5f55\"\u3002 \n        - 3\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u4e3b\u8d26\u6237\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u804a\u5929\u8bb0\u5f55\"\u3002 \n        - 4\u3001\u88ab\u67e5\u8005ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\uff0cid\u6570\u4e0d\u80fd\u8d85\u8fc730\u3002 \n        - 5\u3001\u5f00\u59cb\u65f6\u95f4\u4e0e\u7ed3\u675f\u65f6\u95f4\u4e4b\u95f4\u7684\u95f4\u9694\u4e0d\u80fd\u8d85\u8fc77\u5929 \n        - 6\u3001\u4e0d\u80fd\u67e5\u8be230\u5929\u4ee5\u524d\u7684\u8bb0\u5f55 \n        - 7\u3001\u4e0d\u80fd\u67e5\u8be2\u5f53\u5929\u7684\u6570\u636e"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef evaluation_get(self, service_staff_id, start_date, end_date, session):\n        '''taobao.wangwang.eservice.evaluation.get \u5ba2\u670d\u8bc4\u4ef7\u7edf\u8ba1\n        \n        \u6839\u636e\u64cd\u4f5c\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u6307\u5b9a\u65e5\u671f\u5185\u6bcf\u4e2a\u5e10\u53f7\u6bcf\u65e5\u7684\"\u5ba2\u670d\u8bc4\u4ef7\u7edf\u8ba1\" \u5907\u6ce8\uff1a\n        \n        - 1\u3001\u5982\u679c\u662f\u64cd\u4f5c\u8005ID=\u88ab\u67e5\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u7684\"\u5ba2\u670d\u8bc4\u4ef7\u7edf\u8ba1\"\u3002 \n        - 2\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u7ec4\u7ba1\u7406\u5458\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u4ed6\u7684\u7ec4\u4e2d\u7684\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u5ba2\u670d\u8bc4\u4ef7\u7edf\u8ba1\"\u3002 \n        - 3\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u4e3b\u8d26\u6237\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u5ba2\u670d\u8bc4\u4ef7\u7edf\u8ba1\"\u3002 \n        - 4\u3001\u88ab\u67e5\u8005ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\uff0cid\u6570\u4e0d\u80fd\u8d85\u8fc730\u3002 \n        - 5\u3001\u5f00\u59cb\u65f6\u95f4\u4e0e\u7ed3\u675f\u65f6\u95f4\u4e4b\u95f4\u7684\u95f4\u9694\u4e0d\u80fd\u8d85\u8fc77\u5929 \n        - 6\u3001\u4e0d\u80fd\u67e5\u8be290\u5929\u4ee5\u524d\u7684\u6570\u636e \n        - 7\u3001\u4e0d\u80fd\u67e5\u8be2\u5f53\u5929\u7684\u8bb0\u5f55'''\n        request = TOPRequest('taobao.wangwang.eservice.evaluation.get')\n        request['service_staff_id'] = service_staff_id\n        request['start_date'] = start_date\n        request['end_date'] = end_date\n        self.create(self.execute(request, session))\n        return self.staff_eval_stat_on_days", "response": "TAOBAO evaluation. get \u53ef\u4ee5\u67e5\u8be2\u64cd\u4f5c\u8005ID start_date end_date session \u53ef\u4ee5\u67e5\u8be2\u64cd\u4f5c\u8005ID"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef groupmember_get(self, manager_id, session):\n        '''taobao.wangwang.eservice.groupmember.get \u83b7\u53d6\u7ec4\u6210\u5458\u5217\u8868\n        \n        \u7528\u67d0\u4e2a\u7ec4\u7ba1\u7406\u5458\u8d26\u53f7\u67e5\u8be2\uff0c\u8fd4\u56de\u8be5\u7ec4\u7ec4\u540d\u3001\u548c\u8be5\u7ec4\u6240\u6709\u7ec4\u6210\u5458ID\uff08E\u5ba2\u670d\u7684\u5206\u6d41\u8bbe\u7f6e\uff09\u3002 \u7528\u65fa\u65fa\u4e3b\u5e10\u53f7\u67e5\u8be2\uff0c\u8fd4\u56de\u6240\u6709\u7ec4\u7684\u7ec4\u540d\u548c\u8be5\u7ec4\u6240\u6709\u7ec4\u6210\u5458ID\u3002 \u8fd4\u56de\u7684\u7ec4\u6210\u5458ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\u3002 \u88ab\u67e5\u8005ID\u53ea\u80fd\u4f20\u5165\u4e00\u4e2a\u3002 \u7ec4\u6210\u5458\u4e2d\u6392\u540d\u6700\u9760\u524d\u7684ID\u662f\u7ec4\u7ba1\u7406\u5458ID'''\n        request = TOPRequest('taobao.wangwang.eservice.groupmember.get')\n        request['manager_id'] = manager_id\n        self.create(self.execute(request, session))\n        return self.group_member_list", "response": "TAOBAO. wangwang. eservice. groupmember. get \u83b7\u53d6\u7ec4\u6210\u5458ID"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loginlogs_get(self, service_staff_id, start_date, end_date, session):\n        '''taobao.wangwang.eservice.loginlogs.get \u83b7\u53d6\u767b\u5f55\u65e5\u5fd7\n        \n        \u901a\u8fc7\u7528\u6237id\u67e5\u8be2\u7528\u6237\u81ea\u5df1\u6216\u8005\u5b50\u8d26\u6237\u7684\u767b\u5f55\u65e5\u5fd7\uff1a \u4e3b\u8d26\u53f7\u53ef\u4ee5\u67e5\u8be2\u81ea\u5df1\u548c\u5e97\u94fa\u5b50\u8d26\u6237\u7684\u767b\u5f55\u65e5\u5fd7 \u7ec4\u7ba1\u7406\u5458\u53ef\u4ee5\u67e5\u8be2\u81ea\u5df1\u548c\u7ec4\u5185\u5b50\u8d26\u53f7\u7684\u767b\u5f55\u65e5\u5fd7 \u975e\u7ec4\u7ba1\u7406\u5458\u7684\u5b50\u8d26\u6237\u53ea\u80fd\u67e5\u8be2\u81ea\u5df1\u7684\u767b\u5f55\u65e5\u5fd7'''\n        request = TOPRequest('taobao.wangwang.eservice.loginlogs.get')\n        request['service_staff_id'] = service_staff_id\n        request['start_date'] = start_date\n        request['end_date'] = end_date\n        self.create(self.execute(request, session))\n        return self.loginlogs", "response": "TAOBAO. wangwang. eservice. loginlogs. get \u83b7\u53d6\u767b\u5f55\u65e5\u5fd7\u81ea\u5df1\u7684\u767b\u5f55\u65e5\u5fd7"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef noreplynum_get(self, service_staff_id, start_date, end_date, session):\n        '''taobao.wangwang.eservice.noreplynum.get \u5ba2\u670d\u672a\u56de\u590d\u4eba\u6570\n        \n        \u6839\u636e\u64cd\u4f5c\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u6307\u5b9a\u65e5\u671f\u5185\u6bcf\u4e2a\u5e10\u53f7\u6bcf\u65e5\u7684\"\u672a\u56de\u590d\u60c5\u51b5\" \u5907\u6ce8\uff1a\n        \n        - 1\u3001\u5982\u679c\u662f\u64cd\u4f5c\u8005ID=\u88ab\u67e5\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u7684\"\u672a\u56de\u590d\u60c5\u51b5\"\uff08\u672a\u56de\u590d\u4eba\u6570\u3001\u672a\u56de\u590d\u7684ID\uff09\u3002 \n        - 2\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u7ec4\u7ba1\u7406\u5458\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u4ed6\u7684\u7ec4\u4e2d\u7684\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u672a\u56de\u590d\u60c5\u51b5\"\u3002 \n        - 3\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u4e3b\u8d26\u6237\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u672a\u56de\u590d\u60c5\u51b5\"\u3002 \n        - 4\u3001\u88ab\u67e5\u8005ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\uff0cid\u6570\u4e0d\u80fd\u8d85\u8fc730\u3002 \n        - 5\u3001\u5f00\u59cb\u65f6\u95f4\u4e0e\u7ed3\u675f\u65f6\u95f4\u4e4b\u95f4\u7684\u95f4\u9694\u4e0d\u80fd\u8d85\u8fc77\u5929 \n        - 6\u3001\u4e0d\u80fd\u67e5\u8be290\u5929\u4ee5\u524d\u7684\u6570\u636e \n        - 7\u3001\u4e0d\u80fd\u67e5\u8be2\u5f53\u5929\u7684\u8bb0\u5f55'''\n        request = TOPRequest('taobao.wangwang.eservice.noreplynum.get')\n        request['service_staff_id'] = service_staff_id\n        request['start_date'] = start_date\n        request['end_date'] = end_date\n        self.create(self.execute(request, session))\n        return self.non_reply_stat_on_days", "response": "taobao.wangwang.eservice.noreplynum.get \u5ba2\u670d\u672a\u56de\u590d\u4eba\u6570\n        \n        \u6839\u636e\u64cd\u4f5c\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u6307\u5b9a\u65e5\u671f\u5185\u6bcf\u4e2a\u5e10\u53f7\u6bcf\u65e5\u7684\"\u672a\u56de\u590d\u60c5\u51b5\" \u5907\u6ce8\uff1a\n        \n        - 1\u3001\u5982\u679c\u662f\u64cd\u4f5c\u8005ID=\u88ab\u67e5\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u7684\"\u672a\u56de\u590d\u60c5\u51b5\"\uff08\u672a\u56de\u590d\u4eba\u6570\u3001\u672a\u56de\u590d\u7684ID\uff09\u3002 \n        - 2\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u7ec4\u7ba1\u7406\u5458\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u4ed6\u7684\u7ec4\u4e2d\u7684\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u672a\u56de\u590d\u60c5\u51b5\"\u3002 \n        - 3\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u4e3b\u8d26\u6237\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u672a\u56de\u590d\u60c5\u51b5\"\u3002 \n        - 4\u3001\u88ab\u67e5\u8005ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\uff0cid\u6570\u4e0d\u80fd\u8d85\u8fc730\u3002 \n        - 5\u3001\u5f00\u59cb\u65f6\u95f4\u4e0e\u7ed3\u675f\u65f6\u95f4\u4e4b\u95f4\u7684\u95f4\u9694\u4e0d\u80fd\u8d85\u8fc77\u5929 \n        - 6\u3001\u4e0d\u80fd\u67e5\u8be290\u5929\u4ee5\u524d\u7684\u6570\u636e \n        - 7\u3001\u4e0d\u80fd\u67e5\u8be2\u5f53\u5929\u7684\u8bb0\u5f55"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef receivenum_get(self, service_staff_id, start_date, end_date, session):\n        '''taobao.wangwang.eservice.receivenum.get \u5ba2\u670d\u63a5\u5f85\u6570\n        \n        \u6839\u636e\u64cd\u4f5c\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u6307\u5b9a\u65f6\u95f4\u6bb5\u5185\u6bcf\u4e2a\u5e10\u53f7\u7684\"\u5df2\u63a5\u5f85\u4eba\u6570\" \u5907\u6ce8\uff1a\n        \n        - 1\u3001\u5982\u679c\u662f\u64cd\u4f5c\u8005ID=\u88ab\u67e5\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u7684\"\u5df2\u63a5\u5f85\u4eba\u6570\"\u3002 \n        - 2\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u7ec4\u7ba1\u7406\u5458\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u4ed6\u7684\u7ec4\u4e2d\u7684\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u5df2\u63a5\u5f85\u4eba\u6570\"\u3002 \n        - 3\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u4e3b\u8d26\u6237\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u5df2\u63a5\u5f85\u4eba\u6570\"\u3002 \n        - 4\u3001\u88ab\u67e5\u8005ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\uff0cid\u6570\u4e0d\u80fd\u8d85\u8fc730\u3002 \n        - 5\u3001\u89c4\u5219\uff1a\u67d0\u5ba2\u670d\u57281\u5929\u5185\u548c\u540c\u4e00\u4e2a\u5ba2\u6237\u4ea4\u6d41\u4e86\u591a\u6b21\uff0c\u5df2\u56de\u590d\u4eba\u6570\u7b971\u3002 \n        - 6\u3001\"\u5df2\u63a5\u5f85\u4eba\u6570\"\u5b9a\u4e49\uff1a\u4e70\u5bb6\u3001\u5356\u5bb6\u5f7c\u6b64\u53d1\u8fc7\u81f3\u5c111\u6761\u6d88\u606f \uff0c\u4e0d\u8bba\u8c01\u5148\u53d1\u90fd\u53ef\u4ee5\u3002 4\u3001\u88ab\u67e5\u8005ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\uff0cid\u6570\u4e0d\u80fd\u8d85\u8fc730\u3002 \n        - 7\u3001\u5f00\u59cb\u65f6\u95f4\u4e0e\u7ed3\u675f\u65f6\u95f4\u4e4b\u95f4\u7684\u95f4\u9694\u4e0d\u80fd\u8d85\u8fc77\u5929 \n        - 8\u3001\u4e0d\u80fd\u67e5\u8be290\u5929\u4ee5\u524d\u7684\u6570\u636e \n        - 9\u3001\u4e0d\u80fd\u67e5\u8be2\u5f53\u5929\u7684\u8bb0\u5f55'''\n        request = TOPRequest('taobao.wangwang.eservice.receivenum.get')\n        request['service_staff_id'] = service_staff_id\n        request['start_date'] = start_date\n        request['end_date'] = end_date\n        self.create(self.execute(request, session))\n        return self.reply_stat_list_on_days", "response": "taobao.wangwang.eservice.receivenum.get \u5ba2\u670d\u63a5\u5f85\u6570\n        \n        \u6839\u636e\u64cd\u4f5c\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u6307\u5b9a\u65f6\u95f4\u6bb5\u5185\u6bcf\u4e2a\u5e10\u53f7\u7684\"\u5df2\u63a5\u5f85\u4eba\u6570\" \u5907\u6ce8\uff1a\n        \n        - 1\u3001\u5982\u679c\u662f\u64cd\u4f5c\u8005ID=\u88ab\u67e5\u8005ID\uff0c\u8fd4\u56de\u88ab\u67e5\u8005ID\u7684\"\u5df2\u63a5\u5f85\u4eba\u6570\"\u3002 \n        - 2\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u7ec4\u7ba1\u7406\u5458\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u4ed6\u7684\u7ec4\u4e2d\u7684\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u5df2\u63a5\u5f85\u4eba\u6570\"\u3002 \n        - 3\u3001\u5982\u679c\u64cd\u4f5c\u8005\u662f\u4e3b\u8d26\u6237\uff0c\u4ed6\u53ef\u4ee5\u67e5\u8be2\u6240\u6709\u5b50\u5e10\u53f7\u7684\"\u5df2\u63a5\u5f85\u4eba\u6570\"\u3002 \n        - 4\u3001\u88ab\u67e5\u8005ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\uff0cid\u6570\u4e0d\u80fd\u8d85\u8fc730\u3002 \n        - 5\u3001\u89c4\u5219\uff1a\u67d0\u5ba2\u670d\u57281\u5929\u5185\u548c\u540c\u4e00\u4e2a\u5ba2\u6237\u4ea4\u6d41\u4e86\u591a\u6b21\uff0c\u5df2\u56de\u590d\u4eba\u6570\u7b971\u3002 \n        - 6\u3001\"\u5df2\u63a5\u5f85\u4eba\u6570\"\u5b9a\u4e49\uff1a\u4e70\u5bb6\u3001\u5356\u5bb6\u5f7c\u6b64\u53d1\u8fc7\u81f3\u5c111\u6761\u6d88\u606f \uff0c\u4e0d\u8bba\u8c01\u5148\u53d1\u90fd\u53ef\u4ee5\u3002 4\u3001\u88ab\u67e5\u8005ID\u53ef\u4ee5\u662f\u591a\u4e2a\uff0c\u7528 \",\" \u9694\u5f00\uff0cid\u6570\u4e0d\u80fd\u8d85\u8fc730\u3002 \n        - 7\u3001\u5f00\u59cb\u65f6\u95f4\u4e0e\u7ed3\u675f\u65f6\u95f4\u4e4b\u95f4\u7684\u95f4\u9694\u4e0d\u80fd\u8d85\u8fc77\u5929 \n        - 8\u3001\u4e0d\u80fd\u67e5\u8be290\u5929\u4ee5\u524d\u7684\u6570\u636e \n        - 9\u3001\u4e0d\u80fd\u67e5\u8be2\u5f53\u5929\u7684\u8bb0\u5f55"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npushing entry onto our access log invalidate the old entry if exists.", "response": "def _push_entry(self, key):\n        \"Push entry onto our access log, invalidate the old entry if exists.\"\n        self._invalidate_entry(key)\n\n        new_entry = AccessEntry(key)\n        self.access_lookup[key] = new_entry\n\n        self.access_log_lock.acquire()\n        self.access_log.appendleft(new_entry)\n        self.access_log_lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _prune_entries(self, num):\n        \"Pop entries from our access log until we popped ``num`` valid ones.\"\n        while num > 0:\n            self.access_log_lock.acquire()\n            p = self.access_log.pop()\n            self.access_log_lock.release()\n\n            if not p.is_valid:\n                continue # Invalidated entry, skip\n\n            dict.pop(self, p.key, None)\n            self.access_lookup.pop(p.key, None)\n            num -= 1", "response": "Pop entries from our access log until we popped num valid ones."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _prune_invalidated_entries(self):\n        \"Rebuild our access_log without the invalidated entries.\"\n        self.access_log_lock.acquire()\n        self.access_log = deque(e for e in self.access_log if e.is_valid)\n        self.access_log_lock.release()", "response": "Rebuild our access_log without the invalidated entries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_ordered_access_keys(self):\n        \"Return ordered access keys for inspection. Used for testing.\"\n        self.access_log_lock.acquire()\n        r = [e.key for e in self.access_log if e.is_valid]\n        self.access_log_lock.release()\n\n        return r", "response": "Return ordered access keys for inspection. Used for testing."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calc_scaled_res(self, screen_res, image_res):\n\t\trs = screen_res[0]/float(screen_res[1])\n\t\tri = image_res[0]/float(image_res[1])\n\n\t\tif rs > ri:\n\t\t\treturn (int(image_res[0] * screen_res[1]/image_res[1]), screen_res[1])\n\t\telse:\n\t\t\treturn (screen_res[0], int(image_res[1]*screen_res[0]/image_res[0]))", "response": "Calculate appropriate texture size."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a video. Parameters ---------- vidSource : str The path to the video file", "response": "def load_media(self, vidSource):\n\t\t\"\"\" Loads a video.\n\n\t\tParameters\n\t\t----------\n\t\tvidSource : str\n\t\t\tThe path to the video file\n\t\t\"\"\"\n\t\tif not os.path.exists(vidSource):\n\t\t\tprint(\"File not found: \" + vidSource)\n\t\t\tpygame.display.quit()\n\t\t\tpygame.quit()\n\t\t\tsys.exit(1)\n\n\t\tself.decoder.load_media(vidSource)\n\t\tself.decoder.loop = self.loop\n\t\tpygame.display.set_caption(os.path.split(vidSource)[1])\n\t\tself.vidsize = self.decoder.clip.size\n\n\t\tself.destsize = self.calc_scaled_res(self.windowSize, self.vidsize)\n\t\tself.vidPos = ((self.windowSize[0] - self.destsize[0]) / 2, (self.windowSize[1] - self.destsize[1]) / 2)\n\n\t\tself.__textureSetup()\n\n\t\tif(self.decoder.audioformat):\n\t\t\tif self.soundrenderer == \"pygame\":\n\t\t\t\tfrom mediadecoder.soundrenderers import SoundrendererPygame\n\t\t\t\tself.audio = SoundrendererPygame(self.decoder.audioformat)\n\t\t\telif self.soundrenderer == \"pyaudio\":\n\t\t\t\tfrom mediadecoder.soundrenderers.pyaudiorenderer import SoundrendererPyAudio\n\t\t\t\tself.audio = SoundrendererPyAudio(self.decoder.audioformat)\n\t\t\telif self.soundrenderer == \"sounddevice\":\n\t\t\t\tfrom mediadecoder.soundrenderers.sounddevicerenderer import SoundrendererSounddevice\n\t\t\t\tself.audio = SoundrendererSounddevice(self.decoder.audioformat)\n\t\t\tself.decoder.set_audiorenderer(self.audio)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the texture with the newly supplied frame.", "response": "def __texUpdate(self, frame):\n\t\t\"\"\" Update the texture with the newly supplied frame. \"\"\"\n\t\t# Retrieve buffer from videosink\n\t\tif self.texture_locked:\n\t\t\treturn\n\t\tself.buffer = frame\n\t\tself.texUpdated = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nforegrounds color formatter function factory. Each function casts from a unicode string to a colored bytestring with the respective foreground color and foreground reset ANSI escape codes. You can also use the ``fg.color`` or ``fg[color]`` directly as attributes/items. The colors are the names of the ``colorama.Fore`` attributes (case insensitive). For more information, see: https://pypi.python.org/pypi/colorama https://en.wikipedia.org/wiki/ANSI_escape_code#Colors", "response": "def fg(color):\n    \"\"\"\n    Foreground color formatter function factory.\n\n    Each function casts from a unicode string to a colored bytestring\n    with the respective foreground color and foreground reset ANSI\n    escape codes. You can also use the ``fg.color`` or ``fg[color]``\n    directly as attributes/items.\n\n    The colors are the names of the ``colorama.Fore`` attributes\n    (case insensitive). For more information, see:\n\n    https://pypi.python.org/pypi/colorama\n\n    https://en.wikipedia.org/wiki/ANSI_escape_code#Colors\n    \"\"\"\n    ansi_code = [getattr(colorama.Fore, color.upper()), colorama.Fore.RESET]\n    return lambda msg: msg.join(ansi_code)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a function that prints a single horizontal rule with the given color repeated.", "response": "def hr(color):\n    \"\"\"\n    Colored horizontal rule printer/logger factory.\n\n    The resulting function prints an entire terminal row with the given\n    symbol repeated. It's a terminal version of the HTML ``<hr/>``.\n    \"\"\"\n    logger = log(color)\n    return lambda symbol: logger(symbol * terminal_size.usable_width)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstores the terminal width into ``self.width``, if possible. This function is also the SIGWINCH event handler.", "response": "def retrieve_width(self, signum=None, frame=None):\n        \"\"\"\n        Stores the terminal width into ``self.width``, if possible.\n        This function is also the SIGWINCH event handler.\n        \"\"\"\n        for method_name, args in self.strategies:\n            method = getattr(self, \"from_\" + method_name)\n            width = method(*args)\n            if width and width > 0:\n                self.width = width\n                break # Found!\n        os.environ[\"COLUMNS\"] = str(self.width)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the terminal width assigned to a file object.", "response": "def from_io_control(fobj):\n        \"\"\"\n        Call TIOCGWINSZ (Terminal I/O Control to Get the WINdow SiZe)\n        where ``fobj`` is a file object (e.g. ``sys.stdout``),\n        returning the terminal width assigned to that file.\n\n        See the ``ioctl``, ``ioctl_list`` and tty_ioctl`` man pages\n        for more information.\n        \"\"\"\n        import fcntl, termios, array\n        winsize = array.array(\"H\", [0] * 4) # row, col, xpixel, ypixel\n        if not fcntl.ioctl(fobj.fileno(), termios.TIOCGWINSZ, winsize, True):\n            return winsize[1]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_windows_handle(std_handle):\n        from ctypes import windll, c_ushort\n        # https://msdn.microsoft.com/library/windows/desktop/ms683231\n        handle = windll.kernel32.GetStdHandle(std_handle)\n        # https://msdn.microsoft.com/library/windows/desktop/ms682093\n        info = (c_ushort * 11)() # It's a CONSOLE_SCREEN_BUFFER_INFO:\n            # xsize, ysize,             | COORD      dwSize\n            # xcursor, ycursor,         | COORD      dwCursorPosition\n            # attributes,               | WORD       wAttributes\n            # left, top, right, bottom, | SMALL_RECT srWindow\n            # xmax, ymax                | COORD      dwMaximumWindowSize\n        # https://msdn.microsoft.com/library/windows/desktop/ms683171\n        if windll.kernel32.GetConsoleScreenBufferInfo(handle, info):\n            return info[7] - info[5] + 1", "response": "Get the console width from a Windows Console Handle."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dump_part(part, total_segments=None):\n    try:\n        connection = Connection(host=config['host'], region=config['region'])\n\n        filename = \".\".join([config['table_name'], str(part), \"dump\"])\n        if config['compress']:\n            opener = gzip.GzipFile\n            filename += \".gz\"\n        else:\n            opener = open\n\n        dumper = BatchDumper(connection, config['table_name'], config['capacity'], part, total_segments)\n\n        with opener(filename, 'w') as output:\n            while dumper.has_items:\n                items = dumper.get_items()\n\n                for item in items:\n                    output.write(json.dumps(item))\n                    output.write(\"\\n\")\n                output.flush()\n                config['queue'].put(len(items))\n        config['queue'].put('complete')\n    except Exception as e:\n        print('Unhandled exception: {0}'.format(e))", "response": "Dump a single segment of a single item into a single file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mrcompletion(A, reordered=True):\n\n    assert isinstance(A, cspmatrix) and A.is_factor is False, \"A must be a cspmatrix\"\n\n    symb = A.symb\n    n = symb.n\n    \n    snpost = symb.snpost\n    snptr = symb.snptr\n    chptr = symb.chptr\n    chidx = symb.chidx\n\n    relptr = symb.relptr\n    relidx = symb.relidx\n    blkptr = symb.blkptr\n    blkval = A.blkval\n\n    stack = []\n    r = 0 \n\n    maxr = symb.clique_number\n    Y = matrix(0.0,(n,maxr))       # storage for factorization\n    Z = matrix(0.0,(maxr,maxr))    # storage for EVD of cliques\n    w = matrix(0.0,(maxr,1))       # storage for EVD of cliques\n\n    P = matrix(0.0,(maxr,maxr))    # storage for left singular vectors\n    Q1t = matrix(0.0,(maxr,maxr))  # storage for right singular vectors (1)\n    Q2t = matrix(0.0,(maxr,maxr))  # storage for right singular vectors (2)\n    S = matrix(0.0,(maxr,1))       # storage for singular values\n\n    V = matrix(0.0,(maxr,maxr))\n    Ya = matrix(0.0,(maxr,maxr))\n    \n    # visit supernodes in reverse topological order\n    for k in range(symb.Nsn-1,-1,-1):\n\n        nn = snptr[k+1]-snptr[k]       # |Nk|\n        na = relptr[k+1]-relptr[k]     # |Ak|\n        nj = na + nn\n\n        # allocate F and copy X_{Jk,Nk} to leading columns of F\n        F = matrix(0.0, (nj,nj))\n        lapack.lacpy(blkval, F, offsetA = blkptr[k], ldA = nj, m = nj, n = nn, uplo = 'L')\n\n        # if supernode k is not a root node:\n        if na > 0:\n            # copy Vk to 2,2 block of F\n            Vk = stack.pop()\n            lapack.lacpy(Vk, F, offsetB = nn*nj+nn, m = na, n = na, uplo = 'L')\n\n        # if supernode k has any children:\n        for ii in range(chptr[k],chptr[k+1]):\n            stack.append(frontal_get_update(F,relidx,relptr,chidx[ii]))\n\n        # Compute factorization of F\n        lapack.syevr(F, w, jobz='V', range='A', uplo='L', Z=Z, n=nj,ldZ=maxr)\n        rk = sum([1 for wi in w[:nj] if wi > 1e-14*w[nj-1]])  # determine rank of clique k\n        r = max(rk,r)                                         # update rank\n        \n        # Scale last rk cols of Z and copy parts to Yn\n        for j in range(nj-rk,nj):\n            Z[:nj,j] *= sqrt(w[j])\n        In = symb.snrowidx[symb.sncolptr[k]:symb.sncolptr[k]+nn]\n        Y[In,:rk] = Z[:nn,nj-rk:nj]\n\n        # if supernode k is not a root node:\n        if na > 0:\n            # Extract data\n            Ia = symb.snrowidx[symb.sncolptr[k]+nn:symb.sncolptr[k+1]]\n            Ya[:na,:r] = Y[Ia,:r]\n            V[:na,:rk] = Z[nn:nj,nj-rk:nj]\n            V[:na,rk:r] *= 0.0            \n            # Compute SVDs: V = P*S*Q1t and Ya = P*S*Q2t\n            lapack.gesvd(V,S,jobu='A',jobvt='A',U=P,Vt=Q1t,ldU=maxr,ldVt=maxr,m=na,n=r,ldA=maxr)\n            lapack.gesvd(Ya,S,jobu='N',jobvt='A',Vt=Q2t,ldVt=maxr,m=na,n=r,ldA=maxr)\n            # Scale Q2t \n            for i in range(min(na,rk)):\n                if S[i] > 1e-14*S[0]: Q2t[i,:r] = P[:na,i].T*Y[Ia,:r]/S[i]\n            # Scale Yn            \n            Y[In,:r] = Y[In,:r]*Q1t[:r,:r].T*Q2t[:r,:r]\n                        \n    if reordered:\n        return Y[:,:r]\n    else:\n        return Y[symb.ip,:r]", "response": "Returns a dense version of the minimum rank positive semidefinite completion routine."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_fields(store_name, field_names):\n    def decorate(cls):\n        def _add(index, name):\n            def _set_dir(self, value): getattr(self, store_name)[index] = value\n            def _get_dir(self): return getattr(self, store_name)[index]\n            setattr(cls, name, property(_get_dir, _set_dir))\n\n        for index, field_name in enumerate(field_names):\n            _add(index, field_name)\n\n        return cls\n\n    return decorate", "response": "A class - decorator that creates a set of named\n            fields."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_smallest_dimensions(self, data):\n        min_width = 0\n        min_height = 0\n        for element in self.elements:\n            if not element: continue\n            size = element.get_minimum_size(data)\n            min_width = max(min_width, size.x)\n            min_height = max(min_height, size.y)\n        return datatypes.Point(min_width, min_height)", "response": "A utility method to return the minimum size needed to fit all the elements in the archive."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set(self, instance, value, **kw):\n        return self._set(instance, value, **kw)", "response": "Set the value of the field\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef json_data(self, instance, default=None):\n        value = self.get(instance)\n        return value or default", "response": "Get a JSON compatible value for the given instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _set(self, instance, value, **kw):\n        logger.debug(\"DexterityFieldManager::set: value=%r\" % value)\n\n        # Check if the field is read only\n        if self.field.readonly:\n            raise Unauthorized(\"Field is read only\")\n\n        fieldname = self.get_field_name()\n        # id fields take only strings\n        if fieldname == \"id\":\n            value = str(value)\n\n        try:\n            # Validate\n            self.field.validate(value)\n\n            # TODO: Check security on the field level\n            return self.field.set(instance, value)\n        except WrongType:\n            logger.warn(\"WrongType: Field={} Value={}\".format(self.field, value))\n        except:  # noqa\n            logger.warn(\"Unknown Exception: Field={} Value={}\".format(self.field, value))", "response": "Set the value of the field in the current instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the value of the field", "response": "def _get(self, instance, **kw):\n        \"\"\"Get the value of the field\n        \"\"\"\n        logger.debug(\"DexterityFieldManager::get: instance={} field={}\"\n                     .format(instance, self.field))\n\n        # TODO: Check security on the field level\n        return self.field.get(instance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef json_data(self, instance, default=None):\n        value = self.get(instance)\n        if not value:\n            return \"\"\n        if callable(value):\n            value = value()\n        return api.to_iso_date(value, default=default)", "response": "Get a JSON compatible value for the current user s id"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef json_data(self, instance, default=None):\n        value = self.get(instance)\n        if value:\n            return value.output\n        return value", "response": "Get a JSON compatible value for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_download_url(self, instance, default=None):\n        download = default\n        # calculate the download url\n        download = \"{url}/@@download/{fieldname}/{filename}\".format(\n            url=api.get_url(instance),\n            fieldname=self.get_field_name(),\n            filename=self.get_filename(instance),\n        )\n        return download", "response": "Calculate the download url"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef json_data(self, instance, default=None):\n        value = self.get(instance)\n\n        out = []\n        for rel in value:\n            if rel.isBroken():\n                logger.warn(\"Skipping broken relation {}\".format(repr(rel)))\n                continue\n            obj = rel.to_object\n            out.append(api.get_url_info(obj))\n        return out", "response": "Get a JSON compatible value of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set(self, instance, value, **kw):\n        logger.debug(\"ATFieldManager::set: value=%r\" % value)\n\n        # check field permission\n        if not self.field.checkPermission(\"write\", instance):\n            raise Unauthorized(\"You are not allowed to write the field {}\"\n                               .format(self.name))\n\n        # check if field is writable\n        if not self.field.writeable(instance):\n            raise Unauthorized(\"Field {} is read only.\"\n                               .format(self.name))\n\n        # id fields take only strings\n        if self.name == \"id\":\n            value = str(value)\n\n        # get the field mutator\n        mutator = self.field.getMutator(instance)\n\n        # Inspect function and apply *args and **kwargs if possible.\n        mapply(mutator, value, **kw)\n\n        return True", "response": "Set the value of the field in the given instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the value of the field in the specified instance", "response": "def _get(self, instance, **kw):\n        \"\"\"Get the value of the field\n        \"\"\"\n        logger.debug(\"ATFieldManager::get: instance={} field={}\"\n                     .format(instance, self.field))\n\n        # check the field permission\n        if not self.field.checkPermission(\"read\", instance):\n            raise Unauthorized(\"You are not allowed to read the field {}\"\n                               .format(self.name))\n\n        # return the field value\n        return self.field.get(instance)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the value of the field", "response": "def get(self, instance, **kw):\n        \"\"\"Get the value of the field\n        \"\"\"\n        # Gracefully avoid programming errors in Computed fields\n        try:\n            return self._get(instance, **kw)\n        except AttributeError:\n            logger.error(\"Could not get the value of the computed field '{}'\"\n                         .format(self.get_field_name()))\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the value of the attribute to the given value.", "response": "def set(self, instance, value, **kw):\n        \"\"\"Converts the value into a DateTime object before setting.\n        \"\"\"\n        if value:\n            try:\n                value = DateTime(value)\n            except SyntaxError:\n                logger.warn(\"Value '{}' is not a valid DateTime string\"\n                            .format(value))\n                return False\n\n        self._set(instance, value, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef json_data(self, instance, default=None):\n        value = self.get(instance)\n        return api.to_iso_date(value) or default", "response": "Get a JSON compatible value from the cache"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_filename(self, instance):\n        filename = self.field.getFilename(instance)\n        if filename:\n            return filename\n\n        fieldname = self.get_field_name()\n        content_type = self.get_content_type(instance)\n        extension = mimetypes.guess_extension(content_type)\n\n        return fieldname + extension", "response": "Get the filename of the current object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the download url for the current instance", "response": "def get_download_url(self, instance, default=None):\n        \"\"\"Calculate the download url\n        \"\"\"\n        download = default\n        # calculate the download url\n        download = \"{url}/at_download/{fieldname}\".format(\n            url=instance.absolute_url(), fieldname=self.get_field_name())\n        return download"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndecoding base64 value and set the file object", "response": "def set(self, instance, value, **kw):\n        \"\"\"Decodes base64 value and set the file object\n        \"\"\"\n        value = str(value).decode(\"base64\")\n\n        # handle the filename\n        if \"filename\" not in kw:\n            logger.debug(\"FielFieldManager::set: No Filename detected \"\n                         \"-> using title or id\")\n            kw[\"filename\"] = kw.get(\"id\") or kw.get(\"title\")\n\n        self._set(instance, value, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the value of the refernce field", "response": "def set(self, instance, value, **kw):  # noqa\n        \"\"\"Set the value of the refernce field\n        \"\"\"\n        ref = []\n\n        # The value is an UID\n        if api.is_uid(value):\n            ref.append(api.get_object_by_uid(value))\n\n        # The value is already an object\n        if api.is_at_content(value):\n            ref.append(value)\n\n        # The value is a dictionary\n        # -> handle it like a catalog query\n        if u.is_dict(value):\n            results = api.search(portal_type=self.allowed_types, **value)\n            ref = map(api.get_object, results)\n\n        # The value is a list\n        if u.is_list(value):\n            for item in value:\n                # uid\n                if api.is_uid(item):\n                    ref.append(api.get_object_by_uid(item))\n                    continue\n\n                # object\n                if api.is_at_content(item):\n                    ref.append(api.get_object(item))\n                    continue\n\n                # path\n                if api.is_path(item):\n                    ref.append(api.get_object_by_path(item))\n                    continue\n\n                # dict (catalog query)\n                if u.is_dict(item):\n                    # If there is UID of objects, just use it.\n                    uid = item.get('uid', None)\n                    if uid:\n                        obj = api.get_object_by_uid(uid)\n                        ref.append(obj)\n                    else:\n                        results = api.search(portal_type=self.allowed_types, **item)\n                        objs = map(api.get_object, results)\n                        ref.extend(objs)\n                    continue\n\n                # Plain string\n                # -> do a catalog query for title\n                if isinstance(item, basestring):\n                    results = api.search(portal_type=self.allowed_types, title=item)\n                    objs = map(api.get_object, results)\n                    ref.extend(objs)\n                    continue\n\n        # The value is a physical path\n        if api.is_path(value):\n            ref.append(api.get_object_by_path(value))\n\n        # Handle non multi valued fields\n        if not self.multi_valued:\n            if len(ref) > 1:\n                raise ValueError(\"Multiple values given for single valued \"\n                                 \"field {}\".format(repr(self.field)))\n            else:\n                ref = ref[0]\n        return self._set(instance, ref, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef json_data(self, instance, default=None):\n        value = self.get(instance)\n        if value and self.is_multi_valued():\n            return map(api.get_url_info, value)\n        elif value and not self.is_multi_valued():\n            return api.get_url_info(value)\n        return value or default", "response": "Get a JSON compatible value for the given instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_proxy_field(self, instance):\n        proxy_object = self.get_proxy_object(instance)\n        if not proxy_object:\n            return None\n        return proxy_object.getField(self.name)", "response": "Get the proxied field of this field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the value of the current object s attribute", "response": "def set(self, instance, value, **kw):\n        \"\"\"Set the value of the (proxy) field\n        \"\"\"\n        proxy_field = self.get_proxy_field(instance)\n        if proxy_field is None:\n            return None\n        # set the field with the proper field manager of the proxy field\n        fieldmanager = IFieldManager(proxy_field)\n        return fieldmanager.set(instance, value, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef json_data(self, instance, default=[]):\n        value = self.get(instance)\n        out = map(api.get_url_info, value)\n        return out or default", "response": "Get a JSON compatible value for the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, instance, value, **kw):\n\n        if not isinstance(value, (list, tuple)):\n            value = [value]\n\n        uids = []\n        for item in value:\n            uid = None\n            if isinstance(item, dict):\n                uid = item.get(\"uid\")\n            if api.is_uid(value):\n                uid = item\n            if uid is None:\n                logger.warn(\"Could extract UID of value\")\n                continue\n            uids.append(uid)\n\n        analyses = map(api.get_object_by_uid, uids)\n        self._set(instance, analyses, **kw)", "response": "Set the value of the AR\nTaxonomy field to value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the value of the uid reference field", "response": "def set(self, instance, value, **kw):  # noqa\n        \"\"\"Set the value of the uid reference field\n        \"\"\"\n        ref = []\n        # The value is an UID\n        if api.is_uid(value):\n            ref.append(value)\n\n        # The value is a dictionary, get the UIDs.\n        if u.is_dict(value):\n            ref = ref.append(value.get(\"uid\"))\n\n        # The value is already an object\n        if api.is_at_content(value):\n            ref.append(value)\n\n        # The value is a list\n        if u.is_list(value):\n            for item in value:\n                # uid\n                if api.is_uid(item):\n                    ref.append(item)\n                # dict (catalog query)\n                elif u.is_dict(item):\n                    # If there is UID of objects, just use it.\n                    uid = item.get('uid', None)\n                    if uid:\n                        ref.append(uid)\n\n        # Handle non multi valued fields\n        if not self.multi_valued:\n            if len(ref) > 1:\n                raise ValueError(\"Multiple values given for single valued \"\n                                 \"field {}\".format(repr(self.field)))\n            else:\n                ref = ref[0]\n\n        return self._set(instance, ref, **kw)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts the data of the content and return it as a dictionary", "response": "def to_dict(self):\n        \"\"\" extract the data of the content and return it as a dictionary\n        \"\"\"\n\n        # 1. extract the schema fields\n        data = self.extract_fields()\n\n        # 2. include custom key-value pairs listed in the mapping dictionary\n        for key, attr in self.attributes.iteritems():\n            if key in self.ignore:\n                continue  # skip ignores\n            # fetch the mapped attribute\n            value = getattr(self.context, attr, None)\n            if value is None:\n                value = getattr(self, attr, None)\n            # handle function calls\n            if callable(value):\n                value = value()\n            # map the value to the given key from the mapping\n            data[key] = api.to_json_value(self.context, key, value)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extract_fields(self):\n\n        # get the proper data manager for the object\n        dm = IDataManager(self.context)\n\n        # filter out ignored fields\n        fieldnames = filter(lambda name: name not in self.ignore, self.keys)\n\n        # schema mapping\n        out = dict()\n\n        for fieldname in fieldnames:\n            try:\n                # get the field value with the data manager\n                fieldvalue = dm.json_data(fieldname)\n            # https://github.com/collective/plone.jsonapi.routes/issues/52\n            # -> skip restricted fields\n            except Unauthorized:\n                logger.debug(\"Skipping restricted field '%s'\" % fieldname)\n                continue\n            except ValueError:\n                logger.debug(\"Skipping invalid field '%s'\" % fieldname)\n                continue\n\n            out[fieldname] = api.to_json_value(self.context, fieldname, fieldvalue)\n\n        return out", "response": "Extract the given fieldnames from the object\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _x_get_physical_path(self):\n        path = self.context.getPath()\n        portal_path = api.get_path(api.get_portal())\n        if portal_path not in path:\n            return \"{}/{}\".format(portal_path, path)\n        return path", "response": "Generate the physical path for the current context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snake2ucamel(value):\n    UNDER, LETTER, OTHER = object(), object(), object()\n    def group_key_function(char):\n        if char == \"_\":\n            return UNDER\n        if char in string.ascii_letters:\n            return LETTER\n        return OTHER\n    def process_group(idx, key, chars):\n        if key is LETTER:\n            return \"\".join([chars[0].upper()] + chars[1:])\n        if key is OTHER     \\\n        or len(chars) != 1  \\\n        or idx in [0, last] \\\n        or LETTER not in (groups[idx-1][1], groups[idx+1][1]):\n            return \"\".join(chars)\n        return \"\"\n    raw_groups_gen = itertools.groupby(value, key=group_key_function)\n    groups = [(idx, key, list(group_gen))\n              for idx, (key, group_gen) in enumerate(raw_groups_gen)]\n    last = len(groups) - 1\n    return \"\".join(itertools.starmap(process_group, groups))", "response": "Casts a snake_case string to an UpperCamelCase string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ucamel_method(func):\n    frame_locals = inspect.currentframe().f_back.f_locals\n    frame_locals[snake2ucamel(func.__name__)] = func\n    return func", "response": "Decorator to ensure the given snake_case method is written in\n    UpperCamelCase in the given namespace."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_plain_text(fname, encoding=\"utf-8\"):\n    with io.open(fname, encoding=encoding) as f:\n        result = list(f)\n    if result:\n        if result[-1][-1:] == \"\\n\":\n            result.append(\"\\n\")\n        else:\n            result[-1] += \"\\n\"\n        return [line[:-1] for line in result]\n    return []", "response": "Reads a file as a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef maxcardsearch(A, ve = None):\n    \n    n = A.size[0]\n    assert A.size[1] == n, \"A must be a square matrix\"\n    assert type(A) is spmatrix, \"A must be a sparse matrix\"\n    if ve is None: \n        ve = n-1\n    else:\n        assert type(ve) is int and 0<=ve<n,\\\n          \"ve must be an integer between 0 and A.size[0]-1\"    \n    As = symmetrize(A)\n    cp,ri,_ = As.CCS\n    \n    # permutation vector \n    p = matrix(0,(n,1))\n    \n    # weight array\n    w = matrix(0,(n,1))\n    max_w = 0\n    S = [list(range(ve))+list(range(ve+1,n))+[ve]] + [[] for i in range(n-1)]\n        \n    for i in range(n-1,-1,-1):\n        while True:\n            if len(S[max_w]) > 0:\n                v = S[max_w].pop()\n                if w[v] >= 0: break\n            else:\n                max_w -= 1\n        p[i] = v    \n        w[v] = -1   # set w[v] = -1 to mark that node v has been numbered\n\n        # increase weights for all unnumbered neighbors\n        for r in ri[cp[v]:cp[v+1]]:\n            if w[r] >= 0: \n                w[r] += 1\n                S[w[r]].append(r)     # bump r up to S[w[r]]\n                max_w = max(max_w,w[r])   \n\n    return p", "response": "Returns the maximum cardinality search ordering of a symmetric chordal matrix A."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _setup_logging():\n    import logging\n\n    logger = logging.getLogger('spotify-connect')\n    handler = logging.NullHandler()\n    logger.addHandler(handler)", "response": "Setup logging to log to nowhere by default."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef serialized(f):\n    import functools\n\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        with _lock:\n            return f(*args, **kwargs)\n    if not hasattr(wrapper, '__wrapped__'):\n        # Workaround for Python < 3.2\n        wrapper.__wrapped__ = f\n    return wrapper", "response": "Decorator that serializes access to all decorated functions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_page_impositions(imposition_type,\n                         sheets_per_sig=None, fold_then_collate=False,\n                         thickness=0.2835, signature_mark=0,\n                         elements=[]):\n    \"\"\"\n    Calculates impositions for the elements in the content list and\n    returns a set of page-layouts for each as manager instances.\n\n    An imposition is a way of laying out pages on a larger sheet, such\n    that they can be folded and cut to form a booklet.\n    The signature size of an imposition controls how many of these\n    large sheets can fold together as one. Larger books are made up of\n    multiple signatures sewn together in a codex.\n\n    Arguments:\n\n    ``imposition_type``\n        One of the FORMAT_* constants defined in this module: controls\n        the kind of imposition to make.\n\n    ``sheets_per_sig``\n        How many sheets of paper will be folded, cut and bind\n        together. This is often 1 for commercial presses, but DIY\n        laser printouts often have all the pages in one signature (for\n        stapling). If this value isn't provided, the function will\n        assume the latter.\n\n    ``fold_then_collate``\n        If this is true then each printed sheet will be folded and\n        cut, then the bundle of resulting pages will be combined with\n        the others from its signature. This kindof defeats the object\n        of printing in signatures, but is needed when building\n        multi-signature books using a laser printer. It only makes\n        sense if you have more than one sheet per sig.\n\n    ``thickness``\n        When many pages are folded together, the thickness of the\n        sheets adds up. Giving a page thickness to this argument moves\n        the printed pages around slightly to compensate.\n\n    ``signature_mark``\n        When working with many signatures, it can be fiddly to sort\n        the signatures into the correct order for binding. To help we\n        can add 'signature marks' - a triangle on the spine of each\n        signature indicating up, and offset from signature to\n        signature. When the signatures are correctly collated, the\n        marks form a diagonal pattern: it is obvious when they are not\n        correct. The value of this argument indicates the width of\n        this pattern. Zero indicates that no mark should be added.\n\n    ``elements``\n        The list of individual page element to impose. There can be\n        fewer pages to layout than spaces on the layout (i.e. in a 16\n        page imposition, we could only have 13 pages), any additional\n        space is left blank.\n\n    The returned page layouts can be given to a PageLM for rendering\n    onto individual pages of output. This method isn't a layout\n    manager in its own right.\n    \"\"\"\n    # Take a copy of the elements list so we can mess with it.\n    elements = elements[:]\n\n    # Sanity check the type\n    s = set(imposition_type[2])\n    assert len(s) == imposition_type[0] * imposition_type[1] * 2\n    assert max(*list(s)) == imposition_type[0] * imposition_type[1] * 2\n    assert min(*list(s)) == 1\n\n    # Calculate the sheets per signature.\n    if sheets_per_sig is None:\n        if imposition_type == FORMAT_4_PAGE:\n            sheets_per_sig = int(math.ceil(len(elements) / 4.0))\n        else:\n            sheets_per_sig = 1\n\n    # Find basic data.\n    cols, rows, pattern = imposition_type\n    pages_per_side = cols * rows\n    pages_per_sheet = pages_per_side * 2\n    pages_per_signature = sheets_per_sig * pages_per_sheet\n    num_pages = len(elements)\n    sheets_needed = int(math.ceil(num_pages / float(pages_per_sheet)))\n    signatures_needed = int(math.ceil(sheets_needed / float(sheets_per_sig)))\n\n    # Add effective margins to account for page thickness.\n    if thickness > 0:\n        total_offset = (\n            sheets_per_sig * pages_per_side * thickness * math.pi * 0.25\n            )\n\n        for index, element in enumerate(elements):\n            # Work out which spread this page is on.\n            index_in_sig = index % pages_per_signature\n            if (index_in_sig >= pages_per_signature / 2):\n                index_in_sig = pages_per_signature - 1 - index_in_sig\n\n            # How many thicknesses are we from the outside of the sig\n            out_d = (index_in_sig + 1) // 2\n\n            # And what offset is that from the inside.\n            outer_extra = out_d * thickness * math.pi * 0.5\n            inner_extra = total_offset - outer_extra\n\n            # Work it out in terms of right and left\n            if index % 2 == 0:\n                left, right = inner_extra, outer_extra\n            else:\n                left, right = outer_extra, inner_extra\n\n            # Add the new margins\n            margined = margins.MarginsLM(0, right, 0, left, element)\n            elements[index] = margined\n\n    # Come up with the output plan: the order of pages to output.\n    output_elements = []\n    for sig in range(signatures_needed):\n        sig_offset = sig * pages_per_signature\n\n        # Add the signature mark to the start page of the\n        # signature.\n        if signature_mark > 0:\n            elements[sig_offset] = overlay.OverlayLM(\n                elements = [\n                    elements[sig_offset],\n                    mark.SignatureMark(sig, signatures_needed, signature_mark)\n                    ]\n                )\n\n        if fold_then_collate:\n            # We fold and cut each sheet, then combine them into\n            # their signatures.\n            for sheet in range(sheets_per_sig):\n                offset = sig_offset + sheet * pages_per_side\n                second_half_offset = \\\n                    offset + pages_per_signature - (sheet+1)*pages_per_sheet\n\n                for index, slot in enumerate(pattern):\n                    if slot > pages_per_side:\n                        page_index = second_half_offset + slot - 1\n                    else:\n                        page_index = offset + slot - 1\n\n                    if page_index >= num_pages:\n                        output_elements.append(None)\n                    else:\n                        output_elements.append(elements[page_index])\n\n        else:\n            # We collate the sheets together, then fold them as a whole\n            # and cut to form the signature.\n            sig_elements = [None] * pages_per_signature\n            page_number = 0\n            increasing = True\n            for pattern_index in range(0, pages_per_sheet, 2):\n                # We're looping for each double folio in the sheet\n\n                # Find where these folios are in the pattern\n                location_in_pattern = [\n                    pattern.index(pattern_index+1),\n                    pattern.index(pattern_index+2)\n                    ]\n\n                # Go through each sheet in the signature\n                for sheet in range(sheets_per_sig):\n                    sheet_number = \\\n                        sheet if increasing else sheets_per_sig-1-sheet\n\n                    # Place the next page at this given location\n                    for page in range(2):\n                        slot_index = (\n                            sheet_number * pages_per_sheet +\n                            location_in_pattern[page]\n                            )\n                        page_index = page_number + sig_offset\n                        if page_index < num_pages:\n                            sig_elements[slot_index] = elements[page_index]\n\n                        page_number += 1\n\n                # Next time through, go in the reverse order.\n                increasing = not increasing\n\n            # Add all the elements for this signature to the whole\n            output_elements.extend(sig_elements)\n\n\n\n    # Invert the relevant pages\n    for index, element in enumerate(output_elements):\n        # Check if it needs to be upside down.\n        row_from_bottom = rows - 1 - (index % pages_per_side) // cols\n        if element is not None and row_from_bottom % 2 > 0:\n            output_elements[index] = transform.RotateLM(2, element)\n\n    # Split them into simple grids and pages.\n    pages = []\n    for index in range(0, len(output_elements), pages_per_side):\n        side_elements = output_elements[index:index+pages_per_side]\n        pages.append(grid.SimpleGridLM(\n                cols, rows, margin=0, elements=side_elements\n                ))\n    return pages", "response": "This function calculates the impositions for the elements in the content list and returns a set of page - layouts for each element in the content list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclose the internal epoll file descriptor if it isn t closed.", "response": "def close(self):\n        \"\"\"\n        Close the internal epoll file descriptor if it isn't closed\n\n        :raises OSError:\n            If the underlying ``close(2)`` fails. The error message matches\n            those found in the manual page.\n        \"\"\"\n        with self._close_lock:\n            epfd = self._epfd\n            if epfd >= 0:\n                self._epfd = -1\n                close(epfd)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an epoll object from a given file descriptor.", "response": "def fromfd(cls, fd):\n        \"\"\"\n        Create a new epoll object from a given file descriptor\n\n        :param fd:\n            A pre-made file descriptor obtained from ``epoll_create(2)`` or\n            ``epoll_create1(2)``\n        :raises ValueError:\n            If fd is not a valid file descriptor\n        :returns:\n            A new epoll object\n\n        .. note::\n            If the passed descriptor is incorrect then various methods will\n            fail and raise OSError with an appropriate message.\n        \"\"\"\n        if fd < 0:\n            _err_closed()\n        self = cls.__new__()\n        object.__init__(self)\n        self._epfd = fd\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register(self, fd, eventmask=None):\n        if self._epfd < 0:\n            _err_closed()\n        if eventmask is None:\n            eventmask = EPOLLIN | EPOLLOUT | EPOLLPRI\n        ev = epoll_event()\n        ev.events = eventmask\n        ev.data.fd = fd\n        epoll_ctl(self._epfd, EPOLL_CTL_ADD, fd, byref(ev))", "response": "Register a new descriptor with the entry point."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef modify(self, fd, eventmask):\n        if self._epfd < 0:\n            _err_closed()\n        ev = epoll_event()\n        ev.events = eventmask\n        ev.data.fd = fd\n        epoll_ctl(self._epfd, EPOLL_CTL_MOD, fd, byref(ev))", "response": "Modify the bit - mask of events associated with a previously - registered entry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npoll for events from the internal file descriptor.", "response": "def poll(self, timeout=-1, maxevents=-1):\n        \"\"\"\n        Poll for events\n\n        :param timeout:\n            The amount of seconds to wait for events before giving up. The\n            default value, -1, represents infinity. Note that unlike the\n            underlying ``epoll_wait()`` timeout is a fractional number\n            representing **seconds**.\n        :param maxevents:\n            The maximum number of events to report. The default is a\n            reasonably-sized maximum, identical to the one selected by\n            Python 3.4.\n        :returns:\n            A list of (fd, events) that were reported or an empty list if the\n            timeout elapsed.\n        :raises ValueError:\n            If :meth:`closed()` is True\n        :raises OSError:\n            If the underlying ``epoll_wait(2)`` fails. The error message\n            matches those found in the manual page.\n        \"\"\"\n        if self._epfd < 0:\n            _err_closed()\n        if timeout != -1:\n            # 1000 because epoll_wait(2) uses milliseconds\n            timeout = int(timeout * 1000)\n        if maxevents == -1:\n            maxevents = FD_SETSIZE - 1\n        events = (epoll_event * maxevents)()\n        num_events = epoll_wait(\n            self._epfd, cast(byref(events), POINTER(epoll_event)),\n            maxevents, timeout)\n        return [(events[i].data.fd, events[i].events)\n                for i in range(num_events)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_unicode(path, errors=\"replace\"):\n    if isinstance(path, UNICODE):\n        return path\n    return path.decode(sys.getfilesystemencoding(), errors)", "response": "Given a bytestring or unicode path return it as unicode."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef guess_autoescape(self, template_name):\n        if template_name is None or '.' not in template_name:\n            return False\n        ext = template_name.rsplit('.', 1)[1]\n        return ext in ('html', 'xhtml', 'htm', 'xml')", "response": "Guess if we should autoescape the given template name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate(self, schema_str, xml_valid):\n        # TODO: be able to get doc for error given an xsd.\n        # Changed path to allow have xsd that are imported by others xsd in the\n        # same library, and not call to SAT page each time that is generated\n        # a new XML.\n        with change_path():\n            path = os.path.join(\n                os.path.dirname(os.path.realpath(__file__)), 'templates')\n            os.chdir(path)\n            schema_root = etree.parse(StringIO(schema_str))\n            schema = etree.XMLSchema(schema_root)\n        try:\n            tree = etree.parse(StringIO(xml_valid.encode('UTF-8')))\n            schema.assertValid(tree)\n        except etree.DocumentInvalid as ups:\n            self.ups = ups\n        finally:\n            if self.ups:\n                self.valid = False\n            else:\n                self.valid = True\n            return self.valid", "response": "Compare the valid information on an xml from given schema."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the document xml just rendered already validated against xsd to be signed.", "response": "def set_xml(self):\n        \"\"\"Set document xml just rendered already\n        validated against xsd to be signed.\n\n        :params boolean debug_mode: Either if you want\n            the rendered template to be saved either it\n        is valid or not with the given schema.\n        :returns boolean: Either was valid or not the generated document.\n        \"\"\"\n        cached = StringIO()\n        document = u''\n        try:\n            document = self.template.render(inv=self)\n        except UndefinedError as ups:\n            self.ups = ups\n\n        # TODO: Here should be called the cleanup 'Just before the validation'.\n        valid = self.validate(self.schema, document)\n        self.document = document\n        if valid:\n            document = etree.XML(document)\n            self.document = etree.tostring(document,\n                                           pretty_print=True,\n                                           xml_declaration=True,\n                                           encoding='utf-8')\n            # TODO: When Document Generated, this this should not fail either.\n            # Caching just when valid then.\n            cached.write(self.document is not None and self.document or u'')\n            cached.seek(0)\n            self.document_path = cached"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_documentation(self, element, namespace=None, schema_str=None):\n        if namespace is None:\n            namespace = {'xs': 'http://www.w3.org/2001/XMLSchema'}\n        schema_root = etree.parse(StringIO(self.schema))\n        document = schema_root.xpath(self.get_element_from_clark(element),\n                                     namespaces=namespace)\n        return document and document[0].text or ''", "response": "This method returns a documentation text from the Clark s Notation_COOKIE XML schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, session, words, time='DAY|WEEK|MONTH|3MONTH', aFilter='PV|CLICK|AVGCPC|COMPETITION', nick=None):\n        '''taobao.simba.insight.wordsbase.get\n        ===================================\n        \u8bcd\u57fa\u7840\u6570\u636e\u67e5\u8be2'''\n        request = TOPRequest('taobao.simba.insight.wordsbase.get')\n        request['words'] = words\n        request['time'] = time\n        request['filter'] = aFilter\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request, session))\n        return self.result", "response": "TAOBAO. simba. wordsbase. get"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, wordCategories, aFilter='PV|CLICK|AVGCPC|COMPETITION', nick=None):\n        '''taobao.simba.insight.wordscats.get\n        ===================================\n        \u8bcd\u548c\u7c7b\u76ee\u67e5\u8be2'''\n        request = TOPRequest('taobao.simba.insight.wordscats.get')\n        request['wordCategories'] = wordCategories\n        request['filter'] = aFilter\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request))\n        return self.result", "response": "TAOBAO. simba. wordscats. get"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef changed_get(self, start_time, nick=None, page_size=200, page_no=1):\n        '''taobao.simba.creativeids.changed.get\n        ===================================\n        \u83b7\u53d6\u4fee\u6539\u7684\u521b\u610fID'''\n        request = TOPRequest('taobao.simba.creativeids.changed.get')\n        request['start_time'] = start_time\n        request['page_size'] = page_size\n        request['page_no'] = page_no\n        if nick!=None: request['nick'] = nick\n        self.create(self.execute(request), models={'result':INCategory})\n        return self.result", "response": "TAOBAO. simba. creativeids. changed. get \u83b7\u53d6\u4fee\u6539\u7684\u521b\u610fID"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a mxn sparse matrix with random nonzeros.", "response": "def sp_rand(m,n,a):\n    \"\"\"\n    Generates an mxn sparse 'd' matrix with round(a*m*n) nonzeros.\n    \"\"\"\n    if m == 0 or n == 0: return spmatrix([], [], [], (m,n))\n    nnz = min(max(0, int(round(a*m*n))), m*n)\n    nz = matrix(random.sample(range(m*n), nnz), tc='i')\n    return spmatrix(normal(nnz,1), nz%m, matrix([int(ii) for ii in nz/m]), (m,n))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a single record by uid", "response": "def get_record(uid=None):\n    \"\"\"Get a single record\n    \"\"\"\n    obj = None\n    if uid is not None:\n        obj = get_object_by_uid(uid)\n    else:\n        obj = get_object_by_request()\n    if obj is None:\n        fail(404, \"No object found\")\n    complete = req.get_complete(default=_marker)\n    if complete is _marker:\n        complete = True\n    items = make_items_for([obj], complete=complete)\n    return u.first(items)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_batched(portal_type=None, uid=None, endpoint=None, **kw):\n\n    # fetch the catalog results\n    results = get_search_results(portal_type=portal_type, uid=uid, **kw)\n\n    # fetch the batch params from the request\n    size = req.get_batch_size()\n    start = req.get_batch_start()\n\n    # check for existing complete flag\n    complete = req.get_complete(default=_marker)\n    if complete is _marker:\n        # if the uid is given, get the complete information set\n        complete = uid and True or False\n\n    # return a batched record\n    return get_batch(results, size, start, endpoint=endpoint,\n                     complete=complete)", "response": "Get a batched record\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate items in the target folder", "response": "def create_items(portal_type=None, uid=None, endpoint=None, **kw):\n    \"\"\" create items\n\n    1. If the uid is given, get the object and create the content in there\n       (assumed that it is folderish)\n    2. If the uid is 0, the target folder is assumed the portal.\n    3. If there is no uid given, the payload is checked for either a key\n        - `parent_uid`  specifies the *uid* of the target folder\n        - `parent_path` specifies the *physical path* of the target folder\n    \"\"\"\n\n    # disable CSRF\n    req.disable_csrf_protection()\n\n    # destination where to create the content\n    container = uid and get_object_by_uid(uid) or None\n\n    # extract the data from the request\n    records = req.get_request_data()\n\n    results = []\n    for record in records:\n\n        # get the portal_type\n        if portal_type is None:\n            # try to fetch the portal type out of the request data\n            portal_type = record.pop(\"portal_type\", None)\n\n        # check if it is allowed to create the portal_type\n        if not is_creation_allowed(portal_type):\n            fail(401, \"Creation of '{}' is not allowed\".format(portal_type))\n\n        if container is None:\n            # find the container for content creation\n            container = find_target_container(portal_type, record)\n\n        # Check if we have a container and a portal_type\n        if not all([container, portal_type]):\n            fail(400, \"Please provide a container path/uid and portal_type\")\n\n        # create the object and pass in the record data\n        obj = create_object(container, portal_type, **record)\n        results.append(obj)\n\n    if not results:\n        fail(400, \"No Objects could be created\")\n\n    return make_items_for(results, endpoint=endpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_items(portal_type=None, uid=None, endpoint=None, **kw):\n\n    # disable CSRF\n    req.disable_csrf_protection()\n\n    # the data to update\n    records = req.get_request_data()\n\n    # we have an uid -> try to get an object for it\n    obj = get_object_by_uid(uid)\n    if obj:\n        record = records[0]  # ignore other records if we got an uid\n        obj = update_object_with_data(obj, record)\n        return make_items_for([obj], endpoint=endpoint)\n\n    # no uid -> go through the record items\n    results = []\n    for record in records:\n        obj = get_object_by_record(record)\n\n        # no object found for this record\n        if obj is None:\n            continue\n\n        # update the object with the given record data\n        obj = update_object_with_data(obj, record)\n        results.append(obj)\n\n    if not results:\n        fail(400, \"No Objects could be updated\")\n\n    return make_items_for(results, endpoint=endpoint)", "response": "update items with the given data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete items from the object store", "response": "def delete_items(portal_type=None, uid=None, endpoint=None, **kw):\n    \"\"\" delete items\n\n    1. If the uid is given, we can ignore the request body and delete the\n       object with the given uid (if the uid was valid).\n    2. If no uid is given, the user wants to delete more than one item.\n       => go through each item and extract the uid. Delete it afterwards.\n       // we should do this kind of transaction base. So if we can not get an\n       // object for an uid, no item will be deleted.\n    3. we could check if the portal_type matches, just to be sure the user\n       wants to delete the right content.\n    \"\"\"\n\n    # disable CSRF\n    req.disable_csrf_protection()\n\n    # try to find the requested objects\n    objects = find_objects(uid=uid)\n\n    # We don't want to delete the portal object\n    if filter(lambda o: is_root(o), objects):\n        fail(400, \"Can not delete the portal object\")\n\n    results = []\n    for obj in objects:\n        # We deactivate only!\n        deactivate_object(obj)\n        info = IInfo(obj)()\n        results.append(info)\n\n    if not results:\n        fail(404, \"No Objects could be found\")\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating API compatible data items for the given list of objects or brains.", "response": "def make_items_for(brains_or_objects, endpoint=None, complete=False):\n    \"\"\"Generate API compatible data items for the given list of brains/objects\n\n    :param brains_or_objects: List of objects or brains\n    :type brains_or_objects: list/Products.ZCatalog.Lazy.LazyMap\n    :param endpoint: The named URL endpoint for the root of the items\n    :type endpoint: str/unicode\n    :param complete: Flag to wake up the object and fetch all data\n    :type complete: bool\n    :returns: A list of extracted data items\n    :rtype: list\n    \"\"\"\n\n    # check if the user wants to include children\n    include_children = req.get_children(False)\n\n    def extract_data(brain_or_object):\n        info = get_info(brain_or_object, endpoint=endpoint, complete=complete)\n        if include_children and is_folderish(brain_or_object):\n            info.update(get_children_info(brain_or_object, complete=complete))\n        return info\n\n    return map(extract_data, brains_or_objects)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_info(brain_or_object, endpoint=None, complete=False):\n\n    # also extract the brain data for objects\n    if not is_brain(brain_or_object):\n        brain_or_object = get_brain(brain_or_object)\n        if brain_or_object is None:\n            logger.warn(\"Couldn't find/fetch brain of {}\".format(brain_or_object))\n            return {}\n        complete = True\n\n    # When querying uid catalog we have to be sure that we skip the objects\n    # used to relate two or more objects\n    if is_relationship_object(brain_or_object):\n        logger.warn(\"Skipping relationship object {}\".format(repr(brain_or_object)))\n        return {}\n    \n    # extract the data from the initial object with the proper adapter\n    info = IInfo(brain_or_object).to_dict()\n\n    # update with url info (always included)\n    url_info = get_url_info(brain_or_object, endpoint)\n    info.update(url_info)\n\n    # include the parent url info\n    parent = get_parent_info(brain_or_object)\n    info.update(parent)\n\n    # add the complete data of the object if requested\n    # -> requires to wake up the object if it is a catalog brain\n    if complete:\n        # ensure we have a full content object\n        obj = api.get_object(brain_or_object)\n        # get the compatible adapter\n        adapter = IInfo(obj)\n        # update the data set with the complete information\n        info.update(adapter.to_dict())\n\n        # update the data set with the workflow information\n        # -> only possible if `?complete=yes&workflow=yes`\n        if req.get_workflow(False):\n            info.update(get_workflow_info(obj))\n\n        # # add sharing data if the user requested it\n        # # -> only possible if `?complete=yes`\n        # if req.get_sharing(False):\n        #     sharing = get_sharing_info(obj)\n        #     info.update({\"sharing\": sharing})\n\n    return info", "response": "Extract the data from the catalog brain or content object and return the corresponding data mapping for the object"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate url information for the content object", "response": "def get_url_info(brain_or_object, endpoint=None):\n    \"\"\"Generate url information for the content object/catalog brain\n\n    :param brain_or_object: A single catalog brain or content object\n    :type brain_or_object: ATContentType/DexterityContentType/CatalogBrain\n    :param endpoint: The named URL endpoint for the root of the items\n    :type endpoint: str/unicode\n    :returns: URL information mapping\n    :rtype: dict\n    \"\"\"\n\n    # If no endpoint was given, guess the endpoint by portal type\n    if endpoint is None:\n        endpoint = get_endpoint(brain_or_object)\n\n    uid = get_uid(brain_or_object)\n    portal_type = get_portal_type(brain_or_object)\n    resource = portal_type_to_resource(portal_type)\n\n    return {\n        \"uid\": uid,\n        \"url\": get_url(brain_or_object),\n        \"api_url\": url_for(endpoint, resource=resource, uid=uid),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates url information for the parent object", "response": "def get_parent_info(brain_or_object, endpoint=None):\n    \"\"\"Generate url information for the parent object\n\n    :param brain_or_object: A single catalog brain or content object\n    :type brain_or_object: ATContentType/DexterityContentType/CatalogBrain\n    :param endpoint: The named URL endpoint for the root of the items\n    :type endpoint: str/unicode\n    :returns: URL information mapping\n    :rtype: dict\n    \"\"\"\n\n    # special case for the portal object\n    if is_root(brain_or_object):\n        return {}\n\n    # get the parent object\n    parent = get_parent(brain_or_object)\n    portal_type = get_portal_type(parent)\n    resource = portal_type_to_resource(portal_type)\n\n    # fall back if no endpoint specified\n    if endpoint is None:\n        endpoint = get_endpoint(parent)\n\n    return {\n        \"parent_id\": get_id(parent),\n        \"parent_uid\": get_uid(parent),\n        \"parent_url\": url_for(endpoint, resource=resource, uid=get_uid(parent))\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate data items of the contained contents of the object", "response": "def get_children_info(brain_or_object, complete=False):\n    \"\"\"Generate data items of the contained contents\n\n    :param brain_or_object: A single catalog brain or content object\n    :type brain_or_object: ATContentType/DexterityContentType/CatalogBrain\n    :param complete: Flag to wake up the object and fetch all data\n    :type complete: bool\n    :returns: info mapping of contained content items\n    :rtype: list\n    \"\"\"\n\n    # fetch the contents (if folderish)\n    children = get_contents(brain_or_object)\n\n    def extract_data(brain_or_object):\n        return get_info(brain_or_object, complete=complete)\n    items = map(extract_data, children)\n\n    return {\n        \"children_count\": len(items),\n        \"children\": items\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_file_info(obj, fieldname, default=None):\n\n    # extract the file field from the object if omitted\n    field = get_field(obj, fieldname)\n\n    # get the value with the fieldmanager\n    fm = IFieldManager(field)\n\n    # return None if we have no file data\n    if fm.get_size(obj) == 0:\n        return None\n\n    out = {\n        \"content_type\": fm.get_content_type(obj),\n        \"filename\": fm.get_filename(obj),\n        \"download\": fm.get_download_url(obj),\n    }\n\n    # only return file data only if requested (?filedata=yes)\n    if req.get_filedata(False):\n        data = fm.get_data(obj)\n        out[\"data\"] = data.encode(\"base64\")\n\n    return out", "response": "Extract file data from a file field"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating the workflow information of the assigned workflows", "response": "def get_workflow_info(brain_or_object, endpoint=None):\n    \"\"\"Generate workflow information of the assigned workflows\n\n    :param brain_or_object: A single catalog brain or content object\n    :type brain_or_object: ATContentType/DexterityContentType/CatalogBrain\n    :param endpoint: The named URL endpoint for the root of the items\n    :type endpoint: str/unicode\n    :returns: Workflows info\n    :rtype: dict\n    \"\"\"\n\n    # ensure we have a full content object\n    obj = get_object(brain_or_object)\n\n    # get the portal workflow tool\n    wf_tool = get_tool(\"portal_workflow\")\n\n    # the assigned workflows of this object\n    workflows = wf_tool.getWorkflowsFor(obj)\n\n    # no worfkflows assigned -> return\n    if not workflows:\n        return []\n\n    def to_transition_info(transition):\n        \"\"\" return the transition information\n        \"\"\"\n        return {\n            \"title\": transition[\"title\"],\n            \"value\": transition[\"id\"],\n            \"display\": transition[\"description\"],\n            \"url\": transition[\"url\"],\n        }\n\n    def to_review_history_info(review_history):\n        \"\"\" return the transition information\n        \"\"\"\n        converted = DT2dt(review_history.get('time')).\\\n            strftime(\"%Y-%m-%d %H:%M:%S\")\n        review_history['time'] = converted\n        return review_history\n\n    out = []\n\n    for workflow in workflows:\n\n        # get the status info of the current state (dictionary)\n        info = wf_tool.getStatusOf(workflow.getId(), obj)\n        if info is None:\n            continue\n\n        # get the current review_status\n        review_state = info.get(\"review_state\", None)\n        inactive_state = info.get(\"inactive_state\", None)\n        cancellation_state = info.get(\"cancellation_state\", None)\n        worksheetanalysis_review_state = info.get(\"worksheetanalysis_review_state\", None)\n\n        state = review_state or \\\n            inactive_state or \\\n            cancellation_state or \\\n            worksheetanalysis_review_state\n\n        if state is None:\n            logger.warn(\"No state variable found for {} -> {}\".format(\n                repr(obj), info))\n            continue\n\n        # get the wf status object\n        status_info = workflow.states[state]\n\n        # get the title of the current status\n        status = status_info.title\n\n        # get the transition informations\n        transitions = map(to_transition_info, wf_tool.getTransitionsFor(obj))\n\n        # get the review history\n        rh = map(to_review_history_info,\n                 workflow.getInfoFor(obj, 'review_history', ''))\n\n        out.append({\n            \"workflow\": workflow.getId(),\n            \"status\": status,\n            \"review_state\": state,\n            \"transitions\": transitions,\n            \"review_history\": rh,\n        })\n\n    return {\"workflow_info\": out}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef search(**kw):\n    portal = get_portal()\n    catalog = ICatalog(portal)\n    catalog_query = ICatalogQuery(catalog)\n    query = catalog_query.make_query(**kw)\n    return catalog(query)", "response": "Search the catalog adapter\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches the catalog and return the results", "response": "def get_search_results(portal_type=None, uid=None, **kw):\n    \"\"\"Search the catalog and return the results\n\n    :returns: Catalog search results\n    :rtype: iterable\n    \"\"\"\n\n    # If we have an UID, return the object immediately\n    if uid is not None:\n        logger.info(\"UID '%s' found, returning the object immediately\" % uid)\n        return u.to_list(get_object_by_uid(uid))\n\n    # allow to search search for the Plone Site with portal_type\n    include_portal = False\n    if u.to_string(portal_type) == \"Plone Site\":\n        include_portal = True\n\n    # The request may contain a list of portal_types, e.g.\n    # `?portal_type=Document&portal_type=Plone Site`\n    if \"Plone Site\" in u.to_list(req.get(\"portal_type\")):\n        include_portal = True\n\n    # Build and execute a catalog query\n    results = search(portal_type=portal_type, uid=uid, **kw)\n\n    if include_portal:\n        results = list(results) + u.to_list(get_portal())\n\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a ZCatalog brain for the object", "response": "def get_brain(brain_or_object):\n    \"\"\"Return a ZCatalog brain for the object\n\n    :param brain_or_object: A single catalog brain or content object\n    :type brain_or_object: ATContentType/DexterityContentType/CatalogBrain\n    :returns: True if the object is a catalog brain\n    :rtype: bool\n    \"\"\"\n    if is_brain(brain_or_object):\n        return brain_or_object\n    if is_root(brain_or_object):\n        return brain_or_object\n\n    # fetch the brain by UID\n    uid = get_uid(brain_or_object)\n    uc = get_tool(\"uid_catalog\")\n    results = uc({\"UID\": uid}) or search(query={'UID': uid})\n    if len(results) == 0:\n        return None\n    if len(results) > 1:\n        fail(500, \"More than one object with UID={} found in portal_catalog\".format(uid))\n    return results[0]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_fields(brain_or_object):\n    obj = get_object(brain_or_object)\n    # The portal object has no schema\n    if is_root(obj):\n        return {}\n    schema = get_schema(obj)\n    if is_dexterity_content(obj):\n        names = schema.names()\n        fields = map(lambda name: schema.get(name), names)\n        schema_fields = dict(zip(names, fields))\n        # update with behavior fields\n        schema_fields.update(get_behaviors(obj))\n        return schema_fields\n    return dict(zip(schema.keys(), schema.fields()))", "response": "Get the list of fields from the object\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_field(brain_or_object, name, default=None):\n    fields = get_fields(brain_or_object)\n    return fields.get(name, default)", "response": "Return the named field"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_behaviors(brain_or_object):\n    obj = get_object(brain_or_object)\n    if not is_dexterity_content(obj):\n        fail(400, \"Only Dexterity contents can have assigned behaviors\")\n    assignable = IBehaviorAssignable(obj, None)\n    if not assignable:\n        return {}\n    out = {}\n    for behavior in assignable.enumerateBehaviors():\n        for name, field in getFields(behavior.interface).items():\n            out[name] = field\n    return out", "response": "Iterate over all behaviors that are assigned to the object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_uid(uid):\n    if not isinstance(uid, basestring):\n        return False\n    if uid != \"0\" and len(uid) != 32:\n        return False\n    return True", "response": "Checks if the passed in uid is a valid UID\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_path(path):\n    if not isinstance(path, basestring):\n        return False\n    portal_path = get_path(get_portal())\n    if not path.startswith(portal_path):\n        return False\n    obj = get_object_by_path(path)\n    if obj is None:\n        return False\n    return True", "response": "Checks if the passed in path is a valid Path within the portal\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculate_delta_date(literal):\n    mapping = {\n        \"today\": 0,\n        \"yesterday\": 1,\n        \"this-week\": 7,\n        \"this-month\": 30,\n        \"this-year\": 365,\n    }\n    today = DateTime(DateTime().Date())  # current date without the time\n    return today - mapping.get(literal, 0)", "response": "Calculate the date in the past from the given date literal"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_json_value(obj, fieldname, value=_marker, default=None):\n\n    # This function bridges the value of the field to a probably more complex\n    # JSON structure to return to the client.\n\n    # extract the value from the object if omitted\n    if value is _marker:\n        value = IDataManager(obj).json_data(fieldname)\n\n    # convert objects\n    if isinstance(value, ImplicitAcquisitionWrapper):\n        return get_url_info(value)\n\n    # check if the value is callable\n    if callable(value):\n        value = value()\n\n    # convert dates\n    if is_date(value):\n        return to_iso_date(value)\n\n    # check if the value is JSON serializable\n    if not is_json_serializable(value):\n        logger.warn(\"Output {} is not JSON serializable\".format(repr(value)))\n        return default\n\n    return value", "response": "Convert the value of a field to a JSON encoded value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_date(thing):\n    # known date types\n    date_types = (datetime.datetime,\n                  datetime.date,\n                  DateTime)\n    return isinstance(thing, date_types)", "response": "Checks if the given object represents a date object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_iso_date(date, default=None):\n\n    # not a date\n    if not is_date(date):\n        return default\n\n    # handle Zope DateTime objects\n    if isinstance(date, (DateTime)):\n        return date.ISO8601()\n\n    # handle python datetime objects\n    return date.isoformat()", "response": "Returns the ISO representation of the date object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of all contents of the object in the catalog.", "response": "def get_contents(brain_or_object):\n    \"\"\"Lookup folder contents for this object.\n\n    :param brain_or_object: A single catalog brain or content object\n    :type brain_or_object: ATContentType/DexterityContentType/CatalogBrain\n    :returns: List of contained contents\n    :rtype: list/Products.ZCatalog.Lazy.LazyMap\n    \"\"\"\n\n    # Nothing to do if the object is contentish\n    if not is_folderish(brain_or_object):\n        return []\n\n    # Returning objects (not brains) to make sure we do not miss any child.\n    # It may happen when children belong to different catalogs and not\n    # found on 'portal_catalog'.\n    ret = filter(lambda obj: api.is_object(obj),\n                 api.get_object(brain_or_object).objectValues())\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_parent(brain_or_object):\n\n    if is_root(brain_or_object):\n        return get_portal()\n\n    if is_brain(brain_or_object):\n        parent_path = get_parent_path(brain_or_object)\n        return get_object_by_path(parent_path)\n\n    return brain_or_object.aq_parent", "response": "Locate the parent object of the content or catalog brain"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_resource_mapping():\n    portal_types = get_portal_types()\n    resources = map(portal_type_to_resource, portal_types)\n    return dict(zip(resources, portal_types))", "response": "Map resources used in the routes to portal types\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resource_to_portal_type(resource):\n    if resource is None:\n        return None\n\n    resource_mapping = get_resource_mapping()\n    portal_type = resource_mapping.get(resource.lower())\n\n    if portal_type is None:\n        logger.warn(\"Could not map the resource '{}' \"\n                    \"to any known portal type\".format(resource))\n\n    return portal_type", "response": "Converts a resource name to a portal type name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_container_for(portal_type):\n    container_paths = config.CONTAINER_PATHS_FOR_PORTAL_TYPES\n    container_path = container_paths.get(portal_type)\n\n    if container_path is None:\n        return None\n\n    portal_path = get_path(get_portal())\n    return get_object_by_path(\"/\".join([portal_path, container_path]))", "response": "Returns the single holding container object of this portal type"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef url_for(endpoint, default=DEFAULT_ENDPOINT, **values):\n\n    try:\n        return router.url_for(endpoint, force_external=True, values=values)\n    except Exception:\n        logger.warn(\"Could not build API URL for endpoint '%s'. \"\n                    \"No route provider registered?\" % endpoint)\n        # build generic API URL\n        return router.url_for(default, force_external=True, values=values)", "response": "Looks up the API URL for the given endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the endpoint for this object", "response": "def get_endpoint(brain_or_object, default=DEFAULT_ENDPOINT):\n    \"\"\"Calculate the endpoint for this object\n\n    :param brain_or_object: A single catalog brain or content object\n    :type brain_or_object: ATContentType/DexterityContentType/CatalogBrain\n    :returns: Endpoint for this object\n    :rtype: string\n    \"\"\"\n    portal_type = get_portal_type(brain_or_object)\n    resource = portal_type_to_resource(portal_type)\n\n    # Try to get the right namespaced endpoint\n    endpoints = router.DefaultRouter.view_functions.keys()\n    if resource in endpoints:\n        return resource  # exact match\n    endpoint_candidates = filter(lambda e: e.endswith(resource), endpoints)\n    if len(endpoint_candidates) == 1:\n        # only return the namespaced endpoint, if we have an exact match\n        return endpoint_candidates[0]\n\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninspects request the record to locate an object by a given record", "response": "def get_object_by_record(record):\n    \"\"\"Find an object by a given record\n\n    Inspects request the record to locate an object\n\n    :param record: A dictionary representation of an object\n    :type record: dict\n    :returns: Found Object or None\n    :rtype: object\n    \"\"\"\n\n    # nothing to do here\n    if not record:\n        return None\n\n    if record.get(\"uid\"):\n        return get_object_by_uid(record[\"uid\"])\n    if record.get(\"path\"):\n        return get_object_by_path(record[\"path\"])\n    if record.get(\"parent_path\") and record.get(\"id\"):\n        path = \"/\".join([record[\"parent_path\"], record[\"id\"]])\n        return get_object_by_path(path)\n\n    logger.warn(\"get_object_by_record::No object found! record='%r'\" % record)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds an object by a given physical path", "response": "def get_object_by_path(path):\n    \"\"\"Find an object by a given physical path\n\n    :param path: The physical path of the object to find\n    :type path: string\n    :returns: Found Object or None\n    :rtype: object\n    \"\"\"\n\n    # nothing to do here\n    if not isinstance(path, basestring):\n        return None\n\n    # path must be a string\n    path = str(path)\n\n    portal = get_portal()\n    portal_path = get_path(portal)\n\n    if path == portal_path:\n        return portal\n\n    if path.startswith(portal_path):\n        segments = path.split(\"/\")\n        path = \"/\".join(segments[2:])\n\n    try:\n        return portal.restrictedTraverse(str(path))\n    except (KeyError, AttributeError):\n        fail(404, \"No object could be found at {}\".format(str(path)))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_member_ids():\n    pm = get_tool(\"portal_membership\")\n    member_ids = pm.listMemberIds()\n    # How can it be possible to get member ids with None?\n    return filter(lambda x: x, member_ids)", "response": "Returns all member ids of the portal.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning Plone User object", "response": "def get_user(user_or_username=None):\n    \"\"\"Return Plone User\n\n    :param user_or_username: Plone user or user id\n    :type groupname:  PloneUser/MemberData/str\n    :returns: Plone MemberData\n    :rtype: object\n    \"\"\"\n    if user_or_username is None:\n        return None\n    if hasattr(user_or_username, \"getUserId\"):\n        return ploneapi.user.get(user_or_username.getUserId())\n    return ploneapi.user.get(userid=u.to_string(user_or_username))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding the object by its UID", "response": "def find_objects(uid=None):\n    \"\"\"Find the object by its UID\n\n    1. get the object from the given uid\n    2. fetch objects specified in the request parameters\n    3. fetch objects located in the request body\n\n    :param uid: The UID of the object to find\n    :type uid: string\n    :returns: List of found objects\n    :rtype: list\n    \"\"\"\n    # The objects to cut\n    objects = []\n\n    # get the object by the given uid or try to find it by the request\n    # parameters\n    obj = get_object_by_uid(uid) or get_object_by_request()\n\n    if obj:\n        objects.append(obj)\n    else:\n        # no uid -> go through the record items\n        records = req.get_request_data()\n        for record in records:\n            # try to get the object by the given record\n            obj = get_object_by_record(record)\n\n            # no object found for this record\n            if obj is None:\n                continue\n            objects.append(obj)\n\n    return objects"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlocates a target container for the given portal_type and record.", "response": "def find_target_container(portal_type, record):\n    \"\"\"Locates a target container for the given portal_type and record\n\n    :param record: The dictionary representation of a content object\n    :type record: dict\n    :returns: folder which contains the object\n    :rtype: object\n    \"\"\"\n    portal_type = portal_type or record.get(\"portal_type\")\n    container = get_container_for(portal_type)\n    if container:\n        return container\n\n    parent_uid = record.pop(\"parent_uid\", None)\n    parent_path = record.pop(\"parent_path\", None)\n\n    target = None\n\n    # Try to find the target object\n    if parent_uid:\n        target = get_object_by_uid(parent_uid)\n    elif parent_path:\n        target = get_object_by_path(parent_path)\n    else:\n        fail(404, \"No target UID/PATH information found\")\n\n    if not target:\n        fail(404, \"No target container found\")\n\n    return target"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates an object of the given portal_type and data.", "response": "def create_object(container, portal_type, **data):\n    \"\"\"Creates an object slug\n\n    :returns: The new created content object\n    :rtype: object\n    \"\"\"\n\n    if \"id\" in data:\n        # always omit the id as senaite LIMS generates a proper one\n        id = data.pop(\"id\")\n        logger.warn(\"Passed in ID '{}' omitted! Senaite LIMS \"\n                    \"generates a proper ID for you\" .format(id))\n\n    try:\n        # Special case for ARs\n        # => return immediately w/o update\n        if portal_type == \"AnalysisRequest\":\n            obj = create_analysisrequest(container, **data)\n            # Omit values which are already set through the helper\n            data = u.omit(data, \"SampleType\", \"Analyses\")\n            # Set the container as the client, as the AR lives in it\n            data[\"Client\"] = container\n        # Standard content creation\n        else:\n            # we want just a minimun viable object and set the data later\n            obj = api.create(container, portal_type)\n            # obj = api.create(container, portal_type, **data)\n    except Unauthorized:\n        fail(401, \"You are not allowed to create this content\")\n\n    # Update the object with the given data, but omit the id\n    try:\n        update_object_with_data(obj, data)\n    except APIError:\n\n        # Failure in creation process, delete the invalid object\n        container.manage_delObjects(obj.id)\n        # reraise the error\n        raise\n\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a minimun viable AnalysisRequest", "response": "def create_analysisrequest(container, **data):\n    \"\"\"Create a minimun viable AnalysisRequest\n\n    :param container: A single folderish catalog brain or content object\n    :type container: ATContentType/DexterityContentType/CatalogBrain\n    \"\"\"\n    container = get_object(container)\n    request = req.get_request()\n    # we need to resolve the SampleType to a full object\n    sample_type = data.get(\"SampleType\", None)\n    if sample_type is None:\n        fail(400, \"Please provide a SampleType\")\n\n    # TODO We should handle the same values as in the DataManager for this field\n    #      (UID, path, objects, dictionaries ...)\n    results = search(portal_type=\"SampleType\", title=sample_type)\n\n    values = {\n        \"Analyses\": data.get(\"Analyses\", []),\n        \"SampleType\": results and get_object(results[0]) or None,\n    }\n\n    return create_ar(container, request, values)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the content with the record data", "response": "def update_object_with_data(content, record):\n    \"\"\"Update the content with the record data\n\n    :param content: A single folderish catalog brain or content object\n    :type content: ATContentType/DexterityContentType/CatalogBrain\n    :param record: The data to update\n    :type record: dict\n    :returns: The updated content object\n    :rtype: object\n    :raises:\n        APIError,\n        :class:`~plone.jsonapi.routes.exceptions.APIError`\n    \"\"\"\n\n    # ensure we have a full content object\n    content = get_object(content)\n\n    # get the proper data manager\n    dm = IDataManager(content)\n\n    if dm is None:\n        fail(400, \"Update for this object is not allowed\")\n\n    # Iterate through record items\n    for k, v in record.items():\n        try:\n            success = dm.set(k, v, **record)\n        except Unauthorized:\n            fail(401, \"Not allowed to set the field '%s'\" % k)\n        except ValueError, exc:\n            fail(400, str(exc))\n\n        if not success:\n            logger.warn(\"update_object_with_data::skipping key=%r\", k)\n            continue\n\n        logger.debug(\"update_object_with_data::field %r updated\", k)\n\n    # Validate the entire content object\n    invalid = validate_object(content, record)\n    if invalid:\n        fail(400, u.to_json(invalid))\n\n    # do a wf transition\n    if record.get(\"transition\", None):\n        t = record.get(\"transition\")\n        logger.debug(\">>> Do Transition '%s' for Object %s\", t, content.getId())\n        do_transition_for(content, t)\n\n    # reindex the object\n    content.reindexObject()\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_object(brain_or_object, data):\n    obj = get_object(brain_or_object)\n\n    # Call the validator of AT Content Types\n    if is_at_content(obj):\n        return obj.validate(data=data)\n\n    return {}", "response": "Validate the entire object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeactivates the given object", "response": "def deactivate_object(brain_or_object):\n    \"\"\"Deactivate the given object\n\n    :param brain_or_object: A single catalog brain or content object\n    :type brain_or_object: ATContentType/DexterityContentType/CatalogBrain\n    :returns: Nothing\n    :rtype: None\n    \"\"\"\n    obj = get_object(brain_or_object)\n    # we do not want to delete the site root!\n    if is_root(obj):\n        fail(401, \"Deactivating the Portal is not allowed\")\n    try:\n        do_transition_for(brain_or_object, \"deactivate\")\n    except Unauthorized:\n        fail(401, \"Not allowed to deactivate object '%s'\" % obj.getId())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all the registry records whose name contains the specified keyword or all the registry items that contain the specified keyword.", "response": "def get_registry_records_by_keyword(keyword=None):\n    \"\"\"Get all the registry records (names and values) whose name\n     contains the specified keyword or, if keyword is None, return\n     all registry items\n\n    :param keyword: The keyword that has to be contained in the record name\n    :type keyword: str or None\n    :returns: Dictionary mapping the names of the found records to its values\n    \"\"\"\n    portal_reg = ploneapi.portal.get_tool(name=\"portal_registry\")\n    found_registers = {}\n    for record in portal_reg.records:\n        if keyword is None:\n            found_registers[record] = api.get_registry_record(record)\n        elif keyword.lower() in record.lower():\n            found_registers[record] = api.get_registry_record(record)\n    return found_registers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the settings associated to the specified keyword or all the settings.", "response": "def get_settings_by_keyword(keyword=None):\n    \"\"\"Get the settings associated to the specified keyword or, if\n     keyword is None, get all the settings.\n\n    :param keyword: settings to be retrieved\n    :return: dictionary with the settings plus a key to identify from which\n    keyword where retrieved.\n    \"\"\"\n    settings = []\n    if keyword is None:\n        # iterate over all the schemas to return all settings\n        for key, ischemas in CONTROLPANEL_INTERFACE_MAPPING.items():\n            settings_from_ifaces = map(get_settings_from_interface, ischemas)\n            settings_from_key = {k: v for d in settings_from_ifaces for k, v in d.items()}\n            settings.append({key: settings_from_key,\n                             \"api_url\": url_for(\"senaite.jsonapi.v1.settings\", key=key)})\n        return settings\n    # if keyword has value then get only the settings associated to the key\n    settings_from_ifaces = map(get_settings_from_interface, CONTROLPANEL_INTERFACE_MAPPING[keyword])\n    settings_from_key = {k: v for d in settings_from_ifaces for k, v in d.items()}\n    settings.append({keyword: settings_from_key,\n                     \"api_url\": url_for(\"senaite.jsonapi.v1.settings\", key=keyword)})\n    return settings"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_settings_from_interface(iface):\n    settings = {}\n    schema_id = iface.getName()\n    settings[schema_id] = {}\n    schema = getAdapter(api.get_portal(), iface)\n    for setting in getFieldNames(iface):\n        value = getattr(schema, setting, None)\n        if is_json_serializable(value):\n            settings[schema_id][setting] = value\n    return settings", "response": "Get the configuration settings associated to a schema object from which we want to get its\n    fields."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a batched result record out of a sequence", "response": "def get_batch(sequence, size, start=0, endpoint=None, complete=False):\n    \"\"\" create a batched result record out of a sequence (catalog brains)\n    \"\"\"\n\n    batch = make_batch(sequence, size, start)\n\n    return {\n        \"pagesize\": batch.get_pagesize(),\n        \"next\": batch.make_next_url(),\n        \"previous\": batch.make_prev_url(),\n        \"page\": batch.get_pagenumber(),\n        \"pages\": batch.get_numpages(),\n        \"count\": batch.get_sequence_length(),\n        \"items\": make_items_for([b for b in batch.get_batch()],\n                                endpoint, complete=complete),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _setHeaders(self, request):\n        request.responseHeaders.addRawHeader(b'content-type', b'application/json')\n        request.responseHeaders.addRawHeader(b'Access-Control-Allow-Origin', b'*')\n        request.responseHeaders.addRawHeader(b'Access-Control-Allow-Methods', b'GET, POST, PUT, DELETE')\n        request.responseHeaders.addRawHeader(b'Access-Control-Allow-Headers', b'x-prototype-version,x-requested-with')\n        request.responseHeaders.addRawHeader(b'Access-Control-Max-Age', 2520)\n        return request", "response": "Sets the CORS headers for the given request."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculate_columns(self):\n\n        self.cols = int(math.ceil(len(self.elements) / float(self.rows)))", "response": "Assuming the number of rows is constant work out the best\n        number of columns to use."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_element(self, element, col, row, cols=1, rows=1):\n\n        # Update the number of rows and colums\n        self.rows = max(self.rows, row+rows)\n        self.cols = max(self.cols, col+cols)\n\n        # Add the raw element record\n        self.elements.append((col, row, cols, rows, element))", "response": "Adds the given element to the given position in the grid and\n        with the given size."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a rule to the grid.", "response": "def add_rule(self, start_col, start_row, end_col, end_row,\n                 width=0.5, color=(0,0,0)):\n        \"\"\"Adds a rule to the grid. The row and column numbers are\n        those on the top left of the corresponding cell in the\n        grid. So if the grid is 10x10, then the right hand edge of the\n        grid will be column 10, and the bottom will be column 10. In\n        other words there is one more rule-row and column than there\n        are cell rows and columns.\"\"\"\n        self.rules.append(\n            (start_col, start_row, end_col, end_row, width, color)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _compile_dimension_size(self, base_index, array,\n                                property, sized_elements):\n        \"\"\"Build one set of col widths or row heights.\"\"\"\n        sort_index = base_index + 2\n        sized_elements.sort(key=lambda x: x[sort_index])\n        for element_data in sized_elements:\n            start, end = element_data[base_index], element_data[sort_index]\n            end += start\n            element, size = element_data[4:6]\n\n            # Find the total current size of the set\n            set_size = sum(array[start:end]) + (end-start-1)*self.margin\n\n            # Work out the extra space we need\n            extra_space_needed = getattr(size, property) - set_size\n            if extra_space_needed < 0: continue\n\n            # Distribute it among the entries\n            extra_space_each = extra_space_needed / (end-start)\n            for index in range(start, end):\n                array[index] += extra_space_each", "response": "Compile the dimension size of the set of entries."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_minimum_size(self, data):\n\n        # Gat a list of elements with their sizes, so we don't have to\n        # recalculate that each time.\n        sized_elements = [\n            (col, row, cols, rows, element, element.get_minimum_size(data))\n            for col, row, cols, rows, element in self.elements\n            ]\n\n        # Create the heights and widths for each cell.\n        self.col_widths = [0] * self.cols\n        self.row_heights = [0] * self.rows\n        self._compile_dimension_size(0, self.col_widths, 'x', sized_elements)\n        self._compile_dimension_size(1, self.row_heights, 'y', sized_elements)\n\n        # The final size is the total width and height\n        om = 2*self.outside_margin\n        return datatypes.Point(\n            sum(self.col_widths) + (self.cols-1)*self.margin + om,\n            sum(self.row_heights) + (self.rows-1)*self.margin + om\n            )", "response": "Finds the minimum size of the grid."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render(self, rect, data):\n        size = self.get_minimum_size(data)\n\n        # Find how much extra space we have.\n        extra_width = rect.w - size.x\n        extra_height = rect.h - size.y\n\n        # Distribute the extra space into the correct rows and columns.\n        if self.scaling_col is None or not 0 <= self.scaling_col < self.cols:\n            width_per_col = extra_width / float(self.cols)\n            col_widths = [\n                width + width_per_col\n                for width in self.col_widths\n                ]\n        else:\n            col_widths = self.col_widths[:]\n            col_widths[self.scaling_col] += extra_width\n\n        if self.scaling_row is None or not 0 <= self.scaling_row < self.rows:\n            height_per_row = extra_height / float(self.rows)\n            row_heights = [\n                height + height_per_row\n                for height in self.row_heights\n                ]\n        else:\n            row_heights = self.row_heights[:]\n            row_heights[self.scaling_row] += extra_height\n\n        # Find the (start, end) positions of each row and column.\n        col_xs = []\n        last_x = rect.left + self.outside_margin\n        for width in col_widths:\n            col_xs.append((last_x, last_x + width))\n            last_x += width + self.margin\n        row_ys = []\n        last_y = rect.top - self.outside_margin\n        for height in row_heights:\n            row_ys.append((last_y, last_y - height))\n            last_y -= height + self.margin\n\n        # Now we can loop over the elements and have them rendered.\n        for col, row, cols, rows, element in self.elements:\n            x_start = col_xs[col][0]\n            y_start = row_ys[row][0]\n            x_end = col_xs[col+cols-1][1]\n            y_end = row_ys[row+rows-1][1]\n            element.render(datatypes.Rectangle(\n                x_start, y_end, x_end-x_start, y_start-y_end\n                ), data)\n\n        # And finally we can draw the rules\n        def _get_value(array, index, sign):\n            \"\"\"Returns the value of the index in the given array, where\n            the array (like col_xs and row_ys), consists of start-end pairs\n            of values.\"\"\"\n            if index <= 0:\n                # Special case, it is the start of the first range\n                return array[0][0]-self.outside_margin*sign\n            elif index >= len(array):\n                # Special case, it is the end of the last range\n                return array[-1][1]+self.outside_margin*sign\n            else:\n                # Otherwise it is the blend of a start and end.\n                return (array[index-1][1] + array[index][0])*0.5\n\n        for start_col, start_row, end_col, end_row, width, color in self.rules:\n            x_start = _get_value(col_xs, start_col, 1)\n            y_start = _get_value(row_ys, start_row, -1)\n            x_end = _get_value(col_xs, end_col, 1)\n            y_end = _get_value(row_ys, end_row, -1)\n            data['output'].line(\n                x_start, y_start, x_end, y_end,\n                stroke=color,\n                stroke_width=width\n                )", "response": "Draws the cells in grid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, date, page_no=1, page_size=40, fields=[]):\n        '''taobao.taobaoke.report.get \u6dd8\u5b9d\u5ba2\u62a5\u8868\u67e5\u8be2\n        \n        \u6dd8\u5b9d\u5ba2\u62a5\u8868\u67e5\u8be2'''\n        request = TOPRequest('taobao.taobaoke.items.get')\n        request['date'] = date\n        request['page_no'] = page_no\n        request['page_size'] = page_size\n        if not fields:\n            fields = self.fields\n        request['fields'] = fields\n        self.create(self.execute(request)['taobaoke_report'])\n        return self", "response": "TAOBAOP. report. get \u6dd8\u5b9d\u5ba2\u62a5\u8868\u67e5\u8be2\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert(self, sids, fields=[], **kwargs):\n        '''taobao.taobaoke.shops.convert \u6dd8\u5ba2\u5e97\u94fa\u8f6c\u6362\n        \n        \u6dd8\u5b9d\u5ba2\u5e97\u94fa\u8f6c\u6362'''\n        request = TOPRequest('taobao.taobaoke.shops.convert')\n        request['sids'] = sids\n        if not fields:\n            taobaokeShop = TaobaokeShop()\n            fields = taobaokeShop.fields\n        request['fields'] = fields\n        for k, v in kwargs.iteritems():\n            if k not in ('nick', 'outer_code', 'pid') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request))\n        return self.taobaoke_shops", "response": "TAOBAOP. convert \u6dd8\u5b9d\u5e97\u94fa\u8f6c\u6362 sids \u6dd8\u5b9d\u5e97\u94fa\u8f6c\u6362 fields \u6dd8\u5b9d\u5e97\u94fa\u8f6c\u6362 fields \u6dd8\u5b9d\u5e97\u94fa\u8f6c\u6362 fields \u6dd8\u5b9d\u5e97\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef items_convert(self, fields=[], **kwargs):\n        '''taobao.taobaoke.items.convert \u6dd8\u5ba2\u5546\u54c1\u8f6c\u6362\n        \n        \u6dd8\u5b9d\u5ba2\u5546\u54c1\u8f6c\u6362'''\n        request = TOPRequest('taobao.taobaoke.items.convert')\n        if not fields:\n            taobaokeItem = TaobaokeItem()\n            fields = taobaokeItem.fields\n        request['fields'] = fields\n        for k, v in kwargs.iteritems():\n            if k not in ('nick', 'outer_code', 'num_iids', 'pid', 'is_mobile') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request), fields=['taobaoke_items', 'total_results'], models={'taobaoke_items':TaobaokeItem})\n        return self.taobaoke_items", "response": "TAOBAOP items. convert \u6dd8\u5b9d\u5546\u54c1\u8f6c\u6362 \u6dd8\u5b9d\u5546\u54c1\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listurl_get(self, q, **kwargs):\n        '''taobao.taobaoke.listurl.get \u6dd8\u5b9d\u5ba2\u5173\u952e\u8bcd\u641c\u7d22URL\n        \n        \u6dd8\u5b9d\u5ba2\u5173\u952e\u8bcd\u641c\u7d22URL'''\n        request = TOPRequest('taobao.taobaoke.listurl.get')\n        request['q'] = q\n        for k, v in kwargs.iteritems():\n            if k not in ('nick', 'outer_code', 'pid') and v==None: continue\n            request[k] = v\n        self.create(self.execute(request), fields=['taobaoke_item'], models={'taobaoke_item':TaobaokeItem})\n        return self.taobaoke_item", "response": "taobaoke. listurl. get \u6dd8\u5b9d\u5ba2\u5173\u952e\u8bcd\u641c\u7d22URL"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a block from a list of reStructuredText data.", "response": "def get_block(name, data, newline=\"\\n\"):\n    \"\"\"\n    First block in a list of one line strings containing\n    reStructuredText data. The result is as a joined string with the\n    given newline, or a line generator if it's None. The\n    BLOCK_START and BLOCK_END delimiters are selected with the given\n    name and aren't included in the result.\n    \"\"\"\n    lines = itertools.dropwhile(not_eq(BLOCK_START % name), data)\n    gen = itertools.takewhile(not_eq(BLOCK_END % name), tail(lines))\n    return gen if newline is None else newline.join(gen)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef all_but_blocks(names, data, newline=\"\\n\", remove_empty_next=True,\n                   remove_comments=True):\n    \"\"\"\n    Multiline string from a list of strings data, removing every\n    block with any of the given names, as well as their delimiters.\n    Removes the empty lines after BLOCK_END when ``remove_empty_next``\n    is True. Returns a joined string with the given newline, or a\n    line generator if it's None. If desired, this function use\n    ``commentless`` internally to remove the remaining comments.\n    \"\"\"\n    @allow_implicit_stop\n    def remove_blocks(name, iterable):\n        start, end = BLOCK_START % name, BLOCK_END % name\n        it = iter(iterable)\n        while True:\n            line = next(it)\n            while line != start:\n                yield line\n                line = next(it)\n            it = tail(itertools.dropwhile(not_eq(end), it))\n            if remove_empty_next:\n                it = itertools.dropwhile(lambda el: not el.strip(), it)\n    if isinstance(names, str):\n        names = [names]\n    processors = [functools.partial(remove_blocks, name) for name in names]\n    if remove_comments:\n        processors.append(commentless)\n    gen = functools.reduce(lambda result, func: func(result),\n                           processors, data)\n    return gen if newline is None else newline.join(gen)", "response": "Returns a Multiline string from a list of strings data removing any of the given names and comments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef abs_urls(data, target_url, image_url):\n    def replacer(regex, url):\n        replacement = r\"\\1 {0}/\\2\".format(url.rstrip(\"/\"))\n        return lambda line: regex.sub(replacement, line, count=1)\n    replacers = [replacer(REGEX_ABS_URLS_TARGET, target_url),\n                 replacer(REGEX_ABS_URLS_IMAGE, image_url)]\n    return [functools.reduce(lambda el, func: func(el), replacers, line)\n            for line in data]", "response": "Filter for a list of reStructuredText lines that replaces relative\n    link targets and image sources by absolute URLs given the base\n    target_url and image_url."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __tdfs(j, k, head, next, post, stack):\n    top = 0\n    stack[0] = j\n    while (top >= 0):\n        p = stack[top]\n        i = head[p]\n        if i == -1:\n            top -= 1\n            post[k] = p\n            k += 1\n        else:\n            head[p] = next[i]\n            top += 1\n            stack[top] = i\n\n    return k", "response": "Depth - first search and postorder of a tree rooted at node j."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post_order(parent):\n    n = len(parent)\n    k = 0\n\n    p = matrix(0,(n,1))\n    head = matrix(-1,(n,1))\n    next = matrix(0,(n,1))\n    stack = matrix(0,(n,1))\n\n    for j in range(n-1,-1,-1):\n        if (parent[j] == j): continue\n        next[j] = head[parent[j]]\n        head[parent[j]] = j\n\n    for j in range(n):\n        if (parent[j] != j): continue\n        k = __tdfs(j, k, head, next, p, stack)\n\n    return p", "response": "Post order a forest."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes elimination tree from upper triangle of A.", "response": "def etree(A):\n    \"\"\"\n    Compute elimination tree from upper triangle of A.\n    \"\"\"\n    assert isinstance(A,spmatrix), \"A must be a sparse matrix\"\n    assert A.size[0] == A.size[1], \"A must be a square matrix\"\n\n    n = A.size[0]\n    cp,ri,_ = A.CCS\n    parent = matrix(0,(n,1))\n    w = matrix(0,(n,1))\n\n    for k in range(n):\n        parent[k] = k\n        w[k] = -1\n        for p in range(cp[k],cp[k+1]):\n            i = ri[p]\n            while ((not i == -1) and (i < k)):\n                inext = w[i]\n                w[i] = k\n                if inext == -1: parent[i] = k\n                i = inext;\n\n    return parent"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndetermine if i is a leaf of i'th row subtree.", "response": "def __leaf(i, j, first, maxfirst, prevleaf, ancestor):\n    \"\"\"\n    Determine if j is leaf of i'th row subtree.\n    \"\"\"\n    jleaf = 0\n    if i<=j or first[j] <= maxfirst[i]: return -1, jleaf\n    maxfirst[i] = first[j]\n    jprev = prevleaf[i]\n    prevleaf[i] = j\n    if jprev == -1: jleaf = 1\n    else: jleaf = 2\n    if jleaf == 1: return i, jleaf\n    q = jprev\n    while q != ancestor[q]: q = ancestor[q]\n    s = jprev\n    while s != q:\n        sparent = ancestor[s]\n        ancestor[s] = q\n        s = sparent\n    return q, jleaf"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef counts(A, parent, post):\n    n = A.size[0]\n    colcount = matrix(0,(n,1))\n    ancestor = matrix(range(n),(n,1))\n    maxfirst = matrix(-1,(n,1))\n    prevleaf = matrix(-1,(n,1))\n    first = matrix(-1,(n,1))\n    \n    for k in range(n):\n        j = post[k]\n        if first[j] == -1:\n            colcount[j] = 1\n        else:\n            colcount[j] = 0\n        while  j != -1 and first[j] == -1:\n            first[j] = k;\n            j = parent[j]\n\n    cp,ri,_ = A.CCS\n    for k in range(n):\n        j = post[k]\n        if parent[j] != j:\n            colcount[parent[j]] -= 1\n        for p in range(cp[j],cp[j+1]):\n            i = ri[p]\n            if i <= j: continue\n            q, jleaf = __leaf(i, j, first, maxfirst, prevleaf, ancestor)\n            if jleaf >= 1: colcount[j] += 1\n            if jleaf == 2: colcount[q] -= 1\n        if parent[j] != j: ancestor[j] = parent[j]\n    for j in range(n):\n        if parent[j] != j: colcount[parent[j]] += colcount[j]\n\n    return colcount", "response": "Compute column counts of the given parent and post."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pothen_sun(par, post, colcount):\n    \n    n = len(par)\n    flag = matrix(-1, (n, 1))\n    snpar = matrix(-1, (n, 1))\n    snodes = n\n    ch = {}\n    \n    for j in post:\n\n        if par[j] in ch: ch[par[j]].append(j)\n        else: ch[par[j]] = [j]\n\n        mdeg = colcount[j] - 1\n\n        if par[j] != j:\n            if mdeg == colcount[par[j]] and flag[par[j]] == -1:\n                # par[j] not assigned to supernode\n                snodes -= 1\n                if flag[j] < 0:   # j is a repr. vertex\n                    flag[par[j]] = j\n                    flag[j] -= 1\n                else:             # j is not a repr. vertex\n                    flag[par[j]] = flag[j]\n                    flag[flag[j]] -= 1\n        else:\n            if flag[j] < 0: snpar[j] = j\n            else: snpar[flag[j]] = flag[j]\n\n        if flag[j] < 0: k = j\n        else: k = flag[j]\n\n        if j in ch:\n            for i in ch[j]:\n                if flag[i] < 0: l = i\n                else: l = flag[i]\n                if not l == k: snpar[l] = k\n\n\n    repr = matrix([i for i in range(n) if flag[i] < 0])\n    deg = matrix([-flag[i] for i in range(n) if flag[i] < 0])\n\n    # renumber etree with number of supernodes\n    sn = matrix(-1, (n+1, 1))\n    for k, r in enumerate(repr): sn[r] = k\n    snpar = sn[snpar[repr]]\n\n    return snpar, flag", "response": "This function returns the structure of the sun structure that is a supernode of the specified type and the supernode of the specified type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding supernodes. ARGUMENTS par parent array post array with post ordering colcount array with column counts RETURNS snode array with supernodes; snode[snptr[k]:snptr[k+1]] contains the indices of supernode k snptr pointer array; snptr[k] is the index of the representative vertex of supernode k in the snode array snpar supernodal parent structure", "response": "def supernodes(par, post, colcount):\n    \"\"\"\n    Find supernodes.\n\n    ARGUMENTS\n    par       parent array\n\n    post      array with post ordering\n\n    colcount  array with column counts\n\n    RETURNS\n    snode     array with supernodes; snode[snptr[k]:snptr[k+1]] contains\n              the indices of supernode k\n\n    snptr     pointer array; snptr[k] is the index of the representative\n              vertex of supernode k in the snode array\n\n    snpar     supernodal parent structure \n    \"\"\"\n    snpar, flag = pothen_sun(par, post, colcount)\n    n = len(par)\n    N = len(snpar)\n\n    snode = matrix(0, (n,1))\n    snptr = matrix(0, (N+1,1))\n\n    slist = [[] for i in range(n)]\n    for i in range(n):\n        f = flag[i]\n        if f < 0:\n            slist[i].append(i)\n        else:\n            slist[f].append(i)\n\n    k = 0; j = 0\n    for i,sl in enumerate(slist):\n        nsl = len(sl)\n        if nsl > 0:\n            snode[k:k+nsl] = matrix(sl)\n            snptr[j+1] = snptr[j] + nsl\n            k += nsl\n            j += 1\n        \n    return snode, snptr, snpar"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef amalgamate(colcount, snode, snptr, snpar, snpost, merge_function):\n    N = len(snpost)\n    ch = {}\n    for j in snpost:\n        if snpar[j] in ch: ch[snpar[j]].append(j)\n        else: ch[snpar[j]] = [j]\n\n    snlist = [snode[snptr[k]:snptr[k+1]] for k in range(N)]\n\n    snpar_ = +snpar\n    colcount_ = +colcount\n    Ns = N\n    for k in snpost:\n        if snpar_[k] != k:\n            colk = colcount_[snlist[k][0]]\n            colp = colcount_[snlist[snpar_[k]][0]]\n            nk = len(snlist[k])\n            np = len(snlist[snpar_[k]])\n            if merge_function and merge_function(colp,colk,np,nk):\n                # merge supernode k and snpar[k]\n                snlist[snpar_[k]] = matrix(sorted(list(snlist[k]) + list(snlist[snpar_[k]])))\n                snlist[k] = None\n                colcount_[snlist[snpar_[k]][0]] = colp + nk\n                Ns -= 1\n                if k in ch:\n                    for c in ch[k]:\n                        snpar_[c] = snpar_[k]\n                    ch[snpar_[k]] += ch[k]\n                snpar_[k] = k\n\n    L = [i for i,s in enumerate(snlist) if s is not None]\n    snptr_ = matrix(0,(len(L)+1,1))\n    snode_ = +snode\n    for i,l in enumerate(L):\n        snptr_[i+1] = snptr_[i] + len(snlist[l])\n        snode_[snptr_[i]:snptr_[i+1]] = snlist[l]\n\n    snpar_ = snpar_[L]\n    for i in range(len(snpar_)):\n        snpar_[i] = L.index(snpar_[i])\n    snpost_ = post_order(snpar_)\n    return colcount_, snode_, snptr_, snpar_, snpost_", "response": "This function takes a set of column counts and a set of supernodes and supernodal parent indices and a merge function that takes a set of supernodes and supernodal parent indices and a merge function that takes a set of supernodes and supernodal parent indices and merges them with supernodes and supernodal post indices."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute filled pattern. colptr, rowidx = embed(A, colcount, snode, snptr, snpar, snpost) PURPOSE Computes rowindices and column pointer for representative vertices in supernodes. ARGUMENTS A sparse matrix colcount vector with column counts snode vector with supernodes snptr vector with offsets snpar vector with supernodal parent indices snpost vector with supernodal post ordering RETURNS colptr vector with offsets rowidx vector with rowindices", "response": "def embed(A, colcount, snode, snptr, snpar, snpost):\n    \"\"\"\n    Compute filled pattern.\n\n       colptr, rowidx = embed(A, colcount, snode, snptr, snpar, snpost)\n\n    PURPOSE\n    Computes rowindices and column pointer for representative vertices in supernodes.\n\n    ARGUMENTS\n    A         sparse matrix\n\n    colcount  vector with column counts\n\n    snode     vector with supernodes\n \n    snptr     vector with offsets\n\n    snpar     vector with supernodal parent indices\n\n    snpost    vector with supernodal post ordering\n\n    RETURNS\n    colptr    vector with offsets \n\n    rowidx    vector with rowindices \n    \"\"\"\n\n    Alo = tril(A)\n    cp,ri,_ = Alo.CCS\n    N = len(snpar)\n\n    # colptr for compressed cholesky factor\n    colptr = matrix(0,(N+1,1))\n    for k in range(N):\n        colptr[k+1] = colptr[k] + colcount[snode[snptr[k]]]\n    rowidx = matrix(-1,(colptr[-1],1))\n    cnnz = matrix(0,(N,1))\n\n    # compute compressed sparse representation\n    for k in range(N):\n        p = snptr[k]\n        Nk = snptr[k+1]-p\n        nk = cp[snode[p]+1] - cp[snode[p]]\n        rowidx[colptr[k]:colptr[k]+nk] = ri[cp[snode[p]]:cp[snode[p]+1]]\n        cnnz[k] = nk\n        for i in range(1,Nk):\n            nk = cp[snode[p+i]+1]-cp[snode[p+i]]\n            cnnz[k] = lmerge(rowidx, ri, colptr[k], cp[snode[p+i]], cnnz[k], nk)\n\n    for k in snpost:\n        p = snptr[k]\n        Nk = snptr[k+1]-p\n        if snpar[k] != k:\n            cnnz[snpar[k]] = lmerge(rowidx,rowidx,colptr[snpar[k]], colptr[k]+Nk,cnnz[snpar[k]], cnnz[k]-Nk)\n\n    return colptr, rowidx"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing relative indices of update matrices in frontal matrix of parent.", "response": "def relative_idx(colptr, rowidx, snptr, snpar):\n    \"\"\"\n    Compute relative indices of update matrices in frontal matrix of parent.\n    \"\"\"\n    \n    relptr = matrix(0, (len(snptr),1))\n    relidx = matrix(-1, (colptr[-1],1))\n\n    def lfind(a,b):\n        i = 0\n        ret = +a\n        for k in range(len(a)):\n            while a[k] != b[i]: i += 1\n            ret[k] = i\n            i += 1\n        return ret\n    \n    for k in range(len(snpar)):\n        p = snpar[k]\n        relptr[k+1] = relptr[k]\n        if p != -1:\n            nk = snptr[k+1] - snptr[k]\n            relptr[k+1] += colptr[k+1] - colptr[k] - nk\n            relidx[relptr[k]:relptr[k+1]] = lfind(rowidx[colptr[k]+nk:colptr[k+1]], rowidx[colptr[p]:colptr[p+1]])\n\n    return relptr, relidx[:relptr[k+1]]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef peo(A, p):\n\n    n = A.size[0]\n    assert type(A) == spmatrix, \"A must be a sparse matrix\"\n    assert A.size[1] == n, \"A must be a square matrix\"\n    assert len(p) == n, \"length of p must be equal to the order of A\" \n    if isinstance(p, list): p = matrix(p)\n    \n    As = symmetrize(A)\n    cp,ri,_ = As.CCS\n\n    # compute inverse permutation array\n    ip = matrix(0,(n,1))\n    ip[p] = matrix(range(n),(n,1))\n\n    # test set inclusion\n    for k in range(n):\n        v = p[k]  # next vertex to be eliminated\n\n        # indices of neighbors that correspond to strictly lower triangular elements in reordered pattern\n        r = set([rj for rj in ri[cp[v]:cp[v+1]] if ip[rj] > k])  \n\n        for rj in r:\n            if not r.issubset(set(ri[cp[rj]:cp[rj+1]])): return False\n            \n    return True", "response": "Checks whether an ordering is a perfect elmimination order."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a sparse matrix with the filled pattern. By default the routine uses the reordered pattern and the inverse permutation is applied.", "response": "def sparsity_pattern(self, reordered = True, symmetric = True):\n        \"\"\"\n        Returns a sparse matrix with the filled pattern. By default,\n        the routine uses the reordered pattern, and the inverse\n        permutation is applied if `reordered` is `False`.\n        \n        :param reordered:  boolean (default: `True`)\n        :param symmetric:  boolean (default: `True`)\t\n        \"\"\"\n        return cspmatrix(self, 1.0).spmatrix(reordered = reordered, symmetric = symmetric)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the number of lower - triangular nonzeros.", "response": "def nnz(self):\n        \"\"\"\n        Returns the number of lower-triangular nonzeros.\n        \"\"\"\n        nnz = 0\n        for k in range(len(self.snpost)):\n            nn = self.snptr[k+1]-self.snptr[k]    \n            na = self.relptr[k+1]-self.relptr[k]\n            nnz += nn*(nn+1)/2 + nn*na\n        return nnz"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cliques(self, reordered = True):\n        if reordered:\n            return [list(self.snrowidx[self.sncolptr[k]:self.sncolptr[k+1]]) for k in range(self.Nsn)]\n        else:\n            return [list(self.__p[self.snrowidx[self.sncolptr[k]:self.sncolptr[k+1]]]) for k in range(self.Nsn)]", "response": "Returns a list of cliques in the current region."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef separators(self, reordered = True):\n        if reordered:\n            return [list(self.snrowidx[self.sncolptr[k]+self.snptr[k+1]-self.snptr[k]:self.sncolptr[k+1]]) for k in range(self.Nsn)] \n        else:\n            return [list(self.__p[self.snrowidx[self.sncolptr[k]+self.snptr[k+1]-self.snptr[k]:self.sncolptr[k+1]]]) for k in range(self.Nsn)]", "response": "Returns a list of separator sets \n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of supernodes sets", "response": "def supernodes(self, reordered = True):\n        \"\"\"\n        Returns a list of supernode sets\n        \"\"\"\n        if reordered:\n            return [list(self.snode[self.snptr[k]:self.snptr[k+1]]) for k in range(self.Nsn)]\n        else:\n            return [list(self.__p[self.snode[self.snptr[k]:self.snptr[k+1]]]) for k in range(self.Nsn)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef spmatrix(self, reordered = True, symmetric = False):\n        n = self.symb.n\n        snptr = self.symb.snptr\n        snode = self.symb.snode\n        relptr = self.symb.relptr\n        snrowidx = self.symb.snrowidx\n        sncolptr = self.symb.sncolptr\n        blkptr = self.symb.blkptr\n        blkval = self.blkval\n        \n        if self.is_factor:\n            if symmetric: raise ValueError(\"'symmetric = True' not implemented for Cholesky factors\")\n            if not reordered: raise ValueError(\"'reordered = False' not implemented for Cholesky factors\")\n            snpost = self.symb.snpost\n            blkval = +blkval\n            for k in snpost:\n                j = snode[snptr[k]]            # representative vertex\n                nn = snptr[k+1]-snptr[k]       # |Nk|\n                na = relptr[k+1]-relptr[k]     # |Ak|\n                if na == 0: continue\n                nj = na + nn\n                if nn == 1:\n                    blas.scal(blkval[blkptr[k]],blkval,offset = blkptr[k]+1,n=na)\n                else:\n                    blas.trmm(blkval,blkval, transA = \"N\", diag = \"N\", side = \"R\",uplo = \"L\", \\\n                              m = na, n = nn, ldA = nj, ldB = nj, \\\n                              offsetA = blkptr[k],offsetB = blkptr[k] + nn)\n\n        cc = matrix(0,(n,1))  # count number of nonzeros in each col\n        for k in range(self.symb.Nsn):\n            nn = snptr[k+1]-snptr[k]\n            na = relptr[k+1]-relptr[k]\n            nj = nn + na\n            for i in range(nn):\n                j = snode[snptr[k]+i]\n                cc[j] = nj - i\n\n        # build col. ptr\n        cp = [0]\n        for i in range(n): cp.append(cp[-1] + cc[i])\n        cp = matrix(cp)\n\n        # copy data and row indices\n        val = matrix(0.0, (cp[-1],1))\n        ri = matrix(0, (cp[-1],1))\n        for k in range(self.symb.Nsn):\n            nn = snptr[k+1]-snptr[k]\n            na = relptr[k+1]-relptr[k]\n            nj = nn + na\n            for i in range(nn):\n                j = snode[snptr[k]+i]\n                blas.copy(blkval, val, offsetx = blkptr[k]+nj*i+i, offsety = cp[j], n = nj-i)\n                ri[cp[j]:cp[j+1]] = snrowidx[sncolptr[k]+i:sncolptr[k+1]]\n\n        I = []; J = []\n        for i in range(n):\n            I += list(ri[cp[i]:cp[i+1]])\n            J += (cp[i+1]-cp[i])*[i]\n\n        tmp = spmatrix(val, I, J, (n,n))  # tmp is reordered and lower tril.\n        \n        if reordered or self.symb.p is None:\n            # reordered matrix (do not apply inverse permutation)\n            if not symmetric: return tmp\n            else: return symmetrize(tmp)\n        else:\n            # apply inverse permutation            \n            tmp = perm(symmetrize(tmp), self.symb.ip)\n            if symmetric: return tmp\n            else: return tril(tmp)", "response": "Converts the Cholesky factor to a sparse matrix."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef diag(self, reordered = True):\n        sncolptr = self.symb.sncolptr\n        snptr = self.symb.snptr\n        snode = self.symb.snode\n        blkptr = self.symb.blkptr\n        \n        D = matrix(0.0,(self.symb.n,1))\n        for k in range(self.symb.Nsn):\n            nn = snptr[k+1]-snptr[k]\n            w = sncolptr[k+1]-sncolptr[k]\n            for i in range(nn): D[snode[snptr[k]+i]] = self.blkval[blkptr[k]+i*w+i]\n        if reordered: return D\n        else: return D[self.symb.ip]", "response": "Returns a vector with the diagonal elements of the matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a copy of the current array .", "response": "def copy(self):\n        \"\"\"\n        Returns a new :py:class:`cspmatrix` object with a reference to the same\n        symbolic factorization, but with a copy of the array\n        that stores the numerical values.\n        \"\"\"\n        return cspmatrix(self.symb, blkval = +self.blkval, factor = self.is_factor)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _iadd_spmatrix(self, X, alpha = 1.0):\n        assert self.is_factor is False, \"cannot add spmatrix to a cspmatrix factor\"\n\n        n = self.symb.n\n        snptr = self.symb.snptr\n        snode = self.symb.snode\n        relptr = self.symb.relptr\n        snrowidx = self.symb.snrowidx\n        sncolptr = self.symb.sncolptr\n        blkptr = self.symb.blkptr\n        blkval = self.blkval\n\n        if self.symb.p is not None:\n            Xp = tril(perm(symmetrize(X),self.symb.p))\n        else:\n            Xp = tril(X)\n        cp, ri, val = Xp.CCS\n\n        # for each block ...\n        for k in range(self.symb.Nsn):\n            nn = snptr[k+1]-snptr[k]\n            na = relptr[k+1]-relptr[k]\n            nj = nn + na\n\n            r = list(snrowidx[sncolptr[k]:sncolptr[k+1]])\n            # copy cols from A to block\n            for i in range(nn):\n                j = snode[snptr[k]+i]\n                offset = blkptr[k] + nj*i\n                # extract correct indices and add values\n                I = [offset + r.index(idx) for idx in ri[cp[j]:cp[j+1]]]\n\n                blkval[I] += alpha*val[cp[j]:cp[j+1]]\n        return", "response": "Add a sparse matrix X to the cspmatrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a projection of a dense matrix A onto a cspmatrix factor A.", "response": "def add_projection(self, A, alpha = 1.0, beta = 1.0, reordered=False):\n        \"\"\"\n        Add projection of a dense matrix :math:`A` to :py:class:`cspmatrix`.\n\n            X := alpha*proj(A) + beta*X\n        \"\"\"\n        assert self.is_factor is False, \"cannot project matrix onto a cspmatrix factor\"\n        assert isinstance(A, matrix), \"argument A must be a dense matrix\"\n        \n        symb = self.symb\n        blkval = self.blkval\n\n        n = symb.n\n        snptr = symb.snptr\n        snode = symb.snode\n        relptr = symb.relptr\n        snrowidx = symb.snrowidx\n        sncolptr = symb.sncolptr\n        blkptr = symb.blkptr\n\n        if self.symb.p is not None and reordered is False:\n            A = tril(A)\n            A = A+A.T\n            A[::A.size[0]+1] *= 0.5\n            A = A[self.symb.p,self.symb.p]\n\n        # for each block ...\n        for k in range(self.symb.Nsn):\n            nn = snptr[k+1]-snptr[k]\n            na = relptr[k+1]-relptr[k]\n            nj = nn + na\n             \n            blkval[blkptr[k]:blkptr[k+1]] = beta*blkval[blkptr[k]:blkptr[k+1]] + alpha*(A[snrowidx[sncolptr[k]:sncolptr[k+1]],snode[snptr[k]:snptr[k+1]]][:])\n        \n        return"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_deep_link_url(self, data=None, alias=None, type=0, duration=None, identity=None, tags=None,\n                             campaign=None, feature=None, channel=None, stage=None, skip_api_call=False):\n        \"\"\"\n        Creates a deep linking url\n\n        See the URL https://dev.branch.io/references/http_api/#creating-a-deep-linking-url\n\n        You can also use this method to bulk create deep link by setting \"skip_api_call=True\" and using the parameters\n        returned by the method as an array and call \"create_deep_linking_urls\"\n\n        :return: params or the response\n        \"\"\"\n        url = \"/v1/url\"\n        method = \"POST\"\n        params = {}\n\n        # Check Params\n        self._check_param(\"data\", data, params, type=dict)\n        self._check_param(\"alias\", alias, params, type=(binary_type, text_type))\n        self._check_param(\"type\", type, params, type=int, lte=2, gte=0)\n        self._check_param(\"duration\", duration, params, type=int)\n        self._check_param(\"identity\", identity, params, type=(binary_type, text_type), max_length=127)\n        self._check_param(\"tags\", tags, params, type=list, sub_type=(binary_type, text_type), sub_max_length=64)\n        self._check_param(\"campaign\", campaign, params, type=(binary_type, text_type), max_length=128)\n        self._check_param(\"feature\", feature, params, type=(binary_type, text_type), max_length=128)\n        self._check_param(\"channel\", channel, params, type=(binary_type, text_type), max_length=128)\n        self._check_param(\"stage\", stage, params, type=(binary_type, text_type), max_length=128)\n\n        if skip_api_call is True:\n            return params\n        else:\n            self._check_param(\"branch_key\", self.branch_key, params, optional=False, type=(binary_type, text_type))\n            return self.make_api_call(method, url, json_params=params)", "response": "Create a deep linking url for branch. io."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_deep_linking_urls(self, url_params):\n\n        url = \"/v1/url/bulk/%s\" % self.branch_key\n        method = \"POST\"\n\n        # Checks params\n        self._check_param(value=url_params, type=list, sub_type=dict, optional=False)\n\n        return self.make_api_call(method, url, json_params=url_params)", "response": "Bulk Creates Deep Linking URLs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake a web call to the branch API.", "response": "def make_api_call(self, method, url, json_params=None):\n        \"\"\"\n        Accesses the branch API\n        :param method: The HTTP method\n        :param url: The URL\n        :param json_params: JSON parameters\n        :return: The parsed response\n        \"\"\"\n\n        url = self.BRANCH_BASE_URI+url\n\n        if self.verbose is True:\n            print(\"Making web request: {}\".format(url))\n\n        if json_params is not None:\n            encoded_params = json.dumps(json_params)\n            headers = {'Content-Type': 'application/json'}\n        else:\n            encoded_params = None\n            headers = {}\n\n        if encoded_params is not None and self.verbose is True:\n            print(\"Params: {}\".format(encoded_params))\n\n        request = Request(url, encoded_params.encode('utf-8'), headers)\n        request.get_method = lambda: method\n        response = urlopen(request).read()\n        return json.loads(response.decode('utf-8'))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_enum(lib_prefix, enum_prefix=''):\n\n    def wrapper(cls):\n        for attr in dir(lib):\n            if attr.startswith(lib_prefix):\n                name = attr.replace(lib_prefix, enum_prefix)\n                cls.add(name, getattr(lib, attr))\n        return cls\n    return wrapper", "response": "Class decorator for automatically adding enum values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_bytes(value):\n    if isinstance(value, text_type):\n        return value.encode('utf-8')\n    elif isinstance(value, ffi.CData):\n        return ffi.string(value)\n    elif isinstance(value, binary_type):\n        return value\n    else:\n        raise ValueError('Value must be text, bytes, or char[]')", "response": "Converts bytes unicode C char arrays to bytes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_bytes_or_none(value):\n    if value == ffi.NULL:\n        return None\n    elif isinstance(value, ffi.CData):\n        return ffi.string(value)\n    else:\n        raise ValueError('Value must be char[] or NULL')", "response": "Converts C char arrays to bytes and C NULL values to None."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting bytes unicode and C char arrays to unicode strings.", "response": "def to_unicode(value):\n    \"\"\"Converts bytes, unicode, and C char arrays to unicode strings.\n\n    Bytes and C char arrays are decoded from UTF-8.\n    \"\"\"\n    if isinstance(value, ffi.CData):\n        return ffi.string(value).decode('utf-8')\n    elif isinstance(value, binary_type):\n        return value.decode('utf-8')\n    elif isinstance(value, text_type):\n        return value\n    else:\n        raise ValueError('Value must be text, bytes, or char[]')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_unicode_or_none(value):\n    if value == ffi.NULL:\n        return None\n    elif isinstance(value, ffi.CData):\n        return ffi.string(value).decode('utf-8')\n    else:\n        raise ValueError('Value must be char[] or NULL')", "response": "Converts C char arrays to unicode and C NULL values to None."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on(self, event, listener, *user_args):\n        self._listeners[event].append(\n            _Listener(callback=listener, user_args=user_args))", "response": "Register a listener function to be called when an event is emitted."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef off(self, event=None, listener=None):\n        if event is None:\n            events = self._listeners.keys()\n        else:\n            events = [event]\n        for event in events:\n            if listener is None:\n                self._listeners[event] = []\n            else:\n                self._listeners[event] = [\n                    l for l in self._listeners[event]\n                    if l.callback != listener]", "response": "Removes a listener that was to be called on event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall the registered listeners for event.", "response": "def emit(self, event, *event_args):\n        \"\"\"Call the registered listeners for ``event``.\n\n        The listeners will be called with any extra arguments passed to\n        :meth:`emit` first, and then the extra arguments passed to :meth:`on`\n        \"\"\"\n        listeners = self._listeners[event][:]\n        for listener in listeners:\n            args = list(event_args) + list(listener.user_args)\n            result = listener.callback(*args)\n            if result is False:\n                self.off(event, listener.callback)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef num_listeners(self, event=None):\n        if event is not None:\n            return len(self._listeners[event])\n        else:\n            return sum(len(l) for l in self._listeners.values())", "response": "Return the number of listeners for the specified event."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling the single registered listener for event.", "response": "def call(self, event, *event_args):\n        \"\"\"Call the single registered listener for ``event``.\n\n        The listener will be called with any extra arguments passed to\n        :meth:`call` first, and then the extra arguments passed to :meth:`on`\n\n        Raises :exc:`AssertionError` if there is none or multiple listeners for\n        ``event``. Returns the listener's return value on success.\n        \"\"\"\n        # XXX It would be a lot better for debugging if this error was raised\n        # when registering the second listener instead of when the event is\n        # emitted.\n        assert self.num_listeners(event) == 1, (\n            'Expected exactly 1 event listener, found %d listeners' %\n            self.num_listeners(event))\n        listener = self._listeners[event][0]\n        args = list(event_args) + list(listener.user_args)\n        return listener.callback(*args)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(cls, name, value):\n        attr = cls(value)\n        attr._name = name\n        setattr(cls, name, attr)", "response": "Add a name - value pair to the enumeration."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the minimum size of the elements in the image.", "response": "def get_minimum_size(self, data):\n        \"\"\"\n        Minimum height is the total height + margins, minimum width\n        is the largest width.\n        \"\"\"\n        min_width = 0\n        height = 0\n        for element in self.elements:\n            size = element.get_minimum_size(data)\n            min_width = max(min_width, size.x)\n            height += size.y\n        height += (len(self.elements)-1)*self.margin\n        return datatypes.Point(min_width, height)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders the elements according to the alignment properties.", "response": "def render(self, rect, data):\n        \"\"\"\n        Displays the elements according to the align properties.\n        \"\"\"\n        # Make sure we're aligned correctly\n        if self.horizontal_align not in VerticalLM._VALID_ALIGN_HORIZONTAL:\n            raise ValueError('Horizontal align is not valid.')\n        if self.vertical_align not in VerticalLM._VALID_ALIGN_VERTICAL:\n            raise ValueError('Vertical align is not valid.')\n\n        # Work out the extra height we have to distribute\n        extra_height = rect.h - self.get_minimum_size(data).y\n        num_elements = len(self.elements)\n        if num_elements == 0:\n            return\n        elif num_elements > 1:\n            per_margin = 1.0 / float(num_elements-1)\n        else:\n            per_margin = 0.0\n        per_element = 1.0 / float(num_elements)\n\n        # Work out the starting y coordinate\n        y = rect.y\n        if self.vertical_align == VerticalLM.ALIGN_MIDDLE:\n            y = rect.y + extra_height*0.5\n        elif self.vertical_align == VerticalLM.ALIGN_TOP:\n            y = rect.y + extra_height\n\n        # Render each child element\n        for element in reversed(self.elements):\n            size = element.get_minimum_size(data)\n\n            # Work out the x-coordinates\n            if self.horizontal_align == VerticalLM.ALIGN_LEFT:\n                x = rect.x\n                w = size.x\n            elif self.horizontal_align == VerticalLM.ALIGN_CENTER:\n                x = rect.center - size.x*0.5\n                w = size.x\n            elif self.horizontal_align == VerticalLM.ALIGN_RIGHT:\n                x = rect.right - size.x\n                w = size.x\n            else:\n                assert self.horizontal_align == VerticalLM.ALIGN_GROW\n                x = rect.x\n                w = rect.w\n\n            # Work out the y-coordinates\n            if self.vertical_align in VerticalLM._ALIGN_SIMPLE_SET:\n                h = size.y\n                next_y = y + size.y + self.margin\n            elif self.vertical_align == VerticalLM.ALIGN_EQUAL_SPACING:\n                h = size.y\n                next_y = y + size.y + self.margin + extra_height*per_margin\n            else:\n                assert self.vertical_align == VerticalLM.ALIGN_EQUAL_GROWTH\n                h = size.y + extra_height*per_element\n                next_y = y + h + self.margin\n\n            # Render and move on.\n            element.render(datatypes.Rectangle(x, y, w, h), data)\n            y = next_y"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_minimum_size(self, data):\n        width = 0\n        min_height = 0\n        for element in self.elements:\n            size = element.get_minimum_size(data)\n            min_height = max(min_height, size.y)\n            width += size.x\n        width += (len(self.elements)-1)*self.margin\n        return datatypes.Point(width, min_height)", "response": "Returns the minimum size of the elements in the image."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render(self, rect, data):\n\n        # Make sure we're aligned correctly\n        if self.horizontal_align not in HorizontalLM._VALID_ALIGN_HORIZONTAL:\n            raise ValueError('Horizontal align is not valid.')\n        if self.vertical_align not in HorizontalLM._VALID_ALIGN_VERTICAL:\n            raise ValueError('Vertical align is not valid.')\n\n        # Work out the extra width we have to distribute\n        extra_width = rect.w - self.get_minimum_size(data).x\n        num_elements = len(self.elements)\n        if num_elements == 0:\n            return\n        elif num_elements > 1:\n            per_margin = 1.0 / float(num_elements-1)\n        else:\n            per_margin = 0.0\n        per_element = 1.0 / float(num_elements)\n\n        # Work out the starting x coordinate\n        x = rect.x\n        if self.horizontal_align == HorizontalLM.ALIGN_CENTER:\n            x = rect.x + extra_width*0.5\n        elif self.horizontal_align == HorizontalLM.ALIGN_RIGHT:\n            x = rect.x + extra_width\n\n        # Render each child element\n        for element in self.elements:\n            size = element.get_minimum_size(data)\n\n            # Work out the y-coordinates\n            if self.vertical_align == HorizontalLM.ALIGN_TOP:\n                y = rect.top - size.y\n                h = size.y\n            elif self.vertical_align == HorizontalLM.ALIGN_MIDDLE:\n                y = rect.middle - size.y*0.5\n                h = size.y\n            elif self.vertical_align == HorizontalLM.ALIGN_BOTTOM:\n                y = rect.y\n                h = size.y\n            else:\n                assert self.vertical_align == HorizontalLM.ALIGN_GROW\n                y = rect.y\n                h = rect.h\n\n            # Work out the x-coordinates\n            if self.horizontal_align in HorizontalLM._ALIGN_SIMPLE_SET:\n                w = size.x\n                next_x = x + size.x + self.margin\n            elif self.horizontal_align == HorizontalLM.ALIGN_EQUAL_SPACING:\n                w = size.x\n                next_x = x + size.x + self.margin + extra_width*per_margin\n            else:\n                assert self.horizontal_align == HorizontalLM.ALIGN_EQUAL_GROWTH\n                w = size.x + extra_width*per_element\n                next_x = x + w + self.margin\n\n            # Render and move on.\n            element.render(datatypes.Rectangle(x, y, w, h), data)\n            x = next_x", "response": "Displays the elements according to the align properties."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_minimum_size(self, data):\n        min_width = 0\n        min_height = 0\n        for element in self.elements:\n            size = (\n                datatypes.Point(0, 0) if element is None\n                else element.get_minimum_size(data)\n                )\n            min_height = max(min_height, size.y)\n            min_width = max(min_width, size.x)\n\n        num_elements = len(self.elements)\n        height = min_height * num_elements + self.margin * (num_elements-1)\n        return datatypes.Point(min_width, height)", "response": "The minimum height is the number of rows multiplied by the\n            tallest row."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parser_help_text(help_text):\n    if help_text is None:\n        return None, {}\n\n    main_text = ''\n    params_help = {}\n\n    for line in help_text.splitlines():\n        line = line.strip()\n        match = re.search(r':\\s*param\\s*(?P<param>\\w+)\\s*:(?P<help>.*)$', line)\n        if match:\n            params_help[match.group('param')] = match.group('help').strip()\n        else:\n            main_text += line + ' '\n\n    main_text = main_text.strip()\n    return main_text, params_help", "response": "Takes the help text supplied as a doc string and extraxts the\n    description and any param arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef calculate_default_type(arg, has_default, default_value, params_help):\n    positional = True\n    arg_params = {}\n    arg_name = arg\n\n    # Check to see if we have help text for this argument\n    try:\n        arg_params['help'] = params_help[arg_name]\n    except KeyError:\n        pass\n\n    # If we have a default value, then this is not positional\n    if has_default:\n        positional = False\n\n    # Special case when a base type is supplied\n    if default_value in (int, float):\n        positional = True\n\n    # For boolean options, change the action\n    if default_value is True:\n        arg_params['action'] = 'store_false'\n    elif default_value is False:\n        arg_params['action'] = 'store_true'\n\n    # Finally, check if the default value is an integer or a float\n    # and set the arg type on the item\n    if type(default_value) in (int, float):\n        arg_params['type'] = type(default_value)\n\n    # Update the arg_name\n    if positional:\n        if arg_name.startswith('_'):\n            arg_params['nargs'] = '?'\n            arg_params['default'] = None\n            arg_params['metavar'] = arg_name.lstrip('_')\n            #arg_name = arg_name.lstrip('_')\n    else:\n        arg_params['default'] = default_value\n        if len(arg_name) == 1:\n            arg_name = '-' + arg_name\n        else:\n            arg_name = '--' + arg_name\n\n    return arg_name, arg_params", "response": "This function calculates the type of the default value that is supplied to the parser"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef urijoin(base, ref, strict=False):\n    if isinstance(base, type(ref)):\n        return urisplit(base).transform(ref, strict).geturi()\n    elif isinstance(base, bytes):\n        return urisplit(base.decode()).transform(ref, strict).geturi()\n    else:\n        return urisplit(base).transform(ref.decode(), strict).geturi()", "response": "Convert a URI reference relative to a base URI to its target URI\n    string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures that the subject is equal to other.", "response": "def equals(self, other):\n        \"\"\"\n        Ensures :attr:`subject` is equal to *other*.\n        \"\"\"\n        self._run(unittest_case.assertEqual, (self._subject, other))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_not_equal_to(self, other):\n        self._run(unittest_case.assertNotEqual, (self._subject, other))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns True if subject is not equal to other."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_(self, other):\n        self._run(unittest_case.assertIs, (self._subject, other))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns the subject of the other object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_not(self, other):\n        self._run(unittest_case.assertIsNot, (self._subject, other))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that checks that subject is not other."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef contains(self, element):\n        self._run(unittest_case.assertIn, (element, self._subject))\n        return ChainInspector(self._subject)", "response": "Ensures that the subject contains the given element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef contains_none_of(self, elements):\n        for element in elements:\n            self._run(unittest_case.assertNotIn, (element, self._subject))\n        return ChainInspector(self._subject)", "response": "Ensures that the subject contains none of elements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring that the subject contains exactly one of elements.", "response": "def contains_one_of(self, elements):\n        \"\"\"\n        Ensures :attr:`subject` contains exactly one of *elements*, which must be an iterable.\n        \"\"\"\n        if sum(e in self._subject for e in elements) != 1:\n            raise self._error_factory(_format(\"Expected {} to have exactly one of {}\", self._subject, elements))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nensuring that the set contains only the given elements.", "response": "def contains_only(self, elements):\n        \"\"\"\n        Ensures :attr:`subject` contains all of *elements*, which must be an iterable, and no other items.\n        \"\"\"\n        for element in self._subject:\n            if element not in elements:\n                raise self._error_factory(_format(\"Expected {} to have only {}, but it contains {}\",\n                                                  self._subject, elements, element))\n        self.contains_all_of(elements)\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring that the subject contains at least one of elements.", "response": "def contains_some_of(self, elements):\n        \"\"\"\n        Ensures :attr:`subject` contains at least one of *elements*, which must be an iterable.\n        \"\"\"\n        if all(e not in self._subject for e in elements):\n            raise self._error_factory(_format(\"Expected {} to have some of {}\", self._subject, elements))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nensure that the subject does not contain element.", "response": "def does_not_contain(self, element):\n        \"\"\"\n        Ensures :attr:`subject` does not contain *element*.\n        \"\"\"\n        self._run(unittest_case.assertNotIn, (element, self._subject))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a ChainInspector that contains only elements of class prototype.", "response": "def contains_no(self, prototype):\n        \"\"\"\n        Ensures no item of :attr:`subject` is of class *prototype*.\n        \"\"\"\n        for element in self._subject:\n            self._run(unittest_case.assertNotIsInstance, (element, prototype))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_key(self, key):\n        self.is_a(Mapping)\n        self.contains(key)\n        return KeyInspector(self._subject[key])", "response": "Returns a KeyInspector object that contains the given key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef has_keys(self, keys):\n        self.is_a(Mapping)\n        self.contains_all_of(keys)\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns a new set of keys that are present in the subject."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_only_keys(self, keys):\n        self.is_a(Mapping)\n        self.contains_only(keys)\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that contains only the given keys."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_attribute(self, attr):\n        if not hasattr(self._subject, attr):\n            raise self._error_factory(_format(\"Expected {} to have attribute {}\", self._subject, attr))\n        return ReferenceInspector(getattr(self._subject, attr))", "response": "Ensures that the subject has an attribute attr*."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_in(self, iterable):\n        self._run(unittest_case.assertIn, (self._subject, iterable))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns the first element of the given iterable."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_not_in(self, iterable):\n        self._run(unittest_case.assertNotIn, (self._subject, iterable))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns True if the subject is not contained in the given iterable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_true(self):\n        self._run(unittest_case.assertTrue, (self._subject,))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns the current object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_false(self):\n        self._run(unittest_case.assertFalse, (self._subject,))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a ChainInspector that returns the None object.", "response": "def is_none(self):\n        \"\"\"\n        Ensures :attr:`subject` is ``None``.\n        \"\"\"\n        self._run(unittest_case.assertIsNone, (self._subject,))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_none_or(self):\n        if self._subject is None:\n            return NoOpInspector(subject=self._subject, error_factory=self._error_factory)\n        else:\n            return self", "response": "Returns a new object with the same attributes as this one but with no attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a ChainInspector that returns True if the subject is not None.", "response": "def is_not_none(self):\n        \"\"\"\n        Ensures :attr:`subject` is not ``None``.\n        \"\"\"\n        self._run(unittest_case.assertIsNotNone, (self._subject,))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_empty(self):\n        if len(self._subject) > 0:\n            raise self._error_factory(_format(\"Expected {} to be empty\", self._subject))\n        return ChainInspector(self._subject)", "response": "Checks that the subject is not empty."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new instance of the class with the same attributes as the current instance.", "response": "def is_nonempty(self):\n        \"\"\"\n        Ensures :attr:`subject` has non-zero length.\n        \"\"\"\n        if len(self._subject) == 0:\n            raise self._error_factory(_format(\"Expected {} to be non-empty\", self._subject))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_a(self, prototype):\n        self._run(unittest_case.assertIsInstance, (self._subject, prototype))\n        if hasattr(self._subject, '__iter__'):\n            return IterableInspector(self._subject)\n        else:\n            return ReferenceInspector(self._subject)", "response": "Returns an Inspector that checks that the subject is an instance of prototype."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_positive(self):\n        self._run(unittest_case.assertGreater, (self._subject, 0))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns the subject if it is positive."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_negative(self):\n        self._run(unittest_case.assertLess, (self._subject, 0))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns a new set of all negative entries."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a ChainInspector that returns True if the subject is nonnegative.", "response": "def is_nonnegative(self):\n        \"\"\"\n        Ensures :attr:`subject` is greater than or equal to 0.\n        \"\"\"\n        self._run(unittest_case.assertGreaterEqual, (self._subject, 0))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_not_a(self, prototype):\n        self._run(unittest_case.assertNotIsInstance, (self._subject, prototype))\n        return ChainInspector(self._subject)", "response": "Returns a ChainInspector that returns True if the subject is not an instance of prototype."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef matches(self, pattern, flags=0):\n        if not re.match(pattern, self._subject, flags):\n            raise self._error_factory(_format(\"Expected {} to match {}\", self._subject, pattern))\n        return ChainInspector(self._subject)", "response": "Ensures that the subject matches regular expression pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_an_iterable_of(self, prototype):\n        for element in self._subject:\n            self._run(unittest_case.assertIsInstance, (element, prototype))\n        if isinstance(self._subject, Mapping):\n            return MappingInspector(self._subject)", "response": "Ensures that the subject is an iterable containing only objects of class prototype."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nensuring that the subject is an int float or long.", "response": "def is_numeric(self):\n        \"\"\"\n        Ensures :attr:`subject` is an int, float, or long.\n        \"\"\"\n        from decimal import Decimal\n        numeric_types = (int, float, long, Decimal) if USING_PYTHON2 else (int, float, Decimal)  # noqa\n        if not isinstance(self._subject, numeric_types):\n            raise self._error_factory(_format(\"Expected {} to be numeric (int, float, long or Decimal)\", self._subject))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_callable(self):\n        if not callable(self._subject):\n            raise self._error_factory(_format(\"Expected {} to be callable\", self._subject))", "response": "Ensures that the subject is a callable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring that the subject has the given length and at least min and max.", "response": "def has_length(self, length=None, min=None, max=None):\n        \"\"\"\n        Ensures :attr:`subject` has length *length* (if given), length at least *min* (if given), and length at most\n        *max* (if given).\n        \"\"\"\n        unittest_case.assertFalse(length is None and min is None and max is None)\n        my_length = len(self._subject)\n        if length is not None:\n            try:\n                unittest_case.assertTrue(my_length == length)\n            except self._catch as err:\n                raise self._error_factory(_format(\"Expected {} to have length {}\", self._subject, length))\n        if min is not None:\n            try:\n                unittest_case.assertTrue(my_length >= min)\n            except self._catch as err:\n                raise self._error_factory(_format(\"Expected {} to have length at least {}\", self._subject, min))\n        if max is not None:\n            try:\n                unittest_case.assertTrue(my_length <= max)\n            except self._catch as err:\n                raise self._error_factory(_format(\"Expected {} to have length at most {}\", self._subject, max))\n        return ChainInspector(self._subject)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_less_than(self, other):\n        try:\n            unittest_case.assertTrue(self._subject < other)\n        except self._catch as err:\n            raise self._error_factory(_format(\"Expected {} to be less than {}\", self._subject, other))\n        return ChainInspector(self._subject)", "response": "Ensures that subject is less than other."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nensures that the current object raises the given exception.", "response": "def raises(self, expected_exception):\n        \"\"\"\n        Ensures preceding predicates (specifically, :meth:`called_with()`) result in *expected_exception* being raised.\n        \"\"\"\n        return unittest_case.assertRaises(expected_exception, self._orig_subject, *self._args, **self._kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nensures that the given exception is raised with the given regular expression.", "response": "def raises_regex(self, expected_exception, expected_regexp):\n        \"\"\"\n        Ensures preceding predicates (specifically, :meth:`called_with()`) result in *expected_exception* being raised,\n        and the string representation of *expected_exception* must match regular expression *expected_regexp*.\n        \"\"\"\n        return unittest_case.assertRaisesRegexp(expected_exception, expected_regexp, self._orig_subject,\n                                                *self._args, **self._kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef or_raise(self, error_factory, message=None, *args, **kwargs):\n        if self._exception:\n            if message is None:\n                raise error_factory(self._exception, *args, **kwargs)\n            else:\n                kwargs.setdefault(\"error\", self._exception)\n                raise error_factory(message.format(*args, **kwargs))", "response": "Raises an exception produced by error_factory if a predicate fails."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef or_call(self, _callable, *args, **kwargs):\n        if self._exception:\n            _callable(*args, **kwargs)", "response": "Calls _callable with supplied args and kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_command(self):\n        try:\n            message_bytes = self.socket.recv(zmq.NOBLOCK)\n            log.debug(\"Received message: %r\", message_bytes)\n        except zmq.ZMQError as exc:\n            if exc.errno == zmq.EAGAIN:\n                return None\n            else:\n                raise\n        else:\n            return message_bytes.decode(config.CODEC)", "response": "Attempt to return a unicode object from the command socket\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a unicode object as reply to the most recently - issued command", "response": "def send_response(self, response):\n        \"\"\"Send a unicode object as reply to the most recently-issued command\n        \"\"\"\n        response_bytes = response.encode(config.CODEC)\n        log.debug(\"About to send reponse: %r\", response_bytes)\n        self.socket.send(response_bytes)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_command(self, command):\n        words = shlex.split(command.lower())\n        return words[0], words[1:]", "response": "Break a multi word command up into an action and its parameters"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dispatch(self, command):\n        log.info(\"Dispatch on %s\", command)\n        if not command:\n            return \"OK\"\n        \n        action, params = self.parse_command(command)\n        log.debug(\"Action = %s, Params = %s\", action, params)\n        try:\n            function = getattr(self, \"do_\" + action, None)\n            if function:\n                function(*params)\n            return \"OK\"\n        except KeyboardInterrupt:\n            raise\n        except Exception as exc:\n            log.exception(\"Problem executing action %s\", action)\n            return \"ERROR: %s\" % exc", "response": "Pass a command along with its params to a suitable handler\nalido."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npasses a command directly to the current output processor", "response": "def do_output(self, *args):\n        \"\"\"Pass a command directly to the current output processor\n        \"\"\"\n        if args:\n            action, params = args[0], args[1:]\n            log.debug(\"Pass %s directly to output with %s\", action, params)\n            function = getattr(self.output, \"do_\" + action, None)\n            if function:\n                function(*params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates or retrieve a socket of the right type with the right role.", "response": "def get_socket(self, address, role):\n        \"\"\"Create or retrieve a socket of the right type, already connected\n        to the address. Address (ip:port) must be fully specified at this\n        point. core.address can be used to generate an address.\n        \"\"\"\n        #\n        # If this thread doesn't yet have a sockets cache\n        # in its local storage, create one here.\n        #\n        try:\n            self._tls.sockets\n        except AttributeError:\n            self._tls.sockets = {}\n        \n        # Convert the address to a single canonical string.\n        #\n        # If a list of addresses is passed, turn it into a tuple\n        # of canonical addresses for use as a dictionary key. \n        # Otherwise convert it to a single canonical string.\n        #\n        if isinstance(address, list):\n            caddress = tuple(core.address(a) for a in address)\n        else:\n            caddress = core.address(address)\n            \n        #\n        # Each socket is identified for this thread by its address(es)\n        # and the role the socket is playing (listener, publisher, etc.)\n        # That is, within one thread, we are cacheing a read or a write\n        # socket to the same address(es).\n        #\n        # The slight corner case from this is that if you attempt to\n        # send to [addressA, addressB] and then to addressA and then\n        # to [addressB, addressA], three separate sockets will be\n        # created and used.\n        #\n        identifier = caddress\n        \n        if identifier not in self._tls.sockets:\n            _logger.debug(\"%s does not exist in local sockets\", identifier)\n            #\n            # If this is a listening / subscribing socket, it can only\n            # be bound once, regardless of thread. Therefore keep a\n            # threads-global list of addresses used and make sure this\n            # one hasn't been used elsewhere.\n            #\n            if role in Socket.binding_roles:\n                with self._lock:\n                    if identifier in self._sockets:\n                        raise core.SocketAlreadyExistsError(\"You cannot create a listening socket in more than one thread\")\n                    else:\n                        self._sockets.add(identifier)\n            \n            type = self.roles[role]\n            socket = context.socket(type)\n            socket.role = role\n            socket.address = caddress\n            #\n            # Do this last so that an exception earlier will result\n            # in the socket not being cached\n            #\n            self._tls.sockets[identifier] = socket\n        else:\n            _logger.debug(\"%s already not exist in local sockets\", identifier)\n            #\n            # Only return sockets created in this thread\n            #\n            socket = self._tls.sockets[identifier]\n\n        return socket"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef intervals_ms(self, timeout_ms):\n        if timeout_ms is config.FOREVER:\n            while True:\n                yield self.try_length_ms\n        else:\n            whole_intervals, part_interval = divmod(timeout_ms, self.try_length_ms)\n            for _ in range(whole_intervals):\n                yield self.try_length_ms\n            yield part_interval", "response": "Generate a series of intervals in ms."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking for socket activity and return what s received on the socket or time out if timeout_s expires otherwise raise SocketTimedOutError", "response": "def _receive_with_timeout(self, socket, timeout_s, use_multipart=False):\n        \"\"\"Check for socket activity and either return what's\n        received on the socket or time out if timeout_s expires\n        without anything on the socket.\n        \n        This is implemented in loops of self.try_length_ms milliseconds \n        to allow Ctrl-C handling to take place.\n        \"\"\"\n        if timeout_s is config.FOREVER:\n            timeout_ms = config.FOREVER\n        else:\n            timeout_ms = int(1000 * timeout_s)\n\n        poller = zmq.Poller()\n        poller.register(socket, zmq.POLLIN)\n        ms_so_far = 0\n        try:\n            for interval_ms in self.intervals_ms(timeout_ms):\n                sockets = dict(poller.poll(interval_ms))\n                ms_so_far += interval_ms\n                if socket in sockets:\n                    if use_multipart:\n                        return socket.recv_multipart()\n                    else:\n                        return socket.recv()\n            else:\n                raise core.SocketTimedOutError(timeout_s)\n        except KeyboardInterrupt:\n            raise core.SocketInterruptedError(ms_so_far / 1000.0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting boxes and lines using labels as id.", "response": "def get_boxes_and_lines(ax, labels):\n    \"\"\"Get boxes and lines using labels as id.\"\"\"\n    labels_u, labels_u_line = get_labels(labels)\n    boxes = ax.findobj(mpl.text.Annotation)\n    lines = ax.findobj(mpl.lines.Line2D)\n    lineid_boxes = []\n    lineid_lines = []\n\n    for box in boxes:\n        l = box.get_label()\n        try:\n            loc = labels_u.index(l)\n        except ValueError:\n            # this box is either one not added by lineidplot or has no label.\n            continue\n        lineid_boxes.append(box)\n\n    for line in lines:\n        l = line.get_label()\n        try:\n            loc = labels_u_line.index(l)\n        except ValueError:\n            # this line is either one not added by lineidplot or has no label.\n            continue\n        lineid_lines.append(line)\n\n    return lineid_boxes, lineid_lines"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncoloring text boxes. Instead of this function, one can pass annotate_kwargs and plot_kwargs to plot_line_ids function.", "response": "def color_text_boxes(ax, labels, colors, color_arrow=True):\n    \"\"\"Color text boxes.\n\n    Instead of this function, one can pass annotate_kwargs and plot_kwargs to\n    plot_line_ids function.\n    \"\"\"\n    assert len(labels) == len(colors), \\\n        \"Equal no. of colors and lables must be given\"\n    boxes = ax.findobj(mpl.text.Annotation)\n    box_labels = lineid_plot.unique_labels(labels)\n    for box in boxes:\n        l = box.get_label()\n        try:\n            loc = box_labels.index(l)\n        except ValueError:\n            continue  # No changes for this box\n        box.set_color(colors[loc])\n        if color_arrow:\n            box.arrow_patch.set_color(colors[loc])\n\n    ax.figure.canvas.draw()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncolor lines. Instead of this function, one can pass annotate_kwargs and plot_kwargs to plot_line_ids function.", "response": "def color_lines(ax, labels, colors):\n    \"\"\"Color lines.\n\n    Instead of this function, one can pass annotate_kwargs and plot_kwargs to\n    plot_line_ids function.\n    \"\"\"\n    assert len(labels) == len(colors), \\\n        \"Equal no. of colors and lables must be given\"\n    lines = ax.findobj(mpl.lines.Line2D)\n    line_labels = [i + \"_line\" for i in lineid_plot.unique_labels(labels)]\n    for line in lines:\n        l = line.get_label()\n        try:\n            loc = line_labels.index(l)\n        except ValueError:\n            continue  # No changes for this line\n        line.set_color(colors[loc])\n\n    ax.figure.canvas.draw()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_tool_definition(self, target):\n        if target not in self.targets_mcu_list:\n            logging.debug(\"Target not found in definitions\")\n            return None\n        mcu_record = self.targets.get_mcu_record(target) if self.mcus.get_mcu_record(target) is None else self.mcus.get_mcu_record(target)\n        try:\n            return mcu_record['tool_specific'][self.tool]\n        except KeyError:\n            return None", "response": "Returns the tool specific dic or None if it does not exist for the given target"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_supported(self, target):\n        if target.lower() not in self.targets_mcu_list:\n            logging.debug(\"Target not found in definitions\")\n            return False\n        mcu_record = self.targets.get_mcu_record(target) if self.mcus.get_mcu_record(target) is None else self.mcus.get_mcu_record(target)\n        # Look at tool specific options which define tools supported for target\n        # TODO: we might create a list of what tool requires\n        if self.tool:\n            # tool_specific requested look for it\n            try:\n                for k,v in mcu_record['tool_specific'].items():\n                    if k == self.tool:\n                        return True\n            except (TypeError, KeyError) as err:\n                pass\n            return False\n        else:\n            # supports generic part (mcu part)\n            return True", "response": "Returns True if target is supported by definitions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef aliases_of(self, name):\n        names = []\n        key = name\n        # self.aliases keys are aliases, not realkeys. Easy test to see if we\n        # should flip around to the POV of a realkey when given an alias.\n        if name in self.aliases:\n            key = self.aliases[name]\n            # Ensure the real key shows up in output.\n            names.append(key)\n        # 'key' is now a realkey, whose aliases are all keys whose value is\n        # itself. Filter out the original name given.\n        names.extend([\n            k for k, v\n            in six.iteritems(self.aliases)\n            if v == key and k != name\n        ])\n        return names", "response": "Returns other names for given real key or alias name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrendering the current state of the object at the specified time.", "response": "def render(self, at):\n        # draw bg\n        surf = self.surf\n        surf.fill(BASE3)\n        bg = pygame.Surface((self.size[0], self.bar_height))\n        bg.fill(BASE2)\n        surf.blit(bg, (0, 0))\n        # draw bar\n        ratio = self.gauge.get(at) / float(self.gauge.max(at))\n        if ratio > 1:\n            bar_color = BLUE\n            ratio = 1\n        elif ratio == 1:\n            bar_color = CYAN\n        elif ratio > 0.3:\n            bar_color = GREEN\n        elif ratio > 0.1:\n            bar_color = YELLOW\n        elif ratio > 0:\n            bar_color = ORANGE\n        if ratio > 0:\n            bar = pygame.Surface((int(self.size[0] * ratio), self.bar_height))\n            bar.fill(bar_color)\n            surf.blit(bar, (0, 0))\n        # write current state\n        text = font.render('{0}/{1}'.format(\n            int(self.gauge.get(at)), self.gauge.max(at)), True, BASE1)\n        surf.blit(text, (10, font.get_height() / 2))\n        # write time recover in\n        speed = self.gauge.velocity(at)\n        if speed != 0:\n            text = font.render('{0:+.2f}/s'.format(speed), True,\n                               GREEN if speed > 0 else RED)\n            surf.blit(text, (surf.get_width() - text.get_width() - 10,\n                             font.get_height() / 2))\n        '''\n        try:\n            move_in = self.gauge.momenta[0].move_in(self.gauge, at)\n        except (AttributeError, IndexError):\n            pass\n        else:\n            if move_in:\n                move_in = math.ceil(move_in)\n                text = font.render('{0:02.0f}:{1:02.0f}'.format(\n                    move_in / 60, move_in % 60), True, text_colors[1])\n                surf.blit(text, (surf.get_width() - text.get_width() - 10,\n                                 font.get_height() / 2))\n        '''\n        return surf"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef survey_change_name(request, pk):\n    survey = get_object_or_404(Survey, pk=pk)\n\n    if not request.user.has_perm(\"formly.change_survey_name\", obj=survey):\n        raise PermissionDenied()\n\n    survey.name = request.POST.get(\"name\")\n    survey.save()\n    return JsonResponse({\n        \"status\": \"OK\",\n        \"name\": survey.name\n    })", "response": "Changes the name of a survey"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef uridefrag(uristring):\n    if isinstance(uristring, bytes):\n        parts = uristring.partition(b'#')\n    else:\n        parts = uristring.partition(u'#')\n    return DefragResult(parts[0], parts[2] if parts[1] else None)", "response": "Remove an existing fragment component from a URI reference string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the recombined version of the original URI as a string.", "response": "def geturi(self):\n        \"\"\"Return the recombined version of the original URI as a string.\"\"\"\n        fragment = self.fragment\n        if fragment is None:\n            return self.uri\n        elif isinstance(fragment, bytes):\n            return self.uri + b'#' + fragment\n        else:\n            return self.uri + u'#' + fragment"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getfragment(self, default=None, encoding='utf-8', errors='strict'):\n        fragment = self.fragment\n        if fragment is not None:\n            return uridecode(fragment, encoding, errors)\n        else:\n            return default", "response": "Return the decoded fragment identifier or default if the original URI did not contain a fragment component."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_all_files(glob):\n    for finder in finders.get_finders():\n        for path, storage in finder.list([]):\n            if fnmatch.fnmatchcase(os.path.join(getattr(storage, 'prefix', '')\n                                                or '', path),\n                                   glob):\n                yield path, storage", "response": "Find all files in the django finders for a given glob"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef open_video(specifier):\n    if specifier.startswith('device:'):\n        specifier_dev = int(specifier[7:])\n        log.debug('Opening video device {0}...'.format(specifier_dev))\n        vc = cv2.VideoCapture(specifier_dev)\n    elif specifier.startswith('raw:'):\n        try:\n            w, h = tuple(int(x) for x in specifier[4:].split('x'))\n        except ValueError:\n            log.error('Could not parse raw specifier size from \"{0}\"'.format(specifier))\n            return 1\n        log.debug('Using raw video with shape {0}x{1}'.format(w,h))\n        vc = _RawVideoCapture(w, h)\n    else:\n        log.debug('Using OpenCV video capture on {0}'.format(specifier))\n        vc = cv2.VideoCapture(specifier)\n\n    return vc", "response": "Open a new video capture object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef corner_shape_parameters(corners, frame_shape, cb_shape):\n    corners = corners.reshape(-1, 2)\n    assert corners.shape[0] == cb_shape[0] * cb_shape[1]\n\n    h, w = frame_shape\n\n    # Extract the \"outside\" corners which define the shape of the board in\n    # a clockwise order. I.e. [A,B,C,D] where:\n    #\n    # A----B\n    # |    |\n    # D----C\n    A, B, C, D = tuple(x.reshape(-1) for x in corners[[0, cb_shape[0]-1, -1, -cb_shape[0]], :])\n\n    ba, bc = A - B, C - B   # Edges\n    bd, ac = D - B, C - A   # Diagonals\n\n    # Compute the angle between AB and BC\n    angle = np.arccos(np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc)))\n\n    # Compute skew metric\n    skew = min(1, 2 * np.abs(0.5*np.pi - angle))\n\n    # Compute area (assuming quadrilateral) and hence size metric\n    area = 0.5 * np.abs(bd[0]*ac[1] - bd[1]*ac[0])\n    size = np.sqrt(area / (h*w))\n\n    # For X and Y, we \"shrink\" the image all around by approx. half the board\n    # size. Otherwise large boards are penalized because you can't get much\n    # X/Y variation.\n    border = np.sqrt(area)\n    X = np.clip((np.mean(corners[:,0]) - 0.5*border) / (w - border), 0, 1)\n    Y = np.clip((np.mean(corners[:,1]) - 0.5*border) / (h - border), 0, 1)\n\n    return (X, Y, size, skew)", "response": "Returns a tuple of shape parameters for a given set of corners."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef click(self, locator, params=None, timeout=None):\n        self._click(locator, params, timeout)", "response": "Click web element.\n\n        :param locator: locator tuple or WebElement instance\n        :param params: (optional) locator parameters\n        :param timeout: (optional) time to wait for element\n        :return: None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef shift_click(self, locator, params=None, timeout=None):\n        self._click(locator, params, timeout, Keys.SHIFT)", "response": "Shift - click web element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclick and releases control or command key depending on OS.", "response": "def multi_click(self, locator, params=None, timeout=None):\n        \"\"\"\n        Presses left control or command button depending on OS, clicks and then releases control or command key.\n\n        :param locator: locator tuple or WebElement instance\n        :param params: (optional) locator parameters\n        :param timeout: (optional) time to wait for element\n        :return: None\n        \"\"\"\n        platform = self.execute_script('return navigator.platform')\n        multi_key = Keys.COMMAND if 'mac' in platform.lower() else Keys.LEFT_CONTROL\n        self._click(locator, params, timeout, multi_key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shift_select(self, first_element, last_element):\n        self.click(first_element)\n        self.shift_click(last_element)", "response": "Clicks a web element and shift clicks another web element."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef multi_select(self, elements_to_select):\n        # Click the first element\n        first_element = elements_to_select.pop()\n        self.click(first_element)\n\n        # Click the rest\n        for index, element in enumerate(elements_to_select, start=1):\n            self.multi_click(element)", "response": "Multi - select any number of elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef select_from_drop_down_by_value(self, locator, value, params=None):\n        from selenium.webdriver.support.ui import Select\n\n        element = locator\n        if not isinstance(element, WebElement):\n            element = self.get_present_element(locator, params)\n\n        Select(element).select_by_value(value)", "response": "Select option from drop down widget using value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select_from_drop_down_by_text(self, drop_down_locator, option_locator, option_text, params=None):\n        # Open/activate drop down\n        self.click(drop_down_locator, params['drop_down'] if params else None)\n\n        # Get options\n        for option in self.get_present_elements(option_locator, params['option'] if params else None):\n            if self.get_text(option) == option_text:\n                self.click(option)\n                break", "response": "Select option from drop down widget using text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nselect option from drop down widget using locator.", "response": "def select_from_drop_down_by_locator(self, drop_down_locator, option_locator, params=None):\n        \"\"\"\n        Select option from drop down widget using locator.\n\n        :param drop_down_locator: locator tuple or WebElement instance\n        :param option_locator: locator tuple or WebElement instance\n        :param params: Dictionary containing dictionary of params\n        :return: None\n        \"\"\"\n        # Open/activate drop down\n        self.click(drop_down_locator, params['drop_down'] if params else None)\n\n        # Click option in drop down\n        self.click(option_locator, params['option'] if params else None)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_attribute(self, locator, attribute, params=None, timeout=None, visible=False):\n        element = locator\n        if not isinstance(element, WebElement):\n            element = self.get_present_element(locator, params, timeout, visible)\n\n        try:\n            return element.get_attribute(attribute)\n        except AttributeError:\n            msg = \"Element with attribute <{}> was never located!\".format(attribute)\n            raise NoSuchElementException(msg)", "response": "Get attribute from element based on locator with optional parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget text or value from element based on locator with optional parameters.", "response": "def get_text(self, locator, params=None, timeout=None, visible=True):\n        \"\"\"\n        Get text or value from element based on locator with optional parameters.\n\n        :param locator: element identifier\n        :param params: (optional) locator parameters\n        :param timeout: (optional) time to wait for text (default: None)\n        :param visible: should element be visible before getting text (default: True)\n        :return: element text, value or empty string\n        \"\"\"\n        element = locator\n        if not isinstance(element, WebElement):\n            element = self.get_present_element(locator, params, timeout, visible)\n\n        if element and element.text:\n            return element.text\n        else:\n            try:\n                return element.get_attribute('value')\n            except AttributeError:\n                return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nentering text into a web element.", "response": "def enter_text(self, locator, text, with_click=True, with_clear=False, with_enter=False, params=None):\n        \"\"\"\n        Enter text into a web element.\n\n        :param locator: locator tuple or WebElement instance\n        :param text: text to input\n        :param with_click: clicks the input field\n        :param with_clear: clears the input field\n        :param with_enter: hits enter-key after text input\n        :param params: (optional) locator params\n        :return: None\n        \"\"\"\n        element = locator\n        if not isinstance(element, WebElement):\n            element = self.get_visible_element(locator, params)\n\n        if with_click:\n            self.click(element)\n\n        actions = ActionChains(self.driver)\n        if 'explorer' in self.driver.name and \"@\" in str(text):\n            actions = BasePage.handle_at_sign_for_ie(text, actions)\n        else:\n            actions.send_keys_to_element(element, text)\n\n        if with_clear:\n            element.clear()\n            # Click to regain focus as clear does clear w/ blur by design -\n            # https://w3c.github.io/webdriver/webdriver-spec.html#element-clear\n            self.click(element)\n\n        if with_enter:\n            actions.send_keys(Keys.ENTER)\n\n        actions.perform()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles typing @ symbols in input fields for internet explorer due to it failing when done normally.", "response": "def handle_at_sign_for_ie(text, actions):\n        \"\"\"\n        Handles typing @ symbols in input fields for internet explorer due to it failing when done normally.\n\n        :param text: desired string ot text to input\n        :param actions: ActionChains object\n        :return: ActionChains Object\n        \"\"\"\n        text_list = text.split(\"@\")\n        for entry in text_list:\n            if entry is not text_list[0]:\n                actions.key_down(Keys.CONTROL).\\\n                    key_down(Keys.ALT).\\\n                    send_keys(\"2\").\\\n                    key_up(Keys.CONTROL).\\\n                    key_up(Keys.ALT)\n            actions.send_keys(entry)\n        return actions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nerase text from web element.", "response": "def erase_text(self, locator, click=True, clear=False, backspace=0, params=None):\n        \"\"\"\n        Various ways to erase text from web element.\n\n        :param locator: locator tuple or WebElement instance\n        :param click: clicks the input field\n        :param clear: clears the input field\n        :param backspace: how many times to hit backspace\n        :param params: (optional) locator params\n        :return: None\n        \"\"\"\n        element = locator\n        if not isinstance(element, WebElement):\n            element = self.get_visible_element(locator, params)\n\n        if click:\n            self.click(element)\n\n        if clear:\n            element.clear()\n\n        if backspace:\n            actions = ActionChains(self.driver)\n            for _ in range(backspace):\n                actions.send_keys(Keys.BACKSPACE)\n            actions.perform()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndragging source element and drop at target element.", "response": "def drag_and_drop(self, source_element, target_element, params=None):\n        \"\"\"\n        Drag source element and drop at target element.\n\n        Note: Target can either be a WebElement or a list with x- and y-coordinates (integers)\n\n        :param source_element: WebElement instance\n        :param target_element: WebElement instance or list of x- and y-coordinates\n        :param params: Dictionary containing dictionary of params\n        :return: None\n        \"\"\"\n        if not isinstance(source_element, WebElement):\n            source_element = self.get_visible_element(source_element, params['source'] if params else None)\n        if not isinstance(target_element, WebElement) and not isinstance(target_element, list):\n            source_element = self.get_visible_element(target_element, params['target'] if params else None)\n\n        action = ActionChains(self.driver)\n        if isinstance(target_element, WebElement):\n            action.drag_and_drop(source_element, target_element)\n        else:\n            action.click_and_hold(source_element).move_by_offset(*target_element).release()\n\n        action.perform()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nis element that contains text present.", "response": "def is_element_with_text_present(self, locator, text, params=None, visible=False):\n        \"\"\"\n        Is element that contains <text> either by text or by attribute value present.\n\n        Note: Will return the element if the outcome is positive.\n\n        :param locator: locator tuple or list of WebElements\n        :param text: text that the element should contain\n        :param params: (optional) locator parameters\n        :param visible: (optional) if the element should also be visible (default: False)\n        :return: WebElement instance or False\n        \"\"\"\n        elements = self.get_present_elements(locator, params, 0, visible) if not isinstance(locator, list) else locator\n\n        if not elements:  # Can't iterate over bool\n            return False\n\n        for element in elements:\n            element_text = self.get_text(element)\n            if element_text is not None and text in element_text.strip():\n                return element\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_element_with_text(self, locator, text, params=None, timeout=None, visible=False):\n        if timeout is None:\n            timeout = self._explicit_wait\n\n        @wait(exceptions=ElementNotVisibleException, timeout=timeout)\n        def _wait_for_text():\n            return self.is_element_with_text_present(locator, text, params, visible)\n\n        msg = \"Element with type <{}>, locator <{}> and text <{text}> was never located!\".format(\n            *locator, text=text) if not isinstance(locator, list) else \\\n            \"None of the elements had the text: {}\".format(text)\n\n        if timeout == 0:\n            return self.is_element_with_text_present(locator, text, params, visible)\n\n        try:\n            return _wait_for_text()\n        except RuntimeError as e:\n            LOGGER.debug(e)\n            raise NoSuchElementException(msg)", "response": "Get element that contains text."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets element present in the DOM.", "response": "def get_present_element(self, locator, params=None, timeout=None, visible=False, parent=None):\n        \"\"\"\n        Get element present in the DOM.\n\n        If timeout is 0 (zero) return WebElement instance or None, else we wait and retry for timeout and raise\n        TimeoutException should the element not be found.\n\n        :param locator: element identifier\n        :param params: (optional) locator parameters\n        :param timeout: (optional) time to wait for element (default: self._explicit_wait)\n        :param visible: (optional) if the element should also be visible (default: False)\n        :param parent: internal (see #get_present_child)\n        :return: WebElement instance\n        \"\"\"\n        error_msg = \"Child was never present\" if parent else \"Element was never present!\"\n        expected_condition = ec.visibility_of_element_located if visible else ec.presence_of_element_located\n        return self._get(locator, expected_condition, params, timeout, error_msg, parent)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets element both present AND visible in the DOM.", "response": "def get_visible_element(self, locator, params=None, timeout=None):\n        \"\"\"\n        Get element both present AND visible in the DOM.\n\n        If timeout is 0 (zero) return WebElement instance or None, else we wait and retry for timeout and raise\n        TimeoutException should the element not be found.\n\n        :param locator: locator tuple\n        :param params: (optional) locator params\n        :param timeout: (optional) time to wait for element (default: self._explicit_wait)\n        :return: WebElement instance\n        \"\"\"\n        return self.get_present_element(locator, params, timeout, True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets elements present in the DOM.", "response": "def get_present_elements(self, locator, params=None, timeout=None, visible=False, parent=None):\n        \"\"\"\n        Get elements present in the DOM.\n\n        If timeout is 0 (zero) return WebElement instance or None, else we wait and retry for timeout and raise\n        TimeoutException should the element not be found.\n\n        :param locator: element identifier\n        :param params: (optional) locator parameters\n        :param timeout: (optional) time to wait for element (default: self._explicit_wait)\n        :param visible: (optional) if the element should also be visible (default: False)\n        :param parent: internal (see #get_present_children)\n        :return: WebElement instance\n        \"\"\"\n        error_msg = \"Children were never present\" if parent else \"Elements were never present!\"\n        expected_condition = ec.visibility_of_all_elements_located if visible else ec.presence_of_all_elements_located\n        return self._get(locator, expected_condition, params, timeout, error_msg, parent)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting elements both present AND visible in the DOM.", "response": "def get_visible_elements(self, locator, params=None, timeout=None):\n        \"\"\"\n        Get elements both present AND visible in the DOM.\n\n        If timeout is 0 (zero) return WebElement instance or None, else we wait and retry for timeout and raise\n        TimeoutException should the element not be found.\n\n        :param locator: locator tuple\n        :param params: (optional) locator params\n        :param timeout: (optional) time to wait for element (default: self._explicit_wait)\n        :return: WebElement instance\n        \"\"\"\n        return self.get_present_elements(locator, params, timeout, True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting child - element present in the DOM.", "response": "def get_present_child(self, parent, locator, params=None, timeout=None, visible=False):\n        \"\"\"\n        Get child-element present in the DOM.\n\n        If timeout is 0 (zero) return WebElement instance or None, else we wait and retry for timeout and raise\n        TimeoutException should the element not be found.\n\n        :param parent: parent-element\n        :param locator: locator tuple\n        :param params: (optional) locator params\n        :param timeout: (optional) time to wait for element (default: self._explicit_wait)\n        :param visible: (optional) if the element should also be visible (default: False)\n        :return: WebElement instance\n        \"\"\"\n        return self.get_present_element(locator, params, timeout, visible, parent=parent)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_visible_child(self, parent, locator, params=None, timeout=None):\n        return self.get_present_child(parent, locator, params, timeout, True)", "response": "Get child - element both present AND visible in the DOM."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_present_children(self, parent, locator, params=None, timeout=None, visible=False):\n        return self.get_present_elements(locator, params, timeout, visible, parent=parent)", "response": "Get child - elements both present in the DOM."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget child - elements both present AND visible in the DOM.", "response": "def get_visible_children(self, parent, locator, params=None, timeout=None):\n        \"\"\"\n        Get child-elements both present AND visible in the DOM.\n\n        If timeout is 0 (zero) return WebElement instance or None, else we wait and retry for timeout and raise\n        TimeoutException should the element not be found.\n\n        :param parent: parent-element\n        :param locator: locator tuple\n        :param params: (optional) locator params\n        :param timeout: (optional) time to wait for element (default: self._explicit_wait)\n        :return: WebElement instance\n        \"\"\"\n        return self.get_present_children(parent, locator, params, timeout, True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting elements based on locator with optional parameters.", "response": "def _get(self, locator, expected_condition, params=None, timeout=None, error_msg=\"\", driver=None, **kwargs):\n        \"\"\"\n        Get elements based on locator with optional parameters.\n\n        Uses selenium.webdriver.support.expected_conditions to determine the state of the element(s).\n\n        :param locator: element identifier\n        :param expected_condition: expected condition of element (ie. visible, clickable, etc)\n        :param params: (optional) locator parameters\n        :param timeout: (optional) time to wait for element (default: self._explicit_wait)\n        :param error_msg: (optional) customized error message\n        :param driver: (optional) alternate Webdriver instance (example: parent-element)\n        :param kwargs: optional arguments to expected conditions\n        :return: WebElement instance, list of WebElements, or None\n        \"\"\"\n        from selenium.webdriver.support.ui import WebDriverWait\n\n        if not isinstance(locator, WebElement):\n            error_msg += \"\\nLocator of type <{}> with selector <{}> with params <{params}>\".format(\n                *locator, params=params)\n            locator = self.__class__.get_compliant_locator(*locator, params=params)\n\n        _driver = driver or self.driver\n\n        exp_cond = expected_condition(locator, **kwargs)\n        if timeout == 0:\n            try:\n                return exp_cond(_driver)\n            except NoSuchElementException:\n                return None\n\n        if timeout is None:\n            timeout = self._explicit_wait\n\n        error_msg += \"\\nExpected condition: {}\" \\\n                     \"\\nTimeout: {}\".format(expected_condition, timeout)\n\n        return WebDriverWait(_driver, timeout).until(exp_cond, error_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef scroll_element_into_view(self, selector):\n        element = selector\n        if isinstance(element, WebElement):\n            self.execute_script(\"arguments[0].scrollIntoView( true );\", element)\n        else:\n            self.execute_script(\"$('{}')[0].scrollIntoView( true );\".format(selector[1]))", "response": "Scrolls an element into view."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef open_hover(self, locator, params=None, use_js=False):\n        element = locator\n        if not isinstance(element, WebElement):\n            element = self.get_visible_element(locator, params)\n\n        if use_js:\n            self._js_hover('mouseover', element)\n            return element\n        actions = ActionChains(self.driver)\n        actions.move_to_element(element).perform()\n        actions.reset_actions()\n        return element", "response": "Open a hover or popover."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef close_hover(self, element, use_js=False):\n        try:\n            if use_js:\n                self._js_hover('mouseout', element)\n            else:\n                actions = ActionChains(self.driver)\n                actions.move_to_element_with_offset(element, -100, -100)\n                actions.reset_actions()\n        except (StaleElementReferenceException, MoveTargetOutOfBoundsException):\n            return True", "response": "Close hover by moving to an offset away from the element being hovered."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhovering an element and performs whatever action is specified in the supplied function.", "response": "def perform_hover_action(self, locator, func, error_msg='', exceptions=None, params=None,\n                             alt_loc=None, alt_params=None, **kwargs):\n        \"\"\"\n        Hovers an element and performs whatever action is specified in the supplied function.\n\n        NOTE: Specified function MUST return a non-false value upon success!\n\n        :param locator: locator tuple or WebElement instance\n        :param func: action to perform while hovering\n        :param error_msg: error message to display if hovering failed\n        :param exceptions: list of exceptions (default: StaleElementReferenceException)\n        :param params: (optional) locator parameters\n        :param alt_loc: alternate locator tuple or WebElement instance to move to with offset\n        :param alt_params: (optional) alternate locator parameters\n        :param kwargs: keyword arguments to the function func\n        :return: result of performed action\n        \"\"\"\n        def _do_hover():\n            try:\n                with self.hover(locator, params, alt_loc, alt_params):\n                    return func(**kwargs)\n            except exc:\n                return False\n\n        exc = [StaleElementReferenceException]\n        if exceptions is not None:\n            try:\n                exc.extend(iter(exceptions))\n            except TypeError:  # exceptions is not iterable\n                exc.append(exceptions)\n        exc = tuple(exc)\n\n        msg = error_msg or \"Performing hover actions failed!\"\n        return ActionWait().until(_do_hover, msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef hover(self, locator, params=None, use_js=False, alt_loc=None, alt_params=None):\n        # Open hover\n        element = self.open_hover(locator, params, use_js)\n        try:\n            yield\n        finally:\n            # Close hover\n            if alt_loc:\n                element = alt_loc\n                if not isinstance(element, WebElement):\n                    element = self.get_visible_element(alt_loc, alt_params)\n            self.close_hover(element, use_js)", "response": "Context manager for hovering. Opens and closes the hover."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wait_for_element_to_disappear(self, locator, params=None, timeout=None):\n        exp_cond = eec.invisibility_of if isinstance(locator, WebElement) else ec.invisibility_of_element_located\n        try:\n            self._get(locator, exp_cond, params, timeout, error_msg=\"Element never disappeared\")\n        except (StaleElementReferenceException, NoSuchElementException):\n            return True", "response": "Waits until the element identified by locator is disappeared."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwaits and get elements when they re populated with any text.", "response": "def wait_for_non_empty_text(self, locator, params=None, timeout=5):\n        \"\"\"\n        Wait and get elements when they're populated with any text.\n\n        :param locator: locator tuple\n        :param params: (optional) locator params\n        :param timeout: (optional) maximum waiting time (in seconds) (default: 5)\n        :return: list of WebElements\n        \"\"\"\n        def _do_wait():\n            elements = self.get_present_elements(locator, params, timeout=0)\n            for element in elements:\n                if not self.get_text(element):\n                    return False\n            return elements\n\n        return ActionWait(timeout).until(_do_wait, \"Element text was never populated!\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wait_for_attribute(self, locator, attribute, value, params=None, timeout=5):\n        def _do_wait():\n            element = self.get_present_element(locator, params)\n            return value in self.get_attribute(element, attribute)\n\n        ActionWait(timeout).until(_do_wait, \"Attribute never set!\")", "response": "Waits for an element attribute to get a certain value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait_for_ajax_calls_to_complete(self, timeout=5):\n        from selenium.webdriver.support.ui import WebDriverWait\n\n        WebDriverWait(self.driver, timeout).until(lambda s: s.execute_script(\"return jQuery.active === 0\"))", "response": "Waits until all ajax requests have been completed."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload_to_file_input(self, locator, path, params=None):\n        element = locator\n        if not isinstance(element, WebElement):\n            element = self.get_visible_element(locator, params)\n\n        element.send_keys(path)", "response": "Uploads a file to an element."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_valid_ip_pattern(ip):\n    ip = ip.replace('*', '1')\n    try:\n        socket.inet_aton(ip)\n        return True\n    except socket.error:\n        # Not a valid IPv4 address pattern\n        return False", "response": "Check whether a string matches the outline of an IPv4 address"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding each IP4 broadcast address and the all - broadcast node - list", "response": "def _find_ip4_broadcast_addresses():\n    \"\"\"Yield each IP4 broadcast address, and the all-broadcast\n    \"\"\"\n    yield \"255.255.255.255\"\n    for interface in netifaces.interfaces():\n        ifaddresses = netifaces.ifaddresses(interface)\n        for family in ifaddresses:\n            if family == netifaces.AF_INET:\n                address_info = ifaddresses[family]\n                for info in address_info:\n                    if \"broadcast\" in info:\n                        yield info['broadcast']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_ip4_addresses():\n    global _ip4_addresses\n    proto = socket.AF_INET\n    if _ip4_addresses is None:\n        _ip4_addresses = []\n\n        #\n        # Determine the interface for the default gateway\n        # (if any) and, later, prioritise the INET address on\n        # that interface.\n        #\n        default_gateway = netifaces.gateways()['default']\n        if proto in default_gateway:\n            _, default_gateway_interface = default_gateway[proto]\n        else:\n            default_gateway_interface = None\n\n        for interface in netifaces.interfaces():\n            for info in netifaces.ifaddresses(interface).get(netifaces.AF_INET, []):\n                if info['addr']:\n                    if interface == default_gateway_interface:\n                        _ip4_addresses.insert(0, info['addr'])\n                    else:\n                        _ip4_addresses.append(info['addr'])\n\n    return _ip4_addresses", "response": "Find all the IP4 addresses currently bound to interfaces\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert one of the input IP addresses into a valid IP address string.", "response": "def address(address=None):\n    \"\"\"Convert one of a number of inputs into a valid ip:port string.\n\n    Elements which are not provided are filled in as follows:\n\n        * IP Address: the system is asked for the set of IP addresses associated\n          with the machine and the first one is used, preferring those matching\n          `address` if it is a wildcard.\n        * Port number: a random port is selected from the pool of dynamically-available\n          port numbers.\n\n    This means you can pass any of: nothing; a hostname; an IP address; an IP address with wildcards; a port number\n\n    If an IP address is supplied but is invalid, an InvalidAddressError\n    exception is raised.\n\n    :param address: (optional) Any of: an IP address, a port number, or both\n\n    :returns: a valid ip:port string for this machine\n    \"\"\"\n    address = str(address or \"\").strip()\n    #\n    # If the address is an ip:port pair, split into its component parts.\n    # Otherwise, try to determine whether we're looking at an IP\n    # or at a port and leave the other one blank\n    #\n    host_or_ip, port = split_address(address)\n\n    #\n    # If the port has been supplied, make sure it's numeric and that it's a valid\n    # port number. If it hasn't been supplied, remove a random one from the pool\n    # of possible dynamically-allocated ports and use that.\n    #\n    if port:\n        try:\n            port = int(port)\n        except ValueError:\n            raise AddressError(\"Port %s must be a number\" % port)\n        if port not in config.VALID_PORTS:\n            raise AddressError(\"Port %d must be in range %d - %d\" % (\n                port, min(config.VALID_PORTS), max(config.VALID_PORTS))\n            )\n    else:\n        random.shuffle(PORT_POOL)\n        port = PORT_POOL.pop()\n\n    #\n    # The address part could be an IP address (optionally including\n    # wildcards to indicate a preference) or a hostname or nothing.\n    # If it's a hostname we attempt to resolve it to an IP address.\n    # It it's nothing or a wildcard we query the system for a matching IP address.\n    #\n    if (not host_or_ip) or is_valid_ip_pattern(host_or_ip):\n        #\n        # If a specific IP address is given, use that.\n        # If an IP pattern is given (ie something with a wildcard in it) treat\n        # that as no address with a preference for that wildcard.\n        #\n        prefer = None\n        if \"*\" in host_or_ip:\n            host_or_ip, prefer = None, [host_or_ip]\n\n        #\n        # If no IP (or only a wildcard) is specified, query the system for valid\n        # addresses, preferring those which match the wildcard. NB if the preference\n        # matches one we've previously used, we can return a cached address. But\n        # different requests can specify different wildcard preferences.\n        #\n        if not host_or_ip:\n            if _ip4 and _prefer == prefer:\n                ip = _ip4\n            else:\n                ip = _find_ip4(prefer)\n        else:\n            ip = host_or_ip\n\n    else:\n        #\n        # Treat the string as a hostname and resolve to an IP4 address\n        #\n        try:\n            ip = socket.gethostbyname(host_or_ip)\n        except socket.gaierror as exc:\n            _logger.error(\"gaierror %d for %s\", exc.errno, host_or_ip)\n            raise InvalidAddressError(host_or_ip, exc.errno)\n        else:\n            #\n            # Bizarrely specific check because BT Internet \"helpfully\"\n            # redirects DNS fails to this address which hosts a sponsored\n            # landing page!\n            #\n            if ip == \"92.242.132.15\":\n                raise InvalidAddressError(host_or_ip, 0)\n\n    return \"%s:%s\" % (ip, port)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculate_rate(phone_number, address_country_code=None, address_exception=None):\n\n    if not phone_number:\n        raise ValueError('No phone number provided')\n\n    if not isinstance(phone_number, str_cls):\n        raise ValueError('Phone number is not a string')\n\n    phone_number = phone_number.strip()\n    phone_number = re.sub('[^+0-9]', '', phone_number)\n\n    if not phone_number or phone_number[0] != '+':\n        raise ValueError('Phone number is not in international format with a leading +')\n\n    phone_number = phone_number[1:]\n\n    if not phone_number:\n        raise ValueError('Phone number does not appear to contain any digits')\n\n    country_code = _lookup_country_code(phone_number)\n    if not country_code:\n        raise ValueError('Phone number does not appear to be a valid international phone number')\n\n    if country_code in CALLING_CODE_EXCEPTIONS:\n        for info in CALLING_CODE_EXCEPTIONS[country_code]:\n            if not re.match(info['regex'], phone_number):\n                continue\n\n            mapped_country = info['country_code']\n            mapped_name = info['name']\n\n            if not info['definitive']:\n                if address_country_code is None:\n                    raise UndefinitiveError('It is not possible to determine the users VAT rates based on the information provided')\n\n                if address_country_code != mapped_country:\n                    continue\n\n                if address_exception != info['name']:\n                    continue\n\n            rate = rates.BY_COUNTRY[mapped_country]['exceptions'][mapped_name]\n            return (rate, mapped_country, mapped_name)\n\n    if country_code not in rates.BY_COUNTRY:\n        return (Decimal('0.0'), country_code, None)\n\n    return (rates.BY_COUNTRY[country_code]['rate'], country_code, None)", "response": "Calculates the VAT rate based on a phone number."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a two - character country code from a phone number.", "response": "def _lookup_country_code(phone_number):\n    \"\"\"\n    Accepts an international form of a phone number (+ followed by digits),\n    and returns a two-character country code.\n\n    :param phone_number:\n        The string phone number, in international format with leading +\n\n    :return:\n        A two-character string or None if no match\n    \"\"\"\n\n    leading_digit = phone_number[0]\n\n    if leading_digit not in CALLING_CODE_MAPPING:\n        return None\n\n    for mapping in CALLING_CODE_MAPPING[leading_digit]:\n        if not re.match(mapping['regex'], phone_number):\n            continue\n        return mapping['country_code']\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef urisplit(uristring):\n    if isinstance(uristring, bytes):\n        result = SplitResultBytes\n    else:\n        result = SplitResultUnicode\n    return result(*result.RE.match(uristring).groups())", "response": "Split a well - formed URI reference string into a tuple with five\n      components corresponding to a URI s general structure ::\n      <scheme >://<authority>/<path?query#fragment >"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncombining the elements of a five - item iterable into a URI reference s string representation.", "response": "def uriunsplit(parts):\n    \"\"\"Combine the elements of a five-item iterable into a URI reference's\n    string representation.\n\n    \"\"\"\n    scheme, authority, path, query, fragment = parts\n    if isinstance(path, bytes):\n        result = SplitResultBytes\n    else:\n        result = SplitResultUnicode\n    return result(scheme, authority, path, query, fragment).geturi()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef geturi(self):\n        scheme, authority, path, query, fragment = self\n\n        # RFC 3986 5.3. Component Recomposition\n        result = []\n        if scheme is not None:\n            result.extend([scheme, self.COLON])\n        if authority is not None:\n            result.extend([self.SLASH, self.SLASH, authority])\n        result.append(path)\n        if query is not None:\n            result.extend([self.QUEST, query])\n        if fragment is not None:\n            result.extend([self.HASH, fragment])\n        return self.EMPTY.join(result)", "response": "Return the re - combined version of the original URI reference as a\n        string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getscheme(self, default=None):\n        scheme = self.scheme\n        if scheme is None:\n            return default\n        elif isinstance(scheme, bytes):\n            return scheme.decode('ascii').lower()\n        else:\n            return scheme.lower()", "response": "Return the URI scheme in canonical ( lowercase form or default."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the decoded userinfo host and port subcomponents of the URI authority as a three - item tuple.", "response": "def getauthority(self, default=None, encoding='utf-8', errors='strict'):\n        \"\"\"Return the decoded userinfo, host and port subcomponents of the URI\n        authority as a three-item tuple.\n\n        \"\"\"\n        # TBD: (userinfo, host, port) kwargs, default string?\n        if default is None:\n            default = (None, None, None)\n        elif not isinstance(default, collections.Iterable):\n            raise TypeError('Invalid default type')\n        elif len(default) != 3:\n            raise ValueError('Invalid default length')\n        # TODO: this could be much more efficient by using a dedicated regex\n        return (\n            self.getuserinfo(default[0], encoding, errors),\n            self.gethost(default[1], errors),\n            self.getport(default[2])\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getuserinfo(self, default=None, encoding='utf-8', errors='strict'):\n        userinfo = self.userinfo\n        if userinfo is None:\n            return default\n        else:\n            return uridecode(userinfo, encoding, errors)", "response": "Return the decoded userinfo subcomponent of the URI authority or default if the original URI reference did not contain a specific userinfo field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the decoded host subcomponent of the URI authority as a string or an optional default value.", "response": "def gethost(self, default=None, errors='strict'):\n        \"\"\"Return the decoded host subcomponent of the URI authority as a\n        string or an :mod:`ipaddress` address object, or `default` if\n        the original URI reference did not contain a host.\n\n        \"\"\"\n        host = self.host\n        if host is None or (not host and default is not None):\n            return default\n        elif host.startswith(self.LBRACKET) and host.endswith(self.RBRACKET):\n            return _ip_literal(host[1:-1])\n        elif host.startswith(self.LBRACKET) or host.endswith(self.RBRACKET):\n            raise ValueError('Invalid host %r' % host)\n        # TODO: faster check for IPv4 address?\n        return _ipv4_address(host) or uridecode(host, 'utf-8', errors).lower()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the port subcomponent of the URI authority as an int or default.", "response": "def getport(self, default=None):\n        \"\"\"Return the port subcomponent of the URI authority as an\n        :class:`int`, or `default` if the original URI reference did\n        not contain a port or if the port was empty.\n\n        \"\"\"\n        port = self.port\n        if port:\n            return int(port)\n        else:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the normalized decoded URI path.", "response": "def getpath(self, encoding='utf-8', errors='strict'):\n        \"\"\"Return the normalized decoded URI path.\"\"\"\n        path = self.__remove_dot_segments(self.path)\n        return uridecode(path, encoding, errors)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getquery(self, default=None, encoding='utf-8', errors='strict'):\n        query = self.query\n        if query is None:\n            return default\n        else:\n            return uridecode(query, encoding, errors)", "response": "Return the decoded query string of the original URI\n        reference."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getquerydict(self, sep='&', encoding='utf-8', errors='strict'):\n        dict = collections.defaultdict(list)\n        for name, value in self.getquerylist(sep, encoding, errors):\n            dict[name].append(value)\n        return dict", "response": "Split the query component into individual name = value pairs\n        separated by sep and return a dictionary of query variables."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getquerylist(self, sep='&', encoding='utf-8', errors='strict'):\n        if not self.query:\n            return []\n        elif isinstance(sep, type(self.query)):\n            qsl = self.query.split(sep)\n        elif isinstance(sep, bytes):\n            qsl = self.query.split(sep.decode('ascii'))\n        else:\n            qsl = self.query.split(sep.encode('ascii'))\n        items = []\n        for parts in [qs.partition(self.EQ) for qs in qsl if qs]:\n            name = uridecode(parts[0], encoding, errors)\n            if parts[1]:\n                value = uridecode(parts[2], encoding, errors)\n            else:\n                value = None\n            items.append((name, value))\n        return items", "response": "Split the query component into individual name = value pairs\n            separated by sep and return a list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef isabspath(self):\n        return (self.scheme is None and self.authority is None and\n                self.path.startswith(self.SLASH))", "response": "Return : const : True if this is an absolute - path reference."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns : const : True if this is a relative - path reference.", "response": "def isrelpath(self):\n        \"\"\"Return :const:`True` if this is a relative-path reference.\"\"\"\n        return (self.scheme is None and self.authority is None and\n                not self.path.startswith(self.SLASH))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning : const : True if this is a same - document reference.", "response": "def issamedoc(self):\n        \"\"\"Return :const:`True` if this is a same-document reference.\"\"\"\n        return (self.scheme is None and self.authority is None and\n                not self.path and self.query is None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransforms a URI reference relative to self into a .", "response": "def transform(self, ref, strict=False):\n        \"\"\"Transform a URI reference relative to `self` into a\n        :class:`SplitResult` representing its target URI.\n\n        \"\"\"\n        scheme, authority, path, query, fragment = self.RE.match(ref).groups()\n\n        # RFC 3986 5.2.2. Transform References\n        if scheme is not None and (strict or scheme != self.scheme):\n            path = self.__remove_dot_segments(path)\n        elif authority is not None:\n            scheme = self.scheme\n            path = self.__remove_dot_segments(path)\n        elif not path:\n            scheme = self.scheme\n            authority = self.authority\n            path = self.path\n            query = self.query if query is None else query\n        elif path.startswith(self.SLASH):\n            scheme = self.scheme\n            authority = self.authority\n            path = self.__remove_dot_segments(path)\n        else:\n            scheme = self.scheme\n            authority = self.authority\n            path = self.__remove_dot_segments(self.__merge(path))\n        return type(self)(scheme, authority, path, query, fragment)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculate_rate(country_code, exception_name):\n\n    if not country_code or not isinstance(country_code, str_cls) or len(country_code) != 2:\n        raise ValueError('Invalidly formatted country code')\n\n    if exception_name and not isinstance(exception_name, str_cls):\n        raise ValueError('Exception name is not None or a string')\n\n    country_code = country_code.upper()\n\n    if country_code not in rates.BY_COUNTRY:\n        return (Decimal('0.0'), country_code, None)\n\n    country_info = rates.BY_COUNTRY[country_code]\n\n    if not exception_name:\n        return (country_info['rate'], country_code, None)\n\n    if exception_name not in country_info['exceptions']:\n        raise ValueError('\"%s\" is not a valid exception for %s' % (exception_name, country_code))\n\n    rate_info = country_info['exceptions'][exception_name]\n    if isinstance(rate_info, Decimal):\n        rate = rate_info\n    else:\n        # This allows handling the complex case of the UK RAF bases in Cyprus\n        # that map to the standard country rate. The country code and exception\n        # name need to be changed in addition to gettting a special rate.\n        rate, country_code, exception_name = rate_info\n    return (rate, country_code, exception_name)", "response": "Calculates the VAT rate for a customer based on their declared country code and exception name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef exceptions_by_country(country_code):\n\n    if not country_code or not isinstance(country_code, str_cls) or len(country_code) != 2:\n        raise ValueError('Invalidly formatted country code')\n\n    country_code = country_code.upper()\n\n    return EXCEPTIONS_BY_COUNTRY.get(country_code, [])", "response": "Returns a list of exception names for the given country code"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef normalize(vat_id):\n\n    if not vat_id:\n        return None\n\n    if not isinstance(vat_id, str_cls):\n        raise ValueError('VAT ID is not a string')\n\n    if len(vat_id) < 3:\n        raise ValueError('VAT ID must be at least three character long')\n\n    # Normalize the ID for simpler regexes\n    vat_id = re.sub('\\\\s+', '', vat_id)\n    vat_id = vat_id.replace('-', '')\n    vat_id = vat_id.replace('.', '')\n    vat_id = vat_id.upper()\n\n    country_prefix = vat_id[0:2]\n\n    # Fix people using GR prefix for Greece\n    if country_prefix == 'GR':\n        vat_id = 'EL' + vat_id[2:]\n        country_prefix = 'EL'\n\n    if country_prefix not in ID_PATTERNS:\n        return None\n\n    return vat_id", "response": "Normalizes a VAT ID and returns a normalized string containing the VAT ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate a VAT ID against the VIES system.", "response": "def validate(vat_id):\n    \"\"\"\n    Runs some basic checks to ensure a VAT ID looks properly formatted. If so,\n    checks it against the VIES system for EU VAT IDs or data.brreg.no for\n    Norwegian VAT ID.\n\n    :param vat_id:\n        The VAT ID to check. Allows \"GR\" prefix for Greece, even though it\n        should be \"EL\".\n\n    :raises:\n        ValueError - If the is not a string or is not in the format of two characters plus an identifier\n        InvalidError - If the VAT ID is not valid\n        WebServiceUnavailableError - If the VIES VAT ID service is unable to process the request - this is fairly common\n        WebServiceError - If there was an error parsing the response from the server - usually this means something changed in the webservice\n        urllib.error.URLError/urllib2.URLError - If there is an issue communicating with VIES or data.brreg.no\n\n    :return:\n        None if the VAT ID is blank or not for an EU country or Norway\n        A tuple of (two-character country code, normalized VAT id, company name) if valid\n    \"\"\"\n\n    vat_id = normalize(vat_id)\n\n    if not vat_id:\n        return vat_id\n\n    country_prefix = vat_id[0:2]\n\n    number = vat_id[2:]\n\n    if not re.match(ID_PATTERNS[country_prefix]['regex'], number):\n        raise InvalidError('VAT ID does not appear to be properly formatted for %s' % country_prefix)\n\n    if country_prefix == 'NO':\n        organization_number = number.replace('MVA', '')\n        validation_url = 'http://data.brreg.no/enhetsregisteret/enhet/%s.json' % organization_number\n\n        try:\n            response = urlopen(validation_url)\n            _, params = cgi.parse_header(response.headers['Content-Type'])\n            if 'charset' in params:\n                encoding = params['charset']\n            else:\n                encoding = 'utf-8'\n\n            return_json = response.read().decode(encoding)\n\n            # Example response:\n            #\n            # {\n            #     \"organisasjonsnummer\": 974760673,\n            #     \"navn\": \"REGISTERENHETEN I BR\u00d8NN\u00d8YSUND\",\n            #     \"registreringsdatoEnhetsregisteret\": \"1995-08-09\",\n            #     \"organisasjonsform\": \"ORGL\",\n            #     \"hjemmeside\": \"www.brreg.no\",\n            #     \"registrertIFrivillighetsregisteret\": \"N\",\n            #     \"registrertIMvaregisteret\": \"N\",\n            #     \"registrertIForetaksregisteret\": \"N\",\n            #     \"registrertIStiftelsesregisteret\": \"N\",\n            #     \"antallAnsatte\": 562,\n            #     \"institusjonellSektorkode\": {\n            #         \"kode\": \"6100\",\n            #         \"beskrivelse\": \"Statsforvaltningen\"\n            #     },\n            #     \"naeringskode1\": {\n            #         \"kode\": \"84.110\",\n            #         \"beskrivelse\": \"Generell offentlig administrasjon\"\n            #     },\n            #     \"postadresse\": {\n            #         \"adresse\": \"Postboks 900\",\n            #         \"postnummer\": \"8910\",\n            #         \"poststed\": \"BR\u00d8NN\u00d8YSUND\",\n            #         \"kommunenummer\": \"1813\",\n            #         \"kommune\": \"BR\u00d8NN\u00d8Y\",\n            #         \"landkode\": \"NO\",\n            #         \"land\": \"Norge\"\n            #     },\n            #     \"forretningsadresse\": {\n            #         \"adresse\": \"Havnegata 48\",\n            #         \"postnummer\": \"8900\",\n            #         \"poststed\": \"BR\u00d8NN\u00d8YSUND\",\n            #         \"kommunenummer\": \"1813\",\n            #         \"kommune\": \"BR\u00d8NN\u00d8Y\",\n            #         \"landkode\": \"NO\",\n            #         \"land\": \"Norge\"\n            #     },\n            #     \"konkurs\": \"N\",\n            #     \"underAvvikling\": \"N\",\n            #     \"underTvangsavviklingEllerTvangsopplosning\": \"N\",\n            #     \"overordnetEnhet\": 912660680,\n            #     \"links\": [\n            #         {\n            #             \"rel\": \"self\",\n            #             \"href\": \"http://data.brreg.no/enhetsregisteret/enhet/974760673\"\n            #         },\n            #         {\n            #             \"rel\": \"overordnetEnhet\",\n            #             \"href\": \"http://data.brreg.no/enhetsregisteret/enhet/912660680\"\n            #         }\n            #     ]\n            # }\n\n            info = json.loads(return_json)\n\n            # This should never happen, but keeping it incase the API is changed\n            if 'organisasjonsnummer' not in info or info['organisasjonsnummer'] != int(organization_number):\n                raise WebServiceError('No or different value for the \"organisasjonsnummer\" key in response from data.brreg.no')\n\n            company_name = info['organisasjonsnummer']\n\n        except (HTTPError) as e:\n            # If a number is invalid, we get a 404\n            if e.code == 404:\n                raise InvalidError('VAT ID is invalid')\n\n            # If we get anything but a 404 we want the exception to be recorded\n            raise\n\n    # EU countries\n    else:\n        post_data = '''\n            <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:urn=\"urn:ec.europa.eu:taxud:vies:services:checkVat:types\">\n               <soapenv:Header/>\n               <soapenv:Body>\n                  <urn:checkVat>\n                     <urn:countryCode>%s</urn:countryCode>\n                     <urn:vatNumber>%s</urn:vatNumber>\n                  </urn:checkVat>\n               </soapenv:Body>\n            </soapenv:Envelope>\n        ''' % (country_prefix, number)\n\n        request = Request('http://ec.europa.eu/taxation_customs/vies/services/checkVatService')\n        request.add_header('Content-Type', 'application/x-www-form-urlencoded; charset=utf-8')\n\n        try:\n            response = urlopen(request, post_data.encode('utf-8'))\n        except (HTTPError) as e:\n            # If one of the country VAT ID services is down, we get a 500\n            if e.code == 500:\n                raise WebServiceUnavailableError('VAT ID validation is not currently available')\n\n            # If we get anything but a 500 we want the exception to be recorded\n            raise\n\n        _, params = cgi.parse_header(response.headers['Content-Type'])\n        if 'charset' in params:\n            encoding = params['charset']\n        else:\n            encoding = 'utf-8'\n\n        return_xml = response.read().decode(encoding)\n\n        # Example response:\n        #\n        # <soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n        #    <soap:Body>\n        #       <checkVatResponse xmlns=\"urn:ec.europa.eu:taxud:vies:services:checkVat:types\">\n        #          <countryCode>GB</countryCode>\n        #          <vatNumber>GD001</vatNumber>\n        #          <requestDate>2014-12-17+01:00</requestDate>\n        #          <valid>true</valid>\n        #          <name>MINISTRY OF AGRICULTURE FISHERIES &amp; FOOD</name>\n        #          <address>ROOM C206\n        # GOVERNMENT BUILDINGS\n        # EPSOM ROAD\n        # GUILDFORD\n        # SURREY\n        # GU1 2LD</address>\n        #       </checkVatResponse>\n        #    </soap:Body>\n        # </soap:Envelope>\n\n        try:\n            # If we don't explicitly recode to UTF-8, ElementTree stupidly uses\n            # ascii on Python 2.7\n            envelope = ElementTree.fromstring(return_xml.encode('utf-8'))\n        except (ElementTree.ParseError):\n            raise WebServiceError('Unable to parse response from VIES')\n\n        namespaces = {\n            'soap': 'http://schemas.xmlsoap.org/soap/envelope/',\n            'vat':  'urn:ec.europa.eu:taxud:vies:services:checkVat:types'\n        }\n        valid_elements = envelope.findall('./soap:Body/vat:checkVatResponse/vat:valid', namespaces)\n        if not valid_elements:\n            # Fail loudly if the XML seems to have changed\n            raise WebServiceError('Unable to find <valid> tag in response from VIES')\n\n        name_elements = envelope.findall('./soap:Body/vat:checkVatResponse/vat:name', namespaces)\n        if not name_elements:\n            # Fail loudly if the XML seems to have changed\n            raise WebServiceError('Unable to find <name> tag in response from VIES')\n\n        if valid_elements[0].text.lower() != 'true':\n            raise InvalidError('VAT ID is invalid')\n\n        company_name = name_elements[0].text\n\n    return (ID_PATTERNS[country_prefix]['country_code'], vat_id, company_name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef wait(msg='', exceptions=None, timeout=10):\n    exc = [StaleElementReferenceException]\n    if exceptions is not None:\n        try:\n            exc.extend(iter(exceptions))\n        except TypeError:  # exceptions is not iterable\n            exc.append(exceptions)\n    exc = tuple(exc)\n\n    if not msg:\n        msg = \"Could not recover from Exception(s): {}\".format(', '.join([e.__name__ for e in exc]))\n\n    def wrapper(func):\n        def wait_handler(*args, **kwargs):\n            import time\n\n            poll_freq = 0.5\n            end_time = time.time() + timeout\n            while time.time() <= end_time:\n                try:\n                    value = func(*args, **kwargs)\n                    if value:\n                        return value\n                except exc as e:\n                    LOGGER.debug(e)\n                    pass  # continue\n\n                time.sleep(poll_freq)\n                poll_freq *= 1.25\n            raise RuntimeError(msg)\n        return wait_handler\n    return wrapper", "response": "Decorator to handle generic waiting situations."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculate_rate(country_code, postal_code, city):\n\n    if not country_code or not isinstance(country_code, str_cls):\n        raise ValueError('Invalidly formatted country code')\n\n    country_code = country_code.strip()\n    if len(country_code) != 2:\n        raise ValueError('Invalidly formatted country code')\n\n    country_code = country_code.upper()\n\n    if country_code not in COUNTRIES_WITHOUT_POSTAL_CODES:\n        if not postal_code or not isinstance(postal_code, str_cls):\n            raise ValueError('Postal code is not a string')\n\n    if not city or not isinstance(city, str_cls):\n        raise ValueError('City is not a string')\n\n    if isinstance(postal_code, str_cls):\n        postal_code = re.sub('\\\\s+', '', postal_code)\n        postal_code = postal_code.upper()\n\n        # Remove the common european practice of adding the country code\n        # to the beginning of a postal code, followed by a dash\n        if len(postal_code) > 3 and postal_code[0:3] == country_code + '-':\n            postal_code = postal_code[3:]\n\n        postal_code = postal_code.replace('-', '')\n\n    city = city.lower().strip()\n\n    if country_code not in rates.BY_COUNTRY and country_code not in POSTAL_CODE_EXCEPTIONS:\n        return (Decimal('0.0'), country_code, None)\n\n    country_default = rates.BY_COUNTRY.get(country_code, {'rate': Decimal('0.0')})['rate']\n\n    if country_code not in POSTAL_CODE_EXCEPTIONS:\n        return (country_default, country_code, None)\n\n    exceptions = POSTAL_CODE_EXCEPTIONS[country_code]\n    for matcher in exceptions:\n        # Postal code-only match\n        if isinstance(matcher, str_cls):\n            postal_regex = matcher\n            city_regex = None\n        else:\n            postal_regex, city_regex = matcher\n\n        if not re.match(postal_regex, postal_code):\n            continue\n\n        if city_regex and not re.search(city_regex, city):\n            continue\n\n        mapped_country = exceptions[matcher]['country_code']\n\n        # There is at least one entry where we map to a different country,\n        # but are not mapping to an exception\n        if 'name' not in exceptions[matcher]:\n            country_code = mapped_country\n            country_default = rates.BY_COUNTRY[country_code]['rate']\n            break\n\n        mapped_name = exceptions[matcher]['name']\n\n        rate = rates.BY_COUNTRY[mapped_country]['exceptions'][mapped_name]\n        return (rate, mapped_country, mapped_name)\n\n    return (country_default, country_code, None)", "response": "Calculates the VAT rate for a given country code and postal code and city."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef async_get_device(self, uid, fields='*'):\n        return (yield from self._get('/pods/{}'.format(uid),\n                                     fields=fields))", "response": "Get specific device by ID."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef async_get_measurements(self, uid, fields='*'):\n        return (yield from self._get('/pods/{}/measurements'.format(uid),\n                                     fields=fields))[0]", "response": "Get measurements of a device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting log entries of a device.", "response": "def async_get_ac_states(self, uid, limit=1, offset=0, fields='*'):\n        \"\"\"Get log entries of a device.\"\"\"\n        return (yield from self._get('/pods/{}/acStates'.format(uid),\n                                     limit=limit,\n                                     fields=fields,\n                                     offset=offset))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a specific log entry.", "response": "def async_get_ac_state_log(self, uid, log_id, fields='*'):\n        \"\"\"Get a specific log entry.\"\"\"\n        return (\n            yield from self._get('/pods/{}/acStates/{}'.format(uid, log_id),\n                                 fields=fields))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef async_set_ac_state_property(\n            self, uid, name, value, ac_state=None, assumed_state=False):\n        \"\"\"Set a specific device property.\"\"\"\n        if ac_state is None:\n            ac_state = yield from self.async_get_ac_states(uid)\n            ac_state = ac_state[0]['acState']\n        data = {\n            'currentAcState': ac_state,\n            'newValue': value\n        }\n        if assumed_state:\n            data['reason'] = \"StateCorrectionByUser\"\n        resp = yield from self._session.patch(\n            _SERVER + '/pods/{}/acStates/{}'.format(uid, name),\n            data=json.dumps(data),\n            params=self._params,\n            timeout=self._timeout)\n        try:\n            return (yield from resp.json())['result']\n        except aiohttp.client_exceptions.ContentTypeError:\n            pass\n        raise SensiboError((yield from resp.text()))", "response": "Set a specific device property."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nattempt to bind a socket a number of times with a short interval in between", "response": "def _bind_with_timeout(bind_function, args, n_tries=3, retry_interval_s=0.5):\n    \"\"\"Attempt to bind a socket a number of times with a short interval in between\n    \n    Especially on Linux, crashing out of a networkzero process can leave the sockets\n    lingering and unable to re-bind on startup. We give it a few goes here to see if\n    we can bind within a couple of seconds.\n    \"\"\"\n    n_tries_left = n_tries\n    while n_tries_left > 0:\n        try:\n            return bind_function(*args)\n        except zmq.error.ZMQError as exc:\n            _logger.warn(\"%s; %d tries remaining\", exc, n_tries_left)\n            n_tries_left -= 1\n        except OSError as exc:\n            if exc.errno == errno.EADDRINUSE:\n                _logger.warn(\"%s; %d tries remaining\", exc, n_tries_left)\n                n_tries_left -= 1\n            else:\n                raise\n    else:\n        raise core.SocketAlreadyExistsError(\"Failed to bind after %s tries\" % n_tries)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _start_beacon(port=None):\n    global _beacon\n    if _beacon is None:\n        _logger.debug(\"About to start beacon with port %s\", port)\n        try:\n            _beacon = _Beacon(port)\n        except (OSError, socket.error) as exc:\n            if exc.errno == errno.EADDRINUSE:\n                _logger.warn(\"Beacon already active on this machine\")\n                #\n                # _remote_beacon is simply a not-None sentinel value\n                # to distinguish between the case where we have not\n                # yet started a beacon and where we have found one\n                # in another process.\n                #\n                _beacon = _remote_beacon\n            else:\n                raise\n        else:\n            _beacon.start()", "response": "Start a beacon thread within this process."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadvertises a name at a specific address.", "response": "def advertise(name, address=None, fail_if_exists=False, ttl_s=config.ADVERT_TTL_S):\n    \"\"\"Advertise a name at an address\n    \n    Start to advertise service `name` at address `address`. If\n    the address is not supplied, one is constructed and this is\n    returned by the function. ie this is a typical use::\n    \n        address = nw0.advertise(\"myservice\")\n        \n    :param name: any text\n    :param address: either \"ip:port\" or None\n    :param fail_if_exists: fail if this name is already registered?\n    :param ttl_s: the advert will persist for this many seconds other beacons\n    :returns: the address given or constructed\n    \"\"\"\n    _start_beacon()\n    address = _rpc(\"advertise\", name, address, fail_if_exists, ttl_s)\n    _services_advertised[name] = address\n    return address"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef discover(name, wait_for_s=60):\n    _start_beacon()\n    #\n    # It's possible to enter a deadlock situation where the first\n    # process fires off a discovery request and waits for the\n    # second process to advertise. But the second process has to\n    # connect to the rpc port of the first process' beacon and\n    # its advertisement is queued behind the pending discovery.\n    #\n    # To give both a chance of succeeding we operate in bursts,\n    # allowing them to interleave.\n    #\n    t0 = time.time()\n    while True:\n        discovery = _rpc(\"discover\", name, 0.5)\n        if discovery:\n            return discovery\n        if timed_out(t0, wait_for_s):\n            return None", "response": "Discover a named service by name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of all services and their addresses in a group.", "response": "def discover_group(group, separator=\"/\", exclude=None):\n    \"\"\"Produce a list of all services and their addresses in a group\n    \n    A group is an optional form of namespace within the discovery mechanism.\n    If an advertised name has the form <group><sep><name> it is deemed to\n    belong to <group>. Note that the service's name is still the full\n    string <group><sep><name>. The group concept is simply for discovery and\n    to assist differentiation, eg, in a classroom group.\n    \n    :param group: the name of a group prefix\n    :param separator: the separator character [/]\n    :param exclude: an iterable of names to exclude (or None)\n    \n    :returns: a list of 2-tuples [(name, address), ...]\n    \"\"\"\n    _start_beacon()\n    if exclude is None:\n        names_to_exclude = set()\n    else:\n        names_to_exclude = set(exclude)\n    all_discovered = _rpc(\"discover_all\")\n    return [(name, address) \n        for (name, address) in all_discovered \n        if name.startswith(\"%s%s\" % (group, separator))\n        and name not in names_to_exclude\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npolls the command request.", "response": "def poll_command_request(self):\n        \"\"\"If the command RPC socket has an incoming request,\n        separate it into its action and its params and put it\n        on the command request queue.\n        \"\"\"\n        try:\n            message = self.rpc.recv(zmq.NOBLOCK)\n        except zmq.ZMQError as exc:\n            if exc.errno == zmq.EAGAIN:\n                return\n            else:\n                raise\n\n        _logger.debug(\"Received command %s\", message)\n        segments = _unpack(message)\n        action, params = segments[0], segments[1:]\n        _logger.debug(\"Adding %s, %s to the request queue\", action, params)\n        self._command = _Command(action, params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a message to a nw0 address and return the reply", "response": "def send_message_to(address, message=EMPTY, wait_for_reply_s=config.FOREVER):\n    \"\"\"Send a message and return the reply\n    \n    :param address: a nw0 address (eg from `nw0.discover`)\n    :param message: any simple Python object, including text & tuples\n    :param wait_for_reply_s: how many seconds to wait for a reply [default: forever]\n    \n    :returns: the reply returned from the address or None if out of time\n    \"\"\"\n    _logger.info(\"Sending message %s to %s\", message, address)\n    if isinstance(address, list):\n        raise core.InvalidAddressError(\"Multiple addresses are not allowed\")\n    return sockets._sockets.send_message_to(address, message, wait_for_reply_s)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwaiting for a message from another nw0 address.", "response": "def wait_for_message_from(address, wait_for_s=config.FOREVER, autoreply=False):\n    \"\"\"Wait for a message\n    \n    :param address: a nw0 address (eg from `nw0.advertise`)\n    :param wait_for_s: how many seconds to wait for a message before giving up [default: forever]\n    :param autoreply: whether to send an empty reply [default: No]\n    \n    :returns: the message received from another address or None if out of time\n    \"\"\"\n    _logger.info(\"Waiting for message on %s for %s secs\", address, wait_for_s)\n    message = sockets._sockets.wait_for_message_from(address, wait_for_s)\n    if message is not None and autoreply:\n        sockets._sockets.send_reply_to(address, EMPTY)\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplies to a message previously received by the given address.", "response": "def send_reply_to(address, reply=EMPTY):\n    \"\"\"Reply to a message previously received\n    \n    :param address: a nw0 address (eg from `nw0.advertise`)\n    :param reply: any simple Python object, including text & tuples\n    \"\"\"\n    _logger.debug(\"Sending reply %s to %s\", reply, address)\n    return sockets._sockets.send_reply_to(address, reply)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_news_to(address, topic, data=None):\n    _logger.info(\"Publish topic %s with data %s to %s\", topic, data, address)\n    return sockets._sockets.send_news_to(address, topic, data)", "response": "Publish news to all subscribers\n    \n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwait for news whose topic starts with prefix.", "response": "def wait_for_news_from(address, prefix=config.EVERYTHING, wait_for_s=config.FOREVER, is_raw=False):\n    \"\"\"Wait for news whose topic starts with `prefix`.\n    \n    :param address: a nw0 address, eg from `nw0.discover`\n    :param prefix: any text object [default: all messages]\n    :param wait_for_s: how many seconds to wait before giving up [default: forever]\n    \n    :returns: a 2-tuple of (topic, data) or (None, None) if out of time\n    \"\"\"\n    _logger.info(\"Listen on %s for news matching %s waiting for %s secs\", address, prefix, wait_for_s)\n    return sockets._sockets.wait_for_news_from(address, prefix, wait_for_s, is_raw)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the VAT rate for a given country code subdivision and city.", "response": "def calculate_rate(country_code, subdivision, city, address_country_code=None, address_exception=None):\n    \"\"\"\n    Calculates the VAT rate from the data returned by a GeoLite2 database\n\n    :param country_code:\n        Two-character country code\n\n    :param subdivision:\n        The first subdivision name\n\n    :param city:\n        The city name\n\n    :param address_country_code:\n        The user's country_code, as detected from billing_address or\n        declared_residence. This prevents an UndefinitiveError from being\n        raised.\n\n    :param address_exception:\n        The user's exception name, as detected from billing_address or\n        declared_residence. This prevents an UndefinitiveError from being\n        raised.\n\n    :raises:\n        ValueError - if country code is not two characers, or subdivision or city are not strings\n        UndefinitiveError - when no address_country_code and address_exception are provided and the geoip2 information is not specific enough\n\n    :return:\n        A tuple of (Decimal percentage rate, country code, exception name [or None])\n    \"\"\"\n\n    if not country_code or not isinstance(country_code, str_cls) or len(country_code) != 2:\n        raise ValueError('Invalidly formatted country code')\n\n    if not isinstance(subdivision, str_cls):\n        raise ValueError('Subdivision is not a string')\n\n    if not isinstance(city, str_cls):\n        raise ValueError('City is not a string')\n\n    country_code = country_code.upper()\n    subdivision = subdivision.lower()\n    city = city.lower()\n\n    if country_code not in rates.BY_COUNTRY:\n        return (Decimal('0.0'), country_code, None)\n\n    country_default = rates.BY_COUNTRY[country_code]['rate']\n\n    if country_code not in GEOIP2_EXCEPTIONS:\n        return (country_default, country_code, None)\n\n    exceptions = GEOIP2_EXCEPTIONS[country_code]\n    for matcher in exceptions:\n        # Subdivision-only match\n        if isinstance(matcher, str_cls):\n            sub_match = matcher\n            city_match = None\n        else:\n            sub_match, city_match = matcher\n\n        if sub_match != subdivision:\n            continue\n\n        if city_match and city_match != city:\n            continue\n\n        info = exceptions[matcher]\n        exception_name = info['name']\n        if not info['definitive']:\n            if address_country_code is None:\n                raise UndefinitiveError('It is not possible to determine the users VAT rates based on the information provided')\n\n            if address_country_code != country_code:\n                continue\n\n            if address_exception != exception_name:\n                continue\n\n        rate = rates.BY_COUNTRY[country_code]['exceptions'][exception_name]\n        return (rate, country_code, exception_name)\n\n    return (country_default, country_code, None)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the mcu definition from the project file and return the mcu definition dict.", "response": "def get_mcu_definition(self, project_file):\n        \"\"\" Parse project file to get mcu definition \"\"\"\n        project_file = join(getcwd(), project_file)\n        uvproj_dic = xmltodict.parse(file(project_file), dict_constructor=dict)\n        # Generic Target, should get from Target class !\n        mcu = MCU_TEMPLATE\n\n        try:\n            mcu['tool_specific'] = {\n                # legacy device\n                'uvision' : {\n                    'TargetOption' : {\n                        'Device' : [uvproj_dic['Project']['Targets']['Target']['TargetOption']['TargetCommonOption']['Device']],\n                        'DeviceId' : [None if not uvproj_dic['Project']['Targets']['Target']['TargetOption']['TargetCommonOption']['DeviceId'] else \n                            int(uvproj_dic['Project']['Targets']['Target']['TargetOption']['TargetCommonOption']['DeviceId'])],\n                        'Vendor' : [uvproj_dic['Project']['Targets']['Target']['TargetOption']['TargetCommonOption']['Vendor']],\n                        'Cpu' : [uvproj_dic['Project']['Targets']['Target']['TargetOption']['TargetCommonOption']['Cpu']],\n                        'FlashDriverDll' : [uvproj_dic['Project']['Targets']['Target']['TargetOption']['TargetCommonOption']['FlashDriverDll']],\n                        'SFDFile' : [uvproj_dic['Project']['Targets']['Target']['TargetOption']['TargetCommonOption']['SFDFile']],\n                        'RegisterFile': [uvproj_dic['Project']['Targets']['Target']['TargetOption']['TargetCommonOption']['RegisterFile']],\n                    }\n                }\n            }\n        except KeyError:\n            # validity check for uvision project\n            logging.debug(\"The project_file %s seems to be not valid .uvproj file.\")\n            return mcu\n\n        return mcu"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the project file to get the mcu definition", "response": "def get_mcu_definition(self, project_file):\n        \"\"\" Parse project file to get mcu definition \"\"\"\n        # TODO: check the extension here if it's valid IAR project or we\n        # should at least check if syntax is correct check something IAR defines and return error if not\n        project_file = join(getcwd(), project_file)\n        ewp_dic = xmltodict.parse(file(project_file), dict_constructor=dict)\n\n        mcu = MCU_TEMPLATE\n\n        try:\n            ewp_dic['project']['configuration']\n        except KeyError:\n            # validity check for iar project\n            logging.debug(\"The project_file %s seems to be not valid .ewp file.\")\n            return mcu\n\n        # Fill in only must-have values, fpu will be added if defined for mcu\n        mcu['tool_specific'] = {\n            'iar' : {\n                # MCU selection\n                'OGChipSelectEditMenu' : {\n                    'state' : [],\n                },\n                # we use mcu\n                'OGCoreOrChip' : {\n                    'state' : [1],\n                },\n            }\n        }\n\n\n        # we take 0 configuration or just configuration, as multiple configuration possible\n        # debug, release, for mcu - does not matter, try and adjust\n        try:\n            index_general = self._get_option(ewp_dic['project']['configuration'][0]['settings'], 'General')\n            configuration = ewp_dic['project']['configuration'][0]\n        except KeyError:\n            index_general = self._get_option(ewp_dic['project']['configuration']['settings'], 'General')\n            configuration = ewp_dic['project']['configuration']\n        index_option = self._get_option(configuration['settings'][index_general]['data']['option'], 'OGChipSelectEditMenu')\n        OGChipSelectEditMenu = configuration['settings'][index_general]['data']['option'][index_option]\n        mcu['tool_specific']['iar']['OGChipSelectEditMenu']['state'].append(OGChipSelectEditMenu['state'].replace('\\t', ' ', 1))\n        # we keep this as the internal version. FPU - version 1, FPU2 version 2. \n        # TODO:We shall look at IAR versioning to get this right\n        fileVersion = 1\n        try:\n            if self._get_option(configuration['settings'][index_general]['data']['option'], 'FPU2'):\n                fileVersion = 2\n        except TypeError:\n            pass\n\n        index_option = self._get_option(configuration['settings'][index_general]['data']['option'], 'GBECoreSlave')\n        GBECoreSlave = configuration['settings'][index_general]['data']['option'][index_option]\n        mcu['tool_specific']['iar']['GBECoreSlave'] = { 'state': [int(GBECoreSlave['state'])] }\n\n        if fileVersion == 2:\n            index_option = self._get_option(configuration['settings'][index_general]['data']['option'], 'GFPUCoreSlave2')\n            GFPUCoreSlave2 = configuration['settings'][index_general]['data']['option'][index_option]\n            mcu['tool_specific']['iar']['GFPUCoreSlave2'] = { 'state': [int(GFPUCoreSlave2['state'])] }\n            index_option = self._get_option(configuration['settings'][index_general]['data']['option'], 'CoreVariant')\n            CoreVariant = configuration['settings'][index_general]['data']['option'][index_option]\n            mcu['tool_specific']['iar']['CoreVariant'] = { 'state': [int(CoreVariant['state'])] }\n        else:\n            index_option = self._get_option(configuration['settings'][index_general]['data']['option'], 'GFPUCoreSlave')\n            GFPUCoreSlave = configuration['settings'][index_general]['data']['option'][index_option]\n            mcu['tool_specific']['iar']['GFPUCoreSlave'] = { 'state': [int(GFPUCoreSlave['state'])] }\n            index_option = self._get_option(configuration['settings'][index_general]['data']['option'], 'Variant')\n            Variant = configuration['settings'][index_general]['data']['option'][index_option]\n            mcu['tool_specific']['iar']['Variant'] = { 'state': [int(Variant['state'])] }\n        return mcu"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_mcu_definition(self, project_file):\n        project_file = join(getcwd(), project_file)\n        coproj_dic = xmltodict.parse(file(project_file), dict_constructor=dict)\n\n        mcu = MCU_TEMPLATE\n\n        IROM1_index = self._coproj_find_option(coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'], '@name', 'IROM1')\n        IROM2_index = self._coproj_find_option(coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'], '@name', 'IROM2')\n        IRAM1_index = self._coproj_find_option(coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'], '@name', 'IRAM1')\n        IRAM2_index = self._coproj_find_option(coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'], '@name', 'IRAM2')\n        defaultAlgorithm_index = self._coproj_find_option(coproj_dic['Project']['Target']['DebugOption']['Option'], '@name', 'org.coocox.codebugger.gdbjtag.core.defaultAlgorithm')\n\n        mcu['tool_specific'] = {\n            'coide' : {\n                'Device' : {\n                    'manufacturerId' : [coproj_dic['Project']['Target']['Device']['@manufacturerId']],\n                    'manufacturerName': [coproj_dic['Project']['Target']['Device']['@manufacturerName']],\n                    'chipId': [coproj_dic['Project']['Target']['Device']['@chipId']],\n                    'chipName': [coproj_dic['Project']['Target']['Device']['@chipName']],\n                },\n                'DebugOption': {\n                    'defaultAlgorithm': [coproj_dic['Project']['Target']['DebugOption']['Option'][defaultAlgorithm_index]['@value']],\n                },\n                'MemoryAreas': {\n                    'IROM1': {\n                        'name': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IROM1_index]['@name']],\n                        'size': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IROM1_index]['@size']],\n                        'startValue': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IROM1_index]['@startValue']],\n                        'type': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IROM1_index]['@type']],\n                    },\n                    'IRAM1': {\n                        'name': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IRAM1_index]['@name']],\n                        'size': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IRAM1_index]['@size']],\n                        'startValue': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IRAM1_index]['@startValue']],\n                        'type': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IRAM1_index]['@type']],\n                    },\n                    'IROM2': {\n                        'name': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IROM2_index]['@name']],\n                        'size': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IROM2_index]['@size']],\n                        'startValue': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IROM2_index]['@startValue']],\n                        'type': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IROM2_index]['@type']],\n                    },\n                    'IRAM2': {\n                        'name': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IRAM2_index]['@name']],\n                        'size': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IRAM2_index]['@size']],\n                        'startValue': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IRAM2_index]['@startValue']],\n                        'type': [coproj_dic['Project']['Target']['BuildOption']['Link']['MemoryAreas']['Memory'][IRAM2_index]['@type']],\n                    }\n                }\n            }\n        }\n        return mcu", "response": "Parse project file to get mcu definition"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch():\n\n    response = urlopen('https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml')\n    _, params = cgi.parse_header(response.headers['Content-Type'])\n    if 'charset' in params:\n        encoding = params['charset']\n    else:\n        encoding = 'utf-8'\n\n    return_xml = response.read().decode(encoding)\n\n    # Example return data\n    #\n    # <gesmes:Envelope xmlns:gesmes=\"http://www.gesmes.org/xml/2002-08-01\" xmlns=\"http://www.ecb.int/vocabulary/2002-08-01/eurofxref\">\n    #     <gesmes:subject>Reference rates</gesmes:subject>\n    #     <gesmes:Sender>\n    #         <gesmes:name>European Central Bank</gesmes:name>\n    #     </gesmes:Sender>\n    #     <Cube>\n    #         <Cube time=\"2015-01-09\">\n    #             <Cube currency=\"USD\" rate=\"1.1813\"/>\n    #             <Cube currency=\"JPY\" rate=\"140.81\"/>\n    #             <Cube currency=\"BGN\" rate=\"1.9558\"/>\n    #             <Cube currency=\"CZK\" rate=\"28.062\"/>\n    #             <Cube currency=\"DKK\" rate=\"7.4393\"/>\n    #             <Cube currency=\"GBP\" rate=\"0.77990\"/>\n    #             <Cube currency=\"HUF\" rate=\"317.39\"/>\n    #             <Cube currency=\"PLN\" rate=\"4.2699\"/>\n    #             <Cube currency=\"RON\" rate=\"4.4892\"/>\n    #             <Cube currency=\"SEK\" rate=\"9.4883\"/>\n    #             <Cube currency=\"CHF\" rate=\"1.2010\"/>\n    #             <Cube currency=\"NOK\" rate=\"9.0605\"/>\n    #             <Cube currency=\"HRK\" rate=\"7.6780\"/>\n    #             <Cube currency=\"RUB\" rate=\"72.8910\"/>\n    #             <Cube currency=\"TRY\" rate=\"2.7154\"/>\n    #             <Cube currency=\"AUD\" rate=\"1.4506\"/>\n    #             <Cube currency=\"BRL\" rate=\"3.1389\"/>\n    #             <Cube currency=\"CAD\" rate=\"1.3963\"/>\n    #             <Cube currency=\"CNY\" rate=\"7.3321\"/>\n    #             <Cube currency=\"HKD\" rate=\"9.1593\"/>\n    #             <Cube currency=\"IDR\" rate=\"14925.34\"/>\n    #             <Cube currency=\"ILS\" rate=\"4.6614\"/>\n    #             <Cube currency=\"INR\" rate=\"73.6233\"/>\n    #             <Cube currency=\"KRW\" rate=\"1290.29\"/>\n    #             <Cube currency=\"MXN\" rate=\"17.3190\"/>\n    #             <Cube currency=\"MYR\" rate=\"4.2054\"/>\n    #             <Cube currency=\"NZD\" rate=\"1.5115\"/>\n    #             <Cube currency=\"PHP\" rate=\"53.090\"/>\n    #             <Cube currency=\"SGD\" rate=\"1.5789\"/>\n    #             <Cube currency=\"THB\" rate=\"38.846\"/>\n    #             <Cube currency=\"ZAR\" rate=\"13.6655\"/>\n    #         </Cube>\n    #     </Cube>\n    # </gesmes:Envelope>\n\n    # If we don't explicitly recode to UTF-8, ElementTree stupidly uses\n    # ascii on Python 2.7\n    envelope = ElementTree.fromstring(return_xml.encode('utf-8'))\n\n    namespaces = {\n        'gesmes': 'http://www.gesmes.org/xml/2002-08-01',\n        'eurofxref': 'http://www.ecb.int/vocabulary/2002-08-01/eurofxref'\n    }\n\n    date_elements = envelope.findall('./eurofxref:Cube/eurofxref:Cube[@time]', namespaces)\n    if not date_elements:\n        # Fail loudly if the XML seems to have changed\n        raise WebServiceError('Unable to find <Cube time=\"\"> tag in ECB XML')\n\n    date = date_elements[0].get('time')\n    if not isinstance(date, str_cls):\n        date = date.decode('utf-8')\n\n    currency_elements = envelope.findall('./eurofxref:Cube/eurofxref:Cube/eurofxref:Cube[@currency][@rate]', namespaces)\n    if not currency_elements:\n        # Fail loudly if the XML seems to have changed\n        raise WebServiceError('Unable to find <Cube currency=\"\" rate=\"\"> tags in ECB XML')\n\n    rates = {\n        'EUR': Decimal('1.0000')\n    }\n\n    applicable_currenties = {\n        'BGN': True,\n        'CZK': True,\n        'DKK': True,\n        'EUR': True,\n        'GBP': True,\n        'HRK': True,\n        'HUF': True,\n        'NOK': True,\n        'PLN': True,\n        'RON': True,\n        'SEK': True,\n        'USD': True\n    }\n\n    for currency_element in currency_elements:\n        code = currency_element.attrib.get('currency')\n\n        if code not in applicable_currenties:\n            continue\n\n        rate = currency_element.attrib.get('rate')\n        rates[code] = Decimal(rate)\n\n    return (date, rates)", "response": "Fetch the latest exchange rate info from the European Central Bank."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format(amount, currency=None):\n\n    if currency is None and hasattr(amount, 'currency'):\n        currency = amount.currency\n\n    # Allow Money objects\n    if not isinstance(amount, Decimal) and hasattr(amount, 'amount'):\n        amount = amount.amount\n\n    if not isinstance(currency, str_cls):\n        raise ValueError('The currency specified is not a string')\n\n    if currency not in FORMATTING_RULES:\n        valid_currencies = sorted(FORMATTING_RULES.keys())\n        formatted_currencies = ', '.join(valid_currencies)\n        raise ValueError('The currency specified, \"%s\", is not a supported currency: %s' % (currency, formatted_currencies))\n\n    if not isinstance(amount, Decimal):\n        raise ValueError('The amount specified is not a Decimal')\n\n    rules = FORMATTING_RULES[currency]\n\n    format_string = ',.%sf' % rules['decimal_places']\n\n    result = builtin_format(amount, format_string)\n\n    result = result.replace(',', '_')\n    result = result.replace('.', '|')\n\n    result = result.replace('_', rules['thousands_separator'])\n    result = result.replace('|', rules['decimal_mark'])\n\n    if rules['symbol_first']:\n        result = rules['symbol'] + result\n    else:\n        result = result + rules['symbol']\n\n    return result", "response": "Formats a decimal or Money object into an unambiguous string representation of the amount in the currency."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_momentum_by_name(self, name):\n        if name is None:\n            raise TypeError('\\'name\\' should not be None')\n        for momentum in self.momenta:\n            if momentum.name == name:\n                return momentum\n        raise KeyError('No such momentum named {0}'.format(name))", "response": "Gets a momentum by the given name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving and returns a momentum by the given name.", "response": "def pop_momentum_by_name(self, name):\n        \"\"\"Removes and returns a momentum by the given name.\n\n        :param name: the momentum name.\n\n        :returns: a momentum removed.\n\n        :raises TypeError: `name` is ``None``.\n        :raises KeyError: failed to find a momentum named `name`.\n        \"\"\"\n        momentum = self.get_momentum_by_name(name)\n        self.remove_momentum(momentum)\n        return momentum"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates a momentum by the given name.", "response": "def update_momentum_by_name(self, name, **kwargs):\n        \"\"\"Updates a momentum by the given name.\n\n        :param name: the momentum name.\n        :param velocity: (keyword-only) a new value for `velocity`.\n        :param since: (keyword-only) a new value for `since`.\n        :param until: (keyword-only) a new value for `until`.\n\n        :returns: a momentum updated.\n\n        :raises TypeError: `name` is ``None``.\n        :raises KeyError: failed to find a momentum named `name`.\n        \"\"\"\n        momentum = self.pop_momentum_by_name(name)\n        velocity, since, until = momentum[:3]\n        velocity = kwargs.get('velocity', velocity)\n        since = kwargs.get('since', since)\n        until = kwargs.get('until', until)\n        return self.add_momentum(velocity, since, until, name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef snap_momentum_by_name(self, name, velocity, at=None):\n        at = now_or(at)\n        self.forget_past(at=at)\n        return self.update_momentum_by_name(name, velocity=velocity, since=at)", "response": "Changes the velocity of a momentum named name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompose a URI reference string from its individual components.", "response": "def uricompose(scheme=None, authority=None, path='', query=None,\n               fragment=None, userinfo=None, host=None, port=None,\n               querysep='&', encoding='utf-8'):\n    \"\"\"Compose a URI reference string from its individual components.\"\"\"\n\n    # RFC 3986 3.1: Scheme names consist of a sequence of characters\n    # beginning with a letter and followed by any combination of\n    # letters, digits, plus (\"+\"), period (\".\"), or hyphen (\"-\").\n    # Although schemes are case-insensitive, the canonical form is\n    # lowercase and documents that specify schemes must do so with\n    # lowercase letters.  An implementation should accept uppercase\n    # letters as equivalent to lowercase in scheme names (e.g., allow\n    # \"HTTP\" as well as \"http\") for the sake of robustness but should\n    # only produce lowercase scheme names for consistency.\n    if isinstance(scheme, bytes):\n        scheme = _scheme(scheme)\n    elif scheme is not None:\n        scheme = _scheme(scheme.encode())\n\n    # authority must be string type or three-item iterable\n    if authority is None:\n        authority = (None, None, None)\n    elif isinstance(authority, bytes):\n        authority = _AUTHORITY_RE_BYTES.match(authority).groups()\n    elif isinstance(authority, _unicode):\n        authority = _AUTHORITY_RE_UNICODE.match(authority).groups()\n    elif not isinstance(authority, collections.Iterable):\n        raise TypeError('Invalid authority type')\n    elif len(authority) != 3:\n        raise ValueError('Invalid authority length')\n    authority = _authority(\n        userinfo if userinfo is not None else authority[0],\n        host if host is not None else authority[1],\n        port if port is not None else authority[2],\n        encoding\n    )\n\n    # RFC 3986 3.3: If a URI contains an authority component, then the\n    # path component must either be empty or begin with a slash (\"/\")\n    # character.  If a URI does not contain an authority component,\n    # then the path cannot begin with two slash characters (\"//\").\n    path = uriencode(path, _SAFE_PATH, encoding)\n    if authority is not None and path and not path.startswith(b'/'):\n        raise ValueError('Invalid path with authority component')\n    if authority is None and path.startswith(b'//'):\n        raise ValueError('Invalid path without authority component')\n\n    # RFC 3986 4.2: A path segment that contains a colon character\n    # (e.g., \"this:that\") cannot be used as the first segment of a\n    # relative-path reference, as it would be mistaken for a scheme\n    # name.  Such a segment must be preceded by a dot-segment (e.g.,\n    # \"./this:that\") to make a relative-path reference.\n    if scheme is None and authority is None and not path.startswith(b'/'):\n        if b':' in path.partition(b'/')[0]:\n            path = b'./' + path\n\n    # RFC 3986 3.4: The characters slash (\"/\") and question mark (\"?\")\n    # may represent data within the query component.  Beware that some\n    # older, erroneous implementations may not handle such data\n    # correctly when it is used as the base URI for relative\n    # references (Section 5.1), apparently because they fail to\n    # distinguish query data from path data when looking for\n    # hierarchical separators.  However, as query components are often\n    # used to carry identifying information in the form of \"key=value\"\n    # pairs and one frequently used value is a reference to another\n    # URI, it is sometimes better for usability to avoid percent-\n    # encoding those characters.\n    if isinstance(query, _strtypes):\n        query = uriencode(query, _SAFE_QUERY, encoding)\n    elif isinstance(query, collections.Mapping):\n        query = _querydict(query, querysep, encoding)\n    elif isinstance(query, collections.Iterable):\n        query = _querylist(query, querysep, encoding)\n    elif query is not None:\n        raise TypeError('Invalid query type')\n\n    # RFC 3986 3.5: The characters slash (\"/\") and question mark (\"?\")\n    # are allowed to represent data within the fragment identifier.\n    # Beware that some older, erroneous implementations may not handle\n    # this data correctly when it is used as the base URI for relative\n    # references.\n    if fragment is not None:\n        fragment = uriencode(fragment, _SAFE_FRAGMENT, encoding)\n\n    result = uriunsplit((scheme, authority, path, query, fragment))\n    # always return platform `str` type\n    return result if isinstance(result, str) else result.decode()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes the function until successful or time runs out.", "response": "def until(self, func, message='', *args, **kwargs):\n        \"\"\"\n        Continues to execute the function until successful or time runs out.\n\n        :param func: function to execute\n        :param message: message to print if time ran out\n        :param args: arguments\n        :param kwargs: key word arguments\n        :return: result of function or None\n        \"\"\"\n        value = None\n        end_time = time.time() + self._timeout\n        while True:\n            value = func(*args, **kwargs)\n            if self._debug:\n                print(\"Value from func within ActionWait: {}\".format(value))\n            if value:\n                break\n\n            time.sleep(self._poll)\n            self._poll *= 1.25\n            if time.time() > end_time:\n                raise RuntimeError(message)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_devices():\n    devices = []\n    all_hids = hid.find_all_hid_devices()\n    if all_hids:\n        for index, device in enumerate(all_hids):\n            for device_name,spec in device_specs.items():\n                if device.vendor_id == spec.hid_id[0] and device.product_id == spec.hid_id[1]:\n                    devices.append(device_name)                        \n    return devices", "response": "Return a list of the supported devices connected \n "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef open(callback=None, button_callback=None, device=None):\n    # only used if the module-level functions are used\n    global _active_device\n    \n    # if no device name specified, look for any matching device and choose the first\n    if device==None:\n        all_devices = list_devices()\n        if len(all_devices)>0:\n            device = all_devices[0]\n        else:\n            return None\n        \n    all_hids = hid.find_all_hid_devices()\n    if all_hids:\n        for index, dev in enumerate(all_hids):\n                spec = device_specs[device]\n                if dev.vendor_id == spec.hid_id[0] and dev.product_id == spec.hid_id[1]:\n                    print(\"%s found\" % device)\n                    # create a copy of the device specification\n                    new_device = copy.deepcopy(spec)\n                    new_device.device = dev\n                    # copy in product details\n                    new_device.product_name = dev.product_name\n                    new_device.vendor_name = dev.vendor_name\n                    new_device.version_number = dev.version_number\n                    # doesn't seem to work on 3dconnexion devices...\n                    new_device.serial_number = dev.serial_number                                 \n                    # set the callbacks\n                    new_device.callback = callback\n                    new_device.button_callback = button_callback\n                    # open the device and set the data handler\n                    new_device.open()                    \n                    dev.set_raw_data_handler(lambda x:new_device.process(x))   \n                    _active_device = new_device\n                    return new_device\n        print(\"No supported devices found\")\n        return None\n    else:\n        print(\"No HID devices detected\")\n        return None", "response": "Open a 3D space navigator device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef describe_connection(self):\n        if self.device==None:\n            return \"%s [disconnected]\" % (self.name)\n        else:\n            return \"%s connected to %s %s version: %s [serial: %s]\" % (self.name, \n                self.vendor_name, self.product_name,\n                self.version_number, self.serial_number)", "response": "Return string representation of the connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_led(self, state):        \n        if self.connected:            \n            reports = self.device.find_output_reports()\n            for report in reports:\n                if self.led_usage in report:\n                    report[self.led_usage] = state\n                    report.send()", "response": "Set the LED state to state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process(self, data):\n        button_changed = False        \n    \n        for name,(chan,b1,b2,flip) in self.mappings.items():\n            if data[0] == chan:\n                self.dict_state[name] = flip * to_int16(data[b1], data[b2])/float(self.axis_scale)\n                \n        for button_index, (chan, byte, bit) in enumerate(self.button_mapping):\n            if data[0] == chan:\n                button_changed = True               \n                # update the button vector\n                mask = 1<<bit\n                self.dict_state[\"buttons\"][button_index] = 1 if (data[byte] & mask) != 0 else 0                                \n                                        \n        self.dict_state[\"t\"] = high_acc_clock()\n        \n        # must receive both parts of the 6DOF state before we return the state dictionary\n        if len(self.dict_state)==8:\n            self.tuple_state = SpaceNavigator(**self.dict_state)\n        \n        # call any attached callbacks\n        if self.callback:\n            self.callback(self.tuple_state)                        \n        \n        # only call the button callback if the button state actually changed\n        if self.button_callback and button_changed:            \n            self.button_callback(self.tuple_state, self.tuple_state.buttons)", "response": "This function processes the incoming data for the HID event and updates the state of the object based on the incoming data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef human_to_seconds(string):\n    interval_exc = \"Bad interval format for {0}\".format(string)\n\n    interval_regex = re.compile(\"^(?P<value>[0-9]+)(?P<unit>[{0}])\".format(\"\".join(interval_dict.keys())))\n    seconds = 0\n\n    if string is None:\n        return None\n    while string:\n        match = interval_regex.match(string)\n        if match:\n            value, unit = int(match.group(\"value\")), match.group(\"unit\")\n            if unit in interval_dict:\n                seconds += value * interval_dict[unit]\n                string = string[match.end():]\n            else:\n                raise Exception(\"'{0}' unit not present in {1}\".format(\n                    unit, interval_dict.keys()))\n        else:\n            raise Exception(interval_exc)\n    return seconds", "response": "Convert internal string like 1M 1Y3M 3W to seconds."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a new event with the given information.", "response": "def send_event(\n    name,\n    runbook,\n    status,\n    output,\n    team,\n    page=False,\n    tip=None,\n    notification_email=None,\n    check_every='30s',\n    realert_every=-1,\n    alert_after='0s',\n    dependencies=[],\n    irc_channels=None,\n    slack_channels=None,\n    ticket=False,\n    project=None,\n    priority=None,\n    source=None,\n    tags=[],\n    ttl=None,\n    sensu_host='169.254.255.254',\n    sensu_port=3030,\n    component=None,\n    description=None,\n):\n    \"\"\"Send a new event with the given information. Requires a name, runbook,\n    status code, event output, and team but the other keys are kwargs and have\n    defaults.\n\n    :type name: str\n    :param name: Name of the check\n\n    :type runbook: str\n    :param runbook: The runbook associated with the check\n\n    :type status: int\n    :param status: Exit status code, 0,1,2,3. Must comply with the Nagios\n                   conventions. See `the Sensu docs <https://sensuapp.org/docs/latest/checks#sensu-check-specification>`_\n                   for the exact specification.\n\n    :type output: str\n    :param output: The output of the check itself. May include CRIT/WARN/OK to make\n                   it easy to evaluate how things went. Should be newline separated,\n                   but try to put the most relevant data in the first line.\n                   Example:\n                   OK: Everything is fine\n                   or\n                   CRIT: Accounts are locked. Users can't buy widgets.\n\n    :type team: str\n    :param team: Team responsible for this check. This team must already be defined\n                 server-side in the Sensu handler configuration.\n\n    :type page: bool\n    :param page: Boolean on whether this alert is page-worthy. Activates\n                 handlers that send pages.\n\n    :type tip: str\n    :param tip: A short 1-line version of the runbook. Example:\n                \"Set clip-jawed monodish to 6\"\n\n    :type notification_email: str\n    :param notification_email: A comma-separated string of email destinations. Unset will\n                               default to the \"team\" default.\n\n    :type check_every: str\n    :param check_every: Human readable time unit to let Sensu know how of then\n                        this event is fired. Defaults to \"30s\". If this parameter\n                        is not set correctly, the math for `alert_after` will be\n                        incorrect.\n\n    :type realert_every: int\n    :param realert_every: Integer value for filtering repeat occurrences. A\n                          value of 2 would send every other alert. Defaults to -1,\n                          which is a special value representing exponential backoff.\n                          (alerts on event number 1,2,4,8, etc)\n\n    :type alert_after: str\n    :param alert_after: A human readable time unit to suspend handler action until\n                        enough occurrences have taken place. Only valid when\n                        check_every is accurate.\n\n    :type dependencies: list\n    :param dependencies: An list of strings representing checks that *this*\n                         check is dependent on.\n\n    :type irc_channels: list\n    :param irc_channels: An list of IRC channels to send the event\n                         notification to. Defaults to the team setting. Set an empty\n                         list to specify no IRC notifications.\n\n    :type slack_channels: list\n    :param slack_channels: An list of Slack channels to send the event\n                         notification to. Defaults to the team setting. Set an empty\n                         list to specify no Slack notifications.\n\n    :type ticket: bool\n    :param ticket: A Boolean value to enable ticket creation. Defaults to false.\n\n    :type project: str\n    :param project: A string representing the JIRA project that the ticket\n                    should go under. Defaults to the team value.\n\n    :type priority: str\n    :param priority: A JIRA priority to use when creating a ticket. This only\n                     makes sense to use when in combination with the ticket\n                     parameter set to true.\n\n    :type source: str\n    :param source: Allows \"masquerading\" the source value of the event,\n                   otherwise comes from the fqdn of the host it runs on.\n                   This is especially important to set on events that could\n                   potentially be created from multiple hosts. For example if\n                   ``send_event`` is called from three different hosts in a cluster,\n                   you wouldn't want three different events, you would only want\n                   one event that looked like it came from ``the_cluster``, so\n                   you would set ``source='the_cluster'``.\n\n    :type tags: list\n    :param tags: An list of arbitrary tags that can be used in handlers for\n                 different metadata needs such as labels in JIRA handlers.\n\n    :type ttl: str\n    :param ttl: A human readable time unit to set the check TTL. If Sensu does\n                not hear from the check after this time unit, Sensu will spawn a\n                new failing event! (aka check staleness) Defaults to None,\n                meaning Sensu will only spawn events when send_event is called.\n\n    :type sensu_host: str\n    :param sensu_host: The IP or Name to connect to for sending the event.\n                       Defaults to the yocalhost IP.\n\n    :type component: list\n    :param component: Component(s) affected by the event. Good example here would\n                      would be to include the service that is being affected or a\n                      module of that service such as healthcheck.\n\n    :type description: str\n    :param description: Human readable text giving more context on the event. This could\n                        include information on what the check means or why was it\n                        created.\n\n\n    Note on TTL events and alert_after:\n    ``alert_after`` and ``check_every`` only really make sense on events that are created\n    periodically. Setting ``alert_after`` on checks that are not periodic is not advised\n    because the math will be incorrect. For example, if check was written that called\n    ``send_event`` on minute values that were prime, what should the ``check_every`` setting\n    be? No matter what it was, it would be wrong, and therefore ``alert_after`` would be incorrectly\n    calculated (as it is a function of the number of failing events seen multiplied by the ``check_every``\n    setting). If in doubt, set ``alert_after`` to ``0`` to ensure you never miss an alert\n    due to incorrect ``alert_after`` math on non-periodic events. (See also this\n    `Pull request <https://github.com/sensu/sensu/pull/1200>`_)\n\n    \"\"\"\n    if not (name and team):\n        raise ValueError(\"Name and team must be present\")\n    if not re.match(r'^[\\w\\.-]+$', name):\n        raise ValueError(\"Name cannot contain special characters\")\n    if not runbook:\n        runbook = 'Please set a runbook!'\n    result_dict = {\n        'name': name,\n        'status': status,\n        'output': output,\n        'handler': 'default',\n        'team': team,\n        'runbook': runbook,\n        'tip': tip,\n        'notification_email': notification_email,\n        'interval': human_to_seconds(check_every),\n        'page': page,\n        'realert_every': int(realert_every),\n        'dependencies': dependencies,\n        'alert_after': human_to_seconds(alert_after),\n        'ticket': ticket,\n        'project': project,\n        'priority': priority,\n        'source': source,\n        'tags': tags,\n        'ttl': human_to_seconds(ttl),\n    }\n    if irc_channels is not None:\n        result_dict['irc_channels'] = irc_channels\n\n    if slack_channels is not None:\n        result_dict['slack_channels'] = slack_channels\n\n    if component is not None:\n        result_dict['component'] = component\n\n    if description is not None:\n        result_dict['description'] = description\n\n    json_hash = json.dumps(result_dict)\n\n    sock = socket.socket()\n    try:\n        sock.connect((sensu_host, sensu_port))\n        sock.sendall(six.b(json_hash) + b'\\n')\n    finally:\n        sock.close()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nencoding a URI string or string component.", "response": "def uriencode(uristring, safe='', encoding='utf-8', errors='strict'):\n    \"\"\"Encode a URI string or string component.\"\"\"\n    if not isinstance(uristring, bytes):\n        uristring = uristring.encode(encoding, errors)\n    if not isinstance(safe, bytes):\n        safe = safe.encode('ascii')\n    try:\n        encoded = _encoded[safe]\n    except KeyError:\n        encoded = _encoded[b''][:]\n        for i in _tointseq(safe):\n            encoded[i] = _fromint(i)\n        _encoded[safe] = encoded\n    return b''.join(map(encoded.__getitem__, _tointseq(uristring)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef uridecode(uristring, encoding='utf-8', errors='strict'):\n    if not isinstance(uristring, bytes):\n        uristring = uristring.encode(encoding or 'ascii', errors)\n    parts = uristring.split(b'%')\n    result = [parts[0]]\n    append = result.append\n    decode = _decoded.get\n    for s in parts[1:]:\n        append(decode(s[:2], b'%' + s[:2]))\n        append(s[2:])\n    if encoding is not None:\n        return b''.join(result).decode(encoding, errors)\n    else:\n        return b''.join(result)", "response": "Decode a URI string or string component."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _convert_to_array(x, size, name):\n    try:\n        l = len(x)\n        if l != size:\n            raise ValueError(\n                \"{0} must be scalar or of length {1}\".format(\n                    name, size))\n    except TypeError:\n        # Only one item\n        xa = np.array([x] * size)  # Each item is a diff. object.\n    else:\n        xa = np.array(x)\n\n    return xa", "response": "Convert array or scalar to array."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninterpolates flux at a given wavelength", "response": "def get_line_flux(line_wave, wave, flux, **kwargs):\n    \"\"\"Interpolated flux at a given wavelength (calls np.interp).\"\"\"\n    return np.interp(line_wave, wave, flux, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of unique labels.", "response": "def unique_labels(line_labels):\n    \"\"\"If a label occurs more than once, add num. as suffix.\"\"\"\n    from collections import defaultdict\n    d = defaultdict(int)\n    for i in line_labels:\n        d[i] += 1\n    d = dict((i, k) for i, k in d.items() if k != 1)\n    line_labels_u = []\n    for lab in reversed(line_labels):\n        c = d.get(lab, 0)\n        if c >= 1:\n            v = lab + \"_num_\" + str(c)\n            d[lab] -= 1\n        else:\n            v = lab\n        line_labels_u.insert(0, v)\n\n    return line_labels_u"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the box location of the given line wave and arrow tip.", "response": "def get_box_loc(fig, ax, line_wave, arrow_tip, box_axes_space=0.06):\n    \"\"\"Box loc in data coords, given Fig. coords offset from arrow_tip.\n\n    Parameters\n    ----------\n    fig: matplotlib Figure artist\n        Figure on which the boxes will be placed.\n    ax: matplotlib Axes artist\n        Axes on which the boxes will be placed.\n    arrow_tip: list or array of floats\n        Location of tip of arrow, in data coordinates.\n    box_axes_space: float\n        Vertical space between arrow tip and text box in figure\n        coordinates.  Default is 0.06.\n\n    Returns\n    -------\n    box_loc: list of floats\n        Box locations in data coordinates.\n\n    Notes\n    -----\n    Note that this function is not needed if user provides both arrow\n    tip positions and box locations. The use case is when the program\n    has to automatically find positions of boxes. In the automated\n    plotting case, the arrow tip is set to be the top of the Axes\n    (outside this function) and the box locations are determined by\n    `box_axes_space`.\n\n    In Matplotlib annotate function, both the arrow tip and the box\n    location can be specified. While calculating automatic box\n    locations, it is not ideal to use data coordinates to calculate\n    box location, since plots will not have a uniform appearance. Given\n    locations of arrow tips, and a spacing in figure fraction, this\n    function will calculate the box locations in data\n    coordinates. Using this boxes can be placed in a uniform manner.\n\n    \"\"\"\n    # Plot boxes in their original x position, at a height given by the\n    # key word box_axes_spacing above the arrow tip. The default\n    # is set to 0.06. This is in figure fraction so that the spacing\n    # doesn't depend on the data y range.\n    box_loc = []\n    fig_inv_trans = fig.transFigure.inverted()\n    for w, a in zip(line_wave, arrow_tip):\n        # Convert position of tip of arrow to figure coordinates, add\n        # the vertical space between top edge and text box in figure\n        # fraction. Convert this text box position back to data\n        # coordinates.\n        display_coords = ax.transData.transform((w, a))\n        figure_coords = fig_inv_trans.transform(display_coords)\n        figure_coords[1] += box_axes_space\n        display_coords = fig.transFigure.transform(figure_coords)\n        ax_coords = ax.transData.inverted().transform(display_coords)\n        box_loc.append(ax_coords)\n\n    return box_loc"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates fig and axes if needed and layout axes in fig.", "response": "def prepare_axes(wave, flux, fig=None, ax_lower=(0.1, 0.1),\n                 ax_dim=(0.85, 0.65)):\n    \"\"\"Create fig and axes if needed and layout axes in fig.\"\"\"\n    # Axes location in figure.\n    if not fig:\n        fig = plt.figure()\n    ax = fig.add_axes([ax_lower[0], ax_lower[1], ax_dim[0], ax_dim[1]])\n    ax.plot(wave, flux)\n    return fig, ax"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef initial_annotate_kwargs():\n    return dict(\n        xycoords=\"data\", textcoords=\"data\",\n        rotation=90, horizontalalignment=\"center\", verticalalignment=\"center\",\n        arrowprops=dict(arrowstyle=\"-\", relpos=(0.5, 0.0))\n    )", "response": "Return default parameters passed to Axes. annotate to create labels."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nplotting the line ids for each line in the current language.", "response": "def plot_line_ids(wave, flux, line_wave, line_label1, label1_size=None,\n                  extend=True, annotate_kwargs=None, plot_kwargs=None,\n                  **kwargs):\n    \"\"\"Label features with automatic layout of labels.\n\n    Parameters\n    ----------\n    wave: list or array of floats\n        Wave lengths of data.\n    flux: list or array of floats\n        Flux at each wavelength.\n    line_wave: list or array of floats\n        Wave length of features to be labelled.\n    line_label1: list of strings\n        Label text for each line.\n    label1_size: list of floats\n        Font size in points. If not given the default value in\n        Matplotlib is used. This is typically 12.\n    extend: boolean or list of boolean values\n        For those lines for which this keyword is True, a dashed line\n        will be drawn from the tip of the annotation to the flux at the\n        line.\n    annotate_kwargs : dict\n        Keyword arguments to pass to `annotate`, e.g. color.\n\n        Default value is obtained by calling ``initial_annotate_kwargs()``.\n    plot_kwargs : dict\n        Keyword arguments to pass to `plot`, e.g. color.\n\n        Default value is obtained by calling ``initial_plot_kwargs()``.\n    kwargs: key value pairs\n        All of these keywords are optional.\n\n        The following keys are recognized:\n\n          ax : Matplotlib Axes\n              The Axes in which the labels are to be placed. If not\n              given a new Axes is created.\n          fig: Matplotlib Figure\n              The figure in which the labels are to be placed. If `ax`\n              if given then keyword is then ignored. The figure\n              associated with `ax` is used. If `fig` and `ax` are not\n              given then a new figure is created and an axes is added\n              to it.\n          arrow_tip: scalar or list of floats\n              The location of the annotation point, in data coords. If\n              the value is scalar then it is used for all. Default\n              value is the upper bound of the Axes, at the time of\n              plotting.\n          box_loc: scalar or list of floats\n              The y axis location of the text label boxes, in data\n              units. The default is to place it above the `arrow_tip`\n              by `box_axes_space` units in figure fraction length.\n          box_axes_space: float\n              If no `box_loc` is given then the y position of label\n              boxes is set to `arrow_tip` + this many figure fraction\n              units. The default is 0.06. This ensures that the label\n              layout appearance is independent of the y data range.\n          max_iter: int\n              Maximum iterations to use. Default is set to 1000.\n          add_label_to_artists: boolean\n              If True (default is True) then add unique labels to artists, both\n              text labels and line extending from text label to spectrum. If\n              False then don't add such labels.\n    Returns\n    -------\n    fig, ax: Matplotlib Figure, Matplotlib Axes\n        Figure instance on which the labels were placed and the Axes\n        instance on which the labels were placed. These can be used for\n        further customizations. For example, some labels can be hidden\n        by accessing the corresponding `Text` instance form the\n        `ax.texts` list.\n\n    Notes\n    -----\n    + By default the labels are placed along the top of the Axes. The\n      annotation point is on the top boundary of the Axes at the y\n      location of the line. The y location of the boxes are 0.06 figure\n      fraction units above the annotation location. This value can be\n      customized using the `box_axes_space` parameter. The value must\n      be in figure fractions units. Y location of both labels and\n      annotation points can be changed using `arrow_tip` and `box_loc`\n      parameters.\n    + If `arrow_tip` parameter is given then it is used as the\n      annotation point. This can be a list in which case each line can\n      have its own annotation point.\n    + If `box_loc` is given, then the boxes are placed at this\n      position. This too can be a list.\n    + `arrow_tip` and `box_loc` are the \"y\" components of `xy` and\n      `xyann` parameters accepted by the `annotate` function in\n      Matplotlib.\n    + If the `extend` keyword is True then a line is drawn from the\n      annotation point to the flux at the line wavelength. The flux is\n      calculated by linear interpolation. This parameter can be a list,\n      with one value for each line.\n    + The maximum iterations to be used can be customized using the\n      `max_iter` keyword parameter.\n    + add_label_to_artists: Adding labels to artists makes it very easy to get\n      reference to an artist using Figure.findobj. But a call to plt.legend()\n      will display legend for the lines. Setting add_label_to_artists=False,\n      will not add labels to text or lines and solves this issue. We can all\n      plt.legend() with artists and labels to only display legends for the\n      specified artists.\n\n    \"\"\"\n    wave = np.array(wave)\n    flux = np.array(flux)\n    line_wave = np.array(line_wave)\n    line_label1 = np.array(line_label1)\n\n    nlines = len(line_wave)\n    assert nlines == len(line_label1), \"Each line must have a label.\"\n\n    if label1_size is None:\n        label1_size = np.array([12] * nlines)\n    label1_size = _convert_to_array(label1_size, nlines, \"lable1_size\")\n\n    extend = _convert_to_array(extend, nlines, \"extend\")\n\n    # Sort.\n    indx = np.argsort(wave)\n    wave[:] = wave[indx]\n    flux[:] = flux[indx]\n    indx = np.argsort(line_wave)\n    line_wave[:] = line_wave[indx]\n    line_label1[:] = line_label1[indx]\n    label1_size[:] = label1_size[indx]\n\n    # Flux at the line wavelengths.\n    line_flux = get_line_flux(line_wave, wave, flux)\n\n    # Figure and Axes. If Axes is given then use it. If not, create\n    # figure, if not given, and add Axes to it using a default\n    # layout. Also plot the data in the Axes.\n    ax = kwargs.get(\"ax\", None)\n    if not ax:\n        fig = kwargs.get(\"fig\", None)\n        fig, ax = prepare_axes(wave, flux, fig)\n    else:\n        fig = ax.figure\n\n    # Find location of the tip of the arrow. Either the top edge of the\n    # Axes or the given data coordinates.\n    ax_bounds = ax.get_ybound()\n    arrow_tip = kwargs.get(\"arrow_tip\", ax_bounds[1])\n    arrow_tip = _convert_to_array(arrow_tip, nlines, \"arrow_tip\")\n\n    # The y location of boxes from the arrow tips. Either given heights\n    # in data coordinates or use `box_axes_space` in figure\n    # fraction. The latter has a default value which is used when no\n    # box locations are given. Figure coordiantes are used so that the\n    # y location does not dependent on the data y range.\n    box_loc = kwargs.get(\"box_loc\", None)\n    if not box_loc:\n        box_axes_space = kwargs.get(\"box_axes_space\", 0.06)\n        box_loc = get_box_loc(fig, ax, line_wave, arrow_tip, box_axes_space)\n    else:\n        box_loc = _convert_to_array(box_loc, nlines, \"box_loc\")\n        box_loc = tuple(zip(line_wave, box_loc))\n\n    # If any labels are repeated add \"_num_#\" to it. If there are 3 \"X\"\n    # then the first gets \"X_num_3\". The result is passed as the label\n    # parameter of annotate. This makes it easy to find the box\n    # corresponding to a label using Figure.findobj. But the downside is that a\n    # call to plt.legend() will display legends for the lines (from text to\n    # spectrum location). So we don't add the label to artists if the user\n    # doesn't want to.\n    al = kwargs.get('add_label_to_artists', True)\n    label_u = unique_labels(line_label1) if al else [None for _ in line_label1]\n    label_u_line = [i + \"_line\" for i in label_u] if al else label_u\n\n    if annotate_kwargs is None:\n        annotate_kwargs = {}\n    if plot_kwargs is None:\n        plot_kwargs = {}\n    ak = initial_annotate_kwargs()\n    ak.update(annotate_kwargs)\n    pk = initial_plot_kwargs()\n    pk.update(plot_kwargs)\n    # Draw boxes at initial (x, y) location.\n    for i in range(nlines):\n        ax.annotate(line_label1[i], xy=(line_wave[i], arrow_tip[i]),\n                    xytext=(box_loc[i][0],\n                            box_loc[i][1]),\n\n                    fontsize=label1_size[i],\n                    label=label_u[i],\n                    **ak)\n        if extend[i]:\n            ax.plot([line_wave[i]] * 2, [arrow_tip[i], line_flux[i]],\n                    scalex=False, scaley=False,\n                    label=label_u_line[i],\n                    **pk)\n\n    # Draw the figure so that get_window_extent() below works.\n    fig.canvas.draw()\n\n    # Get annotation boxes and convert their dimensions from display\n    # coordinates to data coordinates. Specifically, we want the width\n    # in wavelength units. For each annotation box, transform the\n    # bounding box into data coordinates and extract the width.\n    ax_inv_trans = ax.transData.inverted()  # display to data\n    box_widths = []  # box width in wavelength units.\n    for box in ax.texts:\n        b_ext = box.get_window_extent()\n        box_widths.append(b_ext.transformed(ax_inv_trans).width)\n\n    # Find final x locations of boxes so that they don't overlap.\n    # Function adjust_boxes uses a direct translation of the equivalent\n    # code in lineid_plot.pro in IDLASTRO.\n    max_iter = kwargs.get('max_iter', 1000)\n    adjust_factor = kwargs.get('adjust_factor', 0.35)\n    factor_decrement = kwargs.get('factor_decrement', 3.0)\n    wlp, niter, changed = adjust_boxes(line_wave, box_widths,\n                                       np.min(wave), np.max(wave),\n                                       adjust_factor=adjust_factor,\n                                       factor_decrement=factor_decrement,\n                                       max_iter=max_iter)\n\n    # Redraw the boxes at their new x location.\n    for i in range(nlines):\n        box = ax.texts[i]\n        if hasattr(box, 'xyann'):\n            box.xyann = (wlp[i], box.xyann[1])\n        elif hasattr(box, 'xytext'):\n            box.xytext = (wlp[i], box.xytext[1])\n        else:\n            warnings.warn(\"Warning: missing xyann and xytext attributes. \"\n                          \"Your matplotlib version may not be compatible \"\n                          \"with lineid_plot.\")\n\n    # Update the figure\n    fig.canvas.draw()\n\n    # Return Figure and Axes so that they can be used for further\n    # manual customization.\n    return fig, ax"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef interpolate_grid(cin, cout, data, fillval=0):\n    if np.iscomplexobj(data):\n        phase = interpolate_grid(\n            cin, cout, unwrap.unwrap_phase(np.angle(data)), fillval=0)\n        ampli = interpolate_grid(cin, cout, np.abs(data), fillval=1)\n        return ampli * np.exp(1j * phase)\n\n    ipol = spinterp.interp2d(x=cin[0], y=cin[1], z=data,\n                             kind=\"linear\",\n                             copy=False,\n                             bounds_error=False,\n                             fill_value=fillval)\n    return ipol(cout[0], cout[1])", "response": "Return the 2D field averaged radially w. r. t. the center"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rytov(radius=5e-6, sphere_index=1.339, medium_index=1.333,\n          wavelength=550e-9, pixel_size=.5e-6, grid_size=(80, 80),\n          center=(39.5, 39.5), focus=0, radius_sampling=42):\n    \"\"\"Field behind a dielectric sphere in the Rytov approximation\n\n    Parameters\n    ----------\n    radius: float\n        Radius of the sphere [m]\n    sphere_index: float\n        Refractive index of the sphere\n    medium_index: float\n        Refractive index of the surrounding medium\n    wavelength: float\n        Vacuum wavelength of the imaging light [m]\n    pixel_size: float\n        Pixel size [m]\n    grid_size: tuple of floats\n        Resulting image size in x and y [px]\n    center: tuple of floats\n        Center position in image coordinates [px]\n    focus: float\n        .. versionadded:: 0.5.0\n\n        Axial focus position [m] measured from the center of the\n        sphere in the direction of light propagation.\n    radius_sampling: int\n        Number of pixels used to sample the sphere radius when\n        computing the Rytov field. The default value of 42\n        pixels is a reasonable number for single-cell analysis.\n    Returns\n    -------\n    qpi: qpimage.QPImage\n        Quantitative phase data set\n    \"\"\"\n    # sample the sphere radius with approximately 42px\n    # (rounded to next integer pixel size)\n    samp_mult = radius_sampling * pixel_size / radius\n    sizex = grid_size[0] * samp_mult\n    sizey = grid_size[1] * samp_mult\n    grid_size_sim = [np.int(np.round(sizex)),\n                     np.int(np.round(sizey))]\n    size_factor = grid_size_sim[0] / grid_size[0]\n    pixel_size_sim = pixel_size / size_factor\n\n    field = sphere_prop_fslice_bessel(radius=radius,\n                                      sphere_index=sphere_index,\n                                      medium_index=medium_index,\n                                      wavelength=wavelength,\n                                      pixel_size=pixel_size_sim,\n                                      grid_size=grid_size_sim,\n                                      lD=focus,\n                                      approx=\"rytov\",\n                                      zeropad=5,\n                                      oversample=1\n                                      )\n\n    # interpolate field back to original image coordinates\n    # simulation coordinates\n    x_sim = (np.arange(grid_size_sim[0]) + .5) * pixel_size_sim\n    y_sim = (np.arange(grid_size_sim[1]) + .5) * pixel_size_sim\n    # output coordinates\n    x = (np.arange(grid_size[0]) + grid_size[0] / 2 - center[0]) * pixel_size\n    y = (np.arange(grid_size[1]) + grid_size[1] / 2 - center[1]) * pixel_size\n\n    # Interpolate resulting field with original extent\n    field = interpolate_grid(cin=(y_sim, x_sim),\n                             cout=(y, x),\n                             data=field)\n\n    meta_data = {\"pixel size\": pixel_size,\n                 \"wavelength\": wavelength,\n                 \"medium index\": medium_index,\n                 \"sim center\": center,\n                 \"sim radius\": radius,\n                 \"sim index\": sphere_index,\n                 \"sim model\": \"rytov\",\n                 }\n    qpi = qpimage.QPImage(data=field, which_data=\"field\",\n                          meta_data=meta_data)\n    return qpi", "response": "Calculates the Rytov field of a dielectric sphere in the Rytov approximation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sphere_prop_fslice_bessel(radius, sphere_index, medium_index,\n                              wavelength=550e-9, pixel_size=1e-7,\n                              grid_size=(80, 80), lD=0, approx=\"rytov\",\n                              zeropad=5, oversample=1\n                              ):\n    \"\"\"Compute the projection of a disc using the Fourier slice theorem\n    and the Bessel function of the first kind of order 1.\n\n    Parameters\n    ----------\n    radius: float\n        Radius of the sphere [m]\n    sphere_index: float\n        Refractive index of the sphere\n    medium_index: float\n        Refractive index of the surrounding medium\n    wavelength: float\n        Vacuum wavelength of the imaging light [m]\n    pixel_size: float\n        Pixel size [m]\n    grid_size: tuple of floats\n        Resulting image size in x and y [px]\n    center: tuple of floats\n        Center position in image coordinates [px]\n    lD: float\n        The axial distance [m] from the center of the sphere\n        at which the field is computed.\n    approx: str\n        Which approximation to use (either \"born\" or \"rytov\")\n    zeropad: int\n        Zero-padding factor\n    oversample: int\n        Oversampling factor\n    \"\"\"\n    assert approx in [\"born\", \"rytov\"]\n    assert oversample > 0\n    assert zeropad > 0\n    assert isinstance(oversample, int)\n    assert isinstance(zeropad, int)\n\n    # convert everything to pixels\n    radius /= pixel_size\n    wavelength /= pixel_size\n    lD /= pixel_size\n\n    # apply over-sampling and zero-padding\n    wavelength *= oversample\n    opad_size = np.array(grid_size) * zeropad * oversample\n\n    assert (int(s) == s for s in opad_size), \"grid_size must be integer type\"\n    opad_size = np.array(np.round(opad_size), dtype=int)\n    grid_size = np.array(np.round(grid_size), dtype=int)\n\n    kx = 2 * np.pi * \\\n        np.fft.ifftshift(np.fft.fftfreq(opad_size[0])).reshape(-1, 1)\n    ky = 2 * np.pi * \\\n        np.fft.ifftshift(np.fft.fftfreq(opad_size[1])).reshape(1, -1)\n    km = 2 * np.pi * medium_index / wavelength\n\n    filter_klp = (kx**2 + ky**2 < km**2)\n\n    kz = np.sqrt((km**2 - kx**2 - ky**2) * filter_klp) - km\n\n    r = np.sqrt((kx**2 + ky**2 + kz**2) * filter_klp) / (2 * np.pi)\n\n    comp_id = r != 0\n    F = np.zeros_like(r)\n    F[comp_id] = spspec.spherical_jn(1, r[comp_id] * radius * np.pi * 2) \\\n        * radius**2 / r[comp_id] * 2\n    # center has analytical value\n    center_fft = np.where(np.abs(kx) + np.abs(ky) + np.abs(kz) == 0)\n    F[center_fft] = 4 / 3 * np.pi * radius**3\n\n    # object amplitude\n    F *= km**2 * ((sphere_index / medium_index)**2 - 1)\n\n    # prefactor A\n    M = 1. / km * np.sqrt((km**2 - kx**2 - ky**2) * filter_klp)\n\n    # division factor\n    A = -2j * km * M * np.exp(-1j * km * M * lD)\n\n    # rotate phase by half a pixel so the ifft is centered in real space\n    if grid_size[0] % 2:\n        doffx = 0\n    else:\n        doffx = .5\n    if grid_size[1] % 2:\n        doffy = 0\n    else:\n        doffy = .5\n    transl = np.exp(1j * ((doffx) * kx + (doffy) * ky))\n\n    valid = F != 0\n    Fconv = np.zeros((opad_size[0], opad_size[1]), dtype=complex)\n    Fconv[valid] = F[valid] / A[valid] * transl[valid]\n\n    p = np.fft.ifftn(np.fft.fftshift(Fconv))\n\n    p = np.fft.ifftshift(p)\n\n    if oversample > 1:\n        p = p[::oversample, ::oversample]\n\n    if zeropad > 1:\n        # Slice\n        a0, a1 = np.array(np.floor(opad_size / 2), dtype=int) // oversample\n        b0, b1 = np.array(np.floor(grid_size / 2), dtype=int)\n        if grid_size[0] % 2 != 0:\n            of0 = 1\n            a0 += 1\n        else:\n            of0 = 0\n        if grid_size[1] % 2 != 0:\n            of1 = 1\n            a1 += 1\n        else:\n            of1 = 0\n        # remove zero-padding\n        p = p[a0 - b0:a0 + b0 + of0, a1 - b1:a1 + b1 + of1]\n\n    if approx == \"born\":\n        # norm = (u0 + ub)/u0\n        # norm = 1 + ub/u0\n        return 1 + p / np.exp(1j * km * lD)\n    elif approx == \"rytov\":\n        # norm = (u0 + ur)/u0\n        # ur = u0 ( exp(ub/u0) -1 )\n        # norm = ( u0 + u0 *(exp(ub/u0)-1) )/u0\n        # norm = exp(ub/u0)\n        return np.exp(p / np.exp(1j * km * lD))", "response": "Compute the projection of a Fourier slice bessel function of a sphere."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _run_resources_file(path, stack):\n    import imp, sys, random, string, copy\n    class ContextImporter(object):\n        def find_module(self, fullname, path=None):\n            if fullname == '_context':\n                self.path = path\n                return self\n            return None\n        def load_module(self, name):\n            mod = imp.new_module(\"_context\")\n            mod.stack = stack\n            return mod\n    # Temporarily add the context importer into the meta path\n    old_meta_path = copy.copy(sys.meta_path)\n    old_path = copy.copy(sys.path)\n    # Save the modules list, in order to remove modules loaded after this point\n    old_sys_modules = sys.modules.keys()\n    # Run the module\n    # Prepare import environment\n    abspath = os.path.abspath(path)\n    sys.meta_path.append(ContextImporter())\n    sys.path.append(os.path.dirname(abspath))   # Enable importing files within module's folder\n    # Perform the importing\n    srcf = open(abspath, \"r\")\n    module_name = ''.join(random.choice(string.digits + string.lowercase) for i in range(16))\n    srcmodule = imp.load_source(\"cloudcast._template_\" + module_name, abspath, srcf)\n    srcf.close()\n    # Restore meta path, modules list and return module\n    sys.meta_path = old_meta_path\n    sys.path = old_path\n    for modname in sys.modules.keys():\n        if not modname in old_sys_modules:\n            del sys.modules[modname]\n    return srcmodule", "response": "This function loads the given path as a python module and returns the module s global dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dump_to_template_obj(self, stack, t):\n        if len(self.Parameters) > 0:\n            t['Parameters'] = dict([e.contents(stack) for e in self.Parameters])\n        if len(self.Mappings) > 0:\n            t['Mappings'] = dict([e.contents(stack) for e in self.Mappings])\n        if len(self.Resources) > 0:\n            t['Resources'] = dict([e.contents(stack) for e in self.Resources])\n        if len(self.Outputs) > 0:\n            t['Outputs'] = dict([e.contents(stack) for e in self.Outputs])", "response": "Dump this object to the given template object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dump_json(self, pretty=True):\n        # Build template\n        t = {}\n        t['AWSTemplateFormatVersion'] = '2010-09-09'        \n        if self.description is not None:\n            t['Description'] = self.description\n        self.elements.dump_to_template_obj(self, t)\n\n        return _CustomJSONEncoder(indent=2 if pretty else None,\n                                  sort_keys=False).encode(t)", "response": "Dump this CloudFormation template into a JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef embedded_preview(src_path):\n  ''' Returns path to temporary copy of embedded QuickLook preview, if it exists '''\n  try:\n    assert(exists(src_path) and isdir(src_path))\n\n    preview_list = glob(join(src_path, '[Q|q]uicklook', '[P|p]review.*'))\n    assert(preview_list)  # Assert there's at least one preview file\n    preview_path = preview_list[0]  # Simplistically, assume there's only one\n\n    with NamedTemporaryFile(prefix='pyglass', suffix=extension(preview_path), delete=False) as tempfileobj:\n      dest_path = tempfileobj.name\n      shutil.copy(preview_path, dest_path)\n\n    assert(exists(dest_path))\n    return dest_path\n  except:\n    return None", "response": "Returns path to temporary copy of embedded QuickLook preview if it exists"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef thumbnail_preview(src_path):\n  ''' Returns the path to small thumbnail preview. '''\n  try:\n    assert(exists(src_path))\n\n    width = '1980'\n\n    dest_dir = mkdtemp(prefix='pyglass')\n    cmd = [QLMANAGE, '-t', '-s', width, src_path, '-o', dest_dir]\n    assert(check_call(cmd) == 0)\n\n    src_filename = basename(src_path)\n    dest_list = glob(join(dest_dir, '%s.png' % (src_filename)))\n    assert(dest_list)\n\n    dest_path = dest_list[0]\n    assert(exists(dest_path))\n\n    return dest_path\n  except:\n    return None", "response": "Returns the path to small thumbnail preview."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling a function, with the given arguments inside Gtk's main loop. Example:: gcall(lbl.set_text, \"foo\") If this call would be made in a thread there could be problems, using it inside Gtk's main loop makes it thread safe.", "response": "def gcall(func, *args, **kwargs):\n    \"\"\"\n    Calls a function, with the given arguments inside Gtk's main loop.\n    Example::\n        gcall(lbl.set_text, \"foo\")\n\n    If this call would be made in a thread there could be problems, using\n    it inside Gtk's main loop makes it thread safe.\n    \"\"\"\n    def idle():\n        with gdk.lock:\n            return bool(func(*args, **kwargs))\n    return gobject.idle_add(idle)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninvoke a function in the mainloop pass the data back.", "response": "def invoke_in_mainloop(func, *args, **kwargs):\n    \"\"\"\n    Invoke a function in the mainloop, pass the data back.\n    \"\"\"\n    results = queue.Queue()\n\n    @gcall\n    def run():\n        try:\n            data = func(*args, **kwargs)\n            results.put(data)\n            results.put(None)\n        except BaseException:  # XXX: handle\n            results.put(None)\n            results.put(sys.exc_info())\n            raise\n\n    data = results.get()\n    exception = results.get()\n\n    if exception is None:\n        return data\n    else:\n        tp, val, tb = results.get()\n        raise tp, val, tb"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gtk_threadsafe(func):\n    '''\n    Decorator to make wrapped function threadsafe by forcing it to execute\n    within the GTK main thread.\n\n    .. versionadded:: 0.18\n\n    .. versionchanged:: 0.22\n        Add support for keyword arguments in callbacks by supporting functions\n        wrapped by `functools.partial()`.  Also, ignore callback return value\n        to prevent callback from being called repeatedly indefinitely.  See the\n        `gobject.idle_add() documentation`_ for further information.\n\n\n    .. _`gobject.idle_add() documentation`: http://library.isr.ist.utl.pt/docs/pygtk2reference/gobject-functions.html#function-gobject--idle-add\n\n\n    Parameters\n    ----------\n    func : function or functools.partial\n    '''\n    # Set up GDK threading.\n    # XXX This must be done to support running multiple threads in GTK\n    # applications.\n    gtk.gdk.threads_init()\n\n    # Support\n    wraps_func = func.func if isinstance(func, functools.partial) else func\n\n    @functools.wraps(wraps_func)\n    def _gtk_threadsafe(*args):\n        def _no_return_func(*args):\n            func(*args)\n\n        gobject.idle_add(_no_return_func, *args)\n\n    return _gtk_threadsafe", "response": "Decorator to make a function threadsafe by forcing it to execute\n    within the GTK main thread."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart the task. is not threadsave", "response": "def start(self, *args, **kwargs):\n        \"\"\"Start the task.\n\n        This is:\n            * not threadsave\n            * assumed to be called in the gtk mainloop\n        \"\"\"\n        args = (self.counter,) + args\n        thread = threading.Thread(\n                target=self._work_callback,\n                args=args, kwargs=kwargs\n                )\n        thread.setDaemon(self.daemon)\n        thread.start()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting unverified uploads for the given list of destinations.", "response": "def delete_unverified_uploads(destinations):\n    \"\"\"\n    :param destinations: list of Destination.destination\n\n    For each Destination.destination:\n        Deletes all FilesDestinations where the destination is not verified\n        Deletes each FilesContainer in the deleted FilesDestinations if not present in a non deleted FilesDestinations\n        Deletes each FileFragment if corresponds to a FilesInContainers for a FilesContainer deleted and not in\n            a non deleted FilesContainer\n        Deletes each UploadedFile if corresponds to a FilesInContainers for a FilesContainer deleted and not in\n            a non deleted FilesContainer and/or has no more FileFragment in non deleted FilesContainer\n    \"\"\"\n    with get_session() as session:\n        # TODO use triggers or cascades to delete relations\n        for destination in destinations:\n            _log.info(\"Deleting unverified uploads for destination %s\", destination)\n\n            # get unverified FilesDestinations for the configured mail_conf\n            files_destinations_q = session.query(FilesDestinations)\\\n                .filter(\n                    FilesDestinations.verification_info.is_(None),\n                    FilesDestinations.destinations_id == (\n                        select([Destination.id]).\n                        where(Destination.destination == destination).\n                        as_scalar()))\n            files_destinations = files_destinations_q.all()\n\n            if not files_destinations:\n                continue\n\n            # get FilesContainer.id for containers which are not associated to another destination\n            fd1 = aliased(FilesDestinations)\n            fd2 = aliased(FilesDestinations)\n            files_container_ids_to_delete = [\n                f.file_containers_id for f in\n                session.query(fd1.file_containers_id)\n                .filter(fd1.file_containers_id.in_([fd.file_containers_id for fd in files_destinations]))\n                .filter(~exists().where(\n                    and_(fd1.file_containers_id == fd2.file_containers_id,\n                         fd1.destinations_id != fd2.destinations_id)))\n                .all()\n                ]\n\n            # will delete all FilesInContainers for containers to be deleted. FIXME could be done in cascade\n            files_in_container_q = session.query(FilesInContainers)\\\n                .filter(FilesInContainers.file_containers_id.in_(files_container_ids_to_delete))\n\n            # get files (and fragments) only present in containers to delete (can be deleted also)\n            fic1 = aliased(FilesInContainers)\n            fic2 = aliased(FilesInContainers)\n            files_to_delete = session.query(fic1)\\\n                .filter(fic1.file_containers_id.in_(files_container_ids_to_delete))\\\n                .filter(~exists().where(\n                    and_(\n                        # same file/fragment\n                        fic1.uploaded_files_id == fic2.uploaded_files_id,\n                        fic1.uploaded_file_fragment_number == fic2.uploaded_file_fragment_number,\n                        # in other container\n                        ~fic2.file_containers_id.in_(files_container_ids_to_delete)\n                    )))\\\n                .all()\n\n            # delete fragments\n            # FIXME needs to be optimized (using placeholders or something)\n            for file_id, fragment_number in \\\n                    [(f.uploaded_files_id, f.uploaded_file_fragment_number)\n                     for f in files_to_delete if f.uploaded_file_fragment_number > 0]:\n                session.query(FileFragment)\\\n                    .filter(FileFragment.file_id == file_id, FileFragment.fragment_number == fragment_number)\\\n                    .delete(synchronize_session='fetch')\n\n            # delete uploaded files without fragments\n            whole_file_ids = [f.uploaded_files_id for f in files_to_delete if f.uploaded_file_fragment_number == 0]\n            if whole_file_ids:\n                session.query(UploadedFile)\\\n                    .filter(UploadedFile.id.in_(whole_file_ids))\\\n                    .delete(synchronize_session='fetch')\n\n            # delete uploaded files with all their fragments deleted. FIXME optimize\n            fragmented_file_ids = [f.uploaded_files_id for f in files_to_delete if f.uploaded_file_fragment_number > 0]\n            if fragmented_file_ids:\n                session.query(UploadedFile)\\\n                    .filter(UploadedFile.id.in_(fragmented_file_ids),\n                            ~exists().where(FileFragment.file_id == UploadedFile.id))\\\n                    .delete(synchronize_session='fetch')\n\n            session.query(FilesContainer)\\\n                .filter(FilesContainer.id.in_(files_container_ids_to_delete))\\\n                .delete(synchronize_session='fetch')\n\n            files_in_container_q.delete(synchronize_session='fetch')\n            files_destinations_q.delete(synchronize_session='fetch')\n        session.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef top_stories(self, limit=5, first=None, last=None, json=False):\n\n        story_ids = requests.get(TOP_STORIES_URL).json()\n        story_urls = []\n        for story_id in story_ids:\n            url = API_BASE + \"item/\" + str(story_id) + '.json'\n            story_urls.append(url)\n\n        if first and last:\n            story_urls = story_urls[first:last]\n            if limit != 5:\n                story_urls[:limit]  # default not given\n        else:\n            story_urls = story_urls[:limit]\n\n        # try:\n        #     response_queue = fetch_parallel(story_urls)\n        #     if json:\n        #         while not response_queue.empty():\n        #             yield response_queue.get()\n        #     else:\n        #         while not response_queue.empty():\n        #             yield story_parser(response_queue.get())\n        # except AttributeError:\n        #     Exception(\"Too many requests worker!!\")\n\n        # using gevent\n        response_list = fetch_event(story_urls)\n        if json:\n            yield response_list\n        else:\n            for response in response_list:\n                yield story_parser(response)", "response": "Get the top stories list of items"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_comments(self, comment_id=2921983, limit=5, json=False):\n        try:\n            comment_ids = requests.get(\n                API_BASE + \"item/\" + str(comment_id) + '.json').json()['kids']\n        except KeyError:\n            return None\n\n        comment_urls = []\n        for comment_id in comment_ids:\n            url = API_BASE + \"item/\" + str(comment_id) + '.json'\n            comment_urls.append(url)\n        comment_urls[:limit]  # default not given\n\n        # try:\n        #     response_queue = fetch_parallel(comment_urls)\n        #     if json:\n        #         while not response_queue.empty():\n        #             yield response_queue.get()\n        #     else:\n        #         while not response_queue.empty():\n        #             yield comment_parser(response_queue.get())\n        # except AttributeError:\n        #     Exception(\"Too many requests worker!!\")\n\n        # using gevent\n        response_list = fetch_event(comment_urls)\n        response_obj = [comment_parser(comment_json)\n                        for comment_json in response_list]\n        return response_obj", "response": "Get the top story objects list by comment id"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_image_to_rgb_mode(image, fill_color=(255, 255, 255)):\n    if image.mode not in ('RGBA', 'LA'):\n        return image\n\n    # In most cases simply discarding the alpha channel will give\n    # undesirable result, because transparent pixels also have some\n    # unpredictable colors. It is much better to fill transparent pixels\n    # with a specified color.\n    background_image = Image.new(image.mode[:-1], image.size, fill_color)\n    background_image.paste(image, image.split()[-1])\n    return background_image", "response": "Convert an image instance to RGB mode."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate multiple pixel resolutions of the given image.", "response": "def generate_multiple_pixel_resolutions(image, pixel_resolutions,\n        filter=Filter.NearestNeighbor,\n        does_crop=False,\n        crop_aligment=CropAlignment.center,\n        match_orientation=False):\n    \"\"\"\n    Generate multiple resolution images of the given image.\n\n\n    @param image: a Python Library Image (PIL) instance to generate\n       multiple pixel resolutions from.\n\n    @param pixel_resolutions: a list of tuples  ``(logical_size, width, height)``\n        where:\n\n        * ``logical_size``: string representation of the image size, such\n          as, for instance, \"thumbnail\", \"small\", \"medium\", \"large\".\n\n        * ``width``: positive integer corresponding to the number of pixel\n          columns of the image.\n\n        * ``height``: positive integer corresponding to the number of\n          pixel rows.\n\n    @param filter: indicate the filter to use when resizing the image.\n\n    @param does_crop: indicate whether to crop each generated images.\n\n    @param crop_alignment: if the image needs to be cropped, select which\n        alignment to use when cropping.\n\n    @param match_orientation: indicate whether the given canvas size\n        should be inverted to match the orientation of the image.\n\n\n    @return: an iterator, known as a generator, that returns a Python\n             Library Image (PIL) instance each the generator is called.\n    \"\"\"\n    for (logical_size, width, height) in \\\n            sorted(pixel_resolutions, key=lambda (l, w, h): w, reverse=True):\n        yield (logical_size,\n            resize_image(image, (width, height),\n                filter=filter,\n                does_crop=does_crop,\n                crop_aligment=crop_aligment,\n                match_orientation=match_orientation))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_exposure(image, filters=None):\n    def _get_exposure(histogram):\n        total = sum(histogram)\n        range_offset = len(histogram) / 4\n        dark = float(sum(histogram[0:range_offset])) / total\n        #normal = float(sum(histogram[range_offset:-range_offset])) / total\n        light = float(sum(histogram[-range_offset:])) / total\n        return PictureExposure.UnderExposed if dark > 0.5 and light < 0.5 \\\n            else PictureExposure.OverExposed if dark < 0.5 and light > 0.5 \\\n            else PictureExposure.NormallyExposed\n\n    FILTER_SETTINGS = {\n        ColorComponentFilter.Red: ('RGB', 0, 256),\n        ColorComponentFilter.Green: ('RGB', 256, 512),\n        ColorComponentFilter.Blue: ('RGB', 512, 768),\n        ColorComponentFilter.Grey: ('L', 0, 256)\n    }\n\n    exposures = collections.defaultdict(int)\n    for exposure in [ _get_exposure(image.convert(mode).histogram()[start_index:end_index])\n        for (mode, start_index, end_index) in [ FILTER_SETTINGS[filtr]\n            for filtr in filters or [\n                ColorComponentFilter.Red,\n                ColorComponentFilter.Green,\n                ColorComponentFilter.Blue,\n                ColorComponentFilter.Grey\n            ] ] ]:\n        exposures[exposure] += 1\n\n    return sorted(exposures.iterkeys(), key=lambda k: exposures[k], reverse=True)[0]", "response": "Determines the exposure of a given image."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nindicate whether the specified image file is valid or not.", "response": "def is_image_file_valid(file_path_name):\n    \"\"\"\n    Indicate whether the specified image file is valid or not.\n\n\n    @param file_path_name: absolute path and file name of an image.\n\n\n    @return: ``True`` if the image file is valid, ``False`` if the file is\n        truncated or does not correspond to a supported image.\n    \"\"\"\n    # Image.verify is only implemented for PNG images, and it only verifies\n    # the CRC checksum in the image.  The only way to check from within\n    # Pillow is to load the image in a try/except and check the error.  If\n    # as much info as possible is from the image is needed,\n    # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it\n    # will attempt to parse as much as possible.\n    try:\n        with Image.open(file_path_name) as image:\n            image.load()\n    except IOError:\n        return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nopen the image from the specified file and reorient it accordingly.", "response": "def open_and_reorient_image(handle):\n    \"\"\"\n    Load the image from the specified file and orient the image accordingly\n    to the Exif tag that the file might embed, which would indicate the\n    orientation of the camera relative to the captured scene.\n\n\n    @param handle: a Python file object.\n\n\n    @return: an instance returned by the Python Library Image library.\n    \"\"\"\n    # Retrieve tags from the Exchangeable image file format (Exif)\n    # included in the picture.  If the orientation of the picture is not\n    # top left side, rotate it accordingly.\n\n    # @deprecated\n    # exif_tags = dict([ (exif_tag.tag, exif_tag)\n    #     for exif_tag in exif.process_file(handle).itervalues()\n    #         if hasattr(exif_tag, 'tag') ])\n\n    exif_tags = exifread.process_file(handle)\n    exif_tag_orientation = exif_tags.get(EXIF_TAG_ORIENTATION)\n\n    rotation_angle = exif_tag_orientation and {\n            3L: 180,\n            6L: 270,\n            8L: 90\n        }.get(exif_tag_orientation.values[0])\n\n    handle.seek(0) # exif.process_file has updated the file's current position.\n    image = Image.open(handle)\n\n    return image if rotation_angle is None else image.rotate(rotation_angle)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef realign_image(image, shift_x, shift_y, max_shift_x, max_shift_y,\n        shift_angle=0.0, filter=Filter.NearestNeighbor,\n        stretch_factor=None,\n        cropping_box=None):\n    \"\"\"\n    Realign the given image providing the specific horizontal and vertical\n    shifts, and crop the image providing the maximum horizontal and\n    vertical shifts of images of a same set so that they all have the same\n    size.\n\n\n    @param image: an instance of Python Image Library (PIL) image.\n\n    @param shift_x: horizontal shift in pixels of the image.\n\n    @param shift_y: vertical shift in pixels of the image.\n\n    @param max_shift_x: maximum absolute value of the horizontal shift in\n        pixels of the images in the capture.\n\n    @param max_shift_y: maximum absolute value of the vertical shift in\n        pixels of the images in the capture.\n\n    @param shift_angle: horizontal displacement angle in degrees of\n           the image.\n\n    @param filter: indicate the filter to use when rotating the image.\n\n    @param stretch_factor: coefficient of multiplication to stretch or\n           to shrink the image in both horizontal and vertical\n           directions.\n\n    @param cropping_box: a 4-tuple defining the left, upper, right, and\n           lower pixel coordinate of the rectangular region from the\n           specified image.\n\n\n    @return: a new instance of Python Image Library (PIL) image.\n    \"\"\"\n    (width, height) = image.size\n\n    # Determine the new size of the image based on the maximal horizontal\n    # and vertical shifts of all the other images in this series.\n    new_width = width - max_shift_x * 2\n    new_height = height - max_shift_y * 2\n\n    # Determine the coordinates of the zone to crop to center the image\n    # based on the horizontal and vertical shifts.\n    bounding_box_x = (0 if shift_x < 0 else shift_x * 2)\n    bounding_box_y = (0 if shift_y < 0 else shift_y * 2)\n\n    if max_shift_x > shift_x:\n        bounding_box_width = width - abs(shift_x) * 2\n        bounding_box_x += (bounding_box_width - new_width) / 2\n        #bounding_box_x = max_shift_x - abs(shift_x)\n\n    if max_shift_y > shift_y:\n        bounding_box_height = height - abs(shift_y) * 2\n        bounding_box_y += (bounding_box_height - new_height) / 2\n        #bounding_box_y = max_shift_y - abs(shift_y)\n\n    # Crop the image and rotate it based on the horizontal displacement\n    # angle of this image.\n    image = image.crop((bounding_box_x, bounding_box_y,\n                        bounding_box_x + new_width, bounding_box_y + new_height)) \\\n        .rotate(-shift_angle, PIL_FILTER_MAP[filter])\n\n    # Stretch or shrink this image based on its coefficient, keeping the\n    # calculated new size of this image.\n    if stretch_factor and stretch_factor > 0:\n        image = image.resize((int(round(width * stretch_factor)), int(round(height * stretch_factor))),\n                             PIL_FILTER_MAP[filter])\n        (width, height) = image.size\n\n        if stretch_factor >= 1:\n            image = image.crop(((width - new_width) / 2, (height - new_height) / 2,\n                                (width - new_width) / 2 + new_width - 1, (height - new_height) / 2 + new_height - 1))\n        else:\n            _image = Image.new(image.mode, (new_width, new_height))\n            _image.paste(image, ((new_width - width) / 2, (new_height - height) / 2))\n            image = _image\n\n    # Crop the image to the specified rectangle, if any defined.\n    if cropping_box:\n        (crop_x1, crop_y1, crop_x2, crop_y2) = cropping_box\n        (width, height) = image.size\n\n        image = image.crop(\n            (int(round(crop_x1 * width)), int(round(crop_y1 * height)),\n             int(round(crop_x2 * width)), int(round(crop_y2 * height))))\n\n    return image", "response": "Realigns the given image with the given horizontal and vertical shifts and crops the image with the given angle."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __get_vtt_angles(self, pvals, nvals):\n\t\t# https://www.khanacademy.org/math/trigonometry/unit-circle-trig-func/inverse_trig_functions/v/inverse-trig-functions--arctan\n\t\tangles = np.arctan2(pvals, nvals)-np.pi/4\n\t\tnorm = np.maximum(np.minimum(angles, np.pi-angles), -1*np.pi-angles)\n\t\tnorm = csr_matrix(norm)\n\t\t# Remove any weight from the NER features. These will be added later.\n\t\tfor key, value in self.B.items():\n\t\t\tnorm[0, key] = 0.\n\t\treturn norm", "response": "Fit the angles to the model and return the normalized coef_ values"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decision_function(self, X):\n\t\tif not hasattr(self, 'coef_') or self.coef_ is None:\n\t\t\traise NotFittedError(\"This %(name)s instance is not fitted \"\n\t\t\t\t\t\t\t\t \"yet\" % {'name': type(self).__name__})\n\n\t\t# Number of NER features. These can be int\n\t\tn_ner = len(self.B)\n\n\t\tX_fea = X[ : , :-n_ner]\n\t\tX_ner = X[ : , -n_ner:]\n\n\t\tX_fea = check_array(X_fea, dtype=bool, accept_sparse='csr')\n\t\tX_ner = check_array(X_ner, dtype=int, ensure_min_features=0, accept_sparse='csr')\n\n\t\tn_features = self.coef_.shape[1]\n\t\tif X.shape[1] != n_features:\n\t\t\traise ValueError(\"X has %d features per sample; expecting %d\" % (X.shape[1], n_features))\n\n\t\tscores = safe_sparse_dot(X, self.coef_.T, dense_output=True) + self.intercept_\n\t\treturn scores.ravel() if scores.shape[1] == 1 else scores", "response": "Predict confidence scores for samples."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the parameters of the estimator.", "response": "def set_params(self, **params):\n\t\t\"\"\" Set the parameters of the estimator.\n\n\t\tArgs:\n\t\t\tbias (array-like) : bias of the estimator. Also known as the intercept in a linear model.\n\t\t\tweights (array-like) : weights of the features. Also known as coeficients.\n\t\t\tNER biases (array-like) : NER entities infering column position on X and bias value. Ex: `b_4=10, b_5=6`.\n\n\t\tExample:\n\t\t\t>>> cls = VTT()\n\t\t\t>>> cls.set_params(b_4=10, b_5=6, b_6=8)\n\t\t\"\"\"\n\t\tif 'bias' in params.keys():\n\t\t\tself.intercept_ = params['bias']\n\t\tif 'weights' in params.keys():\n\t\t\tself.coef_ = params['weights']\n\t\tfor key in params.keys():\n\t\t\tif 'b_' == key[:2]:\n\t\t\t\tself.B[int(key[2:])] = params[key]\n\n\t\treturn self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_params(self, deep=True):\n\t\tparams = {'weights':self.coef_, 'bias':self.intercept_}\n\t\tif deep:\n\t\t\tfor key, value in self.B.items():\n\t\t\t\tparams['b_'+str(key)] = value\n\t\t\n\t\treturn params", "response": "Get parameters for the estimator."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __build_author_name_expr(author_name, author_email_address):\n    assert author_name or author_email_address, 'Both arguments MUST NOT be bull'\n\n    # Use the specified name of the author or the username of his email\n    # address.\n    author_name_expr = author_name or author_email_address[:author_email_address.find('@')]\n\n    # Escape the name of the author if it contains a space character.\n    if ' ' in author_name_expr:\n        author_name_expr = '\"%s\"' % author_name_expr\n\n    # Complete the name of the author with his email address when specified.\n    if author_email_address:\n        author_name_expr = '%s <%s>' % (author_name_expr, author_email_address)\n\n    return author_name_expr", "response": "Builds the name of the author of a message."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending an email to a list of recipients.", "response": "def send_email(hostname, username, password,\n        author_name, author_email_address, recipient_email_addresses,\n        subject, content,\n        file_path_names=None,\n        port_number=587,\n        unsubscribe_mailto_link=None,\n        unsubscribe_url=None):\n    \"\"\"\n    Send a electronic mail to a list of recipients.\n\n\n    @note: Outlook and Gmail leverage the list-unsubscribe option for\n        senders with good sending reputations:\n\n        \"In order to receive unsubscribe feedback, senders must include an\n        RFC2369-compliant List-Unsubscribe header containing a mailto: address.\n        Please note that we only enable this feedback via email, so URIs for\n        other protocols such as http will be ignored. The sender must also\n        have a good reputation, and must act promptly in removing users from\n        their lists. We do not provide unsubscribe feedback to senders when a\n        user unsubscribes from an untrusted message.\"\n        [https://sendersupport.olc.protection.outlook.com/pm/junkemail.aspx]\n\n        \"This only works for some senders right now. We're actively encouraging\n        senders to support auto-unsubscribe \u2014 we think 100% should.  We won't\n        provide the unsubscribe option on messages from spammers: we can't\n        trust that they'll actually unsubscribe you, and they might even send\n        you more spam.  So you'll only see the unsubscribe option for senders\n        that we're pretty sure are not spammers and will actually honor your\n        unsubscribe request.  We're being pretty conservative about which\n        senders to trust in the beginning; over time, we hope to offer the\n        ability to unsubscribe from more email.\"\n        [https://gmail.googleblog.com/2009/07/unsubscribing-made-easy.html]\n\n\n    @param hostname: Internet address or fully qualified domain name --\n        human-readable nickname that corresponds to the address -- of the\n        SMTP server is running on.\n\n    @param username: username to authenticate with against the SMTP server.\n\n    @param password: password associate to the username to authenticate\n        with against the SMTP server.\n\n    @param author_name: complete name of the originator of the message.\n\n    @param author_email_address: address of the mailbox to which the author\n        of the message suggests that replies be sent.\n\n    @param recipient_email_addresses: email address(es) of the primary\n        recipient(s) of the message.  A bare string will be treated as a\n        list with one address.\n\n    @param subject: a short string identifying the topic of the message.\n\n    @param content: the body of the message.\n\n    @param file_path_names: a list of complete fully qualified path name\n        (FQPN) of the files to attach to this message.\n\n    @param port_number: Internet port number on which the remote SMTP\n        server is listening at.\n\n        SMTP communication between mail servers uses TCP port 25.  Mail\n        clients on the other hand, often submit the outgoing emails to a mail\n        server on port 587.  Despite being deprecated, mail providers\n        sometimes still permit the use of nonstandard port 465 for this\n        purpose.\n\n    @param unsubscribe_mailto_link: an email address to directly\n        unsubscribe the recipient who requests to be removed from the\n        mailing list (https://tools.ietf.org/html/rfc2369.html).\n\n        In addition to the email address, other information can be provided.\n        In fact, any standard mail header fields can be added to the mailto\n        link.  The most commonly used of these are \"subject\", \"cc\", and \"body\"\n        (which is not a true header field, but allows you to specify a short\n        content message for the new email). Each field and its value is\n        specified as a query term (https://tools.ietf.org/html/rfc6068).\n\n    @param unsubscribe_url: a link that will take the subscriber to a\n        landing page to process the unsubscribe request.  This can be a\n        subscription center, or the subscriber is removed from the list\n        right away and gets sent to a landing page that confirms the\n        unsubscribe.\n    \"\"\"\n    # Convert bare string representing only one email address as a list with\n    # this single email address.\n    if not isinstance(recipient_email_addresses, (list, set, tuple)):\n        recipient_email_addresses = [ recipient_email_addresses ]\n\n    # Build the message to be sent.\n    message = MIMEMultipart()\n    message['From'] = __build_author_name_expr(author_name, author_email_address)\n    message['To'] = COMMASPACE.join(recipient_email_addresses)\n    message['Date'] = formatdate(localtime=True)\n    message['Subject'] = subject\n\n    if author_email_address:\n        message.add_header('Reply-To', author_email_address)\n\n    # Add method(s) to unsubscribe a recipient from a mailing list at his\n    # request.\n    if unsubscribe_mailto_link or unsubscribe_url:\n        unsubscribe_methods = [\n            unsubscribe_url and '<%s>' % unsubscribe_url,\n            unsubscribe_mailto_link and '<mailto:%s>' % unsubscribe_mailto_link,\n        ]\n\n        message.add_header('List-Unsubscribe', ', '.join([ method for method in unsubscribe_methods if method ]))\n\n    # Detect whether the content of the message is a plain text or an HTML\n    # content, based on whether the content starts with \"<\" or not.\n    message.attach(MIMEText(content.encode('utf-8'),\n            _charset='utf-8',\n            _subtype='html' if content and content.strip()[0] == '<' else 'plain'))\n\n    # Attache the specified files to the message.\n    for file_path_name in file_path_names or []:\n        part = MIMEBase('application', 'octet-stream')\n\n        with open(file_path_name, 'rb') as handle:\n            part.set_payload(handle.read())\n\n        encoders.encode_base64(part)\n        part.add_header('Content-Disposition', 'attachment', filename=os.path.basename(file_path_name))\n        message.attach(part)\n\n    # Connect the remote mail server and send the message.\n    smtp_server = smtplib.SMTP_SSL(hostname) if port_number == 465 else smtplib.SMTP(hostname, port_number)\n    smtp_server.ehlo()\n\n    if port_number <> 465:\n        smtp_server.starttls()\n        smtp_server.ehlo()\n\n    smtp_server.login(username, password)\n    smtp_server.sendmail(author_email_address, recipient_email_addresses, message.as_string())\n\n    smtp_server.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef agg_multi_func(values, agg_field, agg_funcs, group_by=None):\n        if len(values) == 0:\n            return None\n        else:\n            if group_by:\n                group_aggs = pd.DataFrame(values).groupby(group_by).agg({agg_field: agg_funcs})\n                res = {}\n                for row in group_aggs.itertuples():\n                    row_res = {}\n                    for i, func in enumerate(agg_funcs):\n                        row_res.update({func: row[i+1]})\n                    res.update({row[0]: row_res})\n                return res\n            else:\n                aggs = pd.DataFrame(values).agg({agg_field: agg_funcs})\n                res = {}\n                for func in agg_funcs:\n                    res.update({func: aggs[agg_field][func]})\n                return res", "response": "Aggregates several functions in a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\naggregating a list of objects with a single function.", "response": "def agg_single_func(values, agg_field, agg_func, group_by=None):\n        \"\"\"\n        Aggregates single function\n        :param values: list of objects (dict)\n        :param agg_field: target field to calculate aggregate\n        :param agg_func: aggregate function\n        :param group_by: field used to determine group\n        :return: aggregated value\n        \"\"\"\n        if len(values) == 0:\n            return None\n        else:\n            if group_by:\n                group_aggs = pd.DataFrame(values).groupby(group_by).agg({agg_field: [agg_func]})\n                res = {}\n                for row in group_aggs.itertuples():\n                    res.update({row[0]: row[1]})\n                return res\n            else:\n                return pd.DataFrame(values).agg({agg_field: [agg_func]})[agg_field][agg_func]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfirm that a send has been completed.", "response": "def confirm_send(address, amount, ref_id=None, session=ses):\n    \"\"\"\n    Confirm that a send has completed. Does not actually check confirmations,\n    but instead assumes that if this is called, the transaction has been\n    completed. This is because we assume our own sends are safe.\n\n    :param session:\n    :param str ref_id: The updated ref_id for the transaction in question\n    :param str address: The address that was sent to\n    :param Amount amount: The amount that was sent\n    \"\"\"\n    debitq = session.query(wm.Debit)\n    debitq = debitq.filter(wm.Debit.address == address)\n    debitq = debitq.filter(wm.Debit.amount == amount)\n    debit = debitq.filter(wm.Debit.transaction_state == 'unconfirmed').first()\n    if not debit:\n        raise ValueError(\"Debit already confirmed or address unknown.\")\n    debit.transaction_state = 'complete'\n    if ref_id is not None:\n        debit.ref_id = ref_id\n    session.add(debit)\n    session.commit()\n    return debit"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_config(path):\n    parser = _make_parser()\n    if parser.read(path):\n        return parser\n    raise Exception(\"Failed to read {}\".format(path))", "response": "Reads a configuration from disk."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninversing correction of refractive index and radius for Rytov This method returns the inverse of :func:`correct_rytov_output`. Parameters ---------- radius_sc: float Systematically corrected radius of the sphere [m] sphere_index_sc: float Systematically corrected refractive index of the sphere medium_index: float Refractive index of the surrounding medium radius_sampling: int Number of pixels used to sample the sphere radius when computing the Rytov field. Returns ------- radius: float Fitted radius of the sphere [m] sphere_index: float Fitted refractive index of the sphere See Also -------- correct_rytov_output: the inverse of this method", "response": "def correct_rytov_sc_input(radius_sc, sphere_index_sc, medium_index,\n                           radius_sampling):\n    \"\"\"Inverse correction of refractive index and radius for Rytov\n\n    This method returns the inverse of :func:`correct_rytov_output`.\n\n    Parameters\n    ----------\n    radius_sc: float\n        Systematically corrected radius of the sphere [m]\n    sphere_index_sc: float\n        Systematically corrected refractive index of the sphere\n    medium_index: float\n        Refractive index of the surrounding medium\n    radius_sampling: int\n        Number of pixels used to sample the sphere radius when\n        computing the Rytov field.\n\n    Returns\n    -------\n    radius: float\n        Fitted radius of the sphere [m]\n    sphere_index: float\n        Fitted refractive index of the sphere\n\n    See Also\n    --------\n    correct_rytov_output: the inverse of this method\n    \"\"\"\n    params = get_params(radius_sampling)\n\n    # sage script:\n    # var('sphere_index, sphere_index_sc, na, nb, medium_index')\n    # x = sphere_index / medium_index - 1\n    # eq = sphere_index_sc == sphere_index + ( na*x^2 + nb*x) * medium_index\n    # solve([eq], [sphere_index])\n    # (take the positive sign solution)\n    na = params[\"na\"]\n    nb = params[\"nb\"]\n\n    prefac = medium_index / (2 * na)\n    sm = 2 * na - nb - 1\n    rt = nb**2 - 4 * na + 2 * nb + 1 + 4 / medium_index * na * sphere_index_sc\n    sphere_index = prefac * (sm + np.sqrt(rt))\n\n    x = sphere_index / medium_index - 1\n\n    radius = radius_sc / (params[\"ra\"] * x**2\n                          + params[\"rb\"] * x\n                          + params[\"rc\"])\n\n    return radius, sphere_index"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef correct_rytov_output(radius, sphere_index, medium_index, radius_sampling):\n    params = get_params(radius_sampling)\n\n    x = sphere_index / medium_index - 1\n\n    radius_sc = radius * (params[\"ra\"] * x**2\n                          + params[\"rb\"] * x\n                          + params[\"rc\"])\n\n    sphere_index_sc = sphere_index + medium_index * (params[\"na\"] * x**2\n                                                     + params[\"nb\"] * x)\n\n    return radius_sc, sphere_index_sc", "response": "rCorrects the output of the Rytov algorithm for the given radius and sphere index and radius."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rytov_sc(radius=5e-6, sphere_index=1.339, medium_index=1.333,\n             wavelength=550e-9, pixel_size=1e-7, grid_size=(80, 80),\n             center=(39.5, 39.5), radius_sampling=42):\n    r\"\"\"Field behind a dielectric sphere, systematically corrected Rytov\n\n    This method implements a correction of\n    :func:`qpsphere.models.rytov`, where the\n    `radius` :math:`r_\\text{Ryt}` and the `sphere_index`\n    :math:`n_\\text{Ryt}` are corrected using\n    the approach described in :cite:`Mueller2018` (eqns. 3,4, and 5).\n\n    .. math::\n\n        n_\\text{Ryt-SC} &= n_\\text{Ryt} + n_\\text{med} \\cdot\n                           \\left( a_n x^2 + b_n x + c_n \\right)\n\n        r_\\text{Ryt-SC} &= r_\\text{Ryt} \\cdot\n                           \\left( a_r x^2 +b_r x + c_r \\right)\n\n        &\\text{with} x = \\frac{n_\\text{Ryt}}{n_\\text{med}} - 1\n\n    The correction factors are given in\n    :data:`qpsphere.models.mod_rytov_sc.RSC_PARAMS`.\n\n    Parameters\n    ----------\n    radius: float\n        Radius of the sphere [m]\n    sphere_index: float\n        Refractive index of the sphere\n    medium_index: float\n        Refractive index of the surrounding medium\n    wavelength: float\n        Vacuum wavelength of the imaging light [m]\n    pixel_size: float\n        Pixel size [m]\n    grid_size: tuple of floats\n        Resulting image size in x and y [px]\n    center: tuple of floats\n        Center position in image coordinates [px]\n    radius_sampling: int\n        Number of pixels used to sample the sphere radius when\n        computing the Rytov field. The default value of 42\n        pixels is a reasonable number for single-cell analysis.\n\n    Returns\n    -------\n    qpi: qpimage.QPImage\n        Quantitative phase data set\n    \"\"\"\n    r_ryt, n_ryt = correct_rytov_sc_input(radius_sc=radius,\n                                          sphere_index_sc=sphere_index,\n                                          medium_index=medium_index,\n                                          radius_sampling=radius_sampling)\n\n    qpi = mod_rytov.rytov(radius=r_ryt,\n                          sphere_index=n_ryt,\n                          medium_index=medium_index,\n                          wavelength=wavelength,\n                          pixel_size=pixel_size,\n                          grid_size=grid_size,\n                          center=center,\n                          radius_sampling=radius_sampling)\n\n    # update correct simulation parameters\n    qpi[\"sim radius\"] = radius\n    qpi[\"sim index\"] = sphere_index\n    qpi[\"sim model\"] = \"rytov-sc\"\n\n    return qpi", "response": "r A method to generate a Rytov - based systematically corrected version of a dielectric sphere."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn all CSV and JSON files paths in datapackage_registry", "response": "def schema_files():\n    '''Return all CSV and JSON files paths in datapackage_registry/schemas\n\n    The paths are relative to ./datapackage_registry\n    '''\n    def recursive_glob(path, patterns):\n        results = []\n        for base, dirs, files in os.walk(path):\n            matching_files = []\n            for pattern in patterns:\n                matching_files.extend(fnmatch.filter(files, pattern))\n            results.extend(os.path.join(base, f) for f in matching_files)\n        return results\n\n    base_folder = 'datapackage_registry'\n    remove_base_folder = lambda path: path[len(base_folder) + 1:]\n\n    path = os.path.join(base_folder, 'schemas')\n    files_paths = recursive_glob(path, ['*.csv', '*.json'])\n\n    return [remove_base_folder(f) for f in files_paths]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gsignal(name, *args, **kwargs):\n\n    frame = sys._getframe(1)\n    try:\n        locals = frame.f_locals\n    finally:\n        del frame\n\n    dict = locals.setdefault('__gsignals__', {})\n\n    if args and args[0] == 'override':\n        dict[name] = 'override'\n    else:\n        retval = kwargs.get('retval', None)\n        if retval is None:\n            default_flags = gobject.SIGNAL_RUN_FIRST\n        else:\n            default_flags = gobject.SIGNAL_RUN_LAST\n\n        flags = kwargs.get('flags', default_flags)\n        if retval is not None and flags != gobject.SIGNAL_RUN_LAST:\n            raise TypeError(\n                \"You cannot use a return value without setting flags to \"\n                \"gobject.SIGNAL_RUN_LAST\")\n\n        dict[name] = (flags, retval, args)", "response": "Add a GObject signal to the current object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gproperty(name, ptype, default=None, nick='', blurb='',\n              flags=gobject.PARAM_READWRITE, **kwargs):\n    \"\"\"Add a GObject property to the current object.\n\n    :param name:   name of property\n    :param ptype:   type of property\n    :param default:  default value\n    :param nick:     short description\n    :param blurb:    long description\n    :param flags:    parameter flags, a combination of:\n      - PARAM_READABLE\n      - PARAM_READWRITE\n      - PARAM_WRITABLE\n      - PARAM_CONSTRUCT\n      - PARAM_CONSTRUCT_ONLY\n      - PARAM_LAX_VALIDATION\n\n    Optional, only for int, float, long types:\n\n    :param minimum: minimum allowed value\n    :param: maximum: maximum allowed value\n    \"\"\"\n\n    # General type checking\n    if default is None:\n        default = _DEFAULT_VALUES.get(ptype)\n    elif not isinstance(default, ptype):\n        raise TypeError(\"default must be of type %s, not %r\" % (\n            ptype, default))\n    if not isinstance(nick, str):\n        raise TypeError('nick for property %s must be a string, not %r' % (\n            name, nick))\n    nick = nick or name\n    if not isinstance(blurb, str):\n        raise TypeError('blurb for property %s must be a string, not %r' % (\n            name, blurb))\n\n    # Specific type checking\n    if ptype == int or ptype == float or ptype == long:\n        default = (kwargs.get('minimum', ptype(0)),\n                   kwargs.get('maximum', _MAX_VALUES[ptype]),\n                   default)\n    elif ptype == bool:\n        if default is not True and default is not False:\n            raise TypeError(\"default must be True or False, not %r\" % default)\n        default = default,\n    elif gobject.type_is_a(ptype, gobject.GEnum):\n        if default is None:\n            raise TypeError(\"enum properties needs a default value\")\n        elif not isinstance(default, ptype):\n            raise TypeError(\"enum value %s must be an instance of %r\" %\n                            (default, ptype))\n        default = default,\n    elif ptype == str:\n        default = default,\n    elif ptype == object:\n        if default is not None:\n            raise TypeError(\"object types does not have default values\")\n        default = ()\n    else:\n        raise NotImplementedError(\"type %r\" % ptype)\n\n    if flags < 0 or flags > 32:\n        raise TypeError(\"invalid flag value: %r\" % (flags,))\n\n    frame = sys._getframe(1)\n    try:\n        locals = frame.f_locals\n        dict = locals.setdefault('__gproperties__', {})\n    finally:\n        del frame\n\n    dict[name] = (ptype, nick, blurb) + default + (flags,)", "response": "Add a GObject property to the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef refresh_gui(delay=0.0001, wait=0.0001):\n    time.sleep(delay)\n    while gtk.events_pending():\n        gtk.main_iteration_do(block=False)\n        time.sleep(wait)", "response": "Use up all the events waiting to be run in the main thread"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns a widget or a delegate in a Window", "response": "def run_in_window(target, on_destroy=gtk.main_quit):\n    \"\"\"Run a widget, or a delegate in a Window\n    \"\"\"\n    w = _get_in_window(target)\n    if on_destroy:\n        w.connect('destroy', on_destroy)\n    w.resize(500, 400)\n    w.move(100, 100)\n    w.show_all()\n    gtk.main()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a flatland form based on a pandas Series.", "response": "def dict_to_form(dict):\n    '''\n    Generate a flatland form based on a pandas Series.\n    '''\n    from flatland import Boolean, Form, String, Integer, Float\n\n    def is_float(v):\n        try:\n            return (float(str(v)), True)[1]\n        except (ValueError, TypeError):\n            return False\n\n    def is_int(v):\n        try:\n            return (int(str(v)), True)[1]\n        except (ValueError, TypeError):\n            return False\n\n    def is_bool(v):\n        return v in (True, False)\n\n    schema_entries = []\n    for k, v in dict.iteritems():\n        if is_int(v):\n            schema_entries.append(Integer.named(k).using(default=v,\n                                                         optional=True))\n        elif is_float(v):\n            schema_entries.append(Float.named(k).using(default=v,\n                                                       optional=True))\n        elif is_bool(v):\n            schema_entries.append(Boolean.named(k).using(default=v,\n                                                         optional=True))\n        elif type(v) == str:\n            schema_entries.append(String.named(k).using(default=v,\n                                                        optional=True))\n\n    return Form.of(*schema_entries)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _detect_term_type():\n        if os.name == 'nt':\n            if os.environ.get('TERM') == 'xterm':\n                # maybe MinTTY\n                return 'mintty'\n            else:\n                return 'nt'\n        if platform.system().upper().startswith('CYGWIN'):\n            return 'cygwin'\n        return 'posix'", "response": "Detect the type of the terminal."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetecting the default encoding for the terminal s output.", "response": "def _detect_encoding(stdout):\n        \"\"\"\n        Detect the default encoding for the terminal's output.\n        :return: string: encoding string\n        \"\"\"\n        if hasattr(stdout, 'encoding') and stdout.encoding:\n            return stdout.encoding\n\n        if os.environ.get('LANG'):\n            encoding = os.environ.get('LANG').split('.')[-1]\n\n            # validate the encoding string\n            ret = None\n            try:\n                ret = codecs.lookup(encoding)\n            except LookupError:\n                pass\n            if ret:\n                return encoding\n\n        return locale.getpreferredencoding()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the binary function for restoring terminal attributes.", "response": "def _get_restore_function(self):\n        \"\"\"\n        Return the binary function for restoring terminal attributes.\n        :return: function (signal, frame) => None:\n        \"\"\"\n        if os.name == 'nt' or not self.getch_enabled:\n            return lambda signal, frame: None\n\n        try:\n            fd = self.stdin.fileno()\n            initial = termios.tcgetattr(fd)\n        except termios.error:\n            return lambda signal, frame: None\n\n        return lambda signal, frame: termios.tcsetattr(fd, termios.TCSADRAIN, initial)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear(self):\n        if hasattr(self.stdout, 'isatty') and self.stdout.isatty() or self.term_type == 'mintty':\n            cmd, shell = {\n                'posix': ('clear', False),\n                'nt': ('cls', True),\n                'cygwin': (['echo', '-en', r'\\ec'], False),\n                'mintty': (r'echo -en \"\\ec', False),\n            }[self.term_type]\n            subprocess.call(cmd, shell=shell, stdin=self.stdin, stdout=self.stdout, stderr=self.stderr)", "response": "Clear the terminal screen."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear_input_buffer(self):\n        if hasattr(self.stdin, 'isatty') and self.stdin.isatty():\n            if os.name == 'nt':\n                while msvcrt.kbhit():\n                    msvcrt.getch()\n            else:\n                try:\n                    self.stdin.seek(0, 2)  # may fail in some unseekable file object\n                except IOError:\n                    pass", "response": "Clear the input buffer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getch(self):\n        ch = self._get_one_char()\n        if self.keep_input_clean:\n            self.clear_input_buffer()\n\n        try:\n            # accept only unicode characters (for Python 2)\n            uch = to_unicode(ch, 'ascii')\n        except UnicodeError:\n            return ''\n\n        return uch if self._check_key_repeat(uch) else ''", "response": "Read one character from stdin and return it as unicode."}
