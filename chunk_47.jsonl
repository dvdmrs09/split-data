{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nslots for when the current index changes.", "response": "def currentChanged(self, current, prev):\n        \"\"\"Slot for when the current index changes.\n        Emits the :data:`AbstractLevel.new_root` signal.\n\n        :param current: the new current index\n        :type current: QtGui.QModelIndex\n        :param current: the previous current index\n        :type current: QtGui.QModelIndex\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        m = self.model()\n        p = current.parent()\n        index = m.index(current.row(), 0, p)\n        self.new_root.emit(index)\n        return super(ListLevel, self).currentChanged(current, prev)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the current index to the row of the given index", "response": "def set_index(self, index):\n        \"\"\"Set the current index to the row of the given index\n\n        :param index: the index to set the level to\n        :type index: QtCore.QModelIndex\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.setCurrentIndex(index)\n        self.new_root.emit(index)\n        self.scrollTo(index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nschedule an item layout if resize mode is adjust.", "response": "def resizeEvent(self, event):\n        \"\"\"Schedules an item layout if resize mode is \\\"adjust\\\". Somehow this is\n        needed for correctly scaling down items.\n\n        The reason this was reimplemented was the CommentDelegate.\n\n        :param event: the resize event\n        :type event: QtCore.QEvent\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if self.resizeMode() == self.Adjust:\n            self.scheduleDelayedItemsLayout()\n        return super(ListLevel, self).resizeEvent(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates the layouts and set some attributes of the ui", "response": "def setup_ui(self, ):\n        \"\"\"Create the layouts and set some attributes of the ui\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        grid = QtGui.QGridLayout(self)\n        self.setLayout(grid)\n        self.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)\n        self.splitter = QtGui.QSplitter(QtCore.Qt.Horizontal, self)\n        grid.addWidget(self.splitter)\n        grid.setContentsMargins(0, 0, 0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninserting the level and header into the ui.", "response": "def add_lvl_to_ui(self, level, header):\n        \"\"\"Insert the level and header into the ui.\n\n        :param level: a newly created level\n        :type level: :class:`jukeboxcore.gui.widgets.browser.AbstractLevel`\n        :param header: a newly created header\n        :type header: QtCore.QWidget|None\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        w = QtGui.QWidget(self)\n        vbox = QtGui.QVBoxLayout()\n        vbox.setContentsMargins(0, 0, 0, 0)\n        w.setLayout(vbox)\n        if header is not None:\n            vbox.addWidget(header)\n        vbox.addWidget(level)\n        self.splitter.addWidget(w)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_level(self, depth):\n        ll = ListLevel(parent=self)\n        ll.setEditTriggers(ll.DoubleClicked | ll.SelectedClicked | ll.CurrentChanged)\n        #ll.setSelectionBehavior(ll.SelectRows)\n        ll.setResizeMode(ll.Adjust)\n        self.delegate = CommentDelegate(ll)\n        ll.setItemDelegate(self.delegate)\n        ll.setVerticalScrollMode(ll.ScrollPerPixel)\n        return ll", "response": "Create and return a new level for the given depth"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the first lang of Accept - Language Header.", "response": "def get_first_lang():\n    \"\"\"Get the first lang of Accept-Language Header.\n    \"\"\"\n    request_lang = request.headers.get('Accept-Language').split(',')\n    if request_lang:\n        lang = locale.normalize(request_lang[0]).split('.')[0]\n    else:\n        lang = False\n    return lang"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_dict(dictionary, *keys,**kwargs):\n\n    if 'default' in kwargs:\n        default = kwargs['default']\n    else:\n        default = None\n\n    existing = dictionary\n    for i in range(0, len(keys)):\n\n        if keys[i] in existing:\n\n            existing = existing[keys[i]]\n        else:\n\n            return default\n    return existing", "response": "This function returns a dictionary that contains all the keys in the keys list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef search_by_re_list(re_list, text):\n    for matcher in re_list:\n        m = matcher.search(text)\n        if m:\n            return m.groupdict()\n    return None", "response": "Given a list of compiled regular expressions search in text and return the group - dict for that first match."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting code from lines in enhanced node.", "response": "def extract_code(lines, node, lstrip=\"\", ljoin=\"\\n\", strip=\"\"):\n    \"\"\"Get corresponding text in the code\n\n\n    Arguments:\n    lines -- code splitted by linebreak\n    node -- PyPosAST enhanced node\n\n\n    Keyword Arguments:\n    lstrip -- During extraction, strip lines with this arg (default=\"\")\n    ljoin -- During extraction, join lines with this arg (default=\"\\n\")\n    strip -- After extraction, strip all code with this arg (default=\"\")\n    \"\"\"\n    first_line, first_col = node.first_line - 1, node.first_col\n    last_line, last_col = node.last_line - 1, node.last_col\n    if first_line == last_line:\n        return lines[first_line][first_col:last_col].strip(strip)\n\n    result = []\n    # Add first line\n    result.append(lines[first_line][first_col:].strip(lstrip))\n    # Add middle lines\n    if first_line + 1 != last_line:\n        for line in range(first_line + 1, last_line):\n            result.append(lines[line].strip(lstrip))\n    # Add last line\n    result.append(lines[last_line][:last_col].strip(lstrip))\n    return ljoin.join(result).strip(strip)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dnode(self, node):\n        new_node = copy(node)\n        new_node.lineno += self.dline\n        new_node.col_offset += self.dcol\n        return new_node", "response": "Duplicate node and adjust it for deslocated line and column"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dposition(self, node, dcol=0):\n        nnode = self.dnode(node)\n        return (nnode.lineno, nnode.col_offset + dcol)", "response": "Return line and column of node in the tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate infixop for a node", "response": "def calculate_infixop(self, node, previous, next_node):\n        \"\"\"Create new node for infixop\"\"\"\n        previous_position = (previous.last_line, previous.last_col - 1)\n        position = (next_node.first_line, next_node.first_col + 1)\n        possible = []\n        for ch in OPERATORS[node.__class__]:\n            try:\n                pos = self.operators[ch].find_previous(position)\n                if previous_position < pos[1] < position:\n                    possible.append(pos)\n            except KeyError:\n                pass\n\n        if not possible:\n            raise ValueError(\"not a single {} between {} and {}\".format(\n                OPERATORS[node.__class__], previous_position, position))\n\n        return NodeWithPosition(\n            *min(possible, key=lambda x: tuple(map(sub, position, x[0])))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculate_unaryop(self, node, next_node):\n        position = (next_node.first_line, next_node.first_col + 1)\n        possible = []\n        for ch in OPERATORS[node.__class__]:\n            try:\n                pos = self.operators[ch].find_previous(position)\n                if pos[1] < position:\n                    possible.append(pos)\n            except KeyError:\n                pass\n\n        return NodeWithPosition(\n            *min(possible, key=lambda x: tuple(map(sub, position, x[0])))\n        )", "response": "Calculate unaryop node for a given node and next node"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef uid_something_colon(self, node):\n        node.op_pos = [\n            NodeWithPosition(node.uid, (node.first_line, node.first_col))\n        ]\n        position = (node.body[0].first_line, node.body[0].first_col)\n        last, first = self.operators[':'].find_previous(position)\n        node.op_pos.append(NodeWithPosition(last, first))\n        return last", "response": "Returns the last operator that is used to identify the uid."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef optional_else(self, node, last):\n        if node.orelse:\n            min_first_max_last(node, node.orelse[-1])\n            if 'else' in self.operators:\n                position = (node.orelse[0].first_line, node.orelse[0].first_col)\n                _, efirst = self.operators['else'].find_previous(position)\n                if efirst and efirst > last:\n                    elast, _ = self.operators[':'].find_previous(position)\n                    node.op_pos.append(NodeWithPosition(elast, efirst))", "response": "Create op_pos for optional else."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef comma_separated_list(self, node, subnodes):\n        for item in subnodes:\n            position = (item.last_line, item.last_col)\n            first, last = find_next_comma(self.lcode, position)\n            if first:  # comma exists\n                node.op_pos.append(NodeWithPosition(last, first))", "response": "Process comma separated list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef visit_Constant(self, node):\n        nnode = self.dnode(node)\n        node.first_line, node.first_col = ast_pos(nnode, self.bytes_pos_to_utf8)\n        node.last_line = node.first_line\n        node.last_col = node.first_col + len(repr(node.value))\n        node.uid = (node.last_line, node.last_col)", "response": "Set node. first_line node. first_col and node. uid."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvisiting the REPR node.", "response": "def visit_Repr(self, node):\n        \"\"\" Python 2 \"\"\"\n        position = (node.value.last_line, node.value.last_col + 1)\n        r_set_pos(node, *self.operators['`'].find_next(position))\n        position = (node.value.first_line, node.value.first_col + 1)\n        first = self.operators['`'].find_previous(position)[1]\n        node.first_line, node.first_col = first\n        node.op_pos = [\n            NodeWithPosition((node.first_line, node.first_col + 1), first),\n            NodeWithPosition(node.uid, (node.last_line, node.last_col - 1)),\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_next_comma(self, node, sub):\n        position = (sub.last_line, sub.last_col)\n        first, last = find_next_comma(self.lcode, position)\n        if first:  # comma exists\n            node.op_pos.append(NodeWithPosition(last, first))", "response": "Find comma after sub andd add NodeWithPosition in node"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef visit_Starred(self, node):\n        position = (node.value.first_line, node.value.first_col + 1)\n        r_set_pos(node, *self.operators['*'].find_previous(position))\n        last = node.value\n        node.last_line, node.last_col = last.last_line, last.last_col\n        node.op_pos = [\n            NodeWithPosition(node.uid, dec_tuple(node.uid))\n        ]", "response": "Visit the starred operator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvisit a NameConstant node by copying its value and position to the node.", "response": "def visit_NameConstant(self, node):\n        \"\"\" Python 3 \"\"\"\n        nnode = self.dnode(node)\n        copy_from_lineno_col_offset(\n            nnode, str(node.value), self.bytes_pos_to_utf8, to=node)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef visit_Print(self, node):\n        start_by_keyword(node, self.operators['print'], self.bytes_pos_to_utf8)\n        node.op_pos = [\n            NodeWithPosition(node.uid, (node.first_line, node.first_col))\n        ]\n        subnodes = []\n        if node.dest:\n            min_first_max_last(node, node.dest)\n            position = (node.dest.first_line, node.dest.first_col)\n            last, first = self.operators['>>'].find_previous(position)\n            node.op_pos.append(NodeWithPosition(last, first))\n            subnodes.append(node.dest)\n        if node.values:\n            min_first_max_last(node, node.values[-1])\n            subnodes.extend(node.values)\n\n        self.comma_separated_list(node, subnodes)", "response": "Visit a Print node by adding the appropriate operator and subnodes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nproviding an iterable for all model fields.", "response": "def fields(self):\n        \"\"\"\n        Provides an iterable for all model fields.\n        \"\"\"\n        for attr, value in self._meta.fields.items():\n            if isinstance(value, Field):\n                yield attr, value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wrap(self, data):\n        for name, field in self.fields:\n            try:\n                self._state[name] = field.consume(\n                    self._state.get(name, None), data[name])\n            except KeyError:\n                self._state[name] = None", "response": "Wraps and consumes an arbitrary dictionary into the model."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate(self):\n\n        errors = {}\n\n        for name, field in self.fields:\n            try:\n                field.validate(self._state.get(name))\n            except Exception as e:\n                errors[name] = e\n\n        if len(errors) is not 0:\n            raise Exception(errors)\n\n        return True", "response": "Validates all the fields of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the current model to the database.", "response": "async def save(self):\n        \"\"\"\n        Persists the model to the database. If the model holds no primary key,\n        a new one will automatically created by RethinkDB. Otherwise it will\n        overwrite the current model persisted to the database.\n        \"\"\"\n\n        if hasattr(self, \"before_save\"):\n            self.before_save()\n\n        query = r.table(self.table_name)\n\n        if self._state.get(\"id\"):\n            query = query \\\n                .get(self._state.get(\"id\")) \\\n                .update(self.__db_repr, return_changes=True)\n        else:\n            query = query \\\n                .insert(self.__db_repr, return_changes=True)\n\n        resp = await query.run(await conn.get())\n\n        try:\n            changes = resp[\"changes\"]\n\n            if len(changes) > 0:\n                self.wrap(resp[\"changes\"][0][\"new_val\"])\n        except KeyError:\n            raise UnexpectedDbResponse()\n\n        if resp[\"skipped\"] > 0:\n            raise UnexpectedDbResponse(\n                \"Model with id `%s` not found in the database.\" %\n                self._state.get(\"id\"))\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def delete(self):\n        await r.table_name(self.table_name) \\\n            .get(self.id) \\\n            .delete() \\\n            .run(await conn.get())", "response": "Deletes the model from the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing HTML from text into array filled with tags end text.", "response": "def _raw_split(itxt):\n    \"\"\"\n    Parse HTML from text into array filled with tags end text.\n\n    Source code is little bit unintutive, because it is state machine parser.\n\n    For better understanding, look at http://bit.ly/1rXRcJj\n\n    Example::\n\n        >>> dhtmlparser._raw_split('<html><tag params=\"true\"></html>')\n        ['<html>', '<tag params=\"true\">', '</html>']\n\n    Args:\n        itxt (str): Input HTML text, which will be parsed.\n\n    Returns:\n        list: List of strings (input splitted to tags and text).\n    \"\"\"\n    echr = \"\"\n    buff = [\"\", \"\", \"\", \"\"]\n    content = \"\"\n    array = []\n    next_state = 0\n    inside_tag = False\n    escaped = False\n\n    COMMENT_START = [\"-\", \"!\", \"<\"]\n    COMMENT_END = [\"-\", \"-\"]\n\n    gc.disable()\n\n    for c in itxt:\n        # content\n        if next_state == StateEnum.content:\n            if c == \"<\":\n                if content:\n                    array.append(content)\n\n                content = c\n                next_state = StateEnum.tag\n                inside_tag = False\n\n            else:\n                content += c\n\n        # html tag\n        elif next_state == StateEnum.tag:\n            if c == \">\":\n                array.append(content + c)\n                content = \"\"\n                next_state = StateEnum.content\n\n            elif c == \"'\" or c == '\"':\n                echr = c\n                content += c\n                next_state = StateEnum.parameter\n\n            elif c == \"-\" and buff[:3] == COMMENT_START:\n                if content[:-3]:\n                    array.append(content[:-3])\n\n                content = content[-3:] + c\n                next_state = StateEnum.comment\n\n            else:\n                if c == \"<\":   # jump back into tag instead of content\n                    array.append(content)\n                    inside_tag = True\n                    content = \"\"\n\n                content += c\n\n        # quotes \"\" / ''\n        elif next_state == StateEnum.parameter:\n            if c == echr and not escaped:  # end of quotes\n                next_state = StateEnum.tag\n\n            # unescaped end of line - this is good for invalid HTML like\n            # <a href=something\">..., because it allows recovery\n            if c == \"\\n\" and not escaped and buff[0] == \">\":\n                next_state = StateEnum.content\n                inside_tag = False\n\n            content += c\n            escaped = not escaped if c == \"\\\\\" else False\n\n        # html comments\n        elif next_state == StateEnum.comment:\n            if c == \">\" and buff[:2] == COMMENT_END:\n                next_state = StateEnum.tag if inside_tag else StateEnum.content\n                inside_tag = False\n\n                array.append(content + c)\n                content = \"\"\n            else:\n                content += c\n\n        # rotate buffer\n        buff = _rotate_buff(buff)\n        buff[0] = c\n\n    gc.enable()\n\n    if content:\n        array.append(content)\n\n    return array"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _indexOfEndTag(istack):\n    if len(istack) <= 0:\n        return 0\n\n    if not istack[0].isOpeningTag():\n        return 0\n\n    cnt = 0\n    opener = istack[0]\n    for index, el in enumerate(istack[1:]):\n        if el.isOpeningTag() and \\\n           el.getTagName().lower() == opener.getTagName().lower():\n            cnt += 1\n\n        elif el.isEndTagTo(opener):\n            if cnt == 0:\n                return index + 1\n\n            cnt -= 1\n\n    return 0", "response": "Go through istack and search endtag."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parseDOM(istack):\n    ostack = []\n    end_tag_index = 0\n\n    def neither_nonpair_or_end_or_comment(el):\n        return not (el.isNonPairTag() or el.isEndTag() or el.isComment())\n\n    index = 0\n    while index < len(istack):\n        el = istack[index]\n\n        # check if this is pair tag\n        end_tag_index = _indexOfEndTag(istack[index:])\n\n        if end_tag_index == 0 and neither_nonpair_or_end_or_comment(el):\n            el.isNonPairTag(True)\n\n        if end_tag_index == 0:\n            if not el.isEndTag():\n                ostack.append(el)\n        else:\n            el.childs = _parseDOM(istack[index + 1: end_tag_index + index])\n            el.endtag = istack[end_tag_index + index]  # reference to endtag\n            el.endtag.openertag = el\n\n            ostack.append(el)\n            ostack.append(el.endtag)\n\n            index = end_tag_index + index\n\n        index += 1\n\n    return ostack", "response": "Recursively go through element array and create DOM."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing string txt and return DOM tree consisting of single linked node.", "response": "def parseString(txt, cip=True):\n    \"\"\"\n    Parse string `txt` and return DOM tree consisting of single linked\n    :class:`.HTMLElement`.\n\n    Args:\n        txt (str): HTML/XML string, which will be parsed to DOM.\n        cip (bool, default True): Case Insensitive Parameters. Use special\n            dictionary to store :attr:`.HTMLElement.params` as case\n            insensitive.\n\n    Returns:\n        obj: Single conteiner HTML element with blank tag, which has whole DOM\\\n             in it's :attr:`.HTMLElement.childs` property. This element can be\\\n             queried using :meth:`.HTMLElement.find` functions.\n    \"\"\"\n    if isinstance(txt, HTMLElement):\n        return txt\n\n    # remove UTF BOM (prettify fails if not)\n    if len(txt) > 3 and txt[:3] == u\"\\xef\\xbb\\xbf\":\n        txt = txt[3:]\n\n    if not cip:\n        htmlelement.html_parser.SpecialDict = dict\n    elif isinstance(htmlelement.html_parser.SpecialDict, dict):\n        htmlelement.html_parser.SpecialDict = specialdict.SpecialDict\n\n    container = HTMLElement()\n    container.childs = _parseDOM([\n        HTMLElement(x) for x in _raw_split(txt)\n    ])\n\n    return container"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef makeDoubleLinked(dom, parent=None):\n    dom.parent = parent\n\n    for child in dom.childs:\n        child.parent = dom\n        makeDoubleLinked(child, dom)", "response": "Recursively creates a double - linked tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove all tags from dom and obtain plaintext representation.", "response": "def removeTags(dom):\n    \"\"\"\n    Remove all tags from `dom` and obtain plaintext representation.\n\n    Args:\n        dom (str, obj, array): str, HTMLElement instance or array of elements.\n\n    Returns:\n        str: Plain string without tags.\n    \"\"\"\n    # python 2 / 3 shill\n    try:\n        string_type = basestring\n    except NameError:\n        string_type = str\n\n    # initialize stack with proper value (based on dom parameter)\n    element_stack = None\n    if type(dom) in [list, tuple]:\n        element_stack = dom\n    elif isinstance(dom, HTMLElement):\n        element_stack = dom.childs if dom.isTag() else [dom]\n    elif isinstance(dom, string_type):\n        element_stack = parseString(dom).childs\n    else:\n        element_stack = dom\n\n    # remove all tags\n    output = \"\"\n    while element_stack:\n        el = element_stack.pop(0)\n\n        if not (el.isTag() or el.isComment() or not el.getTagName()):\n            output += el.__str__()\n\n        if el.childs:\n            element_stack = el.childs + element_stack\n\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_method(obj, name):\n        if obj == None:\n            raise Exception(\"Object cannot be null\")\n        if name == None:\n            raise Exception(\"Method name cannot be null\")\n\n        name = name.lower()\n\n        for method_name in dir(obj): \n            if method_name.lower() != name:\n                continue\n\n            method = getattr(obj, method_name)\n\n            if MethodReflector._is_method(method, method_name):\n                return True\n        \n        return False", "response": "Checks if an object has a method with specified name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef invoke_method(obj, name, *args):\n        if obj == None:\n            raise Exception(\"Object cannot be null\")\n        if name == None:\n            raise Exception(\"Method name cannot be null\")\n        \n        name = name.lower()\n        \n        try:\n            for method_name in dir(obj): \n                if method_name.lower() != name:\n                    continue\n\n                method = getattr(obj, method_name)\n\n                if MethodReflector._is_method(method, method_name):\n                    return method(*args)\n        except:\n            pass\n        \n        return None", "response": "Invoke an object method by its name with specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget names of all methods implemented in specified object.", "response": "def get_method_names(obj):\n        \"\"\"\n        Gets names of all methods implemented in specified object.\n\n        :param obj: an object to introspect.\n\n        :return: a list with method names.\n        \"\"\"\n        method_names = []\n        \n        for method_name in dir(obj):\n\n            method = getattr(obj, method_name)\n\n            if MethodReflector._is_method(method, method_name):\n                method_names.append(method_name)\n\n        return method_names"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unpack_kinesis_event(kinesis_event, deserializer=None, unpacker=None,\n                         embed_timestamp=False):\n    \"\"\"Extracts events (a list of dicts) from a Kinesis event.\"\"\"\n    records = kinesis_event[\"Records\"]\n    events = []\n    shard_ids = set()\n    for rec in records:\n        data = rec[\"kinesis\"][\"data\"]\n        try:\n            payload = b64decode(data)\n        except TypeError:\n            payload = b64decode(data.encode(\"utf-8\"))\n        if unpacker:\n            payload = unpacker(payload)\n        shard_ids.add(rec[\"eventID\"].split(\":\")[0])\n\n        try:\n            payload = payload.decode()\n        except AttributeError:\n            pass\n\n        if deserializer:\n            try:\n                payload = deserializer(payload)\n            except ValueError:\n                try:\n                    payload = deserializer(payload.replace(\"\\\\'\", \"'\"))\n                except:\n                    logger.error(\"Invalid searialized payload: {}\".format(\n                        payload))\n                    raise\n\n        if isinstance(payload, dict) and embed_timestamp:\n            ts = rec[\"kinesis\"].get(\"approximateArrivalTimestamp\")\n            if ts:\n                ts = datetime.fromtimestamp(ts, tz=tz.tzutc())\n                ts_str = (\"{year:04d}-{month:02d}-{day:02d} \"\n                          \"{hour:02d}:{minute:02d}:{second:02d}\").format(\n                    year=ts.year,\n                    month=ts.month,\n                    day=ts.day,\n                    hour=ts.hour,\n                    minute=ts.minute,\n                    second=ts.second)\n            else:\n                ts_str = \"\"\n\n            payload[embed_timestamp] = ts_str\n        events.append(payload)\n\n    if len(shard_ids) > 1:\n        msg = \"Kinesis event contains records from several shards: {}\".format(\n            shard_ids)\n        raise(BadKinesisEventError(msg))\n\n    return events, shard_ids.pop()", "response": "Extracts events from a Kinesis event."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend a list of events to a Firehose delivery stream.", "response": "def send_to_delivery_stream(events, stream_name):\n    \"\"\"Sends a list of events to a Firehose delivery stream.\"\"\"\n    if not events:\n        logger.info(\"No events provided: nothing delivered to Firehose\")\n        return\n\n    records = []\n    for event in events:\n        if not isinstance(event, str):\n            # csv events already have a newline\n            event = json.dumps(event) + \"\\n\"\n        records.append({\"Data\": event})\n    firehose = boto3.client(\"firehose\")\n    logger.info(\"Delivering %s records to Firehose stream '%s'\",\n                len(records), stream_name)\n    resp = firehose.put_record_batch(\n        DeliveryStreamName=stream_name,\n        Records=records)\n    return resp"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_to_kinesis_stream(events, stream_name, partition_key=None,\n                           packer=None, serializer=json.dumps):\n    \"\"\"Sends events to a Kinesis stream.\"\"\"\n    if not events:\n        logger.info(\"No events provided: nothing delivered to Firehose\")\n        return\n\n    records = []\n    for event in events:\n        if not partition_key:\n            partition_key_value = str(uuid.uuid4())\n        elif hasattr(partition_key, \"__call__\"):\n            partition_key_value = partition_key(event)\n        else:\n            partition_key_value = partition_key\n\n        if not isinstance(event, str):\n            event = serializer(event)\n\n        if packer:\n            event = packer(event)\n\n        record = {\"Data\": event,\n                  \"PartitionKey\": partition_key_value}\n        records.append(record)\n\n    kinesis = boto3.client(\"kinesis\")\n    resp = kinesis.put_records(StreamName=stream_name, Records=records)\n    return resp", "response": "Sends events to a Kinesis stream."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating a given value against this rule.", "response": "def validate(self, path, schema, value, results):\n        \"\"\"\n        Validates a given value against this rule.\n\n        :param path: a dot notation path to the value.\n\n        :param schema: a schema this rule is called from\n\n        :param value: a value to be validated.\n\n        :param results: a list with validation results to add new results.\n        \"\"\"\n        if self._rules == None:\n            return\n\n        for rule in self._rules:\n            rule.validate(path, schema, value, results)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates pairs where the first element is an item from the iterable and the second is a boolean flag indicating if the last item in the sequence is the last item in the sequence.", "response": "def iter_islast(iterable):\n    \"\"\"Generate (item, islast) pairs for an iterable.\n\n    Generates pairs where the first element is an item from the iterable\n    source and the second element is a boolean flag indicating if it is\n    the last item in the sequence.\n    \"\"\"\n    it = iter(iterable)\n    prev = next(it)\n    for item in it:\n        yield prev, False\n        prev = item\n    yield prev, True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef init_app(self, app):\n        app.url_rule_class = partial(NavigationRule, copilot=self)\n        app.context_processor(self.inject_context)", "response": "Register the extension with the application."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dict used for a template context.", "response": "def inject_context(self):\n        \"\"\"Return a dict used for a template context.\"\"\"\n        navbar = filter(lambda entry: entry.visible, self.navbar_entries)\n        return {'navbar': navbar}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register_entry(self, navbar_kwargs):\n        # Add a new rule for each level in the path.\n        path = navbar_kwargs.pop('path')\n        # If a single object is used rather than an iterable (including\n        # a single string), wrap it before using.\n        if not hasattr(path, '__iter__') or isinstance(path, basestring):\n            path = [path]\n\n        entry_group = self.navbar_entries\n        # HACK: I'd like to intelligently replace the URL rule in the\n        # case where the intended rule is provided, but the function has\n        # already created a blank \"placeholder\" rule for it. There are\n        # probably nicer ways to approach this, but it works.\n        for name, is_last in iter_islast(path):\n            kwargs = deepcopy(navbar_kwargs)\n            kwargs['name'] = name\n            for existing_entry in entry_group:\n                # If there's an existing entry for this \"link\", use it\n                # instead of creating a new one. If this existing entry\n                # has no rule and this is the last item in ``path``, the\n                # rule was intended to be assigned to this entry, so\n                # overwrite the blank rule with the one provided via\n                # ``navbar_kwargs``.\n                if existing_entry.name == name:\n                    entry = existing_entry\n                    if is_last:\n                        entry.endpoint = kwargs['endpoint']\n                    break\n            else:\n                # If we can't find an existing entry, create one with a\n                # blank endpoint. If this rule is not the final one in\n                # the list, the endpoint was not intended for this, so\n                # don't assign it.\n                if not is_last:\n                    kwargs['endpoint'] = None\n                entry = NavbarEntry(**kwargs)\n                entry_group.add(entry)\n            entry_group = entry.children", "response": "Register a new navbar entry with the copilot."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a packed version of the current object.", "response": "def packed(self):\n        \"\"\"\n        each row is placed side-by-side with the length of the row interlaced\n        the head of the packed matrix contains offsets to this length\n        e.g. [[11, 22, 33], [44, 55], []] => [3, 7, 10, 3, 11, 22, 33, 2, 44, 55, 0]\n        \"\"\"\n        # not the most efficient implementation atm but whatever\n        n_rows = len(self)\n        size = len(self)*2 + self.n_edges\n        packed = numpy.empty(size, self.dtype)\n        offset = n_rows\n        for r, row in enumerate(self):\n            packed[r] = offset\n            n_edges = len(row)\n            packed[offset] = n_edges\n            packed[(offset+1):(offset+1+n_edges)] = numpy.fromiter(row,\n                                                                   self.dtype)\n            offset += 1 + n_edges\n        return packed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reversed(self):\n        n_rows = len(self)\n        reversed = DirectedAdjacencyMatrix(n_rows, self.dtype)\n        for r, row in enumerate(py.prog_iter(self)):\n            for c in row:\n                reversed[c].append(r)\n                \n        return reversed", "response": "Create a connectivity matrix where each incoming edge becomes outgoing."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nidentifies user by token.", "response": "async def identify(self, request):\n        \"\"\" \u4ecerequest\u4e2d\u5f97\u5230\u767b\u5f55\u8eab\u4efdidentity \"\"\"\n        if hasattr(request, '_session_identity'):\n            return request._session_identity\n\n        token = request.cookies.get(self._cookie_name)\n        if token is None:\n            token = getAuthorizationTokenFromHeader(request)\n            if token is None:\n                raise Unauthorized('\u65e0\u8ba4\u8bc1\u8eab\u4efd')\n\n        identity = await self.decode_jwt(token)\n        setattr(request, '_session_identity', identity)\n\n        # if identity.client_id.startsWith('spa|'):\n        #     checkCRSFToken(request)\n\n        return identity"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef crc7(data):\n    crc = 0\n\n    for c in data:\n        crc = CRC7_TABLE[crc ^ c]\n\n    return crc", "response": "Compute CRC of a whole message."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles input events that weren t handled anywhere else.", "response": "def _unhandledInput(event, workbench, launcher):\n    \"\"\"Handles input events that weren't handled anywhere else.\n\n    \"\"\"\n    if event == \"ctrl w\":\n        raise urwid.ExitMainLoop()\n    elif event == \"esc\":\n        workbench.clear()\n        workbench.display(launcher)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndisplaying the pop - up and returns a deferred that fires when that fires.", "response": "def _runPopUp(workbench, popUp):\n    \"\"\"Displays the pop-up on the workbench and gets a completion\n    notification deferred. When that fires, undisplay the pop-up and\n    return the result of the notification deferred verbatim.\n\n    \"\"\"\n    workbench.display(popUp)\n\n    d = popUp.notifyCompleted()\n    d.addCallback(_popUpCompleted, workbench)\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndisplaying the given tool above the current layer and sets the title to its name.", "response": "def display(self, tool):\n        \"\"\"Displays the given tool above the current layer, and sets the\n        title to its name.\n\n        \"\"\"\n        self._tools.append(tool)\n        self._justDisplay(tool)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisplaying the given tool. Does not register it in the tools list.", "response": "def _justDisplay(self, tool):\n        \"\"\"\n        Displays the given tool. Does not register it in the tools list.\n        \"\"\"\n        self.header.title.set_text(tool.name)\n\n        body, _options = self.widget.contents[\"body\"]\n        overlay = urwid.Overlay(tool.widget, body, *tool.position)\n        self._surface = urwid.AttrMap(overlay, \"foreground\")\n        self.widget.contents[\"body\"] = self._surface, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef undisplay(self):\n        self._tools.pop()\n        self._justClear()\n        for tool in self._tools:\n            self._justDisplay(tool)", "response": "Undisplays the top tool."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _makeExtraWidgets(self):\n        self.textWidget = urwid.Text(self.text)\n        return [self.textWidget]", "response": "Makes a text widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake buttons and wires them up.", "response": "def _makeButtons(self):\n        \"\"\"Makes buttons and wires them up.\n\n        \"\"\"\n        self.button = button = urwid.Button(u\"OK\")\n        urwid.connect_signal(button, \"click\", self._completed)\n        return [self.button]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _makeTextWidgets(self):\n        self.textWidget = urwid.Text(self.text)\n        return [self.textWidget]", "response": "Makes a text widget."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking an editable prompt widget.", "response": "def _makeTextWidgets(self):\n        \"\"\"Makes an editable prompt widget.\n\n        \"\"\"\n        self.prompt = urwid.Edit(self.promptText, multiline=False)\n        return [self.prompt]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _secrets_table_name(environment=None, stage=None):\n    if environment is None:\n        environment = os.environ.get(\"HUMILIS_ENVIRONMENT\")\n\n    if stage is None:\n        stage = os.environ.get(\"HUMILIS_STAGE\")\n\n    if environment:\n        if stage:\n            return \"{environment}-{stage}-secrets\".format(**locals())\n        else:\n            return \"{environment}-secrets\".format(**locals())", "response": "Returns the name of the secrets table associated to a humilis deployment."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _state_table_name(environment=None, layer=None, stage=None):\n    if environment is None:\n        # For backwards compatiblity\n        environment = os.environ.get(\"HUMILIS_ENVIRONMENT\")\n    if layer is None:\n        layer = os.environ.get(\"HUMILIS_LAYER\")\n\n    if stage is None:\n        stage = os.environ.get(\"HUMILIS_STAGE\")\n\n    if environment:\n        if stage:\n            return \"{environment}-{layer}-{stage}-state\".format(\n                **locals())\n        else:\n            return \"{environment}-{layer}-state\".format(**locals())", "response": "Returns the name of the state table associated to a humilis deployment."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_secret_from_vault(\n        key, environment=None, stage=None, namespace=None,\n        wait_exponential_multiplier=50, wait_exponential_max=5000,\n        stop_max_delay=10000):\n    \"\"\"Retrieves a secret from the secrets vault.\"\"\"\n    # Get the encrypted secret from DynamoDB\n    table_name = _secrets_table_name(environment=environment, stage=stage)\n\n    if namespace:\n        key = \"{}:{}\".format(namespace, key)\n\n    if table_name is None:\n        logger.warning(\"Can't produce secrets table name: unable to retrieve \"\n                       \"secret '{}'\".format(key))\n        return\n\n    client = boto3.client('dynamodb')\n    logger.info(\"Retriving key '{}' from table '{}'\".format(\n        key, table_name))\n\n    @retry(retry_on_exception=_is_critical_exception,\n           wait_exponential_multiplier=wait_exponential_multiplier,\n           wait_exponential_max=wait_exponential_max,\n           stop_max_delay=stop_max_delay)\n    def get_item():\n        try:\n            return client.get_item(\n                TableName=table_name,\n                Key={'id': {'S': key}}).get('Item', {}).get(\n                    'value', {}).get('B')\n        except Exception as err:\n            if _is_dynamodb_critical_exception(err):\n                raise CriticalError(err)\n            else:\n                raise\n\n    encrypted = get_item()\n\n    if encrypted is None:\n        return\n\n    # Decrypt using KMS\n    client = boto3.client('kms')\n    try:\n        value = client.decrypt(CiphertextBlob=encrypted)['Plaintext'].decode()\n    except ClientError:\n        logger.error(\"KMS error when trying to decrypt secret\")\n        traceback.print_exc()\n        return\n\n    try:\n        value = json.loads(value)\n    except (TypeError, ValueError):\n        # It's ok, the client should know how to deal with the value\n        pass\n\n    return value", "response": "Retrieves a secret from the secrets vault."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a secret from the environment variable or from vault.", "response": "def get_secret(key, *args, **kwargs):\n    \"\"\"Retrieves a secret.\"\"\"\n    env_value = os.environ.get(key.replace('.', '_').upper())\n    if not env_value:\n        # Backwards compatibility: the deprecated secrets vault\n        return _get_secret_from_vault(key, *args, **kwargs)\n    return env_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_state(key, namespace=None, table_name=None, environment=None,\n              layer=None, stage=None, shard_id=None, consistent=True,\n              deserializer=json.loads, wait_exponential_multiplier=500,\n              wait_exponential_max=5000, stop_max_delay=10000):\n    \"\"\"Get Lambda state value(s).\"\"\"\n    if table_name is None:\n        table_name = _state_table_name(environment=environment, layer=layer,\n                                       stage=stage)\n\n    if not table_name:\n        msg = (\"Can't produce state table name: unable to get state \"\n               \"item '{}'\".format(key))\n        logger.error(msg)\n        raise StateTableError(msg)\n        return\n\n    dynamodb = boto3.resource(\"dynamodb\")\n    table = dynamodb.Table(table_name)\n    logger.info(\"Getting key '{}' from table '{}'\".format(key, table_name))\n    if namespace:\n        key = \"{}:{}\".format(namespace, key)\n\n    if shard_id:\n        key = \"{}:{}\".format(shard_id, key)\n\n    @retry(retry_on_exception=_is_critical_exception,\n           wait_exponential_multiplier=wait_exponential_multiplier,\n           wait_exponential_max=wait_exponential_max,\n           stop_max_delay=stop_max_delay)\n    def get_item():\n        try:\n            return table.get_item(\n                Key={\"id\": key}, ConsistentRead=consistent).get(\n                    \"Item\", {}).get(\"value\")\n        except Exception as err:\n            if _is_dynamodb_critical_exception(err):\n                raise CriticalError(err)\n            else:\n                raise\n\n    value = get_item()\n\n    if not value:\n        return\n\n    if deserializer:\n        try:\n            value = deserializer(value)\n        except ValueError:\n            # For backwards compatibility: plain strings are allowed\n            logger.error(\"Unable to json-deserialize value '{}'\".format(value))\n            return value\n\n    return value", "response": "Get Lambda state value for a specific key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_state_batch(keys, namespace=None, consistent=True):\n\n    ukeys = set(keys)\n\n    if namespace:\n        ns_keys = [\"{}:{}\".format(namespace, key) for key in ukeys]\n\n    uvalues = {k: v for k, v\n               in zip(ukeys, get_item_batch(ns_keys, consistent=consistent))}\n    return list(zip(keys, (uvalues[k] for k in keys)))", "response": "Get a batch of items from the state store."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_state_batch(keys, values, namespace=None, ttl=3600*24*365):\n\n    keys, values = zip(*{k: v for k, v in zip(keys, values)}.items())\n\n    if namespace:\n        keys = [\"{}:{}\".format(namespace, key) for key in keys]\n\n    return set_item_batch(keys, values, ttl)", "response": "Set a batch of items in the state store."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_state(key, value, namespace=None, table_name=None, environment=None,\n              layer=None, stage=None, shard_id=None, consistent=True,\n              serializer=json.dumps, wait_exponential_multiplier=500,\n              wait_exponential_max=5000, stop_max_delay=10000, ttl=None):\n    \"\"\"Set Lambda state value.\"\"\"\n    if table_name is None:\n        table_name = _state_table_name(environment=environment, layer=layer,\n                                       stage=stage)\n\n    if not table_name:\n        msg = (\"Can't produce state table name: unable to set state \"\n               \"item '{}'\".format(key))\n        logger.error(msg)\n        raise StateTableError(msg)\n        return\n\n    dynamodb = boto3.resource(\"dynamodb\")\n    table = dynamodb.Table(table_name)\n    logger.info(\"Putting {} -> {} in DynamoDB table {}\".format(key, value,\n                                                               table_name))\n    if serializer:\n        try:\n            value = serializer(value)\n        except TypeError:\n            logger.error(\n                \"Value for state key '{}' is not json-serializable\".format(\n                    key))\n            raise\n\n    if namespace:\n        key = \"{}:{}\".format(namespace, key)\n\n    if shard_id:\n        key = \"{}:{}\".format(shard_id, key)\n\n    item = {\"id\": key, \"value\": value}\n    if ttl:\n        item[\"ttl\"] = {\"N\": str(int(time.time() + ttl))}\n    @retry(retry_on_exception=_is_critical_exception,\n           wait_exponential_multiplier=500,\n           wait_exponential_max=5000,\n           stop_max_delay=10000)\n    def put_item():\n        try:\n            return table.put_item(Item=item)\n        except Exception as err:\n            if _is_dynamodb_critical_exception(err):\n                raise CriticalError(err)\n            else:\n                raise\n\n    resp = put_item()\n\n    logger.info(\"Response from DynamoDB: '{}'\".format(resp))\n    return resp", "response": "Set Lambda state value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete Lambda state value.", "response": "def delete_state(key, namespace=None, table_name=None, environment=None,\n                 layer=None, stage=None, shard_id=None, consistent=True,\n                 wait_exponential_multiplier=500,\n                 wait_exponential_max=5000, stop_max_delay=10000):\n    \"\"\"Delete Lambda state value.\"\"\"\n    if table_name is None:\n        table_name = _state_table_name(environment=environment, layer=layer,\n                                       stage=stage)\n\n    if not table_name:\n        msg = (\"Can't produce state table name: unable to set state \"\n               \"item '{}'\".format(key))\n        logger.error(msg)\n        raise StateTableError(msg)\n        return\n\n    dynamodb = boto3.resource(\"dynamodb\")\n    table = dynamodb.Table(table_name)\n    logger.info(\"Deleting {} in DynamoDB table {}\".format(key, table_name))\n\n    if namespace:\n        key = \"{}:{}\".format(namespace, key)\n\n    if shard_id:\n        key = \"{}:{}\".format(shard_id, key)\n\n    @retry(retry_on_exception=_is_critical_exception,\n           wait_exponential_multiplier=500,\n           wait_exponential_max=5000,\n           stop_max_delay=10000)\n    def delete_item():\n        try:\n            return table.delete_item(Key={\"id\": key})\n        except Exception as err:\n            if _is_dynamodb_critical_exception(err):\n                raise CriticalError(err)\n            else:\n                raise\n\n    resp = delete_item()\n\n    logger.info(\"Response from DynamoDB: '{}'\".format(resp))\n    return resp"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_context(namespace, context_id):\n    context_obj = get_state(context_id, namespace=namespace)\n    if not context_obj:\n        raise ContextError(\"Context '{}' not found in namespace '{}'\".format(\n            context_id, namespace))\n    return context_obj", "response": "Get stored context object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef arrival_delay_greater_than(item_id, delay, namespace=\"_expected_arrival\"):\n    expected = get_state(item_id, namespace=namespace)\n    now = time.time()\n    if expected and (now - expected) > delay:\n        logger.error(\"Timeout: waited %s seconds for parent.\", delay)\n        return True\n    elif expected:\n        logger.info(\"Still out of order but no timeout: %s-%s <= %s.\",\n                    now, expected, delay)\n        return False\n    elif delay > 0:\n        logger.info(\"Storing expected arrival time (%s) for context '%s'\",\n                    datetime.fromtimestamp(now).isoformat(), item_id)\n        set_state(item_id, now, namespace=namespace)\n        return False\n    else:\n        logger.info(\"Event is out of order but not waiting for parent.\")\n        return True", "response": "Check if an item arrival is delayed more than a given amount."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bin2hexline(data, add_addr=True, width=16):\n    data = bytearray(data)\n\n    # same as string.printable but without \\t\\n\\r\\v\\f ;)\n    printable = string.digits + string.ascii_letters + string.punctuation + \" \"\n\n    addr = 0\n    lines = []\n    run = True\n    line_width = 4 + (width * 3) + 1\n    while run:\n        if add_addr:\n            line = [\"%04i\" % addr]\n        else:\n            line = []\n\n        ascii_block = \"\"\n        for i in range(width):\n            b = data[addr]\n\n            if chr(b) in printable:\n                ascii_block += chr(b)\n            else:\n                ascii_block += \".\"\n\n            line.append(\"%02x\" % b)\n\n            addr += 1\n            if addr >= len(data):\n                run = False\n                break\n\n        line = \" \".join(line)\n        line = line.ljust(line_width)\n        line += ascii_block\n        lines.append(line)\n    return lines", "response": "Convert binary data to a Hex - Editor like format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(name, stype, **kwargs):\n    stype = str(stype)\n\n    params = {}\n    if stype in MPLS_STYPES:\n        params.update(__get(name, stype, **kwargs))\n    else:\n        raise ValueError('unexpected stype: {}! Must be any of {!r}'.format(stype, MPLS_STYPES))\n\n    # color palette hack\n    if params.get('axes.prop_cycle'):\n        params['axes.prop_cycle'] = mpl.rcsetup.cycler('color', params['axes.prop_cycle'])\n\n    return params", "response": "Returns the rcParams dict for the specified style file given by name and stype."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef collect(context=None, style=None, palette=None, **kwargs):\n    params = {}\n    if context:\n        params.update(get(context, 'context', **kwargs))\n    if style:\n        params.update(get(style, 'style', **kwargs))\n    if palette:\n        params.update(get(palette, 'palette', **kwargs))\n    return params", "response": "Returns the merged rcParams dict of the specified context style and palette."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef str_to_num(i, exact_match=True):\n    # TODO: Cleanup -- this is really ugly\n    if not isinstance(i, str):\n        return i\n    try:\n        if not exact_match:\n            return int(i)\n        elif str(int(i)) == i:\n            return int(i)\n        elif str(float(i)) == i:\n            return float(i)\n        else:\n            pass\n    except ValueError:\n        pass\n    return i", "response": "Converts a str to an int or float depending on whether it is an int or float."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking an HTML link out of an URL.", "response": "def make_link(title, url, blank=False):\n\t\"\"\"\n\tMake a HTML link out of an URL.\n\n\tArgs:\n\t  title (str): Text to show for the link.\n\t  url (str): URL the link will point to.\n\t  blank (bool): If True, appends target=_blank, noopener and noreferrer to\n\t    the <a> element. Defaults to False.\n\t\"\"\"\n\tattrs = 'href=\"%s\"' % url\n\tif blank:\n\t\tattrs += ' target=\"_blank\" rel=\"noopener noreferrer\"'\n\treturn '<a %s>%s</a>' % (attrs, title)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the URL of an asset.", "response": "def get_asset_url(self, path):\n\t\t\"\"\"\n\t\tGet the URL of an asset. If asset hashes are added and one exists for\n\t\tthe path, it will be appended as a query string.\n\n\t\tArgs:\n\t\t  path (str): Path to the file, relative to your \"assets\" directory.\n\t\t\"\"\"\n\t\turl = self.root_url + '/assets/' + path\n\t\tif path in self.asset_hash:\n\t\t\turl += '?' + self.asset_hash[path]\n\t\treturn url"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds all markdown files in a directory and add them as pages.", "response": "def add_pages(self, path='pages'):\n\t\t\"\"\"\n\t\tLook through a directory for markdown files and add them as pages.\n\t\t\"\"\"\n\t\tpages_path = os.path.join(self.root_path, path)\n\t\tpages = []\n\t\tfor file in _listfiles(pages_path):\n\t\t\tpage_dir = os.path.relpath(os.path.dirname(file), pages_path)\n\t\t\tif page_dir == '.':\n\t\t\t\tpage_dir = None\n\t\t\tpages.append(self.cm.Page.from_file(file, directory=page_dir))\n\t\tself.cm.add_pages(pages)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_posts(self, path='posts'):\n\t\tpath = os.path.join(self.root_path, path)\n\t\tself.cm.add_posts([\n\t\t\tself.cm.Post.from_file(file)\n\t\t\tfor file in _listfiles(path)\n\t\t])", "response": "Add posts from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncopies assets into the destination directory.", "response": "def copy_assets(self, path='assets'):\n\t\t\"\"\"\n\t\tCopy assets into the destination directory.\n\t\t\"\"\"\n\t\tpath = os.path.join(self.root_path, path)\n\t\tfor root, _, files in os.walk(path):\n\t\t\tfor file in files:\n\t\t\t\tfullpath = os.path.join(root, file)\n\t\t\t\trelpath = os.path.relpath(fullpath, path)\n\t\t\t\tcopy_to = os.path.join(self._get_dist_path(relpath, directory='assets'))\n\t\t\t\tLOG.debug('copying %r to %r', fullpath, copy_to)\n\t\t\t\tshutil.copyfile(fullpath, copy_to)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_asset_hashes(self, path='dist/assets'):\n\t\tfor fullpath in _listfiles(os.path.join(self.root_path, path)):\n\t\t\trelpath = fullpath.replace(self.root_path + '/' + path + '/', '')\n\t\t\tmd5sum = hashlib.md5(open(fullpath, 'rb').read()).hexdigest()\n\t\t\tLOG.debug('MD5 of %s (%s): %s', fullpath, relpath, md5sum)\n\t\t\tself.asset_hash[relpath] = md5sum", "response": "Add hashes for each file found in a directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all the posts added to the blog.", "response": "def get_posts(self, num=None, tag=None, private=False):\n\t\t\"\"\"\n\t\tGet all the posts added to the blog.\n\n\t\tArgs:\n\t\t  num (int): Optional. If provided, only return N posts (sorted by date,\n\t\t    most recent first).\n\t\t  tag (Tag): Optional. If provided, only return posts that have a\n\t\t    specific tag.\n\t\t  private (bool): By default (if False), private posts are not included.\n\t\t    If set to True, private posts will also be included.\n\t\t\"\"\"\n\t\tposts = self.posts\n\n\t\tif not private:\n\t\t\tposts = [post for post in posts if post.public]\n\n\t\tif tag:\n\t\t\tposts = [post for post in posts if tag in post.tags]\n\n\t\tif num:\n\t\t\treturn posts[:num]\n\t\treturn posts"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_pages(self):\n\t\tfor page in self.pages:\n\t\t\tself.generate_page(page.slug, template='page.html.jinja', page=page)", "response": "Generate HTML out of the pages added to the blog."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate one HTML page for each tag that contains all posts that thatmatch that tag.", "response": "def generate_tags(self):\n\t\t\"\"\"\n\t\tGenerate one HTML page for each tag, each containing all posts that\n\t\tmatch that tag.\n\t\t\"\"\"\n\t\tfor tag in self.tags:\n\t\t\tposts = self.get_posts(tag=tag, private=True)\n\t\t\tself.generate_page(['tags', tag.slug],\n\t\t\t\ttemplate='archive.html.jinja', posts=posts)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_page(self, path, template, **kwargs):\n\t\tdirectory = None\n\t\tif kwargs.get('page'):\n\t\t\tdirectory = kwargs['page'].dir\n\n\t\tpath = self._get_dist_path(path, directory=directory)\n\t\tif not path.endswith('.html'):\n\t\t\tpath = path + '.html'\n\n\t\tif not os.path.isdir(os.path.dirname(path)):\n\t\t\tos.makedirs(os.path.dirname(path))\n\n\t\thtml = self._get_template(template).render(**kwargs)\n\n\t\twith open(path, 'w+') as file:\n\t\t\tfile.write(html)", "response": "Generate the HTML for a single page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating the front page aka index. html.", "response": "def generate_index(self, num_posts=5):\n\t\t\"\"\"\n\t\tGenerate the front page, aka index.html.\n\t\t\"\"\"\n\t\tposts = self.get_posts(num=num_posts)\n\t\tself.generate_page('index', template='index.html.jinja', posts=posts)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_rss(self, path='rss.xml', only_excerpt=True, https=False):\n\t\tfeed = russell.feed.get_rss_feed(self, only_excerpt=only_excerpt, https=https)\n\t\tfeed.rss_file(self._get_dist_path(path))", "response": "Generate the RSS feed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating an XML sitemap.", "response": "def generate_sitemap(self, path='sitemap.xml', https=False):\n\t\t\"\"\"\n\t\tGenerate an XML sitemap.\n\n\t\tArgs:\n\t\t  path (str): The name of the file to write to.\n\t\t  https (bool): If True, links inside the sitemap with relative scheme\n\t\t    (e.g. example.com/something) will be set to HTTPS. If False (the\n\t\t    default), they will be set to plain HTTP.\n\t\t\"\"\"\n\t\tsitemap = russell.sitemap.generate_sitemap(self, https=https)\n\t\tself.write_file(path, sitemap)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting a file to the destination path.", "response": "def write_file(self, path, contents):\n\t\t\"\"\"\n\t\tWrite a file of any type to the destination path. Useful for files like\n\t\trobots.txt, manifest.json, and so on.\n\n\t\tArgs:\n\t\t  path (str): The name of the file to write to.\n\t\t  contents (str or bytes): The contents to write.\n\t\t\"\"\"\n\t\tpath = self._get_dist_path(path)\n\t\tif not os.path.isdir(os.path.dirname(path)):\n\t\t\tos.makedirs(os.path.dirname(path))\n\t\tif isinstance(contents, bytes):\n\t\t\tmode = 'wb+'\n\t\telse:\n\t\t\tmode = 'w'\n\t\twith open(path, mode) as file:\n\t\t\tfile.write(contents)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_auth(username, password):\n\n    with open(os.path.expanduser(\"~/config/.note.conf\")) as fd:\n        config = json.loads(fd.read())\n\n    try:\n        u = config['server']['login']['username']\n        p = config['server']['login']['password']\n    except KeyError:\n        print \"cannot start server\"\n        sys.exit(1)\n\n    return username == u and password == p", "response": "This function is called to check if a username and password combination is valid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enable_travis(token, slug, log):\n\n    # Done with github directly. Login to travis\n\n    travis = TravisPy.github_auth(token, uri='https://api.travis-ci.org')\n    user = travis.user()\n    log.info('Travis user: %s', user.name)\n\n    # Ask travis to sync with github, try to fetch created repo with exponentially decaying time.\n\n    last_sync = user.synced_at\n    log.info('syncing Travis with Github, this can take a while...')\n    repo = travis._session.post(travis._session.uri+'/users/sync')\n    for i in range(10):\n        try:\n            sleep((1.5)**i)\n            repo = travis.repo(slug)\n            if travis.user().synced_at == last_sync:\n                raise ValueError('synced not really done, travis.repo() can be a duplicate')\n            log.info('\\nsyncing done')\n            break\n        # TODO: find the right exception here\n        except Exception:\n            pass\n    ## todo , warn if not found\n\n\n    #  Enable travis hook for this repository\n\n    log.info('Enabling Travis-CI hook for this repository')\n    resp = travis._session.put(travis._session.uri+\"/hooks/\",\n                        json={\n                            \"hook\": {\n                                \"id\": repo.id ,\n                                \"active\": True\n                            }\n                        },\n                      )\n    if resp.json()['result'] is True:\n        log.info('Travis hook for this repository is now enabled.')\n        log.info('Continuous integration test should be triggered every time you push code to github')\n    else:\n        log.info(\"I was not able to set up Travis hooks... something went wrong.\")\n\n    return user", "response": "Enable Travis automatically for the given repo."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef project_layout(proposal, user=None, repo=None, log=None):\n\n    proposal = proposal.lower()\n\n    #context_file = os.path.expanduser('~/.cookiecutters/cookiecutter-pypackage/cookiecutter.json')\n    #context = generate_context(context_file)\n\n    # os.chdir('..')\n    # context['cookiecutter']['full_name'] = user.name\n    # context['cookiecutter']['email'] = user.email\n    # context['cookiecutter']['github_username'] = user.login\n    # context['cookiecutter']['project_name'] = proposal\n    # context['cookiecutter']['repo_name'] = proposal.lower()\n\n    try:\n        os.mkdir(proposal)\n    except FileExistsError:\n        log.info('Skip directory structure, as project seem to already exists')\n\n    with open('.gitignore', 'w') as f:\n        f.write('''\n*.pyc\n__pycache__\n/build/\n/dist/\n''')\n\n    with open( '/'.join([proposal, '__init__.py']), 'w') as f: \n        f.write('''\n\"\"\"\na simple package\n\"\"\"\n\n\n__version__ = '0.0.1'\n\n        ''')\n\n\n    travis_yml()\n\n    #generate_files(\n    #        repo_dir=os.path.expanduser('~/.cookiecutters/cookiecutter-pypackage/'),\n    #        context=context\n    #    )\n\n    log.info('Workig in %s', os.getcwd())\n    os.listdir('.')\n\n    subprocess.call(['git','add','.'], )\n\n    subprocess.call(['git','commit',\"-am'initial commit of %s'\" % proposal])\n\n    subprocess.call(['git', \"push\", \"origin\", \"master:master\"])", "response": "Generate the project template and generate the project structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef SetProp(self, prop, value, score=None):\n        if score:\n            self.scores[prop] = value\n        else:\n            if prop == 'id':\n                self.id = value\n            elif prop == 'status':\n                self.status = value\n            elif prop == 'bm':\n                self.bm = format(value)\n            elif prop == 'graph':\n                self.graph = format(value)\n            else:\n                self.properties[prop] = value", "response": "Set the value of a property in the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef GetProp(self, prop):\n\n        if prop == 'scores':\n            return [x[1] for x in self.scores.items()]\n        elif prop:\n            if prop == 'id':\n                return self.id\n            elif prop == 'status':\n                return self.status\n            elif prop == 'bm':\n                return self.bm\n            elif prop == 'graph':\n                return self.graph\n            elif prop in self.scores.keys():\n                return self.scores[prop]\n            elif prop in self.properties.keys():\n                return self.properties[prop]\n            else:\n                return None", "response": "Get a property from the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a formatted string about the status of the given request.", "response": "def request_status(r, detailed=False):\n\t\"\"\"Returns a formatted string about the status, useful for logging.\n\t\n\targs:\n\tr - takes requests.models.Response\n\t\"\"\"\n\t\n\tbase_string = \"HTTP {r.request.method} {r.request.url}: {r.status_code}\"\n\t\n\tif r.status_code in range(200,99):\n\t\tstring = base_string\n\t\tif detailed is True:\n\t\t\tstring += \" - {r.json()}\"\n\t\telse:\n\t\t\tstring += \" - \ud83d\udc4d\"\n\t\treturn string.format(r=r)\n\telse:\n\t\tstring = base_string\n\t\treturn string.format(r=r)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scrubID(ID):\n\n    try:\n        if type(ID) == list:\n            return int(ID[0])\n        elif type(ID) == str:\n            return int(ID)\n        elif type(ID) == int:\n            return ID\n        elif type(ID) == unicode:\n            return int(ID)\n\n    except ValueError:\n        return None", "response": "Scrubs an ID that can be of various types"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if the binary exists False otherwise", "response": "def which(bin_name):\n    \"\"\"\n        :param bin_name: the name of the binary to test for (e.g. vim)\n        :returns: True or False depending on wether the binary exists\n    \"\"\"\n\n    with open(os.devnull) as devnull:\n        # rc = SP.call(['which', bin_name], stdout=devnull, stderr=devnull)\n        rc = SP.call(['which', bin_name])\n\n    return rc"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a databse user.", "response": "def create_db_user(username, password=None, flags=None):\n    \"\"\"Create a databse user.\"\"\"\n\n    flags = flags or u'-D -A -R'\n    sudo(u'createuser %s %s' % (flags, username), user=u'postgres')\n    if password:\n        change_db_user_password(username, password)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting remote psql query.", "response": "def excute_query(query, db=None, flags=None, use_sudo=False, **kwargs):\n    \"\"\"Execute remote psql query.\"\"\"\n\n    flags = flags or u''\n    if db:\n        flags = u\"%s -d %s\" % (flags, db)\n    command = u'psql %s -c \"%s\"' % (flags, query)\n    if use_sudo:\n        sudo(command, user='postgres', **kwargs)\n    else:\n        run(command, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the DB user already exists.", "response": "def db_user_exists(username):\n    \"\"\"Return True if the DB user already exists.\n    \"\"\"\n    qry = u\"\"\"SELECT COUNT(*) FROM pg_roles where rolname = \\'{username}\\';\"\"\"\n    output = StringIO()\n    excute_query(\n        qry.format(username=username),\n        flags=\"-Aqt\",\n        use_sudo=True,\n        stdout=output\n    )\n    # FIXME: is there a way to get fabric to not clutter the output\n    # with \"[127.0.0.1] out:\" on each line?\n    lines = output.getvalue().splitlines()\n    return lines and lines[0].endswith('out: 1')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging a db user s password.", "response": "def change_db_user_password(username, password):\n    \"\"\"Change a db user's password.\"\"\"\n\n    sql = \"ALTER USER %s WITH PASSWORD '%s'\" % (username, password)\n    excute_query(sql, use_sudo=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_db(name, owner=None, encoding=u'UTF-8', template='template1',\n              **kwargs):\n    \"\"\"Create a Postgres database.\"\"\"\n\n    flags = u''\n    if encoding:\n        flags = u'-E %s' % encoding\n    if owner:\n        flags = u'%s -O %s' % (flags, owner)\n    if template and template != 'template1':\n        flags = u'%s --template=%s' % (flags, template)\n    sudo('createdb %s %s' % (flags, name), user='postgres', **kwargs)", "response": "Create a Postgres database."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef upload_pg_hba_conf(template_name=None, pg_version=None, pg_cluster='main', restart=True):\n\n    template_name = template_name or u'postgres/pg_hba.conf'\n    version = pg_version or detect_version()\n    config = {'version': version, 'cluster': pg_cluster}\n    destination = u'/etc/postgresql/%(version)s/%(cluster)s/pg_hba.conf' % config\n    upload_template(template_name, destination, use_sudo=True)\n    if restart:\n        restart_service(u'postgresql')", "response": "Upload configuration for pg_hba. conf"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef detect_version():\n    version_regex = re.compile(r'\\(PostgreSQL\\) (?P<major>\\d)\\.(?P<minor>\\d)\\.(?P<bugfix>\\d)')\n    pg_version = None\n    with hide('running', 'stdout', 'stderr'):\n        output = run('psql --version')\n    match = version_regex.search(output)\n    if match:\n        result = match.groupdict()\n        if 'major' in result and 'minor' in result:\n            pg_version = u'%(major)s.%(minor)s' % result\n    if not pg_version:\n        abort(u\"Error: Could not determine Postgres version of the server.\")\n    return pg_version", "response": "Parse the output of psql to detect Postgres version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndropping and restore a given cluster.", "response": "def reset_cluster(pg_cluster='main', pg_version=None, encoding=u'UTF-8',\n                  locale=u'en_US.UTF-8'):\n    \"\"\"Drop and restore a given cluster.\"\"\"\n    warning = u'You are about to drop the %s cluster. This cannot be undone.' \\\n              u' Are you sure you want to continue?' % pg_cluster\n    if confirm(warning, default=False):\n        version = pg_version or detect_version()\n        config = {'version': version, 'cluster': pg_cluster,\n                  'encoding': encoding, 'locale': locale}\n        sudo(u'pg_dropcluster --stop %(version)s %(cluster)s' % config,\n             user='postgres', warn_only=True)\n        sudo(u'pg_createcluster --start -e %(encoding)s --locale %(locale)s'\n             u' %(version)s %(cluster)s' % config, user='postgres')\n    else:\n        abort(u\"Dropping %s cluster aborted by user input.\" % pg_cluster)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef require_request_model(cls, validate=True):\n    def decorator(handler):\n        async def new_handler(request, *args, **kwargs):\n            body = await request.json()\n            model = cls(**body)\n\n            if validate:\n                model.validate()\n\n            return await handler(request, model, *args, **kwargs)\n        return new_handler\n    return decorator", "response": "Decorator that requires that a request body that map towards the given\nTaxonomy model is provided."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef use_ws_subhandlers(handler):\n    async def new_handler(request, ws):\n        handlers = await handler(request, ws)\n        tasks = [request.app.loop.create_task(h(request, ws))\n                 for h in handlers]\n\n        try:\n            await asyncio.gather(*tasks)\n        finally:\n            for task in tasks:\n                task.cancel()\n\n            await ws.close()\n    return new_handler", "response": "A WS handler that returns any number of subhandlers that will be run in parallel."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_csv(csv_file, options, ensemble_list=None):\n    name, ext = os.path.splitext(csv_file)\n    try:\n        if ext == '.gz':\n            f = gzip.open(csv_file, 'rb')\n        else:\n            f = open(csv_file, 'rU')\n    except IOError:\n        print(\" \\n '{f}' could not be opened\\n\".format(f=os.path.basename(csv_file)))\n        sys.exit(1)\n\n\n    csv_reader = csv.reader(f)\n    molList = []\n    line_number = 1\n\n    for line in csv_reader:\n\n        if line_number == 1:\n            if ensemble_list:\n                prop_indices = read_header(line, options, ensemble_list)\n            else:\n                prop_indices = read_header(line, options)\n        else:\n            mol = Molecule()\n            if ensemble_list:\n                mol = read_line(line, options, prop_indices, mol, ensemble_list)\n            else:\n                mol = read_line(line, options, prop_indices, mol)\n            if mol == 1:\n                print(\" skipping molecule {m}\\n\".format(m=(line_number - 1)))\n            else:\n                molList.append(mol)\n        line_number += 1\n\n    return molList", "response": "Read a CSV file and return a list of Molecule objects."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_header(header_labels, options, ensemble_list=None):\n\n    # set input variables\n    filename = os.path.basename(options.inputpath)\n    if ensemble_list:\n        score_field = ensemble_list[0]\n        ensemble_size = len(ensemble_list)\n    else:\n        score_field = options.score_field\n        ensemble_size = options.ensemble_size\n\n\n    status_field = options.status_field\n\n    # check on score field values\n    if ensemble_list:\n        query_list = ensemble_list\n        # verify that the input queries are in the inputfille\n        if not [x for x in query_list if x in header_labels]:\n            out = ' '.join(query_list)\n            print(\"\\n '{q}' are not in '{e}'\\n\".format(q=out, e=os.path.basename(filename)))\n            sys.exit(1)\n    else:\n        score_field_matcher = re.compile(score_field)\n        query_list = [x for x in header_labels if score_field_matcher.match(x)]\n\n        if not query_list:\n            print(\"\\n There are no '{s}' columns in '{c}'\\n\".format(s=score_field, c=os.path.basename(filename)))\n            sys.exit(1)\n\n        # confirm that there are a sufficient no. of queries to generate\n        # the requested ensemble size\n        if len(query_list) < ensemble_size:\n            print(\"\\n '{s}' will support a maximum ensemble size of '{d}'\\n\".format(s=os.path.basename(filename),\n                                                                              d=len(query_list)))\n            sys.exit(1)\n\n    # confirm that status field exists\n    status_field_matcher = re.compile(status_field)\n    if not any(x for x in header_labels if status_field_matcher.match(x)):\n        print(\"\\n The status_field column '{s}' doesn't exist\\n\".format(s=status_field))\n        sys.exit(1)\n\n    # initiate prop_column dictionary and csv column index\n    prop_indices = {}\n    index = 0\n\n    for label in header_labels:\n        prop_indices[label] = index\n        index += 1\n\n    return prop_indices", "response": "read the header of the file and return the dictionary of properties"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a single line of a molecule", "response": "def read_line(csv_contents, options, prop_indices, mol, ensemble_list=None):\n    \"\"\"\n\tread csv line\n\t\"\"\"\n    if not ensemble_list:\n        score_field = options.score_field\n    status_field = options.status_field\n    active_label = options.active_label\n    decoy_label = options.decoy_label\n\n    # do the active/decoy labels have appropriate values?\n    active_value_matcher = re.compile(active_label)\n    decoy_value_matcher = re.compile(decoy_label)\n    status_label_index = prop_indices[status_field]\n\n    if not active_value_matcher.match(csv_contents[status_label_index]) and not decoy_value_matcher.match(\n            csv_contents[status_label_index]):\n        print(\"\\n molecule lacks appropriate status label\")\n        return 1\n\n    # are the score field values defined?\n    score_field_indices = []\n    if ensemble_list:\n        queryList = ensemble_list\n    else:\n        queryList = [x for x in prop_indices.keys() if score_field in x]\n    for query in queryList:\n        score_field_indices.append(prop_indices[query])\n    for value in [csv_contents[x] for x in score_field_indices]:\n        if value in ('', 'n/a', 'N/A', None):\n            print(\"\\n molecule lacks appropriate score field value\")\n            return 1\n\n    # loop over property values\n    for label in prop_indices.keys():\n\n        # get property value\n        value_index = prop_indices[label]\n        value = csv_contents[value_index]\n\n        # set corresponding molecule attribute\n        if label in queryList:\n            mol.SetProp(label, value, 'score')\n        else:\n            mol.SetProp(label, value)\n\n    # return mol\n    return mol"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef url(match, handler=None, methods=None, defaults=None,\n        redirect_to=None, build_only=False, name=None, **kwargs):\n    \"\"\"Simple helper for build a url, and return anillo\n    url spec hash map (dictionary)\n\n    It can be used in this way:\n\n    urls = [\n        url(\"/<int:year>\", index, methods=[\"get\", \"post\"]),\n        url(\"/<int:year>\", index, methods=[\"get\", \"post\"])\n    ]\n\n    This is a prefered way to define one url.\n\n    :return: The anillo url spec\n    :rtype: dict\n    \"\"\"\n    assert isinstance(match, str), \"match parameter should be string.\"\n    assert handler or redirect_to, \"you should specify handler or redirect_to for the url\"\n\n    if isinstance(methods, str):\n        methods = [methods.upper()]\n    elif isinstance(methods, (list, tuple)):\n        methods = [x.upper() for x in methods]\n\n    rule = {\"match\": match,\n            \"handler\": handler,\n            \"methods\": methods,\n            \"defaults\": defaults,\n            \"redirect_to\": redirect_to,\n            \"build_only\": build_only,\n            \"name\": name,\n            \"extra_data\": kwargs}\n    return rule", "response": "Build a url spec for a given route."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _build_rules(specs):\n    for spec in specs:\n        if \"context\" in spec:\n            yield Context(spec[\"context\"], list(_build_rules(spec.get(\"routes\", []))))\n        else:\n            rulespec = spec.copy()\n            match = rulespec.pop(\"match\")\n            name = rulespec.pop(\"name\")\n            yield Rule(match, endpoint=name, **rulespec)", "response": "Adapts the list of anillo urlmapping specs into\n    a list of werkzeug rules or rules subclasses."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef default_match_error_handler(exc):\n    if isinstance(exc, NotFound):\n        return http.NotFound()\n    elif isinstance(exc, MethodNotAllowed):\n        return http.MethodNotAllowed()\n    elif isinstance(exc, RequestRedirect):\n        return redirect(exc.new_url)\n    else:\n        raise exc", "response": "Default error handler for match error handling."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nroute for OAuth 2 Login", "response": "def r_oauth_login(self):\n        \"\"\"\n        Route for OAuth2 Login\n\n        :param next next url\n        :type str\n\n        :return: Redirects to OAuth Provider Login URL\n        \"\"\"\n        session['next'] = request.args.get('next','')\n        callback_url = self.authcallback\n        if callback_url is None:\n            callback_url = url_for('.r_oauth_authorized', _external=True)\n        return self.authobj.authorize(callback=callback_url)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef r_oauth_authorized(self):\n        resp = self.authobj.authorized_response()\n        if resp is None:\n            return 'Access denied: reason=%s error=%s' % (\n                request.args['error'],\n                request.args['error_description']\n            )\n        session['oauth_token'] = (resp['access_token'], '')\n        user = self.authobj.get('user')\n        ## TODO this is too specific to Perseids' api model. We should externalize.\n        session['oauth_user_uri'] = user.data['user']['uri']\n        session['oauth_user_name'] = user.data['user']['full_name']\n        if 'next' in session and session['next'] is not None:\n            return redirect(session['next'])\n        else:\n            return {\n                \"template\": \"nemo_oauth_plugin::authorized.html\",\n                \"username\": session['oauth_user_name']\n            }", "response": "Route for OAuth2 Authorization callback"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef r_oauth_logout(self):\n        session.pop('oauth_user_uri', None)\n        session.pop('oauth_user_name', None)\n        next = request.args.get('next','')\n        if next is not None:\n            return redirect(session['next'])\n        else:\n            return {\n                \"template\": \"main::index.html\"\n            }", "response": "Route to clear the oauth data from the session"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run_simple(app, *, host=\"127.0.0.1\", port=500,\n               debug=True, autoreload=True, **kwargs):\n    \"\"\"Start a WSGI application.\n    Optional features include a reloader, multithreading and fork support.\n    \"\"\"\n    kwargs.setdefault(\"use_evalex\", debug)\n    return serving.run_simple(host, port, app,\n                              use_debugger=debug,\n                              use_reloader=autoreload,\n                              **kwargs)", "response": "Start a WSGI application."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef with_added_dimensions(self, n):\n        if n > 0:\n            return Rect(np.pad(self.data, ((0, 0), (0, n)), 'constant'))\n        return Rect(self.data[:, :self.dimensions + n])", "response": "Returns a new Rect with n dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransforms an m - dimensional Rect using t", "response": "def transformed(self, t):\n        \"\"\"\n        Transforms an m-dimensional Rect using t, an nxn matrix that can\n        transform vectors in the form: [x, y, z, \u2026, 1].\n        The Rect is padded to n dimensions.\n        \"\"\"\n        assert t.shape[0] == t.shape[1]\n        extra_dimensions = t.shape[0] - self.dimensions - 1\n\n        def transform(a):\n            return t.dot(np.concatenate(\n                (a, [0] * extra_dimensions, [1]),\n                axis=0\n            ))[:self.dimensions]\n        return Rect(transform(self.mins), transform(self.maxes))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clamped(self, point_or_rect):\n        if isinstance(point_or_rect, Rect):\n            return Rect(np.minimum(self.mins, point_or_rect.mins),\n                        np.maximum(self.maxes, point_or_rect.maxes))\n        return np.clip(point_or_rect, self.mins, self.maxes)", "response": "Returns the point or rectangle clamped to this rectangle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rectified(self):\n        return Rect(np.minimum(self.mins, self.maxes),\n                    np.maximum(self.maxes, self.mins))", "response": "Returns a Rect object that is rectified by the current min - max pairs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, limit=None, timeout=None):\n        counter = 0\n        self.stream = sseclient.SSEClient(self.endpoint)\n        while True:\n            with utils.Timeout(timeout):\n                try:\n                    event = next(self.stream)\n                except StopIteration:\n                    continue\n                else:\n                    if not event.data:\n                        continue\n                    self.main_callback(event.data)\n                    counter += 1\n                    if limit and counter >= limit:\n                        return", "response": "This method is called by the event stream thread."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlaunch the SSE consumer.", "response": "def start(self, *args, **kwargs):#pylint:disable=unused-argument\n        \"\"\"\n        | Launch the SSE consumer.\n        | It can listen forever for messages or just wait for one.\n\n        :param limit: If set, the consumer listens for a limited number of events.\n        :type limit: int\n        :param timeout: If set, the consumer listens for an event for a limited time.\n        :type timeout: int\n        :rtype: None\n        \"\"\"\n        limit = kwargs.get('limit', None)\n        timeout = kwargs.get('timeout', None)\n        self.run(limit=limit, timeout=timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a random phrase which consists of few words separated by spaces.", "response": "def phrase(min_size, max_size = None):\n        \"\"\"\n        Generates a random phrase which consists of few words separated by spaces.\n        The first word is capitalized, others are not.\n\n        :param min_size: (optional) minimum string length.\n\n        :param max_size: maximum string length.\n\n        :return: a random phrase.\n        \"\"\"\n        max_size = max_size if max_size != None else min_size\n        size = RandomInteger.next_integer(min_size, max_size)\n        if size <= 0:\n            return \"\"\n        \n        result = \"\"\n        result += random.choice(_all_words)\n        while len(result) < size:\n            result += \" \" + random.choice(_all_words).lower()\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a random person s name which has the following structure", "response": "def name():\n        \"\"\"\n        Generates a random person's name which has the following structure\n        <optional prefix> <first name> <second name> <optional suffix>\n\n        :return: a random name.\n        \"\"\"\n        result = \"\"\n\n        if RandomBoolean.chance(3, 5):\n            result += random.choice(_name_prefixes) + \" \"\n\n        result += random.choice(_first_names) + \" \" + random.choice(_last_names)\n\n        if RandomBoolean.chance(5, 10):\n            result += \" \" + random.choice(_name_suffixes)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a random text that consists of random number of random words separated by spaces.", "response": "def words(min_size, max_size = None):\n        \"\"\"\n        Generates a random text that consists of random number of random words separated by spaces.\n\n        :param min_size: (optional) a minimum number of words.\n\n        :param max_size: a maximum number of words.\n\n        :return: a random text.\n        \"\"\"\n        max_size = max_size if max_size != None else min_size\n        result = \"\"\n        \n        count = RandomInteger.next_integer(min_size, max_size)\n        for i in range(count):\n            result += random.choice(_all_words)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a random phone number.", "response": "def phone():\n        \"\"\"\n        Generates a random phone number. The phone number has the format: (XXX) XXX-YYYY\n\n        :return: a random phone number.\n        \"\"\"\n        result = \"\"\n        result += \"(\" + str(RandomInteger.next_integer(111, 999)) + \") \"\n        result += str(RandomInteger.next_integer(111, 999))\n        result += \"-\" + str(RandomInteger.next_integer(0, 9999))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef text(min_size, max_size):\n        max_size = max_size if max_size != None else min_size\n        size = RandomInteger.next_integer(min_size, max_size)\n\n        result = \"\"\n        result += random.choice(_all_words)\n        \n        while len(result) < size:\n            next = random.choice(_all_words)\n            if RandomBoolean.chance(4, 6):\n                next = \" \" + next.lower()\n            elif RandomBoolean.chance(2, 5):\n                next = random.choice(\":,-\") + next.lower()\n            elif RandomBoolean.chance(3, 5):\n                next = random.choice(\":,-\") + \" \" + next.lower()\n            else:\n                next = random.choice(\".!?\") + \" \" + next\n\n            result += next\n\n        return result", "response": "Generates a random text consisting of first names last names colors stuffs adjectives verbs and punctuation marks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addItem(self, itemType, itemContents, itemID=None):\n\n        if itemType not in self.noteDB.collection_names():\n            fields = [(ii, pymongo.TEXT) for ii in itemContents]\n            self.noteDB[itemType].ensure_index(fields)\n\n        collection = self.noteDB[itemType]\n\n        if itemID is None:\n            itemContents['timestamps'] = [time.time()]\n            itemID = self.getNewID()\n            itemContents[\"ID\"] = itemID\n            collection.insert(itemContents)\n        else:\n            _id = collection.find_one({\"ID\": itemID})[\"_id\"]\n            timestamps = collection.find_one({\"ID\": itemID})[\"timestamps\"]\n            timestamps.append(time.time())\n            itemContents[\"timestamps\"] = timestamps\n            itemContents[\"ID\"] = itemID\n            collection.update({\"_id\": _id}, itemContents)\n\n        return itemID", "response": "Adds an item to the database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving an ID return the note JSON object that represents that ID.", "response": "def getItem(self, itemID):\n        \"\"\"\n           :desc: Given an ID return the note JSON object\n                   {u'note': u'note8',\n                    u'ID': 3.0,\n                    u'tags': [u'8'],\n                    u'timestamps': [1381719620.315899]}\n           :param int itemID: The item ID, an integer\n           :returns: The matching note\n           :rval: int\n        \"\"\"\n        collections = self.get_data_collections()\n\n        itemID = scrubID(itemID)\n\n        for coll in collections:\n            note = self.noteDB[coll].find_one({\"ID\": itemID})\n            if note is not None:\n                del note[\"_id\"]\n                note['type'] = coll\n                break\n\n        return note"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch for a specific item in the database.", "response": "def searchForItem(self, searchInfo, resultLimit=20, sortBy=\"relevance\"):\n        \"\"\"\n            :desc: Given a search term returns a list of results that match\n                   that term:\n\n                   [{u'score': 5.5,\n                     u'obj': {u'note': u'note8',\n                              u'ID': 3.0,\n                              u'timestamps': [1381719620.315899]}}]\n            :param str searchInfo: The search term\n            :returns: A list of matching notes\n            :rval: list\n        \"\"\"\n\n        searchResults = []\n\n        colls = self.get_data_collections()\n\n        proj = {\"_id\": 0}\n        for coll in colls:\n            res = self.noteDB.command(\"text\",\n                                      coll,\n                                      search=searchInfo,\n                                      project=proj,\n                                      limit=resultLimit)['results']\n            for ii in res:\n                ii['type'] = coll\n            searchResults.extend(res)\n\n        if sortBy.lower() == \"date\":\n            k = (lambda x: max(x['obj']['timestamps']))\n            searchResults = sorted(searchResults, key=k)\n        elif sortBy.lower() == \"id\":\n            k = (lambda x: x['obj']['ID'])\n            searchResults = sorted(searchResults, key=k)\n\n        return searchResults"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef deleteItem(self, itemID):\n        collections = self.get_data_collections()\n\n        query = {\"currentMax\": {\"$exists\": True}}\n        currentMax = self.noteDB[\"IDs\"].find_one(query)['currentMax']\n        query = {\"unusedIDs\": {\"$exists\": True}}\n        unusedIDs = self.noteDB['IDs'].find_one(query)['unusedIDs']\n\n        if (itemID > currentMax) or (itemID in unusedIDs):\n            raise ValueError(\"ID {0} does not exist\".format(itemID))\n\n        # Find document with ID\n        for coll in collections:\n            self.noteDB[coll].remove({\"ID\": itemID})\n\n        if currentMax == itemID:\n            self.noteDB['IDs'].update({\"currentMax\": currentMax},\n                                      {\"currentMax\": currentMax - 1})\n        else:\n            unusedIDs.append(itemID)\n            self.noteDB['IDs'].update({\"unusedIDs\": {\"$exists\": True}},\n                                      {\"unusedIDs\": unusedIDs})\n\n        return itemID", "response": "desc Deletes an item from the database"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wrap_form_params(func):\n\n    @functools.wraps(func)\n    def wrapper(request, *args, **kwargs):\n        ctype, pdict = parse_header(request.headers.get('Content-Type', ''))\n        if ctype == \"application/x-www-form-urlencoded\":\n            params = {}\n            for key, value in parse_qs(request.body.decode(\"utf-8\")).items():\n                if len(value) == 1:\n                    params[key] = value[0]\n                else:\n                    params[key] = value\n\n            request.params = merge_dicts(getattr(request, \"params\", None), params)\n            request.form_params = params\n        return func(request, *args, **kwargs)\n    return wrapper", "response": "A middleware that parses the url - encoded body and attachs the parsed values to the request. form_params attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wrap_query_params(func):\n\n    @functools.wraps(func)\n    def wrapper(request, *args, **kwargs):\n        params = {}\n        for key, value in parse_qs(request.query_string.decode(\"utf-8\")).items():\n            if len(value) == 1:\n                params[key] = value[0]\n            else:\n                params[key] = value\n\n        request.params = merge_dicts(getattr(request, \"params\", None), params)\n        request.query_params = params\n        return func(request, *args, **kwargs)\n    return wrapper", "response": "A middleware that parses the urlencoded params from the querystring\n    and attach it to the request. query_params attribute."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _task_idle_ticks(seconds_per_cycle):\n    t = time_ticks()\n    while True:\n        t += seconds_per_cycle\n        yield max(t - time_ticks(), 0)", "response": "Yields idle time ticks"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def _run(self):\n\n        tick_gen = _task_idle_ticks(0.5*self._shard_ttl)\n        self._is_running = True\n        self._ready_event.clear()\n        \n        while True:\n            try:\n                await self._lease_shard()\n                break\n            except grpc.RpcError as exc:\n                nap = _rand_uniform(3, 15)\n                logger.warn(f'failed in gRPC [{exc.code()}]: {exc.details()} '\n                            f'. napping {nap:.0f} secs ...')\n\n                if await self._continueAfterSleep(nap):\n                    continue\n                else:\n                    return\n\n        assert self._shard_id is not None           \n               \n        try:\n            while self._is_running:\n\n                self._ready_event.clear()\n                try:\n                    await self._renew_timestamp()\n                    await self._keepalive_shard()\n                except grpc.RpcError as exc: \n                    # exc.code()==grpc.StatusCode.UNAVAILABLE\n                    nap = _rand_uniform(3, 15)\n                    logger.warn(f'failed in grpc[{exc.code()}]: {exc.details()}'\n                                f', napping {nap:.0f}secs ...')\n\n                    if await self._continueAfterSleep(nap):\n                        continue\n                    else:\n                        break\n\n                self._ready_event.set()\n\n                if await self._continueAfterSleep(next(tick_gen)):\n                    continue\n                else:\n                    break\n\n        except asyncio.CancelledError:\n            pass\n\n        except Exception:\n            logger.error(f'Error in shard#{self._shard_id}:', exc_info=True)\n\n        finally:\n            self._ready_event.clear()\n            await self._lease.revoke() # \u53d6\u6d88\u79df\u7ea6\n            logger.debug(f'shard#{self._shard_id}, the lease revoked')", "response": "This method is run in a loop."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def _lease_shard(self):\n\n        prefix = self._prefix + '/shards/'\n        self._lease = await self._client.grant_lease(ttl=self._shard_ttl)\n\n        timestamp_bytes = (0).to_bytes(4, byteorder='big')\n\n        retries = 0\n        while True:\n            shard_subidx = len(prefix)\n            shard_id = 0\n\n            # \u627e\u5230\u672a\u4f7f\u7528\u7684\u6700\u5c0f\u5206\u7247\u53f7\n            records = await self._client.range_keys(range_prefix(prefix))\n            nums = sorted(int_fromhexbytes(k[shard_subidx:]) for k, _ in records)\n            for i, n in enumerate(nums):\n                if n > i:\n                    shard_id = i\n                    break\n            else:\n                shard_id = len(nums)\n\n            shard_id = int_tohex(shard_id, length=2)\n\n            logger.debug(f'leasing shard#{shard_id}, retry={retries}')\n\n            shard_path = f'{self._prefix}/shards/{shard_id}'\n            is_success, _ = await self._client.txn(compare=[\n                    transaction.Version(shard_path) == 0 \n                ], success=[\n                    KV.put.txn(shard_path, timestamp_bytes, lease=self._lease)\n                ])\n\n            if is_success:\n                self._shard_id = shard_id\n                self._timestamp = None\n                self._seqnum = None\n                break\n            else:\n                logger.debug(f'failed in leasing shard#{shard_id}: retry {retries}')\n                await _random_nap(retries)\n                retries += 1\n\n                if retries > 10:\n                    raise ValueError('out of retries')", "response": "Leases a new shard."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_node(cls, *args, **kwargs):\n    node = cls()\n    for name, value in zip(cls._fields, args):\n        setattr(node, name, value)\n    for name, value in kwargs:\n        setattr(node, name, value)\n    return node", "response": "Initializes an ast node with the provided attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninfer an abstract syntax tree from the provided value.", "response": "def infer_ast(src):\n    \"\"\"Attempts to infer an abstract syntax tree from the provided value.\n    \n    - Python ast.AST instances are passed through.\n    - Strings are parsed. A SyntaxError is raised if invalid.\n    - Functions are sent through cypy.fn_get_source to get a source\n      string, then parsed. If the source can't be a found, an exception is \n      raised by fn_get_source.\n      \n    .. WARNING:: Functions defined on the iPython command line do not have \n                 their source saved. A bug has been filed: \n                 \n                 http://github.com/ipython/ipython/issues/issue/120\n    \"\"\"\n    if isinstance(src, _ast.AST):\n        return src\n    elif isinstance(src, str):\n        return _ast.parse(src)\n    else:\n        # if a function instance is passed in, it's source is found\n        # and parsed. note that finding source can be precarious for\n        # functions defined on the command line. If you get an error\n        # you'll have to use strings instead of regular function\n        # definitions\n        src = cypy.fn_get_source(src)\n        return _ast.parse(src)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts the node of type node_type from the provided node.", "response": "def extract_the(node, node_type):\n    \"\"\"Extracts the node of type node_type from the provided node.\n    \n    - If the node is itself of node_type, returns node.\n    - If the node is a suite, it must contain exactly one node of the provided\n      type in its body.\n    \n    \"\"\"\n    if isinstance(node, node_type):\n        return node\n    try:\n        body = node.body\n    except AttributeError:\n        raise cypy.Error(\n            \"Expecting suite containing a single %s, or a %s, but got %s.\" %\n            (node_type.__name__, node_type.__name__, type(node).__name__))\n    \n    if len(body) != 1 or not isinstance(body[0], node_type):\n        raise cypy.Error(\n            \"The body must contain exactly one node of type %s.\" %\n            node_type.__name__)\n    return body[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_version():\n    proc = subprocess.Popen(\n        (\"git\", \"describe\", \"--tag\", \"--always\"), \n        stdout=subprocess.PIPE, stderr=subprocess.STDOUT\n    )\n    output, _ = proc.communicate()\n    result = output.decode(\"utf-8\").strip()\n    if proc.returncode != 0:\n        sys.stderr.write(\n            \">>> Git Describe Error:\\n    \" +\n            result\n        )\n        return \"1+unknown\"\n    split = result.split(\"-\", 1)\n    version = \"+\".join(split).replace(\"-\", \".\")\n\n    if len(split) > 1:\n        sys.stderr.write(\n            \">>> Please verify the commit tag:\\n    \" +\n            version + \"\\n\"\n        )\n    return version", "response": "Use git describe to get version from tag"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning file contents in unicode as list.", "response": "def get_file(fn):\n    \"\"\"Returns file contents in unicode as list.\"\"\"\n    fn = os.path.join(os.path.dirname(__file__), 'data', fn)\n    f = open(fn, 'rb')\n    lines = [line.decode('utf-8').strip() for line in f.readlines()]\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef name_generator(names=None):\n    if names is None:\n        names = ENGLISH_MONARCHS\n\n    while True:\n        yield text_type(random.choice(names))", "response": "Creates a generator for generating names."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef email_generator(names=None, domains=None, unique=False):\n    if names is None:\n        names = [name.encode('ascii', 'ignore').lower().replace(b' ', b'')\n                 for name in ENGLISH_MONARCHS]\n    if domains is None:\n        domains = DOMAINS\n\n    if unique:\n        uniquifyer = lambda: str(next(_unique_counter))\n    else:\n        uniquifyer = lambda: ''\n\n    while True:\n        yield '{0}{1}@{2}'.format(\n            random.choice(names), uniquifyer(), random.choice(domains))", "response": "Generates email addresses for a set of names and domains."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef paragraph_generator(sentences=None):\n    if sentences is None:\n        sentences = LOREM\n\n    while True:\n        # Paragraph consists of 1-7 sentences.\n        paragraph = [random.choice(sentences)\n                     for num in range(random.randint(1, 7))]\n        yield u' '.join(paragraph)", "response": "Generates a generator for generating paragraphs."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, agentml, user=None, key=None):\n        user = agentml.get_user(key) if key else user\n        if not user:\n            return\n\n        return user.id", "response": "Evaluate and return the current active topic of the user"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the current time as an MJD", "response": "def get_mjd(self):\n        \"\"\"\n        *Get the current time as an MJD*\n\n        **Return:**\n            - ``mjd`` -- the current MJD as a float\n\n        **Usage:**\n        .. todo::\n\n            - add clutil\n            - remove `getCurrentMJD` from all other code\n\n        .. code-block:: python \n\n            from astrocalc.times import now\n            mjd = now(\n                log=log\n            ).get_mjd()\n\n        \"\"\"\n        self.log.info('starting the ``get_mjd`` method')\n\n        jd = time.time() / 86400.0 + 2440587.5\n        mjd = jd - 2400000.5\n\n        self.log.info('completed the ``get_mjd`` method')\n        return mjd"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nimports a dotted path to a member name in a module and returns the member after importing it.", "response": "def import_dotted_path(path):\n    \"\"\"\n    Takes a dotted path to a member name in a module, and returns\n    the member after importing it.\n    \"\"\"\n    # stolen from Mezzanine (mezzanine.utils.importing.import_dotted_path)\n    try:\n        module_path, member_name = path.rsplit(\".\", 1)\n        module = import_module(module_path)\n        return getattr(module, member_name)\n    except (ValueError, ImportError, AttributeError) as e:\n        raise ImportError('Could not import the name: {}: {}'.format(path, e))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef discoverAuthEndpoints(authDomain, content=None, look_in={'name': 'link'}, test_urls=True, validateCerts=True, headers={}):\n    if test_urls:\n        ronkyuu.URLValidator(message='invalid domain URL')(authDomain)\n\n    if content:\n        result = {'status':   requests.codes.ok,\n                  'headers':  None,\n                  'content':  content\n                  }\n    else:\n        r = requests.get(authDomain, verify=validateCerts, headers=headers)\n        result = {'status':   r.status_code,\n                  'headers':  r.headers\n                  }\n        # check for character encodings and use 'correct' data\n        if 'charset' in r.headers.get('content-type', ''):\n            result['content'] = r.text\n        else:\n            result['content'] = r.content\n\n    result.update({'authorization_endpoint': set(), 'redirect_uri': set(), 'authDomain': authDomain})\n\n    if result['status'] == requests.codes.ok:\n        if 'link' in r.headers:\n            all_links = r.headers['link'].split(',', 1)\n\n            for link in all_links:\n                if ';' in link:\n                    link_parts = link.split(';')\n                    for s in link_parts[1:]:\n                        if 'rel=' in s:\n                            href = link_parts[0].strip()\n                            rel  = s.strip().replace('rel=', '').replace('\"', '')\n                            break\n                    url = urlparse(href[1:-1])\n\n                    if url.scheme in ('http', 'https') and rel in ('authorization_endpoint', 'redirect_uri'):\n                        result[rel].add(url)\n\n        all_links = BeautifulSoup(result['content'], _html_parser, parse_only=SoupStrainer(**look_in)).find_all('link')\n        for link in all_links:\n            rel = link.get('rel', None)[0]\n\n            if rel in ('authorization_endpoint', 'redirect_uri'):\n                href = link.get('href', None)\n                if href:\n                    url = urlparse(href)\n\n                    if url.scheme in ('http', 'https'):\n                        result[rel].add(url)\n    return result", "response": "Find the authorization or redirect_uri endpoints for the given authDomain."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validateAuthCode(code, redirect_uri, client_id, state=None, validationEndpoint='https://indieauth.com/auth', headers={}):\n    payload = {'code':         code,\n               'redirect_uri': redirect_uri,\n               'client_id':    client_id,\n              }\n    if state is not None:\n        payload['state'] = state\n\n    authURL = None\n    authEndpoints = discoverAuthEndpoints(client_id, headers=headers)\n    for url in authEndpoints['authorization_endpoint']:\n        authURL = url\n        break\n    if authURL is not None:\n        validationEndpoint = ParseResult(authURL.scheme, authURL.netloc, authURL.path, '', '', '').geturl()\n\n    r = requests.post(validationEndpoint, verify=True, data=payload, headers=headers)\n    result = { 'status':  r.status_code,\n               'headers': r.headers\n             }\n    if 'charset' in r.headers.get('content-type', ''):\n        result['content'] = r.text\n    else:\n        result['content'] = r.content\n    if r.status_code == requests.codes.ok:\n        result['response'] = parse_qs(result['content'])\n\n    return result", "response": "Validate the given auth code."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_params(url, ignore_empty=False):\n        try:\n            params_start_index = url.index('?')\n        except ValueError:\n            params_start_index = 0\n        params_string = url[params_start_index + 1:]\n\n        params_dict = {}\n        for pair in params_string.split('&'):\n            if not pair:\n                continue\n            splitted = pair.split('=')\n            param, value = splitted\n            if not value and ignore_empty:\n                continue\n            value = int(value) if value.isdigit() else value\n            params_dict[param] = value\n        return params_dict", "response": "Static method that parses a given url and returns a dictionary of parameters and their values."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_first_row(row, url_instance):\n        tags = row.xpath(Parser.FIRST_ROW_XPATH)\n        category_url = url_instance.combine(tags[0].get('href'))\n        title = unicode(tags[1].text)\n        # work with the incomplete URL to get str_id\n        torrent_url = tags[1].get('href')\n        str_id = torrent_url.split('details/')[1]\n        str_id = str_id[:-1] if str_id.endswith('/') else str_id\n        # complete the torrent URL with BASE_URL\n        torrent_url = url_instance.combine(torrent_url)\n\n        # means that torrent has external property\n        if len(tags) == 3:\n            # monkey patch the missing external query param\n            category_url += '&external=1'\n            tracked_by = '(external)'\n        else:\n            tracked_by = 'Demonoid'\n        return [str_id, title, tracked_by, category_url, torrent_url]", "response": "Static method that parses a given table row element by executing Parser. FIRST_ROW_XPATH and scrapping torrent s\n        id title tracked by status category url and torrent url. Used specifically with a torrent s first table row."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(url, max_backoff=32, verbose=False, **kwargs):\n    sleep_seconds = 1\n    while sleep_seconds <= max_backoff:\n        try:\n            # you may overwrite `timeout` via `kwargs`\n            response = requests.get(url, **{**{'timeout': 30}, **kwargs})\n            # for 4xx, return instantly, no hope of success\n            if 400 <= response.status_code < 500:\n                return None\n            # successfully return 2XX and 3xx\n            if 200 <= response.status_code < 400:\n                return response\n            # for 1xx and 5xx, retry\n        except RequestException as e:\n            if verbose:\n                print(str(e))\n\n        time.sleep(sleep_seconds)\n        sleep_seconds *= 2\n    return None", "response": "A function that retries requests. get with exponential backoff."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of primary contributors with the highest role assigned.", "response": "def get_primary_contributors(self, permitted=False):\n        \"\"\"Returns a list of primary contributors, with primary being\n        defined as those contributors that have the highest role\n        assigned(in terms of priority).\n        \"\"\"\n        primary_credits = []\n        credits = self.credits.exclude(\n            credit_option=None, credit_option__role_priority=None\n        ).order_by('credit_option__role_priority')\n        if credits.exists():\n            primary_priority = credits[0].credit_option.role_priority\n            for credit in credits:\n                if credit.credit_option.role_priority == primary_priority:\n                    primary_credits.append(credit)\n\n        contributors = []\n        for credit in primary_credits:\n            contributor = credit.contributor\n            if (permitted == False) or \\\n                ((permitted == True) and contributor.is_permitted):\n                contributors.append(contributor)\n\n        return contributors"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts and return Youtube video id", "response": "def youtube_id(self):\n        \"\"\"Extract and return Youtube video id\"\"\"\n        if not self.video_embed:\n            return ''\n        m = re.search(r'/embed/([A-Za-z0-9\\-=_]*)', self.video_embed)\n        if m:\n            return m.group(1)\n        return ''"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new He - Man application with the given configuration", "response": "def create_app(**config):\n    \"\"\"Application Factory\n\n    You can create a new He-Man application with::\n\n        from heman.config import create_app\n\n        app = create_app() # app can be uses as WSGI application\n        app.run() # Or you can run as a simple web server\n    \"\"\"\n    app = Flask(\n        __name__, static_folder=None\n    )\n\n    if 'MONGO_URI' in os.environ:\n        app.config['MONGO_URI'] = os.environ['MONGO_URI']\n\n    app.config['LOG_LEVEL'] = 'DEBUG'\n    app.config['SECRET_KEY'] = '2205552d13b5431bb537732bbb051f1214414f5ab34d47'\n\n    configure_logging(app)\n    configure_sentry(app)\n    configure_api(app)\n    configure_mongodb(app)\n    configure_login(app)\n\n    return app"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef configure_login(app):\n    from heman.auth import login_manager, login\n    login_manager.init_app(app)\n\n    @app.teardown_request\n    def force_logout(*args, **kwargs):\n        login.logout_user()", "response": "Configure login authentification\n    Uses Flask - Login <https://flask - login.readthedocs. org > _\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_DragonDosBinary(self, data, strip_padding=True):\n        data = bytearray(data)\n\n        log.debug(\"Load Dragon DOS Binary Format.\")\n\n        meta_data = struct.unpack(\">BBHHHB\", data[:9])\n\n        machine_type = meta_data[0]\n        if machine_type != 0x55:\n            log.error(\"ERROR: Machine type wrong: is $%02X but should be $55!\", machine_type)\n\n        self.file_type = meta_data[1]\n        self.load_address = meta_data[2]\n        self.length = meta_data[3]\n        self.exec_address = meta_data[4]\n        terminator = meta_data[5]\n        if terminator != 0xAA:\n            log.error(\"ERROR: Terminator byte is $%02X but should be $AA!\", terminator)\n\n        # print(\"before strip:\")\n        # print(\"\\n\".join(bin2hexline(data, width=16)))\n        if strip_padding:\n            self.data = data[9:self.length + 9]\n        else:\n            self.data = data[9:]\n        # print(\"after strip:\")\n        # print(\"\\n\".join(bin2hexline(self.data, width=16)))\n\n        log.debug(\n            \"File type: $%02X Load Address: $%04X Exec Address: $%04X Length: %iBytes\",\n            self.file_type, self.load_address, self.exec_address, self.length\n        )\n        if self.length != len(self.data):\n            log.error(\"ERROR: Wrong data size: should be: %i Bytes but is %i Bytes!\", self.length, len(self.data))\n\n        # log_bytes(self.data, \"data in hex: %s\", level=logging.DEBUG)\n        self.debug2log(level=logging.DEBUG)", "response": "Load the Dragon DOS Binary format from the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_from_bin(self, data):\n        data = bytearray(data)\n\n        machine_type = data[0]\n\n        # machine_type = struct.unpack(\"B\", bin[0])[0]\n        if machine_type == 0x55:\n            # Dragon DOS Binary Format\n            self.load_DragonDosBinary(data)\n        elif machine_type == 0x00:\n            raise NotImplementedError(\"CoCo DECB (Disk Extended Color BASIC) Format not supported, yet.\")\n        else:\n            raise NotImplementedError(\"ERROR: Format $%02X unknown.\" % machine_type)", "response": "Convert binary files to ASCII basic string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rotatePoint(x, y, rotationDegrees, pivotx=0, pivoty=0):\n\n    # Reuse the code in rotatePoints()\n    return list(rotatePoints([(x, y)], rotationDegrees, pivotx, pivoty))[0]", "response": "Rotates the point at x and y by rotationDegrees."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrotating each x and y tuple in points by rotationDegrees.", "response": "def rotatePoints(points, rotationDegrees, pivotx=0, pivoty=0):\n    \"\"\"\n    Rotates each x and y tuple in `points`` by `rotationDegrees`. The points\n    are rotated around the origin by default, but can be rotated around another\n    pivot point by specifying `pivotx` and `pivoty`.\n\n    The points are rotated counterclockwise.\n\n    Returns a generator that produces an x and y tuple for each point in `points`.\n\n    >>> list(rotatePoints([(10, 0), (7, 7)], 45))\n    [(7, 7), (0, 9)]\n    \"\"\"\n\n    rotationRadians = math.radians(rotationDegrees % 360)\n\n    for x, y in points:\n        _checkForIntOrFloat(x)\n        _checkForIntOrFloat(y)\n        x -= pivotx\n        y -= pivoty\n        x, y = x * math.cos(rotationRadians) - y * math.sin(rotationRadians), x * math.sin(rotationRadians) + y * math.cos(rotationRadians)\n        x += pivotx\n        y += pivoty\n\n        yield int(x), int(y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntranslates a sequence of points into a single segment of the base image.", "response": "def translatePoints(points, movex, movey):\n    \"\"\"\n    Returns a generator that produces all of the (x, y) tuples in `points` moved over by `movex` and `movey`.\n\n    >>> points = [(0, 0), (5, 10), (25, 25)]\n    >>> list(translatePoints(points, 1, -3))\n    [(1, -3), (6, 7), (26, 22)]\n    \"\"\"\n\n    # Note: There is no translatePoint() function because that's trivial.\n    _checkForIntOrFloat(movex)\n    _checkForIntOrFloat(movey)\n    try:\n        for x, y in points:\n            _checkForIntOrFloat(x)\n            _checkForIntOrFloat(y)\n            yield x + movex, y + movey\n    except:\n        raise PyBresenhamException('`points` argument must be an iterable of (x, y) points.')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef line(x1, y1, x2, y2, thickness=1, endcap=None, _skipFirst=False):\n\n    if (thickness != 1) or (endcap is not None):\n        raise NotImplementedError('The pybresenham module is under development and the filled and thickness parameters are not implemented. You can contribute at https://github.com/asweigart/pybresenham')\n\n    _checkForIntOrFloat(x1)\n    _checkForIntOrFloat(y1)\n    _checkForIntOrFloat(x2)\n    _checkForIntOrFloat(y2)\n    x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2) # TODO - Do we want this line?\n\n    if not isinstance(_skipFirst, bool):\n        raise PyBresenhamException('_skipFirst argument must be a bool')\n\n    isSteep = abs(y2-y1) > abs(x2-x1)\n    if isSteep:\n        x1, y1 = y1, x1\n        x2, y2 = y2, x2\n    isReversed = x1 > x2\n\n    if isReversed:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n\n        deltax = x2 - x1\n        deltay = abs(y2-y1)\n        error = int(deltax / 2)\n        y = y2\n        ystep = None\n        if y1 < y2:\n            ystep = 1\n        else:\n            ystep = -1\n        for x in range(x2, x1 - 1, -1):\n            if isSteep:\n                if not (_skipFirst and (x, y) == (x2, y2)):\n                    yield (y, x)\n            else:\n                if not (_skipFirst and (x, y) == (x2, y2)):\n                    yield (x, y)\n            error -= deltay\n            if error <= 0:\n                y -= ystep\n                error += deltax\n    else:\n        deltax = x2 - x1\n        deltay = abs(y2-y1)\n        error = int(deltax / 2)\n        y = y1\n        ystep = None\n        if y1 < y2:\n            ystep = 1\n        else:\n            ystep = -1\n        for x in range(x1, x2 + 1):\n            if isSteep:\n                if not (_skipFirst and (x, y) == (x1, y1)):\n                    yield (y, x)\n            else:\n                if not (_skipFirst and (x, y) == (x1, y1)):\n                    yield (x, y)\n            error -= deltay\n            if error < 0:\n                y += ystep\n                error += deltax", "response": "Generates a generator that produces all of the points in a line between x1 y1 and x2 y2."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a generator that produces all of the lines connecting the x y coordinates in points.", "response": "def lines(points, closed=False, thickness=1, endcap=None, _skipFirst=False):\n    \"\"\"\n    Returns a generator that produces all of the points in the lines connecting the (x, y) tuples in `points`.\n\n    If `closed` is `True`, then the last point will connect to the first point.\n\n    (Note: The `thickness` and `endcap` parameters are not yet implemented.)\n\n    >>> list(lines([(0, 0), (10, 3), (5, 5)]))\n    [(0, 0), (1, 0), (2, 1), (3, 1), (4, 1), (5, 1), (6, 2), (7, 2), (8, 2), (9, 3), (10, 3), (9, 4), (8, 4), (7, 4), (6, 5), (5, 5)]\n    >>> drawPoints(lines([(0, 0), (10, 3), (5, 5)]))\n    OO,,,,,,,,,\n    ,,OOOO,,,,,\n    ,,,,,,OOO,,\n    ,,,,,,,,,OO\n    ,,,,,,,OOO,\n    ,,,,,OO,,,,\n    \"\"\"\n\n    if thickness != 1 or endcap is not None:\n        raise NotImplementedError('The pybresenham module is under development and the filled, thickness, and endcap parameters are not implemented. You can contribute at https://github.com/asweigart/pybresenham')\n\n    # Validate points argument\n    try:\n        iter(points)\n    except TypeError:\n        raise PyBresenhamException('points must be an iterable')\n\n    # Check that all the xy coordinates are either ints or floats.\n    for i, point in enumerate(points):\n        try:\n            _checkForIntOrFloat(point[0])\n            _checkForIntOrFloat(point[1])\n        except:\n            raise PyBresenhamException('point at index %s is not a tuple of two int/float values' % (i))\n\n    if closed:\n        # Validate the points argument for a closed multi-line shape.\n        try:\n            points[2] # Make sure there are at least three points for this closed irregular polygon.\n            points = list(points)\n            points.append(points[0]) # The final point connects back to the starting point.\n        except:\n            raise PyBresenhamException('points argument must have at least three points if closed==True')\n        _skipFirst=True\n    else:\n        # Validate that there are at least two points.\n        try:\n            points[1]\n        except:\n            raise PyBresenhamException('points argument must have at least two points')\n\n    # Technically, we're allocating all of the iterators for each line segment\n    # at once, which isn't the most efficient way to do it but is the most\n    # direct. And even this direct way still produces kind of unreadable code.\n    # (\"Line segment\" means the line between two adjacent points in the points\n    # parameter.)\n    # We are using itertools.chain() to create one iterator from several\n    # iterables (one iterable per line segment).\n    if _skipFirst:\n        return itertools.chain.from_iterable([line(points[i][0], points[i][1], points[i+1][0], points[i+1][1], _skipFirst=True) for i in range(len(points) - 1)])\n    else:\n        return itertools.chain([(points[0][0], points[0][1])], # the first point in points\n                               itertools.chain.from_iterable([line(points[i][0], points[i][1], points[i+1][0], points[i+1][1], _skipFirst=True) for i in range(len(points) - 1)]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef polygon(x, y, radius, sides, rotationDegrees=0, stretchHorizontal=1.0, stretchVertical=1.0, filled=False, thickness=1):\n    if thickness != 1:\n        raise NotImplementedError('The pybresenham module is under development and the filled, thickness, and endcap parameters are not implemented. You can contribute at https://github.com/asweigart/pybresenham')\n\n    # Validate sides (x, y, radius, and rotationDegrees are validated in polygonVertices())\n    _checkForIntOrFloat(sides)\n    if sides < 3:\n        raise PyBresenhamException('sides argument must be at least 3')\n\n    vertices = list(polygonVertices(x, y, radius, sides, rotationDegrees, stretchHorizontal, stretchVertical))\n\n    if filled:\n        # Run flood fill on the shape, starting from the center.\n        borderPoints = list(lines(vertices, closed=True, thickness=thickness, endcap=None))\n        return iter(floodFill(borderPoints, x, y))\n    else:\n        return lines(vertices, closed=True, thickness=thickness, endcap=None)", "response": "Generates a generator that produces the points of a regular polygon."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef polygonVertices(x, y, radius, sides, rotationDegrees=0, stretchHorizontal=1.0, stretchVertical=1.0):\n\n    # TODO - validate x, y, radius, sides\n\n    # Setting the start point like this guarantees a flat side will be on the \"bottom\" of the polygon.\n    if sides % 2 == 1:\n        angleOfStartPointDegrees = 90 + rotationDegrees\n    else:\n        angleOfStartPointDegrees = 90 + rotationDegrees - (180 / sides)\n\n    for sideNum in range(sides):\n        angleOfPointRadians = math.radians(angleOfStartPointDegrees + (360 / sides * sideNum))\n\n        yield (  int(math.cos(angleOfPointRadians) * radius  * stretchHorizontal) + x,\n               -(int(math.sin(angleOfPointRadians) * radius) * stretchVertical)   + y)", "response": "Generates a generator that produces the vertices of a polygon."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef floodFill(points, startx, starty):\n\n    # Note: We're not going to use recursion here because 1) recursion is\n    # overrated 2) on a large enough shape it would cause a stackoverflow\n    # 3) flood fill doesn't strictly need recursion because it doesn't require\n    # a stack and 4) recursion is overrated.\n\n    allPoints = set(points) # Use a set because the look ups will be faster.\n\n    # Find the min/max x/y values to get the \"boundaries\" of this shape, to\n    # prevent an infinite loop.\n    minx = miny = maxx = maxy = None\n    for bpx, bpy in points:\n        if minx is None:\n            # This is the first point, so set all the min/max to it.\n            minx = maxx = bpx\n            miny = maxy = bpy\n            continue\n        if bpx < minx:\n            minx = bpx\n        if bpx > maxx:\n            maxx = bpx\n        if bpy < miny:\n            miny = bpy\n        if bpy > maxy:\n            maxy = bpy\n\n    pointsToProcess = [(startx, starty)]\n    while pointsToProcess:\n        x, y = pointsToProcess.pop()\n\n        # Process point to right left of x, y.\n        if x + 1 < maxx and (x + 1, y) not in allPoints:\n            pointsToProcess.append((x + 1, y))\n            allPoints.add((x + 1, y))\n        # Process point to the left of x, y.\n        if x - 1 > minx and (x - 1, y) not in allPoints:\n            pointsToProcess.append((x - 1, y))\n            allPoints.add((x - 1, y))\n        # Process point below x, y.\n        if y + 1 < maxy and (x, y + 1) not in allPoints:\n            pointsToProcess.append((x, y + 1))\n            allPoints.add((x, y + 1))\n        # Process point above x, y.\n        if y - 1 > miny and (x, y - 1) not in allPoints:\n            pointsToProcess.append((x, y - 1))\n            allPoints.add((x, y - 1))\n    return allPoints", "response": "Draw a set of points from a filled in area."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a generator that produces the x y tuples for the outline of a circle.", "response": "def circle(x, y, radius, filled=False, thickness=1):\n    \"\"\"\n    Returns a generator that produces the (x, y) tuples for the outline of a circle.\n\n    `x` and `y` are the center of the circle, `radius` is the size.\n\n    (Note: The `filled` and `thickness` parameter is not yet implemented.)\n\n    >>> list(circle(0, 0, 7))\n    [(-6, 3), (0, 7), (4, -6), (-7, 0), (7, -1), (7, -2), (2, -7), (5, -5), (-5, 5), (-1, -7), (-2, -7), (-4, 6), (7, 2), (5, 5), (-5, -5), (6, -4), (6, 3), (-6, 4), (3, 6), (-3, 6), (6, 4), (1, -7), (6, -3), (7, 1), (-6, -4), (-7, 2), (-4, -6), (-2, 7), (-1, 7), (2, 7), (7, 0), (-7, -1), (-7, -2), (4, 6), (0, -7), (-6, -3), (-7, 1), (1, 7), (3, -6), (-3, -6)]\n    >>> drawPoints(circle(0, 0, 7))\n    ,,,,,OOOOO,,,,,\n    ,,,OO,,,,,OO,,,\n    ,,O,,,,,,,,,O,,\n    ,O,,,,,,,,,,,O,\n    ,O,,,,,,,,,,,O,\n    O,,,,,,,,,,,,,O\n    O,,,,,,,,,,,,,O\n    O,,,,,,,,,,,,,O\n    O,,,,,,,,,,,,,O\n    O,,,,,,,,,,,,,O\n    ,O,,,,,,,,,,,O,\n    ,O,,,,,,,,,,,O,\n    ,,O,,,,,,,,,O,,\n    ,,,OO,,,,,OO,,,\n    ,,,,,OOOOO,,,,,\n    \"\"\"\n    # Mid-point/Bresenham's Circle algorithm from https://www.daniweb.com/programming/software-development/threads/321181/python-bresenham-circle-arc-algorithm\n    # and then modified to remove duplicates.\n\n    # The order that the xy points are returned is rather unconventional due to the optimizations in the code, it is not a simple clockwise/counterclockwise sweep.\n    if filled or thickness != 1:\n        raise NotImplementedError('The pybresenham module is under development and the filled, thickness, and endcap parameters are not implemented. You can contribute at https://github.com/asweigart/pybresenham')\n\n    switch = 3 - (2 * radius)\n    cx = 0\n    cy = radius\n    \"\"\"\n    # NOTE - This code leaves a point missing from the final circle on the left side. Until I can figure it out, I'm usin the old algorithm, which unforuntately defeats the purpose of having a generator.\n    # 1st quarter/octant starts clockwise at 12 o'clock\n    while cx <= cy:\n        # Duplicates are formed whenever cx or cy is 0, or when cx == cy.\n        # I've rearranged the original code to minimize if statements,\n        # though it makes the code a bit inscrutable.\n        yield ( cx + x, -cy + y) # 1st quarter 1st octant\n        if cx != cy:\n            yield ( cy + x, -cx + y) # 1st quarter 2nd octant\n        if cx != 0:\n            yield ( cy + x,  cx + y) # 2nd quarter 3rd octant\n            if cy != 0:\n                yield (-cx + x,  cy + y) # 3rd quarter 5th octant\n                yield (-cy + x, -cx + y) # 4th quarter 7th octant\n                if cx != cy:\n                    yield (-cy + x,  cx + y) # 3rd quarter 6th octant\n                    yield (-cx + x, -cy + y) # 4th quarter 8th octant\n        if cy != 0 and cx != cy:\n            yield ( cx + x,  cy + y) # 2nd quarter 4th octant\n\n        if switch < 0:\n            switch += (4 * cx) + 6\n        else:\n            switch += (4 * (cx - cy)) + 10\n            cy -= 1\n        cx += 1\n    \"\"\"\n    points = set()\n    while cx <= cy:\n        # first quarter first octant\n        points.add((cx + x,-cy + y))\n        # first quarter 2nd octant\n        points.add((cy + x,-cx + y))\n        # second quarter 3rd octant\n        points.add((cy + x,cx + y))\n        # second quarter 4.octant\n        points.add((cx + x,cy + y))\n        # third quarter 5.octant\n        points.add((-cx + x,cy + y))\n        # third quarter 6.octant\n        points.add((-cy + x,cx + y))\n        # fourth quarter 7.octant\n        points.add((-cy + x,-cx + y))\n        # fourth quarter 8.octant\n        points.add((-cx + x,-cy + y))\n        if switch < 0:\n            switch = switch + (4 * cx) + 6\n        else:\n            switch = switch + (4 * (cx - cy)) + 10\n            cy = cy - 1\n        cx = cx + 1\n    return iter(points)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef square(left, top, length, filled=False, thickness=1):\n    if thickness != 1:\n        raise NotImplementedError('The pybresenham module is under development and the filled, thickness, and endcap parameters are not implemented. You can contribute at https://github.com/asweigart/pybresenham')\n\n    return rectangle(left, top, length, length, filled, thickness)", "response": "Returns a generator that produces x y tuples for a square."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rectangle(left, top, width, height, filled=False, thickness=1):\n\n    # Note: For perfomance, this function does not rely on line() to generate its points.\n\n    if thickness != 1:\n        # TODO - should the original left and top be for the thick border, or should thick borders go to the left and above of the left and top coordinates?\n        raise NotImplementedError('The pybresenham module is under development and the filled, thickness, and endcap parameters are not implemented. You can contribute at https://github.com/asweigart/pybresenham')\n\n    # Validate arguments\n    _checkForIntOrFloat(left)\n    _checkForIntOrFloat(top)\n    _checkForIntOrFloat(width)\n    _checkForIntOrFloat(height)\n\n    left, top, width, height = int(left), int(top), int(width), int(height)\n\n    if width < 1 or height < 1:\n        raise PyBresenhamException('width and height must be positive integers')\n\n    # Generate all the points.\n    if filled:\n        for y in range(top, top + height):\n            for x in range(left, left + width):\n                yield (x, y)\n    else:\n        # Note: The `- 1` adjustments here are to prevent duplicate coordinates of the corners being returned.\n\n        # Top side.\n        y = top\n        for x in range(left, left + width - 1):\n            yield (x, y)\n\n        # Right side.\n        x = left + width - 1\n        for y in range(top, top + height - 1):\n            yield (x, y)\n\n        # Bottom side.\n        y = top + height - 1\n        for x in range(left + width - 1, left, -1):\n            yield (x, y)\n\n        # Left side.\n        x = left\n        for y in range(top + height - 1, top, -1):\n            yield (x, y)", "response": "Returns a generator that generates x y tuples for a rectangle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a generator that produces x y tuples in a diamond shape.", "response": "def diamond(x, y, radius, filled=False, thickness=1):\n    \"\"\"\n    Returns a generator that produces (x, y) tuples in a diamond shape.\n    It is easier to predict the size of the diamond that this function\n    produces, as opposed to creatinga 4-sided polygon with `polygon()`\n    and rotating it 45 degrees.\n\n    The `left` and `top` arguments are the x and y coordinates for the topleft corner of the square.\n\n    The width and height of the diamond will be `2 * radius + 1`.\n\n    If `filled` is `True`, the interior points are also returned.\n\n    In this example diamond shape, the D characters represent the\n    drawn diamond, the . characters represent the \"outside spaces\",\n    and the ' characters represent the \"inside spaces\".\n    (The radius of this example diamond is 3.)\n\n    ...D\n    ..D'D\n    .D'''D\n    D'''''D\n    .D'''D\n    ..D'D\n    ...D\n\n    >>> list(diamond(0, 0, 3))\n    [(4, 0), (3, 1), (5, 1), (2, 2), (6, 2), (1, 3), (7, 3), (2, 4), (6, 4), (3, 5), (5, 5), (4, 6)]\n    >>> drawPoints(diamond(0, 0, 3))\n    ,,,O,,,\n    ,,O,O,,\n    ,O,,,O,\n    O,,,,,O\n    ,O,,,O,\n    ,,O,O,,\n    ,,,O,,,\n    >>> drawPoints(diamond(0, 0, 3, filled=True))\n    ,,,O,,,\n    ,,OOO,,\n    ,OOOOO,\n    OOOOOOO\n    ,OOOOO,\n    ,,OOO,,\n    ,,,O,,,\n    \"\"\"\n\n    if thickness != 1:\n        raise NotImplementedError('The pybresenham module is under development and the filled, thickness, and endcap parameters are not implemented. You can contribute at https://github.com/asweigart/pybresenham')\n\n    outsideSpaces = radius\n    insideSpaces = 1 # We'll only start incrementing insidesSpaces on the 2nd row.\n\n    for row in range(radius * 2 + 1):\n        # Yield the leftside point in this row.\n        yield (outsideSpaces + 1 + x, row + y)\n\n        if row != 0 and row != radius * 2:\n            # (The first and last rows only have one point per row.)\n\n            if filled:\n                # Yield all the interior spaces in this row.\n                for interiorx in range(outsideSpaces + 2 + x, outsideSpaces + insideSpaces + 2 + x):\n                    yield (interiorx, row + y) # No need for \"+ x\" here, we did that in the range() call.\n\n            # Yield the rightside point in this row.\n            yield (outsideSpaces + insideSpaces + 2 + x, row + y)\n\n        # Modify outsideSpaces/insideSpaces as we move down the rows.\n        if row < radius:\n            outsideSpaces -= 1\n            if row != 0:\n                insideSpaces += 2\n        else:\n            outsideSpaces += 1\n            insideSpaces -= 2"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a generator that produces x y tuples for a grid.", "response": "def grid(gridLeft, gridTop, numBoxesWide, numBoxesHigh, boxWidth, boxHeight, thickness=1):\n    \"\"\"\n    Returns a generator that produces (x, y) tuples for a grid.\n\n    The `gridLeft` and `gridTop` arguments are the x and y coordinates for the topleft corner of the grid.\n\n    The `numBoxesWide` and `numBoxesHigh` arguments are the number of boxes (or, cells) in the grid.\n\n    The `boxWidth` and `boxHeight` are the size of each box (or, cell). This is the size of the box's\n    interior, and doesn't include the lines of the grid.\n\n    The `thickness` argument is how the thick the grid lines are.\n\n    The width of the grid is `(numBoxesWide * boxWidth) + (thickness * (numBoxesWide + 1))`.\n\n    The height of the grid is `(numBoxesHeight * boxheight) + (thickness * (numBoxesHeight + 1))`.\n\n\n    >>> list(grid(0, 0, 3, 2, 5, 4))\n    [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (10, 0), (11, 0), (12, 0), (13, 0), (14, 0), (15, 0), (16, 0), (17, 0), (18, 0), (0, 5), (1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (7, 5), (8, 5), (9, 5), (10, 5), (11, 5), (12, 5), (13, 5), (14, 5), (15, 5), (16, 5), (17, 5), (18, 5), (0, 10), (1, 10), (2, 10), (3, 10), (4, 10), (5, 10), (6, 10), (7, 10), (8, 10), (9, 10), (10, 10), (11, 10), (12, 10), (13, 10), (14, 10), (15, 10), (16, 10), (17, 10), (18, 10), (0, 1), (0, 2), (0, 3), (0, 4), (0, 6), (0, 7), (0, 8), (0, 9), (6, 1), (6, 2), (6, 3), (6, 4), (6, 6), (6, 7), (6, 8), (6, 9), (12, 1), (12, 2), (12, 3), (12, 4), (12, 6), (12, 7), (12, 8), (12, 9), (18, 1), (18, 2), (18, 3), (18, 4), (18, 6), (18, 7), (18, 8), (18, 9)]\n\n    >>> drawPoints(grid(0, 0, 3, 2, 5, 4))\n    OOOOOOOOOOOOOOOOOOO\n    O,,,,,O,,,,,O,,,,,O\n    O,,,,,O,,,,,O,,,,,O\n    O,,,,,O,,,,,O,,,,,O\n    O,,,,,O,,,,,O,,,,,O\n    OOOOOOOOOOOOOOOOOOO\n    O,,,,,O,,,,,O,,,,,O\n    O,,,,,O,,,,,O,,,,,O\n    O,,,,,O,,,,,O,,,,,O\n    O,,,,,O,,,,,O,,,,,O\n    OOOOOOOOOOOOOOOOOOO\n    >>> drawPoints(grid(0, 0, 3, 2, 5, 4, thickness=2))\n    OOOOOOOOOOOOOOOOOOOOOOO\n    OOOOOOOOOOOOOOOOOOOOOOO\n    OO,,,,,OO,,,,,OO,,,,,OO\n    OO,,,,,OO,,,,,OO,,,,,OO\n    OO,,,,,OO,,,,,OO,,,,,OO\n    OO,,,,,OO,,,,,OO,,,,,OO\n    OOOOOOOOOOOOOOOOOOOOOOO\n    OOOOOOOOOOOOOOOOOOOOOOO\n    OO,,,,,OO,,,,,OO,,,,,OO\n    OO,,,,,OO,,,,,OO,,,,,OO\n    OO,,,,,OO,,,,,OO,,,,,OO\n    OO,,,,,OO,,,,,OO,,,,,OO\n    OOOOOOOOOOOOOOOOOOOOOOO\n    OOOOOOOOOOOOOOOOOOOOOOO\n    \"\"\"\n\n    # Validate arguments.\n    _checkForIntOrFloat(gridLeft)\n    _checkForIntOrFloat(gridTop)\n    _checkForIntOrFloat(numBoxesWide)\n    _checkForIntOrFloat(numBoxesHigh)\n    _checkForIntOrFloat(boxWidth)\n    _checkForIntOrFloat(boxHeight)\n    _checkForIntOrFloat(thickness)\n\n    numBoxesWide = int(numBoxesWide)\n    numBoxesHigh = int(numBoxesHigh)\n    boxWidth = int(boxWidth)\n    boxHeight = int(boxHeight)\n    thickness = int(thickness)\n\n    if numBoxesWide < 1:\n        raise PyBresenhamException('numBoxesWide must be 1 or greater')\n    if numBoxesHigh < 1:\n        raise PyBresenhamException('numBoxesHigh must be 1 or greater')\n    if boxWidth < 1:\n        raise PyBresenhamException('boxWidth must be 1 or greater')\n    if boxHeight < 1:\n        raise PyBresenhamException('boxHeight must be 1 or greater')\n    if thickness < 1:\n        raise PyBresenhamException('thickness must be 1 or greater')\n\n\n    # Record the y coordinates so we don't repeat the points at the intersections\n    # of the grid.\n    intersectiony = set()\n\n    \"\"\"Generate the points for the horizontal lines of the grid.\n    i.e. the - characters in this diagram:\n    ----------\n    |  |  |  |\n    |  |  |  |\n    ----------\n    |  |  |  |\n    |  |  |  |\n    ----------\n    |  |  |  |\n    |  |  |  |\n    ----------\"\"\"\n    for gridRow in range(numBoxesHigh + 1):\n        for thicknessIndex in range(thickness): # thicknessIndex isn't a great name, but each \"grid row\" can be multiple points tall if thickness > 1\n            y = (boxHeight * gridRow) + (thickness * gridRow) + thicknessIndex\n            intersectiony.add(y)\n            for x in range(numBoxesWide * boxWidth + (thickness * (numBoxesWide + 1))):\n                yield (x + gridLeft, y + gridTop)\n\n    \"\"\"Generate the points for the vertical lines in between the horizontal lines of the grid.\n    i.e. the | characters in this diagram:\n    ----------\n    |  |  |  |\n    |  |  |  |\n    ----------\n    |  |  |  |\n    |  |  |  |\n    ----------\n    |  |  |  |\n    |  |  |  |\n    ----------\"\"\"\n    for gridColumn in range(numBoxesWide + 1):\n        for thicknessIndex in range(thickness): # thicknessIndex isn't a great name, but each \"grid row\" can be multiple points tall if thickness > 1\n            x = (boxWidth * gridColumn) + (thickness * gridColumn) + thicknessIndex\n            for y in range(numBoxesHigh * boxHeight + (thickness * (numBoxesHigh + 1))):\n\n                # Additionally, we don't want to yield xy points we've yielded before.\n                \"\"\" i.e. These would be the points at the intersections of the grid,\n                at the + characters in this diagram:\n                    +--+--+--+\n                    |  |  |  |\n                    |  |  |  |\n                    +--+--+--+\n                    |  |  |  |\n                    |  |  |  |\n                    +--+--+--+\n                    |  |  |  |\n                    |  |  |  |\n                    +--+--+--+\"\"\"\n                if y not in intersectiony:\n                    yield (x + gridLeft, y + gridTop)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef drawPoints(points, bg=','):\n\n    # Note: I set bg to ',' instead of '.' because using ... in the docstrings\n    # confuses doctest and makes it think it's Python's secondary ... prompt,\n    # causing doctest errors.\n    import sys\n    points = list(points)\n    try:\n        points = [(int(x), int(y)) for x, y in points]\n    except:\n        raise PyBresenhamException('points must only contains (x, y) numeric tuples')\n\n    # Calculate size of the character grid from the given points.\n    minx = min([x for x, y in points])\n    maxx = max([x for x, y in points])\n    miny = min([y for x, y in points])\n    maxy = max([y for x, y in points])\n\n    charGrid = [[' '] * (maxy - miny + 1) for i in range(maxx - minx + 1)]\n\n    # Draw O characters to the grid at the given points.\n    for x, y in points:\n        charGrid[x - minx][y - miny] = 'O'\n\n    # Print out the character grid.\n    for y in range(len(charGrid[0])):\n        for x in range(len(charGrid)):\n            if charGrid[x][y] in (None, ' '):\n                charToDraw = bg\n            else:\n                charToDraw = charGrid[x][y]\n            sys.stdout.write(charToDraw)\n        print()", "response": "A small debug function that takes an iterable of x y integer tuples\n    and draws them to the screen."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef emit(self, record):\n        self.records.append(Record(levelno=record.levelno, levelname=record.levelname,\n                                   message=self.format(record)))\n        return super(SetupLogChecker, self).emit(record)", "response": "Store the message not only the record."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_generic_pos(self, *tokens):\n        for record in self.records:\n            if all(token in record.message for token in tokens):\n                return\n\n        # didn't exit, all tokens are not present in the same record\n        msgs = [\"Tokens {} not found, all was logged is...\".format(tokens)]\n        for record in self.records:\n            msgs.append(\"    {:9s} {!r}\".format(record.levelname, record.message))\n        self.test_instance.fail(\"\\n\".join(msgs))", "response": "Check if the different tokens were logged in one record any level."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_pos(self, level, *tokens):\n        for record in self.records:\n            if all(record.levelno == level and token in record.message for token in tokens):\n                return\n\n        # didn't exit, all tokens are not present in the same record\n        level_name = logging.getLevelName(level)\n        msgs = [\"Tokens {} not found in {}, all was logged is...\".format(tokens, level_name)]\n        for record in self.records:\n            msgs.append(\"    {:9s} {!r}\".format(record.levelname, record.message))\n        self.test_instance.fail(\"\\n\".join(msgs))", "response": "Check if the different tokens were logged in one record assert by level."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_neg(self, level, *tokens):\n        for record in self.records:\n            if level is not None and record.levelno != level:\n                continue\n            if all(token in record.message for token in tokens):\n                break\n        else:\n            return\n\n        # didn't exit, all tokens found in the same record\n        msg = \"Tokens {} found in the following record:  {}  {!r}\".format(\n            tokens, record.levelname, record.message)\n        self.test_instance.fail(msg)", "response": "Check that the different tokens were NOT logged in one record assert by level."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the consumers list.", "response": "def get_consumers(self, _Consumer, channel):\n        \"\"\"\n        | ConsumerMixin requirement.\n        | Get the consumers list.\n\n        :returns: All the consumers.\n        :rtype: list.\n        \"\"\"\n        return [_Consumer(queues=[self.queue(channel)], callbacks=[self.main_callback], prefetch_count=self.prefetch_count)]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(self, *args, **kwargs):#pylint:disable=unused-argument\n        forever = kwargs.get('forever', True)\n        timeout = kwargs.get('timeout', None)\n        if forever:\n            return self.run(timeout=timeout)\n        elif timeout:\n            next((self.consume(timeout=timeout)), None)\n        else:\n            next((self.consume(limit=1, timeout=timeout)), None)", "response": "| Launch the consumer.\n        | It can listen forever for messages or just wait for one.\n\n        :param forever: If set, the consumer listens forever. Default to `True`.\n        :type forever: bool\n        :param timeout: If set, the consumer waits the specified seconds before quitting.\n        :type timeout: None, int\n        :rtype: None\n        :raises socket.timeout: when no message has been received since `timeout`."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef modelserializer_factory(model, serializer=None, fields=None, exclude=None):\n\n    # default values\n    serializer = serializer or serializers.ModelSerializer\n\n    attrs = {'model': model}\n    if fields == '__all__':\n        opts = model._meta.concrete_model._meta\n        attrs['fields'] = [field.name for field in opts.fields if field.serialize]\n    elif fields is not None:\n        attrs['fields'] = fields\n    if exclude is not None:\n        attrs['exclude'] = exclude\n\n    # create meta class\n    parent = (object,)\n    Meta = type('Meta', parent, attrs)\n\n    # Give this new serializer class a reasonable name.\n    class_name = model.__name__ + 'Serializer'\n\n    # Class attributes for the new serializer class.\n    serializer_class_attrs = {\n        'Meta': Meta,\n    }\n    return type(serializer)(class_name, (serializer,), serializer_class_attrs)", "response": "Returns a new ModelSerializer containing fields for the given model."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts value into map object or returns default when conversion is not possible.", "response": "def to_map_with_default(value, default_value):\n        \"\"\"\n        Converts value into map object or returns default when conversion is not possible\n\n        :param value: the value to convert.\n\n        :param default_value: the default value.\n\n        :return: map object or emptu map when conversion is not supported.\n        \"\"\"\n        result = MapConverter.to_nullable_map(value)\n        return result if result != None else default_value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the current config path.", "response": "def get_kube_path():\n    \"\"\"Get the current config path. If the KUBECONFIG environment \n    parameter is set, use it. If multiple paths are listed in \n    KUBECONFIG, use the first path.\n    \"\"\"\n    try:\n        path = pathlib.Path(os.environ[\"KUBECONFIG\"].split(':')[0])\n    except KeyError:\n        path = pathlib.Path.home().joinpath('.kube', 'config')\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nopen a kube config file. If the file does not exist it creates a new file.", "response": "def open(self, create_if_not_found=True):\n        \"\"\"Open a kube config file. If the file does not\n        exist, it creates a new file.\n        \"\"\"\n        try:\n            self.data = self._read()\n        # If the file does\n        except FileNotFoundError as e: \n            if create_if_not_found is True:\n                self.data = {}\n            else: \n                raise e\n\n        # Enforce the following keys exists in data.\n        if 'clusters' not in self.data:\n            self.data['clusters'] = []\n        if 'contexts' not in self.data:\n            self.data['clusters'] = []\n        if 'users' not in self.data:\n            self.data['users'] = []\n        if 'apiVersion' not in self.data:\n            self.data['apiVersion'] = 'v1'\n        if 'kind' not in self.data:\n            self.data['kind'] = 'Config'\n        if 'preferences' not in self.data:\n            self.data['preferences'] = {}\n        if 'current-context' not in self.data:\n            self.data['current-context'] = ''\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read(self):\n        stream = self.path.read_text()\n        data = yaml.load(stream)\n        return data", "response": "Read the kube config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _write(self, data):\n        stream = yaml.dump(data, default_flow_style=False)\n        self.path.write_text(stream)", "response": "Write data to config file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if a given cluster exists.", "response": "def cluster_exists(self, name):\n        \"\"\"Check if a given cluster exists.\"\"\"\n        clusters = self.data['clusters']\n        for cluster in clusters:\n            if cluster['name'] == name:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget cluster from kubeconfig.", "response": "def get_cluster(self, name):\n        \"\"\"Get cluster from kubeconfig.\"\"\"\n        clusters = self.data['clusters']\n        for cluster in clusters:\n            if cluster['name'] == name:\n                return cluster\n        raise KubeConfError(\"Cluster name not found.\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_clusters(self, names=False):\n        clusters = self.get_clusters()\n        if names:\n            clusters = [cluster['name'] for cluster in clusters]\n        pprint.pprint(clusters)", "response": "Print the cluster names."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_cluster(\n        self, \n        name, \n        server=None,\n        certificate_authority_data=None,\n        **attrs):\n        \"\"\"Add a cluster to config.\"\"\"\n        if self.cluster_exists(name):\n            raise KubeConfError(\"Cluster with the given name already exists.\")\n\n        clusters = self.get_clusters()\n        \n        # Add parameters.\n        new_cluster = {'name': name, 'cluster':{}}\n        attrs_ = new_cluster['cluster']\n        if server is not None:\n            attrs_['server'] = server\n        if certificate_authority_data is not None:\n            attrs_['certificate-authority-data'] = certificate_authority_data\n\n        attrs_.update(attrs)\n        clusters.append(new_cluster)", "response": "Add a cluster to config."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_to_cluster(self, name, **attrs):\n        cluster = self.get_cluster(name=name)\n        attrs_ = cluster['cluster']\n        attrs_.update(**attrs)", "response": "Add attributes to a cluster."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_from_cluster(self, name, *args):\n        cluster = self.get_cluster(name=name)\n        attrs_ = cluster['cluster']\n        for a in args:\n            del attrs_[a]", "response": "Remove attributes from a cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_cluster(self, name):\n        cluster = self.get_cluster(name)\n        clusters = self.get_clusters()\n        clusters.remove(cluster)", "response": "Remove a cluster from kubeconfig."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef user_exists(self, name):\n        users = self.data['users']\n        for user in users:\n            if user['name'] == name:\n                return True\n        return False", "response": "Check if a given user exists."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting user from kubeconfig.", "response": "def get_user(self, name):\n        \"\"\"Get user from kubeconfig.\"\"\"\n        users = self.data['users']\n        for user in users:\n            if user['name'] == name:\n                return user\n        raise KubeConfError(\"user name not found.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a user to config.", "response": "def add_user(\n        self,\n        name, \n        **attrs\n        ):\n        \"\"\"Add a user to config.\"\"\"\n        if self.user_exists(name):\n            raise KubeConfError(\"user with the given name already exists.\")\n\n        users = self.get_users()\n        \n        # Add parameters.\n        new_user = {'name': name, 'user':{}}\n        attrs_ = new_user['user']\n        attrs_.update(attrs)\n        users.append(new_user)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_to_user(self, name, **attrs):\n        user = self.get_user(name=name)\n        attrs_ = user['user']\n        attrs_.update(**attrs)", "response": "Add attributes to a user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_from_user(self, name, *args):\n        user = self.get_user(name=name)\n        attrs_ = user['user']\n        for a in args:\n            del attrs_[a]", "response": "Remove attributes from a user."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a user from kubeconfig.", "response": "def remove_user(self, name):\n        \"\"\"Remove a user from kubeconfig.\n        \"\"\"\n        user = self.get_user(name)\n        users = self.get_users()\n        users.remove(user)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding an exec option to your user.", "response": "def add_exec_to_user(\n        self, \n        name,\n        env,\n        command,\n        args,\n        **attrs\n        ):\n        \"\"\"Add an exec option to your user.\"\"\"\n        # Add exec option.\n        exec_options = {\n            'command': command,\n            'env': env,\n            'args': args,\n        }\n        exec_options.update(attrs)\n        # Add exec to user.\n        self.add_to_user(name=name, exec=exec_options)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if a given context exists.", "response": "def context_exists(self, name):\n        \"\"\"Check if a given context exists.\"\"\"\n        contexts = self.data['contexts']\n        for context in contexts:\n            if context['name'] == name:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_context(self, name):\n        contexts = self.data['contexts']\n        for context in contexts:\n            if context['name'] == name:\n                return context\n        raise KubeConfError(\"context name not found.\")", "response": "Get context from kubeconfig."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting the contexts of the current user.", "response": "def print_contexts(self, names=False):\n        \"\"\"Print users\"\"\"\n        contexts = self.get_contexts()\n        if names:\n            contexts = [context['name'] for context in contexts]\n        pprint.pprint(contexts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_context(\n        self,\n        name,\n        cluster_name=None,\n        user_name=None,\n        namespace_name=None,\n        **attrs\n        ):\n        \"\"\"Add a context to config.\"\"\"\n        if self.context_exists(name):\n            raise KubeConfError(\"context with the given name already exists.\")\n\n        contexts = self.get_contexts()\n        \n        # Add parameters.\n        new_context = {'name': name, 'context':{}}\n        \n        # Add attributes\n        attrs_ = new_context['context']\n        if cluster_name is not None:\n            attrs_['cluster'] = cluster_name\n        if user_name is not None:\n            attrs_['user'] = user_name\n        if namespace_name is not None:\n            attrs_['namespace'] = namespace_name\n        attrs_.update(attrs)\n\n        contexts.append(new_context)", "response": "Add a context to the config."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_to_context(self, name, **attrs):\n        context = self.get_context(name=name)\n        attrs_ = context['context']\n        attrs_.update(**attrs)", "response": "Add attributes to a context."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_from_context(self, name, *args):\n        context = self.get_context(name=name)\n        attrs_ = context['context']\n        for a in args:\n            del attrs_[a]", "response": "Remove attributes from a context."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove a context from kubeconfig.", "response": "def remove_context(self, name):\n        \"\"\"Remove a context from kubeconfig.\n        \"\"\"\n        context = self.get_context(name)\n        contexts = self.get_contexts()\n        contexts.remove(context)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the current context in kubeconfig.", "response": "def set_current_context(self, name):\n        \"\"\"Set the current context in kubeconfig.\"\"\"\n        if self.context_exists(name):\n            self.data['current-context'] = name\n        else:\n            raise KubeConfError(\"Context does not exist.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef configure_logging(self, verbosity_lvl=None, format='%(message)s'):\n        if not verbosity_lvl:\n            verbosity_lvl = logging.INFO\n        logging.basicConfig(format=format)\n        self.logger.setLevel(verbosity_lvl)", "response": "Switches on logging at a given level."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the given shell command.", "response": "def _run_shell_command(self, command, pipe_it=True):\n        \"\"\"Runs the given shell command.\n\n        :param command:\n        :return: bool Status\n        \"\"\"\n        stdout = None\n        if pipe_it:\n            stdout = PIPE\n        self.logger.debug('Executing shell command: %s' % command)\n        return not bool(Popen(command, shell=True, stdout=stdout).wait())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_manage_command(self, command, venv_path, verbose=True):\n        self.logger.debug('Running manage command `%s` for `%s` ...' % (command, venv_path))\n        self._run_shell_command(\n            '. %s/bin/activate && python %s %s' % (venv_path, self._get_manage_py_path(), command),\n            pipe_it=(not verbose))", "response": "Runs a given Django manage command in a given virtual environment."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef venv_install(self, package_name, venv_path):\n        self.logger.debug('Installing `%s` into `%s` ...' % (package_name, venv_path))\n        self._run_shell_command('. %s/bin/activate && pip install -U %s' % (venv_path, package_name))", "response": "Installs a given python package into a given virtual environment."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a virtual environment for a given Django version.", "response": "def make_venv(self, dj_version):\n        \"\"\"Creates a virtual environment for a given Django version.\n\n        :param str dj_version:\n        :rtype: str\n        :return: path to created virtual env\n        \"\"\"\n        venv_path = self._get_venv_path(dj_version)\n        self.logger.info('Creating virtual environment for Django %s ...' % dj_version)\n        try:\n            create_venv(venv_path, **VENV_CREATE_KWARGS)\n        except ValueError:\n            self.logger.warning('Virtual environment directory already exists. Skipped.')\n        self.venv_install('django==%s' % dj_version, venv_path)\n        return venv_path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_apps_dir(self):\n        self.logger.info('Creating a directory for symlinks to your Django applications `%s` ...' % self.apps_path)\n        try:\n            os.mkdir(self.apps_path)\n        except OSError:\n            pass  # Already exists.\n        return self.apps_path", "response": "Creates an empty directory for symlinks to Django applications."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dispatch_op(self, op_name, args_dict):\n        self.logger.debug('Requested `%s` command with `%s` args.' % (op_name, args_dict))\n        method = getattr(self, 'op_%s' % op_name, None)\n        if method is None:\n            error_str = '`%s` command is not supported.' % op_name\n            self.logger.error(error_str)\n            raise DjangoDevException(error_str)\n        method(**args_dict)\n        self.logger.info('Done.')", "response": "Dispatches an operation requested."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of names of available virtual environments.", "response": "def get_venvs(self):\n        \"\"\"Returns a list of names of available virtual environments.\n\n        :raises: DjangoDevException on errors\n        :rtype: list\n        :return: list of names\n        \"\"\"\n\n        def raise_():\n            error_str = 'Virtual environments are not created. Please run `bootstrap` command.'\n            self.logger.error(error_str)\n            raise DjangoDevException(error_str)\n\n        if not os.path.exists(self.venvs_path):\n            raise_()\n        venvs = os.listdir(self.venvs_path)\n        if not venvs:\n            raise_()\n\n        venvs.sort()\n        return venvs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_apps(self, only=None):\n        if not os.path.exists(self.apps_path):\n            error_str = 'It seems that this directory does not contain django-dev project. ' \\\n                        'Use `bootstrap` command to create project in the current directory.'\n            self.logger.error(error_str)\n            raise DjangoDevException(error_str)\n\n        apps = os.listdir(self.apps_path)\n\n        if not apps:\n            error_str = 'Applications directory is empty. ' \\\n                        'Please symlink your apps (and other apps that you apps depend upon) into %s' % self.apps_path\n            self.logger.error(error_str)\n            raise DjangoDevException(error_str)\n\n        apps.sort()\n        if only is None:\n            self.create_manage_py(apps)\n            return apps\n\n        diff = set(only).difference(apps)\n        if diff:\n            error_str = 'The following apps are not found: `%s`.' % ('`, `'.join(diff))\n            self.logger.error(error_str)\n            raise DjangoDevException(error_str)\n\n        self.create_manage_py(apps)\n\n        return [name for name in apps if name in only]", "response": "Returns a list of names of available Django applications and optionally filters it using only."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate manage. py file with a given list of installed apps.", "response": "def create_manage_py(self, apps):\n        \"\"\"Creates manage.py file, with a given list of installed apps.\n\n        :param list apps:\n        \"\"\"\n        self.logger.debug('Creating manage.py ...')\n        with open(self._get_manage_py_path(), mode='w') as f:\n            south_migration_modules = []\n            for app in apps:\n                south_migration_modules.append(\"'%(app)s': '%(app)s.south_migrations'\" % {'app': app})\n\n            f.write(MANAGE_PY % {\n                'apps_available': \"', '\".join(apps),\n                'apps_path': self.apps_path,\n                'south_migration_modules': \", \".join(south_migration_modules)\n\n\n            })"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints out and returns a list of known virtual environments.", "response": "def op_list_venvs(self):\n        \"\"\"Prints out and returns a list of known virtual environments.\n\n        :rtype: list\n        :return: list of virtual environments\n        \"\"\"\n        self.logger.info('Listing known virtual environments ...')\n        venvs = self.get_venvs()\n        for venv in venvs:\n            self.logger.info('Found `%s`' % venv)\n        else:\n            self.logger.info('No virtual environments found in `%s` directory.' % VENVS_DIRNAME)\n        return venvs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef op_list_apps(self):\n        self.logger.info('Listing known applications ...')\n        apps = self.get_apps()\n        for app in apps:\n            self.logger.info('Found `%s`' % app)\n        else:\n            self.logger.info('\\nDONE. No applications found in `%s` directory.\\n' % APPS_DIRNAME)\n        return apps", "response": "Prints out and returns a list of known applications."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef op_bootstrap(self):\n        self.logger.info('Bootstrapping django-dev directory structure in current directory ...')\n        self.make_venv(DJANGO_DEFAULT_VERSION)\n        venv_path = self.make_venv('1.6.5')\n        self.venv_install('south==1.0.1', venv_path)\n        apps_dir = self.make_apps_dir()\n        self.logger.info('Now you may symlink (ln -s) your apps '\n                         '(and other apps that you apps depend upon) into %s' % apps_dir)", "response": "Bootstraps django - dev by creating required directory structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninstalls packages into virtual envs as to satisfy app requirements.", "response": "def op_install_package(self, names):\n        \"\"\"Install packages into virtual envs as to satisfy app requirements.\n\n        Exact version numbers could be given as in PIP: somedep==1.5\n\n        :param list names:\n\n        \"\"\"\n        venvs = self.get_venvs()\n        for venv in venvs:\n            for name in names:\n                self.venv_install(name, self._get_venv_path(venv))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef op_make_trans(self, locales=None, apps=None):\n        self.logger.info('Making translations ...')\n        apps = self.get_apps(only=apps)\n        self.get_venvs()  # Sentinel.\n        venv_path = self._get_venv_path(DJANGO_DEFAULT_VERSION)\n        if locales is None:\n            locales = []\n\n        for app_name in apps:\n            self.logger.info('Application: %s' % app_name)\n            app_path = self._get_app_path(app_name)\n            locales_path = os.path.join(app_path, 'locale')\n\n            if not locales and os.path.exists(locales_path):  # Getting all existing locales.\n                locales = os.listdir(locales_path)\n\n            for lang in locales:\n                self.logger.info('Locale: %s' % lang)\n                locale_path = os.path.join(locales_path, '%s/LC_MESSAGES' % lang)\n                self._make_dirs(locale_path)\n                old_wd = os.getcwd()\n                os.chdir(app_path)\n                self.run_manage_command('makemessages -l %s' % lang, venv_path)\n                self.run_manage_command('compilemessages -l %s' % lang, venv_path)\n                os.chdir(old_wd)", "response": "Creates and updates the localization files for the given list of locales and apps."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite an 8 - bit value to a register.", "response": "def _write8(self, reg, value):\n        \"\"\"Write a 8-bit value to a register.\"\"\"\n        self.i2c.write8(TCS34725_COMMAND_BIT | reg, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_interrupt_limits(self, low, high):\n        self.i2c.write8(0x04, low & 0xFF)\n        self.i2c.write8(0x05, low >> 8)\n        self.i2c.write8(0x06, high & 0xFF)\n        self.i2c.write8(0x07, high >> 8)", "response": "Set the interrupt limits to provied unsigned 16 - bit threshold values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_sint(self):\n        if self._width == 0:\n            return BinInt(0)\n        sbit = 1 << (self._width - 1)\n        return BinInt((self._val - sbit) ^ -sbit)", "response": "Converts the word to a BinInt treating it as a signed number."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sar(self, count):\n        count = operator.index(count)\n        if count < 0:\n            raise ValueError('negative shift')\n        if count > self._width:\n            count = self._width\n        return BinWord(self._width, self.to_sint() >> count, trunc=True)", "response": "Performs an arithmetic right - shift of a BinWord by the given number of bits."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a BinWord with the sign extending the word to a larger width.", "response": "def sext(self, width):\n        \"\"\"Sign-extends a word to a larger width.  It is an error to specify\n        a smaller width (use ``extract`` instead to crop off the extra bits).\n        \"\"\"\n        width = operator.index(width)\n        if width < self._width:\n            raise ValueError('sign extending to a smaller width')\n        return BinWord(width, self.to_sint(), trunc=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nzeroes - extends a word to a larger width.", "response": "def zext(self, width):\n        \"\"\"Zero-extends a word to a larger width.  It is an error to specify\n        a smaller width (use ``extract`` instead to crop off the extra bits).\n        \"\"\"\n        width = operator.index(width)\n        if width < self._width:\n            raise ValueError('zero extending to a smaller width')\n        return BinWord(width, self._val)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomparing two equal - sized BinWords treating them as signed integers returning True if the first is smaller.", "response": "def slt(self, other):\n        \"\"\"Compares two equal-sized BinWords, treating them as signed\n        integers, and returning True if the first is smaller.\n        \"\"\"\n        self._check_match(other)\n        return self.to_sint() < other.to_sint()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomparing two equal - sized BinWords treating them as signed integers returning True if the first is smaller or equal.", "response": "def sle(self, other):\n        \"\"\"Compares two equal-sized BinWords, treating them as signed\n        integers, and returning True if the first is smaller or equal.\n        \"\"\"\n        self._check_match(other)\n        return self.to_sint() <= other.to_sint()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompares two equal - sized BinWords treating them as signed integers returning True if the first is bigger.", "response": "def sgt(self, other):\n        \"\"\"Compares two equal-sized BinWords, treating them as signed\n        integers, and returning True if the first is bigger.\n        \"\"\"\n        self._check_match(other)\n        return self.to_sint() > other.to_sint()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sge(self, other):\n        self._check_match(other)\n        return self.to_sint() >= other.to_sint()", "response": "Compares two equal - sized BinWords treating them as signed\n        integers returning True if the first is bigger or equal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef concat(cls, *args):\n        width = 0\n        val = 0\n        for arg in args:\n            if not isinstance(arg, BinWord):\n                raise TypeError('need BinWord in concat')\n            val |= arg._val << width\n            width += arg._width\n        return cls(width, val)", "response": "Returns a BinWord made from concatenating several BinWords in LSB - first order."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npredict the maximum - likelihoo response for a given set of tokens.", "response": "def predict(self, x):\n        \"\"\"\n        Take in an integer-vectorized (i.e., index) vector, and predict the maximally\n        likely response, returning it as an integer-vectorized (i.e., index) vector.\n        \"\"\"\n        recurrent_unit = self.config['recurrent-unit-type']\n        \n        # encode the input seq into a context vector\n        if recurrent_unit == 'lstm':\n            context_state = self.encoder.predict(np.array(x))\n        elif recurrent_unit == 'gru':\n            hidden_state = self.encoder.predict(np.array(x))\n            context_state = [hidden_state]\n        else:\n            raise Exception('Invalid recurrent unit type: {}'.format(recurrent_unit))\n        \n        # create an empty target sequence, seeded with the start character\n        y = self.vectorizer.vectorize_utterance([self.config['start']])\n        response = []\n        \n        # i = 0\n        while True:\n            \n            # decode the current sequence + current context into a\n            # conditional distribution over next token:\n            output_token_probs = None\n            if recurrent_unit == 'lstm':\n                output_token_probs, h, c = self.decoder.predict([y] + context_state)\n                context_state = [h, c]\n            elif recurrent_unit == 'gru':\n                output_token_probs, hidden_state = self.decoder.predict([y] + context_state)\n                context_state = [hidden_state]\n            else:\n                raise Exception('Invalid recurrent unit type: {}'.format(recurrent_unit))\n            \n            # sample a token from the output distribution (currently using maximum-likelihoo -- i.e., argmax)\n            sampled_token = np.argmax(output_token_probs[0, -1, :])\n            \n            # add the sampled token to our output string\n            response += [sampled_token]\n            \n            # exit condition: either we've\n            # - hit the max length (self.data.output_max_len), or\n            # - decoded a stop token ('\\n')\n            if (sampled_token == self.vectorizer.ie.transform([self.config['stop']]) or \n                len(response) >= self.config['max-utterance-length']):\n                break\n                \n            # update the np array (target seq)\n            y = np.array([sampled_token]) # np.concatenate((y, [sampled_token]))\n            \n        return response"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the sort function for the given TreeSortable.", "response": "def set_sort_function(sortable, callback, column=0):\n    \"\"\"\n    *sortable* is a :class:`gtk.TreeSortable` instance.\n\n    *callback* will be passed two items and must return a value like\n    the built-in `cmp`.\n\n    *column* is an integer adressing the column that holds items.\n\n    This will re-sort even if *callback* is the same as before.\n\n    .. note::\n       When sorting a `ListStore` without a `TreeModelSort` you have to call\n       `set_sort_column_id(-1, gtk.SORT_ASCENDING)` once, *after* this.\n    \"\"\"\n    sortable.set_default_sort_func(\n        lambda tree, itera, iterb: _normalize(callback(\n            tree.get_value(itera, column),\n            tree.get_value(iterb, column)\n            ))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a function that sorts the objects in the order passed in.", "response": "def get_sort_function(order):\n    \"\"\"\n    Returns a callable similar to the built-in `cmp`, to be used on objects.\n\n    Takes a list of dictionaries. In each, 'key' must be a string that is\n    used to get an attribute of the objects to compare, and 'reverse' must\n    be a boolean indicating whether the result should be reversed.\n    \"\"\"\n    stable = tuple((d['key'], -1 if d['reverse'] else 1) for d in order)\n    def sort_function(a, b):\n        for name, direction in stable:\n            v = cmp(getattr(a, name) if a else a, getattr(b, name) if b else b)\n            if v != 0:\n                return v * direction\n        return 0\n    return sort_function"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_order(self):\n        return [dict(reverse=r[0], key=r[1]) for r in self.get_model()]", "response": "Return a list of dicionaries. See set_order."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the order of the items in the list store.", "response": "def set_order(self, order):\n        \"\"\"\n        Takes a list of dictionaries. Those correspond to the arguments of\n        `list.sort` and must contain the keys 'key' and 'reverse' (a boolean).\n\n        You must call `set_labels` before this!\n        \"\"\"\n        m = gtk.ListStore(bool, str)\n        for item in order:\n            m.append(\n                (item['reverse'], item['key'])\n                )\n        # TODO fill with __labels missing in order.\n        self.set_model(m)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pad_dialogues(self, dialogues):\n        \n        self.log('info', 'Padding the dialogues ...')\n        \n        empty_turn = [self.config['pad-d']] * (self.properties['max-utterance-length'] + 1)\n        \n        for i, d in enumerate(dialogues):\n            for j, u in enumerate(d):\n                dif = self.properties['max-utterance-length'] - len(u) + 1\n                dialogues[i][j] += [self.config['pad-u']] * dif\n                \n            # only pad the dialogue if we're training a hierarchical model\n            if self.config['hierarchical']:\n                dif = self.properties['max-dialogue-length'] - len(d)\n                dialogues[i] += [empty_turn] * dif\n        \n        return dialogues", "response": "Pads the dialogues in the dataset to the max size of the dialogues."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef allow_domain(self, domain, to_ports=None, secure=True):\n        if self.site_control == SITE_CONTROL_NONE:\n            raise TypeError(\n                METAPOLICY_ERROR.format(\"allow a domain\")\n            )\n        self.domains[domain] = {'to_ports': to_ports,\n                                'secure': secure}", "response": "Allow access from a domain."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef metapolicy(self, permitted):\n        if permitted not in VALID_SITE_CONTROL:\n            raise TypeError(SITE_CONTROL_ERROR.format(permitted))\n        if permitted == SITE_CONTROL_NONE:\n            # Metapolicy 'none' means no access is permitted.\n            self.domains = {}\n            self.header_domains = {}\n            self.identities = []\n        self.site_control = permitted", "response": "Sets the metapolicy to permitted."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nallows the given headers from a domain.", "response": "def allow_headers(self, domain, headers, secure=True):\n        \"\"\"\n        Allows ``domain`` to push data via the HTTP headers named in\n        ``headers``.\n\n        As with ``allow_domain``, ``domain`` may be either a full\n        domain name or a wildcard. Again, use of wildcards is\n        discouraged for security reasons.\n\n        The value for ``headers`` should be a list of header names.\n\n        To disable Flash's requirement of security matching (e.g.,\n        retrieving a policy via HTTPS will require that SWFs also be\n        retrieved via HTTPS), pass ``secure=False``. Due to security\n        concerns, it is strongly recommended that you not disable\n        this.\n\n        \"\"\"\n        if self.site_control == SITE_CONTROL_NONE:\n            raise TypeError(\n                METAPOLICY_ERROR.format(\"allow headers from a domain\")\n            )\n        self.header_domains[domain] = {'headers': headers,\n                                       'secure': secure}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nallows access from documents digitally signed by the key with fingerprint.", "response": "def allow_identity(self, fingerprint):\n        \"\"\"\n        Allows access from documents digitally signed by the key with\n        ``fingerprint``.\n\n        In theory, multiple algorithms can be added in the future for\n        calculating ``fingerprint`` from the signing key, but at this\n        time only one algorithm -- SHA-1 -- is supported by the\n        cross-domain policy specification.\n\n        \"\"\"\n        if self.site_control == SITE_CONTROL_NONE:\n            raise TypeError(\n                METAPOLICY_ERROR.format(\"allow access from signed documents\")\n            )\n        if fingerprint not in self.identities:\n            self.identities.append(fingerprint)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates the XML elements for allowed domains.", "response": "def _add_domains_xml(self, document):\n        \"\"\"\n        Generates the XML elements for allowed domains.\n\n        \"\"\"\n        for domain, attrs in self.domains.items():\n            domain_element = document.createElement('allow-access-from')\n            domain_element.setAttribute('domain', domain)\n            if attrs['to_ports'] is not None:\n                domain_element.setAttribute(\n                    'to-ports',\n                    ','.join(attrs['to_ports'])\n                )\n            if not attrs['secure']:\n                domain_element.setAttribute('secure', 'false')\n            document.documentElement.appendChild(domain_element)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates the XML elements for allowed header domains.", "response": "def _add_header_domains_xml(self, document):\n        \"\"\"\n        Generates the XML elements for allowed header domains.\n\n        \"\"\"\n        for domain, attrs in self.header_domains.items():\n            header_element = document.createElement(\n                'allow-http-request-headers-from'\n            )\n            header_element.setAttribute('domain', domain)\n            header_element.setAttribute('headers', ','.join(attrs['headers']))\n            if not attrs['secure']:\n                header_element.setAttribute('secure', 'false')\n            document.documentElement.appendChild(header_element)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd the XML elements for the identities of the current resource.", "response": "def _add_identities_xml(self, document):\n        \"\"\"\n        Generates the XML elements for allowed digital signatures.\n\n        \"\"\"\n        for fingerprint in self.identities:\n            identity_element = document.createElement(\n                'allow-access-from-identity'\n            )\n            signatory_element = document.createElement(\n                'signatory'\n            )\n            certificate_element = document.createElement(\n                'certificate'\n            )\n            certificate_element.setAttribute(\n                'fingerprint',\n                fingerprint)\n            certificate_element.setAttribute(\n                'fingerprint-algorithm',\n                'sha-1')\n            signatory_element.appendChild(certificate_element)\n            identity_element.appendChild(signatory_element)\n            document.documentElement.appendChild(identity_element)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_xml_dom(self):\n        if self.site_control == SITE_CONTROL_NONE and \\\n           any((self.domains, self.header_domains, self.identities)):\n            raise TypeError(BAD_POLICY)\n\n        policy_type = minidom.createDocumentType(\n            qualifiedName='cross-domain-policy',\n            publicId=None,\n            systemId='http://www.adobe.com/xml/dtds/cross-domain-policy.dtd'\n        )\n        policy = minidom.createDocument(\n            None,\n            'cross-domain-policy',\n            policy_type\n        )\n\n        if self.site_control is not None:\n            control_element = policy.createElement('site-control')\n            control_element.setAttribute(\n                'permitted-cross-domain-policies',\n                self.site_control\n            )\n            policy.documentElement.appendChild(control_element)\n\n        for elem_type in ('domains', 'header_domains', 'identities'):\n            getattr(self, '_add_{}_xml'.format(elem_type))(policy)\n\n        return policy", "response": "Returns an xml. dom. minidom. Document representing the corresponding cross - domain policy XML."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reverse_with_query(named_url,**kwargs):\n    \"Reverse named URL with GET query\"\n    q = QueryDict('',mutable=True)\n    q.update(kwargs)\n    return '{}?{}'.format(reverse(named_url),q.urlencode())", "response": "Reverse named URL with GET query"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreverse named URL with GET query ( lazy version )", "response": "def reverse_lazy_with_query(named_url,**kwargs):\n    \"Reverse named URL with GET query (lazy version)\"\n    q = QueryDict('',mutable=True)\n    q.update(kwargs)\n    return '{}?{}'.format(reverse_lazy(named_url),q.urlencode())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of URLs for creating updating and deleting models.", "response": "def urls(model,form_class=None,fields=None,redirect=None,object_list=None,fail_if_empty=True):\n    \"\"\"\n    Returns URL patterns for creating, updating and deleting models. Supports lists and formsets as well\n    \n    model          Model class\n    form_class     Form class for use in create, update and formset views (default is None)\n    fields         Required if form_class is not provided\n    redirect       Redirection URL for create, update and delete views\n    object_list    Queryset for list and formset. If absent, these views are not created\n    fail_if_empty  Raise ImproperlyConfigured exception in formset and list views when object_list is empty\n    \"\"\"\n    \n    if form_class is None and fields is None:\n        raise ImproperlyConfigured(\"Must define either `form_class` or `fields`.\")\n    \n    if object_list is None and redirect is None:\n        raise ImproperlyConfigured(\"Must define `redirect` when `object_list` is missing.\")\n    \n    prefix = model.__name__.lower()\n    if redirect is None: redirect = reverse_lazy(prefix + '_list')\n    \n    urlpatterns = patterns('',\n        # Create a new record\n        url('^' + prefix + '/create/',\n            CreateView.as_view(model=model,form_class=form_class,fields=fields,success_url=redirect),\n            name = prefix + '_create'\n        ),\n                            \n        # Update record 'pk'\n        url('^' + prefix + '/update/(?P<pk>\\d+)/',\n            UpdateView.as_view(model=model,form_class=form_class,fields=fields,success_url=redirect),\n            name = prefix + '_update'\n        ),\n        \n        # Delete record 'pk'\n        url('^' + prefix + '/delete/(?P<pk>\\d+)/',\n            DeleteView.as_view(model=model,success_url=redirect),\n            name = prefix + '_delete'\n        ),                            \n    )\n    \n    if object_list:\n        urlpatterns += patterns('',\n            # List records\n            url('^' + prefix + '/list/',\n                ListView.as_view(model=model,object_list=object_list,fail_if_empty=fail_if_empty),\n                name = prefix + '_list'\n            ),\n                                \n            # Edit records using a formset\n            url('^' + prefix + '/formset/',\n                FormsetView.as_view(model=model,form_class=form_class,fields=fields,object_list=object_list,fail_if_empty=fail_if_empty),\n                name = prefix + '_formset'\n            ),\n        )\n\n    \n    return urlpatterns"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the current session can be undoed.", "response": "def can_undo(self):\n        \"\"\"\n        Are there actions to undo?\n        \"\"\"\n        return bool(self._undo) or bool(self._open and self._open[0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef end_grouping(self):\n        close = self._open.pop()\n        if not close:\n            return\n        if self._open:\n            self._open[-1].extend(close)\n        elif self._undoing:\n            self._redo.append(close)\n        else:\n            self._undo.append(close)\n        self.notify()", "response": "Raises IndexError when no group is open."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform the top group on the redo stack. Returns None if no redo was performed.", "response": "def redo(self):\n        \"\"\"\n        Performs the top group on the redo stack, if present. Creates an undo\n        group with the same name. Raises RuntimeError if called while undoing.\n        \"\"\"\n        if self._undoing or self._redoing:\n            raise RuntimeError\n        if not self._redo:\n            return\n        group = self._redo.pop()\n\n        self._redoing = True\n\n        self.begin_grouping()\n        group.perform()\n        self.set_action_name(group.name)\n        self.end_grouping()\n\n        self._redoing = False\n\n        self.notify()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register(self, func, *args, **kwargs):\n        self._open[-1].append(UndoOperation(func, *args, **kwargs))\n        if not (self._undoing or self._redoing):\n            self._redo = []\n        self.notify()", "response": "Register a function to be called when a new entry is created."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_action_name(self, name):\n        if self._open and name is not None:\n            self._open[-1].name = name\n            self.notify()", "response": "Set the name of the action that the user is interested in."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nundo the current state of the current element.", "response": "def undo(self):\n        \"\"\"\n        Raises IndexError if more than one group is open, otherwise closes it\n        and invokes undo_nested_group.\n        \"\"\"\n        if self.grouping_level() == 1:\n            self.end_grouping()\n        if self._open:\n            raise IndexError\n        self.undo_nested_group()\n        self.notify()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef undo_action_name(self):\n        if self._open:\n            return self._open[-1].name\n        elif self._undo:\n            return self._undo[-1].name\n        return \"\"", "response": "Returns the name of the current undo stack entry or an empty string if the undo stack entry is empty."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef undo_nested_group(self):\n        if self._undoing or self._redoing:\n            raise RuntimeError\n        if self._open:\n            group = self._open.pop()\n        elif self._undo:\n            group = self._undo.pop()\n        else:\n            return\n\n        self._undoing = True\n\n        self.begin_grouping()\n        group.perform()\n        self.set_action_name(group.name)\n        self.end_grouping()\n\n        self._undoing = False\n\n        self.notify()", "response": "Performs the last group opened or the top group on the undo stack."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nseparate structured data into a list of actives or decoys.", "response": "def splitter(structured):\n    \"\"\"\n    Separates structured data into a list of actives or a list of decoys. actives are labeled with a '1' in their status\n    fields, while decoys are labeled with a '0' in their status fields.\n    :param structured: either roc_structure or score_structure.\n    roc_structure: list [(id, best_score, best_query, status, fpf, tpf), ..., ]\n    score_structure: list [(id, best_score, best_query, status, net decoy count, net active count), ...,]\n    :return: actives: list [(id, best_score, best_query, status = 1, fpf/net decoy count, tpf/net active count), ..., ]\n    :return decoys: list [(id, best_score, best_query, status = 0, fpf/net decoy count, tpf/net active count), ..., ]\n    \"\"\"\n\n    actives = []\n    decoys = []\n    for mol in structured:\n        status = mol[3]\n        if status == '1':\n            actives.append(mol)\n        elif status == '0':\n            decoys.append(mol)\n    return actives, decoys"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_acd(acd_structure, fpf):\n\n    # initialize variables\n    fw_dict = defaultdict(int) # a count of the number of molecules that share a given framework\n\n    # loop over the molecules in acd_structure and count up the molecules consistent with each unique framework\n    for mol in acd_structure:\n        fw_smiles = mol[4]\n        fw_dict[fw_smiles] += 1\n\n    fw_count = [x[1] for x in fw_dict.items()] # a list of the molecule count consistent with each unique framework\n    fw_count.sort(reverse=True)                # always sort from high to low s.t.: 1 >= ACD >= 0.5\n\n    n_actives = len(acd_structure) # number of active molecules above the fpf threshold\n    n_active_fw = len(fw_count)    # number of unique active frameworks above the fpf threshold\n    # determine the acd\n    acd = (1. / n_actives) * (1. / n_active_fw) * sum(np.cumsum(fw_count))\n\n    return (fpf, acd)", "response": "Calculates the area under the cumulative distribution function of the active framework count and ACD of those active frameworks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef calculate_ef(ef_structure, fpf, diff = None, include_intervals = None):\n\n    # set variables\n    n = len([x for x in ef_structure if x[3] == '0'])          # no of decoys\n    p = len([x for x in ef_structure if x[3] == '1'])          # no of actives\n\n\n    if not fpf:\n        fpf = float(1) / n\n\n    # calculate tpf at fpf threshold tpf = E(gamma)a\n    actives, decoys = splitter(ef_structure)\n    tpf = 0\n    for mol in actives:\n        gamma = mol[4]\n        tpf += gamma\n    tpf = (1. / p) * tpf\n\n    # calculate enrichment factor (ef)\n    ef = tpf / fpf\n\n    if diff:\n        # active & decoy variances are independently determined in the difference calculations\n        return ef, tpf\n    elif include_intervals:\n        # standard error\n        if ef != 0:\n            efvar_a, efvar_d, s2 = calculate_ef_var(tpf, fpf)\n            se = (1 / fpf) * ((efvar_a / p) + s2 * (efvar_d / n) ) ** 0.5\n\n            # 95% confidence interval\n            ci = se * stats.t.ppf(1 - 0.025, n + p - 1)\n\n            # bounds\n            lower = ef - ci\n            upper = ef + ci\n\n            # dumb limit checking (ADD LOGIT FUNCTION)\n            if lower < 0:\n                lower = 0.0\n            if upper > 1 / fpf:\n                upper = 1 / fpf\n\n            return (fpf, ef, lower, upper)\n        else:\n            # when the ef is 0, there's problems with taking its logarithm. This is a\n            # temporary work around put in place 2/12/15.\n            return(fpf, ef, 0, 0)\n    else:\n        decoy_threshold = int(round(n * fpf))   # number of decoys corresponding to fpf\n        return (decoy_threshold, ef)", "response": "Calculates the ROC enrichment factor and confidence intervals at the input false positive fraction fpf."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the variance due to actives decoys and s2 the slope of the ROC curve tangent to the", "response": "def calculate_ef_var(tpf, fpf):\n    \"\"\"\n    determine variance due to actives (efvar_a) decoys (efvar_d) and s2, the slope of the ROC curve tangent to the\n    fpf @ which the enrichment factor was calculated\n    :param tpf: float tpf @ which the enrichment factor was calculated\n    :param fpf: float fpf @ which the enrichment factor was calculated\n    :return efvara, efvard, s2: tuple\n    \"\"\"\n\n    efvara = (tpf * (1 - tpf))\n    efvard = (fpf * (1 - fpf))\n\n    ef = tpf / fpf\n    if fpf == 1:\n        return(0, 0, 0)\n    else:\n        s = ef * ( 1 + (np.log(ef)/np.log(fpf)))\n        s2 = s * s\n        return (efvara, efvard, s2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the difference in enrichment factors and corresponding statistics.", "response": "def calculate_ef_diff(ef_structure1, ef_structure2, fpf):\n    \"\"\"\n    returns the absolute value of the difference in enrichment factors and corresponding statistics.\n    specifically, |ef1 - ef2|, the 95% confidence interval, and the 2-sided p-value\n    :param score_structure_1: list [(id, best_score, best_query, status, net decoy count, net active count), ...,]\n    :param score_structure_2: list [(id, best_score, best_query, status, net decoy count, net active count), ...,]\n    :param fpf: float fpf @ which the enrichment factor was calculated\n    :return EF1-EF2, EF1-EF2 - CI, EF1-EF2 + CI, p-value) : tuple\n    \"\"\"\n\n    ef1, tpf1 = calculate_ef(ef_structure1, fpf, 'diff')\n    ef2, tpf2 = calculate_ef(ef_structure2, fpf, 'diff')\n\n    var1a, var1d, s2_1 = calculate_ef_var(tpf1, fpf)\n    var2a, var2d, s2_2 = calculate_ef_var(tpf2, fpf)\n\n    covara, covard = calculate_ef_covar(ef_structure1, ef_structure2)\n\n    # standard error\n    vardiffa = var2a + var1a - 2 * covara\n    vardiffd = var2d * s2_2 + var1d * s2_1 + 2 * covard * (s2_2 ** 0.5) * (s2_1 ** 0.5)\n\n    p = len([x for x in ef_structure1 if x[3] == '1'])\n    n = len([x for x in ef_structure2 if x[3] == '0'])\n\n    se = (1 / fpf) * ((vardiffa / p) + (vardiffd / n)) ** 0.5\n\n    # 95% confidence interval\n    ci = se * stats.t.ppf(1 - 0.025, n + p - 1)\n\n    # bounds\n    diff = ef1 - ef2\n    lower = diff - ci\n    upper = diff + ci\n\n    # 2-sided p-value\n    tt = ((diff ** 2) ** 0.5)/ se\n    p_value = 2 * stats.t.sf(tt, n + p - 1)\n\n    return (ef1, ef2, diff, (lower, upper), p_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_ef_covar(ef_structure1, ef_structure2):\n\n    # split data by activity class\n    actives1, decoys1 = splitter(ef_structure1)\n    actives2, decoys2 = splitter(ef_structure2)\n\n    # covariance due to actives = E[{gamma2 - E(gamma2)a} * {gamma1 - E(gamma1)a}]a\n    gamma1 = [x[4] for x in actives1]\n    gamma2 = [x[4] for x in actives2]\n    covara = np.cov(gamma1, gamma2)[0][1]\n\n    # covariance due to decoys = E[{gamma2 - E(gamma2)d} * {gamma1 - E(gamma1)d}]\n    gamma1 = [x[4] for x in decoys1]\n    gamma2 = [x[4] for x in decoys2]\n    covard = np.cov(gamma1, gamma2)[0][1]\n\n    return covara, covard", "response": "Calculates the active and decoy covariance of the enrichment factors covara and covard respectively."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the AUC and CI for the given structure.", "response": "def calculate_auc(auc_structure, sort_order, diff = None):\n    \"\"\"\n    TO DO: Add logit bounds\n    determine AUC and 95% confidence intervals (CI)\n    :param roc_structure: auc_structure: list [(id, best_score, best_query, status, fpf, tpf), ..., ]\n    :param sort_order: either 'asc' (binding free energy estimates) or 'dsc' (probabilities)\n    :return (AUC, AUC - CI, AUC + CI): tuple\n    \"\"\"\n\n    # sort by best scores\n    if sort_order == 'asc':\n        auc_structure.sort(key=lambda x: float(x[1]))\n    elif sort_order == 'dsc':\n        auc_structure.sort(key=lambda x: float(x[1]), reverse=True)\n\n    # AUC calculation <tpf>d\n    auc = 0.                         # auc average\n    n = 0                           # decoy count\n    for mol in auc_structure:\n        status = mol[3]\n        if status == '0':\n            tpf = mol[5]\n            n += 1\n            auc += tpf\n    if n == 0:\n        auc = 0\n    else:\n        auc = (1. / n) * auc\n\n    if diff:\n        return auc\n    else:\n        # confidence interval calculations\n        n = len([x for x in auc_structure if x[3] == '0'])          # no of decoys\n        p = len([x for x in auc_structure if x[3] == '1'])          # no of actives\n        aucvar_a, aucvar_d = calculate_auc_var(auc_structure)       # variance due to active and decoys\n        se = (aucvar_a / p + aucvar_d / n) ** 0.5                   # standard error\n        ci = se * stats.t.ppf(1 - 0.025, n + p - 1)                 # 95% confidence interval\n\n        # bounds\n        lower = auc - ci\n        upper = auc + ci\n\n        # dumb limit checking (ADD LOGIT FUNCTION)\n        if lower < 0:\n         lower = 0.0\n        if upper > 1:\n          upper = 1.0\n\n        return (auc, lower, upper)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the variance due to actives and decoys in a single ROC structure.", "response": "def calculate_auc_var(auc_structure):\n    \"\"\"\n    determine AUC variance due to actives (aucvar_a) and decoys (aucvar_d)\n    :param roc_structure: list [(id, best_score, best_query, status, fpf, tpf), ...,]\n    :return (aucvar_a, aucvar_d): tuple variance due to actives and decoys, respectively\n    \"\"\"\n\n    # split data by activity class\n    actives, decoys = splitter(auc_structure)\n\n    # variance due to actives = E[ (fpf - E(fpf)a) ** 2]a\n    fpf = [x[4] for x in actives]\n    aucvar_a = np.var(fpf, ddof=1, dtype=np.float64)\n\n    # variance due to decoys = E[ (tpf - E(tpf)d) ** 2]d\n    tpf = [x[5] for x in decoys]\n    aucvar_d = np.var(tpf, ddof=1, dtype=np.float64)\n\n    return (aucvar_a, aucvar_d)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_auc_diff(auc_structure_1, auc_structure_2, sort_order):\n\n    # determine auc and variance values for both sets\n    auc1 = calculate_auc(auc_structure_1, sort_order, 'diff')\n    var1a, var1d = calculate_auc_var(auc_structure_1)\n    auc2 = calculate_auc(auc_structure_2, sort_order, 'diff')\n    var2a, var2d = calculate_auc_var(auc_structure_2)\n\n    # determine covariances between sets\n    covara, covard = calculate_auc_covar(auc_structure_1, auc_structure_2)\n\n    # determine standard error\n    vardiffa = var2a + var1a - 2 * covara\n    vardiffd = var2d + var1a - 2 * covard\n\n    p = len([x for x in auc_structure_1 if x[3] == '1'])\n    n = len([x for x in auc_structure_1 if x[3] == '0'])\n\n    se = (vardiffa / p + vardiffd / n) ** 0.5\n\n    # confidence interval\n    ci = se * stats.t.ppf(1 - 0.025, n + p - 1)  # 95% confidence interval\n\n    # AUC bounds\n    diff = auc1 - auc2\n    lower = diff - ci\n    upper = diff + ci\n\n    # 2-sided p-value prob(diff >= abs(diff)) = prob(t >= abs(tt))\n    # corresponds to the null hypothesis: the two-methods perform identically\n    tt = ((diff ** 2) ** 0.5) / se\n    p_value = 2 * stats.t.sf(tt, n + p - 1)\n\n    return (auc1, auc2, diff, (lower, upper), p_value)", "response": "Calculates the difference in ROC AUC values and corresponding statistics."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate AUC covariance due to actives and decoys", "response": "def calculate_auc_covar(auc_structure1, auc_structure2):\n    \"\"\"\n    determine AUC covariance due to actives (covar_a) and decoys (covar_d)\n    :param auc_structure1: list [(id, best_score, best_query, status, fpf, tpf), ...,]\n    :param auc_structure2: list [(id, best_score, best_query, status, fpf, tpf), ...,]\n    :return (covar_a, covar_d): tuple\n    \"\"\"\n\n    # split data by activity class\n    actives1, decoys1 = splitter(auc_structure1)\n    actives2, decoys2 = splitter(auc_structure2)\n\n    # covariance due to actives = E[{fpf2 - E(fpf2)a} * {fpf1 - E(fpf1)a}]a\n    fpf1 = [x[4] for x in actives1]\n    fpf2 = [x[4] for x in actives2]\n    covara = np.cov(fpf1,fpf2)[0][1]\n\n    # covariance due to decoys = E[{tpf2 - E(tpf2)d} * {tpf1 - E(tpf1)d}]\n    tpf1 = [x[5] for x in decoys1]\n    tpf2 = [x[5] for x in decoys2]\n    covard = np.cov(tpf1,tpf2)[0][1]    # this is only compatible with versions >= 1.5\n\n    return covara, covard"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking a list of molecules and returns a score_structure that can be used to process the next set of molecules.", "response": "def make_score_structure(molecules, ensemble):\n    \"\"\"\n    puts data in the score_structure format for subsequent processing\n    :param molecules: list [mol_object_1, mol_object_2, .... ] mol_objects are instances of common_tools.molecules\n    :return score_structure: list [(id, best_score, best_query, status, net decoy count, net active count), ..., ]\n    \"\"\"\n    # sort molecules by their ensemble score\n    #sort_order = get_sort_order(molecules)\n    sort_order = 'asc'\n    sorted_molecules = screener.screener(molecules, ensemble, sort_order)\n\n    # initiate variables\n    score_structure = []\n    net_active_count = 0\n    net_decoy_count = 0\n\n    for mol in sorted_molecules:\n        # determine net active count & net decoy count\n        status = mol.GetProp('status')\n        if status == '1':\n            net_active_count += 1\n        elif status == '0':\n            net_decoy_count += 1\n        else:\n            continue\n\n        score_structure.append((mol.GetProp('id'), mol.GetProp('best_score'), mol.GetProp('best_query'), status,\n                                net_decoy_count, net_active_count))\n\n    return score_structure"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates ROC data points and returns a modified form of the score_structure format", "response": "def make_auc_structure(score_structure):\n    \"\"\"\n    calculates ROC data points and returns roc_structure, a modified form of the score_structure format\n    :param score_structure: list [(id, best_score, best_query, status, net decoy count, net active count), ..., ]\n    :return auc_structure: list [(id, best_score, best_query, status, fpf, tpf), ..., ]\n    \"\"\"\n\n    n = len([x for x in score_structure if x[3] == '0'])   # Total no. of decoys\n    p = len([x for x in score_structure if x[3] == '1'])   # Total no. of actives\n\n    auc_structure = []\n\n    for mol in score_structure:\n        if n == 0:\n            fpf = 0\n        else:\n            fpf = float(mol[4]) / n\n        if p == 0:\n            tpf = 0\n        else:\n            tpf = float(mol[5]) / p\n        tup = mol[0:4] + (fpf, tpf)\n        auc_structure.append(tup)\n\n    return auc_structure"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_fpfList(options, score_structure):\n\n    # set variables\n    fpf = options.fpf\n    n = len([x[4] for x in score_structure if x[3] == '0'])   # Total no. of decoys\n\n    # Default fpf values. We include 1, to ensure that the ef dictionary in the results dictionary objects contains\n    # the total number of decoys in the set, which is required in the screener.find_best_ensemble method\n    fpf_list = [0.0001, 0.001, 0.01, 0.05, 1]\n\n    if fpf and fpf not in fpf_list:\n        fpf_list.append(float(fpf))\n\n    if not fpf:\n        fpf = float(1) / n\n        fpf_list.append(fpf)\n\n    fpf_list.sort()\n\n    return fpf_list", "response": "Create a list of FPF values for the current ensemble."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dispatch(*funcs):\n    '''Iterates through the functions\n    and calls them with given the parameters\n    and returns the first non-empty result\n\n    >>> f = dispatch(lambda: None, lambda: 1)\n    >>> f()\n    1\n\n    :param \\*funcs: funcs list of dispatched functions\n    :returns: dispatch functoin\n    '''\n\n    def _dispatch(*args, **kwargs):\n        for f in funcs:\n            result = f(*args, **kwargs)\n            if result is not None:\n                return result\n        return None\n\n    return _dispatch", "response": "Dispatches the functions in the order they were called."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconsuming a preproc directive.", "response": "def preproc_directive(self) -> bool:\n    \"\"\"Consume a preproc directive.\"\"\"\n    self._stream.save_context()\n    if self.read_until(\"\\n\", '\\\\'):\n        return self._stream.validate_context()\n    return self._stream.restore_context()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconnect to a context factory", "response": "def connect(workbench):\n    \"\"\"Connection inititalization routine.\n\n    \"\"\"\n    d = _getContextFactory(getDataPath(), workbench)\n    d.addCallback(_connectWithContextFactory, workbench)\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _connectWithContextFactory(ctxFactory, workbench):\n    endpoint = SSL4ClientEndpoint(reactor, \"localhost\", 4430, ctxFactory)\n\n    splash = _Splash(u\"Connecting\", u\"Connecting...\")\n    workbench.display(splash)\n\n    d = endpoint.connect(Factory(workbench))\n\n    @d.addBoth\n    def closeSplash(returnValue):\n        workbench.undisplay()\n        return returnValue\n\n    @d.addErrback\n    def notifyFailure(f):\n        f.trap(ConnectError)\n        d = alert(workbench, u\"Couldn't connect\", u\"Connection failed! \"\n                  \"Check internet connection, or try again later.\\n\"\n                  \"Error: {!r}\".format(f.value))\n        return d.addCallback(lambda _result: reactor.stop())\n\n    return d", "response": "Connect using the given context factory. Notifications go to the\n    given workbench."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a context factory.", "response": "def _getContextFactory(path, workbench):\n    \"\"\"Get a context factory.\n\n    If the client already has a credentials at path, use them.\n    Otherwise, generate them at path. Notifications are reported to\n    the given workbench.\n\n    \"\"\"\n    try:\n        return succeed(getContextFactory(path))\n    except IOError:\n        d = prompt(workbench, u\"E-mail entry\", u\"Enter e-mail:\")\n        d.addCallback(_makeCredentials, path, workbench)\n        d.addCallback(lambda _result: getContextFactory(path))\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking client certs and writes them to disk at path.", "response": "def _makeCredentials(email, path, workbench):\n    \"\"\"Makes client certs and writes them to disk at path.\n\n    This essentially defers to clarent's ``makeCredentials`` function,\n    except it also shows a nice splash screen.\n\n    \"\"\"\n    splash = _Splash(u\"SSL credential generation\",\n                     u\"Generating SSL credentials. (This can take a while.)\")\n    workbench.display(splash)\n\n    makeCredentials(path, email)\n\n    workbench.undisplay()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a function or generator func return a function or generator that takes any number of kwargs and calls func with only the args and kwargs that func expects.", "response": "def optional_args_func(func) -> callable:\n    \"\"\"\n    Given a function or generator `func`, return a function/generator\n    that takes any number of kwargs and calls `func` with only the args/kwargs\n    that `func` expects.\n    \"\"\"\n    if getattr(func, '_optional_args_func', False):\n        return func\n\n    is_generator = inspect.isgeneratorfunction(func)\n    func_sig = inspect.signature(func)\n    expects_nothing = not func_sig.parameters\n\n    if is_generator:\n        @functools.wraps(func)\n        def wrapped(*args, **kwargs):\n            if expects_nothing:\n                yield from func()\n            else:\n                bound_arguments = func_sig.bind(*args, **{k: v for k, v in kwargs.items() if k in func_sig.parameters})\n                yield from func(*bound_arguments.args, **bound_arguments.kwargs)\n    else:\n        @functools.wraps(func)\n        def wrapped(*args, **kwargs):\n            if expects_nothing:\n                return func()\n            else:\n                bound_arguments = func_sig.bind(*args, **{k: v for k, v in kwargs.items() if k in func_sig.parameters})\n                return func(*bound_arguments.args, **bound_arguments.kwargs)\n\n    # Mark it so that we don't double wrap our own\n    setattr(wrapped, '_optional_args_func', True)\n\n    return wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef npm_install(package, flags=None):\n\n    command = u'install %s %s' % (package, flags or u'') \n    npm_command(command.strip())", "response": "Install a package from NPM."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef normalize_path(path, basedir=None):\n    out = os.path.expanduser(path)\n    if not os.path.isabs(path) and basedir:\n        out = os.path.join(basedir, out)\n\n    return out", "response": "This function will expand user paths if they are not there and return a new path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fasta_iter(handle, header=None):\n\n    # Speed tricks: reduces function calls\n    append = list.append\n    join = str.join\n    strip = str.strip\n\n    next_line = next\n\n    if header is None:\n        header = next(handle)  # Read first FASTQ entry header\n\n    # Check if input is text or bytestream\n    if (isinstance(header, bytes)):\n        def next_line(i):\n            return next(i).decode('utf-8')\n\n        header = strip(header.decode('utf-8'))\n    else:\n        header = strip(header)\n\n    try:  # Manually construct a for loop to improve speed by using 'next'\n\n        while True:  # Loop until StopIteration Exception raised\n\n            line = strip(next_line(handle))\n\n            data = FastaEntry()\n\n            try:\n                if not header[0] == '>':\n                    raise IOError('Bad FASTA format: no \">\" at beginning of line')\n            except IndexError:\n                raise IOError('Bad FASTA format: file contains blank lines')\n\n            try:\n                data.id, data.description = header[1:].split(' ', 1)\n            except ValueError:  # No description\n                data.id = header[1:]\n                data.description = ''\n\n            # Obtain sequence\n            sequence_list = []\n            while line and not line[0] == '>':\n                append(sequence_list, line)\n                line = strip(next_line(handle))  # Raises StopIteration at EOF\n            header = line  # Store current line so it's not lost next iteration\n            data.sequence = join('', sequence_list)\n\n            yield data\n\n    except StopIteration:  # Yield last FASTA entry\n        data.sequence = ''.join(sequence_list)\n        yield data", "response": "Iterate over FASTA file and return FASTA entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplot a 2 - d line with a gradient representing ordering.", "response": "def gradient_line(xs, ys, colormap_name='jet', ax=None):\n  '''Plot a 2-d line with a gradient representing ordering.\n  See http://stackoverflow.com/q/8500700/10601 for details.'''\n  if ax is None:\n    ax = plt.gca()\n  cm = plt.get_cmap(colormap_name)\n  npts = len(xs)-1\n  colors = cm(np.linspace(0, 1, num=npts))\n  if hasattr(ax, 'set_prop_cycle'):\n    ax.set_prop_cycle(color=colors)\n  else:\n    ax.set_color_cycle(colors)\n  for i in range(npts):\n    ax.plot(xs[i:i+2],ys[i:i+2])\n  return plt.show"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef irregular_contour(x, y, z, func=plt.contourf, func_kwargs=dict(),\n                      grid_size=(100,100), padding_fraction=0.05,\n                      interp_method='nearest'):\n  '''Handles interpolating irregular data to a grid,\n  and plots it using the given func [default: contourf]\n  See http://wiki.scipy.org/Cookbook/Matplotlib/Gridding_irregularly_spaced_data\n  '''\n  from scipy.interpolate import griddata  # Late import; scipy is optional\n  x, y, z = map(np.asanyarray, (x, y, z))\n  x_range = (x.min(), x.max())\n  y_range = (y.min(), y.max())\n  pad_x = padding_fraction * -np.subtract.reduce(x_range)\n  pad_y = padding_fraction * -np.subtract.reduce(y_range)\n  grid_x = np.linspace(x_range[0] - pad_x, x_range[1] + pad_x, grid_size[0])\n  grid_y = np.linspace(y_range[0] - pad_y, y_range[1] + pad_y, grid_size[1])\n  grid_z = griddata((x, y), z, (grid_x[None], grid_y[:,None]),\n                    method=interp_method)\n  return func(grid_x, grid_y, grid_z, **func_kwargs)", "response": "Handles irregular contour plotting using a given function"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef voronoi_filled(points_or_voronoi, colors, show_points=False,\n                   padding_fraction=0.05, cmap=None, ax=None, alpha=None,\n                   edgecolor=None):\n  '''Plots a filled voronoi diagram, using the given points and their colors.\n  The first parameter must be an array-like or a scipy.stats.Voronoi object.\n  '''\n  from scipy.spatial import Voronoi  # Late import; scipy is optional\n\n  # Disambiguate the first parameter\n  if isinstance(points_or_voronoi, Voronoi):\n    vor = points_or_voronoi\n  else:\n    points = np.asanyarray(points_or_voronoi)\n    assert points.shape[1] == 2, 'Input points must be 2D'\n    vor = Voronoi(points)\n\n  # Borrowed from http://nbviewer.ipython.org/gist/pv/8037100\n  regions = []\n  vertices = vor.vertices.tolist()\n\n  center = vor.points.mean(axis=0)\n  radius = vor.points.ptp().max()*2\n\n  # Construct a map containing all ridges for a given point\n  all_ridges = {}\n  for (p1, p2), (v1, v2) in zip(vor.ridge_points, vor.ridge_vertices):\n    all_ridges.setdefault(p1, []).append((p2, v1, v2))\n    all_ridges.setdefault(p2, []).append((p1, v1, v2))\n\n  # Reconstruct infinite regions\n  for p1, region in enumerate(vor.point_region):\n    verts = vor.regions[region]\n    if all(v >= 0 for v in verts):\n      # finite region\n      regions.append(verts)\n      continue\n\n    # reconstruct a non-finite region\n    ridges = all_ridges[p1]\n    new_region = [v for v in verts if v >= 0]\n\n    for p2, v1, v2 in ridges:\n      if v2 < 0:\n        v1, v2 = v2, v1\n      if v1 >= 0:\n        # finite ridge: already in the region\n        continue\n\n      # Compute the missing endpoint of an infinite ridge\n      t = vor.points[p2] - vor.points[p1]  # tangent\n      t /= np.linalg.norm(t)\n      n = np.array([-t[1], t[0]])  # normal\n\n      midpoint = vor.points[[p1, p2]].mean(axis=0)\n      direction = np.sign((midpoint - center).dot(n)) * n\n      far_point = vor.vertices[v2] + direction * radius\n\n      new_region.append(len(vertices))\n      vertices.append(far_point.tolist())\n\n    # sort region counterclockwise\n    vs = np.asarray([vertices[v] for v in new_region])\n    vs -= vs.mean(axis=0)\n    angle_order = np.argsort(np.arctan2(vs[:,1], vs[:,0]))\n    new_region = np.array(new_region)[angle_order]\n\n    # finish\n    regions.append(new_region)\n  vertices = np.asarray(vertices)\n\n  # Plot colored polygons\n  if ax is None:\n    ax = plt.gca()\n  polys = PatchCollection([Polygon(vertices[region]) for region in regions],\n                          cmap=cmap, alpha=alpha, edgecolor=edgecolor)\n  polys.set_array(np.asanyarray(colors))\n  ax.add_collection(polys)\n\n  if show_points:\n    ax.plot(vor.points[:,0], vor.points[:,1], 'ko')\n\n  # Zoom to a reasonable scale.\n  pad = padding_fraction * (vor.max_bound - vor.min_bound)\n  mins = vor.min_bound - pad\n  maxes = vor.max_bound + pad\n  ax.set_xlim(mins[0], maxes[0])\n  ax.set_ylim(mins[1], maxes[1])\n  return polys", "response": "Plots a filled voronoi diagram using the given points and their colors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding the 2d PCA ellipse of given data and plots it.", "response": "def pca_ellipse(data, loc=None, ax=None, **ellipse_kwargs):\n  '''Finds the 2d PCA ellipse of given data and plots it.\n  loc: center of the ellipse [default: mean of the data]\n  '''\n  from sklearn.decomposition import PCA  # Late import; sklearn is optional\n  pca = PCA(n_components=2).fit(data)\n  if loc is None:\n    loc = pca.mean_\n  if ax is None:\n    ax = plt.gca()\n  cov = pca.explained_variance_ * pca.components_.T\n  u,s,v = np.linalg.svd(cov)\n  width,height = 2*np.sqrt(s[:2])\n  angle = np.rad2deg(np.arctan2(u[1,0], u[0,0]))\n  ell = Ellipse(xy=loc, width=width, height=height, angle=angle,\n                **ellipse_kwargs)\n  ax.add_patch(ell)\n  return ell"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nplot a subset of images on an axis. Useful for visualizing image embeddings especially when visualizing image athresionalities.", "response": "def embedded_images(X, images, exclusion_radius=None, ax=None, cmap=None,\n                    zoom=1, seed=None, frameon=False):\n  '''Plots a subset of images on an axis. Useful for visualizing image\n  embeddings, especially when plotted over a scatterplot. Selects random points\n  to annotate with their corresponding image, respecting an exclusion_radius\n  around each selected point.'''\n  assert X.shape[0] == images.shape[0], 'Unequal number of points and images'\n  assert X.shape[1] == 2, 'X must be 2d'\n  if ax is None:\n    ax = plt.gca()\n  if exclusion_radius is None:\n    # TODO: make a smarter default based on image size and axis limits\n    exclusion_radius = 1.\n  if seed is not None:\n    np.random.seed(seed)\n  while X.shape[0] > 0:\n    i = np.random.choice(X.shape[0])\n    im = OffsetImage(images[i], zoom=zoom, cmap=cmap)\n    ab = AnnotationBbox(im, X[i], xycoords='data', frameon=frameon)\n    ax.add_artist(ab)\n    dist = np.sqrt(np.square(X[i] - X).sum(axis=1))\n    mask = (dist > exclusion_radius).ravel()\n    X = X[mask]\n    images = images[mask]\n  return plt.show"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting jittered points as a distribution visualizer.", "response": "def jitterplot(data, positions=None, ax=None, vert=True, scale=0.1,\n               **scatter_kwargs):\n  '''Plots jittered points as a distribution visualizer.\n\n  Scatter plot arguments default to: marker='.', c='k', alpha=0.75\n  Also known as a stripplot.\n  See also: boxplot, violinplot, beeswarm\n  '''\n  if ax is None:\n    ax = plt.gca()\n  if positions is None:\n    positions = range(len(data))\n\n  kwargs = dict(marker='.', c='k', alpha=0.75)\n  kwargs.update(scatter_kwargs)\n\n  for pos, y in zip(positions, data):\n    if scale > 0:\n      x = np.random.normal(loc=pos, scale=scale, size=len(y))\n    else:\n      x = np.zeros_like(y) + pos\n    if not vert:\n      x, y = y, x\n    ax.scatter(x, y, **kwargs)\n  return plt.show"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_type(name, library):\n        if name == None:\n            raise Exception(\"Class name cannot be null\")\n        if library == None:\n            raise Exception(\"Module name cannot be null\")\n\n        try:\n            module = importlib.import_module(library)\n            return getattr(module, name)\n        except:\n           return None", "response": "Gets object type by its name and library where it is defined."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget object type by type descriptor.", "response": "def get_type_by_descriptor(descriptor):\n        \"\"\"\n        Gets object type by type descriptor.\n\n        :param descriptor: a type descriptor that points to an object type\n\n        :return: the object type or null is the type wasn't found.\n        \"\"\"\n        if descriptor == None:\n            raise Exception(\"Type descriptor cannot be null\")\n\n        return TypeReflector.get_type(descriptor.get_name(), descriptor.get_library())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates an object of the specified type.", "response": "def create_instance(name, library, *args):\n        \"\"\"\n        Creates an instance of an object type specified by its name and library where it is defined.\n\n        :param name: an object type (factory function) to create.\n\n        :param library: a library (module) where object type is defined.\n\n        :param args: arguments for the object constructor.\n\n        :return: the created object instance.\n        \"\"\"\n        obj_type = TypeReflector.get_type(name, library)\n        if obj_type == None:\n            raise NotFoundException(\n                None, \"TYPE_NOT_FOUND\", \"Type \" + name + \",\" + library + \" was not found\"\n            ).with_details(\"type\", name).with_details(\"library\", library)\n        \n        return obj_type(*args)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_primitive(value):\n        typeCode = TypeConverter.to_type_code(value)\n        return typeCode == TypeCode.String or typeCode == TypeCode.Enum or typeCode == TypeCode.Boolean \\\n               or typeCode == TypeCode.Integer or typeCode == TypeCode.Long \\\n               or typeCode == TypeCode.Float or typeCode == TypeCode.Double \\\n               or typeCode == TypeCode.DateTime or typeCode == TypeCode.Duration", "response": "Checks if the value has primitive type."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef restart(self, timeout=None):\n        msg = { \"value\": \"Restart requested by \" + self.username + \"via the Splunk SDK for Python\"}\n        # This message will be deleted once the server actually restarts.\n        self.messages.create(name=\"restart_required\", **msg)\n        result = self.post(\"server/control/restart\")\n        if timeout is None:\n            return result\n        start = datetime.now()\n        diff = timedelta(seconds=timeout)\n        while datetime.now() - start < diff:\n            try:\n                self.login()\n                if not self.restart_required:\n                    return result\n            except Exception as e:\n                sleep(1)\n        raise Exception( \"Operation time out.\")", "response": "Restarts this Splunk instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the current state of the entity from the server.", "response": "def read(self, response):\n        \"\"\" Reads the current state of the entity from the server. \"\"\"\n        results = self._load_state(response)\n        # In lower layers of the SDK, we end up trying to URL encode\n        # text to be dispatched via HTTP. However, these links are already\n        # URL encoded when they arrive, and we need to mark them as such.\n        unquoted_links = dict([(k, UrlEncoded(v, skip_encode=True))\n                               for k,v in results['links'].items()])\n        results['links'] = unquoted_links\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self, name, **params):\n        if not isinstance(name, basestring):\n            raise InvalidNameException(\"%s is not a valid name for an entity.\" % name)\n        if 'namespace' in params:\n            namespace = params.pop('namespace')\n            params['owner'] = namespace.owner\n            params['app'] = namespace.app\n            params['sharing'] = namespace.sharing\n        response = self.post(name=name, **params)\n        atom = _load_atom(response, XNAME_ENTRY)\n        if atom is None:\n            # This endpoint doesn't return the content of the new\n            # item. We have to go fetch it ourselves.\n            return self[name]\n        else:\n            entry = atom.entry\n            state = _parse_atom_entry(entry)\n            entity = self.item(\n                self.service,\n                self._entity_path(state),\n                state=state)\n            return entity", "response": "Creates a new entity in this collection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create(self, name):\n        # This has to be overridden to handle the plumbing of creating\n        # a ConfigurationFile (which is a Collection) instead of some\n        # Entity.\n        if not isinstance(name, basestring):\n            raise ValueError(\"Invalid name: %s\" % repr(name))\n        response = self.post(__conf=name)\n        if response.status == 303:\n            return self[name]\n        elif response.status == 201:\n            return ConfigurationFile(self.service, PATH_CONF % name, item=Stanza, state={'title': name})\n        else:\n            raise ValueError(\"Unexpected status code %s returned from creating a stanza\" % response.status)", "response": "Creates a new configuration file with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a storage password.", "response": "def create(self, password, username, realm=None):\n        \"\"\" Creates a storage password.\n\n        A `StoragePassword` can be identified by <username>, or by <realm>:<username> if the\n        optional realm parameter is also provided.\n\n        :param password: The password for the credentials - this is the only part of the credentials that will be stored securely.\n        :type name: ``string``\n        :param username: The username for the credentials.\n        :type name: ``string``\n        :param realm: The credential realm. (optional)\n        :type name: ``string``\n\n        :return: The :class:`StoragePassword` object created.\n        \"\"\"\n        if not isinstance(username, basestring):\n            raise ValueError(\"Invalid name: %s\" % repr(username))\n\n        if realm is None:\n            response = self.post(password=password, name=username)\n        else:\n            response = self.post(password=password, realm=realm, name=username)\n\n        if response.status != 201:\n            raise ValueError(\"Unexpected status code %s returned from creating a stanza\" % response.status)\n\n        entries = _load_atom_entries(response)\n        state = _parse_atom_entry(entries[0])\n        storage_password = StoragePassword(self.service, self._entity_path(state), state=state, skip_refresh=True)\n\n        return storage_password"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef attach(self, host=None, source=None, sourcetype=None):\n        args = { 'index': self.name }\n        if host is not None: args['host'] = host\n        if source is not None: args['source'] = source\n        if sourcetype is not None: args['sourcetype'] = sourcetype\n        path = UrlEncoded(PATH_RECEIVERS_STREAM + \"?\" + urllib.urlencode(args), skip_encode=True)\n\n        # Since we need to stream to the index connection, we have to keep\n        # the connection open and use the Splunk extension headers to note\n        # the input mode\n        sock = self.service.connect()\n        headers = [\"POST %s HTTP/1.1\\r\\n\" % self.service._abspath(path),\n                   \"Host: %s:%s\\r\\n\" % (self.service.host, int(self.service.port)),\n                   \"Accept-Encoding: identity\\r\\n\",\n                   \"Authorization: %s\\r\\n\" % self.service.token,\n                   \"X-Splunk-Input-Mode: Streaming\\r\\n\",\n                   \"\\r\\n\"]\n        for h in headers:\n            sock.write(h)\n        return sock", "response": "Opens a stream for writing events to the index."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a relative path to the resources for a given kind.", "response": "def kindpath(self, kind):\n        \"\"\"Returns a path to the resources for a given input kind.\n\n        :param `kind`: The kind of input:\n\n            - \"ad\": Active Directory\n\n            - \"monitor\": Files and directories\n\n            - \"registry\": Windows Registry\n\n            - \"script\": Scripts\n\n            - \"splunktcp\": TCP, processed\n\n            - \"tcp\": TCP, unprocessed\n\n            - \"udp\": UDP\n\n            - \"win-event-log-collections\": Windows event log\n\n            - \"win-perfmon\": Performance monitoring\n\n            - \"win-wmi-collections\": WMI\n\n        :type kind: ``string``\n\n        :return: The relative endpoint path.\n        :rtype: ``string``\n        \"\"\"\n        if kind in self.kinds:\n            return UrlEncoded(kind, skip_encode=True)\n        # Special cases\n        elif kind == 'tcp':\n            return UrlEncoded('tcp/raw', skip_encode=True)\n        elif kind == 'splunktcp':\n            return UrlEncoded('tcp/cooked', skip_encode=True)\n        else:\n            raise ValueError(\"No such kind on server: %s\" % kind)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self, username, password, roles, **params):\n        if not isinstance(username, basestring):\n            raise ValueError(\"Invalid username: %s\" % str(username))\n        username = username.lower()\n        self.post(name=username, password=password, roles=roles, **params)\n        # splunkd doesn't return the user in the POST response body,\n        # so we have to make a second round trip to fetch it.\n        response = self.get(username)\n        entry = _load_atom(response, XNAME_ENTRY).entry\n        state = _parse_atom_entry(entry)\n        entity = self.item(\n            self.service,\n            urllib.parse.unquote(state.links.alternate),\n            state=state)\n        return entity", "response": "Creates a new user."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_replace(iterable, src, dst):\n    result=[]\n    iterable=list(iterable)\n    \n    try:\n        dst=list(dst)\n    except TypeError: # e.g.: int\n        dst=[dst]\n        \n    src=list(src)\n    src_len=len(src)\n    index = 0\n    while index < len(iterable):\n        element = iterable[index:index+src_len]\n#         print element, src\n        if element == src:\n            result += dst\n            index += src_len\n        else:\n            result.append(iterable[index])\n            index += 1\n    return result", "response": "A simple list_replace that replaces the elements in src with dst."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _filter_attribute(mcs, attribute_name, attribute_value):\n        if attribute_name == '__module__':\n            return True\n        elif hasattr(attribute_value, '_trace_disable'):\n            return True\n        return False", "response": "Returns whether the given attribute should be excluded from tracing or not."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates treeview columns and connects missing signals", "response": "def register_view(self, view):\n        \"\"\"Creates treeview columns, and connect missing signals\"\"\"\n        self.setup_columns()\n\n        # connects tv messages\n        tv = self.view['tv_categories']\n        sel = tv.get_selection()\n        sel.connect('changed', self.on_selection_changed)\n\n        # connects other messages\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setup_columns(self):\n        tv = self.view['tv_categories']\n\n        # sets the model\n        tv.set_model(self.model)\n        \n        # creates the columns\n        cell = gtk.CellRendererText()\n        tvcol = gtk.TreeViewColumn('Name', cell)\n\n        def cell_data_func(col, cell, mod, it):\n            if mod[it][0]: cell.set_property('text', mod[it][0].name)\n            return\n        tvcol.set_cell_data_func(cell, cell_data_func)\n        \n        tv.append_column(tvcol)                \n        return", "response": "Creates the treeview columns"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_curr_model_view(self, model, select):        \n        v = self.view.add_currency_view(select)\n        self.curreny = CurrencyCtrl(model, v)\n        return", "response": "Show the current curreny view"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying modification on the right side of the view.", "response": "def apply_modification(self):\n        \"\"\"Modifications on the right side need to be committed\"\"\"\n        self.__changing_model = True\n\n        if self.adding_model: self.model.add(self.adding_model)\n        elif self.editing_model and self.editing_iter:\n            # notifies the currencies model\n            path = self.model.get_path(self.editing_iter)\n            self.model.row_changed(path, self.editing_iter)            \n            pass            \n        \n        self.view.remove_currency_view()\n        self.adding_model = None\n        self.editing_model = None\n        self.editing_iter = None\n        self.curreny = None\n\n        self.unselect()\n        self.__changing_model = False\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_selection_changed(self, sel):\n        m, self.editing_iter = sel.get_selected()\n\n        if self.editing_iter:\n            self.editing_model = m[self.editing_iter][0]\n            self.show_curr_model_view(self.editing_model, False)\n            \n        else: self.view.remove_currency_view()\n            \n        return", "response": "The user changed the selected item"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_estimates(positions, estimates):\n    x = list(positions)\n    fig = plt.figure(figsize=(SUBPLOT_WIDTH * len(estimates), FIGURE_HEIGHT))\n    for i, (title, y) in enumerate(zip(ESTIMATE_TITLES, estimates)):\n        ax = fig.add_subplot(1, len(estimates), i + 1)\n        ax.plot(x, y, linewidth=LINE_WIDTH, c=LINE_COLOR)\n        ax.title.set_text(title)\n        ax.set_xlim(0, 1)\n        ax.set_xlabel(\"position\")\n        ax.set_ylabel(\"$\\\\hat P$\")\n        ax.grid()\n    return fig", "response": "Plots density and probability estimates for a single node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconfiguring with command line option '--filetype.", "response": "def options(self, parser, env):\n        \"\"\" Configure with command line option '--filetype'. \"\"\"\n        Plugin.options(self, parser, env)\n        parser.add_option('--filetype', action='append',\n                          help='Specify additional filetypes to monitor.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configure(self, options, conf):\n        Plugin.configure(self, options, conf)\n        if options.filetype:\n            self.filetypes += options.filetype", "response": "Configure the filetypes of the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef wrap_multipart_params(func):\n\n    def wrapper(request, *args, **kwargs):\n        ctype, pdict = parse_header(request.headers.get('Content-Type', ''))\n        if ctype == \"multipart/form-data\":\n\n            if isinstance(pdict['boundary'], str):\n                pdict['boundary'] = pdict['boundary'].encode()\n\n            params = {}\n            mp = MultipartParser(BytesIO(request.body), pdict['boundary'])\n            for part in mp:\n                params[part.name] = {\n                    \"filename\": part.filename,\n                    \"file\": part.file,\n                }\n\n            request.params = merge_dicts(getattr(request, \"params\", None), params)\n            request.multipart_params = params\n\n        return func(request, *args, **kwargs)\n    return wrapper", "response": "A middleware that parses the multipart request body and adds the parsed content to the multipart_params attribute."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append(self, code):\n        # support one-shot push and pop of dictionaries using operators\n        pop_next = self._pop_next\n        if pop_next:\n            self._pop_next = False\n\n        if isinstance(code, str):\n            # Strings are processed, then indented appropriately\n            for token in self._process(code):\n                prev = self.last_string\n                prev_ends_with_nl = prev is None or prev.endswith('\\n')\n                token_starts_with_nl = token.startswith(\"\\n\")\n                indent_depth = self.indent_depth\n                if prev_ends_with_nl:\n                    if indent_depth > 0:\n                        self.code_builder.append(self.indent_str)\n                    if token_starts_with_nl:\n                        token = token[1:]\n\n                if indent_depth > 0:\n                    token = cypy.re_nonend_newline.sub(\n                        \"\\n\" + self.indent_str, token)\n\n                if token != \"\":\n                    self.code_builder.append(token)\n        else: self._process_nonstrings(code)\n\n        if pop_next:\n            self.pop_context()\n        return self", "response": "This method appends the source code to the source code stream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a line of code to the end of the file.", "response": "def lines(self, code):\n        \"\"\"Fixes indentation for multiline strings before appending.\"\"\"\n        if isinstance(code, str):\n            fix_indentation = self.fix_indentation\n            if fix_indentation:\n                code = fix_indentation(code)\n            return self.append(code)\n        else:\n            return self.append(code)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef with_id_processor(cls, *args):\n        ip = IdentifierProcessor()\n        g = cls(ip, *args)\n        ip.nonstring_processor = lambda _, substitution: \\\n            g._process_nonstrings(substitution)\n        return g", "response": "Returns a new instance with the processor set to a new instance \n        of : class:`IdentifierProcessor`, appropriately initialized to process\n        non - strings appropriately."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the last string in code_builder or None if none so far.", "response": "def last_string(self):\n        \"\"\"The last entry in code_builder, or ``None`` if none so far.\"\"\"\n        cb = self.code_builder\n        len_cb = len(cb)\n        if len_cb > 0:\n            return cb[len_cb - 1]\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npop the last set of keyword arguments provided to the processor.", "response": "def pop_context(self):\n        \"\"\"Pops the last set of keyword arguments provided to the processor.\"\"\"\n        processor = getattr(self, 'processor', None)\n        if processor is not None:\n            pop_context = getattr(processor, 'pop_context', None)\n            if pop_context is None:\n                pop_context = getattr(processor, 'pop', None)\n            if pop_context is not None:\n                return pop_context()\n        if self._pop_next:\n            self._pop_next = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef trigger_staged_cg_hook(self, name, g, *args, **kwargs):\n        print_hooks = self._print_hooks\n        # TODO: document name lookup business\n        # TODO: refactor this context stuff, its confusing\n        hook_name = \"pre_\" + name\n        printed_name = hook_name if print_hooks else None\n        self.trigger_cg_hook(hook_name, g, printed_name, *args, **kwargs) # TODO: avoid copies\n        \n        hook_name = \"in_\" + name\n        printed_name = hook_name if print_hooks else None\n        self.trigger_cg_hook(hook_name, g, printed_name, *args, **kwargs)\n        \n        hook_name = \"post_\" + name\n        printed_name = hook_name if print_hooks else None\n        self.trigger_cg_hook(hook_name, g, printed_name, *args, **kwargs)", "response": "Calls a three - staged cg hook that is called for the given context."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef escape(inp, quote='\"'):\n    output = \"\"\n\n    for c in inp:\n        if c == quote:\n            output += '\\\\'\n\n        output += c\n\n    return output", "response": "Escapes quote in string inp."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_iobject(self,\n                       identifier_ns_uri=None,\n                       uid=None,\n                       timestamp=None,\n                       create_timestamp=None,\n                       iobject_data=None,\n                       config_hooks=None,\n                       namespace_dict=None,\n                       markings=None,\n                       import_older_ts=True,\n                       iobject_family_name=DINGOS_IOBJECT_FAMILY_NAME,\n                       iobject_family_revision_name=DINGOS_REVISION_NAME,\n                       iobject_type_name=DINGOS_PLACEHOLDER_TYPE_NAME,\n                       iobject_type_namespace_uri=DINGOS_NAMESPACE_URI,\n                       iobject_type_revision_name=\"\",\n                       ):\n        \"\"\"\n        Create an information object:\n\n        - the unique identifier of the information object is specified\n          by identifier_ns_uri and uid\n\n        - the timestamp specifies the revision of the information object\n\n        - iobject data must contain the DingoObjDict with the contents\n          of the information object that is to be created\n\n        - config_hooks specifies hooking functions for customizing the\n          way the DingoObjDict is transformed into facts -- please\n          look at the sample import modules for STIX and OpenIOC to\n          get an idea of how this is used\n\n        - A list of markings can be provided. Essentially, a marking is simply\n          another information object, to which the created information object\n          will receive a link. This can be used, e.g., to keep track of provenance\n          information (e.g., which import step led to the creation of that information object.\n\n        - Existing defaults for object family and type can be changed via function parameters.\n          If nothing is changed, then a DINGO PLACEHOLDER object is created. This special\n          object is used by the importer to create objects for forward references found\n          during the import.\n\n        Call the function as\n    \n        (iobject(s),exists) = create_iobject(...)\n    \n        The 'exists' flag contains information about whether there were already existing\n        revisions.\n\n        \"\"\"\n\n        #if not timestamp:\n        #    raise StandardError(\"You must supply a timestamp.\")\n\n        if not uid:\n            raise StandardError(\"You must supply an identifier.\")\n\n\n        if not identifier_ns_uri:\n            raise StandardError(\"You must supply an identifier namespace.\")\n\n        # Fill in parameter defaults that would be mutable.\n\n        if not iobject_data:\n            iobject_data = DingoObjDict()\n\n        if not config_hooks:\n            config_hooks = {}\n\n\n\n        latest_existing_iobject = None\n        latest_existing_timestamp = None\n        existing_iobject = None\n\n        exists = False\n        overwrite = False\n\n        # Check for existing objects of the given uid\n\n\n        latest_existing_iobject = self.get_latest_revision_of_iobject_by_uid(identifier_ns_uri, uid)\n\n        if latest_existing_iobject:\n            latest_existing_timestamp = latest_existing_iobject.timestamp\n\n            if ((not timestamp) and\n                iobject_type_name==DINGOS_PLACEHOLDER_TYPE_NAME and\n                iobject_type_namespace_uri==DINGOS_NAMESPACE_URI):\n                return (latest_existing_iobject, EXIST_ID_AND_EXACT_TIMESTAMP)\n\n        if not timestamp:\n            timestamp = create_timestamp\n\n\n        existing_iobjects = self._DCM['InfoObject'].objects.filter(identifier__uid=uid).filter(\n            identifier__namespace__uri=identifier_ns_uri).filter(timestamp=timestamp)\n\n        if existing_iobjects:\n            existing_iobject = existing_iobjects[0]\n\n        if existing_iobject:\n            if existing_iobject.iobject_type.name == DINGOS_PLACEHOLDER_TYPE_NAME \\\n                and existing_iobject.iobject_family.name == DINGOS_IOBJECT_FAMILY_NAME:\n\n                overwrite = existing_iobject\n\n                exists = EXIST_PLACEHOLDER\n            else:\n                exists = EXIST_ID_AND_EXACT_TIMESTAMP\n        elif latest_existing_iobject:\n            if timestamp < latest_existing_timestamp:\n                exists = EXIST_ID_AND_NEWER_TIMESTAMP\n            else:\n                exists = EXIST_ID_AND_OLDER_TIMESTAMP\n\n        #\n        # if uid:\n        #     latest_existing_iobject = self.get_latest_revision_of_iobject_by_uid(identifier_ns_uri, uid)\n        #\n        # if latest_existing_iobject:\n        #     latest_existing_timestamp = latest_existing_iobject.timestamp\n        #     existing_timestamps = self._DCM['InfoObject'].objects.filter(identifier__uid=uid).filter(\n        #         identifier__namespace__uri=identifier_ns_uri).values_list('timestamp', flat=True)\n        #\n        #     if latest_existing_iobject.iobject_type.name == DINGOS_PLACEHOLDER_TYPE_NAME \\\n        #         and latest_existing_iobject.iobject_family.name == DINGOS_IOBJECT_FAMILY_NAME:\n        #\n        #         overwrite = latest_existing_iobject\n        #\n        #         exists = EXIST_PLACEHOLDER\n        #\n        #\n        #\n        #     else:\n        #         # We found a non-Placeholder object; let us see, what the timestamp says.\n\n\n        # If we have found an object of the given id with the exact timestamp or\n        # a newer object and the parameter 'import_older_ts' is set to False,\n        # we return the latest revision (i.e., object with newest time stamp) of\n        # for the given identifier.\n\n\n        logger.debug(\"EXISTS flag for %s:%s is: %s\" % (identifier_ns_uri, uid, exists))\n\n        if exists==EXIST_ID_AND_EXACT_TIMESTAMP:\n            if markings:\n            # If markings were given, we create the marking.\n\n                 for marking in markings:\n                     Marking2X.objects.create(marked=existing_iobject,\n                         marking=marking)\n\n            return (existing_iobject, exists)\n        elif  (not import_older_ts and exists == EXIST_ID_AND_NEWER_TIMESTAMP):\n            return (latest_existing_iobject, exists)\n\n\n\n        else:\n            # Otherwise, we create or overwrite the object\n\n            #if not uid:\n            #    uid = uuid.uuid1()\n            logger.info(\"Creating %s %s:%s with timestamp %s\" % (iobject_type_name,\n                                                                 identifier_ns_uri,\n                                                                 uid,\n                                                                 '{:%d-%m-%Y:%H:%M:%S}.{:03d}'.format(timestamp, timestamp.microsecond // 1000)))\n\n            iobject, created = get_or_create_iobject(uid,\n                                                     identifier_ns_uri,\n                                                     iobject_type_name,\n                                                     iobject_type_namespace_uri,\n                                                     iobject_type_revision_name,\n                                                     iobject_family_name,\n                                                     iobject_family_revision_name,\n                                                     identifier_namespace_name=None,\n                                                     timestamp=timestamp,\n                                                     create_timestamp=create_timestamp,\n                                                     overwrite=overwrite,\n                                                     dingos_class_map=self._DCM,\n                                                    )\n\n            # After creating the object, we write the facts to the object.\n            # We overwrite in the special case that a PLACEHOLDER was found.\n\n            if created or overwrite:\n                iobject.from_dict(iobject_data, config_hooks=config_hooks, namespace_dict=namespace_dict)\n\n\n            # We adjust the back pointer in the identifier table to the latest version\n            # of the object\n            if not exists or exists == EXIST_ID_AND_OLDER_TIMESTAMP or exists == EXIST_PLACEHOLDER:\n                iobject.identifier.latest = iobject\n                iobject.identifier.save()\n\n            if markings:\n                # If markings were given, we create the marking.\n\n                for marking in markings:\n                    Marking2X.objects.create(marked=iobject,\n                                             marking=marking)\n\n            return (iobject, exists)", "response": "Create a new information object in the system."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_marking_iobject(self,\n                               uid=None,\n                               timestamp=timezone.now(),\n                               metadata_dict=None,\n                               id_namespace_uri=DINGOS_DEFAULT_ID_NAMESPACE_URI,\n                               iobject_family_name=DINGOS_IOBJECT_FAMILY_NAME,\n                               iobject_family_revison_name=DINGOS_REVISION_NAME,\n                               iobject_type_name=DINGOS_DEFAULT_IMPORT_MARKING_TYPE_NAME,\n                               iobject_type_namespace_uri=DINGOS_NAMESPACE_URI,\n                               iobject_type_revision_name=DINGOS_REVISION_NAME,\n                               ):\n        \"\"\"\n        A specialized version of create_iobject with defaults set such that a default marking object is created.\n        \"\"\"\n        if not uid:\n            uid = uuid.uuid1()\n\n        iobject, created = self.create_iobject(iobject_family_name=iobject_family_name,\n                                                      iobject_family_revision_name=iobject_family_revison_name,\n                                                      iobject_type_name=iobject_type_name,\n                                                      iobject_type_namespace_uri=iobject_type_namespace_uri,\n                                                      iobject_type_revision_name=iobject_type_revision_name,\n                                                      iobject_data=metadata_dict,\n                                                      uid=uid,\n                                                      identifier_ns_uri=id_namespace_uri,\n                                                      timestamp=timestamp,\n                                                      )\n\n        return iobject", "response": "A specialized version of create_iobject that creates a new marking object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread single ADC Channel", "response": "def get(self, channel):\n        \"\"\"Read single ADC Channel\"\"\"\n        checked_channel = self._check_channel_no(channel)\n        self.i2c.write_raw8(checked_channel  | self._dac_enabled)\n        reading = self.i2c.read_raw8() \n        reading = self.i2c.read_raw8() \n        return reading / 255.0"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set(self, channel, state):\n        checked_val = self._check_dac_val(channel, state)\n        self._dac_enabled = 0x40\n        self.i2c.write8(self._dac_enabled, checked_val * 255)", "response": "Set the DAC value and enable output"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget an optional environment variable.", "response": "def get_optional_env(key):\n    \"\"\"\n    Return the value of an optional environment variable, and use\n    the provided default if it's not set.\n    \"\"\"\n    environment_variable_value = os.environ.get(key)\n    if environment_variable_value:\n        return environment_variable_value\n    elif key in CONSTANTS:\n        return CONSTANTS[key]\n    else:\n        raise Exception(\"The variable {1} is not set\".format(key))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    ROOT_LOGGER.setLevel(logging.DEBUG)\n\n    file_handler = logging.StreamHandler(LOG_PATH.open(\"wt\"))\n    formatter = logging.Formatter(LOG_FORMAT)\n    file_handler.setFormatter(formatter)\n    file_handler.setLevel(logging.DEBUG)\n    ROOT_LOGGER.addHandler(file_handler)\n\n    terminal_handler = logging.StreamHandler(stdout)\n    terminal_handler.setFormatter(formatter)\n    terminal_handler.setLevel(logging.INFO)\n    ROOT_LOGGER.addHandler(terminal_handler)\n\n    LOGGER.debug(\"Parsing command-line arguments\")\n    parser = ArgumentParser(\n        description=\"\"\"\n            Use datasets, and judgements in the NTCIR-11 Math-2, and NTCIR-12 MathIR XHTML5 format\n            to compute density, and probability estimates.\n        \"\"\")\n    parser.add_argument(\n        \"--datasets\", nargs='+', required=False,\n        type=lambda s: LabelledPath(s.split('=', 1)[0], Path(s.split('=', 1)[1])), help=\"\"\"\n            Paths to the directories containing the datasets. Each path must be prefixed with a\n            unique single-letter label followed by an equals sign (e.g. \"A=/some/path\").\n        \"\"\")\n    parser.add_argument(\n        \"--judgements\", nargs='+', required=False,\n        type=lambda s: (LabelledPath.labels[s.split(':', 1)[0]], Path(s.split(':', 1)[1])), help=\"\"\"\n            Paths to the files containing relevance judgements. Each path must be prefixed with a\n            single-letter label corresponding to the judged dataset followed by a semicolon (e.g.\n            \"A:/some/path/judgement.dat\").\n        \"\"\")\n    parser.add_argument(\n        \"--plots\", type=Path, nargs='+', help=\"\"\"\n            The path to the files, where the probability estimates will plotted. When no datasets\n            are specified, the estimates file will be loaded.\n        \"\"\")\n    parser.add_argument(\n        \"--positions\", type=Path, default=POSITIONS_ALL_PATH, help=\"\"\"\n            The path to the file, where the estimated positions of all paragraph identifiers from\n            all datasets will be stored. Defaults to %(default)s.\n        \"\"\")\n    parser.add_argument(\n        \"--estimates\", type=Path, default=ESTIMATES_PATH, help=\"\"\"\n            The path to the file, where the density, and probability estimates will be stored. When\n            no datasets are specified, this file will be loaded to provide the estimates for\n            plotting. Defaults to %(default)s.\n        \"\"\")\n    parser.add_argument(\n        \"--num-workers\", type=int, default=1, help=\"\"\"\n            The number of processes that will be used for processing the datasets, and for computing\n            the density, and probability estimates. Defaults to %(default)d.\n        \"\"\")\n    args = parser.parse_args()\n\n    LOGGER.debug(\"Performing sanity checks on the command-line arguments\")\n    if args.datasets:\n        for dataset in args.datasets:\n            assert dataset.path.exists() and dataset.path.is_dir(), \\\n                \"Dataset %s does not exist\" % dataset.path\n        assert args.judgements, \"No relevance judgements were specified for the datasets\"\n        for _, judgement_path in args.judgements:\n            assert judgement_path.exists() and judgement_path.is_file(), \\\n                \"Relevance judgement %s does not exist\" % judgement_path\n        assert not args.estimates.exists() or args.estimates.is_file(), \\\n            \"File %s, where estimates are to be stored, is non-regular.\" % args.estimates\n        if args.positions.exists():\n            LOGGER.warning(\"%s exists\", args.positions.name)\n        if args.estimates.exists():\n            LOGGER.warning(\"%s exists\", args.estimates.name)\n    if args.plots:\n        assert args.datasets or args.estimates, \\\n            \"Neither datasets, not a stored file with estimates was provided as a plot source\"\n        if not args.datasets:\n            assert args.estimates.exists() and args.estimates.is_file(), \\\n                \"The file %s with estimates does not exist\" % args.estimates\n        for plot in args.plots:\n            assert plot.parents[0].exists() and plot.parents[0].is_dir(), \\\n                \"Directory %s, where a plot is to be stored, does not exist\" % \\\n                plot.parents[0]\n            if plot.exists():\n                LOGGER.warning(\"%s exists\", plot)\n    assert args.positions.parents[0].exists() and args.positions.parents[0].is_dir(), \\\n        \"Directory %s, where the positions are to be stored, does not exist\" % \\\n        args.positions.parents[0]\n    assert args.estimates.parents[0].exists() and args.estimates.parents[0].is_dir(), \\\n        \"Directory %s, where the estimates are to be stored, does not exist\" % \\\n        args.estimates.parents[0]\n    assert args.num_workers > 0, \"The number of workers must be non-negative\"\n\n    if args.datasets:\n        identifiers_judged = {}\n        identifiers_relevant = {}\n        for dataset_path, judgement_path in args.judgements:\n            LOGGER.info(\n                \"Retrieving judged paragraph identifiers, and scores from %s\", judgement_path.name)\n            if dataset_path not in identifiers_judged:\n                identifiers_judged[dataset_path] = set()\n            if dataset_path not in identifiers_relevant:\n                identifiers_relevant[dataset_path] = set()\n            with judgement_path.open(\"rt\") as f:\n                for identifier, score in get_judged_identifiers(f):\n                    identifiers_judged[dataset_path].add(identifier)\n                    if score > MIN_RELEVANT_SCORE:\n                        identifiers_relevant[dataset_path].add(identifier)\n\n        identifiers_all = {}\n        positions_all = {}\n        positions_relevant = {}\n        for dataset in args.datasets:\n            LOGGER.info(\n                \"Retrieving all paragraph identifiers, and positions from %s\", dataset.path.name)\n            identifiers_all[dataset.path] = []\n            positions_all[dataset.path] = []\n            positions_relevant[dataset.path] = []\n            for directory, identifier, position in get_all_positions(\n                    dataset.path, args.num_workers):\n                identifiers_all[dataset.path].append((directory, identifier))\n                positions_all[dataset.path].append(position)\n                if identifier in identifiers_relevant[dataset.path]:\n                    positions_relevant[dataset.path].append(position)\n\n        for dataset in args.datasets:\n            LOGGER.info(\n                \"%d / %d / %d relevant / judged / total identifiers in dataset %s\",\n                len(identifiers_relevant[dataset.path]), len(identifiers_judged[dataset.path]),\n                len(identifiers_all[dataset.path]), dataset.path.name)\n\n        LOGGER.info(\"Pickling %s\", args.positions.name)\n        with gzip.open(args.positions.open(\"wb\"), \"wb\") as f:\n            pickle.dump({\n                dataset.path: {\n                    identifier: position for position, (_, identifier)\n                    in zip(positions_all[dataset.path], identifiers_all[dataset.path])\n                } for dataset in args.datasets}, f)\n\n        LOGGER.info(\"Fitting density, and probability estimators\")\n        estimators = get_estimators(positions_all, positions_relevant)\n\n        LOGGER.info(\"Computing density, and probability estimates\")\n        estimates = get_estimates(estimators, SAMPLES, args.num_workers)\n\n        LOGGER.info(\"Pickling %s\", args.estimates.name)\n        with gzip.open(args.estimates.open(\"wb\"), \"wb\") as f:\n            pickle.dump(estimates, f)\n    else:\n        LOGGER.info(\"Unpickling %s\", args.estimates.name)\n        with gzip.open(args.estimates.open(\"rb\"), \"rb\") as f:\n            estimates = pickle.load(f)\n    if args.plots:\n        figure = plot_estimates(SAMPLES, estimates)\n        for plot_path in args.plots:\n            LOGGER.info(\"Plotting %s\", plot_path.name)\n            figure.savefig(str(plot_path))", "response": "This is the main function of the main function. It is the main function of the main function. It is the main function of the main function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_datetime_with_default(value, default_value):\n        result = DateTimeConverter.to_nullable_datetime(value)\n        return result if result != None else DateTimeConverter.to_utc_datetime(default_value)", "response": "Converts value into Date or returns default when conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef normalize_path(path):\n    if path == \":memory:\":\n        return path\n\n    return os.path.normcase(os.path.normpath(os.path.realpath(path)))", "response": ">>> normalize_path(\"/a/b/c/\")\n    '/a/b/c'\n    >>> normalize_path(\"/a/b/c\")\n    '/a/b/c'\n    >>> normalize_path(\"/a/b/c////////\")\n    '/a/b/c'\n    >>> normalize_path(\"///a/b/c\")\n    '/a/b/c'\n    >>> normalize_path(\"/a/././b/../b/c/\")\n    '/a/b/c'\n    >>> normalize_path(\":memory:\")\n    ':memory:'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef execute(self, *args, **kwargs):\n\n        with self:\n            self._cursor.execute(*args, **kwargs)", "response": "Analogous to sqlite3. Cursor. execute"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef executemany(self, *args, **kwargs):\n\n        with self:\n            self._cursor.executemany(*args, **kwargs)", "response": "Analogous to sqlite3. Cursor. executemany."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef executescript(self, *args, **kwargs):\n\n        with self:\n            self._cursor.executescript(*args, **kwargs)", "response": "Analogous to sqlite3. Cursor. executescript."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetchmany(self, *args, **kwargs):\n\n        with self:\n            return self._cursor.fetchmany(*args, **kwargs)", "response": "Analogous to sqlite3. Cursor. fetchmany."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nacquire the connection locks.", "response": "def acquire(self, lock_transactions=None):\n        \"\"\"\n            Acquire the connection locks.\n\n            :param lock_transactions: `bool`, acquire the transaction lock\n                                      (`self.lock_transactions` is the default value)\n        \"\"\"\n\n        if not self.personal_lock.acquire(timeout=self.lock_timeout):\n            raise LockTimeoutError(self)\n\n        self.with_count += 1\n\n        if lock_transactions is None:\n            lock_transactions = self.lock_transactions\n\n        if lock_transactions and self.db_state.active_connection is not self:\n            if not self.db_state.transaction_lock.acquire(timeout=self.lock_timeout):\n                self.personal_lock.release()\n                raise LockTimeoutError(self)\n\n            self.db_state.active_connection = self\n\n        if not self.db_state.lock.acquire(timeout=self.lock_timeout):\n            self.personal_lock.release()\n\n            if lock_transactions:\n                self.db_state.active_connection = None\n                self.db_state.transaction_lock.release()\n\n            raise LockTimeoutError(self)\n\n        try:\n            # If the connection is closed, an exception is thrown\n            in_transaction = self.in_transaction\n        except sqlite3.ProgrammingError:\n            in_transaction = False\n\n        self.was_in_transaction = in_transaction"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrelease the connection locks.", "response": "def release(self, lock_transactions=None):\n        \"\"\"\n            Release the connection locks.\n\n            :param lock_transactions: `bool`, release the transaction lock\n                                      (`self.lock_transactions` is the default value)\n        \"\"\"\n\n        self.personal_lock.release()\n\n        self.with_count -= 1\n\n        if lock_transactions is None:\n            lock_transactions = self.lock_transactions\n\n        if not lock_transactions:\n            self.db_state.lock.release()\n            return\n\n        try:\n            # If the connection is closed, an exception is thrown\n            in_transaction = self.in_transaction\n        except sqlite3.ProgrammingError:\n            in_transaction = False\n\n        # The transaction lock should be released only if:\n        # 1) the connection was previously in a transaction and now it isn't\n        # 2) the connection wasn't previously in a transaction and still isn't\n        if (self.was_in_transaction and not in_transaction) or not in_transaction:\n            if self.with_count == 0: # This is for nested with statements\n                self.db_state.active_connection = None\n                self.db_state.transaction_lock.release()\n\n        self.db_state.lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef close(self):\n\n        if self.closed:\n            return\n\n        # Make sure no one minds the connection to be closed\n        # This will help avoid MemoryError in other threads,\n        # they will get sqlite3.ProgrammingError instead\n        if not self.personal_lock.acquire(timeout=self.lock_timeout):\n            raise LockTimeoutError(self)\n\n        try:\n            try:\n                if self.in_transaction:\n                    self.db_state.active_connection = None\n                    self.db_state.transaction_lock.release()\n            except sqlite3.ProgrammingError:\n                pass\n\n            if self._cursor is not None and not self._cursor.closed:\n                self._cursor._cursor.close()\n                self._cursor.closed = True\n\n            if self.connection is not None:\n                self.connection.close()\n\n            self.closed = True\n        finally:\n            self.personal_lock.release()", "response": "Close the connection to the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetchmany(self, *args, **kwargs):\n\n        if not self.single_cursor_mode:\n            raise S3MError(\"Calling Connection.fetchmany() while not in single cursor mode\")\n\n        return self._cursor.fetchmany(*args, **kwargs)", "response": "Wrapper for sqlite3. Cursor. fetchmany."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_type_code(value):\n        if value == None:\n            return TypeCode.Unknown\n\n        if not isinstance(value, type):\n            value = type(value)\n\n        if value is list:\n            return TypeCode.Array\n        elif value is tuple:\n            return TypeCode.Array\n        elif value is set:\n            return TypeCode.Array\n        elif value is bool:\n            return TypeCode.Boolean\n        elif value is int:\n            return TypeCode.Integer\n        # elif value is long:\n        #     return TypeCode.Long\n        elif value is float:\n            return TypeCode.Float\n        elif value is str:\n            return TypeCode.String\n        # elif value is unicode:\n        #     return TypeCode.String\n        elif value is datetime:\n            return TypeCode.DateTime\n        elif value is dict:\n            return TypeCode.Map\n            \n        return TypeCode.Object", "response": "Converts passed value to TypeCode for specific value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert value into an object type specified by Type Code or returns default value when conversion is not possible.", "response": "def to_type_with_default(value_type, value, default_value):\n        \"\"\"\n        Converts value into an object type specified by Type Code or returns default value when conversion is not possible.\n\n        :param value_type: the TypeCode for the data type into which 'value' is to be converted.\n\n        :param value: the value to convert.\n\n        :param default_value: the default value to return if conversion is not possible (returns None).\n\n        :return: object value of type corresponding to TypeCode, or default value when conversion is not supported.\n        \"\"\"\n        result = TypeConverter.to_nullable_type(value_type, value)\n        return result if result != None else default_value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_string(type):\n        if type == None:\n            return \"unknown\"\n        elif type == TypeCode.Unknown:\n            return \"unknown\"\n        elif type == TypeCode.String:\n            return \"string\"\n        elif type == TypeCode.Integer:\n            return \"integer\"\n        elif type == TypeCode.Long:\n            return \"long\"\n        elif type == TypeCode.Float:\n            return \"float\"\n        elif type == TypeCode.Double:\n            return \"double\"\n        elif type == TypeCode.Duration:\n            return \"duration\"\n        elif type == TypeCode.DateTime:\n            return \"datetime\"\n        elif type == TypeCode.Object:\n            return \"object\"\n        elif type == TypeCode.Enum:\n            return \"enum\"\n        elif type == TypeCode.Array:\n            return \"array\"\n        elif type == TypeCode.Map:\n            return \"map\"\n        else:\n            return \"unknown\"", "response": "Converts a TypeCode into its string name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, agentml, user=None, key=None):\n        user = agentml.get_user(key) if key else user\n        if not user:\n            return\n\n        return user.topic", "response": "Evaluate and return the current active topic of the user"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_netsh_command(netsh_args):\n    devnull = open(os.devnull, 'w')\n    command_raw = 'netsh interface ipv4 ' + netsh_args\n    return int(subprocess.call(command_raw, stdout=devnull))", "response": "Execute a netsh command and return the output."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a WMIC array.", "response": "def parse_array(raw_array):\n    \"\"\"Parse a WMIC array.\"\"\"\n    array_strip_brackets = raw_array.replace('{', '').replace('}', '')\n    array_strip_spaces = array_strip_brackets.replace('\"', '').replace(' ', '')\n    return array_strip_spaces.split(',')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register(self, func):\n        assert callable(func)\n        assert inspect.getargspec(func).args == [\"user\", \"privilege\"]\n        self.handlers.add(func)", "response": "Register a function to be called when the log entry is created."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef llcs(s1, s2):\n    '''length of the longest common sequence\n\n    This implementation takes O(len(s1) * len(s2)) time and\n    O(min(len(s1), len(s2))) space.\n\n    Use only with short strings.\n\n    >>> llcs('a.b.cd','!a!b!c!!!d!')\n    4\n    '''\n    m, n = len(s1), len(s2)\n    if m < n:  # ensure n <= m, to use O(min(n,m)) space\n        m, n = n, m\n        s1, s2 = s2, s1\n    l = [0] * (n+1)\n    for i in range(m):\n        p = 0\n        for j in range(n):\n            t = 1 if s1[i] == s2[j] else 0\n            p, l[j+1] = l[j+1], max(p+t, l[j], l[j+1])\n    return l[n]", "response": "length of the longest common sequence\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lcsr(s1, s2):\n    '''longest common sequence ratio\n\n    >>> lcsr('ab', 'abcd')\n    0.5\n    '''\n    if s1 == s2:\n        return 1.0\n    return llcs(s1, s2) / max(1, len(s1), len(s2))", "response": "longest common sequence ratio"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lcp(s1, s2):\n    '''longest common prefix\n\n    >>> lcp('abcdx', 'abcdy'), lcp('', 'a'), lcp('x', 'yz')\n    (4, 0, 0)\n    '''\n    i = 0\n    for i, (c1, c2) in enumerate(zip(s1, s2)):\n        if c1 != c2:\n            return i\n    return min(len(s1), len(s2))", "response": "longest common prefix of two strings"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nserialize a python dictionary into a Gzip Base64 encoded string", "response": "def serialize(data, b64_encode=True, uri_encode=True):\n    \"\"\"Serializes a python dictionary into a Gzip, Base64 encoded string\n\n    :param data: Python dictionary or list to serialize\n    :param b64_encode: If True, the message will be compressed using Gzip and encoded using Base64\n    :param uri_encode: If True, the message will be encoded with the urllib.parse.quote_plus to be used as a value of a URI parameter\n    :return: Serialized data string, encoded if `encode` is `True`\n\n    >>> from jsonuri import jsonuri\n    >>> data = {\"age\": 31, \"name\": \"John\", \"account\": {\"id\": 127, \"regions\": [\"US\", \"SG\"]}}\n    >>> jsonuri.serialize(data, b64_encode=True, uri_encode=False)\n    'H4sIANRnb1oC/6tWSkxPVbJSMDbUUVDKS8wFsZW88jPylID8xOTk/NK8EqBQtVJmCpAyNDIHChelpmfm5xUD+dFKocEghcHuSrG1tQCN2YKETAAAAA=='\n    >>> jsonuri.serialize(data, b64_encode=True, uri_encode=True)\n    'H4sIAOdnb1oC%2F6tWSkxPVbJSMDbUUVDKS8wFsZW88jPylID8xOTk%2FNK8EqBQtVJmCpAyNDIHChelpmfm5xUD%2BdFKocEghcHuSrG1tQCN2YKETAAAAA%3D%3D'\n=\n    \"\"\"\n\n    if not isinstance(data, dict):\n        raise RuntimeError(\"Only dictionaries are supported. The following is not a dictionary:\\n %s\", data)\n\n    message = json.dumps(data)\n\n    if b64_encode:\n        message = jsonuri.io.compress(message).decode('utf-8')\n\n    if uri_encode:\n        message = urllib.parse.quote_plus(message)\n\n    return message"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef deserialize(message, b64_encoded=True, uri_encoded=True):\n\n    data = message\n\n    if uri_encoded:\n        data = urllib.parse.unquote_plus(data)\n\n    if b64_encoded:\n        data = jsonuri.io.decompress(data)\n\n    return json.loads(data)", "response": "Converts an encoded message into a Python dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init(self, width, len_):\n        self._width = width\n        self._len = len_\n        bits = len_ * width\n        self._data = bytearray(BinInt(bits).ceildiv(8))", "response": "Initializes internal data representation of the BinArray to all - 0."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _locate(self, idx):\n        start = idx * self._width\n        end = (idx + 1) * self._width\n        sbyte, sbit = divmod(start, 8)\n        ebyte = BinInt(end).ceildiv(8)\n        return sbyte, sbit, ebyte", "response": "Locates an element in the internal data representation. Returns starting byte index starting bit index in the starting byte and starting bit index in the starting bit index and one past the final byte index."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef repack(self, to_width, *, msb_first, start=0, start_bit=0,\n               length=None):\n        \"\"\"Extracts a part of a BinArray's data and converts it to a BinArray\n        of a different width.\n\n        For the purposes of this conversion, words in this BinArray are joined\n        side-by-side, starting from a given start index (defaulting to 0),\n        skipping ``start_bit`` first bits of the first word, then the resulting\n        stream is split into ``to_width``-sized words and ``length`` first\n        such words are returned as a new BinArray.\n\n        If ``msb_first`` is False, everything proceeds with little endian\n        ordering: the first word provides the least significant bits of the\n        combined stream, ``start_bit`` skips bits starting from the LSB,\n        and the first output word is made from the lowest bits of the combined\n        stream.  Otherwise (``msb_first`` is True), everything proceeds\n        with big endian ordering: the first word provides the most\n        significant bits of the combined stream, ``start_bit`` skips bits\n        starting from the MSB, and the first output word is made from the\n        highest bits of the combined stream.\n\n        ``start_bits`` must be smaller than the width of the input word.\n        It is an error to request a larger length than can be provided from\n        the input array.  If ``length`` is not provided, this function\n        returns as many words as can be extracted.\n\n        For example, consider a 10-to-3 repack with start_bit=2, length=4\n        msb_first=True:\n\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        |         | MSB ... LSB       |\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        |         | ...               |\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        | start   |X|X|a|b|c|d|e|f|g|h|\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        | start+1 |i|j|k|l|X|X|X|X|X|X|\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        |         | ...               |\n        +---------+-+-+-+-+-+-+-+-+-+-+\n\n        is repacked to:\n\n        +-+-+-+-+\n        |0|a|b|c|\n        +-+-+-+-+\n        |1|d|e|f|\n        +-+-+-+-+\n        |2|g|h|i|\n        +-+-+-+-+\n        |3|j|k|l|\n        +-+-+-+-+\n\n        The same repack for msb_first=False is performed as follows:\n\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        |         | MSB ... LSB       |\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        |         | ...               |\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        | start   |h|g|f|e|d|c|b|a|X|X|\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        | start+1 |X|X|X|X|X|X|l|k|j|i|\n        +---------+-+-+-+-+-+-+-+-+-+-+\n        |         | ...               |\n        +---------+-+-+-+-+-+-+-+-+-+-+\n\n        into:\n\n        +-+-+-+-+\n        |0|c|b|a|\n        +-+-+-+-+\n        |1|f|e|d|\n        +-+-+-+-+\n        |2|i|h|g|\n        +-+-+-+-+\n        |3|l|k|j|\n        +-+-+-+-+\n        \"\"\"\n        to_width = operator.index(to_width)\n        if not isinstance(msb_first, bool):\n            raise TypeError('msb_first must be a bool')\n        available = self.repack_data_available(\n                to_width, start=start, start_bit=start_bit)\n        if length is None:\n            length = available\n        else:\n            length = operator.index(length)\n            if length > available:\n                raise ValueError('not enough data available')\n            if length < 0:\n                raise ValueError('length cannot be negative')\n        start = operator.index(start)\n        start_bit = operator.index(start_bit)\n        pos = start\n        accum = BinWord(0, 0)\n        if start_bit:\n            accum = self[pos]\n            pos += 1\n            rest = accum.width - start_bit\n            if msb_first:\n                accum = accum.extract(0, rest)\n            else:\n                accum = accum.extract(start_bit, rest)\n        res = BinArray(width=to_width, length=length)\n        for idx in range(length):\n            while len(accum) < to_width:\n                cur = self[pos]\n                pos += 1\n                if msb_first:\n                    accum = BinWord.concat(cur, accum)\n                else:\n                    accum = BinWord.concat(accum, cur)\n            rest = accum.width - to_width\n            if msb_first:\n                cur = accum.extract(rest, to_width)\n                accum = accum.extract(0, rest)\n            else:\n                cur = accum.extract(0, to_width)\n                accum = accum.extract(to_width, rest)\n            res[idx] = cur\n        return res", "response": "Extracts a part of a BinArray s data and converts it to a BinArray of a different width."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating how many source words would be read for an invocation of repack with a given length, including possible partial words at the beginning and the end of the repack source. This can be called either on a concrete BinArray instance (assuming its width as the source width), or on the BinArray class (providing the source width as an extra first argument). This function doesn't take ``start`` or ``msb_first`` parameters, since they wouldn't affect the computation.", "response": "def repack_source_required(src_width, to_width, length, *,  # noqa: N805\n                               start_bit=0):\n        \"\"\"Calculates how many source words would be read for an invocation of\n        repack with a given length, including possible partial words at\n        the beginning and the end of the repack source.  This can be called\n        either on a concrete BinArray instance (assuming its width as the\n        source width), or on the BinArray class (providing the source width\n        as an extra first argument).  This function doesn't take ``start``\n        or ``msb_first`` parameters, since they wouldn't affect the\n        computation.\n        \"\"\"\n        if isinstance(src_width, BinArray):\n            src_width = src_width._width\n        src_width = operator.index(src_width)\n        to_width = operator.index(to_width)\n        length = operator.index(length)\n        start_bit = operator.index(start_bit)\n        if src_width <= 0:\n            raise ValueError('source width must be positive')\n        if to_width <= 0:\n            raise ValueError('destination width must be positive')\n        if length < 0:\n            raise ValueError('length must not be negative')\n        if start_bit not in range(src_width):\n            raise ValueError('start bit must be in [0, src_width)')\n        return BinInt(start_bit + to_width * length).ceildiv(src_width)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate the maximum number of words that can be requested from a repack invocation with the given settings.", "response": "def repack_data_available(src_width, to_width, *,  # noqa: N805\n                              src_length=None, start=None, start_bit=0):\n        \"\"\"Calculates the maximum number of words that can be requested\n        from a repack invocation with the given settings.\n\n        This function can be called either on a BinArray instance (assuming\n        its width as the source width), or on the BinArray class (passing\n        the source width as an extra first argument).  If called in the\n        second form, ``src_length`` must be provided.  Otherwise, it will\n        default to the number of words in the source array from the given\n        ``start`` index (defaulting to 0) until the end.\n        \"\"\"\n        start_bit = operator.index(start_bit)\n        if isinstance(src_width, BinArray):\n            self = src_width\n            if src_length is None:\n                if start is None:\n                    start = 0\n                else:\n                    start = operator.index(start)\n                    if start < 0:\n                        raise ValueError('start must not be negative')\n                src_length = len(self) - start\n                start = None\n            src_width = self.width\n        if src_length is None:\n            raise TypeError('no length given')\n        if start is not None:\n            raise TypeError('start is redundant with explicit src_length')\n        src_width = operator.index(src_width)\n        to_width = operator.index(to_width)\n        src_length = operator.index(src_length)\n        start_bit = operator.index(start_bit)\n        if src_width <= 0:\n            raise ValueError('source width must be positive')\n        if to_width <= 0:\n            raise ValueError('destination width must be positive')\n        if src_length < 0:\n            raise ValueError('src_length must not be negative')\n        if start_bit not in range(src_width):\n            raise ValueError('start bit must be in [0, src_width)')\n        if src_length == 0 and start_bit != 0:\n            raise ValueError(\n                    'src_length must be positive if start_bit is not zero')\n        return (src_width * src_length - start_bit) // to_width"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the unit_conversion object", "response": "def get(self):\n        \"\"\"\n        *get the unit_conversion object*\n\n        **Return:**\n            - ``unit_conversion``\n\n        .. todo::\n\n            - @review: when complete, clean get method\n            - @review: when complete add logging\n        \"\"\"\n        self.log.info('starting the ``get`` method')\n\n        unit_conversion = None\n\n        self.log.info('completed the ``get`` method')\n        return unit_conversion"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ra_sexegesimal_to_decimal(\n        self,\n        ra\n    ):\n        \"\"\"\n        *Convert a right-ascension from sexegesimal format to decimal degrees.*\n\n        Precision should be respected. If a float is passed to this method, the same float will be returned (useful if unclear which format coordinates are in).\n\n        The code will attempt to read the sexegesimal value in whatever form it is passed. Any of the following should be handled correctly\n\n        - ``23:45:21.23232``\n        - ``23h45m21.23232s``\n        - ``23 45 21.23232``\n        - ``2 04 21.23232``\n        - ``04:45  21``\n\n        **Key Arguments:**\n            - ``ra`` -- ra in sexegesimal units\n\n        **Return:**\n            - ``decimalDegrees``\n\n        **Usage:**\n\n            .. code-block:: python\n\n                - replace dryxPython ra_sexegesimal_to_decimal with this version in all my code\n\n                from astrocalc.coords import unit_conversion\n                converter = unit_conversion(\n                    log=log\n                )\n                ra = converter.ra_sexegesimal_to_decimal(\n                    ra=\"04:45  21\"\n                )\n                print ra\n\n                # OUTPUT: 71.3375\n        \"\"\"\n        import re\n\n        # TEST TO SEE IF DECIMAL DEGREES PASSED\n        try:\n            ra = float(ra)\n            if ra >= 0. and ra <= 360.:\n                self.log.info(\n                    'RA seems to already be in decimal degrees, returning original value' % locals())\n                return float(ra)\n        except:\n            pass\n\n        # REMOVE SURROUNDING WHITESPACE\n        ra = str(ra).strip()\n\n        regex = re.compile(\n            '^(\\+?(\\d|[0-1]\\d|2[0-3]))\\D+([0-5]\\d)\\D+([0-6]?\\d(\\.\\d*?)?)(s)?\\s*?$')\n        raMatch = regex.match(ra)\n\n        if raMatch:\n            degrees = raMatch.group(1)\n            minutes = raMatch.group(3)\n            seconds = raMatch.group(4)\n\n            degrees = abs(float(degrees)) * 15.0\n            minutes = float(minutes) * 15.0\n            seconds = float(seconds) * 15.0\n\n            # PRECISION TEST\n            # 1s ARCSEC = .000018519 DEGREE\n            # THEREFORE REPORT SECONDS TO A PRECISION = INPUT PRECISION + 5\n            decimalLen = len(repr(seconds).split(\".\")[-1])\n            precision = decimalLen + 5\n\n            decimalDegrees = (degrees + (minutes / 60.0)\n                              + (seconds / 3600.0))\n\n            decimalDegrees = \"%0.*f\" % (precision, decimalDegrees)\n\n        else:\n            raise IOError(\n                \"could not convert ra to decimal degrees, could not parse sexegesimal input. Original value was `%(ra)s`\" % locals())\n\n        raDeg = decimalDegrees\n        self.log.debug('raDeg: %(decimalDegrees)s' % locals())\n        self.log.info(\n            'completed the ``ra_sexegesimal_to_decimal`` method')\n\n        return float(raDeg)", "response": "This method converts a sexegesimal value to decimal degrees."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ra_decimal_to_sexegesimal(\n            self,\n            ra,\n            delimiter=\":\"):\n        \"\"\"\n        *Convert a right-ascension between decimal degrees and sexegesimal.*\n\n        Precision should be respected.\n\n        **Key Arguments:**\n            - ``ra`` -- RA in decimal degrees. Will try and convert to float before performing calculation.\n            - ``delimiter`` -- how to delimit the RA units. Default *:*\n\n        **Return:**\n            - ``sexegesimal`` -- ra in sexegesimal units\n\n        **Usage:**\n            ..  todo::\n\n                - replace ra_to_sex from dryxPython in all code\n\n            .. code-block:: python \n\n                from astrocalc.coords import unit_conversion\n                converter = unit_conversion(\n                    log=log\n                )\n                ra = converter.ra_decimal_to_sexegesimal(\n                    ra=\"-23.454676456\",\n                    delimiter=\":\"\n                )\n                print ra\n\n                # OUT: 22:26:10.87\n        \"\"\"\n        self.log.info('starting the ``ra_decimal_to_sexegesimal`` method')\n\n        # CONVERT RA TO FLOAT\n        try:\n            self.log.debug(\"attempting to convert RA to float\")\n            ra = float(ra)\n        except Exception, e:\n            self.log.error(\n                \"could not convert RA to float - failed with this error: %s \" % (str(e),))\n            return -1\n\n        # COMPLAIN IF RA NOT BETWEEN -360 - 360\n        if ra > 0. and ra < 360.:\n            pass\n        elif ra < 0 and ra > -360.:\n            ra = 360. + ra\n        else:\n            self.log.error(\n                \"RA must be between 0 - 360 degrees\")\n            return -1\n\n        # PRECISION TEST\n        # 1s ARCSEC = .000018519 DEGREE\n        # THEREFORE REPORT SECONDS TO A PRECISION = INPUT PRECISION - 5\n        decimalLen = len(repr(ra).split(\".\")[-1])\n        precision = decimalLen - 5\n\n        # CALCULATION FROM DECIMAL DEGREES\n        import math\n        ra_hh = int(ra / 15)\n        ra_mm = int((ra / 15 - ra_hh) * 60)\n        ra_ss = int(((ra / 15 - ra_hh) * 60 - ra_mm) * 60)\n        ra_ff = ((ra / 15 - ra_hh) * 60 - ra_mm) * 60 - ra_ss\n\n        # SET PRECISION\n        ra_ff = repr(ra_ff)[2:]\n        ra_ff = ra_ff[:precision]\n        if len(ra_ff):\n            ra_ff = \".\" + ra_ff\n        if precision < 0:\n            ra_ff = \"\"\n\n        sexegesimal = '%02d' % ra_hh + delimiter + '%02d' % ra_mm + \\\n            delimiter + '%02d' % ra_ss + ra_ff\n\n        self.log.info('completed the ``ra_decimal_to_sexegesimal`` method')\n        return sexegesimal", "response": "Convert a ra decimal number to sexegesimal number."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dec_decimal_to_sexegesimal(\n            self,\n            dec,\n            delimiter=\":\"):\n        \"\"\"\n        *Convert a declination between decimal degrees and sexegesimal.*\n\n        Precision should be respected.\n\n        **Key Arguments:**\n            - ``dec`` -- DEC in decimal degrees. Will try and convert to float before performing calculation.\n            - ``delimiter`` -- how to delimit the RA units. Default *:*\n\n        **Return:**\n            - ``sexegesimal`` -- ra in sexegesimal units\n\n        **Usage:**\n            ..  todo::\n\n                - replace dec_to_sex in dryxPython in all code\n\n            .. code-block:: python \n\n                from astrocalc.coords import unit_conversion\n                converter = unit_conversion(\n                    log=log\n                )\n                dec = converter.dec_decimal_to_sexegesimal(\n                    dec=\"-3.454676456\",\n                    delimiter=\":\"\n                )\n                print dec\n\n                # OUT: -03:27:16.8\n        \"\"\"\n        self.log.info('starting the ``dec_decimal_to_sexegesimal`` method')\n\n        import math\n\n        # CONVERT DEC TO FLOAT\n        try:\n            self.log.debug(\"attempting to convert RA to float\")\n            dec = float(dec)\n        except Exception, e:\n            self.log.error(\n                \"could not convert RA to float - failed with this error: %s \" % (str(e),))\n            return -1\n\n        # COMPLAIN IF DEC NOT BETWEEN -90 - 90\n        if dec > -90. and dec < 90.:\n            pass\n        else:\n            self.log.error(\n                \"DEC must be between -90 - 90 degrees\")\n            return -1\n\n        if (dec >= 0):\n            hemisphere = '+'\n        else:\n            hemisphere = '-'\n            dec *= -1\n\n        # PRECISION TEST\n        # 1s = .000277778 DEGREE\n        # THEREFORE REPORT SECONDS TO A PRECISION = INPUT PRECISION - 4\n        decimalLen = len(repr(dec).split(\".\")[-1])\n        precision = decimalLen - 4\n\n        dec_deg = int(dec)\n        dec_mm = int((dec - dec_deg) * 60)\n        dec_ss = int(((dec - dec_deg) * 60 - dec_mm) * 60)\n        dec_f = (((dec - dec_deg) * 60 - dec_mm) * 60) - dec_ss\n\n        # SET PRECISION\n        dec_f = repr(dec_f)[2:]\n        dec_f = dec_f[:precision]\n        if len(dec_f):\n            dec_f = \".\" + dec_f\n        if precision < 0:\n            dec_f = \"\"\n\n        sexegesimal = hemisphere + '%02d' % dec_deg + delimiter + \\\n            '%02d' % dec_mm + delimiter + '%02d' % dec_ss + dec_f\n\n        self.log.info('completed the ``dec_decimal_to_sexegesimal`` method')\n        return sexegesimal", "response": "Convert a declination between decimal degrees and sexegesimal units to ra in sexegesimal units."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ra_dec_to_cartesian(\n            self,\n            ra,\n            dec):\n        \"\"\"*Convert an RA, DEC coordinate set to x, y, z cartesian coordinates*\n\n        **Key Arguments:**\n            - ``ra`` -- right ascension in sexegesimal or decimal degress.\n            - ``dec`` -- declination in sexegesimal or decimal degress.\n\n        **Return:**\n            - ``cartesians`` -- tuple of (x, y, z) coordinates\n\n        ..  todo::\n\n            - replace calculate_cartesians in all code\n\n        **Usage:**\n\n            .. code-block:: python \n\n                from astrocalc.coords import unit_conversion\n                converter = unit_conversion(\n                    log=log\n                )\n                x, y, z = converter.ra_dec_to_cartesian(\n                    ra=\"23 45 21.23232\",\n                    dec=\"+01:58:5.45341\"\n                )\n                print x, y, z\n\n                # OUTPUT: 0.9973699780687104, -0.06382462462791459, 0.034344492110465606\n        \"\"\"\n        self.log.info('starting the ``ra_dec_to_cartesian`` method')\n\n        ra = self.ra_sexegesimal_to_decimal(\n            ra=ra\n        )\n        dec = self.dec_sexegesimal_to_decimal(\n            dec=dec\n        )\n\n        ra = math.radians(ra)\n        dec = math.radians(dec)\n        cos_dec = math.cos(dec)\n        cx = math.cos(ra) * cos_dec\n        cy = math.sin(ra) * cos_dec\n        cz = math.sin(dec)\n\n        cartesians = (cx, cy, cz)\n\n        self.log.info('completed the ``ra_dec_to_cartesian`` method')\n        return cartesians", "response": "This function converts an RA DEC coordinate set to x y z cartesian coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bucket_to_dataframe(name, buckets, append_name=None):\n    '''A function that turns elasticsearch aggregation buckets into dataframes\n\n        :param name: The name of the bucket (will be a column in the dataframe)\n        :type name: str\n        :param bucket: a bucket from elasticsearch results\n        :type bucket: list[dict]\n        :returns: pandas.DataFrame\n    '''\n    expanded_buckets = []\n    for item in buckets:\n        if type(item) is dict:\n            single_dict = item\n        else:\n            single_dict = item.to_dict()\n        single_dict[name] = single_dict.pop('doc_count')\n        if append_name:\n            persistance_dict = single_dict.copy()\n            for key in persistance_dict.keys():\n                single_dict[append_name + '.' + key] = single_dict.pop(key)\n        expanded_buckets.append(single_dict)\n    return pd.DataFrame(expanded_buckets)", "response": "A function that turns elasticsearch aggregation buckets into dataframes\nAttributeNames"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge_dataframes(*dfs):\n    '''A helper function for merging two dataframes that have the same indices, duplicate columns are removed\n\n        :param dfs: a list of dataframes to be merged (note: they must have the same indices)\n        :type dfs: list[pandas.DataFrame]\n        :returns: pandas.DataFrame -- a merged dataframe\n    '''\n    merged_dataframe = pd.concat(dfs, axis=1, join_axes=[dfs[0].index])\n    return merged_dataframe.transpose().drop_duplicates().transpose()", "response": "A helper function for merging two dataframes that have the same indices duplicate columns are removed from the dataframe"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nre-order a miz file into a folder (flattened) Args: miz_file_path: source miz file target_dir: folder to flatten the content into skip_options_file: do not re-order option file", "response": "def reorder(miz_file_path: typing.Union[str, Path],\n                target_dir: typing.Union[str, Path],\n                skip_options_file: bool,\n                ):\n        \"\"\"\n        Re-orders a miz file into a folder (flattened)\n\n        Args:\n            miz_file_path: source miz file\n            target_dir: folder to flatten the content into\n            skip_options_file: do not re-order option file\n\n        \"\"\"\n\n        miz_file_path = Path(miz_file_path).absolute()\n        if not miz_file_path.exists():\n            raise FileNotFoundError(miz_file_path)\n        if not miz_file_path.is_file():\n            raise ValueError(f'not a file: {miz_file_path}')\n\n        target_dir_path = Path(target_dir).absolute()\n        if not target_dir_path.exists():\n            target_dir_path.mkdir(parents=True)\n        else:\n            if not target_dir_path.is_dir():\n                raise ValueError(f'not a directory: {target_dir_path}')\n\n        LOGGER.debug('re-ordering miz file: %s', miz_file_path)\n        LOGGER.debug('destination folder: %s', target_dir)\n        LOGGER.debug('%s option file', \"skipping\" if skip_options_file else \"including\")\n\n        if not target_dir_path.exists():\n            LOGGER.debug('creating directory %s', target_dir_path)\n            target_dir_path.mkdir(exist_ok=True)\n\n        Miz._do_reorder(miz_file_path, skip_options_file, target_dir_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decode(self):\n\n        LOGGER.debug('decoding lua tables')\n\n        if not self.zip_content:\n            self.unzip()\n\n        LOGGER.debug('reading map resource file')\n        with open(str(self.map_res_file), encoding=ENCODING) as stream:\n            self._map_res, self._map_res_qual = SLTP().decode(stream.read())\n\n        LOGGER.debug('reading l10n file')\n        with open(str(self.dictionary_file), encoding=ENCODING) as stream:\n            self._l10n, self._l10n_qual = SLTP().decode(stream.read())\n\n        LOGGER.debug('reading mission file')\n        with open(str(self.mission_file), encoding=ENCODING) as stream:\n            mission_data, self._mission_qual = SLTP().decode(stream.read())\n            self._mission = Mission(mission_data, self._l10n)\n\n        LOGGER.debug('gathering resources')\n        for file in Path(self.temp_dir, 'l10n', 'DEFAULT').iterdir():\n            if file.name in ('dictionary', 'mapResource'):\n                continue\n            LOGGER.debug('found resource: %s', file.name)\n            self._resources.add(file.name)\n\n        LOGGER.debug('decoding done')", "response": "Decodes the map resource file into dictionaries"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unzip(self, overwrite: bool = False):\n\n        if self.zip_content and not overwrite:\n            raise FileExistsError(str(self.temp_dir))\n\n        LOGGER.debug('unzipping miz to temp dir')\n\n        try:\n\n            with ZipFile(str(self.miz_path)) as zip_file:\n\n                LOGGER.debug('reading infolist')\n\n                self.zip_content = [f.filename for f in zip_file.infolist()]\n\n                self._extract_files_from_zip(zip_file)\n\n        except BadZipFile:\n            raise BadZipFile(str(self.miz_path))\n\n        except:  # noqa: E722\n            LOGGER.exception('error while unzipping miz file: %s', self.miz_path)\n            raise\n\n        LOGGER.debug('checking miz content')\n\n        # noinspection PyTypeChecker\n        for miz_item in ['mission', 'options', 'warehouses', 'l10n/DEFAULT/dictionary', 'l10n/DEFAULT/mapResource']:\n            if not Path(self.temp_dir.joinpath(miz_item)).exists():\n                LOGGER.error('missing file in miz: %s', miz_item)\n                raise FileNotFoundError(miz_item)\n\n        self._check_extracted_content()\n\n        LOGGER.debug('all files have been found, miz successfully unzipped')", "response": "Unzips a MIZ file into the temp dir."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef distance_to_redshift(\n            self,\n            mpc):\n        \"\"\"*Convert a distance from MPC to redshift*\n\n        The code works by iteratively converting a redshift to a distance, correcting itself and honing in on the true answer (within a certain precision)\n\n        **Key Arguments:**\n            - ``mpc`` -- distance in MPC (assumes a luminousity distance).\n\n        **Return:**\n            - ``redshift``\n\n        .. todo::\n\n            - replace convert_mpc_to_redshift in all code\n\n        **Usage:**\n\n            .. code-block:: python\n\n                from astrocalc.distances import converter\n                c = converter(log=log)\n                z = c.distance_to_redshift(\n                    mpc=500\n                )\n\n                print z\n\n                # OUTPUT: 0.108\n        \"\"\"\n        self.log.info('starting the ``distance_to_redshift`` method')\n\n        lowerLimit = 0.\n        upperLimit = 30.\n        redshift = upperLimit - lowerLimit\n        distGuess = float(self.redshift_to_distance(redshift)['dl_mpc'])\n\n        distDiff = mpc - distGuess\n\n        while math.fabs(distDiff) > 0.0001:\n            if distGuess < mpc:\n                lowerLimit = redshift\n                redshift = lowerLimit + (upperLimit - lowerLimit) / 2.\n                distGuess = float(\n                    self.redshift_to_distance(redshift)['dl_mpc'])\n            elif distGuess > mpc:\n                upperLimit = redshift\n                redshift = lowerLimit + (upperLimit - lowerLimit) / 2.\n                distGuess = float(\n                    self.redshift_to_distance(redshift)['dl_mpc'])\n            distDiff = mpc - distGuess\n\n        redshift = float(\"%5.4f\" % (redshift,))\n\n        self.log.info('completed the ``distance_to_redshift`` method')\n        return redshift", "response": "This function converts a distance from MPC to redshift."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef redshift_to_distance(\n            self,\n            z,\n            WM=0.3,\n            WV=0.7,\n            H0=70.0):\n        \"\"\"*convert redshift to various distance measurements*\n\n        **Key Arguments:**\n            - ``z`` -- redshift measurement.\n            - ``WM`` -- Omega_matter. Default *0.3*\n            - ``WV`` -- Omega_vacuum. Default *0.7*\n            - ``H0`` -- Hubble constant. (km s-1 Mpc-1) Default *70.0*\n\n        **Return:**\n            - ``results`` -- result dictionary including\n                - ``dcmr_mpc`` -- co-moving radius distance\n                - ``da_mpc`` -- angular distance\n                - ``da_scale`` -- angular distance scale\n                - ``dl_mpc`` -- luminosity distance (usually use this one)\n                - ``dmod`` -- distance modulus (determined from luminosity distance)\n\n        ..  todo::\n\n                - replace convert_redshift_to_distance in all other code\n\n        **Usage:**\n\n            .. code-block:: python\n\n                from astrocalc.distances import converter\n                c = converter(log=log)\n                dists = c.redshift_to_distance(\n                    z=0.343\n                )\n\n                print \"Distance Modulus: \" + str(dists[\"dmod\"]) + \" mag\"\n                print \"Luminousity Distance: \" + str(dists[\"dl_mpc\"]) + \" Mpc\"\n                print \"Angular Size Scale: \" + str(dists[\"da_scale\"]) + \" kpc/arcsec\"\n                print \"Angular Size Distance: \" + str(dists[\"da_mpc\"]) + \" Mpc\"\n                print \"Comoving Radial Distance: \" + str(dists[\"dcmr_mpc\"]) + \" Mpc\"\n\n                # OUTPUT :\n                # Distance Modulus: 41.27 mag\n                # Luminousity Distance: 1795.16 Mpc\n                # Angular Size Scale: 4.85 kpc/arcsec\n                # Angular Size Distance: 999.76 Mpc\n                # Comoving Radial Distance: 1339.68 Mpc\n\n                from astrocalc.distances import converter\n                c = converter(log=log)\n                dists = c.redshift_to_distance(\n                    z=0.343,\n                    WM=0.286,\n                    WV=0.714,\n                    H0=69.6\n                )\n\n                print \"Distance Modulus: \" + str(dists[\"dmod\"]) + \" mag\"\n                print \"Luminousity Distance: \" + str(dists[\"dl_mpc\"]) + \" Mpc\"\n                print \"Angular Size Scale: \" + str(dists[\"da_scale\"]) + \" kpc/arcsec\"\n                print \"Angular Size Distance: \" + str(dists[\"da_mpc\"]) + \" Mpc\"\n                print \"Comoving Radial Distance: \" + str(dists[\"dcmr_mpc\"]) + \" Mpc\"\n\n                # OUTPUT :\n                # Distance Modulus: 41.29 mag\n                # Luminousity Distance: 1811.71 Mpc\n                # Angular Size Scale: 4.89 kpc/arcsec\n                # Angular Size Distance: 1008.97 Mpc\n                # Comoving Radial Distance: 1352.03 Mpc\n\n        \"\"\"\n        self.log.info('starting the ``redshift_to_distance`` method')\n\n        # VARIABLE\n        h = H0 / 100.0\n        WR = 4.165E-5 / (h * h)     # Omega_radiation\n        WK = 1.0 - WM - WV - WR       # Omega_curvature = 1 - Omega(Total)\n        c = 299792.458          # speed of light (km/s)\n\n        # Arbitrarily set the values of these variables to zero just so we can\n        # define them.\n        DCMR = 0.0             # comoving radial distance in units of c/H0\n        DCMR_Mpc = 0.0          # comoving radial distance in units of Mpc\n        DA = 0.0                # angular size distance in units of c/H0\n        DA_Mpc = 0.0            # angular size distance in units of Mpc\n        # scale at angular size distance in units of Kpc / arcsec\n        DA_scale = 0.0\n        DL = 0.0                # luminosity distance in units of c/H0\n        DL_Mpc = 0.0            # luminosity distance in units of Mpc\n        # Distance modulus determined from luminosity distance\n        DMOD = 0.0\n        a = 0.0                 # 1/(1+z), the scale factor of the Universe\n\n        az = 1.0 / (1.0 + z)        # 1/(1+z), for the given redshift\n\n        # Compute the integral over a=1/(1+z) from az to 1 in n steps\n        n = 1000\n        for i in range(n):\n            a = az + (1.0 - az) * (i + 0.5) / n\n            adot = math.sqrt(WK + (WM / a) + (WR / (math.pow(a, 2)))\n                             + (WV * math.pow(a, 2)))\n            DCMR = DCMR + 1.0 / (a * adot)\n\n        # comoving radial distance in units of c/H0\n        DCMR = (1.0 - az) * DCMR / n\n        # comoving radial distance in units of Mpc\n        DCMR_Mpc = (c / H0) * DCMR\n\n        # Tangental comoving radial distance\n        x = math.sqrt(abs(WK)) * DCMR\n        if x > 0.1:\n            if WK > 0.0:\n                ratio = 0.5 * (math.exp(x) - math.exp(-x)) / x\n            else:\n                ratio = math.sin(x) / x\n        else:\n            y = math.pow(x, 2)\n            if WK < 0.0:\n                y = -y\n            ratio = 1 + y / 6.0 + math.pow(y, 2) / 120.0\n\n        DA = az * ratio * DCMR  # angular size distance in units of c/H0\n        DA_Mpc = (c / H0) * DA  # angular size distance in units of Mpc\n        # scale at angular size distance in units of Kpc / arcsec\n        DA_scale = DA_Mpc / 206.264806\n        DL = DA / math.pow(az, 2)  # luminosity distance in units of c/H0\n        DL_Mpc = (c / H0) * DL  # luminosity distance in units of Mpc\n        # Distance modulus determined from luminosity distance\n        DMOD = 5 * math.log10(DL_Mpc * 1e6) - 5\n\n        # FIXING PRECISIONS\n        # PRECISION TEST\n        precision = len(repr(z).split(\".\")[-1])\n        DCMR_Mpc = \"%0.*f\" % (precision, DCMR_Mpc)\n        DA_Mpc = \"%0.*f\" % (precision, DA_Mpc)\n        DA_scale = \"%0.*f\" % (precision, DA_scale)\n        DL_Mpc = \"%0.*f\" % (precision, DL_Mpc)\n        DMOD = \"%0.*f\" % (precision, DMOD)\n        z = \"%0.*f\" % (precision, z)\n\n        results = \\\n            {\n                \"dcmr_mpc\": float(DCMR_Mpc),\n                \"da_mpc\": float(DA_Mpc),\n                \"da_scale\": float(DA_scale),\n                \"dl_mpc\": float(DL_Mpc),\n                \"dmod\": float(DMOD),\n                \"z\": float(z)\n            }\n\n        self.log.info('completed the ``redshift_to_distance`` method')\n        return results", "response": "convert redshift to various distance measurements"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __fix_bases(base_classes, have_mt):\n        fixed = list(base_classes)\n        contains_model = False\n        for b in fixed:\n            if isinstance(fixed, Model): contains_model = True; break\n            pass\n\n        # adds a model when user is lazy\n        if not contains_model:\n            if have_mt:\n                from gtkmvc3.model_mt import ModelMT\n                fixed.insert(0, ModelMT)\n            else: fixed.insert(0, Model)\n            pass\n\n        class ModelFactoryWrap (object):\n            __metaclass__ = get_noconflict_metaclass(tuple(fixed), (), ())\n            def __init__(self, *args, **kwargs): pass\n            pass\n\n        fixed.append(ModelFactoryWrap)\n        fixed.sort()\n        return tuple(fixed)", "response": "This function checks whether the base_classes contains a Model object and adds a ModelMT to the list of base classes. If not choose the best fitting class for the base object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nusing this static method to build a model class that is derived from other classes.", "response": "def make(base_classes=(), have_mt=False):\n        \"\"\"Use this static method to build a model class that\n        possibly derives from other classes. If have_mt is True,\n        then returned class will take into account multi-threading\n        issues when dealing with observable properties.\"\"\"\n\n        good_bc = ModelFactory.__fix_bases(base_classes, have_mt)\n        print \"Base classes are:\", good_bc\n        key = \"\".join(map(str, good_bc))\n        if key in ModelFactory.__memoized:\n            return ModelFactory.__memoized[key]\n\n        cls = new.classobj('', good_bc, {'__module__': '__main__', '__doc__': None})\n        ModelFactory.__memoized[key] = cls\n        return cls"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef require(request):\n    try:\n        request = request.split(\".\")\n    except AttributeError:\n        pass\n    request = [int(x) for x in request]\n\n    provide = list(__version)\n\n    if request > provide:\n        raise AssertionError(\"gtkmvc3 required version %s, found %s\" % (\n            request, provide))", "response": "Assert that the specified version of the current version is compatible with the given request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handler(key_file=None, cert_file=None, timeout=None):\n\n    def connect(scheme, host, port):\n        kwargs = {}\n        if timeout is not None: kwargs['timeout'] = timeout\n        if scheme == \"http\":\n            return httplib.HTTPConnection(host, port, **kwargs)\n        if scheme == \"https\":\n            if key_file is not None: kwargs['key_file'] = key_file\n            if cert_file is not None: kwargs['cert_file'] = cert_file\n            return httplib.HTTPSConnection(host, port, **kwargs)\n        raise ValueError(\"unsupported scheme: %s\" % scheme)\n\n    def request(url, message, **kwargs):\n        scheme, host, port, path = _spliturl(url)\n        body = message.get(\"body\", \"\")\n        head = {\n            \"Content-Length\": str(len(body)),\n            \"Host\": host,\n            \"User-Agent\": \"splunk-sdk-python/0.1\",\n            \"Accept\": \"*/*\",\n        } # defaults\n        for key, value in message[\"headers\"]:\n            head[key] = value\n        method = message.get(\"method\", \"GET\")\n\n        connection = connect(scheme, host, port)\n        try:\n            connection.request(method, path, body, head)\n            if timeout is not None:\n                connection.sock.settimeout(timeout)\n            response = connection.getresponse()\n        finally:\n            connection.close()\n\n        return {\n            \"status\": response.status,\n            \"reason\": response.reason,\n            \"headers\": response.getheaders(),\n            \"body\": ResponseReader(response),\n        }\n\n    return request", "response": "This class returns an instance of the default HTTP request handler using the values you provide."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _auth_headers(self):\n        if self.token is _NoAuthenticationToken:\n            return []\n        else:\n            # Ensure the token is properly formatted\n            if self.token.startswith('Splunk '):\n                token = self.token\n            else:\n                token = 'Splunk %s' % self.token\n            return [(\"Authorization\", token)]", "response": "Returns a list of headers required to authenticate a request."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform a GET operation from the REST path segment with the given owner app and sharing mode and query.", "response": "def get(self, path_segment, owner=None, app=None, sharing=None, **query):\n        \"\"\"Performs a GET operation from the REST path segment with the given\n        namespace and query.\n\n        This method is named to match the HTTP method. ``get`` makes at least\n        one round trip to the server, one additional round trip for each 303\n        status returned, and at most two additional round trips if\n        the ``autologin`` field of :func:`connect` is set to ``True``.\n\n        If *owner*, *app*, and *sharing* are omitted, this method uses the\n        default :class:`Context` namespace. All other keyword arguments are\n        included in the URL as query parameters.\n\n        :raises AuthenticationError: Raised when the ``Context`` object is not\n             logged in.\n        :raises HTTPError: Raised when an error occurred in a GET operation from\n             *path_segment*.\n        :param path_segment: A REST path segment.\n        :type path_segment: ``string``\n        :param owner: The owner context of the namespace (optional).\n        :type owner: ``string``\n        :param app: The app context of the namespace (optional).\n        :type app: ``string``\n        :param sharing: The sharing mode of the namespace (optional).\n        :type sharing: ``string``\n        :param query: All other keyword arguments, which are used as query\n            parameters.\n        :type query: ``string``\n        :return: The response from the server.\n        :rtype: ``dict`` with keys ``body``, ``headers``, ``reason``,\n                and ``status``\n\n        **Example**::\n\n            c = binding.connect(...)\n            c.get('apps/local') == \\\\\n                {'body': ...a response reader object...,\n                 'headers': [('content-length', '26208'),\n                             ('expires', 'Fri, 30 Oct 1998 00:00:00 GMT'),\n                             ('server', 'Splunkd'),\n                             ('connection', 'close'),\n                             ('cache-control', 'no-store, max-age=0, must-revalidate, no-cache'),\n                             ('date', 'Fri, 11 May 2012 16:30:35 GMT'),\n                             ('content-type', 'text/xml; charset=utf-8')],\n                 'reason': 'OK',\n                 'status': 200}\n            c.get('nonexistant/path') # raises HTTPError\n            c.logout()\n            c.get('apps/local') # raises AuthenticationError\n        \"\"\"\n        path = self.authority + self._abspath(path_segment, owner=owner,\n                                              app=app, sharing=sharing)\n        logging.debug(\"GET request to %s (body: %s)\", path, repr(query))\n        response = self.http.get(path, self._auth_headers, **query)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a POST request to a URL.", "response": "def post(self, url, headers=None, **kwargs):\n        \"\"\"Sends a POST request to a URL.\n\n        :param url: The URL.\n        :type url: ``string``\n        :param headers: A list of pairs specifying the headers for the HTTP\n            response (for example, ``[('Content-Type': 'text/cthulhu'), ('Token': 'boris')]``).\n        :type headers: ``list``\n        :param kwargs: Additional keyword arguments (optional). If the argument\n            is ``body``, the value is used as the body for the request, and the\n            keywords and their arguments will be URL encoded. If there is no\n            ``body`` keyword argument, all the keyword arguments are encoded\n            into the body of the request in the format ``x-www-form-urlencoded``.\n        :type kwargs: ``dict``\n        :returns: A dictionary describing the response (see :class:`HttpLib` for\n            its structure).\n        :rtype: ``dict``\n        \"\"\"\n        if headers is None: headers = []\n        headers.append((\"Content-Type\", \"application/x-www-form-urlencoded\")),\n        # We handle GET-style arguments and an unstructured body. This is here\n        # to support the receivers/stream endpoint.\n        if 'body' in kwargs:\n            body = kwargs.pop('body')\n            if len(kwargs) > 0:\n                url = url + UrlEncoded('?' + _encode(**kwargs), skip_encode=True)\n        else:\n            body = _encode(**kwargs)\n        message = {\n            'method': \"POST\",\n            'headers': headers,\n            'body': body\n        }\n        return self.request(url, message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request(self, url, message, **kwargs):\n        response = self.handler(url, message, **kwargs)\n        response = record(response)\n        if 400 <= response.status:\n            raise HTTPError(response)\n        return response", "response": "Issues an HTTP request to a URL."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads a given number of characters from the response.", "response": "def read(self, size = None):\n        \"\"\"Reads a given number of characters from the response.\n\n        :param size: The number of characters to read, or \"None\" to read the\n            entire response.\n        :type size: ``integer`` or \"None\"\n\n        \"\"\"\n        r = self._buffer\n        self._buffer = bytes()\n        if size is not None:\n            size -= len(r)\n        r = r + self._response.read(size)\n        #raise RuntimeError\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform validation of a given value against the schema and configured validation rules.", "response": "def _perform_validation(self, path, value, results):\n        \"\"\"\n        Validates a given value against the schema and configured validation rules.\n\n        :param path: a dot notation path to the value.\n\n        :param value: a value to be validated.\n\n        :param results: a list with validation results to add new results.\n        \"\"\"\n        name = path if path != None else \"value\"\n        value = ObjectReader.get_value(value)\n\n        super(ArraySchema, self)._perform_validation(path, value, results)\n\n        if value == None:\n            return\n\n        if isinstance(value, list) or isinstance(value, set) or isinstance(value, tuple):\n            index = 0\n            for element in value:\n                element_path = str(index) if path == None or len(path) == 0 else path + \".\" + str(index)\n                self._perform_type_validation(element_path, self.value_type, element, results)\n                index += 1\n        else:\n            results.append(\n                ValidationResult(\n                    path,\n                    ValidationResultType.Error,\n                    \"VALUE_ISNOT_ARRAY\",\n                    name + \" type must be List or Array\",\n                    \"List\",\n                    type(value)\n                )\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_proxy_model(self, model):\n        proxy = ReftrackSortFilterModel(self)\n        proxy.setSourceModel(model)\n        model.rowsInserted.connect(self.sort_model)\n        return proxy", "response": "Create a sort filter proxy model for the given model"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconnecting the signals with the slots to make the ui functional", "response": "def setup_signals(self, ):\n        \"\"\"Connect the signals with the slots to make the ui functional\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.showfilter_tb.toggled.connect(self.switch_showfilter_icon)\n        self.addnew_tb.clicked.connect(self.open_addnew_win)\n        self.search_le.editingFinished.connect(self.update_filter)\n        for cb in (self.loaded_checkb, self.unloaded_checkb, self.imported_checkb, self.empty_checkb,\n                   self.newest_checkb, self.old_checkb, self.alien_checkb):\n            cb.toggled.connect(self.update_filter)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets all icons on buttons", "response": "def setup_icons(self, ):\n        \"\"\"Set all icons on buttons\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        plus_icon = get_icon('glyphicons_433_plus_bright.png', asicon=True)\n        self.addnew_tb.setIcon(plus_icon)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a checkbox for every reftrack type so one can filter them", "response": "def setup_filter(self, ):\n        \"\"\"Create a checkbox for every reftrack type so one can filter them\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        types = self.refobjinter.types.keys()\n        for i, t in enumerate(types):\n            cb = QtGui.QCheckBox(\"%s\" % t)\n            cb.setChecked(True)\n            cb.toggled.connect(self.update_filter)\n            self.typecbmap[t] = cb\n            self.typefilter_grid.addWidget(cb, int(i / 4), i % 4)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nswitch the icon on the showfilter_tb", "response": "def switch_showfilter_icon(self, toggled):\n        \"\"\"Switch the icon on the showfilter_tb\n\n        :param toggled: the state of the button\n        :type toggled: :class:`bool`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        at = QtCore.Qt.DownArrow if toggled else QtCore.Qt.RightArrow\n        self.showfilter_tb.setArrowType(at)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nopens a new window so the use can choose to add new reftracks", "response": "def open_addnew_win(self, *args, **kwargs):\n        \"\"\"Open a new window so the use can choose to add new reftracks\n\n        :returns: None\n        :rtype: None\n        :raises: NotImplementedError\n        \"\"\"\n        if self.reftrackadderwin:\n            self.reftrackadderwin.close()\n        self.reftrackadderwin = ReftrackAdderWin(self.refobjinter, self.root, parent=self)\n        self.reftrackadderwin.destroyed.connect(self.addnewwin_destroyed)\n        self.reftrackadderwin.show()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the filter for the current version of the reftrack.", "response": "def update_filter(self, *args, **kwargs):\n        \"\"\"Update the filter\n\n        :returns: None\n        :rtype: None\n        :raises: NotImplementedError\n        \"\"\"\n        forbidden_statuses = []\n        if not self.loaded_checkb.isChecked():\n            forbidden_statuses.append(reftrack.Reftrack.LOADED)\n        if not self.unloaded_checkb.isChecked():\n            forbidden_statuses.append(reftrack.Reftrack.UNLOADED)\n        if not self.imported_checkb.isChecked():\n            forbidden_statuses.append(reftrack.Reftrack.IMPORTED)\n        if not self.empty_checkb.isChecked():\n            forbidden_statuses.append(None)\n        self.proxy.set_forbidden_statuses(forbidden_statuses)\n\n        forbidden_types = []\n        for typ, cb in self.typecbmap.items():\n            if not cb.isChecked():\n                forbidden_types.append(typ)\n        self.proxy.set_forbidden_types(forbidden_types)\n\n        forbidden_uptodate = []\n        if not self.old_checkb.isChecked():\n            forbidden_uptodate.append(False)\n        if not self.newest_checkb.isChecked():\n            forbidden_uptodate.append(True)\n        self.proxy.set_forbidden_uptodate(forbidden_uptodate)\n\n        forbidden_alien = [] if self.alien_checkb.isChecked() else [True]\n        self.proxy.set_forbidden_alien(forbidden_alien)\n\n        self.proxy.setFilterWildcard(self.search_le.text())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsort the proxy model by the model version", "response": "def sort_model(self, *args, **kwargs):\n        \"\"\"Sort the proxy model\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.proxy.sort(17)  # sort the identifier\n        self.proxy.sort(2)  # sort the element\n        self.proxy.sort(1)  # sort the elementgrp\n        self.proxy.sort(0)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_ui(self, ):\n        plus_icon = get_icon('glyphicons_433_plus_bright.png', asicon=True)\n        self.add_tb.setIcon(plus_icon)\n\n        self.shot_browser = ListBrowser(4, parent=self, headers=[\"Project\", \"Sequence\", \"Shot\", \"Type\"])\n        self.asset_browser = ListBrowser(4, parent=self, headers=[\"Project\", \"Assettype\", \"Asset\", \"Type\"])\n\n        self.shotmodel = self.create_shot_model()\n        self.assetmodel = self.create_asset_model()\n\n        self.shot_browser.set_model(self.shotmodel)\n        self.asset_browser.set_model(self.assetmodel)\n\n        self.shot_vbox.addWidget(self.shot_browser)\n        self.asset_vbox.addWidget(self.asset_browser)", "response": "Setup the general ui"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a treemodel with the levels project sequence shot and reftrack type", "response": "def create_shot_model(self, ):\n        \"\"\"Return a treemodel with the levels: project, sequence, shot and reftrack type\n\n        :returns: a treemodel\n        :rtype: :class:`jukeboxcore.gui.treemodel.TreeModel`\n        :raises: None\n        \"\"\"\n        rootdata = treemodel.ListItemData(['Name'])\n        rootitem = treemodel.TreeItem(rootdata)\n        prjs = djadapter.projects.all()\n        for prj in prjs:\n            prjdata = djitemdata.ProjectItemData(prj)\n            prjitem = treemodel.TreeItem(prjdata, rootitem)\n            for seq in prj.sequence_set.all():\n                seqdata = djitemdata.SequenceItemData(seq)\n                seqitem = treemodel.TreeItem(seqdata, prjitem)\n                for shot in seq.shot_set.all():\n                    shotdata = djitemdata.ShotItemData(shot)\n                    shotitem = treemodel.TreeItem(shotdata, seqitem)\n                    for typ in self.refobjinter.get_available_types_for_scene(shot):\n                        typdata = treemodel.ListItemData([typ])\n                        treemodel.TreeItem(typdata, shotitem)\n\n        return treemodel.TreeModel(rootitem)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new treemodel with the levels project assettype asset and reftrack type", "response": "def create_asset_model(self, ):\n        \"\"\"Return a treemodel with the levels: project, assettype, asset and reftrack type\n\n        :returns: a treemodel\n        :rtype: :class:`jukeboxcore.gui.treemodel.TreeModel`\n        :raises: None\n        \"\"\"\n        rootdata = treemodel.ListItemData(['Name'])\n        rootitem = treemodel.TreeItem(rootdata)\n        prjs = djadapter.projects.all()\n        for prj in prjs:\n            prjdata = djitemdata.ProjectItemData(prj)\n            prjitem = treemodel.TreeItem(prjdata, rootitem)\n            for atype in prj.atype_set.all():\n                atypedata = djitemdata.AtypeItemData(atype)\n                atypeitem = treemodel.TreeItem(atypedata, prjitem)\n                for asset in atype.asset_set.filter(project=prj):\n                    assetdata = djitemdata.AssetItemData(asset)\n                    assetitem = treemodel.TreeItem(assetdata, atypeitem)\n                    for typ in self.refobjinter.get_available_types_for_scene(asset):\n                        typdata = treemodel.ListItemData([typ])\n                        treemodel.TreeItem(typdata, assetitem)\n\n        return treemodel.TreeModel(rootitem)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new reftrack with the selected element and type and add it to the root.", "response": "def add_selected(self, ):\n        \"\"\"Create a new reftrack with the selected element and type and add it to the root.\n\n        :returns: None\n        :rtype: None\n        :raises: NotImplementedError\n        \"\"\"\n        browser = self.shot_browser if self.browser_tabw.currentIndex() == 1 else self.asset_browser\n        selelements = browser.selected_indexes(2)\n        if not selelements:\n            return\n        seltypes = browser.selected_indexes(3)\n        if not seltypes:\n            return\n        elementi = selelements[0]\n        typi = seltypes[0]\n        if not elementi.isValid() or not typi.isValid():\n            return\n        element = elementi.internalPointer().internal_data()\n        typ = typi.internalPointer().internal_data()[0]\n\n        reftrack.Reftrack(self.root, self.refobjinter, typ=typ, element=element)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate(self, path, schema, value, results):\n        name = path if path != None else \"value\"\n        found = []\n\n        for prop in self._properties:\n            property_value = ObjectReader.get_property(value, prop)\n            if property_value != None:\n                found.append(prop)\n\n        if len(found) == 0:\n            results.append(\n                ValidationResult(\n                    path,\n                    ValidationResultType.Error,\n                    \"VALUE_NULL\",\n                    name + \" must have at least one property from \" + str(self._properties),\n                    self._properties,\n                    None\n                )\n            )", "response": "Validates a given value against this rule."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nraising error if invalid B6 format detected", "response": "def b6_verifier(entries, line=None):\n    \"\"\"Raises error if invalid B6/M8 format detected\n\n    Args:\n        entries (list): A list of B6Entry instances\n\n        line (int): Line number of first entry\n\n    Raises:\n        FormatError: Error when B6/M8 format incorrect with descriptive message\n\n    Example:\n        >>> from bio_utils.iterators import b6_iter\n        >>> import os\n        >>> entries = 'query1\\tsubject1\\t86.03\\t1782\\t226\\t18\\t6038\\t7812\\t' \\\n        ...           '755762\\t753997\\t0.0\\t1890{0}' \\\n        ...           'query2\\tsubject2\\t85.46\\t1176\\t165\\t5\\t1213\\t2385\\t' \\\n        ...           '1154754\\t1153582\\t0.0\\t1219'.format(os.linesep)\n        >>> b6_entries = b6_iter(iter(entries.split(os.linesep)))\n        >>> b6_verifier(b6_entries)\n    \"\"\"\n\n    regex = r'^.+\\t.+\\t\\d+\\.?\\d*\\t\\d+\\t\\d+\\t\\d+\\t\\d+\\t\\d+\\t\\d+\\t\\d+\\t' \\\n            + r'\\d+\\.?\\d*(e-)?\\d*\\t\\d+\\.?\\d*{0}$'.format(os.linesep)\n    delimiter = r'\\t'\n\n    for entry in entries:\n        try:\n            entry_verifier([entry.write()], regex, delimiter)\n        except FormatError as error:\n            # Format info on what entry error came from\n            if line:\n                intro = 'Line {0}'.format(str(line))\n            elif error.part == 0:\n                intro = 'Entry with subject ID {0}'.format(entry.subject)\n            else:\n                intro = 'Entry with query ID {0}'.format(entry.query)\n\n            # Generate error\n            if error.part == 0:\n                msg = '{0} has no query ID'.format(intro)\n            elif error.part == 1:\n                msg = '{0} has no subject ID'.format(intro)\n            elif error.part == 2:\n                msg = '{0} has non-numerical ' \\\n                      'characters in percent identity'.format(intro)\n            elif error.part == 3:\n                msg = '{0} has non-numerical ' \\\n                      'characters in alignment length'.format(intro)\n            elif error.part == 4:\n                msg = '{0} has non-numerical ' \\\n                      'characters in mismatches'.format(intro)\n            elif error.part == 5:\n                msg = '{0} has non-numerical ' \\\n                      'characters in gaps'.format(intro)\n            elif error.part == 6:\n                msg = '{0} has non-numerical ' \\\n                      'characters in query start'.format(intro)\n            elif error.part == 7:\n                msg = '{0} has non-numerical ' \\\n                      'characters in query end'.format(intro)\n            elif error.part == 8:\n                msg = '{0} has non-numerical ' \\\n                      'characters in subject start'.format(intro)\n            elif error.part == 9:\n                msg = '{0} has non-numerical ' \\\n                      'characters in subject end'.format(intro)\n            elif error.part == 10:\n                msg = '{0} has non-numerical ' \\\n                      'characters in E-value'.format(intro)\n            elif error.part == 11:\n                msg = '{0} has non-numerical ' \\\n                      'characters in bit score'.format(intro)\n            else:\n                msg = '{0}: Unknown Error: Likely a Bug'.format(intro)\n            raise FormatError(message=msg)\n\n        if line:\n            line += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_roc(roc_structure, inputfilename, options, fw_type = None):\n    # check if ./ROC_DATA exists. If not, create it\n    rocdir = os.path.join(os.getcwd(), 'ROC_DATA')\n    if not os.path.exists(rocdir):\n        os.makedirs(rocdir)\n\n    # generate the root name of the file that will hold the roc data\n    if len(inputfilename.split('.')) == 1:\n        rootname = inputfilename.split('.')\n    else:\n        rootname = inputfilename.split('.csv')[0]\n\n    # add '.csv' to the root name to give the name of the file\n    if fw_type:\n        filename = '%s_fw_roc.csv' % rootname\n    else:\n        filename = '%s_roc.csv' % rootname\n\n    # the path to the file\n    file = os.path.join(rocdir, filename)\n\n    # open file and create a csv writer object\n    f = open(file, 'w')\n    rocwriter = csv.writer(f)\n\n    # create header\n    header = ['id', 'score', 'score source', 'status', 'fpf', 'tpf']\n    rocwriter.writerow(header)\n\n    # write contents\n    for tup in roc_structure:\n        rocwriter.writerow(list(tup))\n\n    f.close()", "response": "Writes ROC data to file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_diff_summary(stats, options):\n    # set output file name\n    out_name = '%s_diff_stats.csv' % options.outname\n    filename = os.path.join(os.getcwd(), out_name)\n\n    # open file & create csv writer object\n    f = open(filename, 'w')\n    statswriter = csv.writer(f)\n\n    # write header\n    statswriter.writerow(stats['header'])\n\n    # write auc\n    line = ['AUC']\n    for metric_tup in stats['AUC']:\n        try:\n            len(metric_tup)\n            line.append('[%0.2f, %0.2f]' % (metric_tup[0], metric_tup[1]))\n        except:\n            line.append('%0.6f' % metric_tup)\n    statswriter.writerow(line)\n\n    # write enrichment factors\n    for title in [x for x in sorted(stats.keys()) if 'E' in x]:\n        line = [title]\n        for metric_tup in stats[title]:\n            try:\n                len(metric_tup)\n                line.append('[%0.2f, %0.2f]' % (metric_tup[0], metric_tup[1]))\n            except:\n                line.append('%0.12f' % metric_tup)\n        statswriter.writerow(line)", "response": "writes contents of stats to outname_diff_stats. csv\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_summary(stats, options, fw_type = None):\n\n    # set output file name\n    out_name = '%s_stats.csv' % options.outname\n    filename = os.path.join(os.getcwd(), out_name)\n\n    # open file & create csv writer object\n    f = open(filename, 'w')\n    stats_writer = csv.writer(f)\n\n    # sort the stats keys using the \"decorate, sort, un decorate method\"\n    decorated = [(x, int(re.search(r'_([0-9]|[0-9][0-9]|[0-9][0-9][0-9])_queries.csv$', x, re.M).group().split('_')[1]))\n                 for x in stats.keys() if '_queries.csv' in x]\n    decorated.sort(key=lambda element: element[1])\n    sorted_stats_keys = [x[0] for x in decorated]\n\n    for leftovers in [x for x in stats.keys() if '_queries.csv' not in x]:\n        sorted_stats_keys.append(leftovers)\n\n    for ensemble in sorted_stats_keys:\n        # write header & first line\n        if f.tell() == 0:\n            header = ['Ensemble name', 'AUC', '95% CI']\n            line = ['%s' % ensemble]\n            for metric_tup in stats[ensemble]:\n                if len(metric_tup) == 3:\n                    line.append('%0.4f' % metric_tup[0])\n                    line.append('[%0.2f, %0.2f]' % (metric_tup[1], metric_tup[2]))\n                if len(metric_tup) == 4:\n                    header.append('E%s' % metric_tup[0])\n                    header.append('95% CI')\n                    line.append('%0.2f' % metric_tup[1])\n                    line.append('[%0.2f, %0.2f]' % (metric_tup[2], metric_tup[3]))\n            stats_writer.writerow(header)\n            stats_writer.writerow(line)\n        # write remaining lines\n        else:\n            line = ['%s' % ensemble]\n            for metric_tup in stats[ensemble]:\n                if len(metric_tup) == 3:\n                    line.append('%0.4f' % metric_tup[0])\n                    line.append('[%0.2f, %0.2f]' % (metric_tup[1], metric_tup[2]))\n                if len(metric_tup) == 4:\n                    line.append('%0.4f' % metric_tup[1])\n                    line.append('[%0.2f, %0.2f]' % (metric_tup[2], metric_tup[3]))\n            stats_writer.writerow(line)\n\n    # write maximum values\n    line = ['max values:']\n    for metric_tup in stats[list(stats.keys())[0]]:\n        if len(metric_tup) == 3:\n            line.append('1.00') # auc\n            line.append(' ') # CI space\n        if len(metric_tup) == 4:\n            line.append('%0.2f' % (1 / metric_tup[0])) # max ef\n            line.append(' ') # CI space\n    stats_writer.writerow(line)\n\n    # close file\n    f.close()", "response": "Writes the stats to outname_stats. csv"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites the ensemble composition to a CSV file", "response": "def write_ensemble(ensemble, options):\n    \"\"\"\n\tPrints out the ensemble composition at each size\n\t\"\"\"\n\n    # set output file name\n    size = len(ensemble)\n    filename = '%s_%s_queries.csv' % (options.outname, size)\n    file = os.path.join(os.getcwd(), filename)\n\n    f = open(file, 'w')\n\n    out = ', '.join(ensemble)\n\n    f.write(out)\n\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef node_indent(elt_name, node_id, fact_term, attribute, highlight_node=None):\n    # Some colors to chose from:\n    color_dict = {0: {0: '#004C80', # blueish\n                      1: '#005C99',\n                      2: '#006BB2',\n                      3: '#007ACC',\n                      4: '#008AE6',\n                      5: '#0099FF',\n                      6: '#19A3FF',\n                      7: '#33ADFF',\n                      8: '#4DB8FF',\n                      9: '#66C2FF',\n                      10: '#80CCFF',\n                      11: '#99D6FF',\n                      12: '#B2E0FF',\n                      13: '#CCEBFF',\n                      14: '#E6F5FF'},\n                  2: {0: '#008000', # greenish\n                      1: '#009900',\n                      2: '#00B200',\n                      3: '#00CC00',\n                      4: '#00E600',\n                      5: '#00FF00',\n                      6: '#19FF19',\n                      7: '#33FF33',\n                      8: '#4DFF4D',\n                      9: '#66FF66',\n                      10: '#80FF80',\n                      11: '#99FF99',\n                      12: '#B2FFB2',\n                      13: '#CCFFCC',\n                      14: '#E6FFE6'},\n                  3: {0: '#804C80', # pinkish\n                      1: '#995C99',\n                      2: '#B26BB2',\n                      3: '#CC7ACC',\n                      4: '#E68AE6',\n                      5: '#FF99FF',\n                      6: '#FFA3FF',\n                      7: '#FFADFF',\n                      8: '#FFB8FF',\n                      9: '#FFC2FF',\n                      10: '#FFCCFF',\n                      11: '#FFD6FF',\n                      12: '#FFE0FF',\n                      13: '#FFEBFF',\n                      14: '#FFF5FF', },\n                  1: {0: \"#5C3D99\", # violetish\n                      1: \"#6B47B2\",\n                      2: \"#7A52CC\",\n                      3: \"#8A5CE6\",\n                      4: \"#9966FF\",\n                      5: \"#A375FF\",\n                      6: \"#AD85FF\",\n                      7: \"#B894FF\",\n                      8: \"#C2A3FF\",\n                      9: \"#CCB2FF\",\n                      10: \"#D6C2FF\",\n                      11: \"#E0D1FF\",\n                      12: \"#EBE0FF\",\n                      13: \"#F5F0FF\",\n                      14: \"#FFFFFF\"}\n\n    }\n\n    indents = 100\n    node_ids = node_id.split(':')\n    fact_components = fact_term.split('/')\n\n    if len(fact_components) == 1 and fact_components[0] == '':\n        fact_components = []\n    if attribute:\n        fact_components.append(\"@%s\" % attribute)\n\n    fact_components = dict([(x, fact_components[x]) for x in range(0, len(fact_components))])\n\n\n    #node_ids.reverse()\n\n    result = []\n    counter = 0\n    for node in node_ids:\n        is_attr = False\n        if len(node) >= 1:\n            if node[0] == 'A':\n                is_attr = True\n\n            node = node[1:]\n\n        if len(node) > 0:\n            node_nr = int(node)\n        else:\n            node_nr = 0\n        if is_attr:\n            node_mod = 2\n        else:\n            node_mod = node_nr % 2\n        if is_attr:\n            result.append(\"<%(elt_name)s style='background: %(color)s'>%(fact_term_component)s</%(elt_name)s>\" % {\n                'elt_name': elt_name,\n                'fact_term_component': fact_components.get(counter, ''),\n                'color': color_dict[2][max(14 - counter,4)]})\n        else:\n            result.append(\n                \"<%(elt_name)s style='width:1px; margin: 0px ; background : %(color)s'>%(fact_term_component)s</%(elt_name)s>\" % {\n                    'elt_name': elt_name,\n                    'color': color_dict[node_mod][max(14 - counter,4)],\n                    'fact_term_component': fact_components.get(counter, '')})\n\n        counter += 1\n\n    highlight = \"style='background: #FF0000;'\" if highlight_node == node_id else None\n\n    result.append(\"<%(elt_name)s colspan='%(colspan)s' %(highlight)s>\" % {'elt_name': elt_name, 'colspan': (indents - counter), 'highlight' : highlight})\n\n    return \"\".join(result)", "response": "This function is used to display indentation of a node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_table_ordering(context, index, title):\n\n    # title + plain url (=without o paramater)\n    new_context = { 'title' : title, 'plain_url' : context['view'].get_query_string(remove=['o']) }\n\n    # ordered url\n    new_context['ordered_url'] = new_context['plain_url'] + '&o=' + index\n\n    # toggled ordering url (only if needed)\n    if 'o' in context['request'].GET and ( context['request'].GET['o'] == index or context['request'].GET['o'] == '-%s' % index):\n        new_context['toggled_url'] = new_context['plain_url'] + '&o=' + (index if context['request'].GET['o'].startswith('-') else '-' + index) \n        new_context['order_direction'] = 'ascending' if context['request'].GET['o'].startswith('-') else 'descending'\n\n    return new_context", "response": "Renders a TABLE LAYOUT ordering using given index and a human - readable title for it."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a sha256 hash value returns the content of the blob.", "response": "def lookup_blob(hash_value):\n    \"\"\"\n    Combines all given arguments to create clean title-tags values.\n    All arguments are divided by a \" \" seperator and HTML tags\n    are to be removed.\n    \"\"\"\n    try:\n        blob = BlobStorage.objects.get(sha256=hash_value)\n    except:\n        return \"Blob not found\"\n    return blob.content"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sshagent_run(cmd):\n    # Handle context manager modifications\n    wrapped_cmd = _prefix_commands(_prefix_env_vars(cmd), 'remote')\n    try:\n        host, port = env.host_string.split(':')\n        return local(\n            u\"ssh -p %s -A -o StrictHostKeyChecking=no %s@%s '%s'\" % (\n                port, env.user, host, wrapped_cmd\n            )\n        )\n    except ValueError:\n        return local(\n            u\"ssh -A -o StrictHostKeyChecking=no %s@%s '%s'\" % (\n                env.user, env.host_string, wrapped_cmd\n            )\n        )", "response": "Runs a command with SSH agent forwarding enabled."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_object(obj):\n    LOGGER.debug('as_object(%s)', obj)\n\n    if isinstance(obj, datetime.date):\n        return as_date(obj)\n\n    elif hasattr(obj, '__dict__'):\n\n        # populate dict with visible attributes\n        out = {k: obj.__dict__[k] for k in obj.__dict__ if not k.startswith('_')}\n\n        # populate dict with property names and values\n        for k, v in (\n                (p, getattr(obj, p))\n                for p, _ in inspect.getmembers(\n                    obj.__class__,\n                    lambda x: isinstance(x, property))\n        ):\n            out[k] = v\n\n        return out", "response": "Return a JSON serializable type for the given object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_date(dat):\n    LOGGER.debug('as_date(%s)', dat)\n\n    return strict_rfc3339.timestamp_to_rfc3339_utcoffset(\n        calendar.timegm(dat.timetuple()))", "response": "Return the RFC3339 UTC string representation of the given date and time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nyield successive n - sized chunks from an iterable.", "response": "def chunks(iterable, chunk):\n    \"\"\"Yield successive n-sized chunks from an iterable.\"\"\"\n    for i in range(0, len(iterable), chunk):\n        yield iterable[i:i + chunk]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of dictionary with n - keys ( chunk per list.", "response": "def dict_chunks(dictionary, chunk):\n    \"\"\"Return a list of dictionary with n-keys (chunk) per list.\"\"\"\n    return [{k: v for k, v in dictionary.items() if k in i} for i in chunks(list(dictionary.keys()), chunk)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef integrate(self, function, lower_bound, upper_bound):\n        ret = 0.0\n        n = self.nsteps\n        xStep = (float(upper_bound) - float(lower_bound)) / float(n)\n        self.log_info(\"xStep\" + str(xStep))\n        x = lower_bound\n        val1 = function(x)\n        self.log_info(\"val1: \" + str(val1))\n        for i in range(n):\n            x = (i + 1) * xStep + lower_bound\n            self.log_info(\"x: \" + str(x))\n            val2 = function(x)\n            self.log_info(\"val2: \" + str(val2))\n            ret += 0.5 * xStep * (val1 + val2)\n            val1 = val2\n        return ret", "response": "Integrates the given one dimensional function with the simplex integration method."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(itf):\n\n    if not itf:\n        return 1\n\n    # access user input\n    options = SplitInput(itf)\n\n    # read input\n    print(\" Reading input file ...\")\n    molecules = csv_interface.read_csv(os.path.abspath(options.inputpath), options)\n    if not molecules:\n        print(\"\\n '{f} was unable to be parsed\\n\".format(f=os.path.basename(options.inputpath)))\n        sys.exit(1)\n    approximator(molecules, options)", "response": "run approximate functions\n    :param itf:\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cdf_abramowitz_stegun(x):\n    if x >= 0:\n        # if x > 7.0:\n        #    return 1 - ONE_OVER_SQRT_OF_TWO_PI * exp(-0.5*x*x)/sqrt(1.0+x*x)\n        result = 1.0 / (1.0 + 0.2316419 * x)\n        ret = 1.0 - ONE_OVER_SQRT_OF_TWO_PI * exp(-0.5 * x * x) * (\n            result * (0.31938153 +\n                      result * (-0.356563782 +\n                                result * (1.781477937 +\n                                          result * (-1.821255978 +\n                                                    result * 1.330274429)))))\n        return ret\n\n    if x <= 0:\n        # if x < -7.0:\n        #    return 1 - one_over_sqrt_of_two_pi() * exp(-0.5*x*x)/sqrt(1.0+x*x)\n        result = 1.0 / (1.0 - 0.2316419 * x)\n        ret = ONE_OVER_SQRT_OF_TWO_PI * exp(-0.5 * x * x) * (\n            result * (0.31938153 +\n                      result * (-0.356563782 +\n                                result * (1.781477937 +\n                                          result * (-1.821255978 +\n                                                    result * 1.330274429)))))\n\n        return ret", "response": "Cumulative distribution function of the standard normal distribution."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates over a SAM file and return a list of GamEntry objects.", "response": "def sam_iter(handle, start_line=None, headers=False):\n    \"\"\"Iterate over SAM file and return SAM entries\n\n    Args:\n        handle (file): SAM file handle, can be any iterator so long as it\n            it returns subsequent \"lines\" of a SAM entry\n\n        start_line (str): Next SAM entry, if 'handle' has been partially read\n            and you want to start iterating at the next entry, read the next\n            SAM entry and pass it to this variable when calling sam_iter.\n            See 'Examples.'\n\n        headers (bool): Yields headers if True, else skips lines starting with\n            \"@\"\n\n    Yields:\n        SamEntry: class containing all SAM data, yields str for headers if\n            headers options is True then yields GamEntry for entries\n\n    Examples:\n        The following two examples demonstrate how to use sam_iter.\n        Note: These doctests will not pass, examples are only in doctest\n        format as per convention. bio_utils uses pytests for testing.\n\n        >>> for entry in sam_iter(open('test.sam')):\n        ...     print(entry.qname)  # Print query sequence name\n        ...     print(entry.flag)  # Print flag number of alignment\n        ...     print(entry.rname)  # Print reference sequence name\n        ...     print(entry.pos)  # Print starting position of alignment\n        ...     print(entry.mapq)  # Print mapping confidence of alignment\n        ...     print(entry.cigar)  # Print CIGAR string of alignment\n        ...     print(entry.rnext)  # Print paired read name\n        ...     print(entry.pnext)  # Print position of paired read\n        ...     print(entry.tlen)  # Print alignment length of all paired reads\n        ...     print(entry.seq)  # Print query sequence\n        ...     print(entry.qual)  # Print query quality scores\n        ...     print(entry.write())  # Print whole SAM entry\n\n        >>> sam_handle = open('test.gff3')\n        >>> next(sam_handle)  # Skip first line/entry\n        >>> next_line = next(sam_handle)  # Store next entry\n        >>> for entry in sam_iter(open('test.sam')):\n        ...     print(entry.qname)  # Print query sequence name\n        ...     print(entry.flag)  # Print flag number of alignment\n        ...     print(entry.rname)  # Print reference sequence name\n        ...     print(entry.pos)  # Print starting position of alignment\n        ...     print(entry.mapq)  # Print mapping confidence of alignment\n        ...     print(entry.cigar)  # Print CIGAR string of alignment\n        ...     print(entry.rnext)  # Print paired read name\n        ...     print(entry.pnext)  # Print position of paired read\n        ...     print(entry.tlen)  # Print alignment length of all paired reads\n        ...     print(entry.seq)  # Print query sequence\n        ...     print(entry.qual)  # Print query quality scores\n        ...     print(entry.write())  # Print whole SAM entry\n    \"\"\"\n\n    # Speed tricks: reduces function calls\n    split = str.split\n    strip = str.strip\n\n    next_line = next\n\n    if start_line is None:\n        line = next_line(handle)  # Read first B6/M8 entry\n    else:\n        line = start_line  # Set header to given header\n\n    # Check if input is text or bytestream\n    if (isinstance(line, bytes)):\n        def next_line(i):\n            return next(i).decode('utf-8')\n\n        line = strip(line.decode('utf-8'))\n    else:\n        line = strip(line)\n\n\n    # A manual 'for' loop isn't needed to read the file properly and quickly,\n    # unlike fasta_iter and fastq_iter, but it is necessary begin iterating\n    # partway through a file when the user gives a starting line.\n    try:  # Manually construct a for loop to improve speed by using 'next'\n\n        while True:  # Loop until StopIteration Exception raised\n\n            split_line = split(line, '\\t')\n\n            if line.startswith('@') and not headers:\n                line = strip(next_line(handle))\n                continue\n            elif line.startswith('@') and headers:\n                yield line\n                line = strip(next_line(handle))\n                continue\n\n            data = SamEntry()\n            data.qname = split_line[0]\n            try:  # Differentiate between int and hex bit flags\n                data.flag = int(split_line[1])\n            except ValueError:\n                data.flag = split_line[1]\n            data.rname = split_line[2]\n            data.pos = int(split_line[3])\n            data.mapq = int(split_line[4])\n            data.cigar = split_line[5]\n            data.rnext = split_line[6]\n            data.pnext = int(split_line[7])\n            data.tlen = int(split_line[8])\n            data.seq = split_line[9]\n            data.qual = split_line[10]\n\n            line = strip(next_line(handle))  # Raises StopIteration at EOF\n\n            yield data\n\n    except StopIteration:  # Yield last SAM entry\n        yield data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning SAM formatted string containing entire SAM entry", "response": "def write(self):\n        \"\"\"Return SAM formatted string\n\n        Returns:\n            str: SAM formatted string containing entire SAM entry\n        \"\"\"\n\n        return '{0}\\t{1}\\t{2}\\t{3}\\t{4}\\t' \\\n               '{5}\\t{6}\\t{7}\\t{8}\\t{9}\\t' \\\n               '{10}{11}'.format(self.qname,\n                                 str(self.flag),\n                                 self.rname,\n                                 str(self.pos),\n                                 str(self.mapq),\n                                 self.cigar,\n                                 self.rnext,\n                                 str(self.pnext),\n                                 str(self.tlen),\n                                 self.seq,\n                                 self.qual,\n                                 os.linesep)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a request to the Core API and return the response.", "response": "def request(self, request_path, data=None, do_authentication=True, is_json=True):\n        \"\"\"\n        Core \"worker\" for making requests and parsing JSON responses.\n\n        If `is_json` is ``True``, `data` should be a dictionary which\n        will be JSON-encoded.\n        \"\"\"\n        uri = self.api_uri % request_path\n        request = urllib2.Request(uri)\n\n        # Build up the request\n        if is_json:\n            request.add_header(\"Content-Type\", \"application/json\")\n            if data is not None:\n                request.add_data(json.dumps(data))\n        elif data is not None:\n            request.add_data(data)\n\n        if do_authentication:\n            if self.client_id is None or self.client_secret is None:\n                raise Exception(u\"You need to supply a client_id and client_secret to perform an authenticated request\")\n            basic_auth = base64.b64encode(\"%s:%s\" % (self.client_id, self.client_secret))\n            request.add_header(\"Authorization\", \"Basic %s\" % basic_auth)\n\n        try:\n            response = self._make_request(request)\n        except Exception as inst:\n            raise # automatically re-raises the exception\n\n        if 'status' in response:\n            # Grab the status info if it exists\n            self._last_status_code = response['status']['code']\n            if 'message' in response['status']:\n                self._last_status_message = response['status']['message']\n\n            if 'data' in response:\n                return response['data']\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _make_request(self, request):\n        # TODO: I'm sure all kinds of error checking needs to go here\n        try:\n            response_raw = urllib2.urlopen(request)\n        except urllib2.HTTPError, e:\n            print e.read()\n            raise\n\n        response_str = response_raw.read()\n        response = json.loads(response_str)\n\n        self._last_request = request\n        self._last_response = response_raw\n        self._last_response_str = response_str\n        return response", "response": "Makes a request and parses the response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting hello message from Fisca", "response": "def hello(self):\n        \"\"\"http://docs.fiesta.cc/index.html#getting-started\"\"\"\n        path = 'hello'\n        response = self.request(path, do_authentication=False)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(cls, api, default_name=None, description=None):\n        path = 'group'\n\n        data = {}\n        if default_name:\n            data['default_group_name'] = default_name\n        if description:\n            data['description'] = description\n        if api.domain:\n            data['domain'] = api.domain\n\n        response_data = api.request(path, data=data)\n\n        id = response_data['group_id']\n        group = cls(api, id)\n        group.default_name = response_data['default_group_name']\n\n        return group", "response": "Create a new group object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_member(self, address, **kwargs):\n        path = 'membership/%s' % self.id\n        kwargs[\"address\"] = address\n\n        if \"group_name\" not in kwargs and self.default_name:\n            kwargs[\"group_name\"] = self.default_name\n\n        response_data = self.api.request(path, kwargs)\n        if 'user_id' in response_data:\n            user_id = response_data['user_id']\n            return FiestaUser(user_id, address=address, groups=[self])\n        return None", "response": "Add a member to a group."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_message(self, subject=None, text=None, markdown=None, message_dict=None):\n        message = FiestaMessage(self.api, self, subject, text, markdown, message_dict)\n        return message.send()", "response": "Send a message to a group"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_application(self, application_id, **kwargs):\n        path = 'group/%s/application' % self.id\n\n        data = {'application_id': application_id}\n        if kwargs:\n            data[\"options\"] = kwargs\n\n        self.api.request(path, data)", "response": "Add an application to a group."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends this current message to a group.", "response": "def send(self, group_id=None, message_dict=None):\n        \"\"\"\n        Send this current message to a group.\n\n        `message_dict` can be a dictionary formatted according to http://docs.fiesta.cc/list-management-api.html#messages\n        If message is provided, this method will ignore object-level variables.\n        \"\"\"\n        if self.group is not None and self.group.id is not None:\n            group_id = self.group.id\n\n        path = 'message/%s' % group_id\n\n        if message_dict is not None:\n            request_data = {\n                'message': message_dict,\n            }\n        else:\n            subject = self.subject\n            text = self.text\n            markdown = self.markdown\n\n            request_data = {\n                'message': {},\n            }\n            if subject:\n                request_data['message']['subject'] = subject\n            if text:\n                request_data['message']['text'] = text\n            if markdown:\n                request_data['message']['markdown'] = markdown\n\n        response_data = self.api.request(path, request_data)\n\n        self.id = response_data['message_id']\n        self.thread_id = response_data['thread_id']\n        self.sent_message = FiestaMessage(self.api, response_data['message'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reset(self):\n        path = 'reset'\n        request_data = {}   # Need to put data into the request to force urllib2 to make it a POST request\n        response_data = self.request(path, request_data)\n        success = response_data['reset']   # True of False\n        return success", "response": "Reset the state of the sandbox."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstore the selected taskfileinfo self. selected and accept the dialog", "response": "def select(self, ):\n        \"\"\"Store the selected taskfileinfo self.selected and accept the dialog\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        s = self.browser.selected_indexes(self.browser.get_depth()-1)\n        if not s:\n            return\n        i = s[0].internalPointer()\n        if i:\n            tfi = i.internal_data()\n            self.selected = tfi\n            self.accept()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_icons(self, ):\n        iconbtns = [(\"menu_border_24x24.png\", self.menu_tb),\n                    (\"duplicate_border_24x24.png\", self.duplicate_tb),\n                    (\"delete_border_24x24.png\", self.delete_tb),\n                    (\"reference_border_24x24.png\", self.reference_tb),\n                    (\"load_border_24x24.png\", self.load_tb),\n                    (\"unload_border_24x24.png\", self.unload_tb),\n                    (\"replace_border_24x24.png\", self.replace_tb),\n                    (\"import_border_24x24.png\", self.importref_tb),\n                    (\"import_border_24x24.png\", self.importtf_tb),\n                    (\"alien.png\", self.alien_tb),\n                    (\"imported.png\", self.imported_tb)]\n        for iconname, btn in iconbtns:\n            i = get_icon(iconname, asicon=True)\n            btn.setIcon(i)", "response": "Setup the icons of the ui\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setup_signals(self, ):\n        self.duplicate_tb.clicked.connect(self.duplicate)\n        self.delete_tb.clicked.connect(self.delete)\n        self.load_tb.clicked.connect(self.load)\n        self.unload_tb.clicked.connect(self.unload)\n        self.reference_tb.clicked.connect(self.reference)\n        self.importtf_tb.clicked.connect(self.import_file)\n        self.importref_tb.clicked.connect(self.import_reference)\n        self.replace_tb.clicked.connect(self.replace)\n        self.imported_tb.clicked.connect(partial(self.toggle_tbstyle, button=self.imported_tb))\n        self.alien_tb.clicked.connect(partial(self.toggle_tbstyle, button=self.alien_tb))", "response": "Connect the signals with the slots to make the ui functional\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisplay the data of the given index", "response": "def set_index(self, index):\n        \"\"\"Display the data of the given index\n\n        :param index: the index to paint\n        :type index: QtCore.QModelIndex\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.index = index\n        self.reftrack = index.model().index(index.row(), 18, index.parent()).data(REFTRACK_OBJECT_ROLE)\n        self.set_maintext(self.index)\n        self.set_identifiertext(self.index)\n        self.set_type_icon(self.index)\n        self.disable_restricted()\n        self.hide_restricted()\n        self.set_top_bar_color(self.index)\n        self.set_status_buttons()\n        self.set_menu()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_maintext(self, index):\n        dr = QtCore.Qt.DisplayRole\n        text = \"\"\n        model = index.model()\n        for i in (1, 2, 3, 5, 6):\n            new = model.index(index.row(), i, index.parent()).data(dr)\n            if new is not None:\n                text = \" | \".join((text, new)) if text else new\n\n        self.maintext_lb.setText(text)", "response": "Set the maintext_lb to display text information about the given reftrack\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the identifier text on the identifier_lb", "response": "def set_identifiertext(self, index):\n        \"\"\"Set the identifier text on the identifier_lb\n\n        :param index: the index\n        :type index: :class:`QtGui.QModelIndex`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        dr = QtCore.Qt.DisplayRole\n        t = index.model().index(index.row(), 17, index.parent()).data(dr)\n        if t is None:\n            t = -1\n        else:\n            t = t+1\n        self.identifier_lb.setText(\"#%s\" % t)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_type_icon(self, index):\n        icon = index.model().index(index.row(), 0, index.parent()).data(QtCore.Qt.DecorationRole)\n        if icon:\n            pix = icon.pixmap(self.type_icon_lb.size())\n            self.type_icon_lb.setPixmap(pix)\n        else:\n            self.type_icon_lb.setPixmap(None)", "response": "Sets the type icon on type_icon_lb"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef disable_restricted(self, ):\n        todisable = [(self.reftrack.duplicate, self.duplicate_tb),\n                     (self.reftrack.delete, self.delete_tb),\n                     (self.reftrack.reference, self.reference_tb),\n                     (self.reftrack.replace, self.replace_tb),]\n        for action, btn in todisable:\n            res = self.reftrack.is_restricted(action)\n            btn.setDisabled(res)", "response": "Disable the restricted buttons in the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhides the restricted buttons", "response": "def hide_restricted(self, ):\n        \"\"\"Hide the restricted buttons\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        tohide = [((self.reftrack.unload, self.unload_tb),\n                   (self.reftrack.load, self.load_tb)),\n                  ((self.reftrack.import_file, self.importtf_tb),\n                   (self.reftrack.import_reference, self.importref_tb))]\n        for (action1, btn1), (action2, btn2) in tohide:\n            res1 = self.reftrack.is_restricted(action1)\n            res2 = self.reftrack.is_restricted(action2)\n            if res1 != res2:\n                btn1.setEnabled(True)\n                btn1.setHidden(res1)\n                btn2.setHidden(res2)\n            else:  # both are restricted, then show one but disable it\n                btn1.setDisabled(True)\n                btn1.setVisible(True)\n                btn2.setVisible(False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the color of the upper frame to the background color of the reftrack status", "response": "def set_top_bar_color(self, index):\n        \"\"\"Set the color of the upper frame to the background color of the reftrack status\n\n        :param index: the index\n        :type index: :class:`QtGui.QModelIndex`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        dr = QtCore.Qt.ForegroundRole\n        c = index.model().index(index.row(), 8, index.parent()).data(dr)\n        if not c:\n            c = self.upper_fr_default_bg_color\n        self.upper_fr.setStyleSheet('background-color: rgb(%s, %s, %s)' % (c.red(), c.green(), c.blue()))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the status buttons for the reftrack", "response": "def set_status_buttons(self, ):\n        \"\"\"Depending on the status of the reftrack, enable or disable\n        the status buttons, for imported/alien status buttons\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        imported = self.reftrack.status() == self.reftrack.IMPORTED\n        alien = self.reftrack.alien()\n\n        for btn, enable in [(self.imported_tb, imported),\n                            (self.alien_tb, alien)]:\n            btn.setEnabled(enable)\n            btn.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef toggle_tbstyle(self, button):\n        old = button.toolButtonStyle()\n        if old == QtCore.Qt.ToolButtonIconOnly:\n            new = QtCore.Qt.ToolButtonTextBesideIcon\n        else:\n            new = QtCore.Qt.ToolButtonIconOnly\n        button.setToolButtonStyle(new)", "response": "Toogle the ToolButtonStyle of the given button between ToolButtonIconOnly and ToolButtonTextBesideIcon."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_menu(self, ):\n        self.menu = QtGui.QMenu(self)\n        actions = self.reftrack.get_additional_actions()\n        self.actions = []\n        for a in actions:\n            if a.icon:\n                qaction = QtGui.QAction(a.icon, a.name, self)\n            else:\n                qaction = QtGui.QAction(a.name, self)\n            qaction.setCheckable(a.checkable)\n            qaction.setChecked(a.checked)\n            qaction.setEnabled(a.enabled)\n            qaction.triggered.connect(a.action)\n            self.actions.append(qaction)\n            self.menu.addAction(qaction)\n        self.menu_tb.setMenu(self.menu)", "response": "Setup the menu that the menu_tb button uses."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a taskfileinfo that the user chose from the available options", "response": "def get_taskfileinfo_selection(self, ):\n        \"\"\"Return a taskfileinfo that the user chose from the available options\n\n        :returns: the chosen taskfileinfo\n        :rtype: :class:`jukeboxcore.filesys.TaskFileInfo`\n        :raises: None\n        \"\"\"\n        sel = OptionSelector(self.reftrack)\n        sel.exec_()\n        return sel.selected"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reference(self, ):\n        tfi = self.get_taskfileinfo_selection()\n        if tfi:\n            self.reftrack.reference(tfi)", "response": "Reference a file containing a taskfileinfo"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_file(self, ):\n        tfi = self.get_taskfileinfo_selection()\n        if tfi:\n            self.reftrack.import_file(tfi)", "response": "Imports a file from the reftrack"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreplace the current reftrack with the current reftrack.", "response": "def replace(self, ):\n        \"\"\"Replace the current reftrack\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        tfi = self.get_taskfileinfo_selection()\n        if tfi:\n            self.reftrack.replace(tfi)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes all renditions if master file as changed.", "response": "def delete_renditions_if_master_has_changed(sender, instance, **kwargs):\n    '''if master file as changed delete all renditions'''\n    try:\n        obj = sender.objects.get(pk=instance.pk)\n    except sender.DoesNotExist:\n        pass  # Object is new, so field hasn't technically changed.\n    else:\n        if not obj.master == instance.master:  # Field has changed\n            obj.master.delete(save=False)\n            instance.delete_all_renditions()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef photo_post_delete_handler(sender, **kwargs):\n    '''delete image when rows is gone from database'''\n    instance = kwargs.get('instance')\n    instance.master.delete(save=False)\n    instance.delete_all_renditions()", "response": "delete image when rows is gone from database"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns real rendition URL", "response": "def get_rendition_size(self, width=0, height=0):\n        '''returns real rendition URL'''\n        if width == 0 and height == 0:\n            return (self.master_width, self.master_height)\n\n        target_width = int(width)\n        target_height = int(height)\n\n        ratio = self.master_width / float(self.master_height)\n        if target_height == 0 and target_width != 0:\n            target_height = int(target_width / ratio)\n\n        if target_height != 0 and target_width == 0:\n            target_width = int(target_height * ratio)\n\n        return target_width, target_height"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the rendition URL for a specified size", "response": "def get_rendition_url(self, width=0, height=0):\n        '''get the rendition URL for a specified size\n\n        if the renditions does not exists it will be created\n        '''\n        if width == 0 and height == 0:\n            return self.get_master_url()\n\n        target_width, target_height = self.get_rendition_size(width, height)\n\n        key = '%sx%s' % (target_width, target_height)\n        if not self.renditions:\n            self.renditions = {}\n        rendition_name = self.renditions.get(key, False)\n        if not rendition_name:\n            rendition_name = self.make_rendition(target_width, target_height)\n        return default_storage.url(rendition_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete all renditions and rendition dict", "response": "def delete_all_renditions(self):\n        '''delete all renditions and rendition dict'''\n        if self.renditions:\n            for r in self.renditions.values():\n                default_storage.delete(r)\n            self.renditions = {}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_rendition(self, width, height):\n        '''build a rendition\n\n        0 x 0 -> will give master URL\n        only width -> will make a renditions with master's aspect ratio\n        width x height -> will make an image potentialy cropped\n        '''\n        image = Image.open(self.master)\n        format = image.format\n\n        target_w = float(width)\n        target_h = float(height)\n\n        if (target_w == 0):\n            target_w = self.master_width\n\n        if (target_h == 0):\n            target_h = self.master_height\n\n        rendition_key = '%dx%d' % (target_w, target_h)\n\n        if rendition_key in self.renditions:\n            return self.renditions[rendition_key]\n\n        if (target_w != self.master_width or target_h != self.master_height):\n            r = target_w / target_h\n            R = float(self.master_width) / self.master_height\n            if r != R:\n                if r > R:\n                    crop_w = self.master_width\n                    crop_h = crop_w / r\n                    x = 0\n                    y = int(self.master_height - crop_h) >> 1\n                else:\n                    crop_h = self.master_height\n                    crop_w = crop_h * r\n                    x = int(self.master_width - crop_w) >> 1\n                    y = 0\n                image = image.crop((x, y, int(crop_w + x), int(crop_h + y)))\n\n            image.thumbnail((int(target_w), int(target_h)), Image.ANTIALIAS)\n\n            filename, ext = os.path.splitext(self.get_master_filename())\n            rendition_name = '%s/%s_%s%s' % (\n                IMAGE_DIRECTORY,\n                filename,\n                rendition_key,\n                ext\n            )\n            fd = BytesIO()\n            image.save(fd, format)\n            default_storage.save(rendition_name, fd)\n\n            self.renditions[rendition_key] = rendition_name\n            self.save()\n\n            return rendition_name\n\n        return self.master.name", "response": "build a rendition with master s aspect ratio width and height"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute_actioncollection(obj, actioncollection, confirm=True):\n    actioncollection.execute(obj)\n    status = actioncollection.status()\n    if status.value == ActionStatus.SUCCESS or not confirm:\n        return status\n    ard = ActionReportDialog(actioncollection)\n    confirmed = ard.exec_()\n    if confirmed:\n        msg = \"User confirmed to continue although the status was: %s\" % status.message,\n        s = ActionStatus.SUCCESS\n        tb = status.traceback\n    else:\n        s = status.value\n        msg = \"User aborted the actions because the status was: %s\" % status.message,\n        tb = status.traceback\n    return ActionStatus(s, msg, tb)", "response": "Execute the given actioncollection with the given object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef release(self):\n        log.info(\"Releasing: %s\", self._workfile.get_fullpath())\n        ac = self.build_actions()\n        ac.execute(self)\n        s = ac.status().value\n        if not s == ActionStatus.SUCCESS:\n            ard = ActionReportDialog(ac)\n            ard.exec_()\n            pass\n        return s == ActionStatus.SUCCESS", "response": "Release the current work file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_actions(self):\n        checkau = ActionUnit(\"Sanity Checks\",\n                             \"Check the workfile. If the file is not conform, ask the user to continue.\",\n                             self.sanity_check)\n        copyau = ActionUnit(\"Copy File\",\n                            \"Copy the workfile to the releasefile location.\",\n                            self.copy,\n                            depsuccess=[checkau])\n        dbau = ActionUnit(\"Create DB entry\",\n                          \"Create an entry in the database for the releasefile\",\n                          self.create_db_entry,\n                          depsuccess=[copyau])\n        cleanau = ActionUnit(\"Cleanup\",\n                             \"Cleanup the releasefile. If something fails, ask the user to continue.\",\n                             self.cleanup,\n                             depsuccess=[dbau])\n        deletefau1 = ActionUnit(\"Delete the releasefile.\",\n                                \"In case the db entry creation fails, delete the releasefile.\",\n                                self.delete_releasefile,\n                                depfail=[dbau])\n        deletefau2 = ActionUnit(\"Delete the releasefile.\",\n                                \"In case the cleanup fails, delete the releasefile.\",\n                                self.delete_releasefile,\n                                depsuccess=[copyau],\n                                depfail=[cleanau])\n        deletedbau = ActionUnit(\"Delete the database entry.\",\n                                \"In case the cleanup fails, delete the database entry\",\n                                self.delete_db_entry,\n                                depsuccess=[dbau],\n                                depfail=[cleanau])\n        return ActionCollection([checkau, copyau, dbau, cleanau, deletefau1, deletefau2, deletedbau])", "response": "Build the list of actions that will be executed for the given file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sanity_check(self, release):\n        log.info(\"Performing sanity checks.\")\n        return execute_actioncollection(release._workfile, actioncollection=release._checks, confirm=True)", "response": "Perform sanity checks on the workfile of the given release."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy(self, release):\n        workfp = release._workfile.get_fullpath()\n        releasefp = release._releasefile.get_fullpath()\n        copy_file(release._workfile, release._releasefile)\n        return ActionStatus(ActionStatus.SUCCESS,\n                            msg=\"Copied %s to %s location.\" % (workfp,\n                                                               releasefp))", "response": "Copies the workfile of the given release to the releasefile location"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_db_entry(self, release):\n        log.info(\"Create database entry with comment: %s\", release.comment)\n        tfi = release._releasefile.get_obj()\n        tf, note = tfi.create_db_entry(release.comment)\n        release._releasedbentry = tf\n        release._commentdbentry = note\n        return ActionStatus(ActionStatus.SUCCESS,\n                            msg=\"Created database entry for the release filw with comment: %s\" % release.comment)", "response": "Create a db entry for the given release"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cleanup(self, release):\n        log.info(\"Performing cleanup.\")\n        return execute_actioncollection(release._releasefile, actioncollection=release._cleanup, confirm=True)", "response": "Perform cleanup actions on the releasefile of the given release"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete the releasefile of the given release", "response": "def delete_releasefile(self, release):\n        \"\"\"Delete the releasefile of the given release\n\n        This is inteded to be used in a action unit.\n\n        :param release: the release with the releasefile\n        :type release: :class:`Release`\n        :returns: an action status\n        :rtype: :class:`ActionStatus`\n        :raises: None\n        \"\"\"\n        fp = release._releasefile.get_fullpath()\n        log.info(\"Deleting release file %s\", fp)\n        delete_file(release._releasefile)\n        return ActionStatus(ActionStatus.SUCCESS,\n                            msg=\"Deleted %s\" % fp)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the db entries for the given release with the given releasefile and comment.", "response": "def delete_db_entry(self, release):\n        \"\"\"Delete the db entries for releasefile and comment of the given release\n\n        :param release: the release with the releasefile and comment db entries\n        :type release: :class:`Release`\n        :returns: an action status\n        :rtype: :class:`ActionStatus`\n        :raises: None\n        \"\"\"\n        log.info(\"Delete database entry for file.\")\n        release._releasedbentry.delete()\n        log.info(\"Delete database entry for comment.\")\n        release._commentdbentry.delete()\n        return ActionStatus(ActionStatus.SUCCESS,\n                            msg=\"Deleted database entries for releasefile and comment\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _perform_validation(self, path, value, results):\n        name = path if path != None else \"value\"\n        value = ObjectReader.get_value(value)\n\n        super(MapSchema, self)._perform_validation(path, value, results)\n\n        if value == None:\n            return\n\n        if isinstance(value, dict):\n            for (key, value) in value.items():\n                element_path = key if path == None or len(path) == 0 else path + \".\" + key\n\n                self._perform_type_validation(element_path, self.key_type, key, results)\n                self._perform_type_validation(element_path, self.value_type, value, results)\n        else:\n            results.append(\n                ValidationResult(\n                    path,\n                    ValidationResultType.Error,\n                    \"VALUE_ISNOT_MAP\",\n                    name + \" type is expected to be Map\",\n                    \"Map\",\n                    type(value)\n                )\n            )", "response": "Perform validation of a given value against the schema and configured validation rules."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading data from adb socket", "response": "def socket_reader(connection: socket, buffer_size: int = 1024):\n    \"\"\" read data from adb socket \"\"\"\n    while connection is not None:\n        try:\n            buffer = connection.recv(buffer_size)\n            # no output\n            if not len(buffer):\n                raise ConnectionAbortedError\n        except ConnectionAbortedError:\n            # socket closed\n            print('connection aborted')\n            connection.close()\n            yield None\n        except OSError:\n            # still operate connection after it was closed\n            print('socket closed')\n            connection.close()\n            yield None\n        else:\n            yield buffer"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndecoding adb response text into set of device ids", "response": "def decode_response(content: bytes) -> set:\n    \"\"\" adb response text -> device set \"\"\"\n    content = content[4:].decode(config.ENCODING)\n    if '\\t' not in content and '\\n' not in content:\n        return set()\n\n    connected_devices = set()\n    device_list = [i for i in content.split('\\n') if i]\n    for each_device in device_list:\n        device_id, device_status = each_device.split('\\t')\n        if device_status == 'device':\n            connected_devices.add(device_id)\n    return connected_devices"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the requirements. txt file and reformat the Pipfile.", "response": "def main(requirements_file, skip_requirements_file, pipfile, skip_pipfile):\n    # type: (str, bool, str, bool) -> None\n    \"\"\"Update the requirements.txt file and reformat the Pipfile.\"\"\"\n    pipfile_path = path.Path(pipfile)\n    pf = load_pipfile(pipfile_path)\n\n    if not skip_requirements_file:\n        requirements_file_path = path.Path(requirements_file)\n        update_requirements(requirements_file_path, pf)\n\n    if not skip_pipfile:\n        dump_pipfile(pipfile_path, pf)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clean_file(self):\n        data = self.cleaned_data['file']\n\n        available_parsers = self.get_parsers()\n\n        for parser in available_parsers:\n            try:\n                return parser.parse_file(data)\n            except parsers.ParserError:\n                pass\n\n        raise forms.ValidationError(\n            \"No parser could read the file. Tried with parsers %s.\" %\n            (\", \" % (force_text(p) for p in available_parsers)))", "response": "Analyse the uploaded file and return the parsed lines."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring unique fields are unique among entered data.", "response": "def clean_unique_fields(self):\n        \"\"\"Ensure 'unique fields' are unique among entered data.\"\"\"\n        if not self.unique_fields:\n            return\n\n        keys = set()\n        duplicates = []\n\n        for form in self.forms:\n            key = tuple(form.cleaned_data[field] for field in self.unique_fields)\n            if key in keys:\n                duplicates.append(\",\".join(key))\n            else:\n                keys.add(key)\n\n        if duplicates:\n            raise forms.ValidationError(\n                \"Fields %s should be unique; found duplicates for %s\" % (\n                    ','.join(self.unique_fields), duplicates))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the bipartite distance matrix between the observations in the first and the second list.", "response": "def distance_matrix(trains1, trains2, cos, tau):\n    \"\"\"\n    Return the *bipartite* (rectangular) distance matrix between the observations in the first and the second list.\n\n    Convenience function; equivalent to ``dissimilarity_matrix(trains1, trains2, cos, tau, \"distance\")``. Refer to :func:`pymuvr.dissimilarity_matrix` for full documentation.\n    \"\"\"\n    return dissimilarity_matrix(trains1, trains2, cos, tau, \"distance\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(itf):\n\n    if not itf:\n        return 1\n\n    # access user input\n    options = SplitInput(itf)\n\n    # read input\n    inputpath = os.path.abspath(options.inputpath)\n    print(\" Reading input file ...\")\n    molecules = csv_interface.read_csv(inputpath, options)\n    if not molecules:\n        print(\"\\n '{flag}' was unable to be parsed\\n\".format(flag=os.path.basename(options.inputpath)))\n        sys.exit(1)\n\n    # determine the sort order & ensemble_size\n    #sort_order = classification.get_sort_order(molecules)\n    sort_order = 'asc'\n    ensemble_size = options.ensemble_size\n\n    # loop over all ensembles\n    # temp 2/3/15 append to auc_list ef_list & write it out for later histogram construction\n    auc_list = []\n    ef_list = []\n    for size in [x + 1 for x in range(ensemble_size)]:\n        auc, ef = optimizor(molecules, sort_order, size, options)\n        auc_list += auc\n        ef_list += ef\n    # temp 2/9/15 write auc_list & ef_list out to files for subsequent post-processing\n    f = open('auc_histogram.csv', 'w')\n    for value in auc_list:\n        f.write('%f\\n' % value)\n        #f.write('%f, %s\\n' % (value[0], value[1]))\n    f.close()\n    f = open('ef_histogram.csv', 'w')\n    for value in ef_list:\n        f.write('%f\\n' % value)\n    f.close()", "response": "run the optimizor function"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nevaluates the performance of all possible ensembles of fixed size.", "response": "def optimizor(molecules, sort_order, ensemble_size, options):\n    \"\"\"\n\tEvaluate the performance of all ensembles of fixed size.\n\t\"\"\"\n    # set variables\n    ncpu = options.ncpu\n    score_field = options.score_field\n\n    # generate an exhaustive list of all possible ensembles\n    ensemble_list = make_ensemble_list(molecules, score_field, ensemble_size)\n\n    # set number of processors.\n    if not ncpu:\n        ncpu = multiprocessing.cpu_count()\n\n    if ncpu > 1:\n        print(\"Determining the performance of {d} ensembles using {n} processors\".format(d=len(ensemble_list), n=ncpu))\n\n        if ncpu > len(ensemble_list):\n            ncpu = len(ensemble_list)\n\n        jobs = []\n        output_queue = multiprocessing.Queue()\n\n        for ensemble_chunk in chunker(ensemble_list, ncpu):\n            p = multiprocessing.Process(target=evaluate,\n                                        args=(molecules, ensemble_chunk, sort_order, options, output_queue))\n            jobs.append(p)\n            p.start()\n\n        # collect results into a dictionary\n        results = {}\n        for i in range(len(jobs)):\n            results.update(output_queue.get())\n\n        # stop jobs\n        for j in jobs:\n            j.join()\n\n    else:\n        print(\"Determining the performance of {d} ensembles using {n} processor\".format(d=len(ensemble_list), n=ncpu))\n        results = evaluate(molecules, ensemble_list, sort_order, options)\n\n    # peel away the best performing ensemble\n    ensemble = screener.find_best_ensemble(results, options)\n\n    # write out the best performing ensemble\n    output.write_ensemble(list(ensemble), options)\n\n    # temp 2/9/15 generate and return a list of auc values and ef at fpf = 0.001 to build up a histogram\n    nd = max([results[x].ef.keys() for x in results.keys()][0])\n    n = int(round(0.001 * nd))\n    ef_list = [results[x].get_prop(n, 'ef') for x in results.keys()]\n    auc_list = [results[x].get_prop('auc') for x in results.keys()]\n    # auc_list = [[results[x].get_prop('auc'), results[x].get_prop('ensemble')] for x in results.keys()]\n    return auc_list, ef_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef evaluate(molecules, ensemble_chunk, sort_order, options, output_queue=None):\n\n    results = {}    # {('receptor_1', ..., 'receptor_n') : ensemble storage object}\n\n    for ensemble in ensemble_chunk:\n        results[ensemble] = calculate_performance(molecules, ensemble, sort_order, options)\n\n    if output_queue is not None:\n        output_queue.put(results)\n    else:\n        return results", "response": "Evaluate VS performance of each ensemble in ensemble_chunk"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncalculate virtual screening performance of the input ensemble and returns the results in an anisotree storage object.", "response": "def calculate_performance(molecules, ensemble, sort_order, options):\n    \"\"\"\n    determine the virtual screening performance of the input ensemble, and return the results in an\n    ensemble storage object.\n    :param molecules:\n    :param ensemble:\n    :param sort_order: string. either 'asc' (for binding energy estimates)  or 'dsc' (for similarity scores)\n    :param options: instance of s\n    :return:\n    \"\"\"\n    es = EnsembleStorage()\n    es.set_prop('ensemble', ensemble)\n\n    # calculate the appropriate score structure type\n    score_structure = classification.make_score_structure(molecules, ensemble)\n\n    # determine auc value\n    auc_structure = classification.make_auc_structure(score_structure)\n    auc = classification.calculate_auc(auc_structure, sort_order, 'no stats')\n    es.set_prop('auc', auc)\n\n    # calculate enrichment factors\n    for fpf in classification.make_fpfList(options, score_structure):\n        fpf = float(fpf)\n        ef_structure = classification.make_ef_structure(score_structure, fpf, sort_order)\n        if ef_structure:\n            ef = classification.calculate_ef(ef_structure, fpf)\n            es.set_prop(ef[0], ef[1], 'ef')\n    return es"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_ensemble_list(molecules, score_field, ensemble_size):\n\n    # generate list of queries\n    queryList = molecules[0].scores.keys()\n\n    # nchoosek\n    ensemble_iterator = itertools.combinations(queryList, ensemble_size)\n\n    # list of tuples: [(query1, query2), ... (queryN-1, queryN)\n    ensembleList = []\n\n    for ensemble in ensemble_iterator:\n        ensembleList.append(ensemble)\n\n    return ensembleList", "response": "Construct ensemble list from list of molecules and score field."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate successive chunks of ensemble_list.", "response": "def chunker(ensemble_list, ncpu):\n    \"\"\"\n\tGenerate successive chunks of ensemble_list.\n\t\"\"\"\n\n    # determine sublist lengths\n    length = int(len(ensemble_list) / ncpu)\n\n    # generator\n    for i in range(0, len(ensemble_list), length):\n        yield ensemble_list[i:i + length]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the angular separation between two locations on the sky.", "response": "def get(\n            self):\n        \"\"\"*Calulate the angular separation between two locations on the sky*\n\n        Input precision should be respected.\n\n        **Key Arguments:**\n\n        **Return:**\n            - ``angularSeparation`` -- total angular separation between coordinates (arcsec)\n            - ``north`` -- north-south separation between coordinates (arcsec)\n            - ``east`` -- east-west separation between coordinates (arcsec)\n\n        See main class usage for details.\n        \"\"\"\n        self.log.info('starting the ``get_angular_separation`` method')\n\n        from astrocalc.coords import unit_conversion\n\n        # CONSTANTS\n        pi = (4 * math.atan(1.0))\n        DEG_TO_RAD_FACTOR = pi / 180.0\n        RAD_TO_DEG_FACTOR = 180.0 / pi\n\n        converter = unit_conversion(\n            log=self.log\n        )\n        dec1 = converter.dec_sexegesimal_to_decimal(\n            dec=self.dec1\n        )\n        dec2 = converter.dec_sexegesimal_to_decimal(\n            dec=self.dec2\n        )\n        ra1 = converter.ra_sexegesimal_to_decimal(\n            ra=self.ra1\n        )\n        ra2 = converter.ra_sexegesimal_to_decimal(\n            ra=self.ra2\n        )\n\n        # PRECISION TEST\n        precision = 100\n        vals = [dec1, dec2, ra1, ra2]\n        for v in vals:\n            thisLen = len(repr(v * 3600.).split(\".\")[-1])\n            if thisLen < precision:\n                precision = thisLen\n\n        angularSeparation = None\n\n        aa = (90.0 - dec1) * DEG_TO_RAD_FACTOR\n        bb = (90.0 - dec2) * DEG_TO_RAD_FACTOR\n        cc = (ra1 - ra2) * DEG_TO_RAD_FACTOR\n        one = math.cos(aa) * math.cos(bb)\n        two = math.sin(aa) * math.sin(bb) * math.cos(cc)\n\n        # Because acos() returns NaN outside the ranges of -1 to +1\n        # we need to check this.  Double precision decimal places\n        # can give values like 1.0000000000002 which will throw an\n        # exception.\n\n        three = one + two\n        if (three > 1.0):\n            three = 1.0\n        if (three < -1.0):\n            three = -1.0\n\n        # BE CAREFUL WITH PRECISION PROPAGATION\n        thisVal = math.acos(three)\n        angularSeparation = float(thisVal) * RAD_TO_DEG_FACTOR * 3600.0\n\n        # Now work out N-S, E-W separations (object 1 relative to 2)\n        north = -(dec1 - dec2) * 3600.0\n        east = -(ra1 - ra2) * \\\n            math.cos((dec1 + dec2) * DEG_TO_RAD_FACTOR / 2.) * 3600.0\n\n        angularSeparation = \"%0.*f\" % (precision, angularSeparation)\n        north = \"%0.*f\" % (precision, north)\n        east = \"%0.*f\" % (precision, east)\n\n        self.log.info('completed the ``get_angular_separation`` method')\n        return angularSeparation, north, east"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fasta_verifier(entries, ambiguous=False):\n\n    if ambiguous:\n        regex = r'^>.+{0}[ACGTURYKMSWBDHVNX]+{0}$'.format(os.linesep)\n    else:\n        regex = r'^>.+{0}[ACGTU]+{0}$'.format(os.linesep)\n    delimiter = r'{0}'.format(os.linesep)\n\n    for entry in entries:\n        try:\n            entry_verifier([entry.write()], regex, delimiter)\n        except FormatError as error:\n            if error.part == 0:\n                msg = 'Unknown Header Error with {0}'.format(entry.id)\n                raise FormatError(message=msg)\n            elif error.part == 1 and ambiguous:\n                msg = '{0} contains a base not in ' \\\n                      '[ACGTURYKMSWBDHVNX]'.format(entry.id)\n                raise FormatError(message=msg)\n            elif error.part == 1 and not ambiguous:\n                msg = '{0} contains a base not in ' \\\n                      '[ACGTU]'.format(entry.id)\n                raise FormatError(message=msg)\n            else:\n                msg = '{0}: Unknown Error: Likely a Bug'.format(entry.id)\n                raise FormatError(message=msg)", "response": "Raises error if invalid FASTA format detected with descriptive message\nMimeType"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a string to get descriptor fields and returns them as a Descriptor.", "response": "def from_string(value):\n        \"\"\"\n        Parses a string to get descriptor fields and returns them as a Descriptor.\n        The string must have format name[,library]\n\n        :param value: a string to parse.\n\n        :return: a newly created Descriptor.\n        \"\"\"\n        if value == None or len(value) == 0:\n            return None\n                \n        tokens = value.split(\",\")\n        if len(tokens) == 1:\n            return TypeDescriptor(tokens[0].strip(), None)\n        elif len(tokens) == 2:\n            return TypeDescriptor(tokens[0].strip(), tokens[1].strip())\n        else:\n            raise ConfigException(\n                None, \"BAD_DESCRIPTOR\", \"Type descriptor \" + value + \" is in wrong format\"\n            ).with_details(\"descriptor\", value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef no_history_check(func):\n\n    def no_history_check_decorator(self, *args, **kwargs):\n        if ConnectionBasic.max_history is 0:\n            raise IndexError(\"ConnectionBasic.max_history is set to 0, \"\n                             \"therefore this functionality is disabled\")\n        return func(self, *args, **kwargs)\n\n    return no_history_check_decorator", "response": "Decorator to setup a check to see if history has been turned off and if it has then throw an exception\nWorkItem"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_connection(username=None, password=None, login_url=None,\n                      auth_url=None, api_key=None, realm=None,\n                      base_uri=None, proxies=None, timeout=None, headers=None,\n                      cookies=None, accepted_return=None):\n    \"\"\"\n        Creates and returns a connection\n        :param realm:\n        :param username        : str of user's email to use for the session.\n        :param password        : str of password for the user\n        :param login_url       : str of the login_url\n        :param auth_url        : str of the auth_url, if Oauth2 is used\n        :param api_key         : str of api key of the client software\n        :param base_uri        : str of base url e.g. seaborngames.us\n        :param proxies         : str of proxies dictionary as used in requests\n        :param timeout         : str of timeout to use for api call\n        :param headers         : str of specially header to use for api calls\n        :param cookies         : list of cookies to use in the http request\n        :param accepted_return : str of enum ['json','text','html'] \n        \"\"\"\n    return ConnectionBasic(**function_kwargs())", "response": "Creates and returns a ConnectionBasic object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef report(self, start=0, end=None):\n        return [api_call.report for api_call in self[start:end]]", "response": "This will return a list of str containing the report for all the endpointVersion and dataVersion"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put(self, _url, **kwargs):\n        api_call = self.request('PUT', _url, **kwargs)\n        self.cookies.update(api_call.response_cookies)\n        return api_call.data", "response": "This method will perform a PUT request to the server and return the response data without repr formatting\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef request(self, method, _url, **kwargs):\n        if self.base_uri and _url.startswith(self.base_uri):\n            _url = _url[len(self.base_uri):]\n        api_call = self._create_api_call(method, _url, kwargs)\n        data = self._clean_arguments(kwargs.pop('data', None))\n        params = self._clean_arguments(kwargs)\n\n        api_call.set_request(method=method,\n                             data=data,\n                             params=params,\n                             sub_url=_url)\n\n        api_call.send()\n        return api_call", "response": "This will instantiate a Request and then store it in self. pn."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self, filename, _url, **kwargs):\n        api_call = self._create_api_call('save', _url, kwargs)\n        api_call.filename = filename\n\n        data = self._clean_arguments(kwargs.pop('data', None))\n        params = self._clean_arguments(kwargs)\n        mkdir(os.path.split(filename)[0])\n        if os.path.exists(filename):\n            os.remove(filename)\n\n        if filename.lower().endswith('.m3u8'):  # remove old files\n            mkdir(os.path.split(filename)[0])\n            ts_path = api_call.get_ts_folder(filename)\n            mkdir(ts_path)\n            [os.remove(file_) for file_ in glob.glob(ts_path + '/*.ts')]\n\n        api_call.set_request(method='GET',\n                             data=data,\n                             params=params,\n                             sub_url=_url)\n\n        api_call.send(stream_to_file=filename)\n\n        last_repeat_needed = 0\n        while last_repeat_needed < api_call.repeat_needed:\n            last_repeat_needed = api_call.repeat_needed\n            for remaining_repeat_attempts in range(1000, -1, -1):\n                if not api_call.repeat_needed:\n                    break\n                api_call.send(stream_to_file=filename)\n        return filename", "response": "This method will stream the results of a request to a file called filename and store it in self. label."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_api_call(self, method, _url, kwargs):\n        api_call = self.ApiCall(name='%s.%s' % (_url, method),\n                                label='ID_%s' % self._count,\n                                base_uri=self.base_uri,\n                                timeout=self.timeout,\n                                headers=self.headers,\n                                cookies=self.cookies,\n                                proxies=self.proxies,\n                                accepted_return=self.accepted_return or 'json')\n        if self.max_history:\n            self._count += 1  # count of _calls\n            if len(self) > self.max_history:\n                self._calls.pop(0)\n            self._calls['ID_%s' % self._count] = api_call\n        return api_call", "response": "This method will create an APICall object and return it\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _clean_arguments(kwargs):\n        if not isinstance(kwargs, dict):\n            return kwargs\n        for k in list(kwargs.keys()):\n            if kwargs[k] is None:\n                kwargs.pop(k)\n            elif kwargs[k] is False:\n                kwargs[k] = 0\n            elif kwargs[k] is True:\n                kwargs[k] = 1\n        return kwargs", "response": "This is to remove None and clean other arguments\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef time_report(self, source=None, **kwargs):\n        if source is None:\n            api_calls = [self[-1]]\n        elif isinstance(source, list):\n            api_calls = source\n        elif source is None:\n            api_calls = self.values()\n        elif isinstance(source, ApiCall):\n            api_calls = [source]\n        else:\n            api_calls = self[source]\n            if not isinstance(api_calls, list):\n                api_calls = [api_calls]\n        return '\\n\\n'.join([repr(api_call.time_report(**kwargs)\n                                 for api_call in api_calls)])", "response": "This will generate a time table for the source api_calls\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean_base_uri(url):\n        if url is None:\n            return url\n        if not '//' in url:\n            url = 'https://' + url\n\n        ret = url[:url.find('/', url.find('//') + 2) + 1] or url\n        assert '.' in url, \"<%s> is not a proper base_uri\" % ret\n\n        if not ret.endswith('/'):\n            ret += '/'\n        return ret", "response": "This will clean up the url so that it is in the form of a proper base_uri."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_every(kls, every):\n        def wrapper(func):\n            func.dashmat_check = Checker(func, every)\n            return func\n        return wrapper", "response": "Decorator for registering a check to run every every."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencoding a request into a raw HTTP request.", "response": "def encode_request(from_pid, to_pid, method, body=None, content_type=None, legacy=False):\n  \"\"\"\n  Encode a request into a raw HTTP request. This function returns a string\n  of bytes that represent a valid HTTP/1.0 request, including any libprocess\n  headers required for communication.\n\n  Use the `legacy` option (set to True) to use the legacy User-Agent based\n  libprocess identification.\n  \"\"\"\n\n  if body is None:\n    body = b''\n\n  if not isinstance(body, (bytes, bytearray)):\n    raise TypeError('Body must be a sequence of bytes.')\n\n  headers = [\n    'POST /{process}/{method} HTTP/1.0'.format(process=to_pid.id, method=method),\n    'Connection: Keep-Alive',\n    'Content-Length: %d' % len(body)\n  ]\n\n  if legacy:\n    headers.append('User-Agent: libprocess/{pid}'.format(pid=from_pid))\n  else:\n    headers.append('Libprocess-From: {pid}'.format(pid=from_pid))\n\n  if content_type is not None:\n    headers.append('Content-Type: {content_type}'.format(content_type=content_type))\n\n  headers = [header.encode('utf8') for header in headers]\n\n  def iter_fragments():\n    for fragment in headers:\n      yield fragment\n      yield CRLF\n    yield CRLF\n    if body:\n      yield body\n\n  return b''.join(iter_fragments())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a single key from stdin", "response": "def get_key(raw=False):\n    \"\"\" Gets a single key from stdin\n    \"\"\"\n    file_descriptor = stdin.fileno()\n    state = tcgetattr(file_descriptor)\n    chars = []\n    try:\n        setraw(stdin.fileno())\n        for i in range(3):\n            char = stdin.read(1)\n            ordinal = ord(char)\n            chars.append(char)\n            if i == 0 and ordinal != 27:\n                break\n            elif i == 1 and ordinal != 91:\n                break\n            elif i == 2 and ordinal != 51:\n                break\n    finally:\n        tcsetattr(file_descriptor, TCSADRAIN, state)\n    result = \"\".join(chars)\n    return result if raw else codes.keys_flipped.get(result, result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_last_commit_message(self):\n        # Check if we are currently in a repo\n        try:\n            branch = self.active_branch\n            return self.commit(branch).message\n        except InvalidGitRepositoryError:\n            print \"Not in a git repo\"\n            return None", "response": "Gets the last commit message on the active branch Returns None if not in a git repo"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_last_modified_timestamp(self):\n        cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\"\n        ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        output = ps.communicate()[0]\n        print output", "response": "Gets the last modified timestamp of the current git root directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_config_root(path=sys.argv[0]):\n    dirname = os.path.dirname(path)\n    lastdirname = None\n\n    while dirname != lastdirname:\n        config_root = os.path.join(dirname, 'config')\n        if os.path.exists(config_root):\n            return config_root\n\n        lastdirname, dirname = dirname, os.path.dirname(dirname)", "response": "Finds config root relative to the given file path"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the value of the item with the given index.", "response": "def setData(self, index, value, role=QtCore.Qt.EditRole):\n        \"\"\"Reimplemented from QtCore.QAbstractItemModel\n\n        You can only set the value.\n\n        :param index: the index to edit, column should be 1.\n        :type index: :class:`PySide.QtCore.QModelIndex`\n        :param value: the new value for the configobj\n        :type value: object\n        :param role: Optional - the ItemDataRole. Default is QtCore.Qt.EditRole\n        :type role: QtCore.Qt.ItemDataRole\n        :returns: True if index was edited, False if index could not be edited.\n        :rtype: bool\n        :raises: None\n\n        \"\"\"\n        if index.isValid():\n            if role == QtCore.Qt.EditRole:\n                if index.column() == 1:\n                    p = index.internalPointer()\n                    k = self.get_key(p, index.row())\n                    # we could just set the value\n                    # BUT for listvalues etc it will not work\n                    strval = self._val_to_str(value)\n                    # _handle_value will parse it correctly\n                    # comments gets lost\n                    (parsedval, comment) = self._conf._handle_value(strval)\n                    p[k] = parsedval\n                    self.dataChanged.emit(index, index)\n                    return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestoring the value of the given index row to its default value.", "response": "def restore_default(self, index):\n        \"\"\"Set the value of the given index row to its default\n\n        :param index:\n        :type index:\n        :returns:\n        :rtype:\n        :raises:\n        \"\"\"\n        spec = self.get_configspec_str(index)\n        if spec is None or isinstance(spec, Section):\n            return\n        try:\n            default = self._vld.get_default_value(spec)\n            defaultstr = self._val_to_str(default)\n            self.setData(index, defaultstr)\n        except KeyError:\n            raise ConfigError(\"Missing Default Value in spec: \\\"%s\\\"\" % spec)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the value of the given index", "response": "def get_value(self, index):\n        \"\"\" Return the value of the given index\n\n        The index stores the section as internal pointer.\n        The row of the index determines the key.\n        The key is used on the section to return the value\n\n        :param index: The QModelIndex\n        :type index: QModelIndex\n        :returns: The value for the given index\n        \"\"\"\n        p = index.internalPointer()\n        k = self.get_key(p, index.row())\n        return p[k]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_configspec_str(self, index):\n        p = index.internalPointer()\n        if p is None:\n            return\n        spec = p.configspec\n        if spec is None:\n            return None\n        k = self.get_key(p, index.row())\n        try:\n            return spec[k]\n        except KeyError:\n            return None", "response": "Returns the config spec string of the given index"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _val_to_str(self, value):\n        # might be a list value\n        # then represent it 'nicer' so that when we edit it, the same value will return\n        if isinstance(value, list):\n            # so we have a list value. the default str(v) would produce something like: ['a', 'b']\n            # handling such a value is not possible. it should be: 'a', 'b'\n            # so we have to convert it to a string but we have to make sure, we do not loose quotes\n            # even when values are integers, they get quoted. thats alright. the config obj will parse them correctly\n            return ', '.join(\"'%s'\" % str(i) for i in value)\n        return str(value)", "response": "Converts the value to a string that can be parsed correctly by the confobj\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data(self, index, role):\n        if not index.isValid():\n            return\n        if role == QtCore.Qt.DisplayRole:\n            conf = self.__configs[index.row()]\n            edited = self.__edited[index.row()]\n            if edited:\n                prefix = '*'\n            else:\n                prefix = ''\n            return '%s%s' % (prefix, conf.filename)\n        if role == self.confobjRole:\n            conf = self.__configs[index.row()]\n            return conf", "response": "Return some data for the item in the index and role"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting whether the conf was edited or not.", "response": "def set_index_edited(self, index, edited):\n        \"\"\"Set whether the conf was edited or not.\n\n        Edited files will be displayed with a \\'*\\'\n\n        :param index: the index that was edited\n        :type index: QModelIndex\n        :param edited: if the file was edited, set edited to True, else False\n        :type edited: bool\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.__edited[index.row()] = edited\n        self.dataChanged.emit(index, index)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all indices that were modified", "response": "def get_edited(self, ):\n        \"\"\"Return all indices that were modified\n\n        :returns: list of indices for modified confs\n        :rtype: list of QModelIndex\n        :raises: None\n        \"\"\"\n        modified = []\n        for i in range(len(self.__edited)):\n            if self.__edited[i]:\n                modified.append(self.__configs[i])\n        return modified"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(self, index):\n        c = self.__configs[index.row()]\n        if c.configspec is None:\n            return True\n        else:\n            return c.validate(self.vld)", "response": "Validate the conf for the given index"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef metapolicy(request, permitted, domains=None):\n    if domains is None:\n        domains = []\n    policy = policies.Policy(*domains)\n    policy.metapolicy(permitted)\n    return serve(request, policy)", "response": "Serves a cross - domain policy which can be used to access other policies on the same domain."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply filter to resource", "response": "def apply(self, resource):\n        \"\"\"\n        Apply filter to resource\n        :param resource: Image\n        :return: Image\n        \"\"\"\n        if not isinstance(resource, Image.Image):\n            raise ValueError('Unknown resource format')\n\n        resource_format = resource.format\n        resource = resource.rotate(self.angle, expand=True)\n        resource.format = resource_format\n\n        return resource"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap around subprocess. Popen.", "response": "def _run_popen(command, print_output=False):\n    \"\"\"\n    subprocess has the most terrible interface ever.\n    Envoy is an option but too heavyweight for this.\n    This is a convenience wrapper around subprocess.Popen.\n\n    Also, this merges STDOUT and STDERR together, since\n    there isn't a good way of interleaving them without\n    threads.\n    \"\"\"\n    output = ''\n    po = subprocess.Popen(\n        command,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n    )\n    fcntl.fcntl(\n        po.stdout.fileno(),\n        fcntl.F_SETFL,\n        fcntl.fcntl(po.stdout.fileno(), fcntl.F_GETFL) | os.O_NONBLOCK,\n    )\n    while po.poll() is None:\n        stream = po.stdout\n        readx = select.select([stream.fileno()], [], [])[0]\n        if readx:\n            chunk = stream.read()\n            output += chunk\n            if print_output:\n                print chunk\n    return Result(output, po.returncode)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ed(s1, s2):\n    '''edit distance\n\n    >>> ed('', ''), ed('a', 'a'), ed('','a'), ed('a', ''), ed('a!a', 'a.a')\n    (0, 0, 1, 1, 1)\n\n    This implementation takes only O(min(|s1|,|s2|)) space.\n    '''\n    m, n = len(s1), len(s2)\n    if m < n:\n        m, n = n, m         # ensure n <= m, to use O(min(n,m)) space\n        s1, s2 = s2, s1\n    d = list(range(n+1))\n    for i in range(m):\n        p = i\n        d[0] = i+1\n        for j in range(n):\n            t = 0 if s1[i] == s2[j] else 1\n            p, d[j+1] = d[j+1], min(p+t, d[j]+1, d[j+1]+1)\n    return d[n]", "response": "edit distance\n\n    >>> ed('', ''), ed('a', 'a'), ed('','a'), ed('a', ''), ed('a!a', 'a.a')\n    (0, 0, 1, 1, 1)\n\n    This implementation takes only O(min(|s1|,|s2|)) space."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef perimeter(patch, world_size=(60, 60),\n              neighbor_func=get_rook_neighbors_toroidal):\n    \"\"\"\n    Count cell faces in patch that do not connect to part of patch.\n    This preserves various square geometry features that would not\n    be preserved by merely counting the number of cells that touch\n    an edge.\n    \"\"\"\n    edge = 0\n    patch = set([tuple(i) for i in patch])\n    for cell in patch:\n        neighbors = neighbor_func(cell, world_size)\n        neighbors = [n for n in neighbors if n not in patch]\n        edge += len(neighbors)\n\n    return edge", "response": "Calculates the number of cells that are not connected to a given patch."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef related_circumscribing_circle(patch, formula=True, world_size=(60, 60)):\n    patch_area = float(area(patch))\n    max_dist = 0.0\n    cell_pair = (None, None)\n\n    try:\n        hull = ConvexHull(patch)\n        edge = list(np.array(patch)[hull.vertices])\n    except:\n        edge = patch\n\n    for i, cell1 in enumerate(edge):\n        for j, cell2 in enumerate(edge[i+1:]):\n            squared_dist = squared_toroidal_dist(cell1, cell2, world_size)\n            if squared_dist > max_dist:\n                max_dist = squared_dist\n                cell_pair = (cell1, cell2)\n\n    radius = sqrt(max_dist)/2.0  # only take sqrt once\n\n    if radius == 0:\n        # This is a 1-cell patch - manually return 0\n        return 0\n\n    if formula:\n        return 1-(patch_area/((radius**2)*pi))\n\n    center = ((cell_pair[0][0]+cell_pair[1][0])/2.0,\n              ((cell_pair[0][1]+cell_pair[1][1])/2.0))\n\n    # Calculating area of circumscrbing circle\n    # by brute force. Turns out that this is the\n    # Gauss circle problem, which is solved by an\n    # infinite sum, so brute force will be more\n    # precise\n\n    circle_area = 0.0\n    x_floor = int(floor(center[0]-radius))\n    x_ceil = int(ceil(center[0]+radius)+1)\n\n    y_floor = int(floor(center[1]-radius))\n    y_ceil = int(ceil(center[1]+radius)+1)\n\n    for x in range(x_floor, x_ceil):\n        for y in range(y_floor, y_ceil):\n            if dist((x, y), center) <= radius:\n                circle_area += 1\n\n    return 1 - (patch_area/circle_area)", "response": "Returns the circumscribing circle for a given patch."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef traverse_core(core_area, world_size=(60, 60),\n                  neighbor_func=get_moore_neighbors_toroidal):\n    \"\"\"\n    Treat cells in core_area like a graph and traverse it to\n    see how many connected components there are.\n    \"\"\"\n\n    if not core_area:\n        return []\n    core_area = [tuple(i) for i in core_area]\n    curr = core_area[0]\n    core_area = set(core_area[1:])\n    to_explore = []\n    cores = [[curr]]\n\n    while core_area:\n        neighbors = neighbor_func(curr, world_size)\n\n        for n in neighbors:\n            if n in core_area:\n                core_area.remove(n)\n                to_explore.append(n)\n                cores[-1].append(n)\n\n        if to_explore:\n            curr = to_explore.pop()\n        else:\n            curr = core_area.pop()\n            cores.append([curr])\n\n    return cores", "response": "Traverse a core_area and return a list of all the cores that are connected to it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _dict_compare(d1, d2):\n    keys_added = set(d2.keys()) - set(d1.keys())\n    keys_changed = [k for k in d1.keys() if k in d2.keys() and d1[k] != d2[k]]\n    return list(keys_added) + keys_changed", "response": "This function compares two dictionaries and returns a list of keys that are added or changed"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def create_identity(self, \n        identity: str, \n        passwd: str, \n    ) -> SessionIdentity :\n        \"\"\" \u76f4\u63a5\u901a\u8fc7\u7535\u5b50\u90ae\u4ef6\u548c\u5bc6\u7801\u521b\u5efa\u65b0\u7528\u6237\u7684\u767b\u5f55\u8eab\u4efd \"\"\"\n\n        identity_path = f\"{self._prefix_identity}/{identity}\"\n\n        profile, _ = await self._client.get(identity_path)\n        if profile is not None:\n            raise AlreadyExists(f\"\u767b\u9646\u8eab\u4efd'{identity}'\u5df2\u7ecf\u6ce8\u518c\")\n\n        user_id = await self._user_id_generator.new()\n\n        # \u52a0\u5bc6\u767b\u5f55\u6807\u8bc6\n        hashed = sha256_crypt.using(rounds=2000, salt_size=8).hash(passwd)\n\n        profile = {\n            \"user_id\": user_id,\n            \"identity\": identity,\n            \"hashed\": hashed\n        }\n    \n        value = json.dumps(profile).encode(\"ascii\")\n        await self._client.put(identity_path, value)\n\n\n        return SessionIdentity(user_id=user_id, identity=identity)", "response": "Create a new identity."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if passwd is correct.", "response": "async def check_passwd(self, \n        identity: str, \n        passwd: str\n    ) -> SessionIdentity :\n        \"\"\" \u901a\u8fc7\u5bc6\u7801\u68c0\u67e5\u8eab\u4efd \"\"\"\n        assert identity\n\n        value, _ = await self._client.get(f\"{self._prefix_identity}/{identity}\")\n        if value is None:\n            logger.debug(f'Not found identity: {identity}')\n            raise Unauthorized(f\"\u65e0\u6b64\u767b\u5f55\u8eab\u4efd'{identity}'\")\n\n        profile = json.loads(value.decode('utf-8'))\n\n        user_id = profile['user_id']\n        identity = profile['identity']\n        hashed = profile['hashed']\n\n        if sha256_crypt.verify(passwd, hashed):\n            return SessionIdentity(user_id=user_id, identity=identity)\n        else:\n            raise Unauthorized(f\"\u767b\u5f55\u8eab\u4efd'{identity}'\u8ba4\u8bc1\u5931\u8d25\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def verify_permissions(self, user_id, *permissions):\n\n        prefix = f\"{self._prefix_perm}/{user_id}/\"\n\n        perm_names = [str(p) for p in permissions]\n        \n        checkings = [KV.get.txn(prefix + p) for p in perm_names]\n        success, responses = await self._client.txn(compare=[], success=checkings)\n        if not success:\n            errmsg = f\"\u65e0\u6cd5\u8bfb\u53d6\u7528\u6237({user_id})\u7684\u6743\u9650\u4fe1\u606f\"\n            raise Unprocessable(errmsg)\n\n        for i, item  in enumerate(responses):\n            if item[0] is not None:\n                return permissions[0]\n                \n        return None", "response": "Verify that the user has the given permissions."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\nasync def create_email_identity(self, \n            client_id, identity, passwd, *, \n            user_id=None # \u5982\u679c\u8bbe\u7f6e\u7528\u6237ID\uff0c\u5219\u521b\u5efa\u8be5\u7528\u6237\u7684\u65b0\u767b\u5f55\u8eab\u4efd\n        ) -> SessionIdentity :\n        \"\"\" \u521b\u5efa\u4f7f\u7528\u7535\u5b50\u90ae\u4ef6\u5730\u5740\u548c\u5bc6\u7801\u767b\u5f55\u7684\u7528\u6237\u8eab\u4efd \"\"\"\n        \n        assert passwd\n\n        value, _ = await self._client.get(f\"/users/identity/{identity}\")\n        if value:\n            raise ValueError(f' {identity} has already been registered')\n\n        if user_id is None: # \u65b0\u7528\u6237\n            user_id = await self._user_id_generator.new()\n\n        # \u52a0\u5bc6\u767b\u5f55\u6807\u8bc6\n        hashed = sha256_crypt.using(rounds=2000, salt_size=8).hash(passwd)\n\n        profile = {\n            \"user_id\": user_id,\n            \"identity\": identity,\n            \"hashed\": hashed\n        }\n\n        token = genword(length=32, charset=\"ascii_50\")\n        key = f\"/users/verifying/{token}\"\n\n        await self._client.put(key, json.dumps(profile))\n\n        return SessionIdentity(user_id=user_id, identity=identity)", "response": "Create a new email identity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_command_line_args():\n    parser = argparse.ArgumentParser(description='PipApp. {}'.format(DESCRIPTION))\n    parser.add_argument(\n        '-d', '--dir',\n        metavar='DIR',\n        help='Root directory where to create new project files and dirs. Default is current directory.'\n    )\n    parser.add_argument(\n        '-v,', '--version',\n        action='version',\n        version='{} v{}'.format(PROGRAMNAME, VERSION)\n    )\n    parser.add_argument(\n        \"project_name\",\n        metavar='PROJECTNAME',\n        help=\"Name of the generated Project. Has to be a valid Python identifier.\"\n    )\n    return parser.parse_args()", "response": "parse command line args"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists the available tasks", "response": "def list_tasks(collector):\n    \"\"\"List the available_tasks\"\"\"\n    print(\"Usage: dashmat <task>\")\n    print(\"\")\n    print(\"Available tasks to choose from are:\")\n    print(\"-----------------------------------\")\n    print(\"\")\n    keygetter = lambda item: item[1].label\n    tasks = sorted(available_actions.items(), key=keygetter)\n    sorted_tasks = sorted(list(tasks), key=lambda item: len(item[0]))\n    max_length = max(len(name) for name, _ in sorted_tasks)\n    for key, task in sorted_tasks:\n        desc = dedent(task.__doc__ or \"\").strip().split('\\n')[0]\n        print(\"\\t{0}{1} :-: {2}\".format(\" \" * (max_length-len(key)), key, desc))\n    print(\"\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef requirements(collector):\n    out = sys.stdout\n    artifact = collector.configuration['dashmat'].artifact\n    if artifact not in (None, \"\", NotSpecified):\n        if isinstance(artifact, six.string_types):\n            out = open(artifact, 'w')\n        else:\n            out = artifact\n\n    for active in collector.configuration['__imported__'].values():\n        for requirement in active.requirements():\n            out.write(\"{0}\\n\".format(requirement))", "response": "Just print out the requirements"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run_checks(collector):\n    artifact = collector.configuration[\"dashmat\"].artifact\n    chosen = artifact\n    if chosen in (None, \"\", NotSpecified):\n        chosen = None\n\n    dashmat = collector.configuration[\"dashmat\"]\n    modules = collector.configuration[\"__active_modules__\"]\n    config_root = collector.configuration[\"config_root\"]\n    module_options = collector.configuration[\"modules\"]\n\n    datastore = JsonDataStore(os.path.join(config_root, \"data.json\"))\n    if dashmat.redis_host:\n        datastore = RedisDataStore(redis.Redis(dashmat.redis_host))\n\n    scheduler = Scheduler(datastore)\n\n    for name, module in modules.items():\n        if chosen is None or name == chosen:\n            server = module.make_server(module_options[name].server_options)\n            scheduler.register(module, server, name)\n\n    scheduler.twitch(force=True)", "response": "Run the checks for our modules"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting the npm modules that get installed in a docker image for the react server", "response": "def list_npm_modules(collector, no_print=False):\n    \"\"\"List the npm modules that get installed in a docker image for the react server\"\"\"\n    default = ReactServer().default_npm_deps()\n    for _, module in sorted(collector.configuration[\"__active_modules__\"].items()):\n        default.update(module.npm_deps())\n\n    if not no_print:\n        print(json.dumps(default, indent=4, sort_keys=True))\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef collect_dashboard_js(collector):\n    dashmat = collector.configuration[\"dashmat\"]\n\n    modules = collector.configuration[\"__active_modules__\"]\n    compiled_static_prep = dashmat.compiled_static_prep\n    compiled_static_folder = dashmat.compiled_static_folder\n\n    npm_deps = list_npm_modules(collector, no_print=True)\n    react_server = ReactServer()\n    react_server.prepare(npm_deps, compiled_static_folder)\n\n    for dashboard in collector.configuration[\"dashboards\"].values():\n        log.info(\"Generating compiled javascript for dashboard:{0}\".format(dashboard.path))\n        filename = dashboard.path.replace(\"_\", \"__\").replace(\"/\", \"_\")\n        location = os.path.join(compiled_static_folder, \"dashboards\", \"{0}.js\".format(filename))\n        if os.path.exists(location):\n            os.remove(location)\n        generate_dashboard_js(dashboard, react_server, compiled_static_folder, compiled_static_prep, modules)", "response": "Generate dashboard javascript for each dashboard"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_file(file, filename='<input>'):\n    reader = Reader(filename)\n    for line in file:\n        yield from reader.feed_line(line)\n    reader.finish()", "response": "This is a generator that yields all top - level S - expression nodes from a given file object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfeeding one line into the reader machine.", "response": "def feed_line(self, line):\n        \"\"\"Feeds one line of input into the reader machine.  This method is\n        a generator that yields all top-level S-expressions that have been\n        recognized on this line (including multi-line expressions whose last\n        character is on this line).\n        \"\"\"\n        self.line += 1\n        pos = 0\n        while pos < len(line):\n            loc_start = TextLocationSingle(self.filename, self.line, pos + 1)\n            if self.state is State.NORMAL:\n                item_re = RE_TOKEN\n                thing = 'token'\n            elif self.state is State.STRING:\n                item_re = RE_STRING_ITEM\n                thing = 'escape sequence'\n            elif self.state is State.BINARRAY:\n                item_re = RE_BINARRAY_ITEM[self.binarray_base]\n                thing = 'binarray item'\n            else:\n                assert 0\n            match = item_re.match(line, pos)\n            if not match:\n                raise ReadError(f'{loc_start}: unknown {thing}')\n            pos = match.end()\n            loc_end = TextLocationSingle(self.filename, self.line, pos + 1)\n            loc = loc_start - loc_end\n            if match['ws_error'] is not None:\n                raise ReadError(f'{loc_end}: no whitespace after token')\n            if self.state is State.NORMAL:\n                # Normal state -- read tokens.\n                if match['lparen'] is not None:\n                    self.stack.append(StackEntryList(loc_start, []))\n                elif match['rparen'] is not None:\n                    if not self.stack:\n                        raise ReadError(f'{loc}: unmatched closing paren')\n                    top = self.stack.pop()\n                    if not isinstance(top, StackEntryList):\n                        top.raise_unclosed_error()\n                    yield from self._feed_node(top.items, top.start - loc_end)\n                elif match['symbol'] is not None:\n                    value = Symbol(match['symbol'])\n                    yield from self._feed_node(value, loc)\n                elif match['sexpr_comment'] is not None:\n                    self.stack.append(StackEntryComment(loc))\n                elif match['bool_value'] is not None:\n                    value = match['bool_value'] == '@true'\n                    yield from self._feed_node(value, loc)\n                elif match['nil_value'] is not None:\n                    yield from self._feed_node(None, loc)\n                elif match['int_or_word'] is not None:\n                    if match['number'] is not None:\n                        value = int(match['number'], 0)\n                    elif match['raw_char'] is not None:\n                        value = ord(match['raw_char'])\n                    elif match['simple_escape'] is not None:\n                        value = ord(ESCAPE_TO_CHAR[match['simple_escape']])\n                    elif match['hex_code'] is not None:\n                        value = int(match['hex_code'], 16)\n                        if value not in range(0x110000):\n                            raise ReadError(\n                                    f'{loc}: not a valid unicode codepoint')\n                    else:\n                        assert 0\n                    if match['word_width'] is not None:\n                        width = int(match['word_width'])\n                        if value < 0:\n                            value += 1 << width\n                        if value not in range(1 << width):\n                            raise ReadError(f'{loc}: word value out of range')\n                        value = BinWord(width, value)\n                    yield from self._feed_node(value, loc)\n                elif match['array_width'] is not None:\n                    self.binarray_base = {\n                        '0b': 2,\n                        '0o': 8,\n                        None: 10,\n                        '0x': 16,\n                    }[match['array_base']]\n                    self.binarray_data = []\n                    self.binarray_width = int(match['array_width'])\n                    self.token_start = loc_start\n                    self.state = State.BINARRAY\n                elif match['start_quote'] is not None:\n                    self.state = State.STRING\n                    self.token_start = loc_start\n                    self.string_buffer = StringIO()\n                    if match['string_width'] is not None:\n                        self.binarray_width = int(match['string_width'])\n                    else:\n                        self.binarray_width = None\n            elif self.state is State.STRING:\n                # Inside a string.\n                if match['end_quote'] is not None:\n                    self.state = State.NORMAL\n                    value = self.string_buffer.getvalue()\n                    loc = self.token_start - loc_end\n                    if self.binarray_width is not None:\n                        vals = [ord(x) for x in value]\n                        for x in vals:\n                            if x not in range(1 << self.binarray_width):\n                                raise ReadError(\n                                        f'{loc}: character code out of range')\n                        value = BinArray(vals, width=self.binarray_width)\n                    yield from self._feed_node(value, loc)\n                elif match['raw_chars'] is not None:\n                    self.string_buffer.write(match['raw_chars'])\n                elif match['simple_escape'] is not None:\n                    c = ESCAPE_TO_CHAR[match['simple_escape']]\n                    self.string_buffer.write(c)\n                elif match['hex_code'] is not None:\n                    code = int(match['hex_code'], 16)\n                    if code not in range(0x110000):\n                        raise ReadError(\n                                f'{loc}: not a valid unicode codepoint')\n                    self.string_buffer.write(chr(code))\n                else:\n                    assert 0\n            elif self.state is State.BINARRAY:\n                # In a BinArray.\n                if match['rparen'] is not None:\n                    self.state = State.NORMAL\n                    value = BinArray(self.binarray_data,\n                                     width=self.binarray_width)\n                    loc = self.token_start - loc_end\n                    yield from self._feed_node(value, loc)\n                elif match['digits'] is not None:\n                    value = int(match['digits'], self.binarray_base)\n                    if value < 0:\n                        value += 1 << self.binarray_width\n                    if value not in range(1 << self.binarray_width):\n                        raise ReadError(f'{loc}: word value out of range')\n                    self.binarray_data.append(value)\n            else:\n                assert 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _feed_node(self, value, loc):\n        node = GenericNode(value, loc)\n        if not self.stack:\n            yield node\n        else:\n            top = self.stack[-1]\n            if isinstance(top, StackEntryList):\n                top.items.append(node)\n            elif isinstance(top, StackEntryComment):\n                self.stack.pop()\n            else:\n                assert 0", "response": "A helper method that yields a node from the top - level expressions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring the reader is in clean state.", "response": "def finish(self):\n        \"\"\"Ensures the reader is in clean state (no unclosed S-expression\n        is currently being parsed).  Should be called after the last\n        ``feed_line``.\n        \"\"\"\n        if self.state is not State.NORMAL:\n            raise ReadError(f'EOF while in {self.state.name} state')\n        if self.stack:\n            top = self.stack[-1]\n            top.raise_unclosed_error()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the request parameters and headers for the current user.", "response": "def set_request(self, method=None, sub_url=\"\", data=None, params=None,\n                    proxies=None):\n        \"\"\"\n        :param method: str of the method of the api_call\n        :param sub_url: str of the url after the uri\n        :param data: dict of form data to be sent with the request\n        :param params: dict of additional data to be sent as the request args\n        :param proxies: str of the proxie to use\n        :return: None\n        \"\"\"\n        self.method = method or self.method\n        self.url = self.base_uri and (self.base_uri + sub_url) or sub_url\n        self.params.update(params or {})\n        self.proxies = proxies or self.proxies\n        if self.params:\n            self.url += '?' + '&'.join(\n                ['%s=%s' % (k, v) for k, v in self.params.items()])\n        self.request_data = deepcopy(data)\n        self._timestamps['setup'] = time.time()\n        if isinstance(data, dict) and 'content-type' not in self.headers:\n            self.headers['content-type'] = 'application/json'\n            self.json = data  # don't change this user.post\n        else:\n            self.data = data\n\n        if self.accepted_return is not None:\n            self.headers['Accept'] = \\\n                {'json': 'application/json', 'html': 'text/html'}[\n                    self.accepted_return]\n\n        self._stage = STAGE_SET"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef response_cookies(self):\n        try:\n            ret = {}\n            for cookie_base_uris in self.response.cookies._cookies.values():\n                for cookies in cookie_base_uris.values():\n                    for cookie in cookies.keys():\n                        ret[cookie] = cookies[cookie].value\n            return ret\n        except Exception as e:\n            self.error = ApiError(\n                \"Exception in making Request with:: %s\\n%s\" % (\n                    e_, traceback.format_exc()))\n            raise Exception(self.error)", "response": "This will return all cookies set\nxid"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef duration(self, significant_digits=3):\n        try:\n            return round(\n                self._timestamps['receive'] - self._timestamps['send'],\n                significant_digits)\n        except Exception as e:\n            return None", "response": "Returns the duration of the request and the receive time of the api call"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the time in seconds of how long the data took to stream", "response": "def stream_time(self, significant_digits=3):\n        \"\"\"\n        :param significant_digits: int of the number of significant digits\n            in the return\n        :return: float of the time in seconds of how long the\n             data took to stream\n        \"\"\"\n        try:\n            return round(\n                self._timestamps['last_stream'] - self._timestamps['stream'],\n                significant_digits)\n        except Exception as e:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef latency(self, significant_digits=3):\n        try:\n            end = 'stream' in self._timestamps and 'stream' or 'receive'\n            return round(self._timestamps[end] - self._timestamps['send'],\n                         significant_digits)\n        except Exception as e:\n            return None", "response": "Returns the latency of the current resource in seconds"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send(self, stream_to_file=None):\n        try:\n            self._stage = STAGE_REQUEST\n            self.prepared_request.prepare(method=self.method,\n                                          url=self.endpoint_url,\n                                          files=self.files,\n                                          json=self.json,\n                                          data=self.data,\n                                          headers=self.headers,\n                                          params=self.params,\n                                          cookies=self.cookies,\n                                          hooks=self.hooks)\n\n        except Exception as e1:\n            self.error = ApiError(\n                \"Exception in making Request with:: %s\\n%s\" % (\n                    e1, traceback.format_exc()))\n            raise Exception(self.error)\n\n        try:\n            self._stage = STAGE_SENDING\n            self._timestamps['send'] = time.time()\n            self.response = self.session.send(self.prepared_request,\n                                              proxies=self.proxies,\n                                              timeout=self.timeout,\n                                              stream=bool(stream_to_file),\n                                              verify=VERIFY,\n                                              cert=None)\n            self._stage = STAGE_RESPONDING\n            self._timestamps['receive'] = time.time()\n        except Exception as e2:\n            self._timestamps.setdefault('exception', time.time())\n            self.error = e2\n            raise\n\n        self.post_process(stream_to_file)\n        self._stage = ((self.name == 'Unknown') and\n                       STAGE_DONE_DATA_FORMATTED or STAGE_DONE)\n        return self.data", "response": "This method will perform the http request and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post_process(self, stream_to_file=False):\n        self.status_code = self.response.status_code\n        if 200 <= self.status_code < 300:\n            if stream_to_file:\n                self.stream_to_file(stream_to_file)\n            else:\n                self.extract_data()\n        else:\n            self._timestamps.setdefault('exception', time.time())\n            if self.status_code in HTTP_STATUS_CODES:\n                self.error = HTTP_STATUS_CODES[self.status_code].str_to_obj(\n                    self.response.content)\n            else:\n                self.error = Exception('Status code = %s' % self.status_code)\n            raise self.error", "response": "This method is called when the HTTP response is received."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stream_to_file(self, filename):\n        stream_size = 0\n        try:\n            partial_chunk = ''\n            chunk_size = 1024\n            m3u8_dir = None\n            if filename[-5:].lower() == '.m3u8':\n                self.repeat_needed = True\n                m3u8_dir = self.get_ts_folder(filename)\n\n            self.content_length = self.response.headers.get('Content-Length',\n                                                            None)\n            if not self.content_length:\n                self.content_length = self.response.headers.get(\n                    'x-een-svc-renderer-file-size', None)\n\n            with open(filename, 'a') as fn:\n                stream_size = self.download_chunks(\n                    chunk_size, fn, m3u8_dir, partial_chunk, stream_size)\n        except ZeroReturnError as e:\n            pass\n        except Exception as e:\n            self._timestamps.setdefault('exception', time.time())\n            self.error = ApiError(\n                \"Failed to Stream Data to file:%s\" % filename,\n                status_code=self.status_code,\n                status_description=str(e),\n                url=self.response.url)\n            raise Exception(self.error)\n\n        self.raw_data = self.data = self.filename + ' size = ' + str(\n            self.content_length)\n        self.content_length = self.content_length or stream_size", "response": "Stream the data to the specified file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef download_ts(self, path, chunk, process_last_line=True):\n        import glob\n\n        ret_chunk = []\n        partial_chunk = ''\n        lines = chunk.strip().split('\\n')\n        if not process_last_line:\n            partial_chunk = lines.pop()\n\n        for line in lines:\n            if line.startswith('http:'):\n                ts = '%s/%s.ts' % (path, line.split('.ts?')[0].split('/')[-1])\n                relative_ts = '%s/%s.ts' % (\n                    path.split('/')[-1], line.split('.ts?')[0].split('/')[-1])\n                if not os.path.exists(ts):  # this could be a repeat call\n                    # log.debug(\"Downloading: %s at %s\" % (line, time.time()))\n                    gevent.spawn(ApiCall.save_url_to_file, line, ts).start()\n                    gevent.sleep(0)\n                    ret_chunk.append('# ' + line)\n                    ret_chunk.append(relative_ts)\n                    # log.debug(\"Done Downloading = %s\"%time.time())\n                else:\n                    ret_chunk = []  # start over\n            else:\n                ret_chunk.append(line)\n\n        if '#EXT-X-ENDLIST' in chunk:\n            self.repeat_needed = 0\n            gevent.sleep(0)\n        elif chunk.strip():\n            self.repeat_needed = 1 + len(glob.glob(path + '/*.ts'))\n\n        ret_chunk = ret_chunk and '\\n'.join(ret_chunk) + '\\n' or ''\n        return ret_chunk, partial_chunk", "response": "This function will download the ts file and replace it with the local file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef time_report(self, include_overhead=False, header=None,\n                    include_server=True, digits=4):\n        \"\"\"\n            Returns a str table of the times for this api call\n        :param include_overhead: bool if True include information from\n                                 overhead, such as the time for this class code\n        :param header:           bool if True includes the column header\n        :param include_server:   bool if True includes times reported by the\n                                 server in the header\n        :param digits:           int of the number of significant digits\n        :return:                 str table of the times for the api call\n        \"\"\"\n        try:\n            self._timestamps.setdefault('report', time.time())\n            header = header or ['Message', 'Start', 'End', 'Sum', 'Count']\n\n            ret = []\n            if include_overhead:\n                ret.append(self.time_report_item(\n                    'create', 'Overhead from api call \"Create\"'))\n                ret.append(self.time_report_item(\n                    'setup', 'Overhead from api call \"Setup\"'))\n\n            if 'repeat' in self._timestamps:\n                ret.append(self.time_report_item(\n                    'repeat', 'First Request of the api call'))\n\n            ret.append(self.time_report_item('send', 'Send the api call'))\n\n            if self._server_timing and include_server:\n\n                send_start = ret[-1]['Start']\n                delta = max(0, ret[-1]['Sum'] - (\n                    self._server_timing['End'] - self._server_timing['Start']))\n\n                if include_overhead:\n                    ret.append(\n                        {'Message': \"Internet overhead\", \"Start\": send_start,\n                         \"End\": ret[0]['Start'] + delta, 'Sum': delta,\n                         'Count': 1})\n\n                    if 'Overhead' in self._server_timing:\n                        ret.append({'Message': \"Time profile overhead\",\n                                    \"Start\": send_start + delta,\n                                    'Sum': self._server_timing['Overhead'],\n                                    'End': send_start + delta +\n                                           self._server_timing['End'] -\n                                           self._server_timing['Start'],\n                                    'Count': sum(\n                                        [len(msg.get('Times', [])) for msg in\n                                         self._server_timing[\n                                             'Messages']]) + 1})\n\n                    for msg in self._server_timing['Messages']:\n                        ret.append(msg.copy())\n                        ret[-1]['Start'] = ret[-1].setdefault(\n                            'Start', 0) + delta + send_start\n                        ret[-1]['End'] = ret[-1].setdefault(\n                            'End', ret[-1]['Sum']) + delta + send_start\n                else:\n                    ret += self._server_timing['Messages']\n\n            if 'stream' in self._timestamps:\n                ret.append(\n                    self.time_report_item('stream', 'Streaming the api call'))\n\n            if include_overhead:\n                ret.append(self.time_report_item(\n                    'receive', 'Overhead from api call \"Post Processing\"'))\n\n            return 'Total Time: %s \\t\\tStart Time: %s\\n%s' % (\n                round(self.timedelta.total_seconds(), digits),\n                reformat_date(self._timestamps.get('send', '')),\n                str(ReprListDict(ret, col_names=header,\n                                 digits=digits).list_of_list()))\n        except Exception as ex:\n            return \"Exception creating time report with %s\" % ex.message", "response": "Returns a str table of the times for the API call and the API call."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self, filename=None, clean_data=False, raw=False, trash=False):\n        full_path = get_filename(filename or self.filename or self.name, trash)\n        data = raw and self.raw_data or self.data\n\n        if clean_data:\n            data = self.clean_data(data)\n\n        with open(full_path, 'w') as fn:\n            if filename.endswith('.json'):\n                fn.write(json.dumps(data, indent=2, separators=(',', ': ')))\n            else:\n                fn.write(str(data))\n        self.filename = full_path\n        return full_path", "response": "This will save the data to a file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sub_base_uri(self):\n        return self.base_uri and self.base_uri.split('://')[-1].split('.')[\n            0] or self.base_uri", "response": "This will return the sub_base_uri parsed from the base_uri\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngathering list of futures and coros and return single Task ready to schedule.", "response": "def gather(self, *futures: Union[asyncio.Future, asyncio.coroutine]):\n        \"\"\"Gather list of futures/coros and return single Task ready to schedule.\n\n        :Example:\n\n        Prepare all futures to execution\n\n        .. code-block:: python\n\n            >>> async def do_something():\n            ...     return 'something'\n            ...\n            >>> async def do_something_else():\n            ...     return 'something_else'\n            ...\n\n        Gather all tasks and then pass to context loop\n\n        .. code-block:: python\n\n            >>> loop = Loop(return_exceptions=True)\n            >>> loop.gather(do_something(), do_something_else())\n            >>> with loop as l:\n            ...     result = l.run_until_complete()\n            ...\n\n        :param futures: One or more coroutine or future.\n        :type futures: asyncio.Future, asyncio.coroutine\n        :return: Futures grouped into single future\n        :rtype: asyncio.Task, asyncio.Future\n        \"\"\"\n        self.ft_count = len(futures)\n        self.futures = asyncio.gather(*futures, loop=self.loop,\n                                      return_exceptions=self.return_exceptions)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning loop until all futures are done and return the result.", "response": "def run_until_complete(self):\n        \"\"\"Run loop until all futures are done.\n\n        Schedule futures for execution and wait until all are done.\n        Return value from future, or list of values if multiple\n        futures had been passed to constructor or gather method.\n\n        All results will be in the same order as order of futures passed to constructor.\n\n        :Example:\n\n        .. code-block:: python\n\n            >>> async def slow():\n            ...     await ultra_slow_task()\n            ...     return 'ultra slow'\n            ...\n            >>> async def fast():\n            ...     await the_fastest_task_on_earth()\n            ...\n            >>> with Loop(slow(), fast()) as loop:\n            ...     result = loop.run_until_complete()\n            ...\n            >>> result\n            ['ultra slow', None]\n\n\n        :return: Value from future or list of values.\n        :rtype: None, list, Any\n        \"\"\"\n        try:\n            result = self.loop.run_until_complete(self.futures)\n        except asyncio.futures.CancelledError:\n            return None\n        else:\n            if self.ft_count == 1:\n                return result[0]\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning irregular vertex if irregular edge is found otherwise raises exception", "response": "def get_irregular_vertex(bgedge):\n    \"\"\"\n    This method is called only in irregular edges in current implementation, thus at least one edge will be irregular\n    \"\"\"\n    if not bgedge.is_irregular_edge:\n        raise Exception(\"trying to retrieve an irregular vertex from regular edge\")\n    return bgedge.vertex1 if bgedge.vertex1.is_irregular_vertex else bgedge.vertex2"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_coordinates(cls,   ra=None, dec=None,\n                                distance=None,\n                                pm_ra_cosdec=None, pm_dec=None,\n                                radial_velocity=None,\n                                obstime=2000.0*u.year,\n                                id=None, mag=None,\n                                **kwargs):\n        '''\n        Iniitalize a constellation object.\n\n\n        Parameters\n        ----------\n\n        ra, dec, distance, pm_ra_cosdec, pm_dec, radial_velocity\n            These must be able to initialize a SkyCoord.\n        id : list, array\n            Identifications for the entries.\n        mag : list, array\n            Magnitudes for the entries.\n        **kwargs\n            All arguments and keyword arguments are passed along\n            to SkyCoord. They can be coordinates in the first place,\n            or, for example, ra and dec with units, or any other\n            inputs that can initialize a SkyCoord.\n        '''\n\n        # make sure we can initialzie some coordinates\n        # coordinates = coord.SkyCoord(ra=ra, dec=dec, distance=distance, pm_ra_cosdec=pm_ra_cosdec, pm_dec=pm_dec, radial_velocity=radial_velocity)\n\n\n        N = len(np.atleast_1d(ra))\n        if id is None:\n            id = ['{}'.format(i) for i in range(N)]\n        if mag is None:\n            mag = np.zeros(N)\n        standardized = Table(data=[id, mag], names=['object-id', 'filter-mag'])\n\n        for k in cls.coordinate_keys:\n            if locals()[k] is not None:\n                standardized[k] = locals()[k]\n\n        return cls(standardized)", "response": "Create a new instance of a constantation object from a set of coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting this catalog out to a text file.", "response": "def to_text(self, filename=None, overwrite=True):\n        '''\n        Write this catalog out to a text file.\n        '''\n\n        table = self.standardized\n        #table = hstack([self.identifiers,\n        #                self._coordinate_table(),\n        #                self.magnitudes,\n        #                self.errors])\n\n        if filename == None:\n            filename = '{}.txt'.format(self.name)\n        self.speak('saving to {}'.format(filename))\n        table.write(filename, format='ascii.ecsv', overwrite=overwrite)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a constellation from a text file.", "response": "def from_text(cls, filename, **kwargs):\n        '''\n        Create a constellation by reading a catalog in from a text file,\n        as long as it's formated as in to_text() with identifiers, coordinates, magnitudes.\n\n        Parameters\n        ----------\n        filename : str\n            The filename to read in.\n\n        **kwargs are passed to astropy.io.ascii.read()\n        '''\n\n        # FIXME -- add something here to parse id, mag, errors from the table?\n\n        # load the table\n        t = ascii.read(filename, **kwargs)\n\n        '''\n        # which columns is the coordinates?\n        i_coordinates = t.colnames.index('ra')\n\n        # everything before the coordinates is an identifier\n        identifiers = Table(t.columns[:i_coordinates])\n\n        # the complete coordinates are stored in one\n        c = t.columns[i_coordinates:i_coordinates+6]\n        coordinates = coord.SkyCoord(**c)\n        coordinates.obstime=Time(cls.epoch, format='decimalyear')\n\n        # everything after coordinates is magnitudes\n        magnitudes = Table(t.columns[i_coordinates+1:])\n\n        newtable = hstack([Table(identifiers),\n                           Table({'coordinates':coordinates}),\n                           Table(magnitudes)])\n        '''\n        this = cls(t)\n        this.speak('loaded constellation from {}'.format(filename))\n\n        return this"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef atEpoch(self, epoch=2000):\n        '''\n        Return SkyCoords of the objects, propagated to a (single) given epoch.\n\n        Parameters\n        ----------\n        epoch : Time, or float\n            Either an astropy time, or a decimal year of the desired epoch.\n\n        Returns\n        -------\n        coordinates : SkyCoord(s)\n            The coordinates, propagated to the given epoch,\n            with that epoch stored in the obstime attribute.\n        '''\n\n        projected = copy.deepcopy(self.standardized)\n\n        # calculate the time offset from the epochs of the orignal coordinates\n        try:\n            epoch.year\n            newobstime = epoch\n        except AttributeError:\n            try:\n                newobstime = epoch.decimalyear*u.year\n            except AttributeError:\n                newobstime = epoch*u.year\n\n        #with warnings.catch_warnings() :\n        #    warnings.filterwarnings(\"ignore\")\n        #    newobstime = Time(year, format='decimalyear')\n        #    dt = newobstime - self.obstime\n        dt = newobstime - self.obstime\n\n        # calculate the new positions, propagated linearly by dt\n        try:\n            # if proper motions exist\n            newra = (self.ra + self.pm_ra_cosdec/np.cos(self.dec)*dt).to(u.deg)\n            newdec = (self.dec + self.pm_dec*dt).to(u.deg)\n        except TypeError:\n            # assume no proper motions, if they're not defined\n            newra = self.ra\n            newdec = self.dec\n            self.speak('no proper motions were used for {}'.format(self.name))\n\n        projected['ra'] = newra\n        projected['dec'] = newdec\n        projected['obstime'] = newobstime\n\n        # return as SkyCoord object\n        return self.__class__(projected)", "response": "Return a new object with the coordinates propagated to the given epoch."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot(self, sizescale=10, color=None, alpha=0.5, label=None, edgecolor='none', **kw):\n        '''\n        Plot the ra and dec of the coordinates,\n        at a given epoch, scaled by their magnitude.\n\n        (This does *not* create a new empty figure.)\n\n        Parameters\n        ----------\n        sizescale : (optional) float\n            The marker size for scatter for a star at the magnitudelimit.\n        color : (optional) any valid color\n            The color to plot (but there is a default for this catalog.)\n        **kw : dict\n            Additional keywords will be passed on to plt.scatter.\n\n        Returns\n        -------\n\n        plotted : outputs from the plots\n        '''\n        # calculate the sizes of the stars (logarithmic with brightness?)\n        size = np.maximum(sizescale*(1 + self.magnitudelimit - self.magnitude), 1)\n\n        # make a scatter plot of the RA + Dec\n        scatter = plt.scatter(self.ra, self.dec,\n                                    s=size,\n                                    color=color or self.color,\n                                    label=label or '{} ({:.1f})'.format(self.name, self.epoch),\n                                    alpha=alpha,\n                                    edgecolor=edgecolor,\n                                    **kw)\n\n        return scatter", "response": "Plot the RA + Dec of the coordinates of the object at a given epoch."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nplotting a finder chart. This does * not * create a new figure.", "response": "def finder(self, figsize=(7,7), **kwargs):\n        '''\n        Plot a finder chart. This *does* create a new figure.\n        '''\n\n        try:\n            center = self.meta['center']\n            radius = self.meta['radius']\n        except KeyError:\n            return self.allskyfinder(**kwargs)\n\n        plt.figure(figsize=figsize)\n        scatter = self.plot(**kwargs)\n        plt.xlabel(r'Right Ascension ($^\\circ$)'); plt.ylabel(r'Declination ($^\\circ$)')\n        #plt.title('{} in {:.1f}'.format(self.name, epoch))\n        r = radius.to('deg').value\n        plt.xlim(center.ra.deg + r/np.cos(center.dec), center.ra.deg - r/np.cos(center.dec))\n        plt.ylim(center.dec.deg - r, center.dec.deg + r)\n        ax = plt.gca()\n        ax.set_aspect(1.0/np.cos(center.dec))\n\n        return scatter"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots an all - sky finder chart. This does * not * create a new figure.", "response": "def allskyfinder(self, figsize=(14, 7), **kwargs):\n        '''\n        Plot an all-sky finder chart. This *does* create a new figure.\n        '''\n\n        plt.figure(figsize=figsize)\n        scatter = self.plot(**kwargs)\n        plt.xlabel(r'Right Ascension ($^\\circ$)'); plt.ylabel(r'Declination ($^\\circ$)')\n        #plt.title('{} in {:.1f}'.format(self.name, epoch))\n        plt.xlim(0, 360)\n        plt.ylim(-90,90)\n        return scatter"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef animate(self, filename='constellation.mp4', epochs=[1900,2100], dt=5, dpi=300, fps=10, **kw):\n        '''\n        Animate a finder chart.\n        '''\n\n        scatter = self.finder(**kw)\n        plt.tight_layout()\n        figure = plt.gcf()\n\n        if '.gif' in filename:\n            try:\n                writer = ani.writers['pillow'](fps=fps)\n            except (RuntimeError, KeyError):\n                writer = ani.writers['imagemagick'](fps=fps)\n            except:\n                raise RuntimeError('This python seems unable to make an animated gif.')\n        else:\n            try:\n                writer = ani.writers['ffmpeg'](fps=fps)\n            except (RuntimeError,KeyError):\n                raise RuntimeError('This computer seems unable to ffmpeg.')\n\n\n        with writer.saving(figure, filename, dpi or figure.get_dpi()):\n            for epoch in tqdm(np.arange(epochs[0], epochs[1]+dt, dt)):\n\n                # update the illustration to a new time\n                coords = self.atEpoch(epoch)\n                scatter.set_offsets(list(zip(coords.ra.value, coords.dec.value)))\n                plt.title('{} in {:.1f}'.format(self.name, epoch))\n\n                writer.grab_frame()", "response": "Animate a single illustration."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crossMatchTo(self, reference, radius=1*u.arcsec, visualize=False):\n        '''\n        Cross-match this catalog onto another reference catalog.\n        If proper motions are included in the reference, then\n        its coordinates will be propagated to the obstime/epoch\n        of this current catalog.\n\n        Parameters\n        ----------\n\n        reference : Constellation\n            A reference Constellation to which we want to\n            cross-match the stars in this catalog. Most likely,\n            you'll want to use Gaia for this (since it has\n            good astrometry and good proper motions).\n\n        radius : float, with astropy units of angle\n            How close to objects need to be in the cross-match\n            for them to be considered a matched pair?\n\n        Returns\n        -------\n\n        i_this : array of indices\n            The elements of this catalog that are matched.\n\n        i_ref : array of indices\n            The elements of the reference catalog, corresponding to\n        '''\n\n        # find the closest match for each of star in this constellation\n        i_ref, d2d_ref, d3d_ref = self.coordinates.match_to_catalog_sky(reference.atEpoch(self.coordinates.obstime))\n\n        # extract only those within the specified radius\n        ok = d2d_ref < radius\n        self.speak('found {} matches within {}'.format(np.sum(ok), radius))\n\n        # make a plot, if desired\n        if visualize:\n            self.speak('p')\n            plt.hist(d2d_ref.arcsec, range=(0,15))\n            plt.axvline(radius.arcsec)\n            plt.xlabel('Separation (arcsec)')\n            plt.ylabel('Number of Matched Sources')\n\n        # return the indices (of this, and of the reference) for the matches\n        return ok, i_ref[ok]", "response": "Cross - match this catalog onto another reference catalog."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_gitdir(self):\n        if self.gitlookup is None:\n            raise tornado.web.HTTPError(500, 'no git lookup configured')\n\n        gitdir = self.gitlookup(self.request)\n        if gitdir is None:\n            raise tornado.web.HTTPError(404, 'unable to find repository')\n        logger.debug(\"Accessing git at: %s\", gitdir)\n\n        return gitdir", "response": "Determine the git repository for this request"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks authentication and authorization of client", "response": "def check_auth(self):\n        \"\"\"Check authentication/authorization of client\"\"\"\n        # access permissions\n        if self.auth is not None:\n            return self.auth(self.request)\n\n        return self.public_readble, self.public_writable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate endtags to elements which looks like openers but doesn t have proper. endtag is set to the last element in childs.", "response": "def _closeElements(childs, HTMLElement):\n    \"\"\"\n    Create `endtags` to elements which looks like openers, but doesn't have\n    proper :attr:`HTMLElement.endtag`.\n\n    Args:\n        childs (list): List of childs (:class:`HTMLElement` obj) - typically\n               from :attr:`HTMLElement.childs` property.\n\n    Returns:\n        list: List of closed elements.\n    \"\"\"\n    out = []\n\n    # close all unclosed pair tags\n    for e in childs:\n        if not e.isTag():\n            out.append(e)\n            continue\n\n        if not e.isNonPairTag() and not e.isEndTag() and not e.isComment() \\\n           and e.endtag is None:\n            e.childs = _closeElements(e.childs, HTMLElement)\n\n            out.append(e)\n            out.append(HTMLElement(\"</\" + e.getTagName() + \">\"))\n\n            # join opener and endtag\n            e.endtag = out[-1]\n            out[-1].openertag = e\n        else:\n            out.append(e)\n\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the last data point from one device for a given period till now.", "response": "def get_last_data(self, uuid, period=0, average_by=0):\n        \"\"\"\n        Get the data from one device for period till now.\n\n        :param uuid: Id of the device\n        :type uuid: str\n        :param period: Number of seconds between start time of search and now\n        :type period: integer\n        :param average_by: amount of seconds to average data over.\n            0 or 300 for no average. Use 3600 (average hourly) or a multiple for\n            long range requests (e.g. more than 1 day)\n        :type average_by: integer\n        :returns: list of datapoints\n        :raises: ClientError, AuthFailure, BadFormat, ForbiddenAccess,\n                 TooManyRequests, InternalError\n\n        .. note::\n            Use period = 0 and averageBy = 0 to get the very last data point.\n            If you only need one average for a period, the average_by needs to\n            be bigger than the period (eg, for a 10 minutes average: period = 600,\n            average_by = 601)\n\n        .. seealso:: :func:`parse_data` for return data syntax\n        \"\"\"\n        return self.parse_data((yield from self._get(\n            LAST_DATA_URL.format(uuid= uuid,\n                period= trunc(period),\n                average_by= trunc(average_by)))))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the historical data from one device for a specified time range.", "response": "def get_historical_data(self, uuid, start, end, average_by=0):\n        \"\"\"\n        Get the data from one device for a specified time range.\n\n        .. note::\n            Can fetch a maximum of 42 days of data.\n            To speed up query processing, you can use a combination of average factor\n            multiple of 1H in seconds (e.g. 3600), and o'clock start and end times\n\n        :param uuid: Id of the device\n        :type uuid: str\n        :param start: start of the range\n        :type start: datetime\n        :param end: end of the range\n        :type end: datetime\n        :param average_by: amount of seconds to average data over.\n            0 or 300 for no average. Use 3600 (average hourly) or a multiple for\n            long range requests (e.g. more than 1 day)\n        :type average_by: integer\n        :returns: list of datapoints\n        :raises: ClientError, AuthFailure, BadFormat, ForbiddenAccess,\n                 TooManyRequests, InternalError\n\n        .. seealso:: :func:`parse_data` for return data syntax\n        \"\"\"\n        return self.parse_data((yield from self._get(\n            HISTORICAL_DATA_URL.format(uuid= uuid,\n                start = trunc(start.replace(tzinfo=timezone.utc).timestamp()),\n                end = trunc(end.replace(tzinfo=timezone.utc).timestamp()),\n                average_by= trunc(average_by)))))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting the weird list format used for datapoints to a more usable one", "response": "def parse_data(self, response):\n        \"\"\"\n        Convert the weird list format used for datapoints to a more usable\n        dictionnary one \n\n        :param response: dictionnary from API json response\n        :type response: dict\n        :returns: list of datapoints\n\n        .. note::\n            Datapoint content:\n                * time: UTC timestamp, unit: seconds\n                * pm: Particulate Matter, unit: ugm3\n                * tmp: temperature, unit: C\n                * hum: humidity, unit: %\n                * co2: Carbon Dioxide, unit: ppm\n                * voc: Volatile Organic Compounds, unit: ppb\n                * allpollu: `foobot index <https://help.foobot.io/hc/en-us/articles/204814371-What-does-central-number-mean->`_, unit: %\n        \"\"\"\n        parsed = []\n        try:\n            items = response['sensors']\n            for datapoint in response['datapoints']:\n                line = {}\n                for index, data in enumerate(datapoint):\n                    line[items[index]] = data\n                parsed.append(line)\n            return parsed\n        except (KeyError, IndexError, TypeError):\n            raise FoobotClient.InvalidData()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a metaclass configured to use this registry.", "response": "def metaclass(self):\n        \"\"\"Get a metaclass configured to use this registry.\"\"\"\n        if '_metaclass' not in self.__dict__:\n            self._metaclass = type('PermissionsMeta', (PermissionsMeta,), {'registry': self})\n        return self._metaclass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nregister permission function & return the original function.", "response": "def register(self, perm_func=None, model=None, allow_staff=None, allow_superuser=None,\n                 allow_anonymous=None, unauthenticated_handler=None, request_types=None, name=None,\n                 replace=False, _return_entry=False):\n        \"\"\"Register permission function & return the original function.\n\n        This is typically used as a decorator::\n\n            permissions = PermissionsRegistry()\n            @permissions.register\n            def can_do_something(user):\n                ...\n\n        For internal use only: you can pass ``_return_entry=True`` to\n        have the registry :class:`.Entry` returned instead of\n        ``perm_func``.\n\n        \"\"\"\n        allow_staff = _default(allow_staff, self._allow_staff)\n        allow_superuser = _default(allow_superuser, self._allow_superuser)\n        allow_anonymous = _default(allow_anonymous, self._allow_anonymous)\n        unauthenticated_handler = _default(unauthenticated_handler, self._unauthenticated_handler)\n        request_types = _default(request_types, self._request_types)\n\n        if perm_func is None:\n            return (\n                lambda perm_func_:\n                    self.register(\n                        perm_func_, model, allow_staff, allow_superuser, allow_anonymous,\n                        unauthenticated_handler, request_types, name, replace, _return_entry)\n            )\n\n        name = _default(name, perm_func.__name__)\n        if name == 'register':\n            raise PermissionsError('register cannot be used as a permission name')\n        elif name in self._registry and not replace:\n            raise DuplicatePermissionError(name)\n\n        view_decorator = self._make_view_decorator(\n            name, perm_func, model, allow_staff, allow_superuser, allow_anonymous,\n            unauthenticated_handler, request_types)\n        entry = Entry(\n            name, perm_func, view_decorator, model, allow_staff, allow_superuser, allow_anonymous,\n            unauthenticated_handler, request_types, set())\n        self._registry[name] = entry\n\n        @wraps(perm_func)\n        def wrapped_func(user, instance=NO_VALUE):\n            if user is None:\n                return False\n            if not allow_anonymous and user.is_anonymous():\n                return False\n            test = lambda: perm_func(user) if instance is NO_VALUE else perm_func(user, instance)\n            return (\n                allow_staff and user.is_staff or\n                allow_superuser and user.is_superuser or\n                test()\n            )\n\n        register.filter(name, wrapped_func)\n\n        log.debug('Registered permission: {0}'.format(name))\n        return entry if _return_entry else wrapped_func"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef require(self, perm_name, **kwargs):\n        view_decorator = self._get_entry(perm_name).view_decorator\n        return view_decorator(**kwargs) if kwargs else view_decorator", "response": "Use as a decorator on a view to require a permission that is granted for a specific object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef entry_for_view(self, view, perm_name):\n        view_name = self._get_view_name(view)\n        entry = self._get_entry(perm_name)\n        if view_name in entry.views:\n            return entry\n        return None", "response": "Get the registry entry for the given view and permission."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nresolving importer from TRACK_IMPORTER_CLASS setting.", "response": "def get_importer(self):\n        \"\"\"\n        Resolve importer from TRACK_IMPORTER_CLASS setting.\n        \"\"\"\n        try:\n            importer_path = settings.TRACK_IMPORTER_CLASS\n        except AttributeError:\n            raise ImproperlyConfigured('No TRACK_IMPORTER_CLASS setting found.')\n        try:\n            dot = importer_path.rindex('.')\n        except ValueError:\n            raise ImproperlyConfigured('%s isn\\'t a Track Importer module.' % importer_path)\n        module, classname = importer_path[:dot], importer_path[dot+1:]\n        try:\n            mod = import_module(module)\n        except ImportError, e:\n            raise ImproperlyConfigured('Could not import Track Importer %s: \"%s\".' % (module, e))\n        try:\n            importer_class = getattr(mod, classname)\n        except AttributeError:\n            raise ImproperlyConfigured('Track Importer module \"%s\" does not define a \"%s\" class.' % (module, classname))\n   \n        importer_instance = importer_class()\n        if not hasattr(importer_instance, 'run'):\n            raise ImproperlyConfigured('Track Importer class \"%s\" does not define a run method. Implement the method to return a list of Track objects.' % classname)\n        \n        return importer_instance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlooking up Django Track object for provided raw importing track object.", "response": "def lookup_track(self, track):\n        \"\"\"\n        Looks up Django Track object for provided raw importing track object.\n        \"\"\"\n        tracks = Track.objects.filter(title__iexact=track.title)\n        for track_obj in tracks:\n            for contributor in track_obj.get_primary_contributors(permitted=False):\n                if contributor.title == track.artist:\n                    return track_obj\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmatching a value to a type of a value.", "response": "def match_value(expected_type, actual_value):\n        \"\"\"\n        Matches expected type to a type of a value.\n        The expected type can be specified by a type, type name or [[TypeCode]].\n\n        :param expected_type: an expected type to match.\n\n        :param actual_value: a value to match its type to the expected one.\n\n        :return: true if types are matching and false if they don't.\n        \"\"\"\n        if expected_type == None:\n            return True\n        if actual_value == None:\n            raise Exception(\"Actual value cannot be null\")\n\n        return TypeMatcher.match_type(expected_type, type(actual_value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmatches an expected type to an actual type.", "response": "def match_type(expected_type, actual_type):\n        \"\"\"\n        Matches expected type to an actual type.\n        The types can be specified as types, type names or [[TypeCode]].\n\n        :param expected_type: an expected type to match.\n\n        :param actual_type: an actual type to match.\n\n        :return: true if types are matching and false if they don't.\n        \"\"\"\n        if expected_type == None:\n            return True\n        if actual_type == None:\n            raise Exception(\"Actual type cannot be null\")\n\n        if isinstance(expected_type, type):\n            return issubclass(actual_type, expected_type)\n        \n        if isinstance(expected_type, str):\n            return TypeMatcher.match_type_by_name(expected_type, actual_type)\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmatch expected type to a value of a type.", "response": "def match_value_by_name(expected_type, actual_value):\n        \"\"\"\n        Matches expected type to a type of a value.\n\n        :param expected_type: an expected type name to match.\n\n        :param actual_value: a value to match its type to the expected one.\n\n        :return: true if types are matching and false if they don't.\n        \"\"\"\n        if expected_type == None:\n            return True\n        if actual_value == None:\n            raise Exception(\"Actual value cannot be null\")\n\n        return TypeMatcher.match_type_by_name(expected_type, type(actual_value))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match_type_by_name(expected_type, actual_type):\n        if expected_type == None:\n            return True\n        if actual_type == None:\n            raise Exception(\"Actual type cannot be null\")\n        \n        expected_type = expected_type.lower()\n\n        if actual_type.__name__.lower() == expected_type: \n            return True\n        elif expected_type == \"object\":\n            return True\n        elif expected_type == \"int\" or expected_type == \"integer\":\n            return issubclass(actual_type, int) #or issubclass(actual_type, long)\n        elif expected_type == \"long\":\n            return issubclass(actual_type, int)\n        elif expected_type == \"float\" or expected_type == \"double\":\n            return issubclass(actual_type, float)\n        elif expected_type == \"string\":\n            return issubclass(actual_type, str) #or issubclass(actual_type, unicode)\n        elif expected_type == \"bool\" or expected_type == \"boolean\":\n            return issubclass(actual_type, bool)\n        elif expected_type == \"date\" or expected_type == \"datetime\":\n            return issubclass(actual_type, datetime.datetime) or issubclass(actual_type. datetime.date)\n        elif expected_type == \"timespan\" or expected_type == \"duration\":\n            return issubclass(actual_type, int) or issubclass(actual_type, float)\n        elif expected_type == \"enum\":\n            return issubclass(actual_type, str) or issubclass(actual_type, int)\n        elif expected_type == \"map\" or expected_type == \"dict\" or expected_type == \"dictionary\":\n            return issubclass(actual_type, dict)\n        elif expected_type == \"array\" or expected_type == \"list\":\n            return issubclass(actual_type, list) or issubclass(actual_type, tuple) or issubclass(actual_type, set)\n        elif expected_type.endswith(\"[]\"):\n            # Todo: Check subtype\n            return issubclass(actual_type, list) or issubclass(actual_type, tuple) or issubclass(actual_type, set)\n        else:\n            return False", "response": "Matches an expected type to an actual type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef blob(self, request, pk=None):\n        obj = self.get_object_or_none()\n        if obj:\n            blob = obj.get_blob_data()\n            content_type = 'octet/stream'\n            response = HttpResponse(blob, content_type=content_type,\n                                    status=status.HTTP_200_OK)\n            response['Content-Disposition'] = (\n                'attachment; filename=\"%s\"' % obj.name\n            )\n            return response\n        return HttpResponse('404', status=status.HTTP_404_NOT_FOUND,\n                            content_type='application/json')", "response": "fetch large object from pg and gives it back to user via HTTP 1. 1\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_github(self):\n        from github import Github\n        vms(\"Querying github with user '{}'.\".format(self.username))\n        g = Github(self.username, self.apikey)\n        self._user = g.get_user()\n        if self._user is None:\n            raise ValueError(\"Can't authenticate to github with '{}'.\".format(self.username))\n        #The github user authenticating always has to be specified; however the user\n        #may not be able to see the repo, even if it has access to it. We may need\n        #to check the organization repos.\n        if self.organization is not None:\n            self._org = g.get_organization(self.organization)\n            vms(\"Found github organization '{}'.\".format(self._org.name), 2)\n\n            #Next we need to find this repository in the lists available to both\n            #the user *and* the organization. If they specified an organization, then we\n            #should check that first/exclusively.\n            for repo in self._org.get_repos():\n                if repo.full_name.lower() == self.name.lower():\n                    self._repo = repo\n                    vms(\"Found organization repository '{}'.\".format(self._repo.full_name), 2)\n                    break\n        else:\n            for repo in self._user.get_repos():\n                if repo.full_name.lower() == self.name.lower():\n                    self._repo = repo\n                    vms(\"Found user repository '{}'.\".format(self._repo.full_name), 2)\n                    break", "response": "Creates an instance of github. Github to interact with the repos via the \n        API interface in pygithub."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a repository tag to update the instance attributes.", "response": "def _parse_repo(self, xml):\n        \"\"\"Parses a <repo> tag to update settings on this Repository instance.\n        \n        :arg xml: the <repo> tag XMLElement.\n        \"\"\"\n        self.name = get_attrib(xml, \"name\", \"repo\")\n        self.username = get_attrib(xml, \"user\", \"repo\")\n        self.apikey = get_attrib(xml, \"apikey\", \"repo\")\n        self.organization = get_attrib(xml, \"organization\")\n        self.staging = get_attrib(xml, \"staging\", \"repo\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting the XML settings into class instances that can operate on the testing functions.", "response": "def _parse_xml(self):\n        \"\"\"Extracts the XML settings into class instances that can operate on\n        the settings to perform the testing functions.\n        \"\"\"\n        import xml.etree.ElementTree as ET\n        from os import path\n        #This dict has the keys of XML tags that are required in order for the\n        #CI server to run the repo. When each one is parsed, we change its value\n        #to True and then check that they are all true at the end.\n        required = {\"testing\": False, \"wiki\": False}\n        #Make sure the file exists and then import it as XML and read the values out.\n        if path.isfile(self.filepath):\n            tree = ET.parse(self.filepath)\n            vms(\"Parsing XML tree from {}.\".format(self.filepath), 2)\n            root = tree.getroot()\n            if root.tag != \"cirepo\":\n                raise ValueError(\"The root tag in a continuous integration settings XML \"\n                                 \"file should be a <cirepo> tag.\")\n\n            self._parse_repo(root)\n            for child in root:\n                if child.tag == \"cron\":\n                    if self.server is not None:\n                        self.server.cron.settings[self.name] = CronSettings(child)\n                if child.tag == \"testing\":\n                    self.testing = TestingSettings(child)\n                if child.tag == \"static\":\n                    self.static = StaticSettings(child)\n                if child.tag == \"wiki\":\n                    self.wiki[\"user\"] = get_attrib(child, \"user\", \"wiki\")\n                    self.wiki[\"password\"] = get_attrib(child, \"password\", \"wiki\")\n                    self.wiki[\"basepage\"] = get_attrib(child, \"basepage\", \"wiki\")\n                if child.tag in required:\n                    required[child.tag] = True\n\n            if not all(required.values()):\n                tags = ', '.join([\"<{}>\".format(t) for t in required])\n                raise ValueError(\"{} are required tags in the repo's XML settings file.\".format(tags))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_xml(self, xml):\n        from re import split\n        vms(\"Parsing <cron> XML child tag.\", 2)\n        self.frequency = get_attrib(xml, \"frequency\", default=5, cast=int)\n        self.emails = split(\",\\s*\", get_attrib(xml, \"emails\", default=\"\"))\n        self.notify = split(\",\\s*\", get_attrib(xml, \"notify\", default=\"\"))", "response": "Extracts the attributes from the XMLElement instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_xml(self, xml):\n        vms(\"Parsing <static> XML child tag.\", 2)\n        for child in xml:\n            if \"path\" in child.attrib and \"target\" in child.attrib:\n                if child.tag == \"file\":\n                    self.files.append({\"source\": child.attrib[\"path\"],\n                                       \"target\": child.attrib[\"target\"]})\n                elif child.tag == \"folder\":\n                    self.folders.append({\"source\": child.attrib[\"path\"],\n                                         \"target\": child.attrib[\"target\"]})", "response": "Extracts objects representing and interacting with the settings in the\n xml tag."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies the static files and folders specified in these settings into the locally - cloned repository directory.", "response": "def copy(self, repodir):\n        \"\"\"Copies the static files and folders specified in these settings into the\n        locally-cloned repository directory.\n\n        :arg repodir: the full path to the directory with the locally-cloned version\n          of the pull request being unit tested.\n        \"\"\"\n        #Instead of using the built-in shell copy, we make shell calls to rsync.\n        #This allows us to copy only changes across between runs of pull-requests.\n        from os import system, path\n        vms(\"Running static file copy locally.\", 2)\n        for file in self.files:\n            fullpath = path.expanduser(file[\"source\"])\n            if path.isfile(fullpath):\n                vms(\"Running 'rsync' for {}.\".format(fullpath), 3)\n                system(\"rsync -t -u {} {}\".format(fullpath, get_repo_relpath(repodir, file[\"target\"])))\n\n        for folder in self.folders:\n            fullpath = path.expanduser(folder[\"source\"])\n            if path.isdir(fullpath):\n                vms(\"Running 'rsync' for {}.\".format(fullpath), 3)\n                system(\"rsync -t -u -r {} {}\".format(path.join(fullpath, \"\"),\n                                                     path.join(get_repo_relpath(repodir, folder[\"target\"]), \"\")))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef serial(self):\n        serial = self.property_get(\"SERIAL\", False)\n        if isinstance(serial, str):\n            return serial.lower() == \"true\"\n        else:\n            return serial", "response": "Returns true if the CI server should run in serial mode."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreplacing all instances of @VAR with their values in the specified text.", "response": "def var_replace(self, text):\n        \"\"\"Replaces all instances of @VAR with their values in the specified text.\n        \"\"\"\n        result = text\n        for var in self._vardict:\n            result = result.replace(\"@{}\".format(var), self._vardict[var])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the values of the configuration variables from an XML file path.", "response": "def load_xml(self, filepath):\n        \"\"\"Loads the values of the configuration variables from an XML path.\"\"\"\n        from os import path\n        import xml.etree.ElementTree as ET\n        #Make sure the file exists and then import it as XML and read the values out.\n        uxpath = path.expanduser(filepath)\n        if path.isfile(uxpath):\n            tree = ET.parse(uxpath)\n            vms(\"Parsing global settings from {}.\".format(uxpath))\n            root = tree.getroot()\n\n            for child in root:\n                if child.tag == \"var\":\n                    self._vardict[child.attrib[\"name\"]] = child.attrib[\"value\"]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a restricted cover function that takes and yields values from l.", "response": "def restricted_cover(l, succsOf):\n    \"\"\" Returns a restricted <succsOf> which only takes and yields\n        values from <l> \"\"\"\n    fzl = frozenset(l)\n    lut = dict()\n    for i in l:\n        lut[i] = fzl.intersection(succsOf(i))\n    return lambda x: lut[x]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dual_cover(l, succsOf):\n    lut = dict()\n    for i in l:\n        lut[i] = list()\n    for i in l:\n        for j in succsOf(i):\n            lut[j].append(i)\n    return lambda x: lut[x]", "response": "This function returns the dual cover function for a list of successors."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sort_by_successors(l, succsOf):\n    rlut = dict()\n    nret = 0\n    todo = list()\n    for i in l:\n        rlut[i] = set()\n    for i in l:\n        for j in succsOf(i):\n            rlut[j].add(i)\n    for i in l:\n        if len(rlut[i]) == 0:\n            todo.append(i)\n    while len(todo) > 0:\n        i = todo.pop()\n        nret += 1\n        yield i\n        for j in succsOf(i):\n            rlut[j].remove(i)\n            if len(rlut[j]) == 0:\n                todo.append(j)\n    if nret != len(l):\n        raise ValueError(\"Cycle detected\")", "response": "Sorts a list by the list of successors of a given list of ones."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_or_create_iobject(identifier_uid,\n                          identifier_namespace_uri,\n                          iobject_type_name,\n                          iobject_type_namespace_uri,\n                          iobject_type_revision_name,\n                          iobject_family_name,\n                          iobject_family_revision_name=\"\",\n                          identifier_namespace_name=\"\",\n                          timestamp=None,\n                          create_timestamp=None,\n                          overwrite=False,\n                          dingos_class_map=dingos_class_map):\n    \"\"\"\n    Get or create an information object.\n    \"\"\"\n\n    # create or retrieve the iobject type and revision\n\n    # create or retrieve identifier\n\n    if not timestamp:\n        raise StandardError(\"You must supply a timestamp.\")\n\n    id_namespace, created = dingos_class_map['IdentifierNameSpace'].objects.get_or_create(uri=identifier_namespace_uri)\n\n    if created and identifier_namespace_name:\n        id_namespace.name = identifier_namespace_name\n        id_namespace.save()\n\n    identifier, created = dingos_class_map['Identifier'].objects.get_or_create(uid=identifier_uid,\n                                                                              namespace=id_namespace,\n                                                                              defaults={'latest': None})\n\n    iobject_type_namespace, created = dingos_class_map['DataTypeNameSpace'].objects.get_or_create(uri=iobject_type_namespace_uri)\n\n    iobject_family, created = dingos_class_map['InfoObjectFamily'].objects.get_or_create(name=iobject_family_name)\n    iobject_family_revision, created = dingos_class_map['Revision'].objects.get_or_create(\n        name=iobject_family_revision_name)\n\n    # create or retrieve the iobject type\n    iobject_type, created = dingos_class_map['InfoObjectType'].objects.get_or_create(name=iobject_type_name,\n                                                                                    iobject_family=iobject_family,\n                                                                                    namespace=iobject_type_namespace)\n    iobject_type_revision, created = dingos_class_map['Revision'].objects.get_or_create(name=iobject_type_revision_name)\n\n    if not create_timestamp:\n        create_timestamp = timezone.now()\n    #if not timestamp:\n    #    timestamp = create_timestamp\n    #    iobject = overwrite\n    #    created = False\n\n\n\n    iobject, created = dingos_class_map[\"InfoObject\"].objects.get_or_create(identifier=identifier,\n                                                                           timestamp=timestamp,\n                                                                           defaults={'iobject_family': iobject_family,\n                                                                                     'iobject_family_revision': iobject_family_revision,\n                                                                                     'iobject_type': iobject_type,\n                                                                                     'iobject_type_revision': iobject_type_revision,\n                                                                                     'create_timestamp': create_timestamp})\n    if created:\n        iobject.set_name()\n        iobject.save()\n        identifier.latest = iobject\n        identifier.save()\n\n\n    elif overwrite:\n        iobject.timestamp = timestamp\n        iobject.create_timestamp = create_timestamp\n        iobject.iobject_family = iobject_family\n        iobject.iobject_family_revision = iobject_family_revision\n        iobject.iobject_type = iobject_type\n        iobject.iobject_type_revision = iobject_type_revision\n        iobject.set_name()\n        iobject.save()\n\n    logger.debug(\n        \"Created iobject id with %s , ts %s (created was %s) and overwrite as %s\" % (iobject.identifier, timestamp, created, overwrite))\n    return iobject, created", "response": "Get or create an information object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting or create a fact object.", "response": "def get_or_create_fact(fact_term,\n                       fact_dt_name='String',\n                       fact_dt_namespace_uri=DINGOS_NAMESPACE_URI,\n                       values=None,\n                       value_iobject_id=None,\n                       value_iobject_ts=None,\n                       ):\n    \"\"\"\n    Get or create a fact object.\n    \"\"\"\n\n    if not values:\n        values = []\n\n\n    vocab_namespace, created = dingos_class_map['DataTypeNameSpace'].objects.get_or_create(uri=fact_dt_namespace_uri)\n\n    fact_data_type, created = dingos_class_map['FactDataType'].objects.get_or_create(name=fact_dt_name,\n                                                                                    namespace=vocab_namespace)\n\n    # Maybe we already have a fact with exactly the same fact term and the same fact values?\n    # We start by looking at the number of values\n\n    value_objects = []\n\n    for value in values:\n        storage_location=dingos.DINGOS_VALUES_TABLE\n        # collect (create or get) the required value objects\n        if value == None:\n            value = ''\n        if isinstance(value,tuple):\n            # If a value is wrapped in a tuple, the second component of the tuple\n            # specifies the storage location of the value.\n            value, storage_location = value\n\n        if storage_location == dingos.DINGOS_VALUES_TABLE:\n            # If the value is larger than a given size, the value is written to disk, instead.\n            # We use this to keep too large values out of the database. Depending on how the\n            # database is set up, this may be necessary to allow indexing, which in turn is\n            # required to check uniqueness on values.\n\n            if len(value) > dingos.DINGOS_MAX_VALUE_SIZE_WRITTEN_TO_VALUE_TABLE:\n                (value_hash,storage_location) = write_large_value(value)\n                value = value_hash\n\n\n        fact_value, created = dingos_class_map['FactValue'].objects.get_or_create(value=value,\n                                                                                 fact_data_type=fact_data_type,\n                                                                                 storage_location=storage_location)\n        value_objects.append(fact_value)\n\n\n\n    # Do we already have a fact with given fact term and given values?\n    #\n    # For understanding the query below better, see https://groups.google.com/forum/#!topic/django-users/X9TCSrBn57Y.\n    # The double query is necessary, because the first count counts the number of selected\n    # fact_value objects, not the number of total objects for each fact.\n\n\n    possibly_matching_facts = Fact.objects.filter(fact_values__in=value_objects,\n                                                  value_iobject_id=value_iobject_id,\n                                                  value_iobject_ts=value_iobject_ts,\n                                                  fact_term=fact_term\n    ).values_list('pk',flat=True)\n\n    matching_facts = Fact.objects.filter(pk__in=list(possibly_matching_facts)). \\\n        annotate(num_values=Count('fact_values')). \\\n        filter(num_values=len(value_objects)). \\\n        exclude(id__in= \\\n        Fact.objects.filter(pk__in=possibly_matching_facts).annotate(total_values=Count('fact_values')). \\\n            filter(total_values__gt=len(value_objects)))\n\n    # Below, for educational purposes, the original query until Dingos 0.2.0, which got *really*\n    # slow with lot's of objects in the system. The reason for this are the last three lines:\n    # the exclude-statement required the database to count the the number of values for each\n    # Fact in the system... but we are really only interested into facts with the same\n    # fact_term, value_iobject_id and value_iobject_ts...\n\n    #matching_facts = Fact.objects.filter(fact_values__in=value_objects). \\\n    #    annotate(num_values=Count('fact_values')). \\\n    #    filter(num_values=len(value_objects)). \\\n    #    filter(value_iobject_id=value_iobject_id). \\\n    #    filter(value_iobject_ts=value_iobject_ts). \\\n    #    filter(fact_term=fact_term). \\\n    #    exclude(id__in= \\\n    #    Fact.objects.annotate(total_values=Count('fact_values')). \\\n    #        filter(total_values__gt=len(value_objects)))\n\n    created = True\n    try:\n        fact_obj = matching_facts[0]\n        created = False\n        logger.debug(\"FOUND MATCHING OBJECT with pk %s\" % fact_obj.pk)\n    except:\n        fact_obj = dingos_class_map['Fact'].objects.create(fact_term=fact_term,\n                                                          value_iobject_id=value_iobject_id,\n                                                          value_iobject_ts=value_iobject_ts,\n                                                           )\n\n        fact_obj.fact_values.add(*value_objects)\n        fact_obj.save()\n\n\n    return fact_obj, created"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_or_create_fact_term(iobject_family_name,\n                            fact_term_name,\n                            fact_term_attribute,\n                            iobject_type_name,\n                            iobject_type_namespace_uri,\n                            fact_dt_name=DINGOS_DEFAULT_FACT_DATATYPE,\n                            fact_dt_namespace_name=None,\n                            fact_dt_kind=FactDataType.UNKNOWN_KIND,\n                            fact_dt_namespace_uri=DINGOS_NAMESPACE_URI,\n                            dingos_class_map=dingos_class_map\n):\n    \"\"\"\n    Get or create a fact term.\n    \"\"\"\n\n    if not fact_term_attribute:\n        fact_term_attribute = ''\n\n    # create or retrieve the enrichment type and revision\n\n    iobject_family, created = dingos_class_map['InfoObjectFamily'].objects.get_or_create(name=iobject_family_name)\n\n    # create or retrieve namespace of data type\n\n    fact_dt_namespace, created = dingos_class_map['DataTypeNameSpace'].objects.get_or_create(uri=fact_dt_namespace_uri)\n\n    # create or retrieve namespace of the infoobject type\n\n    iobject_type_namespace, created = dingos_class_map['DataTypeNameSpace'].objects.get_or_create(uri=iobject_type_namespace_uri)\n\n    if created and fact_dt_namespace_name:\n        fact_dt_namespace.name = fact_dt_namespace_name\n        fact_dt_namespace.save()\n\n\n    # create or retrieve the fact-value data type object\n    fact_dt, created = dingos_class_map['FactDataType'].objects.get_or_create(name=fact_dt_name,\n                                                                              namespace=fact_dt_namespace)\n\n    if created:\n        fact_dt.kind = fact_dt_kind\n        fact_dt.save()\n\n    # create or retreive the iobject type\n    iobject_type, created = dingos_class_map['InfoObjectType'].objects.get_or_create(name=iobject_type_name,\n                                                                                    iobject_family=iobject_family,\n                                                                                    namespace=iobject_type_namespace)\n\n    fact_term, created = dingos_class_map['FactTerm'].objects.get_or_create(term=fact_term_name,\n                                                                           attribute=fact_term_attribute)\n\n    fact_term_2_type, dummy = dingos_class_map['FactTerm2Type'].objects.get_or_create(fact_term=fact_term,\n                                                                                     iobject_type=iobject_type,\n                                                                                     )\n\n    fact_term_2_type.fact_data_types.add(fact_dt)\n\n    fact_term_2_type.save()\n\n    return fact_term, created", "response": "Get or create a fact term."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the back - pointer to the markings that have been attached to this object.", "response": "def marking_thru(self):\n        \"\"\"\n        Return the back-pointer to  markings that\n        may have been attached via Django's content type mechanism.\n        \"\"\"\n        self_django_type = ContentType.objects.get_for_model(self)\n        return Marking2X.objects.filter(content_type__pk=self_django_type.id,\n                                        object_id=self.id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of InfoObjects that are embedded in this InfoObject.", "response": "def embedded_in(self):\n        \"\"\"\n        Used in the view for the InfoObject (in order to be able to use the standard class-based object view.\n        Should be removed from here and put into a proper custom view for the object.\n\n        This query only returns embedding objects of the latest revision: to change\n        this, the filter 'iobject__timestamp=F('iobject__identifier__latest__timestamp' must\n        be removed.\n        \"\"\"\n\n        return self._DCM['InfoObject2Fact']. \\\n            objects. \\\n            filter(fact__value_iobject_id=self.identifier). \\\n            filter(iobject__timestamp=F('iobject__identifier__latest__timestamp')). \\\n            order_by('-iobject__timestamp') \\\n            .values_list(\n            'iobject',\n            'iobject__identifier__namespace__uri',\n            'iobject__identifier__uid',\n            'iobject__timestamp',\n            'iobject__name',\n            'fact__value_iobject_ts',\n            'fact__fact_term__term', \n            'node_id__name').distinct()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_fact(self,\n                 fact_term_name,\n                 fact_term_attribute,\n                 fact_dt_name='String',\n                 fact_dt_namespace_name=None,\n                 fact_dt_namespace_uri=DINGOS_NAMESPACE_URI,\n                 fact_dt_kind=FactDataType.UNKNOWN_KIND,\n                 values=None,\n                 value_iobject_id=None,\n                 value_iobject_ts=None,\n                 node_id_name='',\n                 is_attribute=False,\n                 ns_uri_dict=None,\n                 namespaces=None,\n                 top_level_namespace=None):\n        \"\"\"\n        Add a fact to the iobject. If a fact term for the iobject type\n        with the given fact data type and source (CYBOX, etc.) does not\n        exist yet, it is created.\n\n        \"\"\"\n\n\n        if not values:\n            values = []\n\n        if not namespaces:\n            namespaces = []\n\n        if not ns_uri_dict:\n            ns_uri_dict = None\n\n        # get or create fact_term\n        fact_term, created = get_or_create_fact_term(iobject_family_name=self.iobject_family.name,\n                                                     fact_term_name=fact_term_name,\n                                                     fact_term_attribute=fact_term_attribute,\n                                                     iobject_type_name=self.iobject_type.name,\n                                                     iobject_type_namespace_uri=self.iobject_type.namespace.uri,\n                                                     fact_dt_name=fact_dt_name,\n                                                     fact_dt_kind=fact_dt_kind,\n                                                     fact_dt_namespace_name=fact_dt_namespace_name,\n                                                     fact_dt_namespace_uri=fact_dt_namespace_uri,\n                                                     dingos_class_map=self._DCM)\n\n\n\n        # get or create fact object\n\n        fact_obj, created = get_or_create_fact(fact_term,\n                                               fact_dt_name=fact_dt_name,\n                                               fact_dt_namespace_uri=fact_dt_namespace_uri,\n                                               values=values,\n                                               value_iobject_id=value_iobject_id,\n                                               value_iobject_ts=value_iobject_ts,\n                                               )\n\n\n\n        # get or create node identifier\n\n        node_id, created = dingos_class_map['NodeID'].objects.get_or_create(name=node_id_name)\n\n        # If this is an attribute: determine whether there is a fact for which this fact is\n        # an attribute.\n\n        node_id_name_components = node_id_name.split(':')\n\n        attributed_io2f = None\n        if node_id_name_components[-1] and node_id_name_components[-1][0] == 'A':\n            attributed_node_id_name = \":\".join(node_id_name_components[:-1])\n\n            try:\n                attributed_io2f = dingos_class_map['InfoObject2Fact'].objects.get(iobject=self,\n                                                                                 node_id__name=attributed_node_id_name)\n            except InfoObject2Fact.DoesNotExist:\n                pass\n\n        io2f = self._DCM['InfoObject2Fact'].objects.create(\n            node_id=node_id,\n            iobject=self,\n            fact=fact_obj,\n            attributed_fact=attributed_io2f)\n\n        counter = 0\n        io2f2n_list = []\n\n\n        namespace_map_elts = FactTermNamespaceMap.objects.filter(fact_term=fact_term).order_by('id','namespaces_thru__position').values_list('id',\n                                                                                             'namespaces_thru__position',\n                                                                                             'namespaces_thru__namespace__uri')\n\n        namespace_maps = []\n        for k,g in itertools.groupby(namespace_map_elts,lambda x:x[0]):\n            namespace_maps.append(list(g))\n\n\n        namespace_map = None\n\n        namespaces_uris = map(lambda x:x[0],namespaces)\n\n\n        for i in namespace_maps:\n            if namespaces_uris == map(lambda x:x[2],i):\n                namespace_map = FactTermNamespaceMap.objects.get(id=i[0][0])\n\n\n                break\n\n\n\n        if not namespace_map:\n\n            namespace_map = FactTermNamespaceMap.objects.create(fact_term=fact_term)\n            for (ns_uri,ns_slug) in namespaces:\n\n                if ns_uri:\n\n                    if not (ns_uri in ns_uri_dict):\n                        ns_uri_obj, created = self._DCM['DataTypeNameSpace'].objects.get_or_create(uri=ns_uri,defaults={'name':ns_slug})\n                        ns_uri_obj_pk = ns_uri_obj.pk\n                        ns_uri_dict[ns_uri]=ns_uri_obj_pk\n                    else:\n                        ns_uri_obj_pk = ns_uri_dict[ns_uri]\n\n                    io2f2n_list.append(PositionalNamespace(fact_term_namespace_map=namespace_map,position=counter,namespace_id=ns_uri_obj_pk))\n\n                counter +=1\n                #self._DCM['IO2F2Namespace'].object.create(io2f=self,position=counter,namespace__pk=ns_uri_obj_pk)\n\n            if len(io2f2n_list)!= 0:\n                PositionalNamespace.objects.bulk_create(io2f2n_list)\n            else:\n                namespace_map.delete()\n                namespace_map = None\n\n        if namespace_map:\n            io2f.namespace_map = namespace_map\n            io2f.save()\n\n        return io2f", "response": "Adds a fact to the iobject."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a dictionary to facts and associate it with this information object.", "response": "def from_dict(self,\n                  dingos_obj_dict,\n                  config_hooks=None,\n                  namespace_dict=None,\n                  ):\n        \"\"\"\n        Convert DingoObjDict to facts and associate resulting facts with this information object.\n        \"\"\"\n\n\n        # Instantiate default parameters\n\n\n\n\n        if '@@ns' in dingos_obj_dict.keys():\n            top_level_namespace = (namespace_dict.get(dingos_obj_dict.get('@@ns'),None),dingos_obj_dict.get('@@ns'))\n        else:\n            top_level_namespace = (None,None)\n\n        if not config_hooks:\n            config_hooks = {}\n\n        datatype_extractor = config_hooks.get('datatype_extractor', (lambda io, f, i, n, d: False))\n\n        special_ft_handler = config_hooks.get('special_ft_handler', None)\n\n        attr_ignore_predicate = config_hooks.get('attr_ignore_predicate', None)\n\n        force_nonleaf_fact_predicate = config_hooks.get('force_nonleaf_fact_predicate', None)\n\n        if not namespace_dict:\n            namespace_dict = {}\n\n\n        namespace_uri_2_pk_mapping = dict(self._DCM['DataTypeNameSpace'].objects.values_list('uri','id'))\n\n\n        if not self.is_empty():\n            logger.debug(\"Non-empty info object %s (timestamp %s, pk %s ) is overwritten with new information\" % (self.identifier,\n                                                                                                                 self.timestamp,\n                                                                                                                 self.pk))\n            self.clear()\n\n\n        # Flatten the DingoObjDict\n\n        (flat_list, attrs) = dingos_obj_dict.flatten(attr_ignore_predicate=attr_ignore_predicate,\n                                                     force_nonleaf_fact_predicate=force_nonleaf_fact_predicate,\n                                                     namespace_dict=namespace_dict)\n\n\n\n        for fact in flat_list:\n\n            # Collect the information about all attributes relevant\n            # for this node (i.e., they occur either directly on\n            # the node or on an ancestor node).\n\n            # The following code was used to generate a attribute dictionary::\n            #\n            #     attr_info = ExtendedSortedDict()\n            #     for attr_node in attrs.keys():\n            #         if fact['node_id'].startswith(attr_node):\n            #            for (key, value) in attrs[attr_node].items():\n            #                attr_info.chained_set(value, 'set', key, attr_node)\n            #\n            # The dictionary contained full information about also the attributes given\n            # to ancestor nodes. So far, we have not required this\n            # information for our imports, and thus simplify to a\n            # dictionary that only contains the attributes directly\n            # associated with the current node.\n            #\n            # If, at a later stage, we find we need this kind of information,\n            # we will can use Django's MultiValueDict to add additional\n            # information without changing the signature of the receiving\n            # predicate and handler functions.\n\n\n            attr_info = dict(attrs.get(fact['node_id'],[]))\n\n            #for attr_node in attrs.keys():\n            #    if fact['node_id'] == (attr_node):\n            #        for (key, value) in attrs[attr_node].items():\n            #            attr_info.chained_set(value, 'set', key, attr_node)\n\n\n            # Fill dictionary with arguments for call to 'add_fact'\n\n            add_fact_kargs = {}\n            add_fact_kargs['fact_dt_kind'] = FactDataType.UNKNOWN_KIND\n            add_fact_kargs['fact_dt_namespace_name'] = \"%s-%s\" % (\n                self.iobject_family.name, self.iobject_family_revision.name)\n\n            # See whether the datatype extractor has found a datatype for the value\n\n            datatype_found = datatype_extractor(self, fact, attr_info, namespace_dict, add_fact_kargs)\n\n            if not datatype_found:\n                add_fact_kargs = {}\n                add_fact_kargs['fact_dt_kind'] = FactDataType.NO_VOCAB\n                add_fact_kargs['fact_dt_namespace_name'] = DINGOS_NAMESPACE_SLUG\n                add_fact_kargs['fact_dt_namespace_uri'] = DINGOS_NAMESPACE_URI\n            else:\n                # Check whether the datatype extractor added namespace information\n                # If not, add some here\n                if not 'fact_dt_namespace_uri' in add_fact_kargs:\n                    add_fact_kargs['fact_dt_namespace_uri'] = namespace_dict.get(\n                        add_fact_kargs['fact_dt_namespace_name'], '%s/%s' % (\n                            DINGOS_NAMESPACE_URI, self.iobject_family))\n\n            add_fact_kargs['fact_term_name'] = fact['term']\n            add_fact_kargs['fact_term_attribute'] = fact['attribute']\n            add_fact_kargs['values'] = [fact['value']]\n            add_fact_kargs['node_id_name'] = fact['node_id']\n            add_fact_kargs['namespaces'] = fact['namespaces']\n            add_fact_kargs['top_level_namespace'] = top_level_namespace\n\n            handler_return_value = True\n\n            logger.debug(\"Treating fact (before special handler list) %s with attr_info %s and kargs %s\" % (fact, attr_info, add_fact_kargs))\n            # Below, go through the handlers in the special_ft_handler list --\n            # if the predicate returns True for the fact, execute the handler\n            # on the fact. If a handler returns False/None, the fact is *not*\n            # added. This should only be done, if the handler has added the\n            # fact -- otherwise the sequence of node identifiers is messed up!\n\n            if special_ft_handler:\n                for (predicate, handler) in special_ft_handler:\n                    if predicate(fact, attr_info):\n                        handler_return_value = handler(self, fact, attr_info, add_fact_kargs)\n                        if not handler_return_value:\n                            break\n            logger.debug(\"Treating fact (before special handler list) %s with attr_info %s and kargs %s\" % (fact, attr_info, add_fact_kargs))\n            if (handler_return_value == True):\n                add_fact_kargs['ns_uri_dict'] = namespace_uri_2_pk_mapping\n                e2f_obj = self.add_fact(**add_fact_kargs)\n            elif not handler_return_value:\n                continue\n            else:\n                e2f_obj = handler_return_value\n        self.set_name()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of the fact terms that occur in this InfoObject.", "response": "def show_fact_terms(self,level):\n        \"\"\"Returns a list of the fact terms (split in 'term' and 'attribute') that\n         occur in this InfoObject.\"\"\"\n\n        fact_terms = self._DCM[\"FactTerm\"].objects.filter(fact__infoobject__pk=self.pk). \\\n            distinct('term','attribute').values('term','attribute')\n\n\n        #fact_terms = self._DCM[\"FactTerm\"].objects.filter(fact__iobject_thru__iobject__pk=self.pk).\\\n        #    filter(fact__iobject_thru__node_id__name__startswith=level).order_by('term','attribute').\\\n        #    distinct('term','attribute').values_list('fact__iobject_thru__node_id__name','term','attribute')\n\n        return list(fact_terms)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_name(self,name=None):\n        if name:\n            self.name = name[:254]\n        else:\n            self.name = self.extract_name()[:254]\n\n        self.save()\n\n        return self.name", "response": "Set the name of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_relation(self,\n                     target_id=None,\n                     relation_types=None,\n                     fact_dt_namespace_name=None,\n                     fact_dt_namespace_uri=DINGOS_NAMESPACE_URI,\n                     fact_dt_kind=FactDataType.UNKNOWN_KIND,\n                     fact_dt_name='String',\n                     metadata_dict=None,\n                     markings=None\n    ):\n        \"\"\"\n        Add a relationship between this object and another object.\n        \"\"\"\n        if not markings:\n            markings = []\n\n        if relation_types == None:\n            relation_types = []\n\n        # Create fact-term for relation types\n        relation_type_ft, created = get_or_create_fact_term(iobject_family_name=self.iobject_family.name,\n                                                            fact_term_name=DINGOS_RELATION_TYPE_FACTTERM_NAME,\n                                                            iobject_type_name=self.iobject_type.name,\n                                                            iobject_type_namespace_uri=self.iobject_type.namespace.uri,\n                                                            fact_dt_name=fact_dt_name,\n                                                            fact_dt_namespace_name=fact_dt_namespace_name,\n                                                            fact_dt_kind=fact_dt_kind,\n                                                            fact_dt_namespace_uri=fact_dt_namespace_uri)\n\n        # Create fact containing relation types\n        relation_type_fact, created = get_or_create_fact(fact_term=relation_type_ft,\n                                                         fact_dt_name=fact_dt_name,\n                                                         fact_dt_namespace_uri=fact_dt_namespace_uri,\n                                                         values=relation_types,\n                                                         value_iobject_id=None,\n                                                         value_iobject_ts=None,\n                                                         )\n\n        rel_target_id = target_id\n        rel_source_id = self.identifier\n\n        # Create relation object\n        relation, created = self._DCM['Relation'].objects.get_or_create(\n            source_id=rel_source_id,\n            target_id=rel_target_id,\n            relation_type=relation_type_fact)\n\n        # Add markings\n        for marking in markings:\n            Marking2X.objects.create(marked=relation,\n                                     marking=marking)\n\n        if metadata_dict:\n            # If the relation already existed and had associated metadata,\n            # we retrieve the identifier of that metadata object and\n            # write the current metadata as new revision. Otherwise,\n            # we create a new identifier.\n\n            if relation.metadata_id:\n                rel_identifier_uid = relation.metadata_id.uid\n                rel_identifier_namespace_uri = relation.metadata_id.namespace.uri\n            else:\n                rel_identifier_uid = None\n                rel_identifier_namespace_uri = DINGOS_ID_NAMESPACE_URI\n\n            metadata_iobject, created = get_or_create_iobject(identifier_uid=rel_identifier_uid,\n                                                              identifier_namespace_uri=rel_identifier_namespace_uri,\n                                                              iobject_type_name=DINGOS_RELATION_METADATA_OBJECT_TYPE_NAME,\n                                                              iobject_type_namespace_uri=DINGOS_NAMESPACE_URI,\n                                                              iobject_type_revision_name=DINGOS_REVISION_NAME,\n                                                              iobject_family_name=DINGOS_IOBJECT_FAMILY_NAME,\n                                                              iobject_family_revision_name=DINGOS_REVISION_NAME,\n                                                              timestamp=None,\n                                                              overwrite=False)\n            metadata_iobject.from_dict(metadata_dict)\n\n        return relation", "response": "Adds a relationship between two objects."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef view_link(self):\n        iobject_url = urlresolvers.reverse('url.dingos.view.infoobject', args=(self.id,))\n        return mark_safe(\n            \"\"\"<a href=\"%s\"><img src=\"/static/admin/img/selector-search.gif\" alt=\"Lookup\" height=\"16\" width=\"16\">\"\"\" % iobject_url)", "response": "Return link to the Info Object view for InfoObjects."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_user_data(user=None,group=None,data_kind=DINGOS_USER_DATA_TYPE_NAME):\n        logger.debug(\"Get user settings called\")\n\n        if not user.is_authenticated():\n            user = None\n\n        try:\n            user_config =  UserData.objects.get(user=user,group=group,data_kind=data_kind)\n            return user_config.retrieve()\n        except:\n            return None", "response": "Get user data from database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the latest user data object.", "response": "def get_user_data_iobject(user=None,group=None,data_kind=DINGOS_USER_DATA_TYPE_NAME):\n        \"\"\"\n        Returns either stored settings of a given user or default settings.\n        This behavior reflects the need for views to have some settings at\n        hand when running. The settings are returned as dict object.\n        \"\"\"\n        logger.debug(\"Get user settings called\")\n\n        if not user.is_authenticated():\n            user = None\n        try:\n            user_config =  UserData.objects.get(user=user,group=group,data_kind=data_kind)\n            return user_config.identifier.latest\n        except:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef store_user_data(user=None, group=None,data_kind=DINGOS_USER_DATA_TYPE_NAME,user_data=None,iobject_name=None):\n\n        if not user_data:\n            user_data = {}\n\n        if not user.is_authenticated():\n            user = None\n\n        user_config,created =  UserData.objects.get_or_create(user=user,group=group,data_kind=data_kind)\n        return user_config.store(user_data,iobject_type_name=data_kind,iobject_name=iobject_name)", "response": "Stores user data in a given user or default settings."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_cone(cls, center,\n                  radius=3*u.arcmin,\n                  magnitudelimit=None,\n                  **kw):\n        '''\n        Create a Constellation from a cone search of the sky,\n        characterized by a positional center and a radius from it.\n\n        Parameters\n        ----------\n        center : SkyCoord object\n            The center around which the query will be made.\n        radius : float, with units of angle\n            The angular radius for the query.\n        magnitudelimit : float\n            The maximum magnitude to include in the download.\n            (This is explicitly thinking UV/optical/IR, would\n            need to change to flux to be able to include other\n            wavelengths.)\n        '''\n\n        # make sure the center is a SkyCoord\n        center = parse_center(center)\n\n        criteria = {}\n        if magnitudelimit is not None:\n            criteria[cls.defaultfilter + 'mag'] = '<{}'.format(magnitudelimit)\n\n        v = Vizier(columns=cls.columns,\n                   column_filters=criteria)\n        v.ROW_LIMIT = -1\n\n        # run the query\n        print('querying Vizier for {}, centered on {} with radius {}, for G<{}'.format(cls.name, center, radius, magnitudelimit))\n\n        table = v.query_region(coordinates=center,\n                               radius=radius,\n                               catalog=cls.catalog)[0]\n\n        # store the search parameters in this object\n        c = cls(cls.standardize_table(table))\n        c.standardized.meta['catalog'] = cls.catalog\n        c.standardized.meta['center'] = center\n        c.standardized.meta['radius'] = radius\n        c.standardized.meta['magnitudelimit'] = magnitudelimit\n        #c.center = center\n        #c.radius = radius\n        #c.magnitudelimit = magnitudelimit or cls.magnitudelimit\n        return c", "response": "Create a Constellation object from a cone search of the sky and a characterized center and a radius."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a Constellation from a criteria search of the whole sky.", "response": "def from_sky(cls, magnitudelimit=None):\n        '''\n        Create a Constellation from a criteria search of the whole sky.\n\n        Parameters\n        ----------\n        magnitudelimit : float\n            Maximum magnitude (for Ve = \"estimated V\").\n        '''\n\n\n        # define a query for cone search surrounding this center\n\n        criteria = {}\n        if magnitudelimit is not None:\n            criteria[cls.defaultfilter + 'mag'] = '<{}'.format(magnitudelimit)\n\n        v = Vizier(columns=cls.columns,\n                   column_filters=criteria)\n        v.ROW_LIMIT = -1\n\n        # run the query\n        print('querying Vizier for {}, for {}<{}'.format(cls.name, cls.defaultfilter, magnitudelimit))\n\n        table = v.query_constraints(catalog=cls.catalog, **criteria)[0]\n\n        # store the search parameters in this object\n        c = cls(cls.standardize_table(table))\n        c.standardized.meta['catalog'] = cls.catalog\n        c.standardized.meta['criteria'] = criteria\n        c.standardized.meta['magnitudelimit'] = magnitudelimit or c.magnitudelimit\n        #c.magnitudelimit = magnitudelimit or c.magnitudelimit\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstandardizing a Gaia DR2 table.", "response": "def standardize_table(cls, table):\n        '''\n        Extract objects from a Gaia DR2 table.\n        '''\n\n        print(cls)\n        identifiers = {n+'-id':table[n] for n in cls.identifier_keys}\n\n        # create skycoord objects\n        N = len(table)\n        coordinates = dict(  ra=table['_RAJ2000'].data.data*u.deg,\n                             dec=table['_DEJ2000'].data.data*u.deg,\n                             pm_ra_cosdec=table['pmRA'].data.data*u.arcsec/u.year,\n                             pm_dec=table['pmDE'].data.data*u.arcsec/u.year,\n                             radial_velocity=np.nan*np.ones(N)*u.km/u.s,\n                             distance=np.nan*np.ones(N)*u.pc,#distance=1000*u.pc/table['parallax'].data, # weirdly, messed with RA + Dec signs if parallax is zero\n                             obstime=cls.epoch*np.ones(N)*u.year)#Time(, format='decimalyear'))\n        for k in coordinates:\n            print(k, coordinates[k])\n        magnitudes = {f+'-mag':table[f+'mag'].data for f in cls.filters}\n\n        standardized = hstack([Table(identifiers),\n                               Table(coordinates),\n                               Table(magnitudes)])\n        standardized.meta['catalog'] = 'Gaia'\n\n        return standardized"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_data(self):\n        if self.raw_data is None and self.data_format is not FormatType.PYTHON:\n            if self.file_path is None:\n                raise ArgumentInvalid('One of \"raw_data\" or \"file_path\" should be set!')\n            if not os.path.isfile(self.file_path) or not os.access(self.file_path, os.R_OK):\n                raise ArgumentInvalid('\"file_path\" should be a valid path to an exist file with read permission!')\n            with open(self.file_path) as f:\n                self.raw_data = f.read()", "response": "Load data from file_path or raw_data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate(self):\n        if self.data_format is FormatType.PYTHON:\n            self.data = self.raw_data\n        elif self.data_format is FormatType.JSON:\n            self._validate_json()\n        elif self.data_format is FormatType.YAML:\n            self._validate_yaml()", "response": "Validate the input data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the formatted output of the data in the specified format.", "response": "def get_formatted_output(self, format_type=FormatType.JSON):\n        \"\"\"\n        :param format_type: The format need to output.\n        :return: formatted output.\n        :raise ConversionError: data can't be converted to the specified format_type.\n        \"\"\"\n        if format_type not in [FormatType.JSON, FormatType.YAML]:\n            raise ArgumentInvalid('\"format_type\" should be one of FormatType.JSON / YAML!')\n        elif format_type is FormatType.JSON:\n            return self._format_json()\n        elif format_type is FormatType.YAML:\n            return self._format_yaml()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_bracket_expression(pattern, start=0, no_escape=False):\n    i = start\n\n    if pattern[i:i+len(_BE_OPEN)] != _BE_OPEN:\n        raise ValueError(u'Expected {}'.format(repr(_BE_OPEN)))\n    i += len(_BE_OPEN)\n\n    # fnmatch builds on top of POSIX, but uses `!` while POSIX uses `^`\n    if pattern[i:i+len(_BE_NON_MATCHING)] == _BE_NON_MATCHING:\n        matching = False\n        i += len(_BE_NON_MATCHING)\n    elif pattern[i:i+len(_BE_NON_MATCHING2)] == _BE_NON_MATCHING2:\n        matching = False\n        i += len(_BE_NON_MATCHING2)\n    else:\n        matching = True\n\n    # We iterate other the items twice, first we get the tokens and parse most of it except for\n    # ranges. Then, we resolve ranges by joining collating elements separated by an empty range\n    # marker\n\n    # Items in this bracket expression\n    items = []\n\n    # First pass: tokenize\n    while len(items) == 0 or pattern[i:i + len(_BE_CLOSE)] != _BE_CLOSE:\n        if not no_escape and pattern[i:i+len(_ESCAPE)] == _ESCAPE:  # Literal escape \\a\n            i += len(_ESCAPE)\n            if i >= len(pattern):\n                raise ValueError(u'Invalid pattern, incomplete escape sequence')\n            items.append(_create_be_collating_element(pattern[i:i + 1]))\n            i += 1\n        elif pattern[i:i+len(_BE_CS_OPEN)] == _BE_CS_OPEN:  # Collating symbol [.abc.]\n            cs, cs_len = _parse_be_collating_symbol(pattern, i)\n            items.append(_create_be_collating_element(cs))\n            i += cs_len\n        elif pattern[i:i+len(_BE_ECE_OPEN)] == _BE_ECE_OPEN:  # Equivalence class expression [=abc=]\n            # Currently, equivalence classes are a synonym for collating symbols because we do not\n            # support equivalence classes. The difference is that we have to prevent them from\n            # ending ranges to eventually add support for equivalence classes in the future\n            ec_repr, ece_len = _parse_be_equivalence_class_expression(pattern, i)\n            items.append(_create_be_equivalence_class(ec_repr))\n            i += ece_len\n        elif pattern[i:i+len(_BE_CCE_OPEN)] == _BE_CCE_OPEN:  # Character class expression [:alpha:]\n            cc_name, cce_len = _parse_be_character_class_expression(pattern, i)\n            items.append(_create_be_character_class(cc_name))\n            i += cce_len\n        elif pattern[i:i + len(_BE_RANGE)] == _BE_RANGE:  # Range a-c\n            items.append(_create_be_unmatched_range())\n            i += len(_BE_RANGE)\n        else:  # Single-character collating element\n            items.append(_create_be_collating_element(pattern[i:i+1]))\n            i += 1\n\n        if i >= len(pattern):\n            raise ValueError(u'InvalidPattern, end of bracket expression not found')\n    i += len(_BE_CLOSE)\n\n    # Second pass: resolve ranges\n    items_with_ranges = []\n    j = 0\n    while j < len(items):\n        item = items[j]\n        if not _is_be_unmatched_range(item):\n            items_with_ranges.append(item)\n        else:\n            # From here, the current item is an unmatched range, we try to get the previous and next\n            # item if they are collating elements\n            if j == 0:\n                prev_elem = None\n            else:\n                prev_elem = items_with_ranges[-1]\n                if not _is_be_collating_element(prev_elem):\n                    prev_elem = None\n            if j == len(items) - 1:\n                next_elem = None\n            else:\n                next_elem = items[j + 1]\n                # case [a--], [---] or [[.a.]--]\n                if prev_elem is not None and _is_be_unmatched_range(next_elem):\n                    next_elem = _create_be_collating_element(_BE_RANGE)\n                elif not _is_be_collating_element(next_elem):\n                    next_elem = None\n\n            # Unmatched dash between two collating elements\n            if prev_elem is not None and next_elem is not None:\n                # Note that we allow ranges between multi-character collating elements\n                range_start = _read_be_collating_element(prev_elem)\n                range_end = _read_be_collating_element(next_elem)\n                # Equivalent to .pop then .append\n                items_with_ranges[-1] = _create_be_range(range_start, range_end)\n                j += 1  # Skip the next item (corresponds to the end of the range)\n            # Add the dash as a collating element\n            else:\n                items_with_ranges.append(_create_be_collating_element(_BE_RANGE))\n                _create_be_collating_element(_BE_RANGE)\n        j += 1\n\n    return _create_bracket_expression(matching, items_with_ranges), i - start", "response": "u Parses a pattern into a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef match(pattern, text, no_escape=False, path_name=True, wild_star=True, period=False,\n          case_fold=False):\n    u\"\"\"\n    Matches text against the supplied wildmatch pattern.\n\n    To get git's behavior, use the `wild_star` flag.\n\n    Note that the EXTMATCH (ksh extended glob patterns) option is not available\n\n    :type pattern: text_type\n    :param pattern: A wildmatch pattern\n    :type text: text_type\n    :param text: The text to match\n    :type no_escape: bool\n    :param no_escape: Disable backslash escaping\n    :type path_name: bool\n    :param path_name: Separator (slash) in text cannot be matched by an asterisk, question-mark nor\n                      bracket expression in pattern (only a literal).\n    :type wild_star: bool\n    :param wild_star: A True value forces the `path_name` flag to True. This allows the\n                      double-asterisk `**` to match any (0 to many) number of directories\n    :type period: bool\n    :param period: A leading period in text cannot be matched by an asterisk, question-mark nor\n                   bracket expression in pattern (only a literal). A period is \"leading\" if:\n                   - it is the first character of `text`\n                   OR\n                   - path_name (or wild_star) is True and the previous character is a slash\n    :type case_fold: bool\n    :param case_fold: Perform a case insensitive match (GNU Extension)\n    :rtype: bool\n    :return: Result of the match\n    \"\"\"\n\n    regex = translate(pattern, no_escape=no_escape, path_name=path_name, wild_star=wild_star,\n                      period=period, case_fold=case_fold, closed_regex=True)\n    return regex.match(text) is not None", "response": "u Matches text against the supplied wildmatch pattern."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter(self, texts):\n        return (text for text in texts if self.regex.match(text) is not None)", "response": "u Returns a generator yielding the elements of texts that match this pattern."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot(X, marker='.', kind='plot', title=None, fig='current', ax=None,\n         **kwargs):\n  '''General plotting function that aims to cover most common cases.\n  X : numpy array of 1d, 2d, or 3d points, with one point per row.\n  marker : passed to the underlying plotting function\n  kind : one of {plot, scatter} that controls the plot type.\n  title : if given, used as the axis title\n  fig : a matplotlib.Figure, or one of {current, new}. Only used when ax=None.\n  ax : a matplotlib.Axes object, or None\n  All other keyword arguments are passed on to the underlying plotting function.\n  '''\n  X = np.asanyarray(X)\n  if X.ndim not in (1,2) or (X.ndim == 2 and X.shape[1] not in (1,2,3)):\n    raise ValueError('Input data must be rows of 1, 2, or 3 dimensional points')\n  is_3d = X.ndim == 2 and X.shape[1] == 3\n  is_1d = X.ndim == 1 or X.shape[1] == 1\n  ax = _get_axis(fig, ax, is_3d)\n  # XXX: support old-style scatter=True kwarg usage\n  if kwargs.get('scatter', False):\n    kind = 'scatter'\n    del kwargs['scatter']\n  # Do the plotting\n  if kind is 'scatter':\n    if is_1d:\n      ax.scatter(np.arange(len(X)), X, marker=marker, **kwargs)\n    elif is_3d:\n      ax.scatter(X[:,0], X[:,1], X[:,2], marker=marker, **kwargs)\n    else:\n      ax.scatter(X[:,0], X[:,1], marker=marker, **kwargs)\n  elif kind is 'plot':\n    if is_1d:\n      ax.plot(X, marker, **kwargs)\n    elif is_3d:\n      ax.plot(X[:,0], X[:,1], X[:,2], marker, **kwargs)\n    else:\n      ax.plot(X[:,0], X[:,1], marker, **kwargs)\n  else:\n    raise ValueError('Unsupported kind: %r' % kind)\n  if title:\n    ax.set_title(title)\n  return plt.show", "response": "General plotting function that aims to cover most common cases."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_trajectories(T, colors=None, fig='current', ax=None, colorbar=False,\n                      cmap=None, alpha=1, linewidth=1, title=None):\n  '''Plot lines in T as trajectories (2d only).'''\n  ax = _get_axis(fig, ax, False)\n  if colors is not None:\n    colors = np.asanyarray(colors)\n  lc = LineCollection(T, array=colors, cmap=cmap, alpha=alpha,\n                      linewidth=linewidth)\n  ax.add_collection(lc, autolim=True)\n  if colors is not None and colorbar:\n    cbar = ax.figure.colorbar(lc)\n    cbar.set_alpha(1.)  # colorbars with alpha are ugly\n    cbar.draw_all()\n  ax.autoscale_view()\n  if title:\n    ax.set_title(title)\n  return plt.show", "response": "Plot lines in T as trajectories ( 2d only."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef imagesc(data, title=None, fig='current', ax=None):\n  '''Simple alias for a Matlab-like imshow function.'''\n  ax = _get_axis(fig, ax, False)\n  ax.imshow(data, interpolation='nearest', aspect='auto')\n  if title:\n    ax.set_title(title)\n  return plt.show", "response": "Simple alias for a Matlab - like imshow function."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef axes_grid(n, sharex=False, sharey=False, subplot_kw=None, **fig_kw):\n  '''Finds a reasonable arrangement of n axes. Returns (fig, axes) tuple.\n  For keyword arguments descriptions, see matplotlib.pyplot.subplots'''\n  r = np.floor(np.sqrt(n))\n  r, c = int(r), int(np.ceil(n / r))\n  fig, axes = plt.subplots(nrows=r, ncols=c, figsize=(c*4, r*4), squeeze=False,\n                           sharex=sharex, sharey=sharey,\n                           subplot_kw=subplot_kw, **fig_kw)\n  # Turn off any extra axes\n  for ax in axes.flat[n:]:\n    ax.set_axis_off()\n  return fig, axes", "response": "Finds a reasonable arrangement of n axes. Returns a figure and axes tuple.\n For keyword arguments descriptions see matplotlib. pyplot. subplots"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot vectors that start at points and move along directions.", "response": "def vector_field(points, directions, title=None, fig='current', ax=None,\n                 edge_style='k-', vertex_style='o'):\n  '''Plots vectors that start at 'points', and move along 'directions'.'''\n  assert points.shape[1] in (2,3) and directions.shape == points.shape\n  ax = _get_axis(fig, ax, points.shape[1] == 3)\n  # Plot.\n  if points.shape[1] == 2:\n    x,y = points.T\n    dx,dy = directions.T\n    if hasattr(ax, 'zaxis'):  # Must be on a 3d plot axis, so supply zeros.\n      _quiver3d(ax, x, y, 0, dx, dy, 0, arrow_length_ratio=0.1)\n    else:\n      args = (x, y, dx, dy)\n      ax.quiver(*args, angles='xy', scale_units='xy', scale=1, headwidth=5)\n    if vertex_style is not None:\n      ax.scatter(x, y, marker=vertex_style, zorder=2, edgecolor='none')\n  else:\n    x,y,z = points.T\n    dx,dy,dz = directions.T\n    _quiver3d(ax, x, y, z, dx, dy, dz, arrow_length_ratio=0.1)\n    if vertex_style is not None:\n      ax.scatter(x, y, z, marker=vertex_style, zorder=2, edgecolor='none')\n  if title:\n    ax.set_title(title)\n  return plt.show"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef encoder_decoder_split(self, dialogues):\n        self.log('info', 'Making encoder decoder split ...')\n\n\t    # get start, stop, and pad symbols\n        start = self.properties.start\n        stop = self.properties.stop\n        pad = self.properties.pad_u\n\n\t    # initialize encoder/decoder samples\n        encoder_x = np.copy(dialogues[:, 0])\n        decoder_x = np.zeros(encoder_x.shape)\n        decoder_y = np.copy(dialogues[:, 1])\n\n\t    # prepare decoder_x -- (prefix the <start> symbol to every second-pair part)\n        decoder_x[:, 0] = start\n        for i in range(decoder_y.shape[0]):\n            for j in range(decoder_y.shape[1] - 1):\n                if decoder_y[i, j] == pad:\n                    decoder_y[i, j] = stop\n                    break\n                decoder_x[i, j + 1] = decoder_y[i, j]\n\n        # prepare decoder_y -- the sparse_categorical_crossentropy loss function expects 3D tensors,\n        # where each word sequence is like [[72], [5], [44], [0] ...] -- so we add an extra dim\n        old_shape = decoder_y.shape\n        new_shape = (old_shape[0], old_shape[1], 1)\n        decoder_y = decoder_y.reshape(new_shape)\n\n        return [encoder_x, decoder_x, decoder_y]", "response": "This function splits the dialogues into two encoder and decoder samples."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads password from external file and retrun as string", "response": "def read_passwd_file(pass_file):\n    \"\"\"Read password from external file and retrun as string. The file should\n    contain just single line. Prevents hard-coding password anywhere in this\n    script. IMPORTANT! Password is stored as plain text! Do NOT use with your\n    personal account!\"\n\n    Args:\n        pass_file (str): /path/to/pass_file\n    \"\"\"\n    with open(pass_file) as fin:\n        passwd = fin.read().strip()\n    return passwd"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending an e - mail message using smtplib and email standard python libraries.", "response": "def send_mail(to_addr,\n              subj_msg,\n              body_msg,\n              attach_path,\n              serv_addr,\n              serv_port,\n              from_addr,\n              passwd):\n    \"\"\"Send an e-mail message using smtplib and email standard python libraries.\n    IMPORTANT! Password is stored as plain text! Do NOT use with your personal\n    account!\n\n    Args:\n        to_addr (str): Recipient address.\n        subj_msg (str): Message subject.\n        body_msg (str): Message body.\n        serv_addr (str): Server's address. Default: <smtp.gmail.com>.\n        serv_port (int): Server's port. Default: <587>.\n        from_addr (str): Account address. Default: <headnode.notifiy@gmail.com>.\n        passwd (str): Account password.\n    \"\"\"\n    msg = MIMEMultipart()\n    if attach_path is not None:\n        with open(attach_path, \"rb\") as fin:\n            part = MIMEBase(\"application\", \"octet-stream\")\n            part.set_payload(fin.read())\n            encoders.encode_base64(part)\n            part.add_header(\"Content-Disposition\",\n                            \"attachment; filename={0}\".format(attach_path))\n            msg.attach(part)\n    else:\n        pass\n    msg[\"From\"] = from_addr\n    msg[\"To\"] = to_addr\n    msg[\"Subject\"] = subj_msg\n    msg.attach(MIMEText(body_msg, \"plain\"))\n    server = smtplib.SMTP(serv_addr, serv_port)\n    server.starttls()\n    server.login(from_addr, passwd)\n    text_msg = msg.as_string()\n    server.sendmail(from_addr, to_addr, text_msg)\n    server.quit"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_sort_order(molecules):\n\n    neg_count = 0\n    pos_count = 0\n\n    for index in range(len(molecules)):\n\n        scoreList = molecules[index].GetProp('scores')\n        for element in scoreList:\n            if float(element) > 0:\n                pos_count += 1\n            elif float(element) < 0:\n                neg_count += 1\n\n    if pos_count > neg_count:\n        sort_order = 'dsc'\n    else:\n        sort_order = 'asc'\n\n    return sort_order", "response": "Get the sort order of the given list of molecules."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef roc_calculator(screened_molecules, status_field, active_label, decoy_label):\n\n    P = 0  # Total no. of actives\n    N = 0  # Total no. of decoys\n    tpf = [];\n    tpf.append(0)  # true positive fraction list\n    fpf = [];\n    fpf.append(0)  # false positive fraction list\n    fpindex = []  # indeces where decoys are found are labeled '1'\n\n    # Tally the # of positives & negatives at each threshold & in total\n    for index in range(len(screened_molecules)):\n        if screened_molecules[index].GetProp(status_field) == active_label and index == 0:\n            tpf[index] = float(1)\n            P = P + 1\n            fpindex.append(0)\n        elif screened_molecules[index].GetProp(status_field) == active_label and index > 0:\n            tpf.append(float(tpf[index - 1] + 1))\n            fpf.append(float(fpf[index - 1]))\n            P = P + 1\n            fpindex.append(0)\n        elif screened_molecules[index].GetProp(status_field) == decoy_label and index == 0:\n            fpf[index] = float(1)\n            N = N + 1\n            fpindex.append(1)\n        elif screened_molecules[index].GetProp(status_field) == decoy_label and index > 0:\n            fpf.append(float(fpf[index - 1] + 1))\n            tpf.append(float(tpf[index - 1]))\n            N = N + 1\n            fpindex.append(1)\n\n    # calculate TPF & FPF\n    for index in range(len(tpf)):\n        tpf[index] = tpf[index] / P\n        fpf[index] = fpf[index] / N\n\n    return tpf, fpf, P, N", "response": "Calculates ROC curve for a single screened element."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef metric_calculator(tpf, fpf, P, N, metric_list, anal=True):\n\n    metrics = {}\n\n    # build dictionary to store performance metrics\n    for vs_metric in [float(x) for x in metric_list if '.' in x]:\n        if N >= 1 / vs_metric:\n            # enrichment factor (ef) dictionary {#_of_req_decoys : [FPF,EF]}\n            metrics[round(vs_metric * N)] = [vs_metric, 0]\n\n    # non enrichment factor dictionary {'name' : ['name',value]}\n    for vs_metric in [x for x in metric_list if '.' not in x]:\n        metrics[vs_metric] = [vs_metric, 0, 0, 0]\n\n    # calculate enrichment factors & auc\n    metrics['AUC'][1] = 0\n\n    for index in range(len(tpf)):\n        # calculate and assign enrichment factors\n        if N * fpf[index] in metrics.keys() and N * fpf[index] > 0:\n            ef = tpf[index] / fpf[index]\n            metrics[N * fpf[index]][1] = ef\n\n        # calculate auc\n        if fpf[index] != fpf[index - 1]:\n            metrics['AUC'][1] = tpf[index] + metrics['AUC'][1]\n\n    metrics['AUC'][1] = metrics['AUC'][1] / N\n\n    # reshape metrics dictionary, discarding the #_of_req_decoys, i.e: {'fpf',[value,low,high]}\n    reshaped = {}\n    for k,v in metrics.iteritems():\n            if type(v) is float or type(v) is int:\n                reshaped[k] = v\n            else:\n                reshaped[v[0]] = v[1:]\n\n    return reshaped", "response": "Calculates the VS metrics and VS enrichment factors and aucdences for the given metric list."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlaunches a listener and return the compactor context.", "response": "def listen(identifier):\n  \"\"\"\n  Launch a listener and return the compactor context.\n  \"\"\"\n\n  context = Context()\n  process = WebProcess(identifier)\n\n  context.spawn(process)\n\n  log.info(\"Launching PID %s\", process.pid)\n\n  return process, context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nuploading a file to the Puush account.", "response": "def upload(self, f):\n        \"\"\"Upload a file to the Puush account.\n        \n        Parameters:\n            * f: The file. Either a path to a file or a file-like object.\n        \"\"\"\n        if hasattr(f, 'read'):\n            needs_closing = False\n        else:\n            f = open(f, 'rb')\n            needs_closing = True\n        # The Puush server can't handle non-ASCII filenames.\n        # The official Puush desktop app actually substitutes ? for\n        # non-ISO-8859-1 characters, which helps some Unicode filenames,\n        # but some are still let through and encounter server errors.\n        # Try uploading a file named \u00e5\u00e4\u00f6.txt through the desktop app -\n        # it won't work. It's better to let this Python API do that,\n        # however, with the behavior probably intended in the desktop app.\n        filename = os.path.basename(f.name).encode('ascii', 'replace')\n        filename = filename.decode('ascii') # Requests doesn't like bytes\n        md5 = md5_file(f)\n        \n        data = {\n            'z': 'meaningless',\n            'c': md5\n        }\n        files = {\n            'f': (filename, f)\n        }\n        \n        res = self._api_request('up', data=data, files=files)[0]\n        if res[0] == '-1':\n            raise PuushError(\"File upload failed.\")\n        elif res[0] == '-3':\n            raise PuushError(\"File upload failed: hash didn't match with \"\n                \"the file the server received.\")\n        \n        if needs_closing:\n            f.close()\n        \n        _, url, id, size = res\n        now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        return self._File(id, url, filename, now, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, id):\n        res = self._api_request('del', data={'i': id})[0]\n        if res[0] == '-1':\n            raise PuushError(\"File deletion failed.\")", "response": "Delete a file.\n        \n        Parameters:\n            * id: The Puush ID of the file to delete."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef thumbnail(self, id):\n        res = self._raw_api_request('thumb', data={'i': id})\n        if not res:\n            raise PuushError(\"Getting thumbnail failed.\")\n        return res", "response": "Get the 100x100 thumbnail of a Puush file. Return the raw PNG data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef history(self):\n        res = self._api_request('hist')\n        if res[0][0] == '-1':\n            raise PuushError(\"History retrieval failed.\")\n        \n        files = []\n        for line in res[1:]:\n            id, upload_time, url, filename, views, _ = line\n            files.append(self._File(id, url, filename, upload_time, views))\n        return files", "response": "Get the latest 10 files uploaded to the account."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove C and Javascript style comments from the given text.", "response": "def remove_comments(text):\n    \"\"\"Remove C and Javascript style comments like // [...] and /* [...] */ from\n    the given text.\n    \"\"\"\n    def _replacer(match):\n        # if the 2nd group (capturing comments) is not None,\n        # it means we have captured a non-quoted (real) comment string.\n        if match.group(2) is not None:\n            return \"\"  # so we will return empty to remove the comment\n        else:  # otherwise, we will return the 1st group\n            return match.group(1)  # captured quoted-string\n\n    return COMMENT_PATTERN.sub(_replacer, text)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prepare_value(self, value):\n        if value is None and self.required:\n            choices =list(self.choices)\n            if len(choices) == 1:\n                value = choices[0][0]\n        return super(TemplateChoiceField, self).prepare_value(value)", "response": "This method is used to prepare the value for the field."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert value into float or returns default when conversion is not possible.", "response": "def to_float_with_default(value, default_value):\n        \"\"\"\n        Converts value into float or returns default when conversion is not possible.\n\n        :param value: the value to convert.\n\n        :param default_value: the default value.\n\n        :return: float value or default value when conversion is not supported.\n        \"\"\"\n        result = FloatConverter.to_nullable_float(value)\n        return result if result != None else default_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef normalize_path(path, base_path=u'/', is_dir=None):\n    path = posixpath.normpath(path)\n\n    base_path = posixpath.normpath(base_path)\n\n    if len(base_path) == 0:\n        raise ValueError(u'`project_root` cannot be an empty string after normalization')\n\n    if base_path[-1] != u'/':\n        base_path += u'/'\n\n    if path.startswith(base_path):\n        path = u'/' + posixpath.relpath(path, base_path)\n    elif path.startswith(u'/'):\n        raise ValueError(u'`path` ({}) is absolute but not inside base_path ({})'.format(path,\n                                                                                         base_path))\n\n    if is_dir is None:\n        return path\n    elif is_dir and path[-1:] != u'/':\n        return path + u'/'\n    elif not is_dir and path[-1:] == u'/':\n        return path[:-1]\n\n    return path", "response": "u Normalizes a path to use it with a gitmatch pattern."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create(self, name):\n        self.params.update({'name': name})\n        return FromUrl('https://slack.com/api/channels.create', self._requests)(data=self.params).post()", "response": "Create a new channel with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the slack channel history.", "response": "def history(self, channel_name, **kwargs):\n        \"\"\" https://api.slack.com/methods/channels.history\n        \"\"\"\n        channel_id = self.get_channel_id(channel_name)\n        self.params.update({'channel': channel_id})\n        if kwargs:\n            self.params.update(kwargs)\n        return FromUrl('https://slack.com/api/channels.history', self._requests)(data=self.params).get()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef info(self, channel_name):\n        channel_id = self.get_channel_id(channel_name)\n        self.params.update({'channel': channel_id})\n        return FromUrl('https://slack.com/api/channels.info', self._requests)(data=self.params).get()", "response": "Returns the channel s info."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninvite a user to a channel", "response": "def invite(self, channel_name, user):\n        \"\"\" https://api.slack.com/methods/channels.invite\n        \"\"\"\n        channel_id = self.get_channel_id(channel_name)\n        self.params.update({\n            'channel': channel_id,\n            'user':    user,\n            })\n        return FromUrl('https://slack.com/api/channels.invite', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef join(self, channel_name):\n        self.params.update({\n            'name': channel_name,\n            })\n        return FromUrl('https://slack.com/api/channels.join', self._requests)(data=self.params).post()", "response": "Join a channel with a specific ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmarks the current time for a channel.", "response": "def mark(self, channel_name, ts):\n        \"\"\" https://api.slack.com/methods/channels.mark\n        \"\"\"\n        channel_id = self.get_channel_id(channel_name)\n        self.params.update({\n            'channel':  channel_id,\n            'ts':       ts,\n            })\n        return FromUrl('https://slack.com/api/channels.mark', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rename(self, channel_name, new_name):\n        channel_id = self.get_channel_id(channel_name)\n        self.params.update({\n            'channel':  channel_id,\n            'name':     new_name,\n            })\n        return FromUrl('https://slack.com/api/channels.rename', self._requests)(data=self.params).post()", "response": "Rename the current user s user s domain."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the purpose of a channel.", "response": "def set_purpose(self, channel_name, purpose):\n        \"\"\" https://api.slack.com/methods/channels.setPurpose\n        \"\"\"\n        channel_id = self.get_channel_id(channel_name)\n        self.params.update({\n            'channel': channel_id,\n            'purpose': purpose,\n            })\n        return FromUrl('https://slack.com/api/channels.setPurpose', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_topic(self, channel_name, topic):\n        channel_id = self.get_channel_id(channel_name)\n        self.params.update({\n            'channel': channel_id,\n            'topic': topic,\n            })\n        return FromUrl('https://slack.com/api/channels.setTopic', self._requests)(data=self.params).post()", "response": "Set the topic of a channel."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nposting a message to a specific user.", "response": "def post_message(self, channel, text, **kwargs):\n        \"\"\" https://api.slack.com/methods/chat.postMessage\n        \"\"\"\n        if not channel.startswith('#'):\n            channel = '#' + channel\n        self.params.update({\n            'channel': channel,\n            'text':    text,\n            })\n        if kwargs:\n            self.params.update(kwargs)\n        return FromUrl('https://slack.com/api/chat.postMessage', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef info(self, file, **kwargs):\n        self.params.update({\n            'file': file,\n            })\n        if kwargs:\n            self.params.update(kwargs)\n        return FromUrl('https://slack.com/api/files.info', self._requests)(data=self.params).get()", "response": "Returns the file s info."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading a new item to the Slack server.", "response": "def upload(self, **kwargs):\n        \"\"\" https://api.slack.com/methods/files.upload\n        \"\"\"\n        if kwargs:\n            self.params.update(kwargs)\n        return FromUrl('https://slack.com/api/files.upload', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all the users in the group.", "response": "def list(self, **kwargs):\n        \"\"\" https://api.slack.com/methods/groups.list\n        \"\"\"\n        if kwargs:\n            self.params.update(kwargs)\n        return FromUrl('https://slack.com/api/groups.list', self._requests)(data=self.params).get()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the group s history.", "response": "def history(self, group_name, **kwargs):\n        \"\"\" https://api.slack.com/methods/groups.history\n        \"\"\"\n        group_id = self.get_group_id(group_name)\n        self.params.update({\n            'channel': group_id,\n            })\n        if kwargs:\n            self.params.update(kwargs)\n        return FromUrl('https://slack.com/api/groups.history', self._requests)(data=self.params).get()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef invite(self, group_name, user):\n        group_id = self.get_group_id(group_name)\n        self.params.update({\n            'channel': group_id,\n            'user':    user,\n            })\n        return FromUrl('https://slack.com/api/groups.invite', self._requests)(data=self.params)", "response": "Invite a user to a group"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef kick(self, group_name, user):\n        group_id = self.get_group_id(group_name)\n        self.params.update({\n            'channel': group_id,\n            'user':    user,\n            })\n        return FromUrl('https://slack.com/api/groups.kick', self._requests)(data=self.params).post()", "response": "Kick the current group from a user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mark(self, group_name, ts):\n        group_id = self.get_group_id(group_name)\n        self.params.update({\n            'channel': group_id,\n            'ts':      ts,\n            })\n        return FromUrl('https://slack.com/api/groups.mark', self._requests)(data=self.params).post()", "response": "Mark the current state of a user in a group."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenames the current group s current language.", "response": "def rename(self, group_name, new_name):\n        \"\"\" https://api.slack.com/methods/groups.rename\n        \"\"\"\n        group_id = self.get_group_id(group_name)\n        self.params.update({\n            'channel': group_id,\n            'name':    new_name,\n            })\n        return FromUrl('https://slack.com/api/groups.rename', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_purpose(self, group_name, purpose):\n        group_id = self.get_group_id(group_name)\n        self.params.update({\n            'channel': group_id,\n            'purpose': purpose,\n            })\n        return FromUrl('https://slack.com/api/groups.setPurpose', self._requests)(data=self.params).post()", "response": "Set the purpose of a group."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_topic(self, group_name, topic):\n        group_id = self.get_group_id(group_name)\n        self.params.update({\n            'channel': group_id,\n            'topic':   topic,\n            })\n        return FromUrl('https://slack.com/api/groups.setTopic', self._requests)(data=self.params).post()", "response": "Set the topic for a group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclose an existing object.", "response": "def close(self, channel):\n        \"\"\" https://api.slack.com/methods/im.close\n        \"\"\"\n        self.params.update({\n            'channel': channel,\n            })\n        return FromUrl('https://slack.com/api/im.close', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef history(self, channel, **kwargs):\n        self.params.update({\n            'channel': channel,\n            })\n        if kwargs:\n            self.params.update(kwargs)\n        return FromUrl('https://slack.com/api/im.history', self._requests)(data=self.params).get()", "response": "Returns a list of the current state of a specific user."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmarks the current state of a user in a channel.", "response": "def mark(self, channel, ts):\n        \"\"\" https://api.slack.com/methods/im.mark\n        \"\"\"\n        self.params.update({\n            'channel': channel,\n            'ts':      ts,\n            })\n        return FromUrl('https://slack.com/api/im.mark', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nopens a user in the Slack.", "response": "def open(self, user):\n        \"\"\" https://api.slack.com/methods/im.history\n        \"\"\"\n        self.params.update({\n            'user': user,\n            })\n        return FromUrl('https://slack.com/api/im.open', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naccesses the slack API.", "response": "def access(self, client_id, client_secret, code, **kwargs):\n        \"\"\" https://api.slack.com/methods/oauth.access\n        \"\"\"\n        self.params.update({\n            'client_id':     client_id,\n            'client_secret': client_secret,\n            'code':          code,\n            })\n        if kwargs:\n            self.params.update(kwargs)\n        return FromUrl('https://slack.com/api/oauth.access', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef all(self, query, **kwargs):\n        self.url = 'https://slack.com/api/search.all'\n        return super(Search, self).search_from_url(query, **kwargs)", "response": "Search for all items in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsearches for files in the Slack API.", "response": "def files(self, query, **kwargs):\n        \"\"\" https://api.slack.com/methods/search.files\n        \"\"\"\n        self.url = 'https://slack.com/api/search.files'\n        return super(Search, self).search_from_url(query, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for messages from Slack API", "response": "def messages(self, query, **kwargs):\n        \"\"\" https://api.slack.com/methods/search.messages\n        \"\"\"\n        self.url = 'https://slack.com/api/search.messages'\n        return super(Search, self).search_from_url(query, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the presence of a user in a slab.", "response": "def get_presence(self, user_name):\n        \"\"\" https://api.slack.com/methods/users.getPresence\n        \"\"\"\n        user_id = self.get_id_by_name(user_name)\n        self.params.update({\n            'user': user_id,\n            })\n        return FromUrl('https://slack.com/api/users.getPresence', self._requests)(data=self.params).get()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the presence of a user", "response": "def set_presence(self, presence):\n        \"\"\" https://api.slack.com/methods/users.setPresence\n        \"\"\"\n        if presence not in ['auto', 'away']:\n            presence = 'auto'\n        self.params.update({\n            'presence': presence,\n            })\n        return FromUrl('https://slack.com/api/users.setPresence', self._requests)(data=self.params).post()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef info(self, user):\n        self.params.update({\n            'user': user,\n            })\n        return FromUrl('https://slack.com/api/users.info', self._requests)(data=self.params).get()", "response": "Returns the user s info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_recipients(self, name):\n        to_str = self.render_string(self.data[name])\n        formatted_emails = [\n            email.utils.formataddr(addr_pair)\n            for addr_pair in email.utils.getaddresses([to_str])\n        ]\n        return [i for i in formatted_emails if i]", "response": "Get the list of recipients for a given name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_info_field(prop):\n        if isinstance(prop, ColumnProperty):\n            column = prop.columns[0]\n\n        elif isinstance(prop, RelationshipProperty):\n            column = prop\n\n        return column.info", "response": "Return the info attribute of the given property"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an item to the registry", "response": "def add_item(self, sqla_col_type, item, key_specific=None):\n        \"\"\"\n        Add an item to the registry\n        \"\"\"\n        if key_specific is not None:\n            self.setdefault(key_specific, {})[sqla_col_type] = item\n        else:\n            self[sqla_col_type] = item"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a formatter to the registry", "response": "def add_formatter(self, sqla_col_type, formatter, key_specific=None):\n        \"\"\"\n        Add a formatter to the registry\n        if key_specific is provided, this formatter will only be used for some\n        specific exports\n        \"\"\"\n        self.add_item(sqla_col_type, formatter, key_specific)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef assert_xml_equal(first, second, check_tags_order=False):\n    _assert_xml_compare(_assert_xml_docs_are_equal, first, second, check_tags_order=check_tags_order)", "response": "Assert that two xml documents are equal."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_layout(self, orientation=None):\n        if orientation == QtCore.Qt.Horizontal or orientation is None:\n            layout = QtGui.QHBoxLayout()\n        elif orientation == QtCore.Qt.Vertical:\n            layout = QtGui.QVBoxLayout()\n        else:\n            raise TypeError('Orientation is of wrong type! Allowed is QtCore.Qt.Horizontal and QtCore.Qt.Vertical. Given: %s' % orientation)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(0)\n        self.setLayout(layout)", "response": "Setup the layout for the tooltip in the given orientation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_size(self, width, height):\n        self._iconw = max(0, width - 7)\n        self._iconh = max(0, height - 6)\n        self.update_all_buttons()", "response": "Set the width and height for one cell in the tooltip\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_cyatimer(self, interval):\n        self.cyatimer = QtCore.QTimer(self)\n        self.cyatimer.setSingleShot(True)\n        self.cyatimer.timeout.connect(self.hide)\n        self._interval = interval", "response": "Setup the timer that will close the widget after the mouse left the widget for the time of interval\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a button that has the given widget rendered as an icon", "response": "def create_button(self, widget):\n        \"\"\"Create a button that has the given widget rendered as an icon\n\n        :param widget: the widget to render as icon\n        :type widget: QtGui.QWidget\n        :returns: the created button\n        :rtype: QtGui.QAbstractButton\n        :raises: None\n        \"\"\"\n        btn = QtGui.QToolButton(self)\n        btn.setIconSize(QtCore.QSize(self._iconw, self._iconh))\n        self.update_button(btn, widget)\n        return btn"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the icon of the given button with the given widget.", "response": "def update_button(self, button, widget):\n        \"\"\"Update the icon of the button with the given widget\n\n        if the widget does not is invalid, it is deleted from the tooltip automatically.\n\n        :param button: the button to update\n        :type button: QtGui.QAbstractButton\n        :param widget: the widget to render as icon\n        :type widget: QtGui.QWidget\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not shiboken.isValid(widget):\n            self.remove_widget(widget)\n            return\n        button.setIconSize(QtCore.QSize(self._iconw, self._iconh))\n        pix = QtGui.QPixmap(widget.size())\n        widget.render(pix)\n        icon = QtGui.QIcon(pix)\n        button.setIcon(icon)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating all the buttons in the current taxonomy.", "response": "def update_all_buttons(self, ):\n        \"\"\"Update all buttons\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        for widget, button in self._buttons.items():\n            self.update_button(button, widget)\n        self.adjustSize()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfocuses the given widget.", "response": "def focus_widget(self, checked=None, w=None):\n        \"\"\"Focus the given widget. Checked is ignored and only used as a slot for QAbstractButton.clicked.\n\n        :param checked: The checked state of the button that was clicked\n        :type checked: bool\n        :param w: the widget to focus\n        :type w: QtGui.QWidget\n        :returns: None\n        :raises: None\n        \"\"\"\n        if w is None:\n            return\n        if w.isMinimized():\n            w.showNormal()\n        else:\n            w.show()\n        w.activateWindow()\n        w.setFocus()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the given widget to the tooltip.", "response": "def add_widget(self, widget):\n        \"\"\"Add the given widget to the tooltip\n\n        :param widget: the widget to add\n        :type widget: QtGui.QWidget\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if self._buttons.get(widget):\n            return\n        btn = self.create_button(widget)\n        cb = partial(self.focus_widget, w=widget)\n        btn.clicked.connect(cb)\n        self.layout().addWidget(btn)\n        self._buttons[widget] = btn"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the given widget from the tooltip", "response": "def remove_widget(self, widget):\n        \"\"\"Remove the given widget from the tooltip\n\n        :param widget: the widget to remove\n        :type widget: QtGui.QWidget\n        :returns: None\n        :rtype: None\n        :raises: KeyError\n        \"\"\"\n        button = self._buttons.pop(widget)\n        self.layout().removeWidget(button)\n        button.deleteLater()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef eventFilter(self, watched, event):\n        if event.type() == self._triggerevent:\n            self.show()\n            return True\n        else:\n            return False", "response": "Filter ToolTip events and display this tooltip widget if the event was passed on."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a recommended position for this widget to appear", "response": "def get_position(self, ):\n        \"\"\"Return a recommended position for this widget to appear\n\n        This implemenation returns a position so that the widget is vertically centerd on the mouse\n        and 10 pixels left of the mouse\n\n        :returns: the position\n        :rtype: QPoint\n        :raises: None\n        \"\"\"\n        pos = QtGui.QCursor.pos()\n        if self._alignment & QtCore.Qt.AlignLeft == QtCore.Qt.AlignLeft:\n            pos.setX(pos.x() - self._offset)\n        elif self._alignment & QtCore.Qt.AlignRight == QtCore.Qt.AlignRight:\n            pos.setX(pos.x() - self.frameGeometry().width() + self._offset)\n        elif self._alignment & QtCore.Qt.AlignHCenter == QtCore.Qt.AlignHCenter:\n            pos.setX(pos.x() - self.frameGeometry().width()/2)\n        if self._alignment & QtCore.Qt.AlignTop == QtCore.Qt.AlignTop:\n            pos.setY(pos.y() - self._offset)\n        elif self._alignment & QtCore.Qt.AlignBottom == QtCore.Qt.AlignBottom:\n            pos.setY(pos.y() - self.frameGeometry().height() + self._offset)\n        elif self._alignment & QtCore.Qt.AlignVCenter == QtCore.Qt.AlignVCenter:\n            pos.setY(pos.y() - self.frameGeometry().height()/2)\n        return pos"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_issue(self, branch):\n        if branch:\n            try:\n                issue = self.issue(branch, expand='changelog')\n                return issue\n            except jira.exceptions.JIRAError as ex:\n                if ex.status_code == 404:\n                    print \"No JIRA issue found for branch %s\" % branch\n                else:\n                    print str(ex)", "response": "Returns the JIRA issue associated with the branch name. Returns None if no issue with this branch name exists."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_elapsed_time(self, issue):\n        last_mark = None\n\n        # Get the last mark from the work logs\n        worklogs = self.get_worklog(issue)\n        if worklogs:\n            last_worklog = worklogs[-1]\n            last_mark = dateutil.parser.parse(last_worklog.raw['updated'])\n\n        # If no worklogs, get the time since the issue was marked In Progress\n        if not last_mark:\n            last_mark = self.get_datetime_issue_in_progress(issue)\n\n        if last_mark:\n            now = datetime.datetime.now(dateutil.tz.tzlocal())\n            delta = now - last_mark\n            minutes = int(utils.timedelta_total_seconds(delta) / 60)\n            if minutes > 0:\n                return str(minutes) + 'm'\n            else:\n                return None", "response": "Gets the elapsed time since the last mark of the issue"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef workflow_transition(self, issue, status_name):\n        transitions = self.transitions(issue)\n        for transition in transitions:\n            if transition['to']['name'] == status_name:\n                transition_id = transition['id']\n                self.transition_issue(issue, transition_id)\n                print \"Changed status of issue %s to %s\" % (issue.key, status_name)\n                return True\n\n        print \"Unable to change status of issue %s to %s\" % (issue.key, status_name)", "response": "Change the status of a JIRA issue to a named status."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the most recent time that the issue became In Progress", "response": "def get_datetime_issue_in_progress(self, issue):\n        \"\"\"\n        If the issue is in progress, gets that most recent time that the issue became 'In Progress'\n        \"\"\"\n        histories = issue.changelog.histories\n        for history in reversed(histories):\n            history_items = history.items\n            for item in history_items:\n                if item.field == 'status' and item.toString == \"In Progress\":\n                    return dateutil.parser.parse(history.created)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntouches the last worklog for an issue.", "response": "def touch_last_worklog(self, issue):\n        \"\"\"\n        Touch the last worklog for an issue (changes the updated date on the worklog).  We use this date as the 'mark' for\n        determining the time elapsed for the next log entry.\n        \"\"\"\n        worklogs = self.get_worklog(issue)\n        if worklogs:\n            last_worklog = worklogs[-1]\n            last_worklog.update()\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the cycle time since the start or progress of the issue or start datetime", "response": "def get_cycle_time(self, issue_or_start_or_key):\n        \"\"\"\n        Provided an issue or a start datetime, will return the cycle time since the start or progress\n        \"\"\"\n        if isinstance(issue_or_start_or_key, basestring):\n            issue_or_start_or_key = self.get_issue(issue_or_start_or_key)\n\n        if isinstance(issue_or_start_or_key, jira.resources.Issue):\n            progress_started = self.get_datetime_issue_in_progress(issue_or_start_or_key)\n        elif isinstance(issue_or_start_or_key, datetime.datetime):\n            progress_started = issue_or_start_or_key\n\n        curr_time = datetime.datetime.now(dateutil.tz.tzlocal())\n        return utils.working_cycletime(progress_started, curr_time)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the average cycletime of the current user for the past week.", "response": "def get_week_avg_cycletime(self):\n        \"\"\"\n        Gets the average cycletime of the current user for the past week.\n        This includes any ticket that was marked \"In Progress\" but not reopened.\n        \"\"\"\n        def moving_average(new_val, old_avg, prev_n):\n            return (new_val + old_avg) / (prev_n + 1)\n\n        active_tickets_jql = 'assignee=currentUser() and status was \"In Progress\" DURING (startOfWeek(), endofweek()) and status not in (Backlog, Open) ORDER BY updated DESC'\n\n        week_active_tickets = self.search_issues(active_tickets_jql)\n\n        avg_cycletime = 0\n        n_issues = 0\n        for issue in week_active_tickets:\n            cycle_time = self.get_cycle_time(self.get_issue(issue.key))\n            avg_cycletime = moving_average(cycle_time, avg_cycletime, n_issues)\n            n_issues = n_issues + 1\n\n        return avg_cycletime"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield lines from handle with E - value less than or equal to e_value Returns a generator of all B6 entries in the order of E - value in the file", "response": "def b6_evalue_filter(handle, e_value, *args, **kwargs):\n    \"\"\"Yields lines from handle with E-value less than or equal to e_value\n\n    Args:\n        handle (file): B6/M8 file handle, can be any iterator so long as it\n            it returns subsequent \"lines\" of a B6/M8 entry\n\n        e_value (float): max E-value to return\n\n        *args: Variable length argument list for b6_iter\n\n        **kwargs: Arbitrary keyword arguments for b6_iter\n\n    Yields:\n        B6Entry: class containing all B6/M8 data\n\n    Example:\n        Note: These doctests will not pass, examples are only in doctest\n        format as per convention. bio_utils uses pytests for testing.\n\n        >>> b6_handle = open('test.b6')\n        >>> for entry in b6_evalue_filter(b6_handle, 1e5)\n        ...     print(entry.evalue)  # Print E-value of filtered entry\n    \"\"\"\n\n    for entry in b6_iter(handle, *args, **kwargs):\n        if entry.evalue <= e_value:\n            yield entry"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main():\n\n    for entry in b6_evalue_filter(args.b6, args.e_value):\n        args.output.write(entry.write())", "response": "Open B6 file filter entries by E - Value and write said entries"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_model(self):\n        '''Find out the type of model configured and dispatch the request to the appropriate method'''\n        if self.model_config['model-type']:\n            return self.build_red()\n        elif self.model_config['model-type']:\n            return self.buidl_hred()\n        else:\n            raise Error(\"Unrecognized model type '{}'\".format(self.model_config['model-type']))", "response": "Find out the type of model configured and dispatch the request to the appropriate method"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_fred(self):\n        '''Build a flat recurrent encoder-decoder dialogue model'''\n\n        encoder = Encoder(data=self.data, config=self.model_config)\n        decoder = Decoder(data=self.data, config=self.model_config, encoder=encoder)\n\n        return EncoderDecoder(config=self.model_config, encoder=encoder, decoder=decoder)", "response": "Build a flat recurrent encoder - decoder dialogue model"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a list of Transfer objects", "response": "def get(self, limit=None, offset=None):\n        \"\"\"\n        :param offset:         int of the offset to use\n        :param limit:          int of max number of puzzles to return\n        :return:               list of Transfer dict\n        \"\"\"\n        return self.connection.get('account/transfer/admin/array', limit=limit, offset=offset)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef put(self, deposit_account_id, amount, receipt):\n        return self.connection.put('account/transfer/deposit',\n                                   data=dict(deposit_account_id=deposit_account_id,\n                                             amount=amount,\n                                             receipt=receipt))", "response": "Sends a transfer to the account"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget all the Transfer objects for a given account_id", "response": "def get(self, account_id, withdraws_only=None, limit=None, offset=None):\n        \"\"\"\n        :param account_id:     int of the account_id to get transfer for\n        :param withdraws_only: bool if true only gets withdraw transfer if false only gets deposit, default gets both\n        :param offset:         int of the offset to use\n        :param limit:          int of max number of puzzles to return\n        :return:               list of Transfer dict\n        \"\"\"\n        return self.connection.get('account/transfer/array',\n                                   account_id=account_id,\n                                   withdraws_only=withdraws_only,\n                                   limit=limit,\n                                   offset=offset)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the current evaluation of a condition statement", "response": "def value(self):\n        \"\"\"\n        Return the current evaluation of a condition statement\n        \"\"\"\n        return ''.join(map(str, self.evaluate(self.trigger.user)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the identifiers and scores of the judged paragraphs from the input file.", "response": "def get_judged_identifiers(input_file):\n    \"\"\"\n    Extracts the paragraph identifiers, and the scores of the judged paragraphs from relevance\n    judgements in the NTCIR-11 Math-2, and NTCIR-12 MathIR format.\n\n    Parameters\n    ----------\n    input_file : file\n        The input file containing relevance judgements in the NTCIR-11 Math-2, and NTCIR-12 MathIR\n        format.\n\n    Yields\n    ------\n    (str, float)\n        The judged paragraph identifiers, and scores.\n    \"\"\"\n    for line in tqdm(list(input_file)):\n        _, __, identifier, score = line.split(' ')\n        yield (identifier, float(score))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_all_identifiers(dataset):\n    for document in tqdm(\n            dataset.glob(\"**/*.xhtml.zip\"), desc=\"get_all_identifiers(%s)\" % dataset.name):\n        identifier = get_identifier(document)\n        directory = document.parents[0]\n        yield (directory, identifier)", "response": "Returns a generator that yields all the paragraph identifiers in the NTCIR - 11 Math - 2 MathIR XHTML5\n    format."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the position of a paragraph from the identifier and the parent directory of the the .", "response": "def get_position(directory, identifier):\n    \"\"\"\n    Extracts the position of a paragraph from the identifier, and the parent directory of the\n    paragraph.\n\n    Parameters\n    ----------\n    directory : Path\n        A parent directory of a paragraph.\n    identifier : str\n        An identifier of a paragraph.\n\n    Returns\n    -------\n    float\n        The estimated position of the paragraph in the range [0; 1).\n    \"\"\"\n    paragraph_number = get_paragraph_number(identifier)\n    paragraph_total = max(  # Not all paragraphs are stored, e.g. because of processing errors.\n        get_paragraph_number(get_identifier(document)) + 1\n        for document in directory.iterdir())\n    assert paragraph_total > paragraph_number and paragraph_total > 0\n    position = paragraph_number / paragraph_total\n    return position"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a generator that yields all the paragraph identifiers and positions of the dataset in the NTCIR - 11 Math - 2 MathIR XHTML5 format.", "response": "def get_all_positions(dataset, num_workers=1):\n    \"\"\"\n    Extracts paragraph identifiers, and positions from a dataset in the NTCIR-11 Math-2, and\n    NTCIR-12 MathIR XHTML5 format.\n\n    Parameters\n    ----------\n    dataset : Path\n        A path to a dataset.\n    num_workers : int, optional\n        The number of processes that will extract paragraph positions from the dataset.\n\n    Yields\n    -------\n    (Path, str, float)\n        A parent directory of a paragraph, the identifier of the paragraph, and an estimate of the\n        position of the paragraph in its parent document. The position is in the range [0; 1).\n    \"\"\"\n    positions = []\n    identifiers = tqdm(\n        list(get_all_identifiers(dataset)), desc=\"get_all_positions(%s)\" % dataset.name)\n    with Pool(num_workers) as pool:\n        for directory, identifier, position in pool.map(_get_position_worker, identifiers):\n            positions.append((directory, identifier, position))\n    for directory, identifier, position in positions:\n        yield (directory, identifier, position)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_estimators(positions_all, positions_relevant):\n    samples_all = [\n        (position,) for _, positions in positions_all.items() for position in positions]\n    samples_relevant = [\n        (position,) for _, positions in positions_relevant.items() for position in positions]\n    estimators = dict()\n    estimators[\"P(relevant)\"] = len(samples_relevant) / len(samples_all)\n    LOGGER.info(\"Fitting prior p(position) density estimator\")\n    estimators[\"p(position)\"] = KernelDensity(**KERNEL).fit(samples_all)\n    LOGGER.info(\"Fitting conditional p(position | relevant) density estimator\")\n    estimators[\"p(position|relevant)\"] = KernelDensity(**KERNEL).fit(samples_relevant)\n    return (\n        estimators[\"P(relevant)\"], estimators[\"p(position)\"], estimators[\"p(position|relevant)\"])", "response": "Extracts density estimators from a judged sample of paragraph positions."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new unweighted version of the given set of densities and probabilities for a given set of paragraphs.", "response": "def get_estimates(estimators_tuple, positions, num_workers=1):\n    \"\"\"\n    Estimates densities, and probabilities for paragraph positions.\n\n    Parameters\n    ----------\n    estimators_tuple : (float, KernelDensity, KernelDensity)\n        An estimate of the prior probability P(relevant), an estimator of the prior density\n        p(position), and an estimator of the conditional density p(position | relevant).\n    positions : iterable of float\n        Paragraph positions for which densities, and probabilities will be estimated.\n    num_workers : int, optional\n        The number of processes that will compute the estimates.\n\n    Returns\n    -------\n    five-tuple of (sequence of float)\n        Estimates of P(relevant), p(position), p(position | relevant), P(position, relevant), and\n        P(relevant | position) in the form of histograms.\n    \"\"\"\n    estimators = dict()\n    estimators[\"P(relevant)\"], estimators[\"p(position)\"], \\\n        estimators[\"p(position|relevant)\"] = estimators_tuple\n\n    log_estimates = dict()\n    log_estimates[\"P(relevant)\"] = log(estimators[\"P(relevant)\"])\n    X = [(position,) for position in positions]\n    with Pool(num_workers) as pool:\n        first_job = pool.map_async(estimators[\"p(position)\"].score_samples, tqdm(\n            array_split(X, num_workers), desc=\"p(position)\"))\n        second_job = pool.map_async(estimators[\"p(position|relevant)\"].score_samples, tqdm(\n            array_split(X, num_workers), desc=\"p(position | relevant)\"))\n        log_estimates[\"p(position)\"] = concatenate(first_job.get())\n        log_estimates[\"p(position|relevant)\"] = concatenate(second_job.get())\n    log_estimates[\"P(position,relevant)\"] = \\\n        log_estimates[\"p(position|relevant)\"] + log_estimates[\"P(relevant)\"]\n    log_estimates[\"P(relevant|position)\"] = \\\n        log_estimates[\"P(position,relevant)\"] - log_estimates[\"p(position)\"]\n    return (\n        [estimators[\"P(relevant)\"]] * len(X), exp(log_estimates[\"p(position)\"]),\n        exp(log_estimates[\"p(position|relevant)\"]), exp(log_estimates[\"P(position,relevant)\"]),\n        exp(log_estimates[\"P(relevant|position)\"]))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating mkdocs build command to build the site.", "response": "def _get_build_command(self, mkdocs_site_path: Path) -> str:\n        '''Generate ``mkdocs build`` command to build the site.\n\n        :param mkdocs_site_path: Path to the output directory for the site\n        '''\n\n        components = [self._mkdocs_config.get('mkdocs_path', 'mkdocs')]\n        components.append('build')\n        components.append(f'-d \"{self._escape_control_characters(str(mkdocs_site_path))}\"')\n\n        command = ' '.join(components)\n\n        self.logger.debug(f'Build command: {command}')\n\n        return command"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_ghp_command(self) -> str:\n        '''Generate ``mkdocs gh-deploy`` command to deploy the site to GitHub Pages.'''\n\n        components = [self._mkdocs_config.get('mkdocs_path', 'mkdocs')]\n        components.append('gh-deploy')\n\n        command = ' '.join(components)\n\n        self.logger.debug(f'GHP upload command: {command}')\n\n        return command", "response": "Generate the command to deploy the site to GitHub Pages."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the content of first heading of source Markdown file if the file MimeType contains any headings. Return a data element of pages section of mkdocs. yml file.", "response": "def _get_page_with_optional_heading(self, page_file_path: str) -> str or Dict:\n        '''Get the content of first heading of source Markdown file, if the file\n        contains any headings. Return a data element of ``pages`` section\n        of ``mkdocs.yml`` file.\n\n        :param page_file_path: path to source Markdown file\n\n        :returns: Unchanged file path or a dictionary: content of first heading, file path\n        '''\n\n        self.logger.debug(f'Looking for the first heading in {page_file_path}')\n\n        if page_file_path.endswith('.md'):\n            page_file_full_path = self.project_path / self.config['src_dir'] / page_file_path\n\n            with open(page_file_full_path, encoding='utf8') as page_file:\n                content = page_file.read()\n                headings_found = search(\n                    r'^\\s*#{1,6}[ \\t]+([^\\r\\n]+?)(?:[ \\t]+\\{#\\S+\\})?\\s*[\\r\\n]+',\n                    content\n                )\n\n                if headings_found:\n                    first_heading = headings_found.group(1)\n                    self.logger.debug(f'Heading found: {first_heading}')\n                    return {first_heading: page_file_path}\n\n        self.logger.debug(f'No heading found, returning original file path.')\n\n        return page_file_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the pages section of mkdocs. yml file with the content of top - level headings of source Markdown files.", "response": "def _get_pages_with_headings(self, pages: Dict) -> Dict:\n        '''Update ``pages`` section of ``mkdocs.yml`` file with the content\n        of top-level headings of source Markdown files.\n\n        param pages: Dictionary with the data of ``pages`` section\n\n        returns: Updated dictionary\n        '''\n\n        def _recursive_process_pages(pages_subset, parent_is_dict):\n            if isinstance(pages_subset, dict):\n                new_pages_subset = {}\n                for key, value in pages_subset.items():\n                    if not key:\n                        key = self._mkdocs_config.get('default_subsection_title', '\u2026')\n\n                    new_pages_subset[key] = _recursive_process_pages(value, True)\n\n            elif isinstance(pages_subset, list):\n                new_pages_subset = []\n                for item in pages_subset:\n                    new_pages_subset.append(_recursive_process_pages(item, False))\n\n            elif isinstance(pages_subset, str):\n                if not parent_is_dict:\n                    new_pages_subset = self._get_page_with_optional_heading(pages_subset)\n\n                else:\n                    new_pages_subset = pages_subset\n\n            else:\n                new_pages_subset = pages_subset\n\n            return new_pages_subset\n\n        new_pages = _recursive_process_pages(pages, False)\n\n        self.logger.debug(f'All pages with their headings: {new_pages}')\n\n        return new_pages"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extract_attributes(element, prefix_key_char='@', dict_constructor=dict):\n    result = dict_constructor()\n    if element.properties:\n        for prop in element.properties:\n            if not prop:\n                break\n            if prop.type == 'attribute':\n                try:\n                    # First try with namespace. If no namespace exists,\n                    # an exception is raised\n                    result[\"%s%s:%s\" % (prefix_key_char, prop.ns().name, prop.name)] = prop.content\n                except:\n                    result[\"%s%s\" % (prefix_key_char, prop.name)] = prop.content\n    return result", "response": "Given an XML node extract a dictionary of attribute key - value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wrap_json_body(func=None, *, preserve_raw_body=False):\n\n    if func is None:\n        return functools.partial(\n            wrap_json_body,\n            preserve_raw_body=preserve_raw_body\n        )\n\n    @functools.wraps(func)\n    def wrapper(request, *args, **kwargs):\n        ctype, pdict = parse_header(request.headers.get('Content-Type', ''))\n        if preserve_raw_body:\n            request.raw_body = request.body\n        if ctype == \"application/json\":\n            request.body = json.loads(request.body.decode(\"utf-8\")) if request.body else None\n        return func(request, *args, **kwargs)\n    return wrapper", "response": "A middleware that parses the body of json requests and adds it to the request s body attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading in input file and run functions", "response": "def run(itf):\n    \"\"\"\n\tRun preprocess functions\n\t\"\"\"\n\n    if not itf:\n        return 1\n\n    # access command-line arguments\n    options = SplitInput(itf)\n\n    # read input\n    infile = os.path.abspath(options.input)\n    molList = read_csv(infile, options)\n\n    # split molList into actives and decoys\n    activeList, decoyList = partition(molList, options)\n\n    # split actives and decoys into training and validation sets\n    trainset, valset = split(activeList, decoyList, options)\n\n    # write csv files formatted for ensemble builder\n    csv_writer(trainset, options, 'training_set')\n    csv_writer(valset, options, 'test_set')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_csv_header(mol, csv_writer):\n\n    # create line list where line elements for writing will be stored\n    line = []\n\n    # ID\n    line.append('id')\n\n    # status\n    line.append('status')\n\n    # query labels\n    queryList = mol.properties.keys()\n    for queryLabel in queryList:\n        line.append(queryLabel)\n\n    # write line\n    csv_writer.writerow(line)", "response": "write the csv header"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_csv_line(mol, csv_writer, options):\n\n    # set variables\n    status_field = options.status_field\n\n    # elements for writing will be stored in the line list\n    line = []\n\n    # ID\n    id = mol.GetProp('id')\n    if id is not None:\n        line.append(id)\n    else:\n        line.append('n/a')\n\n    # status\n    line.append(mol.GetProp(status_field))\n\n    # query labels\n    queryList = mol.properties.keys()\n    for queryLabel in queryList:\n        line.append(mol.properties[queryLabel])\n\n    # write line\n    csv_writer.writerow(line)", "response": "Parse a Molecule object and write a line to the csv file\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef csv_writer(molecules, options, prefix):\n\n    # output file\n    outdir = os.getcwd()\n    filename = prefix + '.csv'\n    outfile = os.path.join(outdir, filename)\n\n    # initiate csv writer object\n    f = open(outfile, 'w')\n    csv_writer = csv.writer(f)\n\n    # write csv header\n    mol = molecules[0]\n    write_csv_header(mol, csv_writer)\n\n    # write csv lines\n    for mol in molecules:\n        write_csv_line(mol, csv_writer, options)\n\n    # close file\n    f.close()", "response": "Write a csv file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef split(activeList, decoyList, options):\n\n    # set input variables\n    training_fraction = options.training_fraction\n    decoy_to_active = options.decoy_to_active\n\n    # take care of default decoy_to_active ratio\n    if decoy_to_active is None:\n        decoy_to_active = len(decoyList) / len(activeList)\n\n    # verify that there are enough molecules to satisfy the ratio\n    if len(decoyList) < (len(activeList) * decoy_to_active):\n        max = len(decoyList) / len(activeList)\n        print(\"\\n The maximum decoy to active ratio the input file will support is {f} \\n\".format(f=max))\n        sys.exit(1)\n\n    # randomly split the actives\n    trainsize = int(round(training_fraction * len(activeList)))\n\n    trainIndex = []\n    valIndex = []\n    trainIndex = random.sample(range(len(activeList)), trainsize)\n    valIndex = [x for x in range(len(activeList)) if x not in trainIndex]\n\n    trainactives = [activeList[index] for index in trainIndex]\n    valactives = [activeList[index] for index in valIndex]\n\n    # match up decoys\n    trainsize = len(trainactives) * decoy_to_active\n    valsize = len(valactives) * decoy_to_active\n\n    trainIndex = []\n    valIndex = []\n    trainIndex = random.sample(range(len(decoyList)), int(trainsize))\n    valIndex = [x for x in range(len(decoyList)) if x not in trainIndex][0:int(valsize)]\n\n    traindecoys = [decoyList[index] for index in trainIndex]\n    valdecoys = [decoyList[index] for index in valIndex]\n\n    # merge actives and decoys for each set\n    trainset = trainactives + traindecoys\n    valset = valactives + valdecoys\n\n    # return sets\n    return trainset, valset", "response": "Create training and validation sets for each item in activeList."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\npartitioning molList into activeList and decoyList", "response": "def partition(molList, options):\n    \"\"\"\n\tPartition molList into activeList and decoyList\n\t\"\"\"\n    # set input variables\n    status_field = options.status_field\n    active_label = options.active_label\n    decoy_label = options.decoy_label\n\n    # initiate lists\n    activeList = []\n    decoyList = []\n\n    # partition moList\n    for mol in molList:\n        if mol.GetProp(status_field) == active_label:\n            activeList.append(mol)\n        elif mol.GetProp(status_field) == decoy_label:\n            decoyList.append(mol)\n\n    # return partitions\n    return activeList, decoyList"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a CSV file and return molList a list of mol objects", "response": "def read_csv(csvfile, options):\n    \"\"\"\n\tRead csv and return molList, a list of mol objects\n\t\"\"\"\n\n    # open file or exit\n    name, ext = os.path.splitext(csvfile)\n    try:\n        if ext == '.gz':\n            f = gzip.open(csvfile, 'rb')\n        else:\n            f = open(csvfile, 'rU')\n    except IOError:\n        print(\" \\n '{f}' could not be opened\\n\".format(f=os.path.basename(csvfile)))\n        sys.exit(1)\n\n    # read file\n    csv_reader = csv.reader(f)\n    molList = []\n    linenumber = 1\n\n    for line in csv_reader:\n        # get column labels from the first line\n        if linenumber == 1:\n            prop_indices = read_header(line, options)\n\n        # otherwise read line & append to MolList\n        else:\n            mol = Molecule()\n            mol = read_line(line, options, prop_indices, mol)\n            # if the line's junk, skip it\n            if mol == 1:\n                print(\" skipping molecule 'm'\\n\".format(m=(linenumber - 1)))\n            else:\n                molList.append(mol)\n\n        linenumber += 1\n\n    # return molList\n\n    return molList"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread a single line of a molecule", "response": "def read_line(csv_contents, options, prop_indices, mol):\n    \"\"\"\n\tread csv line\n\t\"\"\"\n\n    # set input variables\n    status_field = options.status_field\n    active_label = options.active_label\n    decoy_label = options.decoy_label\n\n    # confirm the active/decoy labels have appropriate values\n    # otherwise skip molecule\n    active_value_matcher = re.compile(active_label)\n    decoy_value_matcher = re.compile(decoy_label)\n    status_label_index = prop_indices[status_field]\n\n    if not active_value_matcher.match(csv_contents[status_label_index]) and not decoy_value_matcher.match(\n            csv_contents[status_label_index]):\n        print(\"\\n molecule lacks appropriate status label\")\n        return 1\n\n    # loop over property values\n    for prop_label in prop_indices.keys():\n        # get property value\n        value_index = prop_indices[prop_label]\n        prop_value = csv_contents[value_index]\n\n        # set corresponding molecule attribute\n        mol.SetProp(prop_label, prop_value)\n\n    # return mol\n    return mol"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_header(headerlabels, options):\n\n    # set input variables\n    status_field = options.status_field\n\n    # confirm that status_field exists\n    status_field_matcher = re.compile(status_field)\n    if not any(x for x in headerlabels if status_field_matcher.match(x)):\n        print(\"\\n The status_field column '{s}' doesn't exist\\n\".format(s=status_field))\n        sys.exit(1)\n\n    # initiate prop_column dictionary and csv column index\n    prop_indices = {}\n    index = 0\n\n    for label in headerlabels:\n        prop_indices[label] = index\n        index += 1\n\n    return prop_indices", "response": "read csv header returns prop_indices dictionary"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the property of the object.", "response": "def SetProp(self, prop, value):\n        \"\"\"\n\t\tset attribute\n\t\t\"\"\"\n        if prop == 'id':\n            self.id = value\n        elif prop == 'status':\n            self.status = value\n        elif prop == 'bm':\n            self.bm = value\n        elif prop == 'graph':\n            self.graph = value\n        else:\n            self.properties[prop] = value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef GetProp(self, prop):\n\n        if prop == 'id':\n            return self.id\n        elif prop == 'status':\n            return self.status\n        elif prop == 'bm':\n            return self.bm\n        elif prop == 'graph':\n            return self.graph\n        else:\n            return self.properties[prop]", "response": "Get a specific property from the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, n=None):\n        response = \"\"\n        while n is None or n > 0:\n            c = self.stream.read(1)\n            if c == \"\":\n                break\n            elif c == \"<\":\n                c += self.stream.read(1)\n                if c == \"<?\":\n                    while True:\n                        q = self.stream.read(1)\n                        if q == \">\":\n                            break\n                else:\n                    response += c\n                    if n is not None:\n                        n -= len(c)\n            else:\n                response += c\n                if n is not None:\n                    n -= 1\n        return response", "response": "Read at most n characters from this stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_results(self, stream):\n        result = None\n        values = None\n        try:\n            for event, elem in et.iterparse(stream, events=('start', 'end')):\n                if elem.tag == 'results' and event == 'start':\n                    # The wrapper element is a <results preview=\"0|1\">. We\n                    # don't care about it except to tell is whether these\n                    # are preview results, or the final results from the\n                    # search.\n                    is_preview = elem.attrib['preview'] == '1'\n                    self.is_preview = is_preview\n                if elem.tag == 'result':\n                    if event == 'start':\n                        result = OrderedDict()\n                    elif event == 'end':\n                        yield result\n                        result = None\n                        elem.clear()\n\n                elif elem.tag == 'field' and result is not None:\n                    # We need the 'result is not None' check because\n                    # 'field' is also the element name in the <meta>\n                    # header that gives field order, which is not what we\n                    # want at all.\n                    if event == 'start':\n                        values = []\n                    elif event == 'end':\n                        field_name = elem.attrib['k'].encode('utf8')\n                        if len(values) == 1:\n                            result[field_name] = values[0]\n                        else:\n                            result[field_name] = values\n                        # Calling .clear() is necessary to let the\n                        # element be garbage collected. Otherwise\n                        # arbitrarily large results sets will use\n                        # arbitrarily large memory intead of\n                        # streaming.\n                        elem.clear()\n\n                elif elem.tag in ('text', 'v') and event == 'end':\n                    text = \"\".join(elem.itertext())\n                    values.append(text.encode('utf8'))\n                    elem.clear()\n\n                elif elem.tag == 'msg':\n                    if event == 'start':\n                        msg_type = elem.attrib['type']\n                    elif event == 'end':\n                        text = elem.text if elem.text is not None else \"\"\n                        yield Message(msg_type, text.encode('utf8'))\n                        elem.clear()\n        except SyntaxError as pe:\n            # This is here to handle the same incorrect return from\n            # splunk that is described in __init__.\n            if 'no element found' in pe.msg:\n                return\n            else:\n                raise", "response": "Parse the results and messages out of the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_field_info(self, field):\n        field_info = collections.OrderedDict()\n        field_info['type'] = self.label_lookup[field]\n        field_info['required'] = getattr(field, 'required', False)\n\n        attrs = [\n            'read_only', 'label', 'help_text', 'allow_null',\n            'min_length', 'max_length',\n            'min_value', 'max_value',\n        ]\n\n        # Handle default attribute\n        default_value = getattr(field, 'default')\n        if (default_value is not empty):\n            field_info['default'] = force_text(\n                default_value, strings_only=True)\n\n        for attr in attrs:\n            value = getattr(field, attr, None)\n            if value is not None and value != '':\n                field_info[attr] = force_text(value, strings_only=True)\n\n        if hasattr(field, 'choices'):\n            field_info['choices'] = [\n                {\n                    'value': choice_value,\n                    'display_name': force_text(choice_name, strings_only=True)\n                }\n                for choice_value, choice_name in field.choices.items()\n            ]\n\n        # handle RegexField\n        if isinstance(field, serializers.RegexField):\n            pattern = None\n            for validator in field.validators:\n                if isinstance(validator, RegexValidator):\n                    pattern = validator.regex.pattern\n                    break\n            field_info['pattern'] = force_text(pattern, strings_only=True)\n\n        # handle DecimalField\n        if isinstance(field, serializers.DecimalField):\n            for attr in ('max_digits', 'decimal_places'):\n                field_info[attr] = force_text(\n                    getattr(field, attr), strings_only=True)\n\n        return field_info", "response": "Returns a dictionary of metadata about the given serializer field."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread an InputHeader from input_file and updates the internal state of the object.", "response": "def read(self, input_file):\n        \"\"\" Reads an InputHeader from `input_file`.\n\n        The input header is read as a sequence of *<key>***:***<value>* pairs\n        separated by a newline. The end of the input header is signalled by an\n        empty line or an end-of-file.\n\n        :param input_file: File-like object that supports iteration over lines\n\n        \"\"\"\n        key, value = None, None\n        import sys\n        for line in input_file:\n            if line == '\\n':\n                break\n            if line[-1:] == '\\n':\n                line = line[:-1]\n            item = line.split(':', 1)\n            if len(item) == 2:\n                # start of a new item\n                self._update(key, value)\n                key, value = item[0], urllib.unquote(item[1])\n            elif key is not None:\n                # continuation of the current item\n                value = '\\n'.join([value, urllib.unquote(line)])\n\n        self._update(key, value)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef append(self, message_level, message_text):\n        if not message_level in MessagesHeader._message_levels:\n            raise ValueError('message_level=\"%s\"' % message_level)\n        self._messages.append((message_level, message_text))", "response": "Adds a message level and text pair to the MessagesHeader."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write(self, output_file):\n        for message_level, message_text in self:\n            output_file.write('%s=%s\\r\\n' % (message_level, message_text))\n        output_file.write('\\r\\n')", "response": "Writes this MessageHeader to an output stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse an argument list into an options dictionary and a fieldname list.", "response": "def parse(self, argv, command):\n        \"\"\" Splits an argument list into an options dictionary and a fieldname\n        list.\n\n        The argument list, `argv`, must be of the form::\n\n            *[option]... *[<field-name>]\n\n        Options are validated and assigned to items in `command.options`. Field\n        names are validated and stored in the list of `command.fieldnames`.\n\n        #Arguments:\n\n        :param command: Search command instance.\n        :type command: ``SearchCommand``\n        :param argv: List of search command arguments.\n        :type argv: ``list``\n        :return: ``None``\n\n        #Exceptions:\n\n        ``SyntaxError``: Argument list is incorrectly formed.\n        ``ValueError``: Unrecognized option/field name, or an illegal field value.\n\n        \"\"\"\n        # Prepare\n\n        command_args = ' '.join(argv)\n        command.fieldnames = None\n        command.options.reset()\n\n        command_args = SearchCommandParser._arguments_re.match(command_args)\n\n        if command_args is None:\n            raise SyntaxError(\"Syntax error: %s\" % ' '.join(argv))\n\n        # Parse options\n\n        for option in SearchCommandParser._options_re.finditer(\n                command_args.group('options')):\n            name, value = option.group(1), option.group(2)\n            if not name in command.options:\n                raise ValueError('Unrecognized option: %s = %s' % (name, value))\n            command.options[name].value = SearchCommandParser.unquote(value)\n\n        missing = command.options.get_missing()\n\n        if missing is not None:\n            if len(missing) == 1:\n                raise ValueError('A value for \"%s\" is required' % missing[0])\n            else:\n                raise ValueError(\n                    'Values for these options are required: %s' %\n                    ', '.join(missing))\n\n        # Parse field names\n\n        command.fieldnames = command_args.group('fieldnames').split()\n        command.logger.debug('%s: %s', type(command).__name__, command)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves quotes from a quoted string. Splunk search command quote rules are applied. The enclosing double-quotes, if present, are removed. Escaped double-quotes ('\\\"' or '\"\"') are replaced by a single double-quote ('\"'). **NOTE** We are not using a json.JSONDecoder because Splunk quote rules are different than JSON quote rules. A json.JSONDecoder does not recognize a pair of double-quotes ('\"\"') as an escaped quote ('\"') and will decode single-quoted strings (\"'\") in addition to double-quoted ('\"') strings.", "response": "def unquote(cls, string):\n        \"\"\" Removes quotes from a quoted string.\n\n        Splunk search command quote rules are applied. The enclosing\n        double-quotes, if present, are removed. Escaped double-quotes ('\\\"' or\n        '\"\"') are replaced by a single double-quote ('\"').\n\n        **NOTE**\n\n        We are not using a json.JSONDecoder because Splunk quote rules are\n        different than JSON quote rules. A json.JSONDecoder does not recognize\n        a pair of double-quotes ('\"\"') as an escaped quote ('\"') and will decode\n        single-quoted strings (\"'\") in addition to double-quoted ('\"') strings.\n\n        \"\"\"\n        if len(string) == 0:\n            return ''\n\n        if string[0] != '\"':\n            return string\n\n        if len(string) == 1:\n            return string\n\n        if string[-1] != '\"':\n            raise ValueError(\"Poorly formed string literal: %s\" % string)\n\n        def replace(match):\n            value = match.group(0)\n            if value == '\\\\\\\\':\n                return '\\\\'\n            if value == '\\\\\"':\n                return '\"'\n            if value == '\"\"':\n                return '\"'\n            if len(value) != 2:\n                raise ValueError(\"Poorly formed string literal: %s\" % string)\n            return value  # consistent with python handling\n\n        result = re.sub(cls._escaped_quote_re, replace, string[1:-1])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nhandle mouse click events.", "response": "def callback(self, event):\n        \"\"\"\n        Selects cells on click.\n        \"\"\"\n        self.init_width()\n\n        if len(self.initial) > 0:\n            for cell in self.initial:\n                self.color_square(cell[0], cell[1], True)\n            self.initial = []\n        self.begin_drag = event\n        self.color_square(event.x, event.y)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef init_width(self):\n        self.col_width = self.c.winfo_width()/self.cols\n        self.row_height = self.c.winfo_height()/self.rows", "response": "Initialize the width of the screen."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles actually coloring the squares of the current resource.", "response": "def color_square(self, x, y, unit_coords=False):\n        \"\"\"\n        Handles actually coloring the squares\n        \"\"\"\n        # Calculate column and row number\n        if unit_coords:\n            col = x\n            row = y\n        else:\n            col = x//self.col_width\n            row = y//self.row_height\n\n        # If the tile is not filled, create a rectangle\n        if not self.tiles[row][col]:\n            self.tiles[row][col] = \\\n                self.c.create_rectangle(col*self.col_width,\n                                        row*self.row_height,\n                                        (col+1)*self.col_width,\n                                        (row+1)*self.row_height,\n                                        fill=\"black\")\n            self.cells.append(row*self.cols + col)\n\n        # If the tile is filled, delete the rectangle and clear the reference\n        else:\n            self.c.delete(self.tiles[row][col])\n            self.tiles[row][col] = None\n            self.cells.remove(row*self.cols + col)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling the end of a drag action.", "response": "def dragend(self, event):\n        \"\"\"\n        Handles the end of a drag action.\n        \"\"\"\n        x_range = [self.begin_drag.x//self.col_width, event.x//self.col_width]\n        y_range = [self.begin_drag.y//self.row_height,\n                   event.y//self.row_height]\n\n        # Check bounds\n        for i in range(2):\n            for ls in [x_range, y_range]:\n                if ls[i] < 0:\n                    ls[i] = 0\n                if ls[i] >= self.rows:\n                    ls[i] = self.rows-1\n\n        for x in range(min(x_range), max(x_range)+1):\n            for y in range(min(y_range), max(y_range)+1):\n                if x == self.begin_drag.x//self.col_width and \\\n                   y == self.begin_drag.y//self.row_height:\n                    continue\n                self.color_square(x*self.col_width, y*self.row_height)\n        self.begin_drag = None\n\n        print(len(self.cells), \"cells selected\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying to convert item to lowercase if it is str or unicode.", "response": "def _lower_if_str(item):\n    \"\"\"\n    Try to convert item to lowercase, if it is string.\n\n    Args:\n        item (obj): Str, unicode or any other object.\n\n    Returns:\n        obj: ``item.lower()`` if `item` is ``str`` or ``unicode``, else just \\\n             `item` itself.\n    \"\"\"\n    # python 2 / 3 shill\n    try:\n        string_type = basestring\n    except NameError:\n        string_type = str\n\n    if isinstance(item, string_type):\n        return item.lower()\n\n    return item"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the absolute path to the relpath taken relative to the base directory of the repository.", "response": "def get_repo_relpath(repo, relpath):\n    \"\"\"Returns the absolute path to the 'relpath' taken relative to the base\n    directory of the repository.\n    \"\"\"\n    from os import path\n    if relpath[0:2] == \"./\":\n        return path.join(repo, relpath[2::])\n    else:\n        from os import chdir, getcwd\n        cd = getcwd()\n        chdir(path.expanduser(repo))\n        result = path.abspath(relpath)\n        chdir(cd)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_with_datetime(pairs):\n    d = {}\n    for k, v in pairs:\n        if isinstance(v, basestring):\n            try:\n                d[k] = dateutil.parser.parse(v)\n            except ValueError:\n                d[k] = v\n        else:\n            d[k] = v             \n    return d", "response": "Deserialize JSON into python datetime objects."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the JSON serialized object at the specified path or the default value if the file doesn t exist or can t be deserialized.", "response": "def get_json(jsonpath, default):\n    \"\"\"Returns the JSON serialized object at the specified path, or the default\n    if it doesn't exist or can't be deserialized.\n    \"\"\"\n    from os import path\n    import json\n    result = default\n    \n    if path.isfile(jsonpath):\n        try:\n            with open(jsonpath) as f:\n                result = json.load(f, object_pairs_hook=load_with_datetime)\n        except(IOError):\n            err(\"Unable to deserialize JSON at {}\".format(jsonpath))\n            pass\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_exec(repodir, command, output, index):\n    from os import path\n    from subprocess import Popen, PIPE\n    from datetime import datetime\n    \n    child = Popen(\"cd {}; {} > {}.cidat\".format(repodir, command, index),\n                  shell=True, executable=\"/bin/bash\")\n    # Need to do this so that we are sure the process is done before moving on\n    child.wait()\n    output.put({\"index\": index, \"end\": datetime.now(), \"code\": child.returncode,\n                \"output\": path.join(repodir, \"{}.cidat\".format(index))})", "response": "Runs the specified command in the specified directory and puts the output to the multiprocessing queue."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_class(location: str) -> type:\n    module_name, _, class_name = location.rpartition(\".\")\n\n    if not module_name:\n        raise ArcaMisconfigured(f\"The module is not specified, can't load class from '{location}'\")\n\n    try:\n        imported_module = importlib.import_module(module_name)\n        return getattr(imported_module, class_name)\n    except ModuleNotFoundError:\n        raise ArcaMisconfigured(f\"{module_name} does not exist.\")\n    except AttributeError:\n        raise ArcaMisconfigured(f\"{module_name} does not have a {class_name} class\")", "response": "Loads a class from a string and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_last_commit_modifying_files(repo: Repo, *files) -> str:\n    return repo.git.log(*files, n=1, format=\"%H\")", "response": "Returns the hash of the last commit which modified some of the files in those folders."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_hash_for_file(repo: Repo, path: Union[str, Path]) -> str:\n    return repo.git.rev_parse(f\"HEAD:{str(path)}\")", "response": "Returns the hash for the specified file or folder."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns values from the settings in the order of keys.", "response": "def get(self, *keys: str, default: Any = NOT_SET) -> Any:\n        \"\"\" Returns values from the settings in the order of keys, the first value encountered is used.\n\n        Example:\n\n        >>> settings = Settings({\"ARCA_ONE\": 1, \"ARCA_TWO\": 2})\n        >>> settings.get(\"one\")\n        1\n        >>> settings.get(\"one\", \"two\")\n        1\n        >>> settings.get(\"two\", \"one\")\n        2\n        >>> settings.get(\"three\", \"one\")\n        1\n        >>> settings.get(\"three\", default=3)\n        3\n        >>> settings.get(\"three\")\n        Traceback (most recent call last):\n        ...\n        KeyError:\n\n        :param keys: One or more keys to get from settings. If multiple keys are provided, the value of the first key\n            that has a value is returned.\n        :param default: If none of the ``options`` aren't set, return this value.\n        :return: A value from the settings or the default.\n\n        :raise ValueError: If no keys are provided.\n        :raise KeyError: If none of the keys are set and no default is provided.\n\n        \"\"\"\n        if not len(keys):\n            raise ValueError(\"At least one key must be provided.\")\n\n        for option in keys:\n            key = f\"{self.PREFIX}_{option.upper()}\"\n            if key in self._data:\n                return self._data[key]\n\n        if default is NOT_SET:\n            raise KeyError(\"None of the following key is present in settings and no default is set: {}\".format(\n                \", \".join(keys)\n            ))\n\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbatch a list into a list of lists with sub - lists sized by a specified batch size.", "response": "def batch(items, size):\n    \"\"\"Batches a list into a list of lists, with sub-lists sized by a specified\n    batch size.\"\"\"\n    return [items[x:x + size] for x in xrange(0, len(items), size)]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the Storage class compatible with the current environment.", "response": "def get_storage(key, username):\n    \"\"\"Returns the Storage class compatible with the current environment.\"\"\"\n    if IS_APPENGINE and appengine:\n        return appengine.StorageByKeyName(\n            appengine.CredentialsModel, username, 'credentials')\n    file_name = os.path.expanduser('~/.config/webreview/{}_{}'.format(key, username))\n    dir_name = os.path.dirname(file_name)\n    if not os.path.exists(dir_name):\n        os.makedirs(dir_name)\n    return oauth_file.Storage(file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _clean_record(self, record):\n        for k, v in dict(record).items():\n            if isinstance(v, dict):\n                v = self._clean_record(v)\n            if v is None:\n                record.pop(k)\n        return record", "response": "Remove all None values from a record"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a single record from the database with the id field matching obj_id.", "response": "def get_instance(self, collection, obj_id, **kwargs):\n        \"\"\"Get a record from the database with the id field matching `obj_id`.\n        \"\"\"\n        logging.info(\"Getting single record\")\n        try:\n            obj_id = ObjectId(obj_id)\n        except InvalidId:\n            logging.error(\"Invalid ObjectId: {}\".format(obj_id))\n            return {}\n        projection = kwargs.get('projection', {})\n        projection = None if len(projection) < 1 else projection\n        query = kwargs.get('query', {})\n        query.update({'_id': obj_id})\n        logging.debug(\"Query: {}\".format(query))\n        logging.debug(\"Projection: {}\".format(projection))\n        record = self.db[collection].find_one(query, projection)\n        return record"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a record from the database with the id field matching obj_id.", "response": "def get_collection(self, collection, **kwargs):\n        \"\"\"Get a record from the database with the id field matching `obj_id`.\n        \"\"\"\n        query = kwargs.get('query', {})\n        projection = kwargs.get('projection', {})\n        projection = None if len(projection) < 1 else projection\n        limit = kwargs.get('limit', 0)  # no limit by default\n        # sort = kwargs.get('sort', {})\n        logging.info(\"About to get a collection from the database\")\n        logging.debug(\"Collection: {}\".format(collection))\n        logging.debug(\"Query: {}\".format(query))\n        logging.debug(\"Projection: {}\".format(projection))\n        logging.debug(\"Limit: {}\".format(limit))\n        records = \\\n            list(self.db[collection].find(query, projection).limit(limit))\n        logging.debug(\"Got {} results\".format(len(records)))\n        return records"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nserializing the payload into JSON", "response": "def serialize(self, root, records):\n        \"\"\"Serialize the payload into JSON\"\"\"\n        logging.info(\"Serializing record\")\n        logging.debug(\"Root: {}\".format(root))\n        logging.debug(\"Records: {}\".format(records))\n        if records == {}:\n            return '{}'\n        if isinstance(records, dict):\n            if list(records.keys())[0] == 'errors':\n                logging.warning(\"Found errors. Moving on\".format(records))\n                root = None\n            elif '_id' in records:\n                records['id'] = records.pop('_id')\n        else:\n            records = list(records)\n\n            # rename _id to id\n            for r in records:\n                if '_id' in r:\n                    r['id'] = r.pop('_id')\n\n        if root is not None:\n            records = {root: records}\n        return json.dumps(records, cls=JSONEncoder)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rule(ctxt, name):\n\n    # If the result of evaluation is in the rule cache, bypass\n    # evaluation\n    if name in ctxt.rule_cache:\n        ctxt.stack.append(ctxt.rule_cache[name])\n        return\n\n    # Obtain the rule we're to evaluate\n    try:\n        rule = ctxt.policy[name]\n    except KeyError:\n        # Rule doesn't exist; log a message and assume False\n        log = logging.getLogger('policies')\n        log.warn(\"Request to evaluate non-existant rule %r \"\n                 \"while evaluating rule %r\" % (name, ctxt.name))\n        ctxt.stack.append(False)\n        ctxt.rule_cache[name] = False\n        return\n\n    # Evaluate the rule, stopping at the set_authz instruction\n    with ctxt.push_rule(name):\n        rule.instructions(ctxt, True)\n\n    # Cache the result\n    ctxt.rule_cache[name] = ctxt.stack[-1]", "response": "Evaluate a rule while evaluating a rule."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resolve(self, symbol):\n\n        # Try the variables first\n        if symbol in self.variables:\n            return self.variables[symbol]\n\n        return self.policy.resolve(symbol)", "response": "Resolve a symbol encountered during a rule evaluation into the actual value for that symbol."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nallows one rule to be evaluated in the context of another. This allows keeping track of the rule names during nested rule evaluation. :param name: The name of the nested rule to be evaluated. :returns: A context manager, suitable for use with the ``with`` statement. No value is generated.", "response": "def push_rule(self, name):\n        \"\"\"\n        Allow one rule to be evaluated in the context of another.\n        This allows keeping track of the rule names during nested rule\n        evaluation.\n\n        :param name: The name of the nested rule to be evaluated.\n\n        :returns: A context manager, suitable for use with the\n                  ``with`` statement.  No value is generated.\n        \"\"\"\n\n        # Verify that we haven't been evaluating the rule already;\n        # this is to prohibit recursive rules from locking us up...\n        if name in self._name:\n            raise PolicyException(\n                \"Rule recursion detected; invocation chain: %s -> %s\" %\n                (' -> '.join(self._name), name))\n\n        # Save the name temporarily, and set up the program counter\n        # and step\n        self._name.append(name)\n        self._pc.append(0)\n        self._step.append(1)\n        try:\n            yield\n        except Exception as exc:\n            exc_info = sys.exc_info()\n\n            # Report only if we haven't reported it yet\n            if not self.reported:\n                # Get the logger and emit a log message\n                log = logging.getLogger('policies')\n                log.warn(\"Exception raised while evaluating rule %r: %s\" %\n                         (name, exc))\n                self.reported = True\n\n            six.reraise(*exc_info)\n        finally:\n            # Pop the name off the stack of names and restore program\n            # counter and step\n            self._name.pop()\n            self._pc.pop()\n            self._step.pop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef declare(self, name, text='', doc=None, attrs=None, attr_docs=None):\n\n        self._defaults[name] = rules.Rule(name, text, attrs)\n        self._docs[name] = rules.RuleDoc(name, doc, attr_docs)\n\n        return self._defaults[name]", "response": "Declare a rule. This function is used to declare a new rule."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_doc(self, name):\n\n        # Create one if there isn't one already\n        if name not in self._docs:\n            self._docs[name] = rules.RuleDoc(name)\n\n        return self._docs[name]", "response": "Retrieves a RuleDoc object from the Policy with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nresolve a symbol using the entry point group.", "response": "def resolve(self, symbol):\n        \"\"\"\n        Resolve a symbol using the entrypoint group.\n\n        :param symbol: The symbol being resolved.\n\n        :returns: The value of that symbol.  If the symbol cannot be\n                  found, or if no entrypoint group was passed to the\n                  constructor, will return ``None``.\n        \"\"\"\n\n        # Search for a corresponding symbol\n        if symbol not in self._resolve_cache:\n            result = None\n\n            # Search through entrypoints only if we have a group\n            if self._group is not None:\n                for ep in pkg_resources.iter_entry_points(self._group, symbol):\n                    try:\n                        result = ep.load()\n                    except (ImportError, AttributeError,\n                            pkg_resources.UnknownExtra):\n                        continue\n\n                    # We found the result we were looking for\n                    break\n\n            # Cache the result\n            self._resolve_cache[symbol] = result\n\n        return self._resolve_cache[symbol]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef evaluate(self, name, variables=None):\n\n        # Get the rule and predeclaration\n        rule = self._rules.get(name)\n        default = self._defaults.get(name)\n\n        # Short-circuit if we don't have either\n        if rule is None and default is None:\n            return authorization.Authorization(False)\n\n        # Marry the attribute defaults\n        attrs = {}\n        if default:\n            attrs.update(default.attrs)\n        if rule:\n            attrs.update(rule.attrs)\n\n        # Select the rule we'll actually use\n        if rule is None:\n            rule = default\n\n        # Construct the context\n        ctxt = self.context_class(self, attrs, variables or {})\n\n        # Execute the rule\n        try:\n            with ctxt.push_rule(name):\n                rule.instructions(ctxt)\n        except Exception as exc:\n            # Fail closed\n            return authorization.Authorization(False, attrs)\n\n        # Return the authorization result\n        return ctxt.authz", "response": "Evaluate a named rule and return the result of the evaluation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a PID from its string representation.", "response": "def from_string(cls, pid):\n    \"\"\"Parse a PID from its string representation.\n\n    PIDs may be represented as name@ip:port, e.g.\n\n    .. code-block:: python\n\n        pid = PID.from_string('master(1)@192.168.33.2:5051')\n\n    :param pid: A string representation of a pid.\n    :type pid: ``str``\n    :return: The parsed pid.\n    :rtype: :class:`PID`\n    :raises: ``ValueError`` should the string not be of the correct syntax.\n    \"\"\"\n    try:\n      id_, ip_port = pid.split('@')\n      ip, port = ip_port.split(':')\n      port = int(port)\n    except ValueError:\n      raise ValueError('Invalid PID: %s' % pid)\n    return cls(ip, port, id_)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a new value to array element specified by its index.", "response": "def set_as_object(self, index = None, value= None):\n        \"\"\"\n        Sets a new value to array element specified by its index.\n        When the index is not defined, it resets the entire array value.\n        This method has double purpose because method overrides are not supported in JavaScript.\n\n        :param index: (optional) an index of the element to set\n\n        :param value: a new element or array value.\n        \"\"\"\n        if index == None and value != None:\n            self.set_as_array(value)\n        else:\n            self[index] = value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert array element into an AnyValueArray or returns empty AnyValueArray if conversion is not possible.", "response": "def get_as_array(self, index):\n        \"\"\"\n        Converts array element into an AnyValueArray or returns empty AnyValueArray if conversion is not possible.\n\n        :param index: an index of element to get.\n\n        :return: AnyValueArray value of the element or empty AnyValueArray if conversion is not supported.\n        \"\"\"\n        if index == None:\n            array = []\n            for value in self:\n                array.append(value)\n            return array\n        else:\n            value = self[index]\n            return AnyValueArray.from_value(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_as_string_with_default(self, index, default_value):\n        value = self[index]\n        return StringConverter.to_string_with_default(value, default_value)", "response": "Converts array element into a string or returns default value if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts array element into a boolean or returns default value if conversion is not possible.", "response": "def get_as_boolean_with_default(self, index, default_value):\n        \"\"\"\n        Converts array element into a boolean or returns default value if conversion is not possible.\n\n        :param index: an index of element to get.\n\n        :param default_value: the default value\n\n        :return: boolean value ot the element or default value if conversion is not supported.\n        \"\"\"\n        value = self[index]\n        return BooleanConverter.to_boolean_with_default(value, default_value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_as_integer_with_default(self, index, default_value):\n        value = self[index]\n        return IntegerConverter.to_integer_with_default(value, default_value)", "response": "Converts array element into an integer or returns default value if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_as_float_with_default(self, index, default_value):\n        value = self[index]\n        return FloatConverter.to_float_with_default(value, default_value)", "response": "Converts array element into a float or returns default value if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting array element into a Date or returns default value if conversion is not possible.", "response": "def get_as_datetime_with_default(self, index, default_value):\n        \"\"\"\n        Converts array element into a Date or returns default value if conversion is not possible.\n\n        :param index: an index of element to get.\n\n        :param default_value: the default value\n\n        :return: Date value ot the element or default value if conversion is not supported.\n        \"\"\"\n        value = self[index]\n        return DateTimeConverter.to_datetime_with_default(value, default_value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_as_nullable_type(self, index, value_type):\n        value = self[index]\n        return TypeConverter.to_nullable_type(value_type, value)", "response": "Converts array element into a value defined by specied typecode. If conversion is not possible it returns None."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert array element into a value defined by specied typecode.", "response": "def get_as_type(self, index, value_type):\n        \"\"\"\n        Converts array element into a value defined by specied typecode.\n        If conversion is not possible it returns default value for the specified type.\n\n        :param index: an index of element to get.\n\n        :param value_type: the TypeCode that defined the type of the result\n\n        :return: element value defined by the typecode or default if conversion is not supported.\n        \"\"\"\n        value = self[index]\n        return TypeConverter.to_type(value_type, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts array element into a value defined by specied typecode.", "response": "def get_as_type_with_default(self, index, value_type, default_value):\n        \"\"\"\n        Converts array element into a value defined by specied typecode.\n        If conversion is not possible it returns default value.\n\n        :param index: an index of element to get.\n\n        :param value_type: the TypeCode that defined the type of the result\n\n        :param default_value: the default value\n\n        :return: element value defined by the typecode or default value if conversion is not supported.\n        \"\"\"\n        value = self[index]\n        return TypeConverter.to_type_with_default(value_type, value, default_value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if this array contains a value.", "response": "def contains(self, value):\n        \"\"\"\n        Checks if this array contains a value.\n        The check uses direct comparison between elements and the specified value.\n\n        :param value: a value to be checked\n\n        :return: true if this array contains the value or false otherwise.\n        \"\"\"\n        str_value = StringConverter.to_nullable_string(value)\n\n        for element in self:\n            str_element = StringConverter.to_string(element)\n\n            if str_value == None and str_element == None:\n                return True\n            if str_value == None or str_element == None:\n                continue\n            \n            if str_value == str_element:\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef contains_as_type(self, value_type, value):\n        typed_value = TypeConverter.to_nullable_type(value_type, value)\n\n        for element in self:\n            typed_element = TypeConverter.to_type(value_type, element)\n\n            if typed_value == None and typed_element == None:\n                return True\n            if typed_value == None or typed_element == None:\n                continue\n            \n            if typed_value == typed_element:\n                return True\n\n        return False", "response": "Checks if this array contains a value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_value(value):\n        value = ArrayConverter.to_nullable_array(value)\n        if value != None:\n            return AnyValueArray(value)\n        return AnyValueArray()", "response": "Converts specified value into an AnyValueArray."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsplit specified string into elements using a separator and assigns the elements to an AnyValueArray.", "response": "def from_string(values, separator, remove_duplicates = False):\n        \"\"\"\n        Splits specified string into elements using a separator and assigns\n        the elements to a newly created AnyValueArray.\n\n        :param values: a string value to be split and assigned to AnyValueArray\n\n        :param separator: a separator to split the string\n\n        :param remove_duplicates: (optional) true to remove duplicated elements\n\n        :return: a newly created AnyValueArray.\n        \"\"\"\n        result = AnyValueArray()\n\n        if values == None or len(values) == 0:\n            return result\n\n        items = str(values).split(separator)\n        for item in items:\n            if (item != None and len(item) > 0) or remove_duplicates == False:\n                result.append(item)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef paint(self, painter, option, index):\n        if self._widget is None:\n            return super(WidgetDelegate, self).paint(painter, option, index)\n\n        self.set_widget_index(index)\n        painter.save()\n        painter.translate(option.rect.topLeft())\n        self._widget.resize(option.rect.size())\n        self._widget.render(painter, QtCore.QPoint())\n        painter.restore()", "response": "Use the painter and style option to render the item specified by the item index."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the appropriate amount for the size of the widget.", "response": "def sizeHint(self, option, index):\n        \"\"\"Return the appropriate amount for the size of the widget\n\n        The widget will always be expanded to at least the size of the viewport.\n\n        :param option: the options for painting\n        :type option: :class:`QtGui.QStyleOptionViewItem`\n        :param index: the index to paint\n        :type index: :class:`QtCore.QModelIndex`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if self._widget is None:\n            return super(WidgetDelegate, self).sizeHint(option, index)\n\n        self.set_widget_index(index)\n        self._widget.resize(option.rect.size())\n        sh = self._widget.sizeHint()\n        return sh"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef close_editors(self, ):\n        for k in reversed(self._edit_widgets.keys()):\n            self.commit_close_editor(k)", "response": "Close all current editors"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating an editor for the given index.", "response": "def createEditor(self, parent, option, index):\n        \"\"\"Return the editor to be used for editing the data item with the given index.\n\n        Note that the index contains information about the model being used.\n        The editor's parent widget is specified by parent, and the item options by option.\n\n        This will set auto fill background to True on the editor, because else, you would see\n        The rendered delegate below.\n\n        :param parent: the parent widget\n        :type parent: QtGui.QWidget\n        :param option: the options for painting\n        :type option: QtGui.QStyleOptionViewItem\n        :param index: the index to paint\n        :type index: QtCore.QModelIndex\n        :returns: The created widget | None\n        :rtype: :class:`QtGui.QWidget` | None\n        :raises: None\n        \"\"\"\n        # close all editors\n        self.close_editors()\n        e = self.create_editor_widget(parent, option, index)\n        if e:\n            self._edit_widgets[index] = e\n            e.setAutoFillBackground(True)\n            e.destroyed.connect(partial(self.editor_destroyed, index=index))\n        return e"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncommit and close the editor at the given index", "response": "def commit_close_editor(self, index, endedithint=QtGui.QAbstractItemDelegate.NoHint):\n        \"\"\"Commit and close the editor\n\n        Call this method whenever the user finished editing.\n\n        :param index: The index of the editor\n        :type index: :class:`QtCore.QModelIndex`\n        :param endedithint: Hints that the delegate can give the model\n                            and view to make editing data comfortable for the user\n        :type endedithint: :data:`QtGui.QAbstractItemDelegate.EndEditHint`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        editor = self._edit_widgets[index]\n        self.commitData.emit(editor)\n        self.closeEditor.emit(editor, endedithint)\n        del self._edit_widgets[index]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates the editor geometry with the current option and index.", "response": "def updateEditorGeometry(self, editor, option, index):\n        \"\"\"Make sure the editor is the same size as the widget\n\n        By default it can get smaller because does not expand over viewport size.\n        This will make sure it will resize to the same size as the widget.\n\n        :param editor: the editor to update\n        :type editor: :class:`QtGui.QWidget`\n        :param option: the options for painting\n        :type option: QtGui.QStyleOptionViewItem\n        :param index: the index to paint\n        :type index: QtCore.QModelIndex\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        super(WidgetDelegate, self).updateEditorGeometry(editor, option, index)\n        editor.setGeometry(option.rect)\n        if self.keep_editor_size:\n            esh = editor.sizeHint()\n            osh = option.rect.size()\n            w = osh.width() if osh.width() > esh.width() else esh.width()\n            h = osh.height() if osh.height() > esh.height() else esh.height()\n            editor.resize(w, h)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef index_at_event(self, event):\n        # find index at mouse position\n        globalpos = event.globalPos()\n        viewport = self.viewport()\n        pos = viewport.mapFromGlobal(globalpos)\n        return self.indexAt(pos)", "response": "Returns the index of the item under the given mouse event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmapping the global position to the position relative to the index", "response": "def get_pos_in_delegate(self, index, globalpos):\n        \"\"\"Map the global position to the position relative to the\n        given index\n\n        :param index: the index to map to\n        :type index: :class:`QtCore.QModelIndex`\n        :param globalpos: the global position\n        :type globalpos: :class:`QtCore.QPoint`\n        :returns: The position relative to the given index\n        :rtype: :class:`QtCore.QPoint`\n        :raises: None\n        \"\"\"\n        rect = self.visualRect(index)  # rect of the index\n        p = self.viewport().mapToGlobal(rect.topLeft())\n        return globalpos - p"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef propagate_event_to_delegate(self, event, eventhandler):\n        # if we are recursing because we sent a click event, and it got propagated to the parents\n        # and we recieve it again, terminate\n        if self.__recursing:\n            return\n        # find index at mouse position\n        i = self.index_at_event(event)\n\n        # if the index is not valid, we don't care\n        # handle it the default way\n        if not i.isValid():\n            return getattr(super(WidgetDelegateViewMixin, self), eventhandler)(event)\n        # get the widget delegate. if there is None, handle it the default way\n        delegate = self.itemDelegate(i)\n        if not isinstance(delegate, WidgetDelegate):\n            return getattr(super(WidgetDelegateViewMixin, self), eventhandler)(event)\n\n        # see if there is already a editor\n        widget = delegate.edit_widget(i)\n        if not widget:\n            # close all editors, then start editing\n            delegate.close_editors()\n            # Force editing. If in editing state, view will refuse editing.\n            if self.state() == self.EditingState:\n                self.setState(self.NoState)\n            self.edit(i)\n            # get the editor widget. if there is None, there is nothing to do so return\n            widget = delegate.edit_widget(i)\n        if not widget:\n            return getattr(super(WidgetDelegateViewMixin, self), eventhandler)(event)\n\n        # try to find the relative position to the widget\n        pid = self.get_pos_in_delegate(i, event.globalPos())\n        widgetatpos = widget.childAt(pid)\n        if widgetatpos:\n            widgettoclick = widgetatpos\n            g = widget.mapToGlobal(pid)\n            clickpos = widgettoclick.mapFromGlobal(g)\n        else:\n            widgettoclick = widget\n            clickpos = pid\n\n        # create a new event for the editor widget.\n        e = QtGui.QMouseEvent(event.type(),\n                              clickpos,\n                              event.button(),\n                              event.buttons(),\n                              event.modifiers())\n        # before we send, make sure, we cannot recurse\n        self.__recursing = True\n        try:\n            r = QtGui.QApplication.sendEvent(widgettoclick, e)\n        finally:\n            self.__recursing = False  # out of the recursion. now we can accept click events again\n        return r", "response": "Propagate the given mouse event to the widgetdelegate\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_total_indentation(self, index):\n        n = 0\n        while index.isValid():\n            n += 1\n            index = index.parent()\n        return n * self.indentation()", "response": "Returns the total indentation for the given index"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the index of the item under the given mouse event.", "response": "def index_at_event(self, event):\n        \"\"\"Get the index under the position of the given MouseEvent\n\n        This implementation takes the indentation into account.\n\n        :param event: the mouse event\n        :type event: :class:`QtGui.QMouseEvent`\n        :returns: the index\n        :rtype: :class:`QtCore.QModelIndex`\n        :raises: None\n        \"\"\"\n        # find index at mouse position\n        globalpos = event.globalPos()\n        viewport = self.viewport()\n        pos = viewport.mapFromGlobal(globalpos)\n        i = self.indexAt(pos)\n        n = self.get_total_indentation(i)\n        if pos.x() > n:\n            return i\n        else:\n            return QtCore.QModelIndex()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef render(self, f_buf=None):\n        if f_buf is None:\n            f_buf = StringIO.StringIO()\n\n        headers = getattr(self, 'headers', ())\n\n        keys = [\n            force_encoding(header['label'], self.encoding)\n            for header in headers\n        ]\n\n        extra_headers = getattr(self, 'extra_headers', ())\n        keys.extend([\n            force_encoding(header['label'], self.encoding)\n            for header in extra_headers\n        ])\n\n        outfile = csv.DictWriter(\n            f_buf,\n            keys,\n            extrasaction='ignore',\n            delimiter=self.delimiter,\n            quotechar=self.quotechar,\n            quoting=csv.QUOTE_ALL,\n        )\n        outfile.writeheader()\n        _datas = getattr(self, '_datas', ())\n        outfile.writerows(_datas)\n        f_buf.seek(0)\n        return f_buf", "response": "Writes the table to a file buffer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef format_row(self, row):\n        res_dict = {}\n        headers = getattr(self, 'headers', [])\n        extra_headers = getattr(self, 'extra_headers', [])\n        for header in tuple(headers) + tuple(extra_headers):\n            name, label = header['name'], header['label']\n            val = row.get(name)\n            if val is None:\n                continue\n            label = force_encoding(label, self.encoding)\n            if hasattr(self, \"format_%s\" % name):\n                val = getattr(self, \"format_%s\" % name)(val)\n\n            res_dict[label] = force_encoding(val, self.encoding)\n        return res_dict", "response": "Format the row to fit our export"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the headers of our csv writer", "response": "def set_headers(self, headers):\n        \"\"\"\n        Set the headers of our csv writer\n\n        :param list headers: list of dict with label and name key (label is\n        mandatory : used for the export)\n        \"\"\"\n        self.headers = []\n        if 'order' in self.options:\n            for element in self.options['order']:\n                for header in headers:\n                    if header['key'] == element:\n                        self.headers.append(header)\n                        break\n        else:\n            self.headers = headers"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds extra datas to the last row of the table", "response": "def add_extra_datas(self, extra_datas):\n        \"\"\"\n        Add extra datas to the last row\n        headers : [col1, col2, col3, col4, col5]\n        row : {col1: a1, col2: a2, col3: a3}\n        extra_datas : [a4, a5]\n\n        row becomes : {col1: a1, col2: a2, col3: a3, col4: a4, col5: a5}\n\n        in case of longer extra_datas, the last columns will be overriden\n\n        :param list extra_datas: list of values to set in the last columns\n        \"\"\"\n        # we will add datas starting from the last index\n        for index, data in enumerate(extra_datas):\n            header = self.extra_headers[index]\n            self._datas[-1][header['label']] = data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_style(primary=None, secondary=None):\n    global _primary_style, _secondary_style\n    if primary:\n        _primary_style = primary\n    if secondary:\n        _secondary_style = secondary", "response": "Sets the primary and secondary component styles."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_char(key, value):\n    global _chars\n    category = _get_char_category(key)\n    if not category:\n        raise KeyError\n    _chars[category][key] = value", "response": "Updates the character with the given key to the given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisables color and switches to an ASCII character set if True.", "response": "def ascii_mode(enabled=True):\n    \"\"\" Disables color and switches to an ASCII character set if True.\n    \"\"\"\n    global _backups, _chars, _primary_style, _secondary_style, _ascii_mode\n    if not (enabled or _backups) or (enabled and _ascii_mode):\n        return\n    if enabled:\n        _backups = _chars.copy(), _primary_style, _secondary_style\n        _chars = {\n            \"primary\": {\"selected\": \"*\", \"block\": \"#\"},\n            \"secondary\": {\"arrow\": \">\", \"left-edge\": \"|\", \"right-edge\": \"|\"},\n            \"plain\": {\"unselected\": \".\"},\n        }\n        _primary_style = ()\n        _secondary_style = ()\n    else:\n        _chars, _primary_style, _secondary_style = _backups\n    _ascii_mode = enabled"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nraise error if invalid SAM format detected", "response": "def sam_verifier(entries, line=None):\n    \"\"\"Raises error if invalid SAM format detected\n\n    Args:\n        entries (list): A list of SamEntry instances\n\n        line (int): Line number of first entry\n\n    Raises:\n        FormatError: Error when SAM format incorrect with descriptive message\n    \"\"\"\n\n    regex = r'^[!-?A-~]{1,255}\\t' \\\n            + r'([0-9]{1,4}|[0-5][0-9]{4}|' \\\n            + r'[0-9]{1,4}|[1-5][0-9]{4}|' \\\n            + r'6[0-4][0-9]{3}|65[0-4][0-9]{2}|' \\\n            + r'655[0-2][0-9]|6553[0-7])\\t' \\\n            + r'\\*|[!-()+-<>-~][!-~]*\\t' \\\n            + r'([0-9]{1,9}|1[0-9]{9}|2(0[0-9]{8}|' \\\n            + r'1([0-3][0-9]{7}|4([0-6][0-9]{6}|' \\\n            + r'7([0-3][0-9]{5}|4([0-7][0-9]{4}|' \\\n            + r'8([0-2][0-9]{3}|3([0-5][0-9]{2}|' \\\n            + r'6([0-3][0-9]|4[0-7])))))))))\\t' \\\n            + r'([0-9]{1,2}|1[0-9]{2}|' \\\n            + r'2[0-4][0-9]|25[0-5])\\t' \\\n            + r'\\*|([0-9]+[MIDNSHPX=])+\\t' \\\n            + r'\\*|=|[!-()+-<>-~][!-~]*\\t' \\\n            + r'([0-9]{1,9}|1[0-9]{9}|2(0[0-9]{8}|' \\\n            + r'1([0-3][0-9]{7}|4([0-6][0-9]{6}|' \\\n            + r'7([0-3][0-9]{5}|4([0-7][0-9]{4}|' \\\n            + r'8([0-2][0-9]{3}|3([0-5][0-9]{2}|' \\\n            + r'6([0-3][0-9]|4[0-7])))))))))\\t' \\\n            + r'-?([0-9]{1,9}|1[0-9]{9}|2(0[0-9]{8}|' \\\n            + r'1([0-3][0-9]{7}|4([0-6][0-9]{6}|' \\\n            + r'7([0-3][0-9]{5}|4([0-7][0-9]{4}|' \\\n            + r'8([0-2][0-9]{3}|3([0-5][0-9]{2}|' \\\n            + r'6([0-3][0-9]|4[0-7])))))))))\\t' \\\n            + r'\\*|[A-Za-z=.]+\\t' \\\n            + r'[!-~]+{0}$'.format(os.linesep)\n    delimiter = r'\\t'\n\n    for entry in entries:\n        try:\n            entry_verifier([entry.write()], regex, delimiter)\n        except FormatError as error:\n            # Format info on what entry error came from\n            if line:\n                intro = 'Line {0}'.format(str(line))\n            elif error.part == 0:\n                intro = 'An entry with reference {0}'.format(entry.rname)\n            else:\n                intro = 'An entry with query {0}'.format(entry.qname)\n\n            # Generate error\n            if error.part == 0:\n                if len(entry.qname) == 0:\n                    msg = '{0} has no query name'.format(intro)\n                elif len(entry.qname) > 255:\n                    msg = '{0} query name must be less than 255 ' \\\n                          'characters'.format(intro)\n                else:\n                    msg = '{0} query name contains characters not in ' \\\n                          '[!-?A-~]'.format(intro)\n            elif error.part == 1:\n                msg = '{0} flag not in range [0-(2^31-1)]'.format(intro)\n            elif error.part == 2:\n                if len(entry.rname) == 0:\n                    msg = '{0} has no reference name'.format(intro)\n                else:\n                    msg = '{0} reference name has characters not in ' \\\n                          '[!-()+-<>-~][!-~]'.format(intro)\n            elif error.part == 3:\n                msg = '{0} leftmost position not in range ' \\\n                      '[0-(2^31-1)]'.format(intro)\n            elif error.part == 4:\n                msg = '{0} mapping quality not in range ' \\\n                      '[0-(2^8-1)]'.format(intro)\n            elif error.part == 5:\n                msg = '{0} CIGAR string has characters not in ' \\\n                      '[0-9MIDNSHPX=]'.format(intro)\n            elif error.part == 6:\n                msg = '{0} mate read name has characters not in ' \\\n                      '[!-()+-<>-~][!-~]'.format(intro)\n            elif error.part == 7:\n                msg = '{0} mate read position not in range ' \\\n                      '[0-(2^31-1)]'.format(intro)\n            elif error.part == 8:\n                msg = '{0} template length not in range ' \\\n                      '[(-2^31+1)-(2^31-1)]'.format(intro)\n            elif error.part == 9:\n                msg = '{0} sequence has characters not in ' \\\n                      '[A-Za-z=.]'.format(intro)\n            elif error.part == 10:\n                msg = '{0} quality scores has characters not in ' \\\n                      '[!-~]'.format(intro)\n            else:\n                msg = '{0}: Unknown Error: Likely a Bug'.format(intro)\n            raise FormatError(message=msg)\n\n        if line:\n            line += 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending the message to the broker.", "response": "def send(self, message, *args, **kwargs):\n        \"\"\"\n        Send the the `message` to the broker.\n\n        :param message: The message to send. Its type depends on the serializer used.\n        :type message: object\n        :rtype: None\n        \"\"\"\n        routing_keys = kwargs.get('routing_key') or self.routing_key\n        routing_keys = [routing_keys] if isinstance(routing_keys, basestring) else routing_keys\n        correlation_id = kwargs.get('correlation_id', None)\n        reply_to = kwargs.get('reply_to', None)\n        declare=[self.exchange] + kwargs.get('declare', [])\n        conn = self.get_connection()\n        with connections[conn].acquire(block=True) as connection:\n            self.exchange.maybe_bind(connection)\n            #reply_to.maybe_bind(connection)\n            #reply_to.declare(True)\n            with producers[connection].acquire(block=True) as producer:\n                for routing_key in routing_keys:\n                    LOGGER.info('Send message %s to exchange %s with routing_key %s reply_to %s correlation_id %s',\n                                message, self.exchange.name, routing_key, reply_to, correlation_id)\n                    producer.publish(\n                        message,\n                        exchange=self.exchange,\n                        declare=declare,\n                        serializer=self.settings['serializer'],\n                        routing_key=routing_key,\n                        correlation_id=correlation_id,\n                        retry=self.settings['retry'],\n                        delivery_mode=self.settings['delivery_mode'],\n                        reply_to=reply_to,\n                        retry_policy=self.settings['retry_policy'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisplays formatted error message and exit call", "response": "def exit_with_error(message):\n    \"\"\" Display formatted error message and exit call \"\"\"\n    click.secho(message, err=True, bg='red', fg='white')\n    sys.exit(0)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef perm_check(function, perm_check_func=_perm_check_func, raise_exception=False):\n    def real_decorator(func):\n        def wrapped(request, db, col, cmd, *args, **kwargs):\n            bPermPass = perm_check_func(request, db, col, cmd) if perm_check_func else True\n            if raise_exception and (not bPermPass):\n                raise PermissionDenied\n            return func(request, db, col, cmd, *args, **kwargs) if bPermPass else {\"error\": \"permission disallowed\"}\n\n        return wrapped\n    return real_decorator(function)", "response": "Decorator to check permissions for a given auth func"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef examples():\n    script = \"Continuous Integration Automation Server\"\n    explain = (\"For complex codes with many collaborators, it is often difficult to maintian \"\n               \"a pristine code that everyone can rely on. If every developer has power to \"\n               \"commit to master, unintentional mistakes happen that can cripple those who \"\n               \"rely on the code for day-to-day business. One way to overcome this is to isolate \"\n               \"the master branch and require collaborators to work on separate forks/branches. \"\n               \"When they are ready to commit their changes to master, they create a pull request \"\n               \"that summarizes the changes and why they want to merge them into the master branch.\\n\\n\"\n               \"A continuous integration server monitors repositories for new pull requests. When a new \"\n               \"request is made, the proposed changes are downloaded to a local sandbox and tested \"\n               \"against all the existing code. If the master branch has a rich suite of unit tests \"\n               \"this will detect any bugs in the proposed merger. If all the tests pass, then the \"\n               \"owner of the master branch can have confidence that the merger will be okay.\")\n    contents = [((\"Configure this machine to be a CI server. Unfortunately, this step requires \"\n                  \"sudo authority because the API accesses the crontab for arbitrary users.\"), \n                 \"sudo ci.py -setup\", \n                 (\"Before this setup can proceed, you need to make sure the global configuration \"\n                  \"XML file has been created and the environment variable to its path has been set:\\n\"\n                  \"\\texport PYCI_XML='~/path/to/global.xml'.\\nSee also: -rollback\")),\n                ((\"Remove the cron tab from the server, delete the list of installed repositories \"\n                  \"and undo anything else that the script did when -setup was used.\"),\n                 \"sudo ci.py -rollback\",\n                 (\"This action deletes the files specified in 'ARCHFILE' and 'DATAFILE' in 'global.xml'. \"\n                  \"Also, the crontab is removed, which is why sudo privileges are needed. See also -setup.\")),\n                ((\"Install the repository described by myrepo.xml onto the CI server so that \"\n                  \"it's pull requests are monitored and unit ,tested.\"),\n                 \"ci.py -install myrepo.xml\",\n                 (\"After installation, you can query the repository immediately by running the \"\n                  \"script with -cron. You can install a list of repositories with a single command.\"\n                  \"See also -uninstall.\")),\n                ((\"Run the routines that check for new pull requests, run the unit tests, and post \"\n                  \"the results to the media wiki.\"),\n                 \"ci.py -cron\", \"\")]\n    required = (\"REQUIRED:\\n\\t-'repo.xml' file for *each* repository that gets installed on the server.\\n\"\n                \"\\t-'global.xml' file with configuration settings for *all* repositories.\\n\"\n                \"\\t- git user and API key with push access for *each* repository installed.\")\n    output = (\"RETURNS: prints status information to stdout.\")\n    details = (\"This script installs a continous integration server on the local machine by \"\n               \"configuring a cron to call this script every couple of minutes. The script interacts \"\n               \"with github using an API to monitor the pull requests. When new ones are found, the \"\n               \"list of tests specified in the 'repo.xml' file is executed and the results are posted \"\n               \"to a media wiki page associated with the specific pull request. For more details, see \"\n               \"the online repo at https://github.com/rosenbrockc/ci.\")\n    outputfmt = (\"\")\n\n    from pyci.msg import example\n    example(script, explain, contents, required, output, outputfmt, details)", "response": "Prints examples of using the script to the console using colored output."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the command line options and arguments from the command line.", "response": "def _parser_options():\n    \"\"\"Parses the options and arguments from the command line.\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"UNCLE Cron Server\")\n    parser.add_argument(\"-examples\", action=\"store_true\",\n                        help=\"Display examples of how to use this script.\")\n    parser.add_argument(\"-setup\", action=\"store_true\",\n                        help=(\"Setup the cron tab and script database for this server so \"\n                              \"that it is ready to have repositories installed.\"))\n    parser.add_argument(\"-rollback\", action=\"store_true\",\n                        help=(\"Remove this script's cron tab and reverse other things done \"\n                              \"by this script. This does not delete this script.\"))\n    parser.add_argument(\"-enable\", action=\"store_true\",\n                        help=\"Re-enable the continuous integration server.\")\n    parser.add_argument(\"-disable\", action=\"store_true\",\n                        help=(\"Disable the continuous integration server so that it no longer \"\n                              \"monitors the installed repositories.\"))\n    parser.add_argument(\"-cron\", action=\"store_true\",\n                        help=(\"Run the continuous integration routines for all the repos installed \"\n                              \"in this script's database.\"))\n    parser.add_argument(\"-list\", action=\"store_true\",\n                        help=\"List all the repositories in the CI server's database.\")\n    parser.add_argument(\"-install\", nargs=\"+\",\n                        help=(\"Install the specified XML file(s) as repositories to be monitored \"\n                              \"by the CI server.\"))\n    parser.add_argument(\"-uninstall\", nargs=\"+\",\n                        help=(\"Uninstall the specified XML file(s) as repositories from \"\n                              \"the CI server.\"))\n    parser.add_argument(\"--verbose\", nargs=\"?\", type=int, const=1,\n                        help=\"Runs the CI server in verbose mode.\")\n    parser.add_argument(\"-cronfreq\", type=int, default=1,\n                        help=\"Specify the frequency at which the cron runs.\")\n    parser.add_argument(\"-nolive\", action=\"store_true\",\n                        help=(\"For unit testing, when specified no live requests are made to \"\n                              \"servers and all the class actions are performed in test mode. \"\n                              \"This also prevents the cron tab from being installed.\"))\n\n    global args\n    args = vars(parser.parse_known_args()[0])\n\n    if args[\"examples\"]:\n        examples()\n        exit(0)\n\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _save_db():\n    from pyci.utility import json_serial\n    import json\n    vms(\"Serializing DB to JSON in {}\".format(datapath))\n    with open(datapath, 'w') as f:\n        json.dump(db, f, default=json_serial)", "response": "Serializes the contents of the script db to JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes sure that the virtualenv specified in the global settings file actually exists.", "response": "def _check_virtualenv():\n    \"\"\"Makes sure that the virtualenv specified in the global settings file\n    actually exists.\n    \"\"\"\n    from os import waitpid\n    from subprocess import Popen, PIPE\n    penvs = Popen(\"source /usr/local/bin/virtualenvwrapper.sh; workon\",\n                 shell=True, executable=\"/bin/bash\", stdout=PIPE, stderr=PIPE)\n    waitpid(penvs.pid, 0)\n    envs = penvs.stdout.readlines()\n    enverr = penvs.stderr.readlines()\n    result = (settings.venv + '\\n') in envs and len(enverr) == 0\n\n    vms(\"Find virtualenv: {}\".format(' '.join(envs).replace('\\n', '')))\n    vms(\"Find virtualenv | stderr: {}\".format(' '.join(enverr)))\n    \n    if not result:\n        info(envs)\n        err(\"The virtualenv '{}' does not exist; can't use CI server.\".format(settings.venv))\n        if len(enverr) > 0:\n            map(err, enverr)\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_global_settings():\n    global settings\n    if settings is not None:\n        #We must have already loaded this and everything was okay!\n        return True\n    \n    from os import getenv\n    result = False\n    \n    if getenv(\"PYCI_XML\") is None:\n        err(\"The environment variable PYCI_XML for the global configuration \"\n            \"has not been set.\")\n    else:\n        from os import path\n        fullpath = path.abspath(path.expanduser(getenv(\"PYCI_XML\")))\n        if not path.isfile(fullpath):\n            err(\"The file {} for global configuration does not exist.\".format(fullpath))\n        else:\n            from pyci.config import GlobalSettings\n            settings = GlobalSettings()\n            result = True\n\n    return result", "response": "Makes sure that the global settings environment variable and file\n    exist for configuration."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting up the crontab if it hasn t already been setup.", "response": "def _setup_crontab():\n    \"\"\"Sets up the crontab if it hasn't already been setup.\"\"\"\n    from crontab import CronTab\n    #Since CI works out of a virtualenv anyway, the `ci.py` script will be\n    #installed in the bin already, so we can call it explicitly.\n    command = '/bin/bash -c \"source ~/.cron_profile; workon {}; ci.py -cron\"'.format(settings.venv)\n    user = _get_real_user()\n    if args[\"nolive\"]:\n        vms(\"Skipping cron tab configuration because 'nolive' enabled.\")\n        return\n    cron = CronTab(user=user)\n    \n    #We need to see if the cron has already been created for this command.\n    existing = False\n    possible = cron.find_comment(\"pyci_cron\")\n    if len(list(possible)) > 0:\n        if args[\"rollback\"]:\n            vms(\"Removing {} from cron tab.\".format(command))\n            cron.remove_all(command)\n            cron.write()\n            db[\"cron\"] = False\n            _save_db()\n        else:\n            existing = True\n    \n    if not existing and not args[\"rollback\"]:\n        job = cron.new(command=command, comment=\"pyci_cron\")\n        #Run the cron every minute of every hour every day.\n        if args[\"cronfreq\"] == 1:\n            vms(\"New cron tab configured *minutely* for {}\".format(command))\n            job.setall(\"* * * * *\")\n        else:\n            vms(\"New cron tab configured every {} minutes for {}.\".format(args[\"cronfreq\"], command))\n            job.setall(\"*/{} * * * *\".format(args[\"cronfreq\"]))\n        cron.write()\n        db[\"cron\"] = True\n        _save_db()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting up the. cron_profile file if it does not already exist.", "response": "def _cron_profile():\n    \"\"\"Sets up the .cron_profile file if it does not already exist.\n    \"\"\"\n    #The main ingredients of the file are the import of the virtualenvwrapper\n    #and the setting of the PYCI_XML variable for global configuration.\n    from os import path\n    cronpath = path.expanduser(\"~/.cron_profile\")\n    if not path.isfile(cronpath):\n        from os import getenv\n        xmlpath = getenv(\"PYCI_XML\")    \n        contents = ['source /usr/local/bin/virtualenvwrapper.sh',\n                    'export PYCI_XML=\"{}\"'.format(xmlpath)]\n        with open(cronpath, 'w') as f:\n            f.write('\\n'.join(contents))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _setup_server():\n    if args[\"setup\"] or args[\"install\"]:\n        #If the cron has been configured, it means that the server has been\n        #setup. We also perform some checks of the configuration file and the\n        #existence of the virtualenv.\n        if not _check_global_settings() or not _check_virtualenv():\n            return False\n\n        _cron_profile()\n        if \"cron\" in db and not db[\"cron\"]:\n            _setup_crontab()\n\n    if args[\"rollback\"]:\n        _setup_crontab()", "response": "Checks whether the server needs to be setup if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _server_rollback():\n    #Remove the data and archive files specified in settings. The cron\n    #gets remove by the _setup_server() script if -rollback is specified.\n    from os import path, remove\n    archpath = path.abspath(path.expanduser(settings.archfile))\n    if path.isfile(archpath) and not args[\"nolive\"]:\n        vms(\"Removing archive JSON file at {}.\".format(archpath))\n        remove(archpath)\n    datapath = path.abspath(path.expanduser(settings.datafile))\n    if path.isfile(datapath) and not args[\"nolive\"]:\n        vms(\"Removing script database JSON file at {}\".format(datapath))\n        remove(datapath)", "response": "Removes the data and archive files to rollback the CI server\n    installation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether the server should be enabled and makes the change accordingly.", "response": "def _server_enable():\n    \"\"\"Checks whether the server should be enabled/disabled and makes the\n    change accordingly.\n    \"\"\"\n    prev = None if \"enabled\" not in db else db[\"enabled\"]\n    if args[\"disable\"]:\n        db[\"enabled\"] = False\n        okay(\"Disabled the CI server. No pull requests will be processed.\")\n\n    if args[\"enable\"]:\n        db[\"enabled\"] = True\n        okay(\"Enabled the CI server. Pull request monitoring online.\")\n\n    #Only perform the save if something actually changed.\n    if prev != db[\"enabled\"]:\n        _save_db()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the next repository to run based on the current state of the database.", "response": "def _find_next(server):\n    \"\"\"Finds the name of the next repository to run based on the *current*\n    state of the database.\n    \"\"\"\n    from datetime import datetime\n    #Re-load the database in case we have multiple instances of the script\n    #running in memory.\n    _load_db()\n    result = None\n    visited = []\n    \n    if \"status\" in db:\n        for reponame, status in db[\"status\"].items():\n            vms(\"Checking cron status for {}: {}\".format(reponame, status))\n            start = None if \"started\" not in status else status[\"started\"]\n            end = None if \"end\" not in status else status[\"end\"]\n            running = start is not None and end is not None and start > end\n            add = False\n            \n            if not running and end is not None:\n                #Check the last time it was run and see if enough time has\n                #elapsed.\n                elapsed = (datetime.now() - end).seconds/60\n                add = elapsed > server.cron.settings[reponame].frequency\n                if not add:\n                    vms(\"'{}' skipped because the interval hasn't \".format(reponame) +\n                        \"elapsed ({} vs. {})\".format(elapsed, server.cron.settings[reponame].frequency))\n            elif end is None:\n                add = True\n\n            if add:\n                result = reponame\n                break\n            visited.append(reponame)\n    else:\n        db[\"status\"] = {}        \n\n\n    if result is None:\n        #We still need to check the newly installed repos.            \n        for reponame, repo in server.repositories.items():\n            if reponame not in visited:\n                #These are newly installed repos that have never run before.\n                vms(\"Added '{}' as new repo for cron execution.\".format(reponame))\n                result = reponame\n                break\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the cron request.", "response": "def _do_cron():\n    \"\"\"Handles the cron request to github to check for new pull requests. If\n    any are found, they are run *sequentially* until they are all completed.\n    \"\"\"\n    if not args[\"cron\"]:\n        return\n    \n    if (\"enabled\" in db and not db[\"enabled\"]) or \"enabled\" not in db:\n        warn(\"The CI server is disabled. Exiting.\")\n        exit(0)\n    #Our basic idea with the cron is as follows:\n    # - the cron runs every minute of the day.\n    # - each installed XML file has the last time it ran saved in the script's\n    #   database. If the specified check frequency has elapsed since it last\n    #   ran, then we run the repository server checks.\n    # - NB: before running the time-intensive checks against remote servers\n    #   or running the unit tests, first update the running status of the repo\n    #   so that another call with -cron doesn't duplicate the work!\n\n    #By having the cron run every minute, we maximize the probability that\n    #repo checks with time intensive unit tests may run in parallel. Since\n    #servers usually have many cores, this shouldn't impact the run times too\n    #severely unless the tests are disk intensive.\n\n    #We use the repo full names as keys in the db's status dictionary.\n    from pyci.server import Server\n    from datetime import datetime\n    attempted = []\n    server = Server(testmode=args[\"nolive\"])\n    nextrepo = _find_next(server)\n    dbs = db[\"status\"]\n    \n    while nextrepo is not None:\n        vms(\"Working on '{}' in cron.\".format(nextrepo))\n        if nextrepo in attempted:\n            #This makes sure we don't end up in an infinite loop.\n            vms(\"'{}' has already been handled! Exiting infinite loop.\".format(nextrepo))\n            break\n        \n        if nextrepo not in dbs:\n            vms(\"Created blank status dictionary for '{}' in db.\".format(nextrepo))\n            dbs[nextrepo] = {\"start\": None, \"end\": None}\n        dbs[nextrepo][\"start\"] = datetime.now()\n        _save_db()\n\n        #Now that we have saved our intent to run these repo-checks, let's\n        #actually run them.\n        attempted.append(nextrepo)\n        server.runnable = [nextrepo]\n        if not args[\"nolive\"]:\n            vms(\"Starting pull request processing for '{}'.\".format(nextrepo))\n            server.process_pulls()\n    \n        dbs[nextrepo][\"end\"] = datetime.now()\n        _save_db()\n        nextrepo = _find_next(server)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists all the installed repos as well as their last start and finish times from the cron s perspective.", "response": "def _list_repos():\n    \"\"\"Lists all the installed repos as well as their last start and finish\n    times from the cron's perspective.\n    \"\"\"\n    if not args[\"list\"]:\n        return\n    \n    #Just loop over the list of repos we have in a server instance. See if\n    #they also exist in the db's status; if they do, include the start/end\n    #times we have saved.\n    from pyci.server import Server\n    server = Server(testmode=args[\"nolive\"])\n    output = [\"Repository           |      Started     |      Finished    | XML File Path\",\n              \"--------------------------------------------------------------------------\"]\n\n    dbs = {} if \"status\" not in db else db[\"status\"]\n    fullfmt = \"{0:<20} | {1:^16} | {2:^16} | {3}\"\n    for reponame, repo in server.repositories.items():\n        if reponame in dbs:\n            start = _fmt_time(dbs[reponame][\"start\"])\n            end = _fmt_time(dbs[reponame][\"end\"])\n        else:\n            start = \"Never\"\n            end = \"Never\"\n        output.append(fullfmt.format(reponame, start, end, repo.filepath))\n\n    info('\\n'.join(output))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _handle_install():\n    from pyci.server import Server\n    if args[\"install\"]:\n        server = Server(testmode=args[\"nolive\"])\n        for xpath in args[\"install\"]:\n            server.install(xpath)\n            okay(\"Installed {} into the CI server.\".format(xpath))\n    if args[\"uninstall\"]:\n        server = Server(testmode=args[\"nolive\"])\n        for xpath in args[\"uninstall\"]:\n            server.uninstall(xpath)\n            okay(\"Uninstalled {} from the CI server.\".format(xpath))", "response": "Handles the installation of repositories on this CI server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef partition(string, sep):\n    p = string.split(sep, 1)\n    if len(p) == 2:\n        return p[0], sep, p[1]\n    return string, '', ''", "response": "Partition string into two parts."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _idle_register_view(self, view):\n        assert(self.view is None)\n        self.view = view\n\n        if self.handlers == \"class\":\n            for name in dir(self):\n                when, _, what = partition(name, '_')\n                widget, _, signal = partition(what, '__')\n                if when == \"on\":\n                    try:\n                        view[widget].connect(signal, getattr(self, name))\n                    except IndexError:\n                        # Not a handler\n                        pass\n                    except KeyError:\n                        logger.warn(\"Widget not found for handler: %s\", name)\n        elif self.handlers == \"glade\":\n            self.__autoconnect_signals()\n        else:\n            raise NotImplementedError(\"%s is not a valid source of signal \"\n                \"connections\" % self.handlers)\n\n        self.register_view(view)\n        self.register_adapters()\n        if self.__auto_adapt: self.adapt()\n        return False", "response": "Internal method that calls register_view and adaptes the view if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsearching the view for :class:`TreeView` instances and call :meth:`setup_column` on all their columns. .. note:: This is a convenience function. It is never called by the framework. You are free to repurpose it in subclasses. For editing to work, the widget must already be connected to a model. If you don't use :class:`ListStoreModel` this can be done in Glade, however a `bug <https://bugzilla.gnome.org/show_bug.cgi?id=597095>`_ makes versions prior to 3.7.0 (released March 10th, 2010) remove Python columns on save. If you want to correct the XML manually, it should look like this:: <object class=\"GtkListStore\" id=\"liststore1\"> <columns> <column type=\"PyObject\"/> </columns> </object>", "response": "def setup_columns(self):\n        \"\"\"\n        Search the view for :class:`TreeView` instances and call\n        :meth:`setup_column` on all their columns.\n\n        .. note::\n           This is a convenience function. It is never called by the framework.\n           You are free to repurpose it in subclasses.\n\n        For editing to work, the widget must already be connected to a model.\n        If you don't use :class:`ListStoreModel` this can be done in Glade,\n        however a `bug <https://bugzilla.gnome.org/show_bug.cgi?id=597095>`_\n        makes versions prior to 3.7.0 (released March 10th, 2010) remove\n        Python columns on save. If you want to correct the XML manually, it\n        should look like this::\n\n         <object class=\"GtkListStore\" id=\"liststore1\">\n           <columns>\n             <column type=\"PyObject\"/>\n           </columns>\n         </object>\n        \"\"\"\n        for name in self.view:\n            w = self.view[name]\n            if isinstance(w, Gtk.TreeView):\n                m = w.get_model()\n                for c in w.get_columns():\n                    self.setup_column(c, model=m)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets up a :class:`TreeView` to display attributes of Python objects stored in its :class:`TreeModel`. This assumes that :class:`TreeViewColumn` instances have already been added and :class:`CellRenderer` instances packed into them. Both can be done in Glade. *model* is the instance displayed by the widget. You only need to pass this if you set *renderer* to be editable. If you use sorting or filtering this may not be the actual data store, but all tree paths and column indexes are relative to this. Defaults to our model. *widget* is a column, or a string naming one in our view. *column* is an integer addressing the column in *model* that holds your objects. *attribute* is a string naming an object attribute to display. Defaults to the name of *widget*. *renderer* defaults to the first one found in *widget*. *property* is a string naming the property of *renderer* to set. If not given this is guessed based on the type of *renderer*. *from_python* is a callable. It gets passed a value from the object and must return it in a format suitable for *renderer*. If not given this is guessed based on *property*. *to_python* is a callable. It gets passed a value from *renderer* and must return it in a format suitable for the attribute. If not given a cast to the type of the previous attribute value is attempted. If you need more flexibility, like setting multiple properties, setting your own cell data function will override the internal one. Returns an integer you can use to disconnect the internal editing callback from *renderer*, or None. .. versionadded:: 1.99.2", "response": "def setup_column(self, widget, column=0, attribute=None, renderer=None,\n        property=None, from_python=None, to_python=None, model=None):\n        # Maybe this is too overloaded.\n        \"\"\"\n        Set up a :class:`TreeView` to display attributes of Python objects\n        stored in its :class:`TreeModel`.\n\n        This assumes that :class:`TreeViewColumn` instances have already\n        been added and :class:`CellRenderer` instances packed into them.\n        Both can be done in Glade.\n\n        *model* is the instance displayed by the widget. You only need to pass\n        this if you set *renderer* to be editable.\n        If you use sorting or filtering this may not be the actual data store,\n        but all tree paths and column indexes are relative to this.\n        Defaults to our model.\n\n        *widget* is a column, or a string naming one in our view.\n\n        *column* is an integer addressing the column in *model* that holds your\n        objects.\n\n        *attribute* is a string naming an object attribute to display. Defaults\n        to the name of *widget*.\n\n        *renderer* defaults to the first one found in *widget*.\n\n        *property* is a string naming the property of *renderer* to set. If not\n        given this is guessed based on the type of *renderer*.\n\n        *from_python* is a callable. It gets passed a value from the object and\n        must return it in a format suitable for *renderer*. If not given this\n        is guessed based on *property*.\n\n        *to_python* is a callable. It gets passed a value from *renderer* and\n        must return it in a format suitable for the attribute. If not given a\n        cast to the type of the previous attribute value is attempted.\n\n        If you need more flexibility, like setting multiple properties, setting\n        your own cell data function will override the internal one.\n\n        Returns an integer you can use to disconnect the internal editing\n        callback from *renderer*, or None.\n\n        .. versionadded:: 1.99.2\n        \"\"\"\n        if isinstance(widget, str):\n            widget = self.view[widget]\n        if not model and isinstance(self.model, Gtk.TreeModel):\n            model = self.model\n        return setup_column(widget, column=column, attribute=attribute,\n            renderer=renderer, property=property, from_python=from_python,\n            to_python=to_python, model=model)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef adapt(self, *args, **kwargs):\n\n        # checks arguments\n        n = len(args)\n\n        flavour = kwargs.get(\"flavour\", None)\n\n        if n==0:\n            adapters = []\n            props = self.model.get_properties()\n            # matches all properties not previoulsy adapter by the user:\n            for prop_name in (p for p in props\n                              if p not in self.__user_props):\n                try: wid_name = self._find_widget_match(prop_name)\n                except TooManyCandidatesError as e:\n                    # multiple candidates, gives up\n                    raise e\n                except ValueError as e:\n                    # no widgets found for given property, continue after emitting a warning\n                    if e.args:\n                        logger.warn(e[0])\n                    else:\n                        logger.warn(\"No widget candidates match property '%s'\"\n                            % prop_name)\n                else:\n                    logger.debug(\"Auto-adapting property %s and widget %s\" % \\\n                                     (prop_name, wid_name))\n                    adapters += self.__create_adapters__(prop_name, wid_name, flavour)\n\n        elif n == 1: #one argument\n            if isinstance(args[0], Adapter): adapters = (args[0],)\n\n            elif isinstance(args[0], str):\n                prop_name = args[0]\n                wid_name = self._find_widget_match(prop_name)\n                adapters = self.__create_adapters__(prop_name, wid_name, flavour)\n\n            else:\n                raise TypeError(\"Argument of adapt() must be either an \"\n                                \"Adapter or a string\")\n\n        elif n == 2: # two arguments\n            if not (isinstance(args[0], str) and\n                    isinstance(args[1], str)):\n                raise TypeError(\"Arguments of adapt() must be two strings\")\n\n            # retrieves both property and widget, and creates an adapter\n            prop_name, wid_name = args\n            adapters = self.__create_adapters__(prop_name, wid_name, flavour)\n\n        elif n == 3:\n            for arg in args:\n                if not isinstance(arg, str):\n                    raise TypeError(\"names must be strings\")\n\n            prop_name, wid_name, gprop_name = args\n            ad = Adapter(self.model, prop_name)\n            ad.connect_widget(self.view[wid_name],\n                              getter=lambda w: w.get_property(gprop_name),\n                              setter=lambda w, v: w.set_property(gprop_name, v),\n                              signal='notify::%s' % gprop_name,\n                              flavour=flavour)\n            adapters = [ad]\n\n        else:\n            raise TypeError(\n                \"adapt() takes at most three arguments (%i given)\" % n)\n\n        for ad in adapters:\n            self.__adapters.append(ad)\n            # remember properties added by the user\n            if n > 0: self.__user_props.add(ad.get_property_name())", "response": "Adapt the given property names to the view by name and create adapters for the given widget type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _find_widget_match(self, prop_name):\n        names = []\n        for wid_name in self.view:\n            # if widget names ends with given property name: we skip\n            # any prefix in widget name\n            if wid_name.lower().endswith(prop_name.lower()):\n                names.append(wid_name)\n\n        if len(names) == 0:\n            raise ValueError(\"No widget candidates match property '%s': %s\" % \\\n                                 (prop_name, names))\n\n        if len(names) > 1:\n            raise TooManyCandidatesError(\"%d widget candidates match property '%s': %s\" % \\\n                                             (len(names), prop_name, names))\n\n        return names[0]", "response": "Find the best match for a given property name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __autoconnect_signals(self):\n        dic = {}\n        for name in dir(self):\n            method = getattr(self, name)\n            if (not isinstance(method, collections.Callable)):\n                continue\n            assert(name not in dic) # not already connected!\n            dic[name] = method\n\n        # autoconnects glade in the view (if available any)\n        for xml in self.view.glade_xmlWidgets:\n            xml.signal_autoconnect(dic)\n\n        # autoconnects builder if available\n        if self.view._builder is not None:\n            self.view._builder_connect_signals(dic)", "response": "This is called during view registration to autoconnect signals in glade file with methods within the controller."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the unqualified teams extension request parameters and add them to this object.", "response": "def parseExtensionArgs(self, args):\n        \"\"\"Parse the unqualified teams extension request\n        parameters and add them to this object.\n\n        This method is essentially the inverse of\n        C{L{getExtensionArgs}}. This method restores the serialized teams\n        extension team names.\n\n        If you are extracting arguments from a standard OpenID\n        checkid_* request, you probably want to use C{L{fromOpenIDRequest}},\n        which will extract the teams extension namespace and arguments from the\n        OpenID request. This method is intended for cases where the\n        OpenID server needs more control over how the arguments are\n        parsed than that method provides.\n\n        >>> args = message.getArgs(teams_uri)\n        >>> request.parseExtensionArgs(args)\n\n        @param args: The unqualified teams extension arguments\n        @type args: {str:str}\n\n        @returns: None; updates this object\n        \"\"\"\n        items = args.get('query_membership')\n        if items:\n            for team_name in items.split(','):\n                self.requestTeam(team_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef requestTeam(self, team_name):\n        if not team_name in self.requested:\n            self.requested.append(team_name)", "response": "Request the specified team membership from the OpenID user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef requestTeams(self, team_names):\n        if isinstance(team_names, six.string_types):\n            raise TypeError('Teams should be passed as a list of '\n                            'strings (not %r)' % (type(field_names),))\n\n        for team_name in team_names:\n            self.requestTeam(team_name)", "response": "Add the given list of team names to the request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a C{L{TeamsRequest} and a list of teams that the user is member of and creates a C{L{TeamsResponse}} containing the list of team names that are both requested and in the membership list of the user.", "response": "def extractResponse(cls, request, teams):\n        \"\"\"Take a C{L{TeamsRequest}} and a list of groups\n        the user is member of and create a C{L{TeamsResponse}}\n        object containing the list of team names that are both\n        requested and in the membership list of the user.\n\n        @param request: The teams extension request object\n        @type request: TeamsRequest\n\n        @param teams: The list of teams the user is a member of\n        @type teams: [str]\n\n        @returns: a teams extension response object\n        @rtype: TeamsResponse\n        \"\"\"\n        self = cls()\n        for team in request.requestedTeams():\n            if team in teams:\n                self.teams.append(team)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fromSuccessResponse(cls, success_response, signed_only=True):\n        self = cls()\n        if signed_only:\n            args = success_response.getSignedNS(self.ns_uri)\n        else:\n            args = success_response.message.getArgs(self.ns_uri)\n\n        if not args:\n            return None\n\n        self.teams = []\n\n        items = args['is_member']\n        if items:\n            for team_name in items.split(','):\n                self.teams.append(team_name)\n\n        return self", "response": "Create a new instance of the object from a success response."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_property(obj, name):\n        if obj == None or name == None:\n            return False\n\n        names = name.split(\".\")\n        if names == None or len(names) == 0: \n            return False\n\n        return RecursiveObjectReader._perform_has_property(obj, names, 0)", "response": "Checks recursively if object or its subobjects has a property with specified name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_property(obj, name):\n        if obj == None or name == None:\n            return None\n\n        names = name.split(\".\")\n        if names == None or len(names) == 0:\n            return None\n\n        return RecursiveObjectReader._perform_get_property(obj, names, 0)", "response": "Recursive get property of object or array."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget values of all properties in specified object and its subobjects and returns them as a map.", "response": "def get_properties(obj):\n        \"\"\"\n        Get values of all properties in specified object and its subobjects and returns them as a map.\n\n        The object can be a user defined object, map or array.\n        Returned properties correspondently are object properties, map key-pairs or array elements with their indexes.\n\n        :param obj: an object to get properties from.\n\n        :return: a map, containing the names of the object's properties and their values.\n        \"\"\"\n        properties = {}\n        \n        if obj != None:\n            cycle_detect = []\n            RecursiveObjectReader._perform_get_properties(obj, None, properties, cycle_detect)\n\n        return properties"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitialising hookery in a class that declares hooks by decorating it with this decorator. This replaces the class with another one which has the same name, but also inherits Hookable which has HookableMeta set as metaclass so that sub-classes of cls will have hook descriptors initialised properly. When you say: @hookable class My: before = Hook() then @hookable changes My.before to be a HookDescriptor which is then changed into Hook if anyone accesses it. There is no need to decorate sub-classes of cls with @hookable.", "response": "def hookable(cls):\n    \"\"\"\n    Initialise hookery in a class that declares hooks by decorating it with this decorator.\n\n    This replaces the class with another one which has the same name, but also inherits Hookable\n    which has HookableMeta set as metaclass so that sub-classes of cls will have hook descriptors\n    initialised properly.\n\n    When you say:\n        @hookable\n        class My:\n            before = Hook()\n\n    then @hookable changes My.before to be a HookDescriptor which is then\n    changed into Hook if anyone accesses it.\n\n    There is no need to decorate sub-classes of cls with @hookable.\n    \"\"\"\n    assert isinstance(cls, type)\n\n    # For classes that won't have descriptors initialised by metaclass, need to do it here.\n    hook_definitions = []\n    if not issubclass(cls, Hookable):\n        for k, v in list(cls.__dict__.items()):\n            if isinstance(v, (ClassHook, InstanceHook)):\n                delattr(cls, k)\n                if v.name is None:\n                    v.name = k\n                hook_definitions.append((k, v))\n\n    hookable_cls = type(cls.__name__, (cls, Hookable), {})\n\n    for k, v in hook_definitions:\n        setattr(hookable_cls, k, HookDescriptor(defining_hook=v, defining_class=hookable_cls))\n\n    return hookable_cls"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef unregister_handler(self, handler_or_func):\n        index = -1\n        for i, handler in enumerate(self._direct_handlers):\n            if handler is handler_or_func or handler._original_func is handler_or_func:\n                index = i\n                break\n        if index >= 0:\n            self._direct_handlers.pop(index)\n            self._cached_handlers = None\n\n        elif self.parent_class_hook is not None and self.parent_class_hook.has_handler(handler_or_func):\n            self.parent_class_hook.unregister_handler(handler_or_func)\n            self._cached_handlers = None\n\n        elif self.instance_class_hook is not None and self.instance_class_hook.has_handler(handler_or_func):\n            self.instance_class_hook.unregister_handler(handler_or_func)\n            self._cached_handlers = None\n\n        else:\n            raise ValueError('{} is not a registered handler of {}'.format(handler_or_func, self))", "response": "Unregisters the handler_or_func from this class hook s list of handlers."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nnotifies the user that a particular exercise has been solved.", "response": "def notifySolved(self, identifier, title):\n        \"\"\"Notifies the user that a particular exercise has been solved.\n\n        \"\"\"\n        notify(self.workbench, u\"Congratulations\", u\"Congratulations! You \"\n               \"have completed the '{title}' exercise.\".format(title=title))\n        return {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prepend_urls(self):\n        return [\n            url(r\"^(?P<resource_name>%s)/(?P<pk>\\w[\\w/-]*)/generate%s$\" %\n                (self._meta.resource_name, trailing_slash()),\n                self.wrap_view('generate'), name=\"api_tileset_generate\"),\n            url(r\"^(?P<resource_name>%s)/(?P<pk>\\w[\\w/-]*)/download%s$\" %\n                (self._meta.resource_name, trailing_slash()),\n                self.wrap_view('download'), name=\"api_tileset_download\"),\n            url(r\"^(?P<resource_name>%s)/(?P<pk>\\w[\\w/-]*)/status%s$\" %\n                (self._meta.resource_name, trailing_slash()),\n                self.wrap_view('status'), name=\"api_tileset_status\"),\n            url(r\"^(?P<resource_name>%s)/(?P<pk>\\w[\\w/-]*)/stop%s$\" %\n                (self._meta.resource_name, trailing_slash()),\n                self.wrap_view('stop'), name=\"api_tileset_stop\"),\n        ]", "response": "Adds the following array of urls to the Tileset base urls"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate(self, request, **kwargs):\n\n        # method check to avoid bad requests\n        self.method_check(request, allowed=['get'])\n\n        # create a basic bundle object for self.get_cached_obj_get.\n        basic_bundle = self.build_bundle(request=request)\n\n        # using the primary key defined in the url, obtain the tileset\n        tileset = self.cached_obj_get(\n            bundle=basic_bundle,\n            **self.remove_api_resource_names(kwargs))\n\n        # Return what the method output, tastypie will handle the serialization\n        return self.create_response(request, tileset.generate())", "response": "method to generate the object for the requested resource"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndownloads the object from the tileset", "response": "def download(self, request, **kwargs):\n        \"\"\" proxy for the helpers.tileset_download method \"\"\"\n\n        # method check to avoid bad requests\n        self.method_check(request, allowed=['get'])\n\n        # create a basic bundle object for self.get_cached_obj_get.\n        basic_bundle = self.build_bundle(request=request)\n\n        # using the primary key defined in the url, obtain the tileset\n        tileset = self.cached_obj_get(\n            bundle=basic_bundle,\n            **self.remove_api_resource_names(kwargs))\n\n        filename = helpers.get_tileset_filename(tileset)\n        filename = os.path.abspath(filename)\n        if os.path.isfile(filename):\n            response = serve(request, os.path.basename(filename), os.path.dirname(filename))\n            response['Content-Disposition'] = 'attachment; filename=\"{}\"'.format(os.path.basename(filename))\n        else:\n            response = self.create_response(request, {'status': 'not generated'})\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconfigure the component with specified parameters.", "response": "def configure(self, config):\n        \"\"\"\n        Configures the component with specified parameters.\n\n        :param config: configuration parameters to set.\n        \"\"\"\n        dependencies = config.get_section(\"dependencies\")\n        names = dependencies.get_key_names()\n        for name in names:\n            locator = dependencies.get(name)\n            if locator == None:\n                continue\n            \n            try:\n                descriptor = Descriptor.from_string(locator)\n                if descriptor != None:\n                    self._dependencies[name] = descriptor\n                else:\n                    self._dependencies[name] = locator\n            except Exception as ex:\n                self._dependencies[name] = locator"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _locate(self, name):\n        if name == None:\n            raise Exception(\"Dependency name cannot be null\")\n        if self._references == None:\n            raise Exception(\"References shall be set\")\n        \n        return self._dependencies.get(name)", "response": "Locates a dependency by its name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all optional dependencies by their name.", "response": "def get_optional(self, name):\n        \"\"\"\n        Gets all optional dependencies by their name.\n\n        :param name: the dependency name to locate.\n\n        :return: a list with found dependencies or empty list of no dependencies was found.\n        \"\"\"\n        locator = self._locate(name)\n        return self._references.get_optional(locator) if locator != None else None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_required(self, name):\n        locator = self._locate(name)\n        if locator == None:\n            raise ReferenceException(None, name)\n        \n        return self._references.get_required(locator)", "response": "Gets all required dependencies by their name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget one optional dependency by its name.", "response": "def get_one_optional(self, name):\n        \"\"\"\n        Gets one optional dependency by its name.\n\n        :param name: the dependency name to locate.\n\n        :return: a dependency reference or null of the dependency was not found\n        \"\"\"\n        locator = self._locate(name)\n        return self._references.get_one_optional(locator) if locator != None else None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_one_required(self, name):\n        locator = self._locate(name)\n        if locator == None:\n            raise ReferenceException(None, name)\n        \n        return self._references.get_one_required(locator)", "response": "Gets one required dependency by its name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds all matching dependencies by their name.", "response": "def find(self, name, required):\n        \"\"\"\n        Finds all matching dependencies by their name.\n\n        :param name: the dependency name to locate.\n\n        :param required: true to raise an exception when no dependencies are found.\n\n        :return: a list of found dependencies\n        \"\"\"\n        if name == None:\n            raise Exception(\"Name cannot be null\")\n        \n        locator = self._locate(name)\n        if locator == None:\n            if required:\n                raise ReferenceException(None, name)\n            return None\n        \n        return self._references.find(locator, required)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_tuples(*tuples):\n        result = DependencyResolver()\n        if tuples == None or len(tuples) == 0:\n            return result\n        \n        index = 0\n        while index < len(tuples):\n            if index + 1 >= len(tuples):\n                break\n\n            name = StringConverter.to_string(tuples[index])\n            locator = tuples[index + 1]\n\n            result.put(name, locator)\n            index = index + 2\n        \n        return result", "response": "Creates a new DependencyResolver from a list of key - value pairs called tuples\n        where key is dependency name and value is the depedency locator."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef obtain_to(filename):\n    root, _ = nc.open(filename)\n    lat, lon = nc.getvar(root, 'lat')[0,:], nc.getvar(root, 'lon')[0,:]\n    nc.close(root)\n    return obtain(lat, lon)", "response": "Return the digital elevation map projected to the lat lon matrix coordenates."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef persist(filename):\n    dem_projected = obtain_to(filename)\n    with nc.loader(filename) as root:\n        data = nc.getvar(root, 'data')\n        dem = nc.getvar(root, 'dem', 'f4', source=data)\n        stack = [dim for dim in dem.shape if dim not in dem_projected.shape]\n        stack = stack[0] if stack else 1\n        dem[:] = np.vstack(map(lambda x: [dem_projected], range(stack)))", "response": "Persist the digital elevation map projected to the netcdf file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(arguments=None):\n    from astrocalc.coords import unit_conversion\n    # setup the command-line util settings\n    su = tools(\n        arguments=arguments,\n        docString=__doc__,\n        logLevel=\"CRITICAL\",\n        options_first=True,\n        projectName=\"astrocalc\"\n    )\n    arguments, settings, log, dbConn = su.setup()\n\n    # tab completion for raw_input\n    readline.set_completer_delims(' \\t\\n;')\n    readline.parse_and_bind(\"tab: complete\")\n    readline.set_completer(tab_complete)\n\n    # unpack remaining cl arguments using `exec` to setup the variable names\n    # automatically\n    for arg, val in arguments.iteritems():\n        if arg[0] == \"-\":\n            varname = arg.replace(\"-\", \"\") + \"Flag\"\n        else:\n            varname = arg.replace(\"<\", \"\").replace(\">\", \"\")\n        if isinstance(val, str) or isinstance(val, unicode):\n            exec(varname + \" = '%s'\" % (val,))\n        else:\n            exec(varname + \" = %s\" % (val,))\n        if arg == \"--dbConn\":\n            dbConn = val\n        log.debug('%s = %s' % (varname, val,))\n\n    ## START LOGGING ##\n    startTime = times.get_now_sql_datetime()\n    log.info(\n        '--- STARTING TO RUN THE cl_utils.py AT %s' %\n        (startTime,))\n\n    # set options interactively if user requests\n    if \"interactiveFlag\" in locals() and interactiveFlag:\n\n        # load previous settings\n        moduleDirectory = os.path.dirname(__file__) + \"/resources\"\n        pathToPickleFile = \"%(moduleDirectory)s/previousSettings.p\" % locals()\n        try:\n            with open(pathToPickleFile):\n                pass\n            previousSettingsExist = True\n        except:\n            previousSettingsExist = False\n        previousSettings = {}\n        if previousSettingsExist:\n            previousSettings = pickle.load(open(pathToPickleFile, \"rb\"))\n\n        # x-raw-input\n        # x-boolean-raw-input\n        # x-raw-input-with-default-value-from-previous-settings\n\n        # save the most recently used requests\n        pickleMeObjects = []\n        pickleMe = {}\n        theseLocals = locals()\n        for k in pickleMeObjects:\n            pickleMe[k] = theseLocals[k]\n        pickle.dump(pickleMe, open(pathToPickleFile, \"wb\"))\n\n    # CALL FUNCTIONS/OBJECTS\n    if coordflip:\n\n        if cartesianFlag:\n            converter = unit_conversion(\n                log=log\n            )\n            x, y, z = converter.ra_dec_to_cartesian(\n                ra=\"23 45 21.23232\",\n                dec=\"+01:58:5.45341\"\n            )\n            print x, y, z\n            return\n\n        try:\n            ra = float(ra)\n            dec = float(dec)\n            degree = True\n        except Exception, e:\n            degree = False\n\n        if degree is True:\n            converter = unit_conversion(\n                log=log\n            )\n            try:\n                ra = converter.ra_decimal_to_sexegesimal(\n                    ra=ra,\n                    delimiter=\":\"\n                )\n                dec = converter.dec_decimal_to_sexegesimal(\n                    dec=dec,\n                    delimiter=\":\"\n                )\n            except Exception, e:\n                print e\n                sys.exit(0)\n\n            print ra, dec\n        else:\n            converter = unit_conversion(\n                log=log\n            )\n            try:\n                ra = converter.ra_sexegesimal_to_decimal(\n                    ra=ra\n                )\n                dec = converter.dec_sexegesimal_to_decimal(\n                    dec=dec\n                )\n            except Exception, e:\n                print e\n                sys.exit(0)\n            print ra, dec\n\n    if sep:\n        from astrocalc.coords import separations\n        calculator = separations(\n            log=log,\n            ra1=ra1,\n            dec1=dec1,\n            ra2=ra2,\n            dec2=dec2,\n        )\n        angularSeparation, north, east = calculator.get()\n        print \"\"\"%(angularSeparation)s arcsec (%(north)s N, %(east)s E)\"\"\" % locals()\n\n    if timeflip:\n        try:\n            inputMjd = float(datetime)\n            if datetime[0] not in [\"0\", \"1\", \"2\"]:\n                inputMjd = True\n            else:\n                inputMjd = False\n        except:\n            inputMjd = False\n        from astrocalc.times import conversions\n        converter = conversions(\n            log=log\n        )\n\n        if inputMjd == False:\n            try:\n                mjd = converter.ut_datetime_to_mjd(utDatetime=datetime)\n                print mjd\n            except Exception, e:\n                print e\n        else:\n            try:\n                utDate = converter.mjd_to_ut_datetime(mjd=datetime)\n                print utDate\n            except Exception, e:\n                print e\n\n    if trans:\n        # TRANSLATE COORDINATES ACROSS SKY\n        from astrocalc.coords import translate\n        newRa, newDec = translate(\n            log=log,\n            ra=ra,\n            dec=dec,\n            northArcsec=float(north),\n            eastArcsec=float(east)\n        ).get()\n        from astrocalc.coords import unit_conversion\n        converter = unit_conversion(\n            log=log\n        )\n        ra = converter.ra_decimal_to_sexegesimal(\n            ra=newRa,\n            delimiter=\":\"\n        )\n        dec = converter.dec_decimal_to_sexegesimal(\n            dec=newDec,\n            delimiter=\":\"\n        )\n\n        print \"%(newRa)s, %(newDec)s (%(ra)s, %(dec)s)\" % locals()\n\n    if now:\n        from astrocalc.times import now\n        mjd = now(\n            log=log\n        ).get_mjd()\n        print mjd\n\n    if dist and redshiftFlag:\n        from astrocalc.distances import converter\n        c = converter(log=log)\n        if not hcFlag:\n            hcFlag = 70.\n        if not wmFlag:\n            wmFlag = 0.3\n        if not wvFlag:\n            wvFlag = 0.7\n        dists = c.redshift_to_distance(\n            z=float(distVal),\n            WM=float(wmFlag),\n            WV=float(wvFlag),\n            H0=float(hcFlag)\n        )\n        print \"Distance Modulus: \" + str(dists[\"dmod\"]) + \" mag\"\n        print \"Luminousity Distance: \" + str(dists[\"dl_mpc\"]) + \" Mpc\"\n        print \"Angular Size Scale: \" + str(dists[\"da_scale\"]) + \" kpc/arcsec\"\n        print \"Angular Size Distance: \" + str(dists[\"da_mpc\"]) + \" Mpc\"\n        print \"Comoving Radial Distance: \" + str(dists[\"dcmr_mpc\"]) + \" Mpc\"\n\n    if dist and mpcFlag:\n        from astrocalc.distances import converter\n        c = converter(log=log)\n        z = c.distance_to_redshift(\n            mpc=float(distVal)\n        )\n        print \"z = %(z)s\" % locals()\n\n    if \"dbConn\" in locals() and dbConn:\n        dbConn.commit()\n        dbConn.close()\n    ## FINISH LOGGING ##\n    endTime = times.get_now_sql_datetime()\n    runningTime = times.calculate_time_difference(startTime, endTime)\n    log.info('-- FINISHED ATTEMPT TO RUN THE cl_utils.py AT %s (RUNTIME: %s) --' %\n             (endTime, runningTime, ))\n\n    return", "response": "This is the main function used by the cl_utils. py module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resolve(config, config_as_default = False):\n        options = config.get_section(\"options\")\n\n        if len(options) == 0 and config_as_default:\n            options = config\n\n        return options", "response": "Resolves an options section from component configuration parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decode(self, text):\n        LOGGER.debug('decoding text to dictionary')\n\n        if not text or type(text) is not str:\n            raise SLTPParsingError(ERRORS['unexp_type_str'])\n\n        LOGGER.debug('extracting qualifier')\n        qual = re.compile(r'^(?P<value>(dictionary|mission|mapResource|warehouses) = ?)\\n')\n        match = qual.match(text)\n\n        if match is None:\n            raise ValueError('qualifier not found; first line: {}'.format(text.split('\\n')[0]))\n\n        self.qual = match.group('value')\n        text = qual.sub('', text)\n\n        reg = re.compile(r' -- .*[^(\\\\|\",)]$', re.M)\n        text = reg.sub('', text)\n\n        self.text = text\n        self.at, self.ch, self.depth = 0, '', 0\n        self.len = len(text)\n        self.next_chr()\n        result = self.value()\n        return result, self.qual", "response": "Decode a Lua string to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encode(self, obj, qualifier: str):\n        LOGGER.debug('encoding dictionary to text')\n        if not obj:\n            if qualifier.replace('=', '').rstrip() == 'mapResource':\n                # Accept empty mapResource\n                return '{}\\n{{\\n}} -- end of {}\\n'.format(qualifier, qualifier.replace('=', '').rstrip())\n            else:\n                LOGGER.error('{}\\n{{\\n}} -- end of {}\\n'.format(qualifier, qualifier.replace('=', '').rstrip()))\n                raise SLTPEmptyObjectError(qualifier)\n        self.depth = 0\n        out = []\n        s = self.__encode(obj)\n        lines = s.split(self.newline)\n        for line in lines:\n            m = self.line_end.match(line)\n            if m:\n                out.append('{},{}'.format(m.group('intro'), m.group('comment')))\n            else:\n                out.append(line)\n        return '{}{} -- end of {}\\n'.format(qualifier, self.newline.join(out), qualifier.replace('=', '').rstrip())", "response": "Encodes a dictionary - like object to a Lua string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef form(self, obj=None, form=None, name=None, template=None, var_name=None, validate_on_submit=True,\\\n        exit_on_failure=True, csrf_enabled=None):\n        \"\"\"Loads a form and validates it (unless specified).\n        If the form referenced has not been loaded, an attempt to create a form\n        object using the information in the template will be made.\n        \"\"\"\n        if not form or isinstance(form, str):\n            if not name and isinstance(form, str):\n                name = form\n            if not name:\n                name = request.endpoint.rsplit('.', 1)[1] if '.' in request.endpoint else request.endpoint\n            if name not in self.forms:\n                raise NoFormError(\"Cannot find form '%s'\" % name)\n            form = self.forms[name]\n        if inspect.isclass(form):\n            if isinstance(obj, dict):\n                obj = DictObject(obj)\n            if csrf_enabled is None:\n                csrf_enabled = self.options[\"csrf_enabled\"]\n            form = form(obj=obj, meta={'csrf': csrf_enabled})\n\n        current_context.data.form = form\n        yield form\n\n        if validate_on_submit and request.method == \"POST\":\n            self.validate(form, exit_on_failure=exit_on_failure)", "response": "Loads a form and validates it."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the form referenced in the view exists or attempts to create it by parsing the template and the var_name. If the form does not exist or attempts to create it by parsing the template and returning the form class.", "response": "def init_form_view(self, view, opts):\n        \"\"\"Checks if the form referenced in the view exists or attempts to\n        create it by parsing the template\n        \"\"\"\n        name = opts.get(\"name\", opts.get(\"form\"))\n        if isinstance(name, Form):\n            return\n\n        template = opts.get(\"template\", getattr(view, \"template\", None))\n        if not template:\n            if not name:\n                raise NoFormError(\"No form name specified in the form action and no template\")\n            return\n\n        try:\n            as_ = opts.get(\"var_name\", getattr(self.form, \"as_\", \"form\"))\n            form_class = create_from_template(current_app, template, var_name=as_)\n        except NoFormError:\n            if not name:\n                raise\n            return\n\n        if not name:\n            name = view.name\n\n        self.forms[name] = form_class\n        self.form_created_from_view_signal.send(self, view=view, form_class=form_class)\n        return form_class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef populate_obj(self, obj=None, form=None):\n        if not form:\n            form = current_context.data.form\n        if obj is None:\n            obj = AttrDict()\n        form.populate_obj(obj)\n        return obj", "response": "Populates an object with the form s data\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert_to_article(request, entry_id):\n    def get_entry_author(entry):\n        if not entry.optional_name:\n            return 'By Anonymous'\n        return 'By %s' % entry.optional_name\n\n    entry = get_object_or_404(YourTipsEntry, pk=entry_id)\n    if not entry.converted_article_page:\n        tip_section_index_page = YourTipsSectionIndexPage.objects.\\\n            descendant_of(request.site.root_page).live().first()\n        tip_article = YourTipsArticlePage(\n            title='Tip-%s' % str(entry.id),\n            slug='yourtips-entry-%s' % cautious_slugify(entry.id),\n            body=json.dumps([\n                {\"type\": \"paragraph\", \"value\": entry.tip_text},\n                {\"type\": \"heading\", \"value\": get_entry_author(entry)}\n            ])\n        )\n        tip_section_index_page.add_child(instance=tip_article)\n        tip_article.save_revision()\n        tip_article.unpublish()\n\n        entry.converted_article_page = tip_article\n        entry.save()\n    return redirect('/admin/pages/%d/edit/' % entry.converted_article_page.id)", "response": "This method converts a tip entry to an unpublished article."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(self):\n\n        none_type = type(None)\n\n        # Format attributes for writing\n        attrs = self.attribute_string()\n\n        # Place holder if field value is NoneType\n        for attr in self.__dict__.keys():\n            if type(attr) == none_type:\n                setattr(self, attr, '.')\n\n        # Format entry for writing\n        fstr = '{0}\\t{1}\\t{2}\\t{3}\\t{4}\\t{5}\\t{6}\\t{7}\\t{8}{9}'\\\n               .format(self.seqid, self.source, self.type, str(self.start),\n                       str(self.end), self._score_str, self.strand, \n                       self.phase, attrs, os.linesep)\n\n        return fstr", "response": "Restore GFF3 entry to original format\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef attribute_string(self):\n        escape_map = {ord('='): '%3D',\n                      ord(','): '%2C',\n                      ord(';'): '%3B',\n                      ord('&'): '%26',\n                      ord('\\t'): '%09',\n                     }\n\n        list_type = type(list())\n\n        attrs = self.attributes\n        if type(attrs) is OrderedDict:\n            reserved_attrs = []\n            other_attrs = []\n\n            for name, value in attrs.items():\n                # Escape reserved characters\n                name = name.translate(escape_map)\n\n                if type(value) == list_type:\n                    value = ','.join([i.translate(escape_map) for i in value])\n                else:\n                    value = value.translate(escape_map)\n\n                # Regain original formatting of attribute column\n                out_attr = '{0}={1}'.format(name, value)\n\n                # Order attributes so that reserved tags are output first\n                if name[0].isupper():\n                    reserved_attrs.append(out_attr)\n                else:\n                    other_attrs.append(out_attr)\n\n            out_attrs = ';'.join(reserved_attrs + other_attrs)\n\n        else:\n            out_attrs = attrs\n\n        return out_attrs", "response": "Restore an entries attributes in original format escaping reserved characters when necessary\n                  "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate over GFF3 file and return GFF3Entry objects.", "response": "def iterate(self, start_line=None, parse_attr=True, headers=False, \n        comments=False):\n        \"\"\"Iterate over GFF3 file, returning GFF3 entries\n\n        Args:\n            start_line (str): Next GFF3 entry. If 'handle' has been partially\n                read and you want to start iterating at the next entry, read \n                the next GFF3 entry and pass it to this variable when calling \n                gff3_iter. See 'Examples' for proper usage.\n\n            parse_attr (bool): Parse attributes column into a dictionary such \n                that the string \"tag1=value1;tag2=value2\" becomes:\n\n                tag1: value1\n                tag2: value2\n\n            headers (bool): Yields headers if True, else skips lines starting \n                with \"##\"\n\n            comments (bool): Yields comments if True, else skips lines starting\n                with \"#\"\n\n        Yields:\n            GFF3Entry: class containing all GFF3 data, yields str for headers \n                if headers options is True then yields GFF3Entry for entries\n\n        Examples:\n            The following three examples demonstrate how to use gff3_iter.\n            Note: These doctests will not pass, examples are only in doctest\n            format as per convention. bio_utils uses pytests for testing.\n\n            >>> for entry in gff3_iter(open('test.gff3')):\n            ...     print(entry.seqid)  # Sequence ID\n            ...     print(entry.source)  # Software that performed annotation\n            ...     print(entry.type)  # Type of annotation\n            ...     print(entry.start)  # Start position of annotation\n            ...     print(entry.end)  # End position of annotation\n            ...     print(entry.score)  # Confidence score of annotation\n            ...     print(entry.strand)  # Strand annotation is on\n            ...     print(entry.phase)  # Bases until next codon\n            ...     print(entry.attributes)  # Attributes of annotation\n            ...     print(entry.write())  # Reconstituted GFF3 entry\n\n            >>> gff3_handle = open('test.gff3')\n            >>> next(gff3_handle)  # Skip first line/entry\n            >>> next_line = next(gff3_handle)  # Store next entry\n            >>> for entry in gff3_iter(gff3_handle, start_line=next_line):\n            ...     print(entry.seqid)  # Sequence ID\n            ...     print(entry.source)  # Software that performed annotation\n            ...     print(entry.type)  # Type of annotation\n            ...     print(entry.start)  # Start position of annotation\n            ...     print(entry.end)  # End position of annotation\n            ...     print(entry.score)  # Confidence score of annotation\n            ...     print(entry.strand)  # Strand annotation is on\n            ...     print(entry.phase)  # Bases until next codon\n            ...     print(entry.attributes)  # Attributes of annotation\n            ...     print(entry.write())  # Reconstituted GFF3 entry\n\n            >>> for entry in gff3_iter(open('test.gff3'), parse_attr=True):\n            ...     print(entry.seqid)  # Sequence ID\n            ...     print(entry.source)  # Software that performed annotation\n            ...     print(entry.type)  # Type of annotation\n            ...     print(entry.start)  # Start position of annotation\n            ...     print(entry.end)  # End position of annotation\n            ...     print(entry.score)  # Confidence score of annotation\n            ...     print(entry.strand)  # Strand annotation is on\n            ...     print(entry.phase)  # Bases until next codon\n            ...     print(entry.attributes['attr1'])  # Print attribute 'attr1'\n            ...     print(entry.attributes['attr2'])  # Print attribute 'attr2'\n            ...     print(entry.write())  # Reconstituted GFF3 entry\n        \"\"\"\n\n        handle = self.handle\n\n        # Speed tricks: reduces function calls\n        split = str.split\n        strip = str.strip\n\n        if start_line is None:\n            line = next(handle)  # Read first GFF3\n        else:\n            line = start_line  # Set header to given header\n\n        # Check if input is text or bytestream\n        if (isinstance(line, bytes)):\n            def next_line(i):\n                return next(i).decode('utf-8')\n\n            line = strip(line.decode('utf-8'))\n        else:\n            next_line = next\n            line = strip(line)\n\n        # Manual 'for' loop isn't needed to read the file properly and quickly,\n        # unlike fasta_iter and fastq_iter, but it is necessary begin iterating\n        # partway through a file when the user gives a starting line.\n        try:  # Manually construct a for loop to improve speed by using 'next'\n\n            while True:  # Loop until StopIteration Exception raised\n\n                self.current_line += 1\n\n                data = GFF3Entry()  # Initialize early to prevent access error\n\n                if line.startswith('##FASTA'):  # Skip FASTA entries\n                    raise FastaFound\n\n                if line.startswith('##') and not headers:\n                    line = strip(next_line(handle))\n                    continue\n                elif line.startswith('##') and headers:\n                    yield line\n                    line = strip(next_line(handle))\n                    continue\n\n                if line.startswith('#') and not comments:\n                    line = strip(next_line(handle))\n                    continue\n                elif line.startswith('#') and comments:\n                    yield line\n                    line = strip(next_line(handle))\n                    continue\n\n                split_line = split(line, '\\t')\n\n                data.origline = line\n                data.seqid = split_line[0]\n                data.source = split_line[1]\n                data.type = split_line[2]\n                data.start = int(split_line[3])\n                data.end = int(split_line[4])\n                try:  # Make float unless dot\n                    data.score = float(split_line[5])\n                except ValueError:\n                    data.score = split_line[5]\n                data._score_str = split_line[5]\n                data.strand = split_line[6]\n                try:  # Get phase as int unless phase not given\n                    data.phase = int(split_line[7])\n                except ValueError:\n                    data.phase = split_line[7]\n                data.attributes = split_line[8]\n\n                if parse_attr:\n                    attributes = split(data.attributes, ';')\n                    data.attributes = OrderedDict()\n                    for attribute in attributes:\n                        split_attribute = attribute.split('=')\n                        key = split_attribute[0]\n                        value = split_attribute[-1].split(',') if ',' in \\\n                                split_attribute[-1] else split_attribute[-1]\n                        if not key == '':  # Avoid semicolon split at end\n                            data.attributes[key] = value\n\n                line = strip(next_line(handle))  # Raises StopIteration at EOF\n\n                yield data\n\n        except StopIteration:  # Yield last GFF3 entry\n            if data.origline:\n                yield data\n            else:  #handle case where GFF ends in comment\n                pass\n        except FastaFound:  # When FASTA found, last entry is repeat so pass\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef put(self, locator = None, component = None):\n        if component == None:\n            raise Exception(\"Component cannot be null\")\n\n        self._lock.acquire()\n        try:\n            self._references.append(Reference(locator, component))\n        finally:\n            self._lock.release()", "response": "Adds a new reference into the reference map."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves a previously added reference that matches the specified locator.", "response": "def remove(self, locator):\n        \"\"\"\n        Removes a previously added reference that matches specified locator.\n        If many references match the locator, it removes only the first one.\n        When all references shall be removed, use [[removeAll]] method instead.\n\n        :param locator: a locator to remove reference\n\n        :return: the removed component reference.\n        \"\"\"\n        if locator == None:\n            return None\n\n        self._lock.acquire()\n        try:\n            for reference in reversed(self._references):\n                if reference.match(locator):\n                    self._references.remove(reference)\n                    return reference.get_component()\n        finally:\n            self._lock.release()\n        \n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_all(self, locator):\n        components = []\n\n        if locator == None:\n            return components\n\n        self._lock.acquire()\n        try:\n            for reference in reversed(self._references):\n                if reference.match(locator):\n                    self._references.remove(reference)\n                    components.append(reference.get_component())\n        finally:\n            self._lock.release()\n        \n        return components", "response": "Removes all component references that match the specified locator."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets locators for all registered component references in this reference map.", "response": "def get_all_locators(self):\n        \"\"\"\n        Gets locators for all registered component references in this reference map.\n\n        :return: a list with component locators.\n        \"\"\"\n        locators = []\n\n        self._lock.acquire()\n        try:\n            for reference in self._references:\n                locators.append(reference.get_locator())\n        finally:\n            self._lock.release()\n\n        return locators"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all(self):\n        components = []\n        \n        self._lock.acquire()\n        try:\n            for reference in self._references:\n                components.append(reference.get_component())\n        finally:\n            self._lock.release()\n\n        return components", "response": "Gets all component references registered in this reference map."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_one_optional(self, locator):\n        try:\n            components = self.find(locator, False)\n            return components[0] if len(components) > 0 else None\n        except Exception as ex:\n            return None", "response": "Gets an optional component reference that matches the specified locator."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a required component reference that matches the specified locator.", "response": "def get_one_required(self, locator):\n        \"\"\"\n         Gets a required component reference that matches specified locator.\n\n         :param locator: the locator to find a reference by.\n\n         :return: a matching component reference.\n\n         :raises: a [[ReferenceException]] when no references found.\n         \"\"\"\n        components = self.find(locator, True)\n        return components[0] if len(components) > 0 else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the global configuration of the current language.", "response": "def initialize(**kwargs):\n    \"\"\"\n    Loads the globally shared YAML configuration\n    \"\"\"\n    global config\n    config_opts = kwargs.setdefault('config',{})\n\n    if isinstance(config_opts,basestring):\n        config_opts = {'config_filename':config_opts}\n        kwargs['config'] = config_opts\n\n    if 'environment' in kwargs:\n        config_opts['environment'] = kwargs['environment']\n\n    config.load_config(**config_opts)\n\n    # Overlay the subconfig\n    if kwargs.get('name'):\n        subconfig = config.get(kwargs.get('name'),{})\n        config.overlay_add(subconfig)\n\n    config.overlay_add(app_config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef config_find(self,config_dirs=None,config_filename=None):\n        if config_dirs is None:\n            config_dirs = self._config_dirs\n        else:\n            if isinstance(config_dirs,basestring):\n                config_dirs = [config_dirs]\n\n        if config_filename is None:\n            config_filename = self._config_filename\n        for test_dir in config_dirs:\n            test_fpath = os.path.join(test_dir,config_filename)\n            if os.path.isfile(test_fpath):\n                return test_fpath\n\n        # No matches found\n        return", "response": "Attempt to use the config dir and config_filenames to locate the configuration file requested."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cfg_(self,cfg=None):\n        if cfg is None:\n            cfg = self._cfg\n        else:\n            self._cfg = cfg\n        self.overlay_load()\n        return cfg", "response": "Get or set the configuration data for the current system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef config_amend_key_(self,key,value):\n        cfg_i = self._cfg\n        keys = key.split('.')\n        last_key = keys.pop()\n        trail = []\n        for e in keys:\n            cfg_i.setdefault(e,{})\n            cfg_i = cfg_i[e]\n            trail.append(e)\n            if not isinstance(cfg_i,dict):\n                raise Exception('.'.join(trail) + ' has conflicting dict/scalar types!')\n        cfg_i.setdefault(last_key,value)", "response": "This method will take a stringified key representation and value and append it into the configuration file for furthur usage."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the string from the user input", "response": "def get_string(self, input_string):\n        \"\"\"\n\t\tReturn string type user input\n\t\t\"\"\"\n\n        if input_string in ('--input', '--outname', '--framework'):\n\n            # was the flag set?\n            try:\n                index = self.args.index(input_string) + 1\n            except ValueError:\n                # it wasn't, so if it's required, exit\n                if input_string in self.required:\n                    print(\"\\n {flag} is required\".format(input_string))\n                    print_short_help()\n                    sys.exit(1)\n                # it wasn't, if its optional, return the default\n                else:\n                    return None\n\n                    # the flag was set, so check if a value was set, otherwise exit\n            try:\n                if self.args[index] in self.flags:\n                    print(\"\\n {flag} was set but a value was not specified\".format(flag=input_string))\n                    print_short_help()\n                    sys.exit(1)\n            except IndexError:\n                print(\"\\n {flag} was set but a value was not specified\".format(input_string))\n                print_short_help()\n                sys.exit(1)\n\n            # a value was set, so check and assign the appropriate value or exit\n            if input_string == '--input':\n                return os.path.abspath(self.args[index])\n            elif input_string == '--outname':\n                return format(self.args[index])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef select_executor(elem, doc):\n    executor = EXECUTORS['default']\n\n    if 'cmd' in elem.attributes.keys():\n        executor = elem.attributes['cmd']\n    elif 'runas' in elem.attributes.keys():\n        executor = EXECUTORS[elem.attributes['runas']]\n    elif elem.classes[0] != 'exec':\n        executor = EXECUTORS[elem.classes[0]]\n\n    return executor", "response": "Determines the executor for the code in elem. text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting a code block by passing it to the executor.", "response": "def execute_code_block(elem, doc):\n    \"\"\"Executes a code block by passing it to the executor.\n\n    Args:\n        elem The AST element.\n        doc  The document.\n\n    Returns:\n        The output of the command.\n    \"\"\"\n    command = select_executor(elem, doc).split(' ')\n    code = elem.text\n    if 'plt' in elem.attributes or 'plt' in elem.classes:\n        code = save_plot(code, elem)\n    command.append(code)\n    if 'args' in elem.attributes:\n        for arg in elem.attributes['args'].split():\n            command.append(arg)\n\n    cwd = elem.attributes['wd'] if 'wd' in elem.attributes else None\n\n    return subprocess.run(command,\n                          encoding='utf8',\n                          stdout=subprocess.PIPE,\n                          stderr=subprocess.STDOUT,\n                          cwd=cwd).stdout"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef execute_interactive_code(elem, doc):\n    code_lines = [l[4:] for l in elem.text.split('\\n')]\n\n    code_blocks = [[code_lines[0]]]\n    for line in code_lines[1:]:\n        if line.startswith(' ') or line == '':\n            code_blocks[-1].append(line)\n        else:\n            code_blocks.append([line])\n\n    final_code = []\n    try:\n        child = replwrap.REPLWrapper(\"python\", \">>> \", None)\n    except NameError:\n        pf.debug('Can not run interactive session. No output produced ' +\n                 '(Code was:\\n{!s}\\n)'\n                 .format(elem))\n        pf.debug('Please pip install pexpect.')\n        return ''\n    for code_block in code_blocks:\n        result = child.run_command('\\n'.join(code_block) + '\\n').rstrip('\\r\\n')\n        final_code += [('>>> ' if i == 0 else '... ') + l for i, l in\n                       enumerate(code_block)]\n        if result:\n            final_code += [r for r in result.split('\\n')\n                           if r.strip() not in code_block]\n    return '\\n'.join(final_code)", "response": "Executes code blocks for a python shell."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread a file which matches the pattern filename.", "response": "def read_file(filename):\n    \"\"\"Reads a file which matches the pattern `filename`.\n\n    Args:\n        filename The filename pattern\n\n    Returns:\n        The file content or the empty string, if the file is not found.\n    \"\"\"\n    hits = glob.glob('**/{}'.format(filename), recursive=True)\n    if not len(hits):\n        pf.debug('No file \"{}\" found.'.format(filename))\n        return ''\n    elif len(hits) > 1:\n        pf.debug('File pattern \"{}\" ambiguous. Using first.'.format(filename))\n\n    with open(hits[0], 'r') as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filter_lines(code, line_spec):\n    code_lines = code.splitlines()\n\n    line_specs = [line_denom.strip() for line_denom in line_spec.split(',')]\n\n    single_lines = set(map(int, filter(lambda line: '-' not in line, line_specs)))\n    line_ranges = set(filter(lambda line: '-' in line, line_specs))\n\n    for line_range in line_ranges:\n        begin, end = line_range.split('-')\n        if not begin:\n            begin = 1\n        if not end:\n            end = len(code_lines)\n        single_lines.update(range(int(begin), int(end) + 1))\n\n    keep_lines = []\n    for line_number, line in enumerate(code_lines, 1):\n        if line_number in single_lines:\n            keep_lines.append(line)\n\n    return '\\n'.join(keep_lines)", "response": "Removes all lines not matching the line_spec."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_import_statements(code):\n    new_code = []\n    for line in code.splitlines():\n        if not line.lstrip().startswith('import ') and \\\n           not line.lstrip().startswith('from '):\n            new_code.append(line)\n\n    while new_code and new_code[0] == '':\n        new_code.pop(0)\n    while new_code and new_code[-1] == '':\n        new_code.pop()\n\n    return '\\n'.join(new_code)", "response": "Removes lines with import statements from the code."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts matplotlib plots to tikz code.", "response": "def save_plot(code, elem):\n    \"\"\"Converts matplotlib plots to tikz code.\n\n    If elem has either the plt attribute (format: plt=width,height) or the\n    attributes width=width and/or height=height, the figurewidth and -height\n    are set accordingly. If none are given, a height of 4cm and a width of 6cm\n    is used as default.\n\n    Args:\n        code: The matplotlib code.\n        elem: The element.\n\n    Returns:\n        The code and some code to invoke matplotlib2tikz.\n    \"\"\"\n    if 'plt' in elem.attributes:\n        figurewidth, figureheight = elem.attributes['plt'].split(',')\n    else:\n        try:\n            figureheight = elem.attributes['height']\n        except KeyError:\n            figureheight = '4cm'\n\n        try:\n            figurewidth = elem.attributes['width']\n        except KeyError:\n            figurewidth = '6cm'\n\n    return f\"\"\"import matplotlib\nmatplotlib.use('TkAgg')\n{code}\nfrom matplotlib2tikz import get_tikz_code\ntikz = get_tikz_code(figureheight='{figureheight}', figurewidth='{figurewidth}')  # noqa\nprint(tikz)\"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsimplify the given path.", "response": "def trimpath(attributes):\n    \"\"\"Simplifies the given path.\n\n    If pathdepth is in attributes, the last pathdepth elements will be\n    returned. If pathdepth is \"full\", the full path will be returned.\n    Otherwise the filename only will be returned.\n\n    Args:\n        attributes: The element attributes.\n\n    Returns:\n        The trimmed path.\n    \"\"\"\n    if 'pathdepth' in attributes:\n        if attributes['pathdepth'] != 'full':\n            pathelements = []\n            remainder = attributes['file']\n            limit = int(attributes['pathdepth'])\n            while len(pathelements) < limit and remainder:\n                remainder, pe = os.path.split(remainder)\n                pathelements.insert(0, pe)\n            return os.path.join(*pathelements)\n        return attributes['file']\n    return os.path.basename(attributes['file'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_codelisting(inner_elements, caption, label, *,\n                     shortcaption=None, above=True):\n    r\"\"\"Creates a source code listing:\n\n        \\begin{codelisting}[hbtp]\n        inner_elements\n        \\caption[caption]{\\label{label}caption}\n        \\end{codelisting}\n\n    and returns the list containing the pandoc elements.\n\n    Args:\n        inner_elements: A list of inner pandoc elements, usually a\n                        code block and potentially outputs etc.\n        caption:        The caption to be used. Will be used below code and in\n                        list of code listings.\n        label:          The label to use.\n        shortcaption:   A short caption to be used in the list of code listings.\n                        If None, the normal caption will be used.\n        above:          The caption is placed above (True) or below (False)\n                        the code listing.\n\n    Returns:\n        A list of elements for this codelisting.\n    \"\"\"\n    begin = pf.RawBlock(r'\\begin{codelisting}[hbtp]', format='tex')\n    end = pf.RawBlock(r'\\end{codelisting}', format='tex')\n\n    if not shortcaption:\n        shortcaption = caption\n    cap_begin = f'\\\\caption[{shortcaption}]{{\\\\label{{{label}}}'\n    caption_elem = pf.RawBlock(cap_begin + caption + '}', format='tex')\n    if above:\n        return [begin, caption_elem] + inner_elements + [end]\n    return [begin] + inner_elements + [caption_elem, end]", "response": "r Creates a source code listing for the given inner elements and caption."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prepare(doc):\n    doc.caption_found = False\n    doc.plot_found = False\n    doc.listings_counter = 0", "response": "Sets the caption_found and plot_found variables to False."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nembed a possible tikz image inside a center environment.", "response": "def maybe_center_plot(result):\n    \"\"\"Embeds a possible tikz image inside a center environment.\n\n    Searches for matplotlib2tikz last commend line to detect tikz images.\n\n    Args:\n        result: The code execution result\n\n    Returns:\n        The input result if no tikzpicture was found, otherwise a centered\n        version.\n    \"\"\"\n    begin = re.search('(% .* matplotlib2tikz v.*)', result)\n    if begin:\n        result = ('\\\\begin{center}\\n' + result[begin.end():] +\n                  '\\n\\\\end{center}')\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses the code block and returns the changed element or None.", "response": "def action(elem, doc):  # noqa\n    \"\"\"Processes pf.CodeBlocks.\n\n    For details and a specification of how each command should behave,\n    check the example files (especially the md and pdf)!\n\n    Args:\n        elem: The element to process.\n        doc:  The document.\n\n    Returns:\n        A changed element or None.\n    \"\"\"\n    if isinstance(elem, pf.CodeBlock):\n        doc.listings_counter += 1\n        elems = [elem] if 'hide' not in elem.classes else []\n\n        if 'file' in elem.attributes:\n            elem.text = read_file(elem.attributes['file'])\n            filename = trimpath(elem.attributes)\n            prefix = pf.Emph(pf.Str('File:'))\n\n        if 'exec' in elem.classes:\n            if 'interactive' in elem.classes or elem.text[:4] == '>>> ':\n                elem.text = execute_interactive_code(elem, doc)\n            else:\n                result = execute_code_block(elem, doc)\n\n                if 'hideimports' in elem.classes:\n                    elem.text = remove_import_statements(elem.text)\n\n                if 'plt' in elem.attributes or 'plt' in elem.classes:\n                    doc.plot_found = True\n                    result = maybe_center_plot(result)\n                    block = pf.RawBlock(result, format='latex')\n                else:\n                    block = pf.CodeBlock(result, classes=['changelog'])\n\n                elems += [pf.Para(pf.Emph(pf.Str('Output:'))), block]\n\n        if 'lines' in elem.attributes:\n            elem.text = filter_lines(elem.text, elem.attributes['lines'])\n\n        label = elem.attributes.get('label', f'cl:{doc.listings_counter}')\n\n        if 'caption' in elem.attributes.keys():\n            doc.caption_found = True\n            cap = pf.convert_text(elem.attributes['caption'], output_format='latex')  # noqa\n            if 'shortcaption' in elem.attributes.keys():\n                shortcap = pf.convert_text(elem.attributes['shortcaption'], output_format='latex')  # noqa\n            else:\n                shortcap = cap\n            if 'file' in elem.attributes.keys():\n                cap += pf.convert_text(f'&nbsp;(`{filename}`)', output_format='latex')  # noqa\n\n            elems = make_codelisting(elems, cap, label, shortcaption=shortcap,\n                                     above='capbelow' not in elem.classes)\n        elif 'caption' in elem.classes:\n            doc.caption_found = True\n            cap = ''\n            if 'file' in elem.attributes.keys():\n                cap = pf.convert_text(f'`{filename}`', output_format='latex')\n            elems = make_codelisting(elems, cap, label,\n                                     above='capbelow' not in elem.classes)\n        else:\n            if 'file' in elem.attributes.keys():\n                elems.insert(0, pf.Para(prefix, pf.Space,\n                                        pf.Code(filename)))\n\n        return elems"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the pgfplots and caption packages to the header - includes if needed.", "response": "def finalize(doc):\n    \"\"\"Adds the pgfplots and caption packages to the header-includes if needed.\n    \"\"\"\n    if doc.plot_found:\n        pgfplots_inline = pf.MetaInlines(pf.RawInline(\n            r'''%\n\\makeatletter\n\\@ifpackageloaded{pgfplots}{}{\\usepackage{pgfplots}}\n\\makeatother\n\\usepgfplotslibrary{groupplots}\n''', format='tex'))\n        try:\n            doc.metadata['header-includes'].append(pgfplots_inline)\n        except KeyError:\n            doc.metadata['header-includes'] = pf.MetaList(pgfplots_inline)\n\n    if doc.caption_found:\n        caption_inline = pf.MetaInlines(pf.RawInline(\n            r'''%\n\\makeatletter\n\\@ifpackageloaded{caption}{}{\\usepackage{caption}}\n\\@ifpackageloaded{cleveref}{}{\\usepackage{cleveref}}\n\\@ifundefined{codelisting}{%\n    \\DeclareCaptionType{codelisting}[Code Listing][List of Code Listings]\n    \\crefname{codelisting}{code listing}{code listings}\n    \\Crefname{codelisting}{Code Listing}{Code Listings}\n    \\captionsetup[codelisting]{position=bottom}\n}{}\n\\makeatother\n''', format='tex'))\n        try:\n            doc.metadata['header-includes'].append(caption_inline)\n        except KeyError:\n            doc.metadata['header-includes'] = pf.MetaList(caption_inline)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extra_prepare(self, configuration, args_dict):\n        dashmat = args_dict.pop(\"dashmat\")\n\n        self.configuration.update(\n          { \"dashmat\": dashmat\n          }\n        , source = \"<args_dict>\"\n        )", "response": "Called before the configuration. converters are activated"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_file(self, location):\n        try:\n            return yaml.load(open(location))\n        except (yaml.parser.ParserError, yaml.scanner.ScannerError) as error:\n            raise self.BadFileErrorKls(\"Failed to read yaml\", location=location, error_type=error.__class__.__name__, error=\"{0}{1}\".format(error.problem, error.problem_mark))", "response": "Read in a yaml file and return as a python object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extra_configuration_collection(self, configuration):\n        configuration[\"__imported__\"] = {}\n        configuration[\"__registered__\"] = {}\n        configuration[\"__active_modules__\"] = {}\n\n        def make_converter(name, spec):\n            def converter(p, v):\n                log.info(\"Converting %s\", p)\n                meta = Meta(p.configuration, [(name, \"\")])\n                configuration.converters.started(p)\n                return spec.normalise(meta, v)\n            return converter\n        configuration.install_converters(DashMatConverters(), make_converter)\n\n        if \"modules\" in configuration:\n            for module_name, module_options in list(configuration[\"modules\"].items()):\n                if \"import_path\" in module_options:\n                    module = module_import_spec(Module).normalise(Meta(configuration, []).at(\"modules\").at(module_name), module_options[\"import_path\"])\n                    import_path = \"{0}:{1}\".format(module.module_path, module.__name__)\n                    self.activate_module(module_name, import_path, module, configuration)\n                    configuration[[\"modules\", module_name, \"import_path\"]] = module", "response": "Hook to do any extra configuration collection or converter registration"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef observed(func):\n\n    def wrapper(*args, **kwargs):\n        self = args[0]\n        assert(isinstance(self, Observable))\n\n        self._notify_method_before(self, func.__name__, args, kwargs)\n        res = func(*args, **kwargs)\n        self._notify_method_after(self, func.__name__, res, args, kwargs)\n        return res\n\n    log.logger.warning(\"Decorator observable.observed is deprecated:\"\n                       \"use Observable.observed instead\")\n    return wrapper", "response": "Decorator for the observed method."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecorate methods to be observable. If they are called on an instance stored in a property, the model will emit before and after notifications.", "response": "def observed(cls, _func):\n        \"\"\"\n        Decorate methods to be observable. If they are called on an instance\n        stored in a property, the model will emit before and after\n        notifications.\n        \"\"\"\n\n        def wrapper(*args, **kwargs):\n            self = args[0]\n            assert(isinstance(self, Observable))\n\n            self._notify_method_before(self, _func.__name__, args, kwargs)\n            res = _func(*args, **kwargs)\n            self._notify_method_after(self, _func.__name__, res, args, kwargs)\n            return res\n\n        return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef emit(self, arg=None):\n        for model,name in self.__get_models__():\n            model.notify_signal_emit(name, arg)", "response": "Emits the signal passing the optional argument"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, primary=False, limit=None, offset=None):\n        return self.connection.get('account/array',\n                                   primary=primary,\n                                   limit=limit,\n                                   offset=offset)", "response": "Get the list of accounts that the current user has access to"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef put(self, name=None, user_ids=None):\n        return self.connection.put('account', data=dict(name=name, user_ids=user_ids))", "response": "Create an account in the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _linearize(cls, inst_list):\n\n        for inst in inst_list:\n            # Check if we need to recurse\n            if isinstance(inst, Instructions):\n                for sub_inst in cls._linearize(inst.instructions):\n                    yield sub_inst\n            else:\n                yield inst", "response": "A generator function which performs linearization of the list\n        of instructions and yields all the Instructions that are not in the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms constant folding. If the result of applying the operator to the elements would be a fixed constant value, returns the result of applying the operator to the operands. Otherwise, returns an instance of ``Instructions`` containing the instructions necessary to apply the operator. :param elems: A list (or list-like object) containing the elements. :returns: A list of one element, containing the instructions necessary to implement the operator.", "response": "def fold(self, elems):\n        \"\"\"\n        Perform constant folding.  If the result of applying the\n        operator to the elements would be a fixed constant value,\n        returns the result of applying the operator to the operands.\n        Otherwise, returns an instance of ``Instructions`` containing\n        the instructions necessary to apply the operator.\n\n        :param elems: A list (or list-like object) containing the\n                      elements.\n\n        :returns: A list of one element, containing the instructions\n                  necessary to implement the operator.\n        \"\"\"\n\n        # Are the elements constants?\n        if all(isinstance(e, Constant) for e in elems):\n            return [Constant(self.op(*[e.value for e in elems]))]\n\n        return [Instructions(elems[:] + [self])]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fold(self, elems):\n\n        cond, if_true, if_false = elems\n\n        if isinstance(cond, Constant):\n            return [if_true if cond.value else if_false]\n\n        return [Instructions([cond, JumpIfNot(len(if_true) + 2), pop, if_true,\n                              Jump(len(if_false) + 1), pop, if_false])]", "response": "Perform constant folding on the entries in the list of elements."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fold(self, elems):\n\n        lhs, rhs = elems\n\n        if isinstance(lhs, Constant):\n            return [rhs if lhs.value else lhs]\n\n        return [Instructions([lhs, JumpIfNot(len(rhs) + 1), pop, rhs])]", "response": "Perform constant folding on the elements in elems."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the remote host SSH public key to the known_hosts file.", "response": "def add_to_known_hosts(self, hosts, known_hosts=DEFAULT_KNOWN_HOSTS, dry=False):\n        \"\"\"\n        Add the remote host SSH public key to the `known_hosts` file.\n\n        :param hosts: the list of the remote `Host` objects.\n        :param known_hosts: the `known_hosts` file to store the SSH public keys.\n        :param dry: perform a dry run.\n        \"\"\"\n        to_add = []\n        with open(known_hosts) as fh:\n            known_hosts_set = set(line.strip() for line in fh.readlines())\n\n        cmd = ['ssh-keyscan'] + [host.hostname for host in hosts]\n        logger.debug('Call: %s',  ' '.join(cmd))\n        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        stdout, stderr = p.communicate()\n        for line in stdout.splitlines():\n            line = line.strip()\n            logger.info('[%s] Add the remote host SSH public key to [%s]...', line.split(' ', 1)[0], known_hosts)\n            if line not in known_hosts_set:\n                known_hosts_set.add(line)\n                to_add.append('{0}\\n'.format(line))\n\n        if not dry:\n            with open(known_hosts, 'a') as fh:\n                fh.writelines(to_add)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_from_known_hosts(self, hosts, known_hosts=DEFAULT_KNOWN_HOSTS, dry=False):\n        for host in hosts:\n            logger.info('[%s] Removing the remote host SSH public key from [%s]...', host.hostname, known_hosts)\n            cmd = ['ssh-keygen', '-f', known_hosts, '-R', host.hostname]\n            logger.debug('Call: %s', ' '.join(cmd))\n            if not dry:\n                try:\n                    subprocess.check_call(cmd)\n                except subprocess.CalledProcessError as ex:\n                    logger.error(format_error(format_exception(ex)))", "response": "Remove the remote host SSH public key from the known_hosts file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncopy the SSH public keys to the given host.", "response": "def copy_ssh_keys_to_host(self, host, password=None, no_add_host=False, known_hosts=DEFAULT_KNOWN_HOSTS):\n        \"\"\"\n        Copy the SSH keys to the given host.\n\n        :param host: the `Host` object to copy the SSH keys to.\n        :param password: the SSH password for the given host.\n        :param no_add_host: if the host is not in the known_hosts file, write an error instead of adding it to the\n                            known_hosts.\n        :param known_hosts: the `known_hosts` file to store the SSH public keys.\n        :raise paramiko.ssh_exception.AuthenticationException: if SSH authentication error.\n        :raise paramiko.ssh_exception.SSHException: generic SSH error.\n        :raise socket.error: if error at the socket level.\n        \"\"\"\n        client = None\n        try:\n            client = paramiko.SSHClient()\n            if not no_add_host:\n                client.set_missing_host_key_policy(paramiko.client.AutoAddPolicy())\n            if os.path.isfile(known_hosts):\n                client.load_host_keys(filename=known_hosts)\n\n            client.connect(host.hostname, port=host.port, username=host.user, password=password,\n                           key_filename=self.priv_key)\n\n            cmd = (r'''mkdir -p ~/.ssh && chmod 700 ~/.ssh && \\\nk='{0}' && if ! grep -qFx \"$k\" ~/.ssh/authorized_keys; then echo \"$k\" >> ~/.ssh/authorized_keys; fi'''\n                   .format(self.pub_key_content))\n            logger.debug('Run on [%s]: %s', host.hostname, cmd)\n            client.exec_command(cmd.encode('utf-8'))\n        finally:\n            if client:\n                client.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloops that runs in a thread to process requests synchronously.", "response": "def process_requests(self):\n        \"\"\"\n        Loop that runs in a thread to process requests synchronously.\n        \"\"\"\n        while True:\n            id, args, kwargs = self.request_queue.get()\n            try:\n                response = self._make_request(*args, **kwargs)\n            except Exception as e:\n                response = e\n            self.results[id] = response"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndefaulting implementation of get_coinbase_cache.", "response": "def default_from_address(self):\n        \"\"\"\n        Cache the coinbase address so that we don't make two requests for every\n        single transaction.\n        \"\"\"\n        if self._coinbase_cache_til is not None:\n            if time.time - self._coinbase_cache_til > 30:\n                self._coinbase_cache_til = None\n                self._coinbase_cache = None\n\n        if self._coinbase_cache is None:\n            self._coinbase_cache = self.get_coinbase()\n\n        return self._coinbase_cache"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the balance of a specific address.", "response": "def get_balance(self, address, block=\"latest\"):\n        \"\"\"\n        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getbalance\n        \"\"\"\n        response = self.make_request(\"eth_getBalance\", [address, block])\n        return int(response['result'], 16)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_code(self, address, block=\"latest\"):\n        response = self.make_request(\"eth_getCode\", [address, block])\n        return response['result']", "response": "Get the code for a specific address."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a eth_call to get the current state of the node.", "response": "def call(self, _from=None, to=None, gas=None, gas_price=None, value=0,\n             data=None, block=\"latest\"):\n        \"\"\"\n        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_call\n        \"\"\"\n        if _from is None:\n            _from = self.default_from_address\n\n        params = [\n            get_transaction_params(_from, to, gas, gas_price, value, data),\n            block,\n        ]\n        response = self.make_request(\"eth_call\", params)\n        return response['result']"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the block with the given hash.", "response": "def get_block_by_hash(self, block_hash, full_transactions=True):\n        \"\"\"\n        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getblockbyhash\n        \"\"\"\n        response = self.make_request(\"eth_getBlockByHash\", [block_hash, full_transactions])\n        return response['result']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_block_by_number(self, block_number, full_transactions=True):\n        if isinstance(block_number, numbers.Number):\n            block_number_as_hex = hex(block_number)\n        else:\n            block_number_as_hex = block_number\n        response = self.make_request(\n            \"eth_getBlockByNumber\", [block_number_as_hex, full_transactions],\n        )\n        return response['result']", "response": "Get the block information by its number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef new_filter(self, from_block=None, to_block=None, address=None, topics=None):\n        params = construct_filter_args(from_block, to_block, address, topics)\n        response = self.make_request(\"eth_newFilter\", [params])\n        return(response['result'])", "response": "Create a new filter object that can be used to notify the EVM of changes in the EVM."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving a filter by ID.", "response": "def uninstall_filter(self, filter_id):\n        \"\"\"\n        https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_uninstallfilter\n        Removes a filter by ID\n        \"\"\"\n        if isinstance(filter_id, numbers.Number):\n            filt_hex = hex(filter_id)\n        else:\n            filt_hex = filter_id\n\n        response = self.make_request(\"eth_uninstallFilter\", [filt_hex])\n        return(response['result'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconstruct a dictionary of fields and replacement values based on the event and pull status.", "response": "def _get_fields(self, event, pull, message=None):\n        \"\"\"Constructs a dictionary of fields and replacement values based on the\n        specified event and the status of the pull request.\n        \n        :arg event: one of [\"start\", \"error\", \"finish\"].\n        :arg pull: an instance of PullRequest that has details about the current\n          status of the pull request testing etc.\n        :arg message: an additional contextual message to add in the __message__ field.\n        \"\"\"\n        result = pull.fields_general(event)            \n        if message is not None:\n            result[\"__message__\"] = message\n            \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun self. find_pulls and processes the pull requests.", "response": "def process_pulls(self, testpulls=None, testarchive=None, expected=None):\n        \"\"\"Runs self.find_pulls() *and* processes the pull requests unit tests,\n        status updates and wiki page creations.\n\n        :arg expected: for unit testing the output results that would be returned\n          from running the tests in real time.\n        \"\"\"\n        from datetime import datetime\n        pulls = self.find_pulls(None if testpulls is None else testpulls.values())\n        for reponame in pulls:\n            for pull in pulls[reponame]:\n                try:\n                    archive = self.archive[pull.repokey]\n                    if pull.snumber in archive:\n                        #We pass the archive in so that an existing staging directory (if\n                        #different from the configured one) can be cleaned up if the previous\n                        #attempt failed and left the file system dirty.\n                        pull.init(archive[pull.snumber])\n                    else:\n                        pull.init({})\n                        \n                    if self.testmode and testarchive is not None:\n                        #Hard-coded start times so that the model output is reproducible\n                        if pull.number in testarchive[pull.repokey]:\n                            start = testarchive[pull.repokey][pull.number][\"start\"]\n                        else:\n                            start = datetime(2015, 4, 23, 13, 8)\n                    else:\n                        start = datetime.now()\n                    archive[pull.snumber] = {\"success\": False, \"start\": start,\n                                             \"number\": pull.number, \"stage\": pull.repodir,\n                                             \"completed\": False, \"finished\": None}\n                    #Once a local staging directory has been initialized, we add the sha\n                    #signature of the pull request to our archive so we can track the rest\n                    #of the testing process. If it fails when trying to merge the head of\n                    #the pull request, the exception block should catch it and email the\n                    #owner of the repo.\n                    #We need to save the state of the archive now in case the testing causes\n                    #an unhandled exception.\n                    self._save_archive()\n\n                    pull.begin()\n                    self.cron.email(pull.repo.name, \"start\", self._get_fields(\"start\", pull), self.testmode)\n                    pull.test(expected[pull.number])\n                    pull.finalize()\n\n                    #Update the status of this pull request on the archive, save the archive\n                    #file in case the next pull request throws an unhandled exception.\n                    archive[pull.snumber][\"completed\"] = True\n                    archive[pull.snumber][\"success\"] = abs(pull.percent - 1) < 1e-12\n\n                    #This if block looks like a mess; it is necessary so that we can easily\n                    #unit test this processing code by passing in the model outputs etc. that should\n                    #have been returned from running live.\n                    if (self.testmode and testarchive is not None and\n                        pull.number in testarchive[pull.repokey] and\n                        testarchive[pull.repokey][pull.number][\"finished\"] is not None):\n                        archive[pull.snumber][\"finished\"] = testarchive[pull.repokey][pull.number][\"finished\"]\n                    elif self.testmode:\n                        archive[pull.snumber][\"finished\"] = datetime(2015, 4, 23, 13, 9)\n                    else:\n                        #This single line could replace the whole if block if we didn't have\n                        #unit tests integrated with the main code.\n                        archive[pull.snumber][\"finished\"] = datetime.now()\n                    self._save_archive()\n\n                    #We email after saving the archive in case the email server causes exceptions.\n                    if archive[pull.snumber][\"success\"]:\n                        key = \"success\"\n                    else:\n                        key = \"failure\"\n                    self.cron.email(pull.repo.name, key, self._get_fields(key, pull), self.testmode)\n                except:\n                    import sys, traceback\n                    e = sys.exc_info()\n                    errmsg = '\\n'.join(traceback.format_exception(e[0], e[1], e[2]))\n                    err(errmsg)\n                    self.cron.email(pull.repo.name, \"error\", self._get_fields(\"error\", pull, errmsg),\n                                    self.testmode)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding a list of new pull requests that need to be processed.", "response": "def find_pulls(self, testpulls=None):\n        \"\"\"Finds a list of new pull requests that need to be processed.\n\n        :arg testpulls: a list of tserver.FakePull instances so we can test the code\n          functionality without making live requests to github.\n        \"\"\"\n        #We check all the repositories installed for new (open) pull requests.\n        #If any exist, we check the pull request number against our archive to\n        #see if we have to do anything for it.\n        result = {}\n        for lname, repo in self.repositories.items():\n            if lname not in self.archive:\n                raise ValueError(\"Trying to find pull requests for a repository \"\n                                 \"that hasn't been installed. Use server.install().\")\n            if self.runnable is not None and lname not in self.runnable:\n                #We just ignore this repository completely and don't even bother\n                #performing a live check on github.\n                continue\n            \n            pulls = testpulls if testpulls is not None else repo.repo.get_pulls(\"open\")\n            result[lname] = []\n            for pull in pulls:\n                newpull = True\n                if pull.snumber in self.archive[lname]:\n                    #Check the status of that pull request processing. If it was\n                    #successful, we just ignore this open pull request; it is\n                    #obviously waiting to be merged in.\n                    if self.archive[lname][pull.snumber][\"completed\"] == True:\n                        newpull = False\n\n                if newpull:\n                    #Add the pull request to the list that needs to be processed.\n                    #We don't add the request to the archive yet because the\n                    #processing step hasn't happened yet.\n                    result[lname].append(PullRequest(self, repo, pull, testpulls is not None))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _save_archive(self):\n        import json\n        from utility import json_serial\n        with open(self.archpath, 'w') as f:\n            json.dump(self.archive, f, default=json_serial)", "response": "Saves the JSON archive of processed pull requests."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a list of all the installed repositories in this server.", "response": "def _get_repos(self):\n        \"\"\"Gets a list of all the installed repositories in this server.\n        \"\"\"\n        result = {}\n        for xmlpath in self.installed:\n            repo = RepositorySettings(self, xmlpath)\n            result[repo.name.lower()] = repo\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_installed(self):\n        from utility import get_json\n        #This is a little tricky because the data file doesn't just have a list\n        #of installed servers. It also manages the script's database that tracks\n        #the user's interactions with it.\n        fulldata = get_json(self.instpath, {})\n        if \"installed\" in fulldata:\n            return fulldata[\"installed\"]\n        else:\n            return []", "response": "Gets a list of the file paths to repo settings files that are\n        being monitored by the CI server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uninstall(self, xmlpath):\n        from os import path\n        fullpath = path.abspath(path.expanduser(xmlpath))\n        if fullpath in self.installed:\n            repo = RepositorySettings(self, fullpath)\n            if repo.name.lower() in self.repositories:\n                del self.repositories[repo.name.lower()]\n            if repo.name.lower() in self.archive:\n                del self.archive[repo.name.lower()]\n                self._save_archive()\n            self.installed.remove(fullpath)\n            self._save_installed()\n        else:\n            warn(\"The repository at {} was not installed to begin with.\".format(fullpath))", "response": "Uninstalls the repository with the specified XML path from the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninstalling the repository at the specified XML path as an additional repo to monitor pull requests for.", "response": "def install(self, xmlpath):\n        \"\"\"Installs the repository at the specified XML path as an additional\n        repo to monitor pull requests for.\n        \"\"\"\n        #Before we can install it, we need to make sure that none of the existing\n        #installed paths point to the same repo.\n        from os import path\n        fullpath = path.abspath(path.expanduser(xmlpath))\n        if path.isfile(fullpath):\n            repo = RepositorySettings(self, fullpath)\n            if repo.name.lower() not in self.repositories:\n                self.installed.append(fullpath)\n                self._save_installed()\n                self.archive[repo.name.lower()] = {}\n                self._save_archive()\n                \n                self.repositories[repo.name.lower()] = repo\n        else:\n            warn(\"The file {} does not exist; install aborted.\".format(fullpath))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _save_installed(self):\n        import json\n        from utility import json_serial, get_json\n        #This is a little tricky because the data file doesn't just have a list\n        #of installed servers. It also manages the script's database that tracks\n        #the user's interactions with it.\n        fulldata = get_json(self.instpath, {})\n        fulldata[\"installed\"] = self.installed\n        with open(self.instpath, 'w') as f:\n            json.dump(fulldata, f, default=json_serial)", "response": "Saves the list of installed repo XML settings files."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init(self, archive):\n        from os import makedirs, path, chdir, system, getcwd\n        self.repodir = path.abspath(path.expanduser(self.repo.staging))\n\n        if (\"stage\" in archive and path.isdir(archive[\"stage\"]) and\n            self.repodir != archive[\"stage\"] and archive[\"stage\"] is not None):\n            #We have a previous attempt in a different staging directory to clean.\n            from shutil import rmtree\n            rmtree(archive[\"stage\"])\n\n        if not path.isdir(self.repodir):\n            makedirs(self.repodir)\n            \n        #Copy across all the static files so that we don't have to download them\n        #again and chew up the bandwidth. We don't have to copy files that already\n        #exist in the local repo.\n        self.repo.static.copy(self.repodir)\n        cwd = getcwd()\n        chdir(self.repodir)\n        \n        if not self._is_gitted():\n            #Next we need to initialize the git repo, then add all the static files\n            #and folders to be tracked so that when we pull from origin master they\n            #can be merged into the repo without re-downloading them.\n            system(\"git init\")\n            if not self.testmode:\n                system(\"git remote add origin {}.git\".format(self.repo.repo.html_url))\n\n            for file in self.repo.static.files:\n                #Here the 2:: removes the ./ specifying the path relative to the git\n                #repository root. It is added by convention in the config files.\n                system(\"git add {}\".format(file[\"target\"][2::]))\n            for folder in self.repo.static.folders:\n                system(\"git add {}\".format(file[\"target\"][2::]))\n\n            #Now sync with the master branch so that we get everything else that isn't\n            #static. Also, fetch the changes from the pull request head so that we\n            #can merge them into a new branch for unit testing.\n            if not self.testmode:\n                system(\"git pull origin master\")\n\n        #Even though we have initialized the repo before, we still need to fetch the\n        #pull request we are wanting to merge in.\n        if not self.testmode:\n            system(\"git fetch origin pull/{0}/head:testing_{0}\".format(self.pull.number))\n            system(\"git checkout testing_{}\".format(pull.number))\n\n        #The local repo now has the pull request's proposed changes and is ready\n        #to be unit tested.\n        chdir(cwd)", "response": "Creates the local repo folder locally copies the static files and their corresponding folders and initalizes the repo with git."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _is_gitted(self):\n        from os import waitpid\n        from subprocess import Popen, PIPE\n    \n        premote = Popen(\"cd {}; git remote -v\".format(self.repodir),\n                        shell=True, executable=\"/bin/bash\", stdout=PIPE, stderr=PIPE)\n        waitpid(premote.pid, 0)\n        remote = premote.stdout.readlines()\n        remerr = premote.stderr.readlines()\n\n        pbranch = Popen(\"cd {}; git branch\".format(self.repodir),\n                        shell=True, executable=\"/bin/bash\", stdout=PIPE, stderr=PIPE)\n        waitpid(pbranch.pid, 0)\n        branch = pbranch.stdout.readlines()\n        braerr = pbranch.stderr.readlines()\n\n        if len(remote) > 0 and len(remerr) > 0 and len(branch) > 0:\n            return ((\".git\" in remote[0] and \"fatal\" not in remerr[0])\n                    and any([\"testing\" in b for b in branch]))\n        elif self.testmode and len(remote) == 0 and len(branch) == 0 and len(remerr) == 0:\n            return True\n        else:\n            return False", "response": "Returns True if the current repodir has been initialized in git and has a testing branch."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the status message on the last commit for this pull request to pending.", "response": "def begin(self):\n        \"\"\"Sets the status message on the *last* commit for this pull request\n        to be 'pending' with a details link to a newly created Wiki page with\n        the setup of the unit tests being run. Does *not* run the actual unit\n        tests yet.\n        \"\"\"\n        self.url = self.server.wiki.create(self)\n        if not self.testmode:\n            self.commit.create_status(\"pending\", self.url, \"Running unit tests...\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef finalize(self):\n        #Determine the percentage success on the unit tests. Also see the total time for all\n        #the unit tests.\n        stotal = 0\n        ttotal = 0\n        for test in self.repo.testing.tests:\n            stotal += (1 if test[\"success\"]==True else 0)\n            ttotal += (test[\"end\"] - test[\"start\"]).seconds\n\n        self.percent = stotal/float(len(self.repo.testing.tests))\n        self.message = \"Results: {0:.2%} in {1:d}s.\".format(self.percent, ttotal)\n        if not self.testmode:\n            if percent < 1:\n                self.commit.create_status(\"failure\", self.url, self.message)\n            elif any([test[\"code\"] == 1 for test in self.repo.testing.tests]):\n                self.commit.create_status(\"pending\", self.url, self.message + \" Slowdown reported.\")\n            else:\n                self.commit.create_status(\"success\", self.url, self.message)\n        self.server.wiki.update(self)", "response": "Finalizes the pull request processing by updating the wiki page with the details of all the unit tests."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _fields_common(self):\n        result = {}\n        if not self.testmode:\n            result[\"__reponame__\"] = self.repo.repo.full_name\n            result[\"__repodesc__\"] = self.repo.repo.description\n            result[\"__repourl__\"] = self.repo.repo.html_url\n            result[\"__repodir__\"] = self.repodir\n\n            if self.organization is not None:\n                owner = self.repo.organization\n            else:\n                owner = self.repo.user\n                \n            result[\"__username__\"] = owner.name\n            result[\"__userurl__\"] = owner.html_url\n            result[\"__useravatar__\"] = owner.avatar_url\n            result[\"__useremail__\"] = owner.email\n\n        return result", "response": "Returns a dictionary of fields and values that are common to all events\n            for which fields dictionaries are created."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the wiki markup describing the details of the github pull request", "response": "def wiki(self):\n        \"\"\"Returns the wiki markup describing the details of the github pull request\n        as well as a link to the details on github.\n        \"\"\"\n        date = self.pull.created_at.strftime(\"%m/%d/%Y %H:%M\")\n        return \"{} {} ({} [{} github])\\n\".format(self.pull.avatar_url, self.pull.body, date,\n                                                 self.pull.html_url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the fields that are common to all the events in the log.", "response": "def fields_general(self, event):\n        \"\"\"Appends any additional fields to the common ones and returns the fields\n        dictionary.\n        \"\"\"\n        result = self._fields_common()\n        basic = {\n            \"__test_html__\": self.repo.testing.html(False),\n            \"__test_text__\": self.repo.testing.text(False)}\n        full = {\n            \"__test_html__\": self.repo.testing.html(),\n            \"__test_text__\": self.repo.testing.text()}\n        \n        if event in [\"finish\", \"success\"]:\n            full[\"__percent__\"] = \"{0:.2%}\".format(self.percent)\n            full[\"__status__\"] = self.message\n        \n        extra = {\n            \"start\": basic,\n            \"error\": basic,\n            \"finish\": full,\n            \"success\": full,\n            \"timeout\": basic\n        }\n        if event in extra:\n            result.update(extra[event])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_site(self):\n        import mwclient\n        parts = self.server.settings.wiki.replace(\"http\", \"\").replace(\"://\", \"\").split(\"/\")\n        self.url = parts[0]\n        if len(parts) > 1 and parts[1].strip() != \"\":\n            self.relpath = '/' + '/'.join(parts[1:len(parts)])\n            #The API expects us to have a trailing forward-slash.\n            if self.relpath[-1] != \"/\":\n                self.relpath += \"/\"\n            if not self.testmode:\n                self.site = mwclient.Site(self.url, path=self.relpath)\n        else:\n            if not self.testmode:\n                self.site = mwclient.Site(self.url)", "response": "Returns the mwclient. Site for accessing and editing the wiki pages."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _site_login(self, repo):\n        try:\n            if not self.testmode:\n                self.site.login(repo.wiki[\"user\"], repo.wiki[\"password\"])\n        except LoginError as e:\n            print(e[1]['result'])\n        self.basepage = repo.wiki[\"basepage\"]", "response": "Logs the user specified in the repo into the wiki."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, request):\n        self._site_login(request.repo)\n        self.prefix = \"{}_Pull_Request_{}\".format(request.repo.name, request.pull.number)\n        \n        #We add the link to the main repo page during this creation; we also create\n        #the full unit test report page here.\n        self._edit_main(request)\n        return self._create_new(request)", "response": "Creates a new wiki page for the specified PullRequest instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, request):\n        from os import path\n        self._site_login(request.repo)\n        self.prefix = \"{}_Pull_Request_{}\".format(request.repo.name, request.pull.number)\n                \n        #Before we can update the results from stdout, we first need to upload them to the\n        #server. The files can be quite big sometimes; if a file is larger than 1MB, we ...\n        for i, test in enumerate(request.repo.testing.tests):\n            test[\"remote_file\"] = \"{}_{}.txt\".format(self.prefix, i)\n            if test[\"result\"] is not None and path.isfile(test[\"result\"]):\n                #Over here, we might consider doing something different if the wiki server\n                #is the same physical machine as the CI server; we needn't use the network\n                #protocols for the copy then. However, the machine knows already if an address\n                #it is accessing is its own; the copy, at worst, would be through the named\n                #pipes over TCP. It is wasteful compared to a HDD copy, but simplifies the\n                #uploading (which must also make an entry in the wiki database).\n                if not self.testmode:\n                    self.site.upload(open(test[\"result\"]), test[\"remote_file\"],\n                                     '`stdout` from `{}`'.format(test[\"command\"]))\n\n        #Now we can just overwrite the page with the additional test results, including the\n        #links to the stdout files we uploaded.\n        head = list(self._newpage_head)\n        #Add a link to the details page that points back to the github pull request URL.\n        head.append(\"==Github Pull Request Info==\\n\")\n        head.append(request.wiki())\n        head.append(\"==Commands Run for Unit Testing==\\n\")\n        head.append(request.repo.testing.wiki())\n        if not self.testmode:\n            page = self.site.Pages[self.newpage]\n            result = page.save('\\n'.join(head), summary='Edited by CI bot with uploaded unit test details.',\n                               minor=True, bot=True)\n            return result[u'result'] == u'Success'\n        else:\n            return '\\n'.join(head)", "response": "Updates the wiki page with the results of the unit tests run for the given pull request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _create_new(self, request):\n        self.prefix = \"{}_Pull_Request_{}\".format(request.repo.name, request.pull.number)\n        head = list(self._newpage_head)\n        head.append(request.repo.testing.wiki(False))\n        if not self.testmode:\n            page = self.site.Pages[self.newpage]\n            result = page.save('\\n'.join(head), summary='Created by CI bot for unit test details.', bot=True)\n            return result[u'result'] == u'Success'\n        else:\n            return '\\n'.join(head)", "response": "Creates the new wiki page that houses the details of the unit testing runs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _edit_main(self, request):\n        self.prefix = \"{}_Pull_Request_{}\".format(request.repo.name, request.pull.number)\n        if not self.testmode:\n            page = site.pages[self.basepage]\n            text = page.text()\n        else:\n            text = \"This is a fake wiki page.\\n\\n<!--@CI:Placeholder-->\"\n            \n        self.newpage = self.prefix\n        link = \"Pull Request #{}\".format(request.pull.number)\n        text = text.replace(\"<!--@CI:Placeholder-->\",\n                            \"* [[{}|{}]]\\n<!--@CI:Placeholder-->\".format(self.newpage, link))\n        if not self.testmode:\n            result = page.save(text, summary=\"Added {} unit test link.\".format(link), minor=True, bot=True)\n            return result[u'result'] == u'Success'\n        else:\n            return text", "response": "Edit the main wiki page."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_template(self, event, ctype, fields):\n        from os import path\n        template = path.join(self.server.dirname, \"templates\", \"{}.{}\".format(event, ctype))\n        contents = None\n        \n        if path.isfile(template):\n            with open(template) as f:\n                #The templates are very small, so we don't need to worry about the file size.\n                contents = f.read()\n            for field, value in fields.items():\n                contents = contents.replace(field, value)\n        else:\n            raise ValueError(\"The event '{}' is not supported or \".format(event) +\n                             \"the template file ({}) is missing.\".format(template))\n        return contents", "response": "Gets the contents of the template file for the specified event and type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef email(self, repo, event, fields, dryrun=False):\n        tcontents = self._get_template(event, \"txt\", fields)\n        hcontents = self._get_template(event, \"html\", fields)\n        if tcontents is not None and hcontents is not None:\n            return Email(self.server, repo, self.settings[repo], tcontents, hcontents, dryrun)", "response": "Sends an email to the configured recipients for the specified event."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend the email using the configured settings.", "response": "def _send(self, server, texts, htmls, dryrun):\n        \"\"\"Sends the email using the configured settings.\n\n        :arg server: the Server instance for the entire CI workflow.\n        \"\"\"\n        import smtplib\n        from email.mime.multipart import MIMEMultipart\n        from email.mime.text import MIMEText\n\n        # Create message container - the correct MIME type is multipart/alternative.\n        emsg = MIMEMultipart('alternative')\n        emsg['Subject'] = self.subject\n        emsg['From'] = self.sender\n        emsg['To'] = ', '.join(self.to)\n\n        # Create the body of the message (a plain-text and an HTML version).\n        self.text = '\\n'.join(texts) if isinstance(texts, list) else texts\n        self.html = \"\"\"\n        <html>\n          <head></head>\n          <body>\n            {}  \n          </body>\n        </html>\n        \"\"\".format('\\n'.join(htmls) if isinstance(htmls, list) else htmls)\n\n        # Record the MIME types of both parts - text/plain and text/html.\n        part1 = MIMEText(self.text, 'plain')\n        part2 = MIMEText(self.html, 'html')\n\n        # Attach parts into message container.\n        # According to RFC 2046, the last part of a multipart message, in this case\n        # the HTML message, is best and preferred.\n        emsg.attach(part1)\n        emsg.attach(part2)\n\n        # Send the message via the configured SMTP server from ANCLE global configuration.\n        if not dryrun:\n            s = smtplib.SMTP(server.settings.gateway)\n            s.sendmail(self.sender, self.to, emsg.as_string())\n            s.quit()\n\n        self.sent = True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef detect_sys():\n    system = platform.system()\n    bit = platform.architecture()[0]\n    compiler = platform.python_compiler()\n    ver = platform.python_version_tuple()\n    return {'system': system, 'bit': bit, 'compiler': compiler, 'python_version_tuple': ver}", "response": "Tries to identify your python platform and returns the gathered information"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the installation path to maya.", "response": "def get_maya_location(self, ):\n        \"\"\" Return the installation path to maya\n\n        :returns: path to maya\n        :rtype: str\n        :raises: errors.SoftwareNotFoundError\n        \"\"\"\n        import _winreg\n        # query winreg entry\n        # the last flag is needed, if we want to test with 32 bit python!\n        # Because Maya is an 64 bit key!\n        for ver in MAYA_VERSIONS:\n            try:\n                key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,\n                                      MAYA_REG_KEY.format(mayaversion=ver), 0,\n                                      _winreg.KEY_READ | _winreg.KEY_WOW64_64KEY)\n                value = _winreg.QueryValueEx(key, \"MAYA_INSTALL_LOCATION\")[0]\n            except WindowsError:\n                log.debug('Maya %s installation not found in registry!' % ver)\n        if not value:\n            raise errors.SoftwareNotFoundError('Maya %s installation not found in registry!' % MAYA_VERSIONS)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_maya_envpath(self):\n        opj = os.path.join\n        ml = self.get_maya_location()\n        mb = self.get_maya_bin()\n        msp = self.get_maya_sitepackage_dir()\n        pyzip = opj(mb, \"python27.zip\")\n        pydir = opj(ml, \"Python\")\n        pydll = opj(pydir, \"DLLs\")\n        pylib = opj(pydir, \"lib\")\n        pyplat = opj(pylib, \"plat-win\")\n        pytk = opj(pylib, \"lib-tk\")\n        path = os.pathsep.join((pyzip, pydll, pylib, pyplat, pytk, mb, pydir, msp))\n        return path", "response": "Return the path that mayapy will run from the current directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsorts the response dictionaries priority levels for ordered iteration", "response": "def _sort(self):\n        \"\"\"\n        Sort the response dictionaries priority levels for ordered iteration\n        \"\"\"\n        self._log.debug('Sorting responses by priority')\n        self._responses = OrderedDict(sorted(list(self._responses.items()), reverse=True))\n        self.sorted = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, response, condition=None):\n        self._log.info('Adding a new response with the priority level {priority}'.format(priority=response.priority))\n        # If this is the first time we are seeing this priority level, ready a new response list\n        if response.priority not in self._responses:\n            self.sorted = False  # Only reset sorted flag on a new priority definition for efficiency\n            self._responses[response.priority] = []\n\n        # If this response requires a condition be met, assign it to the Response object directly\n        if condition:\n            self._log.debug('Response has a condition defined')\n            self._conditionals[response] = condition\n\n        self._responses[response.priority].append(response)", "response": "Adds a new Response object to the list of known entries."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a random Response object.", "response": "def random(self, user=None):\n        \"\"\"\n        Retrieve a random Response\n        :param user: The user to test for active limitations and to apply response actions on\n        :type  user: agentml.User or None\n\n        :return: A randomly selected Response object\n        :rtype : parser.trigger.response.Response\n        \"\"\"\n        if not self.sorted:\n            self._sort()\n\n        self._log.info('Attempting to retrieve a random response')\n        failed_conditions = []\n        passed_conditions = {}\n        successful_response = None\n\n        for priority, responses in self._responses.items():\n            self._log.debug('Attempting priority {priority} responses'.format(priority=priority))\n            response_pool = []\n\n            for response in responses:\n                # If the response has a condition, attempt to evaluate it\n                condition = self._conditionals[response] if response in self._conditionals else None\n                if condition:\n                    # Condition has already been evaluated and the evaluation failed, skip and continue\n                    if condition in failed_conditions:\n                        self._log.debug('Skipping response due to a previously failed condition check')\n                        continue\n                    # Condition has already been evaluated successfully, check if this response is in the cond. results\n                    elif condition in passed_conditions:\n                        if response in passed_conditions[condition]:\n                            self._log.debug('Response is in a condition that has already been successfully evaluated')\n                        else:\n                            # This error is kinda ambiguous, but it basically means the condition evaluated true,\n                            # but this specific response was in a different if / elif / else statement\n                            self._log.debug('Response is in a condition that has already been successfully evaluated, '\n                                            'but the response was in the wrong condition statement, skipping')\n                            continue\n                    # Condition has not been evaluated yet, process it now and save the result\n                    elif condition not in passed_conditions:\n                        self._log.debug('Evaluating a new condition')\n                        evaluated = condition.evaluate(user)\n                        # Fail, skip and continue\n                        if not evaluated:\n                            self._log.debug('Condition failed to evaluate successfully, skipping response')\n                            failed_conditions.append(condition)\n                            continue\n\n                        # Pass\n                        self._log.debug('Condition evaluated successfully, checking if we\\'re in the right condition '\n                                        'statement')\n                        passed_conditions[condition] = evaluated\n\n                        if response in passed_conditions[condition]:\n                            self._log.debug('Response is in the successfully evaluated condition statement, continuing')\n                        else:\n                            # This error is kinda ambiguous, but it basically means the condition evaluated true,\n                            # but this specific response was in a different if / elif / else statement\n                            self._log.debug('Response was in the wrong condition statement, skipping')\n                            continue\n\n                # Does the user have a limit for this response enforced?\n                if user and user.is_limited(response):\n                    if response.ulimit_blocking:\n                        self._log.debug('An active blocking limit for this response is being enforced against the user '\n                                        '{uid}, no response will be returned'.format(uid=user.id))\n                        raise LimitError\n\n                    self._log.debug('An active limit for this response is being enforced against the user {uid}, '\n                                    'skipping'.format(uid=user.id))\n                    continue\n\n                # Is there a global limit for this response enforced?\n                if response.agentml.is_limited(response):\n                    if response.glimit_blocking:\n                        self._log.debug('An active blocking limit for this response is being enforced globally, no '\n                                        'response will be returned')\n                        raise LimitError\n\n                    self._log.debug('An active limit for this response is being enforced globally, skipping')\n                    continue\n\n                self._log.debug('Adding new response to the random pool with a weight of {weight}'\n                                .format(weight=response.weight))\n                response_pool.append((response, response.weight))\n\n            # If we have no responses in the response pool, that means a limit is being enforced for them all and\n            # we need to move on to responses in the next priority bracket\n            if not response_pool:\n                self._log.debug('All responses with a priority of {priority} failed to pass one or more condition '\n                                'checks, continuing to the next priority bracket'.format(priority=priority))\n                continue\n\n            # Start a loop so we can weed out responses that fail chance conditions\n            while True:\n                # Retrieve a random weighted response\n                response = weighted_choice(response_pool)\n\n                # Are we out of responses to try?\n                if not response:\n                    break\n\n                # Is there a chance we need to evaluate?\n                if response.chance is None or response.chance == 100:\n                    successful_response = response\n                    break\n\n                # Chance succeeded\n                if response.chance >= random.uniform(0, 100):\n                    self._log.info('Response had a {chance}% chance of being selected and succeeded selection'\n                                   .format(chance=response.chance))\n                    successful_response = response\n                    break\n                # Chance failed\n                else:\n                    if response.chance_blocking:\n                        self._log.info('Response had a blocking {chance}% chance of being selected but failed selection'\n                                       ', no response will be returned'.format(chance=response.chance))\n                        raise ChanceError\n\n                    self._log.info('Response had a {chance}% chance of being selected but failed selection'\n                                   .format(chance=response.chance))\n                    response_pool = [r for r in response_pool if r[0] is not response]\n                    continue\n\n            # If we have no successful response defined, that means a chance condition for all the responses failed and\n            # we need to move on to responses in the next priority bracket\n            if successful_response is None:\n                self._log.debug('All responses with a priority of {priority} have chance conditions defined and we '\n                                'failed to pass any of them, continuing to the next priority bracket'\n                                .format(priority=priority))\n                continue\n\n            # If we're still here, that means we DO have a successful response ans we should process it immediately\n            if user:\n                successful_response.apply_reactions(user)\n\n            return successful_response\n\n        # If we looped through everything but haven't returned yet, that means we ran out of responses to attempt\n        self._log.info('All responses failed to pass one or more condition checks, nothing to return')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_blueprints(app, application_package_name=None, blueprint_directory=None):\n    if not application_package_name:\n        application_package_name = 'app'\n\n    if not blueprint_directory:\n        blueprint_directory = os.path.join(os.getcwd(), application_package_name)\n\n    blueprint_directories = get_child_directories(blueprint_directory)\n\n    for directory in blueprint_directories:\n        abs_package = '{}.{}'.format(application_package_name, directory)\n\n        service = importlib.import_module(abs_package)\n        app.register_blueprint(service.blueprint_api, url_prefix='')", "response": "Register Flask blueprints on app object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_child_directories(path):\n    if not _is_valid_directory(path):\n        raise exceptions.InvalidDirectory\n\n    entries = os.listdir(path)\n    directory_names = []\n\n    for entry in entries:\n        abs_entry_path = os.path.join(path, entry)\n        if _is_valid_directory(abs_entry_path):\n            directory_names.append(entry)\n\n    return directory_names", "response": "Return names of immediate child directories"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef projects(self):\n        return self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>(?!\\[Searches\\]|- )\\S.*?:(?!\\S)) *(?P<tagString>( *?@[^(\\s]+(\\([^)]*\\))?)+)?(?P<content>(\\n(( |\\t)+\\S.*)|\\n( |\\t)*|\\n)+)', re.UNICODE),\n            objectType=\"project\",\n            content=None\n        )", "response": "Return a list of all child projects of this taskpaper object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tasks(self):\n        return self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>- ((?! @).)*)( *(?P<tagString>( *?@[^(\\s]+(\\([^)]*\\))?)+))?(?P<content>(\\n(( |\\t)+\\S.*)|\\n( |\\t)*)*)', re.UNICODE),\n            objectType=\"task\",\n            content=None\n        )", "response": "Return a list of the top - level tasks assoicated with this object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the text content of the object.", "response": "def content(\n            self):\n        \"\"\"*The text content of this object (excluding title)*\n\n        Much like the `raw_content` of an object, but does not include a title or tags. The initial indentation is also removed. For a document object the `content` is synonymous with `raw_content`.\n\n        **Usage:**\n\n            .. code-block:: python\n\n                pContent = aProject.content\n                tContent = aTask.content\n        \"\"\"\n        reIndent = re.compile(r'^(?P<indent>\\s+).*?$', re.UNICODE)\n\n        cleanedContent = \"\"\n        replaceContent = \"\"\n\n        # FIND THE SMALLEST INDENT LEVEL IN THE CONTENT\n        lowestIndent = \"\\t\" * 10\n        for line in self.meta[\"content\"].split(\"\\n\"):\n            if len(line.strip()) == 0:\n                continue\n            matchObject = reIndent.match(line)\n            if matchObject:\n                indent = matchObject.group(\"indent\")\n                if len(indent) < len(lowestIndent):\n                    lowestIndent = indent\n\n        # STRIP OFF THE SMALLEST INDENT LEVEL FROM CONTENT\n        for line in self.meta[\"content\"].split(\"\\n\"):\n            if len(line.strip()) == 0:\n                continue\n            cleanedContent += line[len(lowestIndent):] + \"\\n\"\n            replaceContent += line + \"\\n\"\n\n        self.meta[\"content\"] = replaceContent[:-1]\n        return cleanedContent[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tags(\n            self):\n        \"\"\"*The list of tags associated with this taskpaper object*\n\n        **Usage:**\n            ..\n            project and task objects can have associated tags. To get a list of tags assigned to an object use:\n\n            .. code-block:: python\n\n                projectTag = aProject.tags\n                taskTags = aTasks.tags\n\n                print projectTag\n                > ['flag', 'home(bathroom)']\n        \"\"\"\n\n        tags = []\n        regex = re.compile(r'@[^@]*', re.S)\n        if self.meta[\"tagString\"]:\n            matchList = regex.findall(self.meta[\"tagString\"])\n            for m in matchList:\n                tags.append(m.strip().replace(\"@\", \"\"))\n\n        return tags", "response": "Returns a list of all tags associated with this object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of the notes assoicated with this object", "response": "def notes(self):\n        \"\"\"*list of the notes assoicated with this object*\n\n        **Usage:**\n\n            The document, project and task objects can all contain notes.\n\n            .. code-block:: python\n\n                docNotes = doc.notes\n                projectNotes = aProject.notes\n                taskNotes = aTask.notes\n        \"\"\"\n        return self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>\\S(?<!-)((?!(: +@|: *\\n|: *$)).)*)\\s*?(\\n|$)(?P<tagString>&&&)?(?P<content>&&&)?', re.UNICODE),\n            objectType=\"note\",\n            content=None\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_project(\n            self,\n            projectName):\n        \"\"\"*recursively scan this taskpaper object to find a descendant project by name*\n\n        **Key Arguments:**\n            - ``projectName`` -- the name, or title, of the project you want to return\n\n        **Return:**\n            - ``project`` -- the taskpaper project object you requested (or ``None`` if no project was matched)\n\n        **Usage:**\n\n            .. code-block:: python\n\n                archiveProject = doc.get_project(\"Archive\")\n        \"\"\"\n\n        if projectName[-1] != \":\":\n            projectName += \":\"\n        project = None\n        for p in self.projects:\n            if p.title.lower() == projectName.lower():\n                project = p\n                break\n\n        if project == None:\n            for p in self.projects:\n                project = p.get_project(projectName)\n                if project:\n                    break\n\n        return project", "response": "get_project - recursively scans this taskpaper object to find a descendant project by name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_task(\n            self,\n            taskName):\n        \"\"\"*recursively scan this taskpaper object to find a descendant task by name*\n\n        **Key Arguments:**\n            - ``taskName`` -- the name, or title, of the task you want to return\n\n        **Return:**\n            - ``task`` -- the taskpaper task object you requested (or ``None`` if no task was matched)\n\n        **Usage:**\n\n            .. code-block:: python\n\n                aTask = doc.get_task(\"cut the grass\")\n        \"\"\"\n\n        if taskName[:2] != \"- \":\n            taskName = \"- \" + taskName\n        task = None\n        try:\n            self.refresh\n        except:\n            pass\n\n        # SEARCH TASKS\n        for t in self.tasks:\n            if t.title.lower() == taskName.lower() and task == None:\n                task = t\n                break\n\n        # SEARCH TASK CONTENTS\n        if task == None:\n            for t in self.tasks:\n                task = t.get_task(taskName)\n                if task:\n                    break\n\n        # SEARCH PROJECT CONTENTS\n        if task == None and \"<Task \" not in self.__repr__():\n            for p in self.projects:\n                task = p.get_task(taskName)\n                if task:\n                    break\n\n        return task", "response": "get_task returns the task object that is descendant of taskName"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting this taskpaper object to a string", "response": "def to_string(\n            self,\n            indentLevel=1,\n            title=True,\n            tags=None,\n            projects=None,\n            tasks=None,\n            notes=None):\n        \"\"\"*convert this taskpaper object to a string*\n\n        **Key Arguments:**\n            - ``indentLevel`` -- the level of the indent for this object. Default *1*.\n            - ``title`` -- print the title of the taskpaper object alongside the contents. Default *True*\n            - ``tags`` -- replace tags with these tags. Default *None*\n            - ``projects`` -- replace projects with these projects, pass empty list to delete all projects. Default *None*\n            - ``tasks`` -- replace tasks with these ones, pass empty list to delete all tasks. Default *None*\n            - ``notes`` -- replace notes with these ones, pass empty list to delete all notes. Default *None*\n\n        **Return:**\n            - ``objectString`` -- the taskpaper object as a string\n\n        **Usage:**\n\n            If we have the *archive* project from a taskpaper document, we can convert it to a string using:\n\n            .. code-block:: python\n\n                print archiveProject.to_string()\n\n            .. code-block:: text\n\n                Archive:\n                    - and a third task @done(2016-09-04) @project(parent project / child-project)\n                    - and a forth task @done(2016-09-04) @project(parent project / child-project)\n                    - fill the kettle @done(2016-09-04) @project(parent project / make coffee)\n                    - boil the kettle @done(2016-09-04) @project(parent project / make coffee)\n        \"\"\"\n        indent = indentLevel * \"\\t\"\n\n        objectString = \"\"\n        if title:\n            try:\n                # NONE DOCUMENT OBJECTS\n                objectString += self.title\n            except:\n                pass\n\n            try:\n                if tags:\n                    tagString = (\" @\").join(tags)\n                else:\n                    tagString = (\" @\").join(self.tags)\n\n                if len(tagString):\n                    objectString += \" @\" + tagString\n            except:\n                pass\n\n        try:\n            if not notes:\n                notes = self.notes\n            for n in notes:\n                if len(n.title.strip()):\n                    if not self.parent and len(objectString) == 0:\n                        objectString += indent + n.title.strip() + n.content\n                    else:\n                        objectString += \"\\n\" + indent + n.title.strip() + n.content\n        except:\n            pass\n\n        try:\n            if not tasks:\n                tasks = self.tasks\n            for t in tasks:\n                objectString += \"\\n\" + indent + t.to_string(indentLevel + 1)\n        except:\n            pass\n\n        try:\n            if not projects:\n                projects = self.projects\n            for p in projects:\n                objectString += \"\\n\" + indent + p.to_string(indentLevel + 1)\n        except:\n            pass\n\n        try:\n            objectString += \"\\n\" + indent + self.searches\n        except:\n            pass\n\n        return objectString.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tagged_projects(\n            self,\n            tag):\n        \"\"\"*return a list of projects contained within this taskpaper object filtered by a given tag*\n\n        **Key Arguments:**\n            - ``tag`` -- the tag to filter the projects by.\n\n        **Return:**\n            - ``projectList`` -- the list of filtered projects\n\n        **Usage:**\n\n            To filter the projects recursively found with a taskpaper document object and return only those projects tagged with ``flag``, using the following:\n\n            .. code-block:: python\n\n                filteredProjects = doc.tagged_projects(\"flag\")\n                for p in filteredProjects:\n                    print p.title\n\n            Note you can give the tag with or without the *@*, and you can also give a tag attribute, e.g. ``@due(today)``\n        \"\"\"\n        self.refresh\n        projectList = []\n        tag = tag.replace(\"@\", \"\").lower()\n        for p in self.projects:\n            for aTag in p.tags:\n                if \"(\" not in tag:\n                    aTag = aTag.split(\"(\")[0]\n                if aTag.lower() == tag:\n                    projectList.append(p)\n                    break\n\n            subProjects = p.tagged_projects(tag)\n            projectList += subProjects\n\n        return projectList", "response": "Return a list of projects contained within this taskpaper object filtered by a given tag"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of tasks contained within this taskpaper object filtered by a given tag", "response": "def tagged_tasks(\n            self,\n            tag):\n        \"\"\"*return a list of tasks contained within this taskpaper object filtered by a given tag*\n\n        **Key Arguments:**\n            - ``tag`` -- the tag to filter the tasks by.\n\n        **Return:**\n            - ``taskList`` -- the list of filtered tasks\n\n        **Usage:**\n\n            To filter the tasks recursively found with a taskpaper document object and return only those tasks tagged with ``flag``, using the following:\n\n            .. code-block:: python\n\n               filteredTasks = doc.tagged_tasks(\"@flag\")\n               for t in filteredTasks:\n                    print t.title\n\n            Note you can give the tag with or without the *@*, and you can also give a tag attribute, e.g. ``@due(today)``\n        \"\"\"\n        self.refresh\n        tasksList = []\n        tag = tag.replace(\"@\", \"\").lower()\n        for t in self.tasks:\n            for aTag in t.tags:\n                if \"(\" not in tag:\n                    aTag = aTag.split(\"(\")[0]\n                if aTag.lower() == tag:\n                    tasksList.append(t)\n                    break\n\n            subtasks = t.tagged_tasks(tag)\n            tasksList += subtasks\n\n        isProject = False\n        try:\n            this = self.projects\n            isProject = True\n        except:\n            pass\n\n        if isProject:\n            for p in self.projects:\n                subtasks = p.tagged_tasks(tag)\n                tasksList += subtasks\n\n        return tasksList"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef all_tasks(\n            self):\n        \"\"\"*return a flat list of all tasks contained within this taskpaper object*\n\n        **Return:**\n            - ``taskList`` -- a flat list of all tasks\n\n        **Usage:**\n\n            To return a flat list of all tasks recursively found with a taskpaper document object, use the following:\n\n            .. code-block:: python\n\n               allTasks = doc.all_tasks()\n               for t in allTasks:\n                    print t.title\n        \"\"\"\n        self.refresh\n        tasksList = []\n        for t in self.tasks:\n            tasksList.append(t)\n            subtasks = t.all_tasks()\n            tasksList += subtasks\n\n        isProject = False\n        try:\n            this = self.projects\n            isProject = True\n        except:\n            pass\n\n        if isProject:\n            for p in self.projects:\n                subtasks = p.all_tasks()\n                tasksList += subtasks\n\n        return tasksList", "response": "Return a list of all tasks contained within this taskpaper object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsorting the projects within this taskpaper object.", "response": "def sort_projects(\n            self,\n            workflowTags):\n        \"\"\"*order the projects within this taskpaper object via a list of tags*\n\n         The order of the tags in the list dictates the order of the sort - first comes first*\n\n        **Key Arguments:**\n            - ``workflowTags`` -- a string of space/comma seperated tags.\n\n        **Return:**\n            - ``None``\n\n        **Usage:**\n\n            To recursively sort the projects within a taskpaper document with the following order:\n\n            1. *@due*\n            2. *@flag*\n            3. *@hold*\n            4. *@next*\n            5. *@someday*\n            6. *@wait*\n\n            use the following:\n\n            .. code-block:: python\n\n                doc.sort_projects(\"@due, @flag, @hold, @next, @someday, @wait\")\n        \"\"\"\n        self.refresh\n        if not isinstance(workflowTags, list):\n            workflowTagsLists = workflowTags.strip().replace(\",\", \"\").replace(\"@\", \"\")\n            workflowTagsLists = workflowTagsLists.split(\" \")\n        else:\n            workflowTagsLists = []\n            workflowTagsLists[:] = [l.replace(\"@\", \"\") for l in workflowTags]\n        matchedProjects = collections.OrderedDict()\n        unmatchedProjects = []\n        for wt in workflowTagsLists:\n            matchedProjects[wt.lower()] = []\n        for p in self.projects:\n            matched = False\n            for pt in p.tags:\n                if matched:\n                    break\n                for wt in workflowTagsLists:\n                    thisTag = pt.lower()\n                    if \"(\" not in wt:\n                        thisTag = pt.split(\"(\")[0].lower()\n                    if thisTag == wt.lower() and matched == False:\n                        matchedProjects[wt.lower()].append(p)\n                        matched = True\n                        break\n            if matched == False:\n                unmatchedProjects.append(p)\n\n        sortedProjects = []\n        for k, v in matchedProjects.iteritems():\n            sortedProjects += v\n\n        sortedProjects += unmatchedProjects\n        self.projects = sortedProjects\n\n        self.content = self.to_string(\n            title=False, projects=sortedProjects, indentLevel=0)\n\n        for p in self.projects:\n            p.projects = p.sort_projects(workflowTags)\n\n        # ADD DIRECTLY TO CONTENT IF THE PROJECT IS BEING ADDED SPECIFICALLY TO\n        # THIS OBJECT\n        oldContent = self.to_string(indentLevel=1)\n        newContent = self.to_string(\n            indentLevel=1, projects=sortedProjects)\n\n        if self.parent:\n            self.parent._update_document_tree(\n                oldContent=oldContent,\n                newContent=newContent\n            )\n\n        self.content = self.content.replace(self.to_string(indentLevel=0, title=False), self.to_string(\n            indentLevel=0, title=False, projects=sortedProjects))\n\n        self.refresh\n\n        return sortedProjects"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntidy this taskpapaer object so that sub - objects appear in this order.", "response": "def tidy(self):\n        \"\"\"*Tidy this taskpapaer object so that sub-objects appear in this order: title, tags, notes, tasks, projects*\n\n        **Return:**\n            - ``None``\n\n        **Usage:**\n\n           When a taskpaper document is opened it is tidied by default. To tidy the document object (or project or task) use the command:\n\n            .. code-block:: python\n\n                doc.tidy()\n        \"\"\"\n        try:\n            self.tags.sort(lambda x, y: cmp(len(x), len(y)))\n        except:\n            pass\n\n        try:\n            for t in self.tasks:\n                t.tidy()\n        except:\n            pass\n\n        try:\n            for p in self.projects:\n                p.tidy()\n        except:\n            pass\n\n        # REMOVE BLANK LINES\n        if self.content:\n            if self.parent:\n                self.content = (\"\\n\").join(self.to_string(\n                    indentLevel=0).split(\"\\n\")[1:])\n            else:\n                regex = re.compile(r'\\s*?\\n\\s*?\\n')\n                while \"\\n\\n\" in self.content:\n                    self.content = regex.sub(\"\\n\", self.content)\n\n        if not self.parent:\n            self.content = self.to_string(\n                indentLevel=0, title=False)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a project to the object.", "response": "def add_project(\n            self,\n            title,\n            tags=None):\n        \"\"\"*Add a project to this taskpaper object*\n\n        **Key Arguments:**\n            - ``title`` -- the title for the project.\n            - ``tags`` -- tag string (*\"@one @two(data)\"*) or list of tags (*['one', 'two(data)']*)\n            - ``oldContent`` -- the old content to be replaced in parent object (user sould not need to give this)\n            - ``newContent`` -- the replacement text for the parent object  (user sould not need to give this)\n\n        **Return:**\n            - ``project`` -- the new taskpaper project object\n\n        **Usage:**\n\n            To add a sub-project to a taskpaper document or project use:\n\n            .. code-block:: python\n\n                newProject = doc.add_project(\n                    title=\"this is a projects I added\",\n                    tags=\"@with @tags\"\n                )\n        \"\"\"\n        self.refresh\n        project = title.strip()\n        if \":\" != project[-1]:\n            project += \":\"\n\n        if tags:\n            if isinstance(tags, list):\n                if \"@\" not in tags[0]:\n                    tagString = (\" @\").join(tags)\n                    tagString = \"@\" + tagString\n                else:\n                    tagString = (\" \").join(tags)\n            else:\n                tagString = tags\n\n            tagString = tagString.strip()\n            project += \" \" + tagString\n\n        newProject = self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>(?!\\[Searches\\]|- )\\S.*?:(?!\\S)) *(?P<tagString>( *?@[^(\\s]+(\\([^)]*\\))?)+)?(?P<content>(\\n(( |\\t)+\\S.*)|\\n( |\\t)*|\\n)+)', re.UNICODE),\n            objectType=\"project\",\n            content=project\n        )\n\n        # ADD DIRECTLY TO CONTENT IF THE PROJECT IS BEING ADDED SPECIFICALLY TO\n        # THIS OBJECT\n        oldContent = self.to_string(indentLevel=1)\n        newContent = self.to_string(\n            indentLevel=1, projects=self.projects + newProject)\n\n        if self.parent:\n            doc = self.parent._update_document_tree(\n                oldContent=oldContent,\n                newContent=newContent\n            )\n\n        self.content = self.content.replace(self.to_string(indentLevel=0, title=False), self.to_string(\n            indentLevel=0, title=False, projects=self.projects + newProject))\n\n        doc = self\n        while doc.parent:\n            doc = doc.parent\n        doc.refresh\n\n        if not self.parent:\n            parent = self\n        else:\n            parent = doc.get_project(self.title)\n\n        thisProject = parent.get_project(title)\n\n        self.refresh\n        return thisProject"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_document_tree(\n            self,\n            oldContent=None,\n            newContent=None):\n        \"\"\"*update document tree*\n\n        **Key Arguments:**\n            - ``oldContent`` -- the old content to be replaced in parent object (user sould not need to give this)\n            - ``newContent`` -- the replacement text for the parent object  (user sould not need to give this)\n\n        **Return:**\n            - ``doc`` -- the updated document object\n        \"\"\"\n        self.refresh\n        if self.parent:\n            self.refresh\n            indentOldContent = \"\"\n            indentNewContent = \"\"\n            for l in oldContent.split(\"\\n\"):\n                indentOldContent += \"\\t\" + l + \"\\n\"\n            uoldContent = indentOldContent[:-1]\n            for l in newContent.split(\"\\n\"):\n                indentNewContent += \"\\t\" + l + \"\\n\"\n            unewContent = indentNewContent[:-1]\n\n            thisOldContent = self.to_string(indentLevel=1)\n            thisNewContent = thisOldContent.replace(uoldContent, unewContent)\n\n            self.content = self.to_string(\n                indentLevel=0, title=False).replace(oldContent, newContent)\n\n            self.content = self.to_string(\n                indentLevel=0, title=False).replace(oldContent, newContent)\n\n            # REPLACE THE NEW CONTENT OF THIS PROJECT IN THE PARENT OBJECT'S\n            # CONTENT\n            doc = self.parent._update_document_tree(\n                oldContent=thisOldContent,\n                newContent=thisNewContent\n            )\n\n        else:\n            self.content = self.content.replace(oldContent, newContent)\n            doc = self\n\n        self.refresh\n        return doc", "response": "Update the content of the object in the document tree."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_tag(\n            self,\n            tag):\n        \"\"\"*Add a tag this taskpaper object*\n\n        **Key Arguments:**\n            - ``tag`` -- the tag to add to the object\n\n        **Usage:**\n\n            .. code-block:: python \n\n                aTask.add_tag(\"@due\")\n        \"\"\"\n\n        if tag.replace(\"@\", \"\") in self.tags:\n            return\n\n        self.refresh\n        oldContent = self.to_string(indentLevel=1)\n        self.tags += [tag.replace(\"@\", \"\")]\n        newContent = self.to_string(indentLevel=1)\n\n        # ADD DIRECTLY TO CONTENT IF THE PROJECT IS BEING ADDED SPECIFICALLY TO\n        # THIS OBJECT\n        self.parent._update_document_tree(\n            oldContent=oldContent,\n            newContent=newContent\n        )\n\n        self.refresh\n        return None", "response": "Add a tag to the object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef del_tag(\n            self,\n            tag):\n        \"\"\"*delete a tag this taskpaper object*\n\n        **Key Arguments:**\n            - ``tag`` -- the tag to delete to the object\n\n        **Usage:**\n\n            .. code-block:: python \n\n                aTask.del_tag(\"@due\")\n        \"\"\"\n\n        if tag.replace(\"@\", \"\") not in self.tags:\n            return\n\n        self.refresh\n        oldContent = self.to_string(indentLevel=1)\n        newTags = []\n        newTags[:] = [n for n in newTags if tag not in n]\n        self.tags = newTags\n        newContent = self.to_string(indentLevel=1)\n\n        # ADD DIRECTLY TO CONTENT IF THE PROJECT IS BEING ADDED SPECIFICALLY TO\n        # THIS OBJECT\n        self.parent._update_document_tree(\n            oldContent=oldContent,\n            newContent=newContent\n        )\n\n        self.refresh\n        return None", "response": "delete a tag from the object"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_tags(\n            self,\n            tags=\"\"):\n        \"\"\"*Set the tags for this taskpaper object*\n\n        **Key Arguments:**\n            - ``tags`` -- a tag string to set\n\n        **Usage:**\n\n            .. code-block:: python \n\n                aTask.set_tags(\"@due @mac\")\n        \"\"\"\n        self.refresh\n        tagList = []\n        regex = re.compile(r'@[^@]*', re.S)\n        matchList = regex.findall(tags)\n        for m in matchList:\n            tagList.append(m.strip().replace(\"@\", \"\"))\n\n        self.refresh\n        oldContent = self.to_string(indentLevel=1)\n        self.tags = tagList\n        newContent = self.to_string(indentLevel=1)\n\n        # ADD DIRECTLY TO CONTENT IF THE PROJECT IS BEING ADDED SPECIFICALLY TO\n        # THIS OBJECT\n        self.parent._update_document_tree(\n            oldContent=oldContent,\n            newContent=newContent\n        )\n        self.refresh\n        return None", "response": "Sets the tags for this object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef done(\n            self,\n            depth=\"root\"):\n        \"\"\"*mark this object as done*\n\n        **Key Arguments:**\n            - ``depth`` -- either mark root item as done or all recursive items. Default *\"root\"*. [\"root\"|\"all\"]\n\n        **Usage:**\n\n            To mark a task or project as done\"\n\n            .. code-block:: python\n\n                aTask.done()\n\n            Or or mark the object as done as well all descendant tasks and projects:\n\n            .. code-block:: python\n\n                aTask.done(\"all\")\n        \"\"\"\n        self.refresh\n        oldContent = self.to_string(indentLevel=1)\n        now = datetime.now()\n        now = now.strftime(\"%Y-%m-%d %H:%M:%S\")\n        newContent = self.to_string(\n            indentLevel=1, tags=[\"done(%(now)s)\" % locals()])\n\n        # ADD DIRECTLY TO CONTENT IF THE PROJECT IS BEING ADDED SPECIFICALLY TO\n        # THIS OBJECT\n        self.parent._update_document_tree(\n            oldContent=oldContent,\n            newContent=newContent\n        )\n\n        if depth == \"all\":\n            try:\n                for t in self.tasks:\n                    t.done(\"all\")\n            except:\n                pass\n\n            try:\n                for p in self.projects:\n                    t.done(\"all\")\n            except:\n                pass\n\n        self.content = self.to_string(indentLevel=0, title=False)\n\n        self.refresh\n\n        return self", "response": "Mark this object as done and update the document tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a task to the object tree.", "response": "def add_task(\n            self,\n            title,\n            tags=None):\n        \"\"\"*Add a task to this taskpaper object*\n\n        **Key Arguments:**\n            - ``title`` -- the title for the task.\n            - ``tags`` -- tag string (*'@one @two(data)'*) or list of tags (*['one', 'two(data)']*)\n\n        **Return:**\n            - ``task`` -- the new taskpaper task object\n\n        **Usage:**\n\n            To add a task to an object (document, project, or task) use:\n\n            .. code-block:: python\n\n                newTask = doc.add_task(\"this is a task I added\", \"@with @tags\")\n        \"\"\"\n        self.refresh\n        task = title.strip()\n        if task[:2] != \"- \":\n            task = \"- \" + task\n\n        if tags:\n            if isinstance(tags, list):\n                if \"@\" not in tags[0]:\n                    tagString = (\" @\").join(tags)\n                    tagString = \"@\" + tagString\n                else:\n                    tagString = (\" \").join(tags)\n            else:\n                tagString = tags\n\n            tagString = tagString.strip()\n            task += \" \" + tagString\n\n        newTask = self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>- ((?! @).)*)( *(?P<tagString>( *?@[^(\\s]+(\\([^)]*\\))?)+))?(?P<content>(\\n(( |\\t)+\\S.*)|\\n( |\\t)*)*)', re.UNICODE),\n            objectType=\"task\",\n            content=task\n        )\n\n        # ADD DIRECTLY TO CONTENT IF THE PROJECT IS BEING ADDED SPECIFICALLY TO\n        # THIS OBJECT\n        oldContent = self.to_string(indentLevel=1)\n        newContent = self.to_string(\n            indentLevel=1, tasks=self.tasks + newTask)\n\n        if self.parent:\n            doc = self.parent._update_document_tree(\n                oldContent=oldContent,\n                newContent=newContent\n            )\n\n        self.content = self.content.replace(self.to_string(indentLevel=0, title=False), self.to_string(\n            indentLevel=0, title=False, tasks=self.tasks + newTask))\n\n        doc = self\n        while doc.parent:\n            doc = doc.parent\n        doc.refresh\n\n        if not self.parent:\n            parent = self\n        else:\n\n            parent = doc.get_project(self.title)\n        if not parent:\n            parent = doc.get_task(self.title)\n\n        thisTask = parent.get_task(title)\n\n        self.refresh\n\n        return thisTask"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a note to the object tree", "response": "def add_note(\n            self,\n            note):\n        \"\"\"*Add a note to this taskpaper object*\n\n        **Key Arguments:**\n            - ``note`` -- the note (string)\n\n        **Return:**\n            - None\n\n        **Usage:**\n\n            To add a note to a document, project or task object:\n\n            .. code-block:: python\n\n                newNote = doc.add_note(And another note with a link http://www.thespacedoctor.co.uk\")\n        \"\"\"\n        self.refresh\n        note = note.strip()\n\n        newNote = self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>\\S(?<!-)((?!(: +@|: *\\n|: *$)).)*)\\s*?(\\n|$)(?P<tagString>&&&)?(?P<content>&&&)?', re.UNICODE),\n            objectType=\"note\",\n            content=note\n        )\n\n        # ADD DIRECTLY TO CONTENT IF THE PROJECT IS BEING ADDED SPECIFICALLY TO\n        # THIS OBJECT\n        oldContent = self.to_string(indentLevel=1)\n        newContent = self.to_string(\n            indentLevel=1)\n\n        if self.parent:\n            self.parent._update_document_tree(\n                oldContent=oldContent,\n                newContent=newContent\n            )\n\n        self.notes = newNote + self.notes\n        self.content = self.content.replace(self.to_string(indentLevel=0, title=False), self.to_string(\n            indentLevel=0, title=False))\n\n        doc = self\n        while doc.parent:\n            doc = doc.parent\n        doc.refresh\n\n        return newNote[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the search - block object associated with this document", "response": "def searches(self):\n        \"\"\"*The search-block (if any) associated with this document*\n\n        **Usage:**\n\n            .. code-block:: python\n\n                # DOCUMENT SEARCHES\n                docSearchBlock = doc.searches\n        \"\"\"\n        return self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>\\[Searches\\]:) *(?P<tagString>( *?@\\S*(\\(.*?\\))?)+)?(?P<content>(\\n(    |\\t).*)*)', re.UNICODE),\n            objectType=\"searchBlock\",\n            content=None\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsave the content of the current object to the file.", "response": "def save(\n            self,\n            copypath=None):\n        \"\"\"*save the content of the document back to the file*\n\n        **Key Arguments:**\n            - ``copypath`` -- the path to a new file if you want to make a copy of the document instead of saving it to the original filepath. Default *None*\n\n\n        **Usage:**\n\n            To save the document to file run:\n\n            .. code-block:: python\n\n                doc.save()\n\n            Or to copy the content to another file run the save method with a new filepath as an argument:\n\n            .. code-block:: python\n\n                doc.save(\"/path/to/saturday-tasks-copy.taskpaper\")\n        \"\"\"\n        self.refresh\n        if copypath:\n            self.filepath = copypath\n\n        content = self.content\n\n        import codecs\n        # SET ENCODE ERROR RETURN VALUE\n        writeFile = codecs.open(self.filepath, encoding='utf-8', mode='w')\n        writeFile.write(content)\n        writeFile.close()\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrefreshing the internal state of the object containing the current state of the object.", "response": "def refresh(\n            self):\n        \"\"\"*Refreshs this documents's attributesd*\n\n        **Usage:**\n\n            To refresh the taskpaper document:\n\n            .. code-block:: python\n\n                doc.refresh\n        \"\"\"\n\n        self.projects = self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>(?!\\[Searches\\]|- )\\S.*?:(?!\\S)) *(?P<tagString>( *?@[^(\\s]+(\\([^)]*\\))?)+)?(?P<content>(\\n(( |\\t)+\\S.*)|\\n( |\\t)*|\\n)+)', re.UNICODE),\n            objectType=\"project\",\n            content=None\n        )\n\n        self.tasks = self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>- ((?! @).)*)( *(?P<tagString>( *?@[^(\\s]+(\\([^)]*\\))?)+))?(?P<content>(\\n(( |\\t)+\\S.*)|\\n( |\\t)*)*)', re.UNICODE),\n            objectType=\"task\",\n            content=None\n        )\n\n        self.notes = self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>\\S(?<!-)((?!(: +@|: *\\n|: *$)).)*)\\s*?(\\n|$)(?P<tagString>&&&)?(?P<content>&&&)?', re.UNICODE),\n            objectType=\"note\",\n            content=None\n        )\n\n        self.search = self._get_object(\n            regex=re.compile(\n                r'((?<=\\n)|(?<=^))(?P<title>\\[Searches\\]:) *(?P<tagString>( *?@\\S*(\\(.*?\\))?)+)?(?P<content>(\\n( |\\t).*)*)', re.UNICODE),\n            objectType=\"searchBlock\",\n            content=None\n        )\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef refresh(\n            self):\n        \"\"\"*Refreshs this tasks's attributes if, for example, the parent document's projects or tasks has been sorted*\n\n        **Usage:**\n\n            To refresh the task:\n\n            .. code-block:: python\n\n                aTask.refresh\n        \"\"\"\n\n        if self.parent:\n            self.parent.refresh\n\n        replace = None\n        title = self.title\n        for t in self.parent.tasks:\n            if t.title == title:\n                replace = t\n        if not replace:\n            return\n\n        self.tags = replace.tags\n\n        self.notes = replace.notes\n        self.tasks = replace.tasks\n\n        self.content = replace.to_string(indentLevel=0, title=False)\n\n        return None", "response": "Refreshes the attributes of this task."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrefresh the internal representation of the object.", "response": "def refresh(\n            self):\n        \"\"\"*Refreshs this project's attributes if, for example, the parent document's projects or tasks has been sorted*\n\n        **Usage:**\n\n            To refresh the project:\n\n            .. code-block:: python\n\n                myProject.refresh\n        \"\"\"\n\n        if self.parent:\n            self.parent.refresh\n        title = self.title\n        replace = self.parent.get_project(title)\n        if not replace:\n            return\n        self.tags = replace.tags\n        self.tasks = replace.tasks\n        self.notes = replace.notes\n        try:\n            title = self.title\n            replace = self.parent.get_project(title)\n            self.tags = replace.tags\n            self.tasks = replace.tasks\n            self.notes = replace.notes\n        except:\n            pass\n        self.projects = replace.projects\n        try:\n            self.projects = replace.projects\n        except:\n            pass\n\n        self.content = replace.to_string(indentLevel=0, title=False)\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete a project from the document", "response": "def delete(\n        self\n    ):\n        \"\"\"*delete a project from the document*\n\n        **Return:**\n            - None\n\n        **Usage:**\n\n            .. code-block:: python\n\n                myProject.delete()\n        \"\"\"\n\n        projectTitle = self.title\n        theseProjects = self.parent.projects[:]\n        for p in theseProjects:\n            if p.title == projectTitle:\n                theseProjects.remove(p)\n                break\n        self.parent.projects = theseProjects\n\n        doc = self\n        while doc:\n            if not doc.parent:\n                break\n            else:\n                doc = doc.parent\n\n        doc.content = doc.to_string(indentLevel=0, title=False)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self):\n        redis_search_key = \":\".join([self.namespace, self.key, \"*\"])\n        keys = self.conn.keys(redis_search_key)\n        if keys:\n            for key in keys:\n                part = key.split(\":\")[-1]\n                self._data.pop(part)\n                self.conn.delete(part)\n\n        del self", "response": "Deletes all the keys from redis along with emptying the objects\n        internal _data dict and then deleting itself at the end of it all."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve a part of the model from redis and stores it.", "response": "def get(self, part):\n        \"\"\"\n        Retrieves a part of the model from redis and stores it.\n\n        :param part: The part of the model to retrieve.\n        :raises RedisORMException: If the redis type is different from string\n            or list (the only two supported types at this time.)\n        \"\"\"\n        redis_key = ':'.join([self.namespace, self.key, part])\n\n        objectType = self.conn.type(redis_key)\n        if objectType == \"string\":\n            self._data[part] = self.conn.get(redis_key)\n\n        elif objectType == \"list\":\n            self._data[part] = RedisList(redis_key, self.conn)\n\n        else:\n            raise RedisORMException(\"Other types besides string and list are unsupported at this time.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload(client, source_dir):\n    print('')\n    print('upload inappproducs')\n    print('---------------------')\n\n    products_folder = os.path.join(source_dir, 'products')\n    product_files = filter(os.path.isfile, list_dir_abspath(products_folder))\n\n    current_product_skus = map(lambda product: product['sku'], client.list_inappproducts())\n    print(current_product_skus)\n    for product_file in product_files:\n        with open(product_file) as product_file:\n            product = json.load(product_file)\n        #check if the product is new\n        sku = product['sku']\n        product['packageName'] = client.package_name\n        print(sku)\n        if sku in current_product_skus:\n            print(\"update product {0}\".format(sku))\n            client.update_inappproduct(product, sku)\n        else:\n            print(\"create product {0}\".format(sku))\n            client.insert_inappproduct(product)", "response": "Upload inappproducts to play store."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download(client, target_dir):\n    print('')\n    print(\"download inappproducts\")\n    print('---------------------')\n    products = client.list_inappproducts()\n\n    for product in products:\n        path = os.path.join(target_dir, 'products')\n        del product['packageName']\n        mkdir_p(path)\n        with open(os.path.join(path, product['sku'] + '.json'), 'w') as outfile:\n            print(\"save product for {0}\".format(product['sku']))\n            json.dump(\n                product, outfile, sort_keys=True,\n                indent=4, separators=(',', ': '))", "response": "Download inappproducts from play store."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the absolute path to the dataset with the given name ; otherwise return None.", "response": "def dataset_exists(dataset_name):\n    '''If a dataset with the given name exists, return its absolute path; otherwise return None'''\n    dataset_dir = os.path.join(LIB_DIR, 'datasets')\n    dataset_path = os.path.join(dataset_dir, dataset_name)\n    \n    return dataset_path if os.path.isdir(dataset_path) else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_script(self, args, event_writer, input_stream):\n\n        try:\n            if len(args) == 1:\n                # This script is running as an input. Input definitions will be\n                # passed on stdin as XML, and the script will write events on\n                # stdout and log entries on stderr.\n                self._input_definition = InputDefinition.parse(input_stream)\n                self.stream_events(self._input_definition, event_writer)\n                event_writer.close()\n                return 0\n\n            elif str(args[1]).lower() == \"--scheme\":\n                # Splunk has requested XML specifying the scheme for this\n                # modular input Return it and exit.\n                scheme = self.get_scheme()\n                if scheme is None:\n                    event_writer.log(\n                        EventWriter.FATAL,\n                        \"Modular input script returned a null scheme.\")\n                    return 1\n                else:\n                    event_writer.write_xml_document(scheme.to_xml())\n                    return 0\n\n            elif args[1].lower() == \"--validate-arguments\":\n                validation_definition = ValidationDefinition.parse(input_stream)\n                try:\n                    self.validate_input(validation_definition)\n                    return 0\n                except Exception as e:\n                    root = ET.Element(\"error\")\n                    ET.SubElement(root, \"message\").text = e.message\n                    event_writer.write_xml_document(root)\n\n                    return 1\n            else:\n                err_string = \"ERROR Invalid arguments to modular input script:\" + ' '.join(\n                    args)\n                event_writer._err.write(err_string)\n\n        except Exception as e:\n            err_string = EventWriter.ERROR + e.message\n            event_writer._err.write(err_string)\n            return 1", "response": "This function handles all the specifics of running a modular input script."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a CSV file and returns a Transactions instance.", "response": "def parse(filename, format=u\"J\u00e6ren Sparebank\", encoding=\"latin1\"):\n    \"\"\"Parses bank CSV file and returns Transactions instance.\n\n    Args:\n        filename: Path to CSV file to read.\n        format: CSV format; one of the entries in `elv.formats`.\n        encoding: The CSV file encoding.\n\n    Returns:\n        A ``Transactions`` object.\n    \"\"\"\n    Class = formats[format.lower()]\n\n    if PY3:\n        kw = {\"encoding\": encoding}\n    else:\n        kw = {}\n\n    with open(filename, \"rt\", **kw) as f:\n        return Class.csv_to_transactions(f)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_stream(stream, format=u\"J\u00e6ren Sparebank\"):\n    Class = formats[format.lower()]\n    return Class.csv_to_transactions(stream)", "response": "Parses a CSV stream and returns a Transactions instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert money amount in string to Decimal object.", "response": "def money(s, thousand_sep=\".\", decimal_sep=\",\"):\n        \"\"\"Converts money amount in string to a Decimal object.\n\n        With the default arguments, the format is expected to be\n        ``-38.500,00``, where dots separate thousands and comma the decimals.\n\n        Args:\n            thousand_sep: Separator for thousands.\n            decimal_sep: Separator for decimals.\n\n        Returns:\n            A ``Decimal`` object of the string encoded money amount.\n        \"\"\"\n        s = s.replace(thousand_sep, \"\")\n        s = s.replace(decimal_sep, \".\")\n        return Decimal(s)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a row of strings into a Transaction object.", "response": "def csv_row_to_transaction(index, row, source_encoding=\"latin1\",\n            date_format=\"%d-%m-%Y\", thousand_sep=\".\", decimal_sep=\",\"):\n        \"\"\"\n        Parses a row of strings to a ``Transaction`` object.\n\n        Args:\n            index: The index of this row in the original CSV file. Used for\n            sorting ``Transaction``s by their order of appearance.\n\n            row: The row containing strings for [transfer_date, posted_date,\n            message, money_amount, money_total].\n\n            source_encoding: The encoding that will be used to decode strings\n            to UTF-8.\n\n            date_format: The format of dates in this row.\n\n            thousand_sep: The thousand separator in money amounts.\n\n            decimal_sep: The decimal separator in money amounts.\n\n        Returns:\n            A ``Transaction`` object.\n\n        \"\"\"\n        xfer, posted, message, amount, total = row\n        xfer = Parse.date(xfer)\n        posted = Parse.date(posted)\n        message = Parse.to_utf8(message, source_encoding)\n        amount = Parse.money(amount)\n        total = Parse.money(total)\n        return Transaction(index, xfer, posted, message, amount, total)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a CSV file and returns a list of Transactions.", "response": "def csv_to_transactions(handle, source_encoding=\"latin1\",\n            date_format=\"%d-%m-%Y\", thousand_sep=\".\", decimal_sep=\",\"):\n        \"\"\"\n        Parses CSV data from stream and returns ``Transactions``.\n\n        Args:\n            index: The index of this row in the original CSV file. Used for\n            sorting ``Transaction``s by their order of appearance.\n\n            row: The row containing strings for [transfer_date, posted_date,\n            message, money_amount, money_total].\n\n            source_encoding: The encoding that will be used to decode strings\n            to UTF-8.\n\n            date_format: The format of dates in this row.\n\n            thousand_sep: The thousand separator in money amounts.\n\n            decimal_sep: The decimal separator in money amounts.\n\n        Returns:\n            A ``Transactions`` object.\n        \"\"\"\n        trans = Transactions()\n        rows = csv.reader(handle, delimiter=\";\", quotechar=\"\\\"\")\n\n        for index, row in enumerate(rows):\n            trans.append(Parse.csv_row_to_transaction(index, row))\n\n        return trans"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an SQLITE3 connection to a database containing the available log entries.", "response": "def to_sqlite3(self, location=\":memory:\"):\n        \"\"\"Returns an SQLITE3 connection to a database containing the\n        transactions.\"\"\"\n\n        def decimal_to_sqlite3(n):\n            return int(100*n)\n\n        def sqlite3_to_decimal(s):\n            return Decimal(s)/100\n\n        sqlite3.register_adapter(Decimal, decimal_to_sqlite3)\n        sqlite3.register_converter(\"decimal\", sqlite3_to_decimal)\n\n        con = sqlite3.connect(location, detect_types=sqlite3.PARSE_COLNAMES |\n                sqlite3.PARSE_DECLTYPES)\n        cur = con.cursor()\n        cur.execute(\"\"\"create table transactions(\n                           id primary key,\n                           xfer date,\n                           posted date,\n                           message text,\n                           amount decimal,\n                           total decimal)\"\"\")\n        for t in self:\n            cur.execute(\"INSERT INTO transactions values(?,?,?,?,?,?)\",\n                (t.index, t.xfer, t.posted, t.message, t.amount, t.total))\n        return con"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef group_by(self, key, field=lambda x: x.xfer):\n        return Transactions([t for t in self.trans if field(t) == key])", "response": "Returns all transactions whose given field matches key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef balance(self):\n        sin = Decimal(\"0.00\")\n        sout = Decimal(\"0.00\")\n\n        for t in self.trans:\n            if t.amount < Decimal(\"0.00\"):\n                sout += t.amount\n            else:\n                sin += t.amount\n\n        return sin, sout", "response": "Returns a tuple of ( total amount deposited total amount withdrawn )."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a Transactions object in an inclusive date range.", "response": "def range(self, start_date=None, stop_date=None, field=lambda x: x.xfer):\n        \"\"\"Return a ``Transactions`` object in an inclusive date range.\n\n        Args:\n            start_date: A ``datetime.Date`` object that marks the inclusive\n            start date for the range.\n\n            stop_date: A ``datetime.Date`` object that marks the inclusive end\n            date for the range.\n\n            field: The field to compare start and end dates to. Default is the\n            ``xfer`` field.\n\n        Returns:\n            A ``Transactions`` object.\n        \"\"\"\n        assert start_date <= stop_date, \\\n            \"Start date must be earlier than end date.\"\n\n        out = Transactions()\n\n        for t in self.trans:\n            date = field(t)\n            if (start_date is not None) and not (date >= start_date):\n                continue\n            if (stop_date is not None) and not (date <= stop_date):\n                continue\n            out.append(t)\n\n        return out"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the output file for module / package <name.", "response": "def write_file(name, text, opts):\n    \"\"\"Write the output file for module/package <name>.\"\"\"\n    fname = path.join(opts.destdir, '%s.%s' % (name, opts.suffix))\n    if opts.dryrun:\n        print 'Would create file %s.' % fname\n        return\n    if not opts.force and path.isfile(fname):\n        print 'File %s already exists, skipping.' % fname\n    else:\n        print 'Creating file %s.' % fname\n        f = open(fname, 'w')\n        try:\n            f.write(text)\n        finally:\n            f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nnormalizing the excluded directory list.", "response": "def normalize_excludes(rootpath, excludes):\n    \"\"\"Normalize the excluded directory list.\"\"\"\n    return [path.normpath(path.abspath(exclude)) for exclude in excludes]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_parser():\n    parser = optparse.OptionParser(\n        usage=\"\"\"\\\nusage: %prog [options] -o <output_path> <module_path> [exclude_path, ...]\n\nLook recursively in <module_path> for Python modules and packages and create\none reST file with automodule directives per package in the <output_path>.\n\nThe <exclude_path>s can be files and/or directories that will be excluded\nfrom generation.\n\nNote: By default this script will not overwrite already created files.\"\"\")\n\n    parser.add_option('-o', '--output-dir', action='store', dest='destdir',\n                      help='Directory to place all output', default='')\n    parser.add_option('-d', '--maxdepth', action='store', dest='maxdepth',\n                      help='Maximum depth of submodules to show in the TOC '\n                      '(default: 4)', type='int', default=4)\n    parser.add_option('-f', '--force', action='store_true', dest='force',\n                      help='Overwrite existing files')\n    parser.add_option('-l', '--follow-links', action='store_true',\n                      dest='followlinks', default=False,\n                      help='Follow symbolic links. Powerful when combined '\n                      'with collective.recipe.omelette.')\n    parser.add_option('-n', '--dry-run', action='store_true', dest='dryrun',\n                      help='Run the script without creating files')\n    parser.add_option('-e', '--separate', action='store_true',\n                      dest='separatemodules',\n                      help='Put documentation for each module on its own page')\n    parser.add_option('-P', '--private', action='store_true',\n                      dest='includeprivate',\n                      help='Include \"_private\" modules')\n    parser.add_option('-T', '--no-toc', action='store_true', dest='notoc',\n                      help='Don\\'t create a table of contents file')\n    parser.add_option('-E', '--no-headings', action='store_true',\n                      dest='noheadings',\n                      help='Don\\'t create headings for the module/package '\n                           'packages (e.g. when the docstrings already contain '\n                           'them)')\n    parser.add_option('-s', '--suffix', action='store', dest='suffix',\n                      help='file suffix (default: rst)', default='rst')\n    parser.add_option('-F', '--full', action='store_true', dest='full',\n                      help='Generate a full project with sphinx-quickstart')\n    parser.add_option('-H', '--doc-project', action='store', dest='header',\n                      help='Project name (default: root module name)')\n    parser.add_option('-A', '--doc-author', action='store', dest='author',\n                      type='str',\n                      help='Project author(s), used when --full is given')\n    parser.add_option('-V', '--doc-version', action='store', dest='version',\n                      help='Project version, used when --full is given')\n    parser.add_option('-R', '--doc-release', action='store', dest='release',\n                      help='Project release, used when --full is given, '\n                      'defaults to --doc-version')\n    return parser", "response": "Sets up the argument parser and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing and check the command line arguments.", "response": "def main(argv=sys.argv):\n    \"\"\"Parse and check the command line arguments.\"\"\"\n    parser = setup_parser()\n\n    (opts, args) = parser.parse_args(argv[1:])\n\n    if not args:\n        parser.error('A package path is required.')\n\n    rootpath, excludes = args[0], args[1:]\n    if not opts.destdir:\n        parser.error('An output directory is required.')\n    if opts.header is None:\n        opts.header = path.normpath(rootpath).split(path.sep)[-1]\n    if opts.suffix.startswith('.'):\n        opts.suffix = opts.suffix[1:]\n    if not path.isdir(rootpath):\n        print >>sys.stderr, '%s is not a directory.' % rootpath\n        sys.exit(1)\n    if not path.isdir(opts.destdir):\n        if not opts.dryrun:\n            os.makedirs(opts.destdir)\n    rootpath = path.normpath(path.abspath(rootpath))\n    excludes = normalize_excludes(rootpath, excludes)\n    modules = recurse_tree(rootpath, excludes, opts)\n    if opts.full:\n        from sphinx import quickstart as qs\n        modules.sort()\n        prev_module = ''\n        text = ''\n        for module in modules:\n            if module.startswith(prev_module + '.'):\n                continue\n            prev_module = module\n            text += '   %s\\n' % module\n        d = dict(\n            path = opts.destdir,\n            sep  = False,\n            dot  = '_',\n            project = opts.header,\n            author = opts.author or 'Author',\n            version = opts.version or '',\n            release = opts.release or opts.version or '',\n            suffix = '.' + opts.suffix,\n            master = 'index',\n            epub = True,\n            ext_autodoc = True,\n            ext_viewcode = True,\n            makefile = True,\n            batchfile = True,\n            mastertocmaxdepth = opts.maxdepth,\n            mastertoctree = text,\n        )\n        if not opts.dryrun:\n            qs.generate(d, silent=True, overwrite=opts.force)\n    elif not opts.notoc:\n        create_modules_toc_file(modules, opts)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_kwargs(grid, kwargs, phenotypes=False):\n    denom = None\n    if \"denom\" in kwargs:\n        denom = kwargs[\"denom\"]\n\n    if \"palette\" in kwargs:\n        palette = kwargs[\"palette\"]\n        if denom is None:\n            denom = len(palette)\n    elif \"environment\" in kwargs or isinstance(grid, EnvironmentFile):\n        if \"environment\" in kwargs:\n            env = kwargs[\"environment\"]\n        else:\n            env = grid\n\n        if phenotypes:\n            palette = env.task_palette\n            if denom is None:\n                denom = len(env.tasks)\n        else:\n            palette = env.resource_palette\n            if denom is None:\n                denom = len(env.resources)\n\n    else:\n        length = get_pallete_length(grid)\n        palette = sns.hls_palette(length, s=1)\n        denom = length\n\n    return denom, palette", "response": "Helper function to figure out what denom and palette to use based on the kwargs and the grid being plotted."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_pallete_length(grid):\n    elements = list(set(flatten_array(grid)))\n    length = len(elements)\n\n    if type(elements[0]) is str:\n        lengths = [len(el) for el in elements if not el.startswith(\"-\")]\n        if max(lengths) < 5:  # Mixing red and green\n            length += 2  # is not pretty so let's avoid it\n    return length", "response": "Returns the length of the palette."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef agg_grid(grid, agg=None):\n    grid = deepcopy(grid)\n\n    if agg is None:\n        if type(grid[0][0]) is list and type(grid[0][0][0]) is str:\n            agg = string_avg\n        else:\n            agg = mode\n\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            grid[i][j] = agg(grid[i][j])\n\n    return grid", "response": "This function returns a 2d list with a complex data type in each cell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef slice_3d_grid(grid, n):\n    phen_grid = initialize_grid((len(grid[0]), len(grid)), 0)\n\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            phen_grid[i][j] = grid[i][j][n]\n\n    return phen_grid", "response": "Takes a three dimensional array and an integer n and returns a 2d array containing the Nth value from the 3rd dimension at each location in the 3rd dimension at each location in the 3rd dimension."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking a multi - dimensional array and returns a 1 dimensional array with the same contents.", "response": "def flatten_array(grid):\n    \"\"\"\n    Takes a multi-dimensional array and returns a 1 dimensional array with the\n    same contents.\n    \"\"\"\n    grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))]\n    while type(grid[0]) is list:\n        grid = flatten_array(grid)\n    return grid"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a list of lists and appends 0s to the beggining of each sub_list until all of them are all the same length. Used for sign - extending binary numbers.", "response": "def prepend_zeros_to_lists(ls):\n    \"\"\"\n    Takes a list of lists and appends 0s to the beggining of each sub_list\n    until they are all the same length. Used for sign-extending binary numbers.\n    \"\"\"\n    longest = max([len(l) for l in ls])\n\n    for i in range(len(ls)):\n        while len(ls[i]) < longest:\n            ls[i].insert(0, \"0\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef squared_toroidal_dist(p1, p2, world_size=(60, 60)):\n    halfx = world_size[0]/2.0\n    if world_size[0] == world_size[1]:\n        halfy = halfx\n    else:\n        halfy = world_size[1]/2.0\n\n    deltax = p1[0] - p2[0]\n    if deltax < -halfx:\n        deltax += world_size[0]\n    elif deltax > halfx:\n        deltax -= world_size[0]\n\n    deltay = p1[1] - p2[1]\n    if deltay < -halfy:\n        deltay += world_size[1]\n    elif deltay > halfy:\n        deltay -= world_size[1]\n\n    return deltax*deltax + deltay*deltay", "response": "Squared Toroidal distance between two sets of points."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a set of resources present in a single cell to binary string representations.", "response": "def convert_world_to_phenotype(world):\n    \"\"\"\n    Converts sets indicating the resources present in a single cell to binary\n    strings (bit order is based on the order of resources in world.resources).\n\n    TODO: Figure out how to handle relationship between resources and tasks\n\n    Inputs: world - an EnvironmentFile object with a grid of resource sets\n    Returns: an EnvironmentFile object with a grid of binary strings\n    \"\"\"\n    if set(world.resources) != set(world.tasks):\n        print(\"Warning: world phenotypes don't correspond to phenotypes\")\n    if set(world.resources).issubset(set(world.tasks)):\n        conversion_func = function_with_args(res_set_to_phenotype, world.tasks)\n    else:\n        conversion_func = \\\n            function_with_args(res_set_to_phenotype, world.resources)\n\n    grid = agg_grid(deepcopy(world), conversion_func)\n    return grid"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef phenotype_to_res_set(phenotype, resources):\n    assert(phenotype[0:2] == \"0b\")\n    phenotype = phenotype[2:]\n    # Fill in leading zeroes\n    while len(phenotype) < len(resources):\n        phenotype = \"0\" + phenotype\n\n    res_set = set()\n\n    for i in range(len(phenotype)):\n        if phenotype[i] == \"1\":\n            res_set.add(resources[i])\n\n    assert(phenotype.count(\"1\") == len(res_set))\n    return res_set", "response": "Converts a binary string containing the bits in the string containing the resources indicated by the phenotype."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a set of strings indicating which resources are present to a binary string where the positions of 1s indicate which resources are present.", "response": "def res_set_to_phenotype(res_set, full_list):\n    \"\"\"\n    Converts a set of strings indicating resources to a binary string where\n    the positions of 1s indicate which resources are present.\n\n    Inputs: res_set - a set of strings indicating which resources are present\n            full_list - a list of strings indicating all resources which could\n                        could be present, and the order in which they should\n                        map to bits in the phenotype\n    returns: A binary string\n    \"\"\"\n\n    full_list = list(full_list)\n    phenotype = len(full_list) * [\"0\"]\n\n    for i in range(len(full_list)):\n        if full_list[i] in res_set:\n            phenotype[i] = \"1\"\n\n    assert(phenotype.count(\"1\") == len(res_set))\n\n    # Remove uneceesary leading 0s\n    while phenotype[0] == \"0\" and len(phenotype) > 1:\n        phenotype = phenotype[1:]\n\n    return \"0b\"+\"\".join(phenotype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef weighted_hamming(b1, b2):\n    assert(len(b1) == len(b2))\n    hamming = 0\n    for i in range(len(b1)):\n        if b1[i] != b2[i]:\n            # differences at more significant (leftward) bits\n            # are more important\n            if i > 0:\n                hamming += 1 + 1.0/i\n                # This weighting is completely arbitrary\n    return hamming", "response": "Calculates the weighted hamming distance between two strings."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef n_tasks(dec_num):\n    bitstring = \"\"\n    try:\n        bitstring = dec_num[2:]\n    except:\n        bitstring = bin(int(dec_num))[2:]  # cut off 0b\n    # print bin(int(dec_num)), bitstring\n    return bitstring.count(\"1\")", "response": "Takes a decimal number as input and returns the number of ones in the a\n    binary representation."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_to_pysal(data):\n    w = pysal.lat2W(len(data[0]), len(data))\n    data = np.array(data)\n    data = np.reshape(data, (len(data)*len(data[0]), 1))\n    return w, data", "response": "Converts a numpy array of data into a distance matrix and data formatted in a numpy array."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a list and returns the median.", "response": "def median(ls):\n    \"\"\"\n    Takes a list and returns the median.\n    \"\"\"\n    ls = sorted(ls)\n    return ls[int(floor(len(ls)/2.0))]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a list of strings of equal length and returns a string containing the most common value from each index in the string.", "response": "def string_avg(strings, binary=True):\n    \"\"\"\n    Takes a list of strings of equal length and returns a string containing\n    the most common value from each index in the string.\n\n    Optional argument: binary - a boolean indicating whether or not to treat\n    strings as binary numbers (fill in leading zeros if lengths differ).\n    \"\"\"\n\n    if binary:  # Assume this is a binary number and fill leading zeros\n        strings = deepcopy(strings)\n        longest = len(max(strings, key=len))\n\n        for i in range(len(strings)):\n            while len(strings[i]) < longest:\n                split_string = strings[i].split(\"b\")\n                strings[i] = \"0b0\" + split_string[1]\n\n    avg = \"\"\n    for i in (range(len(strings[0]))):\n        opts = []\n        for s in strings:\n            opts.append(s[i])\n        avg += max(set(opts), key=opts.count)\n\n    return avg"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_world_dimensions(gridfile, delim=\" \"):\n    infile = open(gridfile)\n    lines = infile.readlines()\n    infile.close()\n    world_x = len(lines[0].strip().split(delim))\n    world_y = len(lines)\n    return (world_x, world_y)", "response": "This function takes a name of a file in grid_task format and returns the dimensions of the world it represents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the grid with the specified dimensions.", "response": "def initialize_grid(world_size, inner):\n    \"\"\"\n    Creates an empty grid (2d list) with the dimensions specified in\n    world_size. Each element is initialized to the inner argument.\n    \"\"\"\n    data = []\n\n    for i in range(world_size[1]):\n        data.append([])\n        for j in range(world_size[0]):\n            data[i].append(deepcopy(inner))\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply(self, resource):\n        if not isinstance(resource, Image.Image):\n            raise ValueError('Unknown resource format')\n\n        original_width, original_height = resource.size\n\n        resource_format = resource.format\n\n        if self.mode == 'outbound':\n            target_width, target_height = self.outbound_sizes(original_width, original_height, self.width, self.height)\n            resource = resource.resize((target_width, target_height), Image.ANTIALIAS)\n\n            crop_sizes = self.crop_sizes(target_width, target_height, self.width, self.height)\n            resource = resource.crop(crop_sizes)\n        else:\n            target_width, target_height = self.inset_sizes(original_width, original_height, self.width, self.height)\n            resource = resource.resize((target_width, target_height), Image.ANTIALIAS)\n\n        resource.format = resource_format\n\n        return resource", "response": "Apply filter to resource\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inset_sizes(cls, original_width, original_height, target_width, target_height):\n        if target_width >= original_width and target_height >= original_height:\n            target_width = float(original_width)\n            target_height = original_height\n\n        elif target_width <= original_width and target_height >= original_height:\n            k = original_width / float(target_width)\n            target_height = int(original_height / k)\n\n        elif target_width >= original_width and target_height <= original_height:\n            k = original_height / float(target_height)\n            target_width = int(original_width / k)\n\n        elif target_width < original_width and target_height < original_height:\n            k = original_width / float(original_height)\n            k_w = original_width / float(target_width)\n            k_h = original_height / float(target_height)\n\n            if k_w >= k_h:\n                target_height = int(target_width / k)\n            else:\n                target_width = int(target_height * k)\n\n        return target_width, target_height", "response": "Calculate new image sizes for inset mode."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef outbound_sizes(cls, original_width, original_height, target_width, target_height):\n        if target_width <= original_width and target_height <= original_height:\n            k = original_width / float(original_height)\n            k_w = original_width / float(target_width)\n            k_h = original_height / float(target_height)\n\n            if k_w > k_h:\n                target_width = int(target_height * k)\n            else:\n                target_height = int(target_width / k)\n        else:\n            target_width = original_width\n            target_height = original_height\n\n        return target_width, target_height", "response": "Calculate new image sizes for the given image size."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the sizes of the crop parameters for outbound mode.", "response": "def crop_sizes(cls, original_width, original_height, target_width, target_height):\n        \"\"\"\n        Calculate crop parameters for outbound mode\n        :param original_width: int\n        :param original_height: int\n        :param target_width: int\n        :param target_height: int\n        :return: tuple(int, int, int, int)\n        \"\"\"\n        if target_width < original_width:\n            left = abs(original_width - target_width) / 2\n            right = left + target_width\n        else:\n            left = 0\n            right = original_width\n        if target_height < original_height:\n            upper = abs(original_height - target_height) / 2\n            lower = upper + target_height\n        else:\n            upper = 0\n            lower = original_height\n\n        return left, upper, right, lower"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_sampleset(self, f, name):\n        '''Serialize the sampleset to file using the HDF5 format. Name is usually in {train, test}.'''\n        f.create_dataset(name + '_encoder_x', data=self.encoder_x)\n        f.create_dataset(name + '_decoder_x', data=self.decoder_x)\n        f.create_dataset(name + '_decoder_y', data=self.decoder_y)", "response": "Serialize the sampleset to file using the HDF5 format. Name is usually in train test."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_sampleset(self, f, name):\n        '''Read the sampleset from using the HDF5 format. Name is usually in {train, test}.'''\n        self.encoder_x = np.array(f[name + '_encoder_x'])\n        self.decoder_x = np.array(f[name + '_decoder_x'])\n        self.decoder_y = np.array(f[name + '_decoder_y'])", "response": "Read the sampleset from using the HDF5 format. Name is usually in train test."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlogs a message at the specified priority.", "response": "def log(self, priority, msg):\n        \"\"\"\n        Just a wrapper, for convenience.\n        NB1: priority may be set to one of:\n        - CRITICAL     [50]\n        - ERROR        [40]\n        - WARNING      [30]\n        - INFO         [20]\n        - DEBUG        [10]\n        - NOTSET       [0]\n        Anything else defaults to [20]\n        NB2: the levelmap is a defaultdict stored in Config; it maps priority\n             strings onto integers\n        \"\"\"\n        # self.logger.log(self.config.levelmap[priority], msg)\n        self.logger.log(logging.CRITICAL, msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pformat(self):\n        '''\n        Manually pformat to force using \"\"\"...\"\"\" and supress escaping apostrophe\n        '''\n        result = \"{\\n\"\n        indent1 = \" \" * 4\n        indent2 = \" \" * 8\n        for line_no, code_objects in sorted(self.items()):\n            result += '%s%i: [\\n' % (indent1, line_no)\n            for code_object in code_objects:\n                result += '%s\"\"\"<%s:%s>\"\"\",\\n' % (\n                    indent2, code_object.PART_TYPE, code_object.content\n                )\n            result += '%s],\\n' % indent1\n        result += \"}\"\n\n        return result", "response": "Return a string representation of the cache entry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the given ASCII BASIC listing.", "response": "def parse(self, ascii_listing):\n        \"\"\"\n        parse the given ASCII BASIC listing.\n        Return a ParsedBASIC() instance.\n        \"\"\"\n        self.parsed_lines = ParsedBASIC()\n        for match in self.regex_line_no.finditer(ascii_listing):\n            log.info(\"_\" * 79)\n            log.info(\"parse line >>>%r<<<\", match.group())\n            line_no = int(match.group(\"no\"))\n            line_content = match.group(\"content\")\n\n            self.line_data = []\n            self._parse_code(line_content)\n            log.info(\"*** line %s result: %r\", line_no, self.line_data)\n\n            self.parsed_lines[line_no] = self.line_data\n\n        return self.parsed_lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_data(self, line, old_data=\"\"):\n        log.debug(\"*** parse DATA: >>>%r<<< old data: >>>%r<<<\", line, old_data)\n        parts = self.regex_split_data.split(line, maxsplit=1)\n        if len(parts) == 1:  # end\n            return old_data + parts[0], None\n\n        pre, match, post = parts\n        log.debug(\"\\tpre: >>>%r<<<\", pre)\n        pre = old_data + pre\n        log.debug(\"\\tmatch: >>>%r<<<\", match)\n        log.debug(\"\\tpost: >>>%r<<<\", post)\n        if match == \":\":\n            return old_data, match + post\n        elif match == '\"':\n            string_part, rest = self._parse_string(post)\n            return self._parse_data(rest, old_data=pre + match + string_part)\n\n        raise RuntimeError(\"Wrong Reg.Exp.? match is: %r\" % match)", "response": "Parse a DATA section of a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a string from the log and return the pre and post parts.", "response": "def _parse_string(self, line):\n        \"\"\"\n        Consume the complete string until next \" or \\n\n        \"\"\"\n        log.debug(\"*** parse STRING: >>>%r<<<\", line)\n        parts = self.regex_split_string.split(line, maxsplit=1)\n        if len(parts) == 1:  # end\n            return parts[0], None\n\n        pre, match, post = parts\n        log.debug(\"\\tpre: >>>%r<<<\", pre)\n        log.debug(\"\\tmatch: >>>%r<<<\", match)\n        log.debug(\"\\tpost: >>>%r<<<\", post)\n        pre = pre + match\n        log.debug(\"Parse string result: %r,%r\", pre, post)\n        return pre, post"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_code(self, line):\n        log.debug(\"*** parse CODE: >>>%r<<<\", line)\n        parts = self.regex_split_all.split(line, maxsplit=1)\n        if len(parts) == 1:  # end\n            self.line_data.append(BASIC_Code(parts[0]))\n            return\n        pre, match, post = parts\n        log.debug(\"\\tpre: >>>%r<<<\", pre)\n        log.debug(\"\\tmatch: >>>%r<<<\", match)\n        log.debug(\"\\tpost: >>>%r<<<\", post)\n\n        if match == '\"':\n            log.debug(\"%r --> parse STRING\", match)\n            self.line_data.append(BASIC_Code(pre))\n            string_part, rest = self._parse_string(post)\n            self.line_data.append(BASIC_String(match + string_part))\n            if rest:\n                self._parse_code(rest)\n            return\n\n        self.line_data.append(BASIC_Code(pre + match))\n\n        if match == \"DATA\":\n            log.debug(\"%r --> parse DATA\", match)\n            data_part, rest = self._parse_data(post)\n            self.line_data.append(BASIC_Data(data_part))\n            if rest:\n                self._parse_code(rest)\n            return\n        elif match in (\"'\", \"REM\"):\n            log.debug(\"%r --> consume rest of the line as COMMENT\", match)\n            if post:\n                self.line_data.append(BASIC_Comment(post))\n            return\n\n        raise RuntimeError(\"Wrong Reg.Exp.? match is: %r\" % match)", "response": "parse the given BASIC line and branch into DATA STRING and COMMENT and return a new entry for the new entry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclose multiple components. To be closed components must implement [[ICloseable]] interface. If they don't the call to this method has no effect. :param correlation_id: (optional) transaction id to trace execution through call chain. :param components: the list of components that are to be closed.", "response": "def close(correlation_id, components):\n        \"\"\"\n        Closes multiple components.\n\n        To be closed components must implement [[ICloseable]] interface.\n        If they don't the call to this method has no effect.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param components: the list of components that are to be closed.\n        \"\"\"\n        if components == None:\n            return\n\n        for component in components:\n            Closer.close_one(correlation_id, component)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd static files endpoint with optional directory index.", "response": "def add(app, url = None, path = None, endpoint=None, decorate=None, index='index.html', **options):\n    \"\"\"Adds static files endpoint with optional directory index.\"\"\"\n\n    url = url or app.static_url_path or ''\n    path = os.path.abspath(path or app.static_folder or '.')\n    endpoint = endpoint or 'static_' + os.path.basename(path)\n    decorate = decorate or (lambda f: f)\n    endpoints = {}\n\n    if path == app.static_folder:\n        raise ValueError('Files in `{}` path are already automatically served on `{}` URL by Flask.'\n            ' Set Flask app static_folder to None, if you want to serve them using Flask Ecstatic at `{}` URL'\n            .format(path, app.static_url_path, url))\n\n    @app.route(url + '/<path:filename>', endpoint = endpoint)\n    @handle404\n    @decorate\n    def static_files(filename):\n        if index:\n            filename = safe_join(path, filename)\n            if os.path.isdir(filename):\n                filename = os.path.join(filename, index)\n            return send_file(filename, **options)\n        else:\n            return send_from_directory(path, filename, **options)\n\n    endpoints[endpoint] = static_files\n\n    if index:\n         @app.route(url + '/', endpoint = endpoint + '_index')\n         @handle404\n         @decorate\n         def static_index():\n             return send_from_directory(path, index, **options)\n\n         endpoints[endpoint + '_index'] = static_index\n\n         if url:\n             @app.route(url, endpoint = endpoint + '_index_bare')\n             @handle404\n             @decorate\n             def static_index_bare():\n                 return send_from_directory(path, index, **options)\n\n             endpoints[endpoint + '_index_bare'] = static_index_bare\n\n    return endpoints"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a memory dump of a tokensized BASIC listing into ASCII listing list.", "response": "def program_dump2ascii_lines(self, dump, program_start=None):\n        \"\"\"\n        convert a memory dump of a tokensized BASIC listing into\n        ASCII listing list.\n        \"\"\"\n        dump = bytearray(dump)\n        # assert isinstance(dump, bytearray)\n\n        if program_start is None:\n            program_start = self.DEFAULT_PROGRAM_START\n        return self.listing.program_dump2ascii_lines(dump, program_start)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a ASCII BASIC program listing into tokens.", "response": "def ascii_listing2program_dump(self, basic_program_ascii, program_start=None):\n        \"\"\"\n        convert a ASCII BASIC program listing into tokens.\n        This tokens list can be used to insert it into the\n        Emulator RAM.\n        \"\"\"\n        if program_start is None:\n            program_start = self.DEFAULT_PROGRAM_START\n\n        basic_lines = self.ascii_listing2basic_lines(basic_program_ascii, program_start)\n\n        program_dump=self.listing.basic_lines2program_dump(basic_lines, program_start)\n        assert isinstance(program_dump, bytearray), (\n            \"is type: %s and not bytearray: %s\" % (type(program_dump), repr(program_dump))\n        )\n        return program_dump"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pformat_program_dump(self, program_dump, program_start=None):\n        assert isinstance(program_dump, bytearray)\n\n        if program_start is None:\n            program_start = self.DEFAULT_PROGRAM_START\n        return self.listing.pformat_program_dump(program_dump, program_start)", "response": "Format a BASIC program dump. Useful for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bin2bas(self, data):\n        data = bytearray(data)\n\n        binary_file = BinaryFile()\n        binary_file.load_from_bin(data)\n\n        if binary_file.file_type != 0x01:\n            log.error(\"ERROR: file type $%02X is not $01 (tokenised BASIC)!\", binary_file.file_type)\n\n        ascii_lines = self.program_dump2ascii_lines(dump=binary_file.data,\n            # FIXME:\n            #program_start=bin.exec_address\n            program_start=binary_file.load_address\n        )\n        return \"\\n\".join(ascii_lines)", "response": "Convert binary files to ASCII basic string."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a GAF 2. 0 - compatible string representation of the annotation.", "response": "def get_gaf_format(self):\n        \"\"\"Return a GAF 2.0-compatible string representation of the annotation.\n\n        Parameters\n        ----------\n\n        Returns\n        -------\n        str\n            The formatted string.\n        \"\"\"\n        sep = '\\t'\n        return sep.join(\n            [self.gene, self.db_ref, self.term.id, self.evidence,\n             '|'.join(self.db_ref), '|'.join(self.with_)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nraising stopiteration with end the parse. isAveragedException", "response": "def ahead(self, i, j=None):\n        '''Raising stopiteration with end the parse.\n        '''\n        if j is None:\n            return self._stream[self.i + i]\n        else:\n            return self._stream[self.i + i: self.i + j]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntransform underscore separated string to pascal case", "response": "def to_pascal_case(s):\n    \"\"\"Transform underscore separated string to pascal case\n\n    \"\"\"\n    return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransforms camel or pascal case to underscore separated string Apps", "response": "def to_underscore(s):\n    \"\"\"Transform camel or pascal case to underscore separated string\n\n    \"\"\"\n    return re.sub(\n            r'(?!^)([A-Z]+)',\n            lambda m: \"_{0}\".format(m.group(1).lower()),\n            re.sub(r'(?!^)([A-Z]{1}[a-z]{1})', lambda m: \"_{0}\".format(m.group(1).lower()), s)\n        ).lower()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nencode a sequence of two - element tuples or dictionary into a URL query string.", "response": "def urlencode2(query, doseq=0, safe=\"\", querydelimiter=\"&\"):\n    \"\"\"Encode a sequence of two-element tuples or dictionary into a URL query string.\n\n    If any values in the query arg are sequences and doseq is true, each\n    sequence element is converted to a separate parameter.\n\n    If the query arg is a sequence of two-element tuples, the order of the\n    parameters in the output will match the order of parameters in the\n    input.\n    \"\"\"\n\n    if hasattr(query,\"items\"):\n        # mapping objects\n        query = query.items()\n    else:\n        # it's a bother at times that strings and string-like objects are\n        # sequences...\n        try:\n            # non-sequence items should not work with len()\n            # non-empty strings will fail this\n            if len(query) and not isinstance(query[0], tuple):\n                raise TypeError\n            # zero-length sequences of all types will get here and succeed,\n            # but that's a minor nit - since the original implementation\n            # allowed empty dicts that type of behavior probably should be\n            # preserved for consistency\n        except TypeError:\n            ty,va,tb = sys.exc_info()\n            raise TypeError(\"not a valid non-string sequence or mapping object \" + tb)\n\n    l = []\n    if not doseq:\n        # preserve old behavior\n        for k, v in query:\n            k = quote_plus(str(k), safe=safe)\n            v = quote_plus(str(v), safe=safe)\n            l.append(k + '=' + v)\n    else:\n        for k, v in query:\n            k = quote_plus(str(k), safe=safe)\n            if isinstance(v, str):\n                v = quote_plus(v, safe=safe)\n                l.append(k + '=' + v)\n            elif _is_unicode(v):\n                # is there a reasonable way to convert to ASCII?\n                # encode generates a string, but \"replace\" or \"ignore\"\n                # lose information and \"strict\" can raise UnicodeError\n                v = quote_plus(v.encode(\"ASCII\",\"replace\"))\n                l.append(k + '=' + v)\n            else:\n                try:\n                    # is this a sufficient test for sequence-ness?\n                    len(v)\n                except TypeError:\n                    # not a sequence\n                    v = quote_plus(str(v), safe=safe)\n                    l.append(k + '=' + v)\n                else:\n                    # loop over the sequence\n                    for elt in v:\n                        l.append(k + '=' + quote_plus(str(elt)))\n    return querydelimiter.join(l)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef chance(chances, max_chances):\n        chances = chances if chances >= 0 else 0\n        max_chances = max_chances if max_chances >= 0 else 0\n        if chances == 0 and max_chances == 0:\n            return False\n        \n        max_chances = max(max_chances, chances)\n        start = (max_chances - chances) / 2\n        end = start + chances\n        hit = random.random() * max_chances\n        return hit >= start and hit <= end", "response": "Calculates a random chance out of a set of chances."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef notify(self, correlation_id, args):\n        for listener in self._listeners:\n            try:\n                listener.on_event(correlation_id, self, args)\n            except Exception as ex:\n                raise InvocationException(\n                    correlation_id,\n                    \"EXEC_FAILED\",\n                    \"Raising event \" + self._name + \" failed: \" + str(ex)\n                ).with_details(\"event\", self._name).wrap(ex)", "response": "Fires this event and notifies all registered listeners."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntrue constructor which really initializes the : class : HTMLElement.", "response": "def _init_tag(self, tag):\n        \"\"\"\n        True constructor, which really initializes the :class:`HTMLElement`.\n\n        This is the function where all the preprocessing happens.\n\n        Args:\n            tag (str): HTML tag as string.\n        \"\"\"\n        self._element = tag\n\n        self._parseIsTag()\n        self._parseIsComment()\n\n        if not self._istag or self._iscomment:\n            self._tagname = self._element\n        else:\n            self._parseTagName()\n\n        if self._iscomment or not self._istag:\n            return\n\n        self._parseIsEndTag()\n        self._parseIsNonPairTag()\n\n        if self._istag and (not self._isendtag) or \"=\" in self._element:\n            self._parseParams()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _init_tag_params(self, tag, params):\n        self._element = tag\n        self.params = params\n        self._parseTagName()\n        self._istag = True\n        self._isendtag = False\n        self._isnonpairtag = False\n\n        self._element = self.tagToString()", "response": "This method is used to initialize the internal state of the tag and the parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parseIsTag(self):\n        el = self._element\n        self._istag = el and el[0] == \"<\" and el[-1] == \">\"", "response": "Parses the element s isTag property."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the element and returns a boolean indicating if the element is nonpair or not.", "response": "def _parseIsNonPairTag(self):\n        \"\"\"\n        Detect whether the element is nonpair or not (ends with ``/>``).\n\n        Result is saved to the :attr:`_isnonpairtag` property.\n        \"\"\"\n        self._isnonpairtag = False\n\n        if self._iscomment:\n            return\n\n        if self._element.startswith(\"<\") and self._element.endswith(\"/>\"):\n            self._isnonpairtag = True\n\n        # check listed nonpair tags\n        if self._istag and self._tagname.lower() in NONPAIR_TAGS:\n            self._isnonpairtag = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the isComment attribute of the element.", "response": "def _parseIsComment(self):\n        \"\"\"\n        Detect whether the element is HTML comment or not.\n\n        Result is saved to the :attr:`_iscomment` property.\n        \"\"\"\n        self._iscomment = (\n            self._element.startswith(\"<!--\") and self._element.endswith(\"-->\")\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parseTagName(self):\n        for el in self._element.split():\n            el = el.replace(\"/\", \"\").replace(\"<\", \"\").replace(\">\", \"\")\n\n            if el.strip():\n                self._tagname = el.rstrip()\n                return", "response": "Parse the name of the tag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the parameters from their string HTML representation to dictionary.", "response": "def _parseParams(self):\n        \"\"\"\n        Parse parameters from their string HTML representation to dictionary.\n\n        Result is saved to the :attr:`params` property.\n        \"\"\"\n        # check if there are any parameters\n        if \" \" not in self._element or \"=\" not in self._element:\n            return\n\n        # remove '<' & '>'\n        params = self._element.strip()[1:-1].strip()\n\n        # remove tagname\n        offset = params.find(self.getTagName()) + len(self.getTagName())\n        params = params[offset:].strip()\n\n        # parser machine\n        next_state = 0\n        key = \"\"\n        value = \"\"\n        end_quote = \"\"\n        buff = [\"\", \"\"]\n        for c in params:\n            if next_state == 0:      # key\n                if c.strip() != \"\":  # safer than list space, tab and all\n                    if c == \"=\":     # possible whitespaces in UTF\n                        next_state = 1\n                    else:\n                        key += c\n\n            elif next_state == 1:    # value decisioner\n                if c.strip() != \"\":  # skip whitespaces\n                    if c == \"'\" or c == '\"':\n                        next_state = 3\n                        end_quote = c\n                    else:\n                        next_state = 2\n                        value += c\n\n            elif next_state == 2:    # one word parameter without quotes\n                if c.strip() == \"\":\n                    next_state = 0\n                    self.params[key] = value\n                    key = \"\"\n                    value = \"\"\n                else:\n                    value += c\n\n            elif next_state == 3:    # quoted string\n                if c == end_quote and (buff[0] != \"\\\\\" or (buff[0]) == \"\\\\\" and buff[1] == \"\\\\\"):\n                    next_state = 0\n                    self.params[key] = unescape(value, end_quote)\n                    key = \"\"\n                    value = \"\"\n                    end_quote = \"\"\n                else:\n                    value += c\n\n            buff = _rotate_buff(buff)\n            buff[0] = c\n\n        if key:\n            if end_quote and value.strip():\n                self.params[key] = unescape(value, end_quote)\n            else:\n                self.params[key] = value\n\n        if \"/\" in self.params.keys():\n            del self.params[\"/\"]\n            self._isnonpairtag = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns True if the element is listed in nonpair tag table.", "response": "def isNonPairTag(self, isnonpair=None):\n        \"\"\"\n        True if element is listed in nonpair tag table (``br`` for example) or\n        if it ends with ``/>`` (``<hr />`` for example).\n\n        You can also change state from pair to nonpair if you use this as\n        setter.\n\n        Args:\n            isnonpair (bool, default None): If set, internal nonpair state is\n                      changed.\n\n        Returns:\n            book: True if tag is nonpair.\n        \"\"\"\n        if isnonpair is None:\n            return self._isnonpairtag\n\n        if not self._istag:\n            return\n\n        if isnonpair:\n            self.endtag = None\n            self.childs = []\n\n        self._isnonpairtag = isnonpair"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if this is a pair tag.", "response": "def isPairTag(self):\n        \"\"\"\n        Returns:\n            bool: True if this is pair tag - ``<body> .. </body>`` for example.\n        \"\"\"\n        if self.isComment() or self.isNonPairTag():\n            return False\n\n        if self.isEndTag():\n            return True\n\n        if self.isOpeningTag() and self.endtag:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isOpeningTag(self):\n        if self.isTag() and \\\n           not self.isComment() and \\\n           not self.isEndTag() and \\\n           not self.isNonPairTag():\n            return True\n\n        return False", "response": "Returns True if this tag is opening."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isEndTagTo(self, opener):\n        if not (self._isendtag and opener.isOpeningTag()):\n            return False\n\n        return self._tagname.lower() == opener.getTagName().lower()", "response": "Returns True if this element is endtag to opener."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tagToString(self):\n        def is_el_without_params():\n            return not self.params and \"=\" not in self._element\n\n        if not self.isTag() or self.isComment() or is_el_without_params():\n            return self._element\n\n        output = \"<\" + str(self._tagname)\n\n        for key in self.params:\n            output += \" \" + key + \"=\\\"\" + escape(self.params[key], '\"') + \"\\\"\"\n\n        return output + \" />\" if self._isnonpairtag else output + \">\"", "response": "Returns the HTML element representation of the tag but only the tag but not the childs or endtag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the Shannon entropy of a given environment.", "response": "def calc_environment_entropy(world, world_size=(60, 60),\n                             exclude_desert=False):\n    \"\"\"\n    Calculate the Shannon entropy of a given environment, treating each niche\n    (where niches are defined by regions in which different sets of resources\n    are rewarded) as a category. The environment is specified with the\n    following inputs:\n\n    world - a list of lists of sets of resources (strings) indicating\n            the set of resources in every cell in the world.\n\n    world_size - a tuple indicating the dimensions of the world.\n           Default = 60x60, because that's the default Avida world siz\n\n    excludeDesert - an optional argument which defaults to False. If True is\n          specific, niches in which no tasks are rewarded\n          will not be considered in the calculation.\n    \"\"\"\n\n    niches = make_niche_dictionary(world, world_size)\n\n    if exclude_desert and frozenset([]) in niches:\n        del niches[frozenset([])]\n\n    # Calculate entropy\n    return entropy(niches)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef entropy(dictionary):\n    total = 0.0\n    entropy = 0\n    for key in dictionary.keys():\n        total += dictionary[key]\n\n    for key in dictionary.keys():\n        entropy += dictionary[key]/total * log(1.0/(dictionary[key]/total), 2)\n    return entropy", "response": "Returns the entropy of the keys in a frequency dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate Shannon entropy based on square root of phenotype count.", "response": "def sqrt_shannon_entropy(filename):\n    \"\"\"\n    Calculates Shannon entropy based on square root of phenotype count.\n    This might account for relationship between population size and\n    evolvability.\n    \"\"\"\n    data = load_grid_data(filename, \"int\")\n    data = agg_grid(data, mode)\n    phenotypes = {}\n    for r in data:\n        for c in r:\n            if c in phenotypes:\n                phenotypes[c] += 1\n            else:\n                phenotypes[c] = 1\n\n    for key in phenotypes.keys():\n        phenotypes[key] = sqrt(phenotypes[key])\n\n    return entropy(phenotypes)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _composed_doc(fs):\n    if not fs:\n        # Argument name for the docstring.\n        return 'n'\n\n    return '{f}({g})'.format(f=fs[0].__name__, g=_composed_doc(fs[1:]))", "response": "Generates a docstring for the composition of a file system."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compose(*fs):\n    # Pull the iterator out into a tuple so we can call `composed`\n    # more than once.\n    rs = tuple(reversed(fs))\n\n    def composed(n):\n        return reduce(lambda a, b: b(a), rs, n)\n\n    # Attempt to make the function look pretty with\n    # a fresh docstring and name.\n    try:\n        composed.__doc__ = 'lambda n: ' + _composed_doc(fs)\n    except AttributeError:\n        # One of our callables does not have a `__name__`, whatever.\n        pass\n    else:\n        # We already know that for all `f` in `fs`, there exists `f.__name__`\n        composed.__name__ = '_of_'.join(f.__name__ for f in fs)\n\n    return composed", "response": "Compose functions together in order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate(self, path, schema, value, results):\n        name = path if path != None else \"value\"\n        found = False\n\n        for this_value in self._values:\n            if this_value != None and this_value == value:\n                found = True\n                break\n\n        if not found:\n            results.append(\n                ValidationResult(\n                    path,\n                    ValidationResultType.Error,\n                    \"VALUE_NOT_INCLUDED\",\n                    name + \" must be one of \" + str(self._values),\n                    self._values,\n                    value\n                )\n            )", "response": "Validates a given value against this rule."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect_widget(self, wid, getters=None, setters=None,\n                       signals=None, arg=None,\n                       flavours=None):\n        \"\"\"\n        Called when the widget is instantiated, and the adapter is\n        ready to connect the widgets inside it (if a container) or\n        each widget if wid is a list of widgets. getters and setters\n        can be None, a function or a list or a map of\n        functions. signals can be None, a signal name, or a list or\n        a map of signal names. When maps are used, keys can be\n        widgets or widget names. The length of the possible lists or\n        maps must be lesser or equal to the number of widgets that\n        will be connected.\n        \"\"\"\n\n        if isinstance(wid, Gtk.Container):\n            self._widgets = wid.get_children()\n        elif isinstance(wid, (list, tuple)):\n            self._widgets = wid\n        else:\n            raise TypeError(\"widget must be either a Gtk.Container or a list or tuple\")\n\n        # prepares the mappings:\n        for idx, w in enumerate(self._widgets):\n            if self._prop_is_map: idx=_get_name(w)\n            self._idx2wid[idx] = w\n            self._wid2idx[w] = idx\n            pass\n\n        # prepares the lists for signals\n        getters = self.__handle_par(\"getters\", getters)\n        setters = self.__handle_par(\"setters\", setters)\n        signals = self.__handle_par(\"signals\", signals)\n        flavours = self.__handle_par(\"flavours\", flavours)\n\n        for wi,ge,se,si,fl in zip(self._widgets, getters, setters, signals, flavours):\n            if type(ge) == types.MethodType: ge = ge.im_func\n            if type(se) == types.MethodType: se = se.im_func\n            UserClassAdapter.connect_widget(self, wi, ge, se, si, arg, False, fl)\n            pass\n\n        self.update_widget()\n        self._wid = wid\n        return", "response": "Connects the given widget to the adapter."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_model(self, idx=None):\n        if idx is None:\n            for w in self._widgets:\n                idx = self._get_idx_from_widget(w)\n                try: val = self._read_widget(idx)\n                except ValueError: pass\n                else: self._write_property(val, idx)\n                pass\n            pass\n        else:\n            try: val = self._read_widget(idx)\n            except ValueError: pass\n            else: self._write_property(val, idx)\n        return", "response": "Updates the value of property at given index."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nforce the widget at given index to be updated from the property value. If idx is not given all controlled widgets will be updated.", "response": "def update_widget(self, idx=None):\n        \"\"\"Forces the widget at given index to be updated from the\n        property value. If index is not given, all controlled\n        widgets will be updated. This method should be called\n        directly by the user when the property is not observable, or\n        in very unusual conditions.\"\"\"\n        if idx is None:\n            for w in self._widgets:\n                idx = self._get_idx_from_widget(w)\n                self._write_widget(self._read_property(idx), idx)\n            pass\n        else: self._write_widget(self._read_property(idx), idx)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall when the widget is changed", "response": "def _on_wid_changed(self, wid):\n        \"\"\"Called when the widget is changed\"\"\"\n        if self._itsme: return\n        self.update_model(self._get_idx_from_widget(wid))\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _on_prop_changed(self, instance, meth_name, res, args, kwargs):\n        if  not self._itsme and meth_name == \"__setitem__\": self.update_widget(args[0])\n        return", "response": "Called by the observation code when the property is changed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch the given url strip formfeeds and decode the response into the defined encoding ridge", "response": "def fetch_url(url):\n    \"\"\"\n    Fetch the given url, strip formfeeds and decode\n    it into the defined encoding\n    \"\"\"\n\n    with closing(urllib.urlopen(url)) as f:\n        if f.code is 200:\n            response = f.read()\n            return strip_formfeeds(response).decode(ENCODING)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndo a regex match of the mount entry string", "response": "def match_entry_line(str_to_match, regex_obj=MAIN_REGEX_OBJ):\n    \"\"\"Does a regex match of the mount entry string\"\"\"\n    match_obj = regex_obj.match(str_to_match)\n    if not match_obj:\n        error_message = ('Line \"%s\" is unrecognized by overlay4u. '\n                'This is only meant for use with Ubuntu Linux.')\n        raise UnrecognizedMountEntry(error_message % str_to_match)\n    return match_obj.groupdict()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of all the mount entries in this instance.", "response": "def as_list(self, fs_type=None):\n        \"\"\"List mount entries\"\"\"\n        entries = self._entries\n        if fs_type:\n            entries = filter(lambda a: a.fs_type == fs_type, entries)\n        return entries"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cast_value(val, totype):\n    t = type(val)\n    if issubclass(t, totype):\n        return val  # no cast needed\n    if issubclass(totype, bytes):\n        return bytes(val)\n    if issubclass(totype, str):\n        return str(val)\n    if issubclass(totype, bool):\n        if issubclass(t, str):\n            _v = val.lower()\n            if _v in (\"true\", \"yes\", \"y\"):\n                return True\n            if _v in (\"false\", \"no\", \"n\"):\n                return False\n            raise TypeError(\"Not able to cast value: \" + str(val) +\n                            \" with \" + str(t) +\n                            \" to \" + str(totype))\n\n    if (issubclass(totype, (int, float)) and\n        issubclass(t, (bytes, str, int, float))):\n        if val:\n            return totype(float(val))\n        else:\n            return totype(0)\n\n    raise TypeError(\"Not able to cast value:\" + str(val) +\n                    \" with \" + str(t) +\n                    \" to \" + str(totype))", "response": "Cast a value to a different type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __nt_relpath(path, start=os.curdir):\n\n    if not path: raise ValueError(\"no path specified\")\n\n    start_list = os.path.abspath(start).split(os.sep)\n    path_list = os.path.abspath(path).split(os.sep)\n    if start_list[0].lower() != path_list[0].lower():\n        unc_path, rest = os.path.splitunc(path)\n        unc_start, rest = os.path.splitunc(start)\n        if bool(unc_path) ^ bool(unc_start):\n            raise ValueError(\"Cannot mix UNC and non-UNC paths (%s and %s)\" \\\n                             % (path, start))\n        else: raise ValueError(\"path is on drive %s, start on drive %s\" \\\n                               % (path_list[0], start_list[0]))\n    # Work out how much of the filepath is shared by start and path.\n    for i in range(min(len(start_list), len(path_list))):\n        if start_list[i].lower() != path_list[i].lower():\n            break\n        else: i += 1\n        pass\n\n    rel_list = [os.pardir] * (len(start_list)-i) + path_list[i:]\n    if not rel_list: return os.curdir\n    return os.path.join(*rel_list)", "response": "Return a relative version of a path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef render(self, f_buf=None):\n        if f_buf is None:\n            f_buf = StringIO.StringIO()\n        with odswriter.writer(f_buf) as writer:\n            default_sheet = writer.new_sheet(self.title)\n            self._render_headers(default_sheet)\n            self._render_rows(default_sheet)\n\n            # abstract_sheet require the same attributes as our current writer\n            for abstract_sheet in self.sheets:\n                sheet = writer.new_sheet(name=abstract_sheet.title)\n                abstract_sheet._render_headers(sheet)\n                abstract_sheet._render_rows(sheet)\n        f_buf.seek(0)\n        return f_buf", "response": "Definesitely render the workbook and returns a file buffer that can be used to write the workbook to f_buf"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the headers row", "response": "def _render_headers(self, sheet):\n        \"\"\"\n        Write the headers row\n\n        :param obj sheet: an odswriter Sheet object\n        \"\"\"\n        headers = getattr(self, 'headers', ())\n        labels = [header['label'] for header in headers]\n        extra_headers = getattr(self, \"extra_headers\", ())\n        labels.extend([header['label'] for header in extra_headers])\n        sheet.writerow(labels)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an SqlaOdsExporter for the given related object and stores it in the column as a cache", "response": "def _get_related_exporter(self, related_obj, column):\n        \"\"\"\n        returns an SqlaOdsExporter for the given related object and stores it in\n        the column object as a cache\n        \"\"\"\n        result = column.get('sqla_ods_exporter')\n        if result is None:\n            result = column['sqla_ods_exporter'] = SqlaOdsExporter(\n                related_obj.__class__,\n                is_root=False,\n                title=column.get('label', column['key']),\n            )\n            self.add_sheet(result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_relationship_cell_val(self, obj, column):\n        val = SqlaExporter._get_relationship_cell_val(self, obj, column)\n        if val == \"\":\n            related_key = column.get('related_key', None)\n\n            if column['__col__'].uselist and related_key is None and \\\n                    self.is_root:\n\n                # on r\u00e9cup\u00e8re les objets li\u00e9s\n                key = column['key']\n                related_objects = getattr(obj, key, None)\n                if not related_objects:\n                    return \"\"\n                else:\n                    exporter = self._get_related_exporter(\n                        related_objects[0],\n                        column,\n                    )\n                    for rel_obj in related_objects:\n                        exporter.add_row(rel_obj)\n\n        return val", "response": "Return the value to insert in a relationship cell\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef raster(times, indices, max_time=None, max_index=None, \n           x_label=\"Timestep\", y_label=\"Index\", **kwargs):\n    \"\"\"Plots a raster plot given times and indices of events.\"\"\"\n    # set default size to 1\n    if 's' not in kwargs:\n        kwargs['s'] = 1\n    scatter(times, indices, **kwargs)\n    \n    if max_time is None:\n        max_time = max(times)\n    if max_index is None:\n        max_index = max(indices)\n    axis((0, max_time, 0, max_index))\n    if x_label is not None: xlabel(x_label)\n    if y_label is not None: ylabel(y_label)", "response": "Plots a raster plot given times and indices of events."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query(query):\n    '''\n    Send an ADQL query to the Gaia archive,\n    wait for a response,\n    and hang on to the results.\n    '''\n\n    # send the query to the Gaia archive\n    with warnings.catch_warnings() :\n        warnings.filterwarnings(\"ignore\")\n\n        _gaia_job = astroquery.gaia.Gaia.launch_job(query)\n\n        # return the table of results\n        return _gaia_job.get_results()", "response": "Send an ADQL query to the Gaia archive and return the table of results."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a Constellation object from a cone search of the sky and a characterized center and a radius.", "response": "def from_cone(cls, center,\n                  radius=3*u.arcmin,\n                  magnitudelimit=20,\n                  **kw):\n        '''\n        Create a Constellation from a cone search of the sky,\n        characterized by a positional center and a radius from it.\n\n        Parameters\n        ----------\n        center : SkyCoord object, or str\n            The center around which the query will be made.\n            If a str, SkyCoord will be resolved with coord.SkyCoord.from_name\n        radius : float, with units of angle\n            The angular radius for the query.\n        magnitudelimit : float\n            The maximum magnitude to include in the download.\n            (This is explicitly thinking UV/optical/IR, would\n            need to change to flux to be able to include other\n            wavelengths.)\n        '''\n\n        center = parse_center(center)\n\n        # define a query for cone search surrounding this center\n        conequery = \"\"\"{} WHERE CONTAINS(POINT('ICRS',gaiadr2.gaia_source.ra,gaiadr2.gaia_source.dec),CIRCLE('ICRS',{},{},{}))=1 and phot_g_mean_mag < {}\"\"\".format(cls.basequery, center.ra.deg, center.dec.deg, radius.to(u.deg).value, magnitudelimit)\n        print(conequery)\n\n        # run the query\n        print('querying Gaia DR2, centered on {} with radius {}, for G<{}'.format(center, radius, magnitudelimit))\n        table = query(conequery)\n\n        # store the search parameters in this object\n        c = cls(cls.standardize_table(table))\n        c.standardized.meta['query'] = conequery\n        c.standardized.meta['center'] = center\n        c.standardized.meta['radius'] = radius\n        c.standardized.meta['magnitudelimit'] = magnitudelimit\n        #c.center = center\n        #c.radius = radius\n        #c.magnitudelimit = magnitudelimit\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_sky(cls, distancelimit=15, magnitudelimit=18):\n        '''\n        Create a Constellation from a criteria search of the whole sky.\n\n        Parameters\n        ----------\n        distancelimit : float\n            Maximum distance (parsecs).\n        magnitudelimit : float\n            Maximum magnitude (for Gaia G).\n\n        '''\n\n        # define a query for cone search surrounding this center\n        criteria = []\n        if distancelimit is not None:\n            criteria.append('parallax >= {}'.format(1000.0/distancelimit))\n        if magnitudelimit is not None:\n            criteria.append('phot_g_mean_mag <= {}'.format(magnitudelimit))\n\n        allskyquery = \"\"\"{} WHERE {}\"\"\".format(cls.basequery, ' and '.join(criteria))\n        print(allskyquery)\n\n        # run the query\n        print('querying Gaia DR2, for distance<{} and G<{}'.format(distancelimit, magnitudelimit))\n        table = query(allskyquery)\n\n        # store the search parameters in this object\n        c = cls(cls.standardize_table(table))\n\n        c.standardized.meta['query'] = allskyquery\n        c.standardized.meta['magnitudelimit'] = magnitudelimit\n        c.standardized.meta['distancelimit'] = distancelimit\n\n        #c.distancelimit = distancelimit\n        #c.magnitudelimit = magnitudelimit or c.magnitudelimit\n        return c", "response": "Create a Constellation object from a criteria search of the whole sky."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef standardize_table(cls, table):\n        '''\n        Extract objects from a Gaia DR2 table.\n        '''\n\n\n        # tidy up quantities, setting motions to 0 if poorly defined\n        for key in ['pmra', 'pmdec', 'parallax', 'radial_velocity']:\n            bad = table[key].mask\n            table[key][bad] = 0.0\n\n        bad = table['parallax']/table['parallax_error'] < 1\n        bad += table['parallax'].mask\n        table['parallax'][bad] = np.nan\n        distance = 1000*u.pc/table['parallax'].data\n\n        distance[bad] = 10000*u.pc#np.nanmax(distance)\n        identifiers  = {'GaiaDR2-id':table['source_id']}\n\n        # create skycoord objects\n        coordinates = dict(  ra=table['ra'].data*u.deg,\n                             dec=table['dec'].data*u.deg,\n                             pm_ra_cosdec=table['pmra'].data*u.mas/u.year,\n                             pm_dec=table['pmdec'].data*u.mas/u.year,\n                             radial_velocity=table['radial_velocity'].data*u.km/u.s,\n                             distance=distance, # weirdly, messed with RA + Dec signs if parallax is zero\n                             obstime=cls.epoch*np.ones(len(table))*u.year)#Time(, format='decimalyear'))\n\n        magnitudes = {k+'-mag':table['phot_{}_mean_mag'.format(k.lower())].data for k in cls.filters}\n\n\n        errors = dict(distance= distance*(table['parallax_error'].data/table['parallax'].data),\n                      pm_ra_cosdec=table['pmra_error'].data*u.mas/u.year,\n                      pm_dec=table['pmdec_error'].data*u.mas/u.year,\n                      radial_velocity=table['radial_velocity_error'].data*u.km/u.s)\n\n        error_table = Table(data=[errors[k] for k in cls.error_keys],\n                            names=[k+'-error' for k in cls.error_keys])\n\n\n        #for key in ['pmra', 'pmdec', 'parallax', 'radial_velocity']:\n        #        bad = table[key].mask\n        #        table[key][bad] = 0.0\n\n\n        standardized = hstack([Table(identifiers),\n                               Table(coordinates),\n                               Table(magnitudes),\n                               error_table])\n\n        standardized.meta['catalog'] = 'Gaia'\n\n        return standardized", "response": "Standardize a Gaia DR2 table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(arguments=None):\n    # setup the command-line util settings\n    su = tools(\n        arguments=arguments,\n        docString=__doc__,\n        logLevel=\"DEBUG\",\n        options_first=False,\n        projectName=\"tastic\"\n    )\n    arguments, settings, log, dbConn = su.setup()\n\n    # unpack remaining cl arguments using `exec` to setup the variable names\n    # automatically\n    for arg, val in arguments.iteritems():\n        if arg[0] == \"-\":\n            varname = arg.replace(\"-\", \"\") + \"Flag\"\n        else:\n            varname = arg.replace(\"<\", \"\").replace(\">\", \"\")\n        if varname == \"import\":\n            varname = \"iimport\"\n        if isinstance(val, str) or isinstance(val, unicode):\n            exec(varname + \" = '%s'\" % (val,))\n        else:\n            exec(varname + \" = %s\" % (val,))\n        if arg == \"--dbConn\":\n            dbConn = val\n        log.debug('%s = %s' % (varname, val,))\n\n    ## START LOGGING ##\n    startTime = times.get_now_sql_datetime()\n    log.info(\n        '--- STARTING TO RUN THE cl_utils.py AT %s' %\n        (startTime,))\n\n    if init:\n        from os.path import expanduser\n        home = expanduser(\"~\")\n        filepath = home + \"/.config/tastic/tastic.yaml\"\n        try:\n            cmd = \"\"\"open %(filepath)s\"\"\" % locals()\n            p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n        except:\n            pass\n        try:\n            cmd = \"\"\"start %(filepath)s\"\"\" % locals()\n            p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n        except:\n            pass\n\n    # CALL FUNCTIONS/OBJECTS\n    if sort or archive:\n\n        ws = workspace(\n            log=log,\n            settings=settings,\n            fileOrWorkspacePath=pathToFileOrWorkspace\n        )\n    if sort:\n        ws.sort()\n    if archive:\n        ws.archive_done()\n\n    if sync:\n        tp = syncc(\n            log=log,\n            settings=settings,\n            workspaceRoot=pathToWorkspace,\n            workspaceName=workspaceName,\n            syncFolder=pathToSyncFolder,\n            editorialRootPath=editorialRootPath,\n            includeFileTags=fileTagsFlag\n        )\n        tp.sync()\n\n    if reminders:\n        r = reminderss(\n            log=log,\n            settings=settings\n        )\n        r.import_list(\n            listName=listName,\n            pathToTaskpaperDoc=pathToTaskpaperDoc\n        )\n\n    if \"dbConn\" in locals() and dbConn:\n        dbConn.commit()\n        dbConn.close()\n    ## FINISH LOGGING ##\n    endTime = times.get_now_sql_datetime()\n    runningTime = times.calculate_time_difference(startTime, endTime)\n    log.info('-- FINISHED ATTEMPT TO RUN THE cl_utils.py AT %s (RUNTIME: %s) --' %\n             (endTime, runningTime, ))\n\n    return", "response": "This function is the main function used by the cl_utils. py module."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a chunk of bytes into responses and calls responseReceived for each.", "response": "def dataReceived(self, data):\n        \"\"\"\n        Parses chunks of bytes into responses.\n\n        Whenever a complete response is received, this method extracts its\n        payload and calls L{responseReceived} to process it.\n\n        @param data: A chunk of data representing a (possibly partial) response\n        @type data: C{bytes}\n        \"\"\"\n        size = len(self._buffer) + len(data)\n        if size > self.MAX_LENGTH:\n            self.lengthLimitExceeded(size)\n        self._buffer += data\n\n        start = 0\n        for match in self._pattern.finditer(self._buffer):\n            # The start of the sentinel marks the end of the response.\n            end = match.start()\n            tag = int(match.group(1))\n            self.responseReceived(self._buffer[start:end], tag)\n\n            # Advance start position to the beginning of the next line\n            start = match.end() + 1\n\n        if start:\n            self._buffer = self._buffer[start:]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling when a complete response is received from the server.", "response": "def responseReceived(self, response, tag):\n        \"\"\"\n        Receives some characters of a netstring.\n\n        Whenever a complete response is received, this method calls the\n        deferred associated with it.\n\n        @param response: A complete response generated by exiftool.\n        @type response: C{bytes}\n        @param tag: The tag associated with the response\n        @type tag: C{int}\n        \"\"\"\n        self._queue.pop(tag).callback(response)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes one command to exiftool and returns a deferred which is fired when the command completes.", "response": "def execute(self, *args):\n        \"\"\"\n        Pass one command to exiftool and return a deferred which is fired as\n        soon as the command completes.\n\n        @param *args: Command line arguments passed to exiftool\n        @type *args: C{unicode}\n\n        @rtype: C{Deferred}\n        @return: A deferred whose callback will be invoked when the command\n        completed.\n        \"\"\"\n\n        result = defer.Deferred()\n        if self.connected and not self._stopped:\n            self._tag += 1\n\n            args = tuple(args) + ('-execute{:d}'.format(self._tag), '')\n            safe_args = [fsencode(arg) for arg in args]\n            self.transport.write(b'\\n'.join(safe_args))\n\n            result = defer.Deferred()\n            self._queue[self._tag] = result\n        else:\n            result.errback(error.ConnectionClosed('Not connected to exiftool'))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef loseConnection(self):\n        if self._stopped:\n            result = self._stopped\n        elif self.connected:\n            result = defer.Deferred()\n            self._stopped = result\n            self.transport.write(b'\\n'.join((b'-stay_open', b'False', b'')))\n        else:\n            # Already disconnected.\n            result = defer.succeed(self)\n\n        return result", "response": "Close the connection and terminate exiftool process."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks whether termination was intended and invoke the deferred.", "response": "def connectionLost(self, reason=protocol.connectionDone):\n        \"\"\"\n        Check whether termination was intended and invoke the deferred.\n\n        If the connection terminated unexpectedly, reraise the failure.\n\n        @type reason: L{twisted.python.failure.Failure}\n        \"\"\"\n        self.connected = 0\n\n        for pending in self._queue.values():\n            pending.errback(reason)\n        self._queue.clear()\n\n        if self._stopped:\n            result = self if reason.check(error.ConnectionDone) else reason\n            self._stopped.callback(result)\n            self._stopped = None\n        else:\n            reason.raiseException()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_next_character(code, position, char):\n    end = LineCol(code, *position)\n    while not end.eof and end.char() in WHITESPACE:\n        end.inc()\n\n    if not end.eof and end.char() == char:\n        return end.tuple(), inc_tuple(end.tuple())\n    return None, None", "response": "Find next character and return its first and last positions"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\napply filter to resource", "response": "def apply(self, resource):\n        \"\"\"\n        Apply filter to resource\n        :param resource: Image\n        :return: Image\n        \"\"\"\n        if not isinstance(resource, Image.Image):\n            raise ValueError('Unknown resource format')\n\n        if hasattr(resource, '_getexif'):\n            exif = getattr(resource, '_getexif')()\n            if not exif:\n                return resource\n\n            orientation_key = 274  # cf ExifTags\n            if orientation_key in exif:\n                orientation = exif[orientation_key]\n\n                rotate_values = {\n                    3: 180,\n                    6: 270,\n                    8: 90\n                }\n\n                if orientation in rotate_values:\n                    resource_format = resource.format\n                    resource = resource.rotate(rotate_values[orientation])\n                    resource.format = resource_format\n\n        return resource"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_value(value = None):\n        if isinstance(value, ProjectionParams):\n            return value\n        array = AnyValueArray.from_value(value) if value != None else AnyValueArray()\n        return ProjectionParams(array)", "response": "Converts specified value into a ProjectionParams object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_string(self):\n        builder = \"\"\n\n        index = 0\n        while index < self.__len__():\n            if index > 0:\n                builder = builder + ','\n            builder = builder + super(ProjectionParams, self).__getitem__(index)\n            index = index + 1\n\n        return builder", "response": "Gets a string representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snake_case_backend_name(self):\n        s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', type(self).__name__)\n        return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "response": "CamelCase - > snake_case"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a setting for the given key.", "response": "def get_setting(self, key, default=NOT_SET):\n        \"\"\" Gets a setting for the key.\n\n        :raise KeyError: If the key is not set and default isn't provided.\n        \"\"\"\n        if self._arca is None:\n            raise LazySettingProperty.SettingsNotReady\n        return self._arca.settings.get(*self.get_settings_keys(key), default=default)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hash_file_contents(requirements_option: RequirementsOptions, path: Path) -> str:\n        return hashlib.sha256(path.read_bytes() + bytes(\n            requirements_option.name + arca.__version__, \"utf-8\"\n        )).hexdigest()", "response": "Returns a SHA256 hash of the contents of path combined with the Arca version."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_requirements_information(self, path: Path) -> Tuple[RequirementsOptions, Optional[str]]:\n        if self.pipfile_location is not None:\n            pipfile = path / self.pipfile_location / \"Pipfile\"\n            pipfile_lock = path / self.pipfile_location / \"Pipfile.lock\"\n\n            pipfile_exists = pipfile.exists()\n            pipfile_lock_exists = pipfile_lock.exists()\n\n            if pipfile_exists and pipfile_lock_exists:\n                option = RequirementsOptions.pipfile\n                return option, self.hash_file_contents(option, pipfile_lock)\n            elif pipfile_exists:\n                raise BuildError(\"Only the Pipfile is included in the repository, Arca does not support that.\")\n            elif pipfile_lock_exists:\n                raise BuildError(\"Only the Pipfile.lock file is include in the repository, Arca does not support that.\")\n\n        if self.requirements_location:\n            requirements_file = path / self.requirements_location\n\n            if requirements_file.exists():\n                option = RequirementsOptions.requirements_txt\n                return option, self.hash_file_contents(option, requirements_file)\n\n        return RequirementsOptions.no_requirements, None", "response": "Returns the information needed to install requirements for a repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the name of the task definition file and its contents.", "response": "def serialized_task(self, task: Task) -> Tuple[str, str]:\n        \"\"\" Returns the name of the task definition file and its contents.\n        \"\"\"\n        return f\"{task.hash}.json\", task.json"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting the script and returns the result.", "response": "def run(self, repo: str, branch: str, task: Task, git_repo: Repo, repo_path: Path) -> Result:  # pragma: no cover\n        \"\"\"\n        Executes the script and returns the result.\n\n        Must be implemented by subclasses.\n\n        :param repo: Repo URL\n        :param branch: Branch name\n        :param task: The requested :class:`Task`\n        :param git_repo: A :class:`Repo <git.repo.base.Repo>` of the repo/branch\n        :param repo_path: :class:`Path <pathlib.Path>` to the location where the repo is stored.\n        :return: The output of the task in a :class:`Result` instance.\n        \"\"\"\n        raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_or_create_environment(self, repo: str, branch: str,\n                                  git_repo: Repo, repo_path: Path) -> str:  # pragma: no cover\n        \"\"\"\n        Abstract method which must be implemented in subclasses, which must return a str path to a Python executable\n        which will be used to run the script.\n\n        See :meth:`BaseBackend.run <arca.BaseBackend.run>` to see arguments description.\n        \"\"\"\n        raise NotImplementedError", "response": "Get or create the environment for the given branch."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, repo: str, branch: str, task: Task, git_repo: Repo, repo_path: Path) -> Result:\n        python_path = self.get_or_create_environment(repo, branch, git_repo, repo_path)\n\n        task_filename, task_json = self.serialized_task(task)\n\n        task_path = Path(self._arca.base_dir, \"tasks\", task_filename)\n        task_path.parent.mkdir(parents=True, exist_ok=True)\n        task_path.write_text(task_json)\n\n        logger.info(\"Stored task definition at %s\", task_path)\n\n        out_output = \"\"\n        err_output = \"\"\n\n        cwd = str(repo_path / self.cwd)\n\n        logger.info(\"Running at cwd %s\", cwd)\n\n        try:\n            logger.debug(\"Running with python %s\", python_path)\n\n            process = subprocess.Popen([python_path,\n                                        str(self.RUNNER),\n                                        str(task_path.resolve())],\n                                       stdout=subprocess.PIPE,\n                                       stderr=subprocess.PIPE,\n                                       cwd=cwd)\n\n            try:\n                out_stream, err_stream = process.communicate(timeout=task.timeout)\n            except subprocess.TimeoutExpired:\n                process.kill()\n                raise BuildTimeoutError(f\"The task timeouted after {task.timeout} seconds.\")\n\n            out_output = out_stream.decode(\"utf-8\")\n            err_output = err_stream.decode(\"utf-8\")\n\n            logger.debug(\"stdout output from the command\")\n            logger.debug(out_output)\n\n            return Result(out_output)\n        except BuildError:  # can be raised by  :meth:`Result.__init__` or by timeout\n            raise\n        except Exception as e:\n            logger.exception(e)\n            raise BuildError(\"The build failed\", extra_info={\n                \"exception\": e,\n                \"out_output\": out_output,\n                \"err_output\": err_output,\n            })", "response": "Runs the task using subprocess. Popen."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef quote_names(db, names):\n    c = db.cursor()\n    c.execute(\"SELECT pg_catalog.quote_ident(n) FROM pg_catalog.unnest(%s::text[]) n\", [list(names)])\n    return [name for (name,) in c]", "response": "Quote the given list of identifiers."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute_catch(c, sql, vars=None):\n    try:\n        c.execute(sql, vars)\n    except Exception as err:\n        cmd = sql.split(' ', 1)[0]\n        log.error(\"Error executing %s: %s\", cmd, err)", "response": "Run a query but ignore any errors. For error recovery paths where the error handler should not raise another."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cmd_copy():\n    db = connect()\n\n    if args.force and db_exists(db, args.dest):\n        tmp_db = generate_alt_dbname(db, args.dest, 'tmp')\n        pg_copy(db, args.src, tmp_db)\n\n        pg_move_extended(db, tmp_db, args.dest)\n\n    else:\n        pg_copy(db, args.src, args.dest)", "response": "Copies the current database to the new database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cmd_move(db=None):\n    if db is None:\n        db = connect()\n\n    pg_move_extended(db, args.src, args.dest)", "response": "Rename a database within a server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nkill all active connections to the specified database.", "response": "def cmd_kill():\n    \"\"\"Kills all active connections to the specified database(s).\"\"\"\n    db = connect()\n    count = terminate(db, args.databases)\n    if count == 0:\n        log.error(\"No connections could be killed\")\n        # Return status 1, like killall\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd_reindex():\n    db = connect(args.database)\n    for idx in args.indexes:\n        pg_reindex(db, idx)", "response": "Reindexes the duplicate index for the current node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_argparser():\n\n    if PY2:\n        def unicode_arg(val):\n            return val.decode(sys.getfilesystemencoding() or 'utf8')\n    else:\n        unicode_arg = str\n\n    # Generic options\n    p_main = ArgumentParser()\n    generic = p_main.add_argument_group(\"generic arguments\")\n    generic.add_argument(\"-q\", \"--quiet\",\n                         action='store_true', dest='quiet', default=False,\n                         help=\"silence information messages\")\n    generic.add_argument(\"-f\", \"--force\",\n                         action='store_true', dest='force', default=False,\n                         help=\"Kill connections automatically if they prevent a command from executing. \"\n                              \"Rename existing databases that are in the way.\")\n    generic.add_argument(\"--traceback\", action='store_true', default=False,\n                         help=\"print traceback when an error occurs\")\n    generic.add_argument(\"--host\", metavar=\"HOST\",\n                         help=\"hostname of database server\")\n    generic.add_argument(\"-p\", \"--port\", metavar=\"PORT\", type=int,\n                         help=\"port number of database server\")\n\n    sub = p_main.add_subparsers(metavar=\"COMMAND\", dest='cmd')\n\n    p_cp = sub.add_parser('cp', description=cmd_copy.__doc__,\n                          help=\"Create a copy of a database within a server\")\n    p_mv = sub.add_parser('mv', description=cmd_move.__doc__,\n                          help=\"Rename a database within a server\")\n\n    for p_cmd in (p_cp, p_mv):\n        p_cmd.add_argument('src', metavar=\"SOURCE\", type=unicode_arg,\n                           help=\"source database name\")\n        p_cmd.add_argument('dest', metavar=\"DEST\", type=unicode_arg,\n                           help=\"destination database name\")\n        p_cmd.add_argument(\"--no-backup\",\n                           action='store_true', dest='no_backup', default=False,\n                           help=\"drop existing DEST database if it exists\")\n\n    p_kill = sub.add_parser('kill', description=cmd_kill.__doc__,\n                            help=\"Terminate active connections to a database\")\n    p_kill.add_argument('databases', metavar=\"DBNAME\", type=unicode_arg, nargs='+',\n                        help=\"kill connections on this database\")\n\n    p_reindex = sub.add_parser('reindex', description=cmd_reindex.__doc__,\n                               help=\"Gracefully recreate an index\")\n    p_reindex.add_argument('-d', '--database', metavar=\"DB\", type=unicode_arg,\n                           help=\"apply reindex in this database\")\n    p_reindex.add_argument('indexes', metavar=\"IDXNAME\", type=unicode_arg, nargs='+',\n                           help=\"reindex these indexes\")\n\n    return p_main", "response": "Create an argument parser for the current application."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef align(s1, s2, gap=' ', eq=operator.eq):\n    '''aligns two strings\n\n    >>> print(*align('pharmacy', 'farm\u00e1cia', gap='_'), sep='\\\\n')\n    pharmac_y\n    _farm\u00e1cia\n\n    >>> print(*align('advantage', 'vantagem', gap='_'), sep='\\\\n')\n    advantage_\n    __vantagem\n\n    '''\n    # first we compute the dynamic programming table\n    m, n = len(s1), len(s2)\n    table = []  # the table is extended lazily, one row at a time\n    row = list(range(n+1))  # the first row is 0, 1, 2, ..., n\n    table.append(list(row))  # copy row and insert into table\n    for i in range(m):\n        p = i\n        row[0] = i+1\n        for j in range(n):\n            t = 0 if eq(s1[i], s2[j]) else 1\n            p, row[j+1] = row[j+1], min(p+t, row[j]+1, row[j+1]+1)\n        table.append(list(row))  # copy row and insert into table\n    # now we trace the best alignment path from cell [m][n] to cell [0],[0]\n    s1_, s2_ = '', ''\n\n    i, j = m, n\n    while i != 0 and j != 0:\n        _, i, j, s1_, s2_ = min(\n            (table[i-1][j-1], i-1, j-1, s1[i-1]+s1_, s2[j-1]+s2_),\n            (table[i-1][j], i-1, j, s1[i-1]+s1_, gap+s2_),\n            (table[i][j-1], i, j-1, gap+s1_, s2[j-1]+s2_)\n        )\n    if i != 0:\n        s1_ = s1[:i]+s1_\n        s2_ = gap*i+s2_\n    if j != 0:\n        s1_ = gap*j+s1_\n        s2_ = s2[:j]+s2_\n    return s1_, s2_", "response": "aligns two strings s1 and s2 in a dynamic programming table"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract mismatched segments from aligned strings s1 and s2", "response": "def mismatches(s1, s2, context=0, eq=operator.eq):\n    '''extract mismatched segments from aligned strings\n\n    >>> list(mismatches(*align('pharmacy', 'farm\u00e1cia'), context=1))\n    [('pha', ' fa'), ('mac', 'm\u00e1c'), ('c y', 'cia')]\n\n    >>> list(mismatches(*align('constitution', 'constitui\u00e7\u00e3o'), context=1))\n    [('ution', 'ui\u00e7\u00e3o')]\n\n    >>> list(mismatches(*align('idea', 'ideia'), context=1))\n    [('e a', 'eia')]\n\n    >>> list(mismatches(*align('instructed', 'instru\u00eddo'), context=1))\n    [('ucted', 'u \u00eddo')]\n\n    >>> list(mismatches(*align('concluded', 'conclu\u00eddo'), context=1))\n    [('uded', 'u\u00eddo')]\n    '''\n    n = len(s1)\n    assert(len(s2) == n)\n    lct, rct = context, context if isinstance(context, int) else context\n    i = None\n    for j in range(n):\n        if eq(s1[j], s2[j]):\n            if i is not None:\n                # report mismatch segment [i:j] with lct chars of left context\n                # and rct chars of right context\n                p, q = max(0, i-lct), min(j+rct, n)\n                yield s1[p:q], s2[p:q]\n                i = None\n        elif i is None:\n                i = j\n    if i is not None:\n        p = max(i-lct, 0)\n        yield s1[p:], s2[p:]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds connection and init it", "response": "def _init():\n    \"\"\" build connection and init it\"\"\"\n    connection.connect()\n\n    # start track\n    # all services were provided here:\n    # https://android.googlesource.com/platform/system/core/+/jb-dev/adb/SERVICES.TXT\n    ready_data = utils.encode_data('host:track-devices')\n    connection.adb_socket.send(ready_data)\n\n    # get status\n    status = connection.adb_socket.recv(4)\n\n    # make sure track is ready\n    if status != b'OKAY':\n        raise RuntimeError('adb server return \"{}\", not OKAY'.format(str(status)))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_comment_group_for_path(self, pathname, default_content_type=None):\n        content_type = self.guess_content_type(pathname)\n        if not content_type:\n            # Content type is not found.\n            if default_content_type:\n                content_type = default_content_type\n                return self.get_comment_group(content_type)\n            else:\n                raise ValueError(\n                    \"No content type defined for file path: %s\" % pathname)\n        else:\n            try:\n                return self.get_comment_group(content_type)\n            except KeyError:\n                raise KeyError(\n                    \"No comment groups for content type `%s` for file `%s` found\" % (\n                    content_type, pathname))", "response": "Returns the comment group for a specified pathname."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_config_file(self, config_filename):\n        with open(config_filename, 'rb') as f:\n            content = f.read()\n            config = yaml.load(content)\n            self.add_config(config, config_filename)", "response": "Adds the content. types file to the content types database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the given configuration dictionary to the content types database.", "response": "def add_config(self, config, config_filename):\n        \"\"\"\n        Updates the content types database with the given configuration.\n\n        :param config:\n            The configuration dictionary.\n        :param config_filename:\n            The path of the configuration file.\n        \"\"\"\n        content_types = config['content-types']\n        comment_groups = config['comment-groups']\n\n        self._comment_groups.update(comment_groups)\n        self._content_types.update(content_types)\n\n        for content_type, patterns in content_types.iteritems():\n            if not patterns:\n                raise ValueError('''error: config parse error: \\\n%s: Missing pattern for content type - `%s`\"''' % (config_file, content_type))\n            for pattern in patterns:\n                first_character = pattern[0]\n                last_character = pattern[-1]\n                if first_character == '.':\n                    # Extension map.\n                    pattern = extension_case_transform_func(pattern)\n                    self._extension_map[pattern] = content_type\n                elif first_character == '/' and last_character == '/':\n                    # Regular expression map.\n                    self._regexp_map[re.compile(pattern[1:-1])] = content_type\n                else:\n                    # Filename map.\n                    self._filename_map[pattern] = content_type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef guess_content_type(self, pathname):\n        file_basename = os.path.basename(pathname)\n        content_type = None\n\n        # Try to determine from the path.\n        if not content_type and self._filename_map.has_key(file_basename):\n            content_type = self._filename_map[file_basename]\n            #logger.debug(\"Content type of '%s' is '%s' (determined from full \"\\\n            #             \"path).\", pathname, content_type)\n\n        # Try to determine from the suffix.\n        if not content_type and '.' in file_basename:\n            extension = \".\" + file_basename.split(\".\")[-1]\n            extension = extension_case_transform_func(extension)\n            try:\n                content_type = self._extension_map[extension]\n                #logger.debug(\"Content type of '%s' is '%s' (determined from \"\\\n                #             \"suffix '%s').\", pathname, content_type, extension)\n            except KeyError:\n                pass\n\n        # Try to determine from the registered set of regular expression patterns.\n        if not content_type:\n            for regexp, _content_type in self._regexp_map.iteritems():\n                if regexp.search(file_basename):\n                    content_type = _content_type\n                    #logger.debug(\n                    #    \"Content type of '%s' is '%s' (matches regexp '%s')\",\n                    #    pathname, content_type, regexp.pattern)\n                    break\n\n        # Try to determine from the file contents.\n        if os.path.exists(pathname):\n            with open(pathname, 'rb') as f:\n                content = f.read()\n                if content.startswith(\"<?xml\"):  # cheap XML sniffing\n                    content_type = \"XML\"\n\n        # TODO: Try to determine from mime-type.\n\n        return content_type", "response": "Guess the content type for the given path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect():\n    global adb_socket\n    if adb_socket is not None:\n        raise RuntimeError('connection already existed')\n\n    host, port = config.HOST, config.PORT\n\n    connection = socket.socket()\n    try:\n        connection.connect((host, port))\n    except ConnectionError as _:\n        warn_msg = 'failed when connecting to adb server: {}:{}, retrying ...'.format(host, port)\n        warnings.warn(warn_msg)\n        reboot_adb_server()\n        connect()\n        return\n\n    adb_socket = connection", "response": "create socket and connect to adb server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reboot_adb_server():\n    _reboot_count = 0\n    _max_retry = 1\n\n    def _reboot():\n        nonlocal _reboot_count\n        if _reboot_count >= _max_retry:\n            raise RuntimeError('fail after retry {} times'.format(_max_retry))\n        _reboot_count += 1\n\n        return_code = subprocess.call(['adb', 'devices'], stdout=subprocess.DEVNULL)\n        if bool(return_code):\n            warnings.warn('return not zero, execute \"adb version\" failed')\n            raise EnvironmentError('adb did not work :(')\n\n    return _reboot", "response": "execute adb devices to start adb server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_via_name_list(src, name_parts):\n    if len(name_parts) > 1:\n        for part in name_parts[:-1]:\n            if part not in src:\n                return None\n            src = src[part]\n    return src.get(name_parts[-1])", "response": "Get a name sequence from a dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_to_name_list(dest, name_parts, value):\n    if len(name_parts) > 1:\n        for part in name_parts[:-1]:\n            if part not in dest:\n                dest[part] = {}\n            dest = dest[part]\n    dest[name_parts[-1]] = value", "response": "Save some name sequence to a dict."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the provided button is pressed False otherwise.", "response": "def is_pressed(self, button):\n        \"\"\"Return True if the provided button is pressed, False otherwise.\"\"\"\n        if button not in set((SELECT, RIGHT, DOWN, UP, LEFT)):\n            raise ValueError('Unknown button, must be SELECT, RIGHT, DOWN, UP, or LEFT.')\n        return self._mcp.get(button)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a string to its S - expression representation adding quotes and escaping funny characters.", "response": "def escape_string(value):\n    \"\"\"Converts a string to its S-expression representation, adding quotes\n    and escaping funny characters.\n    \"\"\"\n    res = StringIO()\n    res.write('\"')\n    for c in value:\n        if c in CHAR_TO_ESCAPE:\n            res.write(f'\\\\{CHAR_TO_ESCAPE[c]}')\n        elif c.isprintable():\n            res.write(c)\n        elif ord(c) < 0x100:\n            res.write(f'\\\\x{ord(c):02x}')\n        elif ord(c) < 0x10000:\n            res.write(f'\\\\u{ord(c):04x}')\n        else:\n            res.write(f'\\\\U{ord(c):06x}')\n    res.write('\"')\n    return res.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms a comparison operation over two values of type string.", "response": "def compare(value1, operation, value2):\n        \"\"\"\n        Perform comparison operation over two arguments.\n        The operation can be performed over values of any type.\n\n        :param value1: the first argument to compare\n\n        :param operation: the comparison operation: \"==\" (\"=\", \"EQ\"), \"!= \" (\"<>\", \"NE\"); \"<\"/\">\"\n                                                    (\"LT\"/\"GT\"), \"<=\"/\">=\" (\"LE\"/\"GE\"); \"LIKE\".\n\n        :param value2: the second argument to compare\n\n        :return: result of the comparison operation\n        \"\"\"\n        if operation == None:\n            return False\n        \n        operation = operation.upper()\n\n        if operation in [\"=\", \"==\", \"EQ\"]:\n            return ObjectComparator.are_equal(value1, value2)\n        if operation in [\"!=\", \"<>\", \"NE\"]:\n            return ObjectComparator.are_not_equal(value1, value2)\n        if operation in [\"<\", \"LT\"]:\n            return ObjectComparator.less(value1, value2)\n        if operation in [\"<=\", \"LE\"]:\n            return ObjectComparator.are_equal(value1, value2) or ObjectComparator.less(value1, value2)\n        if operation in [\">\", \"GT\"]:\n            return ObjectComparator.more(value1, value2)\n        if operation in [\">=\", \"GE\"]:\n            return ObjectComparator.are_equal(value1, value2) or ObjectComparator.more(value1, value2)\n        if operation == \"LIKE\":\n            return ObjectComparator.match(value1, value2)\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if two values are equal.", "response": "def are_equal(value1, value2):\n        \"\"\"\n        Checks if two values are equal. The operation can be performed over values of any type.\n\n        :param value1: the first value to compare\n\n        :param value2: the second value to compare\n\n        :return: true if values are equal and false otherwise\n        \"\"\"\n        if value1 == None or value2 == None:\n            return True\n        if value1 == None or value2 == None:\n            return False\n        return value1 == value2"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if the first value is less than the second value.", "response": "def less(value1, value2):\n        \"\"\"\n        Checks if first value is less than the second one.\n        The operation can be performed over numbers or strings.\n\n        :param value1: the first value to compare\n\n        :param value2: the second value to compare\n\n        :return: true if the first value is less than second and false otherwise.\n        \"\"\"\n        number1 = FloatConverter.to_nullable_float(value1)\n        number2 = FloatConverter.to_nullable_float(value2)\n\n        if number1 == None or number2 == None:\n            return False\n\n        return number1 < number2"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef more(value1, value2):\n        number1 = FloatConverter.to_nullable_float(value1)\n        number2 = FloatConverter.to_nullable_float(value2)\n\n        if number1 == None or number2 == None:\n            return False\n\n        return number1 > number2", "response": "Checks if first value is greater than second value."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if a string value matches a regular expression", "response": "def match(value1, value2):\n        \"\"\"\n        Checks if string matches a regular expression\n\n        :param value1: a string value to match\n\n        :param value2: a regular expression string\n\n        :return: true if the value matches regular expression and false otherwise.\n        \"\"\"\n        if value1 == None and value2 == None:\n            return True\n        if value1 == None or value2 == None:\n            return False\n\n        string1 = str(value1)\n        string2 = str(value2)\n        return re.match(string2, string1) != None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_view(self, view):\n        self.view.set_text(self.model.credits)\n        gobject.timeout_add(1500, self.on_begin_scroll)\n        return", "response": "Loads the credits from the model then starts a\n        timer to scroll it."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls to scroll text", "response": "def on_scroll(self):\n        \"\"\"Called to scroll text\"\"\"\n        try:\n            sw = self.view['sw_scroller']\n        except KeyError:\n            return False # destroyed!        \n        vadj = sw.get_vadjustment()\n        if vadj is None: return False\n        val = vadj.get_value()\n        \n        # is scrolling over?\n        if val >= vadj.upper - vadj.page_size:\n            self.view.show_vscrollbar()\n            return False\n        \n        vadj.set_value(val+0.5)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the radio buttons for counter selection and sets up the progress bar.", "response": "def setup_content(self, names, max_value):\n        \"\"\"Creates the radio buttons for counter selection, and sets\n        up the progress bar.\n        \n        @param names is an iterable of strings for the names of counters.\n        @param max_value is the maximum value used to set the progress bar.\n\n        This method is called by controllers, when connected model is\n        available.\n        \"\"\"\n\n        # radio buttons\n        box = self['vbox_rb']\n        group = None        \n        for name in names:\n            if 'rb_'+name in self: continue # skip already created names\n            \n            rb = gtk.RadioButton(group, name)\n            self['rb_'+name] = rb\n            rb.set_visible(True)\n            box.pack_start(rb, expand=False)\n            group = group or rb\n            pass\n\n        # progress bar:\n        self['adjustment_counter'].set_upper(max_value)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves details for a specific Token.", "response": "def retrieve_token(self, token):\n        \"\"\"\n        Retrieve Token details for a specific Token.\n\n        Args:\n            token: The identifier of the token.\n\n\n        Returns:\n\n        \"\"\"\n        headers = self.client._get_private_headers()\n        endpoint = '/tokens/{}'.format(token)\n        return self.client._get(self.client.URL_BASE + endpoint, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _as_classification(classification, queryset, field, nclasses, geofield='geom', \n    propertyname=None, userstyletitle=None, featuretypestylename=None, colorbrewername='',\n    invertgradient=False, **kwargs):\n    \"\"\"\n    Accept a queryset of objects, and return the values of the class breaks \n    on the data distribution. If the queryset is empty, no class breaks are\n    computed.\n\n    @type  classification: pysal classifier\n    @param classification: A classification class defined in \n        pysal.esda.mapclassify. As of version 1.0.1, this list is comprised of:\n\n          - Equal_Interval\n          - Fisher_Jenks\n          - Jenks_Caspall\n          - Jenks_Caspall_Forced\n          - Jenks_Caspall_Sampled\n          - Max_P_Classifier\n          - Maximum_Breaks\n          - Natural_Breaks\n          - Quantiles\n\n    @type  queryset: QuerySet\n    @param queryset: The query set that contains the entire distribution of data values.\n    @type     field: string\n    @param    field: The name of the field on the model in the queryset that contains the data values.\n    @type  nclasses: integer\n    @param nclasses: The number of class breaks desired.\n    @type  geofield: string\n    @keyword geofield: The name of the geography column on the model. Defaults to 'geom'\n    @type  propertyname: string\n    @keyword propertyname: The name of the filter property name, if different from the model field.\n    @type  userstyletitle: string\n    @keyword userstyletitle: The title of the UserStyle element.\n    @type  featuretypestylename: string\n    @keyword featuretypestylename: The name of the FeatureTypeStyle element.\n    @type    colorbrewername: string\n    @keyword colorbrewername: The name of a colorbrewer ramp name. Must have the same # of corresponding classes as nclasses.\n    @type    invertgradient: boolean\n    @keyword invertgradient: Should the resulting SLD have colors from high to low, instead of low to high?\n    @type    kwargs: keywords\n    @param   kwargs: Additional keyword arguments for the classifier.\n    @rtype: L{sld.StyledLayerDescriptor}\n    @returns: An SLD class object that represents the classification scheme \n        and filters.\n    \"\"\"\n    thesld = StyledLayerDescriptor()\n\n    ftype = queryset.model._meta.get_field_by_name(geofield)[0]\n    if isinstance(ftype, fields.LineStringField) or isinstance(ftype, fields.MultiLineStringField):\n        symbolizer = LineSymbolizer\n    elif isinstance(ftype, fields.PolygonField) or isinstance(ftype, fields.MultiPolygonField):\n        symbolizer = PolygonSymbolizer\n    else:\n        # PointField, MultiPointField, GeometryField, or GeometryCollectionField\n        symbolizer = PointSymbolizer\n\n    if propertyname is None:\n        propertyname = field\n\n    nl = thesld.create_namedlayer('%d breaks on \"%s\" as %s' % (nclasses, field, classification.__name__))\n    us = nl.create_userstyle()\n    if not userstyletitle is None:\n        us.Title = str(userstyletitle)\n    fts = us.create_featuretypestyle()\n    if not featuretypestylename is None:\n        fts.Name = str(featuretypestylename)\n\n    # with just one class, make a single static style with no filters\n    if nclasses == 1:\n        rule = fts.create_rule(propertyname, symbolizer=symbolizer)\n        shade = 0 if invertgradient else 255\n        shade = '#%02x%02x%02x' % (shade, shade, shade,)\n\n        # no filters for one class\n        if symbolizer == PointSymbolizer:\n            rule.PointSymbolizer.Graphic.Mark.Fill.CssParameters[0].Value = shade\n        elif symbolizer == LineSymbolizer:\n            rule.LineSymbolizer.Stroke.CssParameters[0].Value = shade\n        elif symbolizer == PolygonSymbolizer:\n            rule.PolygonSymbolizer.Stroke.CssParameters[0].Value = '#000000'\n            rule.PolygonSymbolizer.Fill.CssParameters[0].Value = shade\n\n        thesld.normalize()\n\n        return thesld\n\n    # with more than one class, perform classification\n    datavalues = array(queryset.order_by(field).values_list(field, flat=True))\n    q = classification(datavalues, nclasses, **kwargs)\n\n    shades = None\n    if q.k == nclasses and colorbrewername and not colorbrewername == '':\n        try:\n            import colorbrewer\n            shades = getattr(colorbrewer, colorbrewername)[nclasses]\n\n            if invertgradient:\n                shades.reverse()\n        except:\n            # could not import colorbrewer, or nclasses unavailable\n            pass\n\n    for i,qbin in enumerate(q.bins):\n        if type(qbin) == ndarray:\n            qbin = qbin[0]\n\n        title = '<= %s' % qbin\n        rule = fts.create_rule(title, symbolizer=symbolizer)\n\n        if shades:\n            shade = '#%02x%02x%02x' % shades[i]\n        else:\n            shade = (float(q.k - i) / q.k ) * 255\n            if invertgradient:\n                shade = 255 - shade\n            shade = '#%02x%02x%02x' % (shade, shade, shade,)\n\n        if symbolizer == PointSymbolizer:\n            rule.PointSymbolizer.Graphic.Mark.Fill.CssParameters[0].Value = shade\n        elif symbolizer == LineSymbolizer:\n            rule.LineSymbolizer.Stroke.CssParameters[0].Value = shade\n        elif symbolizer == PolygonSymbolizer:\n            rule.PolygonSymbolizer.Stroke.CssParameters[0].Value = '#000000'\n            rule.PolygonSymbolizer.Fill.CssParameters[0].Value = shade\n\n        # now add the filters\n        if i > 0:\n            f_low = Filter(rule)\n            f_low.PropertyIsGreaterThan = PropertyCriterion(f_low, 'PropertyIsGreaterThan')\n            f_low.PropertyIsGreaterThan.PropertyName = propertyname\n            f_low.PropertyIsGreaterThan.Literal = str(q.bins[i-1])\n\n        f_high = Filter(rule)\n        f_high.PropertyIsLessThanOrEqualTo = PropertyCriterion(f_high, 'PropertyIsLessThanOrEqualTo')\n        f_high.PropertyIsLessThanOrEqualTo.PropertyName = propertyname\n        f_high.PropertyIsLessThanOrEqualTo.Literal = str(qbin)\n\n       \n        if i > 0:\n            rule.Filter = f_low + f_high\n        else:\n            rule.Filter = f_high\n           \n    thesld.normalize()\n\n    return thesld", "response": "Returns a list of objects that are of the specified class breaks."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prj_created_data(project, role):\n    if role == QtCore.Qt.DisplayRole:\n        return project.date_created.isoformat(' ')", "response": "Return the data for the created\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prj_fps_data(project, role):\n    if role == QtCore.Qt.DisplayRole:\n        return str(project.framerate)", "response": "Return the data for the fps\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef prj_resolution_data(project, role):\n    if role == QtCore.Qt.DisplayRole:\n        return '%s x %s' % (project.resx, project.resy)", "response": "Return the data for the resolution of the item"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the data for the duration of the item in the given role", "response": "def shot_duration_data(shot, role):\n    \"\"\"Return the data for duration\n\n    :param shot: the shot that holds the data\n    :type shot: :class:`jukeboxcore.djadapter.models.Shot`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the duration\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    if role == QtCore.Qt.DisplayRole:\n        return str(shot.duration)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shot_start_data(shot, role):\n    if role == QtCore.Qt.DisplayRole:\n        return str(shot.startframe)", "response": "Return the data for the startframe of the item"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef shot_end_data(shot, role):\n    if role == QtCore.Qt.DisplayRole:\n        return str(shot.endframe)", "response": "Return the data for the endframe of the item"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef taskfile_path_data(file_, role):\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return file_.path", "response": "Return the data for the path\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef taskfile_user_data(file_, role):\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return file_.user.username", "response": "Return the data for the user in the taskfile"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef taskfile_created_data(file_, role):\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        dt = file_.date_created\n        return dt_to_qdatetime(dt)", "response": "Return the data for the created date\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef taskfile_updated_data(file_, role):\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        dt = file_.date_updated\n        return dt_to_qdatetime(dt)", "response": "Return the data for the updated date\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the data for the content of the given note", "response": "def note_content_data(note, role):\n    \"\"\"Return the data for content\n\n    :param note: the note that holds the data\n    :type note: :class:`jukeboxcore.djadapter.models.Note`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the created date\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return note.content"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the data for the user in the order they belong to", "response": "def note_user_data(note, role):\n    \"\"\"Return the data for user\n\n    :param note: the note that holds the data\n    :type note: :class:`jukeboxcore.djadapter.models.Note`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the created date\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return note.user.username"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef note_created_data(note, role):\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        dt = note.date_created\n        return dt_to_qdatetime(dt)", "response": "Return the data for the created date\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef note_updated_data(note, role):\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        dt = note.date_updated\n        return dt_to_qdatetime(dt)", "response": "Return the data for the updated date\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the data for the specified column and role", "response": "def data(self, column, role):\n        \"\"\"Return the data for the specified column and role\n\n        The column addresses one attribute of the data.\n\n        :param column: the data column\n        :type column: int\n        :param role: the data role\n        :type role: QtCore.Qt.ItemDataRole\n        :returns: data depending on the role\n        :rtype:\n        :raises: None\n        \"\"\"\n        return self.columns[column](self._project, role)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the data for the specified column and role", "response": "def data(self, column, role):\n        \"\"\"Return the data for the specified column and role\n\n        The column addresses one attribute of the data.\n\n        :param column: the data column\n        :type column: int\n        :param role: the data role\n        :type role: QtCore.Qt.ItemDataRole\n        :returns: data depending on the role\n        :rtype:\n        :raises: None\n        \"\"\"\n        return self.columns[column](self._sequence, role)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the data for the specified column and role", "response": "def data(self, column, role):\n        \"\"\"Return the data for the specified column and role\n\n        The column addresses one attribute of the data.\n\n        :param column: the data column\n        :type column: int\n        :param role: the data role\n        :type role: QtCore.Qt.ItemDataRole\n        :returns: data depending on the role\n        :rtype:\n        :raises: None\n        \"\"\"\n        return self.columns[column](self._shot, role)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data(self, column, role):\n        return self.columns[column](self._task, role)", "response": "Return the data for the specified column and role"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef data(self, column, role):\n        return self.columns[column](self._taskfile, role)", "response": "Return the data for the specified column and role"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data(self, column, role):\n        return self.columns[column](self._atype, role)", "response": "Return the data for the specified column and role"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef data(self, column, role):\n        return self.columns[column](self._asset, role)", "response": "Return the data for the specified column and role"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef data(self, column, role):\n        return self.columns[column](self._note, role)", "response": "Return the data for the specified column and role"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the data for the specified column and role", "response": "def data(self, column, role):\n        \"\"\"Return the data for the specified column and role\n\n        The column addresses one attribute of the data.\n\n        :param column: the data column\n        :type column: int\n        :param role: the data role\n        :type role: QtCore.Qt.ItemDataRole\n        :returns: data depending on the role\n        :rtype:\n        :raises: None\n        \"\"\"\n        return self.columns[column](self._user, role)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the data for the specified column and role", "response": "def data(self, column, role):\n        \"\"\"Return the data for the specified column and role\n\n        The column addresses one attribute of the data.\n\n        :param column: the data column\n        :type column: int\n        :param role: the data role\n        :type role: QtCore.Qt.ItemDataRole\n        :returns: data depending on the role\n        :rtype:\n        :raises: None\n        \"\"\"\n        return self.columns[column](self._Department, role)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_adapter(widget_class, signal_name, getter, setter, value_type,\n                flavour=None):\n    \"\"\"This function can be used to extend at runtime the set of\n    default adapters. If given widget class which is being added is\n    already in the default set, it will be substituted by the new one\n    until the next removal (see remove_adapter).\n\n    @param flavour can be used to differentiate otherwise identical\n    entries (None for no flavour).\"\"\"\n\n    new_tu = (widget_class, signal_name, getter, setter,\n              value_type, flavour)\n    for it,tu in enumerate(__def_adapter):\n        if issubclass(tu[WIDGET], widget_class):\n            # found an insertion point, iteration is over after inserting\n            __def_adapter.insert(it, new_tu)\n            return\n\n    # simply append it\n    __def_adapter.append(new_tu)", "response": "This function is used to add a new widget class to the set of available default adapters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the given widget class information from the default set of adapters.", "response": "def remove_adapter(widget_class, flavour=None):\n    \"\"\"Removes the given widget class information from the default set\n    of adapters.\n\n    If widget_class had been previously added by using add_adapter,\n    the added adapter will be removed, restoring possibly previusly\n    existing adapter(s). Notice that this function will remove only\n    *one* adapter about given wiget_class (the first found in order),\n    even if many are currently stored.\n\n    @param flavour has to be used when the entry was added with a\n    particular flavour.\n\n    Returns True if one adapter was removed, False if no adapter was\n    removed.\"\"\"\n    for it,tu in enumerate(__def_adapter):\n        if (widget_class == tu[WIDGET] and flavour == tu[FLAVOUR]):\n            del __def_adapter[it]\n            return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef search_adapter_info(wid, flavour=None):\n    t = (type(wid), flavour)\n    if t in __memoize__:\n        return __memoize__[t]\n\n    for w in __def_adapter:\n        if (isinstance(wid, w[WIDGET]) and flavour == w[FLAVOUR]):\n            __memoize__[t] = w\n            return w\n\n    raise TypeError(\"Adapter type \" + str(t) + \" not found among supported adapters\")", "response": "Given a widget returns the default tuple found in __def_adapter."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_model(self, model):\n        if self.model:\n            self.model.unregister_observer(self)\n        self.model = model\n        if self.model:\n            self.model.register_observer(self)\n            self.model_notification()\n        else:\n            self.set_widget(None)\n        self.widget.set_sensitive(bool(self.model))", "response": "Sets the model of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a map element specified by its key.", "response": "def get(self, key):\n        \"\"\"\n        Gets a map element specified by its key.\n\n        The key can be defined using dot notation\n        and allows to recursively access elements of elements.\n\n        :param key: a key of the element to get.\n\n        :return: the value of the map element.\n        \"\"\"\n        if key == None or key == '':\n            return None\n        elif key.find('.') > 0:\n            return RecursiveObjectReader.get_property(self, key)\n        else:\n            return super(Parameters, self).get(key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put(self, key, value):\n        if key == None or key == '':\n            return None\n        elif key.find('.') > 0:\n            RecursiveObjectWriter.set_property(self, key, value)\n            return value\n        else:\n            self[key] = value\n            return value", "response": "Put a new value into a map element specified by its key."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts map element into an Parameters or returns null if conversion is not possible.", "response": "def get_as_nullable_parameters(self, key):\n        \"\"\"\n        Converts map element into an Parameters or returns null if conversion is not possible.\n\n        :param key: a key of element to get.\n\n        :return: Parameters value of the element or null if conversion is not supported.\n        \"\"\"\n        value = self.get_as_nullable_map(key)\n        return Parameters(value) if value != None else None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_as_parameters_with_default(self, key, default_value):\n        result = self.get_as_nullable_parameters(key)\n        return result if result != None else default_value", "response": "Converts map element into an Parameters or returns default value if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef override(self, parameters, recursive = False):\n        result = Parameters()\n\n        if recursive:\n            RecursiveObjectWriter.copy_properties(result, self)\n            RecursiveObjectWriter.copy_properties(result, parameters)\n        else:\n            ObjectWriter.set_properties(result, self)\n            ObjectWriter.set_properties(result, parameters)\n\n        return result", "response": "Overrides parameters with new values from specified Parameters and returns a new Parameters object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_defaults(self, default_values, recursive = False):\n        result = Parameters()\n\n        if recursive:\n            RecursiveObjectWriter.copy_properties(result, default_values)\n            RecursiveObjectWriter.copy_properties(result, self)\n        else:\n            ObjectWriter.set_properties(result, default_values)\n            ObjectWriter.set_properties(result, self)\n\n        return result", "response": "Set default values from specified Parameters and returns a new Parameters object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef assign_to(self, value):\n        if value == None or len(self) == 0:\n            return\n\n        RecursiveObjectWriter.copy_properties(value, self)", "response": "Assigns properties from the specified value to this map."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npicking parameters from this Parameters and returns them as a new Parameters object.", "response": "def pick(self, *props):\n        \"\"\"\n        Picks select parameters from this Parameters and returns them as a new Parameters object.\n\n        :param props: keys to be picked and copied over to new Parameters.\n\n        :return: a new Parameters object.\n        \"\"\"\n        result = Parameters()\n        for prop in props:\n            if self.contains_key(prop):\n                result.put(prop, self.get(prop))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef omit(self, *props):\n        result = Parameters(self)\n        for prop in props:\n            del result[prop]\n        return result", "response": "Returns a new Parameters object with selected parameters removed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new Parameters object filled with key - value pairs from specified object.", "response": "def from_value(value):\n        \"\"\"\n        Creates a new Parameters object filled with key-value pairs from specified object.\n\n        :param value: an object with key-value pairs used to initialize a new Parameters.\n\n        :return: a new Parameters object.\n        \"\"\"\n        map = value if isinstance(value, dict) else RecursiveObjectReader.get_properties(value)\n        return Parameters(map)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_config(config):\n        result = Parameters()\n        \n        if config == None or len(config) == 0:\n            return result\n        \n        for (key, value) in config.items():\n            result.put(key, value)\n        \n        return result", "response": "Creates a new Parameters object from a ConfigMap object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating treeview columns and connects missing signals", "response": "def register_view(self, view):\n        \"\"\"Creates treeview columns, and connect missing signals\"\"\"\n\n        # if stand-alone, connects the window delete event to\n        # kill the loop\n        if self.view.is_stand_alone():\n            import gtk\n            self.view.get_top_widget().connect('delete-event',\n                 lambda w,e: gtk.main_quit())\n            pass\n        \n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute one specific component.", "response": "def execute_one(correlation_id, component, args):\n        \"\"\"\n        Executes specific component.\n        To be executed components must implement [[IExecutable]] interface.\n        If they don't the call to this method has no effect.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param component: the component that is to be executed.\n\n        :param args: execution arguments.\n\n        :return: execution result\n        \"\"\"\n        if isinstance(component, IExecutable):\n            return component.execute(correlation_id, args)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute multiple components. To be executed components must implement [[IExecutable]] interface. If they don't the call to this method has no effect. :param correlation_id: (optional) transaction id to trace execution through call chain. :param components: a list of components that are to be executed. :param args: execution arguments. :return: execution result", "response": "def execute(correlation_id, components, args = None):\n        \"\"\"\n        Executes multiple components.\n\n        To be executed components must implement [[IExecutable]] interface.\n        If they don't the call to this method has no effect.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param components: a list of components that are to be executed.\n\n        :param args: execution arguments.\n\n        :return: execution result\n        \"\"\"\n        results = []\n\n        if components == None:\n            return\n\n        args = args if args != None else Parameters()\n        for component in components:\n            result = Executor.execute_one(correlation_id, component, args)\n            results.append(result)\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decorator(func):\n\n        def function_timer(*args, **kwargs):\n            \"\"\"A nested function for timing other functions.\"\"\"\n            # Capture start time\n            start = time.time()\n\n            # Execute function with arguments\n            value = func(*args, **kwargs)\n\n            # Capture end time\n            end = time.time()\n\n            # Calculate run time\n            runtime = end - start\n            if runtime < 60:\n                runtime = str('sec: ' + str('{:f}'.format(runtime)))\n            else:\n                runtime = str('min: ' + str('{:f}'.format(runtime / 60)))\n            print('{func:50} --> {time}'.format(func=func.__qualname__, time=runtime))\n            return value\n\n        return function_timer", "response": "A function timer decorator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a per - thread global batcher instance.", "response": "def global_instance(cls):\n        \"\"\"Return a per-thread global batcher instance.\"\"\"\n        try:\n            return GLOBAL_BATCHER.instance\n        except AttributeError:\n\n            instance = PrioritizedBatcher(\n                **getattr(settings, 'PRIORITIZED_BATCHER', {})\n            )\n            GLOBAL_BATCHER.instance = instance\n            return instance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, name, handler, group_by=None, aggregator=None):\n        assert self.batch is not None, \"No active batch, call start() first\"\n\n        items = self.batch.setdefault(name, collections.OrderedDict())\n        if group_by is None:\n            # None is special as it means no grouping. In this case we must store all\n            # the different handlers and call them all.\n            items.setdefault(group_by, []).append((None, handler))\n        elif aggregator is not None:\n            agg = items.get(group_by, [(None, None)])[0][0]\n            items[group_by] = [(aggregator(agg), handler)]\n        else:\n            items[group_by] = [(None, handler)]", "response": "Add a new handler to the current batch."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_all_taskpaper_files(\n            self,\n            workspaceRoot):\n        \"\"\"*get a list of all the taskpaper filepaths in the workspace (excluding the sync directory)*\n\n        **Key Arguments:**\n            - ``workspaceRoot`` -- path to the root folder of a workspace containing taskpaper files\n\n        **Return:**\n            - ``taskpaperFiles`` -- a list of paths to all the taskpaper files within the workspace\n        \"\"\"\n        self.log.info('starting the ``_get_all_taskpaper_files`` method')\n\n        theseFiles = recursive_directory_listing(\n            log=self.log,\n            baseFolderPath=self.workspaceRoot,\n            whatToList=\"files\"  # all | files | dirs\n        )\n\n        taskpaperFiles = []\n        taskpaperFiles[:] = [f for f in theseFiles if os.path.splitext(f)[\n            1] == \".taskpaper\" and self.syncFolder not in f]\n\n        self.log.info('completed the ``_get_all_taskpaper_files`` method')\n        return taskpaperFiles", "response": "get all the taskpaper files in the workspace"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_tagged_content_from_taskpaper_files(\n            self,\n            taskpaperFiles,\n            tagSet,\n            editorial=False,\n            workflowTagSet=False,\n            includeFileTags=True):\n        \"\"\"*get all tasks tagged with a sync-tag from taskpaper files*\n\n        **Key Arguments:**\n            - ``taskpaperFiles`` -- paths to all taskpaper files in workspace\n            - ``tagSet`` -- the tagset to extract from the taskpaper files.\n            - ``editorial`` -- format links for editorial ios apps\n            - ``workflowTagSet`` -- does the tag set contain workflow tags (if not skip the non-live project lists)\n            - ``includeFileTags`` -- if the tag is in the filepath (e.g. /@due/mytasks.taskpaper) include all items the file in that tag set\n\n        **Return:**\n            - ``content`` -- the given tagged content of all taskpaper files in a workspace (string)\n        \"\"\"\n        self.log.info(\n            'starting the ``_get_tagged_content_from_taskpaper_files`` method')\n\n        content = \"\"\n        for tp in taskpaperFiles:\n\n            done = False\n            if not workflowTagSet:\n                for tag in [\"@next\", \"@hold\", \"@done\", \"@someday\"]:\n                    if \"/\" + tag + \"/\" in tp:\n                        done = True\n            if done:\n                continue\n\n            # OPEN TASKPAPER FILE\n            doc = document(tp)\n            basename = os.path.basename(tp).replace(\"-\", \" \").upper()\n            archive = doc.get_project(\"Archive\")\n            if archive:\n                archive.delete()\n\n            fileTagged = False\n            done = False\n            for tag in tagSet:\n                if includeFileTags == True:\n                    tag = \"@\" + tag.replace(\"@\", \"\")\n                    if \"/%(tag)s/\" % locals() in tp:\n                        fileTagged = True\n                if \"/@done/\" in tp:\n                    done = True\n\n            if done:\n                continue\n\n            # GENERATE THE EDITORIAL FILE LINK\n            if self.editorialRootPath:\n                tp = urllib.quote(tp)\n                tp = tp.replace(\n                    self.editorialRootPath, \"editorial://open\") + \"?root=dropbox\"\n\n            for tag in tagSet:\n                tag = \"@\" + tag.replace(\"@\", \"\")\n                etag = \"%40\" + tag.replace(\"@\", \"\")\n\n                # DETERMINE THE SUBORDINATE/HIGH LEVEL TAGS\n                lesserTags = []\n                greaterTags = []\n                if workflowTagSet:\n                    trumped = False\n                else:\n                    trumped = True\n\n                for t in self.workflowTags:\n                    if t == tag:\n                        trumped = True\n                    if t != tag:\n                        if trumped:\n                            lesserTags.append(t)\n\n                        else:\n                            greaterTags.append(t)\n\n                # FOR DOCUMENT WITH THIS SYNC TAG\n                filteredTasks = []\n                if (\"/%(tag)s/\" % locals() in tp or \"/%(etag)s/\" % locals() in tp) and includeFileTags == True:\n                    filteredTasks = doc.all_tasks()\n                    for ft in filteredTasks:\n                        trumped = False\n                        for t in ft.tags:\n                            if t in \" \".join(greaterTags):\n                                trumped = True\n                        if not trumped:\n                            for t in lesserTags:\n                                ft.del_tag(t)\n                            ft.add_tag(tag)\n                elif not fileTagged:\n                    filteredProjects = doc.tagged_projects(tag)\n                    for p in filteredProjects:\n                        allTasks = p.all_tasks()\n                        for ft in filteredTasks:\n                            trumped = False\n                            for t in ft.tags:\n                                if t in \" \".join(greaterTags):\n                                    trumped = True\n                            if not trumped:\n                                for t in lesserTags:\n                                    ft.del_tag(t)\n                                ft.add_tag(tag)\n                    filteredTasks = doc.tagged_tasks(tag)\n                for ft in filteredTasks:\n                    if \"done\" not in \"\".join(ft.tags):\n                        if \"Project\" in ft.parent.__repr__():\n                            thisNote = tp + \" > \" + ft.parent.title[:-1]\n                        else:\n                            thisNote = tp\n                        ft.add_note(thisNote)\n                        content += ft.to_string() + \"\\n\"\n\n        self.log.info(\n            'completed the ``_get_tagged_content_from_taskpaper_files`` method')\n        return content", "response": "This method returns the content of all tasks tagged with a sync - tag from the given taskpaper files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a taskpaper task list from content pulled in from all of the workspace taskpaper docs", "response": "def _create_single_taskpaper_task_list(\n            self,\n            content,\n            setName):\n        \"\"\"*create single, sorted taskpaper task list from content pulled in from all of the workspace taskpaper docs*\n\n        **Key Arguments:**\n            - ``content`` -- the content to add to the taskpaper task index\n            - ``setName`` -- the name of the sync tag set\n\n        **Return:**\n            - ``taskpaperDocPath`` -- path to the task index taskpaper doc\n        \"\"\"\n        self.log.info(\n            'starting the ``_create_single_taskpaper_task_list`` method')\n\n        taskpaperDocPath = None\n        if len(content):\n            # content = content.decode(\"utf-8\")\n            if self.editorialRootPath:\n                taskpaperDocPath = self.syncFolder + \"/e-\" + \\\n                    self.workspaceName + \"-\" + setName + \"-tasks.taskpaper\"\n            else:\n                taskpaperDocPath = self.syncFolder + \"/\" + \\\n                    self.workspaceName + \"-\" + setName + \"-tasks.taskpaper\"\n            try:\n                self.log.debug(\"attempting to open the file %s\" %\n                               (taskpaperDocPath,))\n                writeFile = codecs.open(\n                    taskpaperDocPath, encoding='utf-8', mode='w')\n            except IOError, e:\n                message = 'could not open the file %s' % (taskpaperDocPath,)\n                self.log.critical(message)\n                raise IOError(message)\n            writeFile.write(content)\n            writeFile.close()\n            # OPEN TASKPAPER FILE\n            if self.editorialRootPath:\n                doc = document(self.syncFolder + \"/e-\" +\n                               self.workspaceName + \"-\" + setName + \"-tasks.taskpaper\")\n            else:\n                doc = document(self.syncFolder + \"/\" +\n                               self.workspaceName + \"-\" + setName + \"-tasks.taskpaper\")\n            doc.sort_projects(workflowTags=self.workflowTags)\n            doc.sort_tasks(workflowTags=self.workflowTags)\n            doc.save()\n\n        self.log.info(\n            'completed the ``_create_single_taskpaper_task_list`` method')\n        return taskpaperDocPath"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create_html_tasklist(\n            self,\n            taskpaperDocPath):\n        \"\"\"*create an html version of the single taskpaper index task list*\n\n        **Key Arguments:**\n            - ``taskpaperDocPath`` -- path to the task index taskpaper doc\n\n        **Return:**\n            - ``htmlFilePath`` -- the path to the output HTML file\n        \"\"\"\n        self.log.info('starting the ``_create_html_tasklist`` method')\n\n        if self.editorialRootPath:\n            return\n\n        title = self.workspaceName\n        content = \"<h1>%(title)s tasks</h1><ul>\\n\" % locals()\n\n        # OPEN TASKPAPER FILE\n        doc = document(taskpaperDocPath)\n        docTasks = doc.tasks\n\n        for task in docTasks:\n\n            tagString = \" \".join(task.tags)\n            tagString2 = \"\"\n            for t in task.tags:\n                t1 = t.split(\"(\")[0]\n                tagString2 += \"\"\" <span class=\"%(t1)s tag\">@%(t)s</span>\"\"\" % locals()\n\n            notes = task.notes\n            filepath = notes[0].title.split(\" > \")[0]\n            basename = os.path.basename(filepath).replace(\n                \".taskpaper\", \"\").replace(\"-\", \" \")\n            filepath = \"dryx-open://\" + filepath\n            taskTitle = u\"\"\"<a href=\"%(filepath)s\"><span class=\"bullet %(tagString)s\">\u25c9</span> </a>\"\"\" % locals() + \\\n                task.title[2:] + tagString2\n\n            if len(notes[0].title.split(\" > \")) > 1:\n                parent = notes[0].title.split(\" > \")[1]\n                parent = \"\"\"<span class=\"parent\">%(basename)s > %(parent)s</span></br>\\n\"\"\" % locals(\n                )\n            else:\n                parent = \"\"\"<span class=\"parent\">%(basename)s</span></br>\\n\"\"\" % locals(\n                )\n            taskContent = \"\"\"</span>\\n\\t\\t</br><span class=\"notes\">\"\"\".join(task.to_string(\n                title=False, indentLevel=0).split(\"\\n\")[1:])\n            if len(taskContent):\n                taskContent = \"\"\"\\n\\t<br><span class=\"notes\">\"\"\" + \\\n                    taskContent + \"\"\"\\n\\t</span>\"\"\"\n            else:\n                taskContent = \"\"\n\n            htmlTask = \"\"\"<li class=\"XXX\">%(parent)s%(taskTitle)s%(taskContent)s</li>\\n\"\"\"  % locals()\n            content += htmlTask\n\n        content += \"</ul>\"\n\n        htmlFilePath = taskpaperDocPath.replace(\".taskpaper\", \".html\")\n        try:\n            self.log.debug(\"attempting to open the file %s\" % (htmlFilePath,))\n            writeFile = codecs.open(\n                htmlFilePath, encoding='utf-8', mode='w')\n        except IOError, e:\n            message = 'could not open the file %s' % (htmlFilePath,)\n            self.log.critical(message)\n            raise IOError(message)\n        writeFile.write(content)\n        writeFile.close()\n\n        self.log.info('completed the ``_create_html_tasklist`` method')\n        return htmlFilePath", "response": "create an html version of the single taskpaper index task list"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _complete_original_tasks(\n            self,\n            setName):\n        \"\"\"*mark original tasks as completed if they are marked as complete in the index taskpaper document*\n\n        **Key Arguments:**\n            - ``setName`` -- the name of the sync tag set\n        \"\"\"\n        self.log.info('starting the ``_complete_original_tasks`` method')\n\n        if self.editorialRootPath:\n            taskpaperDocPath = self.syncFolder + \"/e-\" + \\\n                self.workspaceName + \"-\" + setName + \"-tasks.taskpaper\"\n        else:\n            taskpaperDocPath = self.syncFolder + \"/\" + \\\n                self.workspaceName + \"-\" + setName + \"-tasks.taskpaper\"\n        exists = os.path.exists(taskpaperDocPath)\n        if not exists:\n            return\n\n        # OPEN TASKPAPER INDEX FILE\n        doc = document(taskpaperDocPath)\n        doneTasks = doc.tagged_tasks(\"@done\")\n\n        for t in doneTasks:\n            theseNotes = t.notes\n            parent = t.parent\n            while not len(theseNotes) and parent and parent.parent:\n                theseNotes = parent.notes\n                parent = parent.parent\n\n            if self.editorialRootPath:\n                theseNotes[0].title = theseNotes[0].title.replace(\n                    \"editorial://open\", self.editorialRootPath).replace(\"?root=dropbox\", \"\")\n                theseNotes[0].title = urllib.unquote(\n                    theseNotes[0].title).replace(\"%40\", \"@\")\n\n            originalFile = theseNotes[0].title.split(\" > \")[0].strip()\n            if len(theseNotes[0].title.split(\" > \")) > 1:\n                projectName = theseNotes[0].title.split(\" > \")[1].strip()\n            else:\n                projectName = False\n\n            odoc = document(originalFile)\n            odoc.tidy()\n            odoc.save()\n            odoc = document(originalFile)\n            if projectName:\n                thisObject = odoc.get_project(projectName)\n            else:\n                thisObject = odoc\n\n            oTask = thisObject.get_task(t.title)\n            if oTask:\n                oTask.done(\"all\")\n                odoc.save()\n\n        self.log.info('completed the ``_complete_original_tasks`` method')\n        return None", "response": "This method is used to mark original tasks as complete in the index taskpaper document."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure(name, path=None):\n    app_directory = os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0])))\n\n    if path is None:\n        probing_path = [\n            'local/%s.logging.conf' % name,\n            'default/%s.logging.conf' % name,\n            'local/logging.conf',\n            'default/logging.conf']\n        for relative_path in probing_path:\n            configuration_file = os.path.join(app_directory, relative_path)\n            if os.path.exists(configuration_file):\n                path = configuration_file\n                break\n    elif not os.path.isabs(path):\n        found = False\n        for conf in 'local', 'default':\n            configuration_file = os.path.join(app_directory, conf, path)\n            if os.path.exists(configuration_file):\n                path = configuration_file\n                found = True\n                break\n        if not found:\n            raise ValueError(\n                'Logging configuration file \"%s\" not found in local or default '\n                'directory' % path)\n    elif not os.path.exists(path):\n        raise ValueError('Logging configuration file \"%s\" not found')\n\n    if path is not None:\n        working_directory = os.getcwd()\n        os.chdir(app_directory)\n        try:\n            splunk_home = os.path.normpath(os.path.join(working_directory, os.environ['SPLUNK_HOME']))\n        except KeyError:\n            splunk_home = working_directory  # reasonable in debug scenarios\n        try:\n            path = os.path.abspath(path)\n            fileConfig(path, {'SPLUNK_HOME': splunk_home})\n        finally:\n            os.chdir(working_directory)\n\n    if len(root.handlers) == 0:\n        root.addHandler(StreamHandler())\n\n    logger = getLogger(name)\n    return logger, path", "response": "Configure logging and return a logger and the location of its logging configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_contents(self, element):\n        return [Response(self.trigger, child, self.file_path)\n                for child in element if child.tag in ['response', 'template']]", "response": "Retrieve the contents of an element"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef evaluate(self, agentml, user=None):\n        self._log.debug('Evaluating conditional statement: {statement}'\n                        .format(statement=' '.join(filter(None, [self.type, self.name, self.operator, self.value]))))\n\n        # Get the value of our key type\n        if self.type not in agentml.conditions:\n            self._log.error('Unknown condition type, \"{type}\", unable to evaluate condition statement'\n                            .format(type=self.type))\n            return\n\n        key_value = agentml.conditions[self.type].get(agentml, user, self.name)\n\n        # Atomic comparisons\n        if self.operator is None and key_value:\n            return self.contents\n\n        if (self.operator == self.IS) and (key_value == self.value):\n            return self.contents\n\n        if (self.operator == self.IS_NOT) and (key_value != self.value):\n            return self.contents\n\n        # All remaining self.operators are numeric based, so key_value must contain a valid integer or float\n        try:\n            key_value = float(key_value)\n            value = float(self.value)\n        except (ValueError, TypeError):\n            return False\n\n        # Numeric comparisons\n        if (self.operator == self.GREATER_THAN) and (key_value > value):\n            return self.contents\n\n        if (self.operator == self.GREATER_THAN_OR_EQUAL) and (key_value >= value):\n            return self.contents\n\n        if (self.operator == self.LESS_THAN) and (key_value < value):\n            return self.contents\n\n        if (self.operator == self.LESS_THAN_OR_EQUAL) and (key_value <= value):\n            return self.contents\n\n        return False", "response": "Evaluate the condition statement and return its contents if a successful evaluation takes place."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef expand_user(path, user=None):\n\n    def _replace(m):\n        m_user = m.group(1) or user\n        return pwd.getpwnam(m_user).pw_dir if m_user else pwd.getpwuid(os.getuid()).pw_dir\n\n    return re.sub(r'~(\\w*)', _replace, path)", "response": "Roughly the same as os. path. expanduser but you can pass a default user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unique_list(input_, key=lambda x:x):\n    seen = set()\n    output = []\n    for x in input_:\n        keyx = key(x)\n        if keyx not in seen:\n            seen.add(keyx)\n            output.append(x)\n    return output", "response": "Return the unique elements from the input in order."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the split colon - delimited list from an environment variable.", "response": "def get_environ_list(name, default=None):\n    \"\"\"Return the split colon-delimited list from an environment variable.\n\n    Returns an empty list if the variable didn't exist.\n\n    \"\"\"\n    packed = os.environ.get(name)\n    if packed is not None:\n        return packed.split(':')\n    elif default is not None:\n        return default\n    else:\n        return []"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_indel(reference_bases, alternate_bases):\n    if len(reference_bases) > 1:\n        return True\n    for alt in alternate_bases:\n        if alt is None:\n            return True\n        elif len(alt) != len(reference_bases):\n            return True\n    return False", "response": "Return whether or not the variant is an INDEL."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn whether or not the variant is a SNP", "response": "def is_snp(reference_bases, alternate_bases):\n    \"\"\" Return whether or not the variant is a SNP \"\"\"\n    if len(reference_bases) > 1:\n        return False\n    for alt in alternate_bases:\n        if alt is None:\n            return False\n        if alt not in ['A', 'C', 'G', 'T', 'N', '*']:\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_deletion(reference_bases, alternate_bases):\n    # if multiple alts, it is unclear if we have a transition\n    if len(alternate_bases) > 1:\n        return False\n\n    if is_indel(reference_bases, alternate_bases):\n        # just one alt allele\n        alt_allele = alternate_bases[0]\n        if alt_allele is None:\n            return True\n        if len(reference_bases) > len(alt_allele):\n            return True\n        else:\n            return False\n    else:\n        return False", "response": "Return whether or not the INDEL is a deletion."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndoes these variants overlap in the reference?", "response": "def overlapping(self, other):\n        \"\"\"Do these variants overlap in the reference\"\"\"\n        return (\n            other.start in self.ref_range) or (\n            self.start in other.ref_range)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_input(prompt, default=None, choices=None, option_value=None):\n    if option_value is not None:\n        return option_value\n    \n    choices = choices or []\n    while 1:\n        r = input(prompt+' ').strip()\n        if not r and default is not None:\n            return default\n        if choices:\n            if r not in choices:\n                r = None\n            else:\n                break\n        else:\n            break\n    return r", "response": "Get the input from a user."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_from_argv(self, prog, subcommand, global_options, argv):\n        self.prog_name = prog\n        parser = self.create_parser(prog, subcommand)\n        options, args = parser.parse_args(argv)\n        self.global_options = global_options\n        self.options = options\n        self.args = args\n        self.execute(args, options, global_options)", "response": "Run the command from the given command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint the help text for this script.", "response": "def print_help_info(self, global_options):\n        \"\"\"\n        Returns the script's main help text, as a string.\n        \"\"\"\n        usage = ['',\"Type '%s help <subcommand>' for help on a specific subcommand.\" % self.prog_name,'']\n        usage.append('Available subcommands:')\n        commands = list(self.get_commands().keys())\n        commands.sort()\n        for cmd in commands:\n            usage.append('  %s' % cmd)\n        return '\\n'.join(usage)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute the command - line arguments and returns the result of the command.", "response": "def execute(self):\n        \"\"\"\n        Given the command-line arguments, this figures out which subcommand is\n        being run, creates a parser appropriate to that command, and runs it.\n        \"\"\"\n        # Preprocess options to extract --settings and --pythonpath.\n        # These options could affect the commands that are available, so they\n        # must be processed early.\n        parser = NewOptionParser(prog=self.prog_name,\n                             usage=self.usage_info,\n#                             version=self.get_version(),\n                             formatter = NewFormatter(),\n                             add_help_option = False,\n                             option_list=self.option_list)\n        \n        if not self.global_options:\n            global_options, args = parser.parse_args(self.argv)\n            handle_default_options(global_options)\n            args = args[1:]\n        else:\n            global_options = self.global_options\n            args = self.argv\n    \n        def print_help(global_options):\n            parser.print_help()\n            sys.stderr.write(self.print_help_info(global_options) + '\\n')\n            sys.exit(0)\n            \n        if len(args) == 0:\n            if global_options.version:\n                print(self.get_version())\n                sys.exit(1)\n            else:\n                print_help(global_options)\n                sys.ext(1)\n    \n        try:\n            subcommand = args[0]\n        except IndexError:\n            subcommand = 'help' # Display help if no arguments were given.\n    \n        if subcommand == 'help':\n            if len(args) > 1:\n                command = self.fetch_command(global_options, args[1])\n                if issubclass(command, CommandManager):\n                    cmd = command(['help'], None, '%s %s' % (self.prog_name, args[1]), global_options=global_options)\n                    cmd.execute()\n                else:\n                    command().print_help(self.prog_name, args[1])\n                sys.exit(1)\n            else:\n                print_help(global_options)\n        if global_options.help:\n            print_help(global_options)\n        else:\n            command = self.fetch_command(global_options, subcommand)\n            if issubclass(command, CommandManager):\n                cmd = command(args[1:], None, '%s %s' % (self.prog_name, subcommand), global_options=global_options)\n                cmd.execute()\n            else:\n                cmd = command()\n                cmd.run_from_argv(self.prog_name, subcommand, global_options, args[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_pgurl(self, url):\n        parsed = urlsplit(url)\n\n        return {\n            'user': parsed.username,\n            'password': parsed.password,\n            'database': parsed.path.lstrip('/'),\n            'host': parsed.hostname,\n            'port': parsed.port or 5432,\n        }", "response": "Given a Postgres url return a dict with keys user password host port and database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset_current_row(self, *args, **kwargs):\n        i = self.configobj_treev.currentIndex()\n        m = self.configobj_treev.model()\n        m.restore_default(i)", "response": "Resets the selected rows value to its default value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_configs(self):\n        # all loaded configs are stored in confs\n        confs = []\n        # always load core config. it is not part of the plugin configs\n        try:\n            confs.append(iniconf.get_core_config())\n        except ConfigError, e:\n            log.error(\"Could not load Core config! Reason was: %s\" % e)\n\n        # get config specs that lie in the plugin path\n        # we have to watch the order we gather the specs\n        # plugins can override each other, so can config specs\n        # it depends on the order of the JUKEBOX_PLUGIN_PATH\n        specs = {}\n        pathenv = os.environ.get('JUKEBOX_PLUGIN_PATH', '')\n        paths = pathenv.split(';')\n        paths.append(constants.BUILTIN_PLUGIN_PATH)\n        for p in reversed(paths):\n            if p:\n                files = self.find_inifiles(p)\n                for ini in files:\n                    base = os.path.basename(ini)\n                    specs[base] = ini\n\n        configs = {}\n        files = self.find_inifiles(PLUGIN_CONFIG_DIR)\n        for ini in files:\n            base = os.path.basename(ini)\n            configs[base] = ini\n\n        # find matching pairs of configs and specs\n        # and load them\n        for k in configs:\n            spec = specs.pop(k, None)\n            conf = configs[k]\n            try:\n                confs.append(iniconf.load_config(conf, spec))\n            except ConfigError, e:\n                log.error(\"Could not load config %s, Reason was: %s\" % (k ,e))\n\n        # the remaining configspecs can be used to create\n        # empty configs\n        for k in specs:\n            spec = specs[k]\n            conf = os.path.join(PLUGIN_CONFIG_DIR, k)\n            try:\n                confs.append(iniconf.load_config(conf, spec))\n            except ConfigError, e:\n                log.error(\"Could not load config %s, Reason was: %s\" % (k ,e))\n\n        return confs", "response": "Load all config files and return the configobjs\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_inifile(self, current, previous):\n        c = self.inimodel.data(current, self.inimodel.confobjRole)\n        self.confobjmodel = ConfigObjModel(c)\n        self.configobj_treev.setModel(self.confobjmodel)\n        self.configobj_treev.expandAll()\n        self.confobjmodel.dataChanged.connect(self.iniedited)", "response": "Set the configobj to the current index of the files_lv\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the current index of inimodel to modified", "response": "def iniedited(self, *args, **kwargs):\n        \"\"\"Set the current index of inimodel to modified\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.inimodel.set_index_edited(self.files_lv.currentIndex(), True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef closeEvent(self, event):\n        if self.inimodel.get_edited():\n            r = self.doc_modified_prompt()\n            if r == QtGui.QMessageBox.Yes:\n                event.accept()\n            else:\n                event.ignore()\n        else:\n            event.accept()", "response": "Handles closing of the window."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef doc_modified_prompt(self, ):\n        msgbox = QtGui.QMessageBox()\n        msgbox.setWindowTitle(\"Discard changes?\")\n        msgbox.setText(\"Documents have been modified.\")\n        msgbox.setInformativeText(\"Do you really want to exit? Changes will be lost!\")\n        msgbox.setStandardButtons(msgbox.Yes | msgbox.Cancel)\n        msgbox.setDefaultButton(msgbox.Cancel)\n        msgbox.exec_()\n        return msgbox.result()", "response": "Create a message box that asks the user to continue although files have been modified."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save_current_config(self, ):\n        # check if all configs validate correctly\n        btn = None\n        for row in range(self.inimodel.rowCount()):\n            i = self.inimodel.index(row, 0)\n            r = self.inimodel.validate(i)\n            if r is not True:\n                btn = self.invalid_prompt()\n                break\n\n        if btn == QtGui.QMessageBox.Cancel:\n            return\n        current = self.files_lv.currentIndex()\n        c = self.inimodel.data(current, self.inimodel.confobjRole)\n        c.write()\n        self.inimodel.set_index_edited(current, False)", "response": "Saves the currently displayed config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting the configeditor :returns: None :rtype: None :raises: None", "response": "def run(self, parent=None):\n        \"\"\"Start the configeditor\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.cw = ConfigerWin(parent=parent)\n        self.cw.show()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_virtualenv_path(self, requirements_option: RequirementsOptions, requirements_hash: Optional[str]) -> Path:\n        if requirements_option == RequirementsOptions.no_requirements:\n            venv_name = \"no_requirements\"\n        else:\n            venv_name = requirements_hash\n\n        return Path(self._arca.base_dir) / \"venvs\" / venv_name", "response": "Returns the path to the virtualenv that the current state of the repository is in."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the location of the virtualenv from the path creates it if it does not exist.", "response": "def get_or_create_venv(self, path: Path) -> Path:\n        \"\"\"\n        Gets the location of  the virtualenv from :meth:`get_virtualenv_path`, checks if it exists already,\n        creates it and installs requirements otherwise. The virtualenvs are stored in a folder based\n        on the :class:`Arca` ``base_dir`` setting.\n\n        :param path: :class:`Path <pathlib.Path>` to the cloned repository.\n        \"\"\"\n        requirements_option, requirements_hash = self.get_requirements_information(path)\n\n        venv_path = self.get_virtualenv_path(requirements_option, requirements_hash)\n\n        if not venv_path.exists():\n            logger.info(f\"Creating a venv in {venv_path}\")\n            builder = EnvBuilder(with_pip=True)\n            builder.create(venv_path)\n\n            shell = False\n            cmd = None\n            cwd = None\n\n            if requirements_option == RequirementsOptions.pipfile:\n                cmd = [\"source\", (str(venv_path / \"bin\" / \"activate\")), \"&&\",\n                       \"pipenv\", \"install\", \"--deploy\", \"--ignore-pipfile\"]\n\n                cmd = \" \".join(cmd)\n\n                cwd = path / self.pipfile_location\n                shell = True\n            elif requirements_option == RequirementsOptions.requirements_txt:\n                requirements_file = path / self.requirements_location\n\n                logger.debug(\"Requirements file:\")\n                logger.debug(requirements_file.read_text())\n                logger.info(\"Installing requirements from %s\", requirements_file)\n\n                cmd = [str(venv_path / \"bin\" / \"python3\"), \"-m\", \"pip\", \"install\", \"-r\",\n                       shlex.quote(str(requirements_file))]\n\n            if cmd is not None:\n                logger.info(\"Running Popen cmd %s, with shell %s\", cmd, shell)\n\n                process = subprocess.Popen(cmd,\n                                           stdout=subprocess.PIPE,\n                                           stderr=subprocess.PIPE,\n                                           shell=shell,\n                                           cwd=cwd)\n\n                try:\n                    out_stream, err_stream = process.communicate(timeout=self.requirements_timeout)\n                except subprocess.TimeoutExpired:\n                    process.kill()\n                    logger.warning(\"The install command timed out, deleting the virtualenv\")\n                    shutil.rmtree(str(venv_path), ignore_errors=True)\n\n                    raise BuildTimeoutError(f\"Installing of requirements timeouted after \"\n                                            f\"{self.requirements_timeout} seconds.\")\n\n                out_stream = out_stream.decode(\"utf-8\")\n                err_stream = err_stream.decode(\"utf-8\")\n\n                logger.debug(\"Return code is %s\", process.returncode)\n                logger.debug(out_stream)\n                logger.debug(err_stream)\n\n                if process.returncode:\n                    logger.warning(\"The install command failed, deleting the virtualenv\")\n                    shutil.rmtree(str(venv_path), ignore_errors=True)\n                    raise BuildError(\"Unable to install requirements.txt\", extra_info={\n                        \"out_stream\": out_stream,\n                        \"err_stream\": err_stream,\n                        \"returncode\": process.returncode\n                    })\n\n            else:\n                logger.info(\"Requirements file not present in repo, empty venv it is.\")\n        else:\n            logger.info(f\"Venv already exists in {venv_path}\")\n\n        return venv_path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_or_create_environment(self, repo: str, branch: str, git_repo: Repo, repo_path: Path) -> str:\n        return str(self.get_or_create_venv(repo_path).resolve() / \"bin\" / \"python\")", "response": "Handles the requirements in the target repository returns a path to a virtualenv that will be used to run the python executable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_cf_response(event, context, response_status, reason=None,\n                     response_data=None, physical_resource_id=None):\n    \"\"\"Responds to Cloudformation after a create/update/delete operation.\"\"\"\n    response_data = response_data or {}\n    reason = reason or \"See the details in CloudWatch Log Stream: \" + \\\n        context.log_stream_name\n    physical_resource_id = physical_resource_id or context.log_stream_name\n    response_body = json.dumps(\n        {\n            'Status': response_status,\n            'Reason': reason,\n            'PhysicalResourceId': physical_resource_id,\n            'StackId': event['StackId'],\n            'RequestId': event['RequestId'],\n            'LogicalResourceId': event['LogicalResourceId'],\n            'Data': response_data\n        }\n    )\n\n    opener = build_opener(HTTPHandler)\n    request = Request(event[\"ResponseURL\"], data=response_body)\n    request.add_header(\"Content-Type\", \"\")\n    request.add_header(\"Content-Length\", len(response_body))\n    request.get_method = lambda: 'PUT'\n    try:\n        response = opener.open(request)\n        print(\"Status code: {}\".format(response.getcode()))\n        print(\"Status message: {}\".format(response.msg))\n        return True\n    except HTTPError as exc:\n        print(\"Failed executing HTTP request: {}\".format(exc.code))\n        return False", "response": "Sends a Cloudformation response to CloudWatch Log Stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nannotating events with entry and exit timestamps.", "response": "def annotate_mapper(**decargs):\n    \"\"\"Add input and output watermarks to processed events.\"\"\"\n    def decorator(func):\n        \"\"\"Annotate events with entry and/or exit timestamps.\"\"\"\n        def wrapper(event, *args, **kwargs):\n            \"\"\"Add enter and exit annotations to the processed event.\"\"\"\n            funcname = \":\".join([func.__module__, func.__name__])\n            enter_ts = time.time()\n            out = func(event, *args, **kwargs)\n            enter_key = funcname + \"|enter\"\n            out = annotate_event(out, enter_key, ts=enter_ts, **decargs)\n            exit_key = funcname + \"|exit\"\n            out = annotate_event(out, exit_key, ts=time.time(), **decargs)\n            return out\n\n        return wrapper\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds input and output watermarks to filtered events.", "response": "def annotate_filter(**decargs):\n    \"\"\"Add input and output watermarks to filtered events.\"\"\"\n    def decorator(func):\n        \"\"\"Annotate events with entry and/or exit timestamps.\"\"\"\n        def wrapper(event, *args, **kwargs):\n            \"\"\"Add enter and exit annotations to the processed event.\"\"\"\n            funcname = \":\".join([func.__module__, func.__name__])\n            enter_key = funcname + \"|enter\"\n            annotate_event(event, enter_key, **decargs)\n            out = func(event, *args, **kwargs)\n            exit_key = funcname + \"|exit\"\n            annotate_event(event, exit_key, **decargs)\n            return out\n\n        return wrapper\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _error_repr(error):\n    error_repr = repr(error)\n    if len(error_repr) > 200:\n        error_repr = hash(type(error))\n    return error_repr", "response": "A compact unique representation of an error."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef annotation_has_expired(event, key, timeout):\n    anns = get_annotations(event, key)\n    if anns:\n        return (time.time() - anns[0][\"ts\"]) > timeout\n    else:\n        return False", "response": "Check if an event error has expired."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replace_event_annotations(event, newanns):\n    _humilis = event.get(\"_humilis\", {})\n    if not _humilis:\n        event[\"_humilis\"] = {\"annotation\": newanns}\n    else:\n        event[\"_humilis\"][\"annotation\"] = newanns", "response": "Replace event annotations with the provided ones."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an annotation to an event.", "response": "def annotate_event(ev, key, ts=None, namespace=None, **kwargs):\n    \"\"\"Add an annotation to an event.\"\"\"\n    ann = {}\n    if ts is None:\n        ts = time.time()\n    ann[\"ts\"] = ts\n    ann[\"key\"] = key\n    if namespace is None and \"HUMILIS_ENVIRONMENT\" in os.environ:\n        namespace = \"{}:{}:{}\".format(\n            os.environ.get(\"HUMILIS_ENVIRONMENT\"),\n            os.environ.get(\"HUMILIS_LAYER\"),\n            os.environ.get(\"HUMILIS_STAGE\"))\n\n    if namespace is not None:\n        ann[\"namespace\"] = namespace\n    ann.update(kwargs)\n    _humilis = ev.get(\"_humilis\", {})\n    if not _humilis:\n        ev[\"_humilis\"] = {\"annotation\": [ann]}\n    else:\n        ev[\"_humilis\"][\"annotation\"] = _humilis.get(\"annotation\", [])\n        # Clean up previous annotations with the same key\n        delete_annotations(ev, key)\n        ev[\"_humilis\"][\"annotation\"].append(ann)\n\n    return ev"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_annotations(event, key, namespace=None, matchfunc=None):\n    if matchfunc is None:\n        matchfunc = _is_equal\n    if isinstance(key, Exception):\n        key = _error_repr(key)\n    return [ann for ann in event.get(\"_humilis\", {}).get(\"annotation\", [])\n            if (matchfunc(key, ann[\"key\"]) and\n                (namespace is None or ann.get(\"namespace\") == namespace))]", "response": "Produce the list of annotations for a given key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting all event annotations with a matching key.", "response": "def delete_annotations(event, key, namespace=None, matchfunc=None):\n    \"\"\"Delete all event annotations with a matching key.\"\"\"\n    if matchfunc is None:\n        matchfunc = _is_equal\n    if isinstance(key, Exception):\n        key = _error_repr(key)\n    newanns = [ann for ann in event.get(\"_humilis\", {}).get(\"annotation\", [])\n               if not (matchfunc(key, ann[\"key\"]) and\n                   (namespace is None or ann.get(\"namespace\") == namespace))]\n    replace_event_annotations(event, newanns)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nproduce a list of function annotations in this event.", "response": "def get_function_annotations(event, funcname, type=None, namespace=None):\n    \"\"\"Produce a list of function annotations in in this event.\"\"\"\n    if type:\n        postfix = \"|\" + type\n    else:\n        postfix = \"|.+\"\n\n    def matchfunc(key, annkey):\n        \"\"\"Check if the provider regex matches an annotation key.\"\"\"\n        return re.match(key, annkey) is not None\n\n    return get_annotations(event, funcname + postfix, namespace=namespace,\n                           matchfunc=matchfunc)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_task(self, keywords, context, rule):\n        for keyword in keywords:\n            self._tasks[keyword] = {'context': context, 'rule': rule}", "response": "Map a function to a list of keywords"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a modifier to the internal dictionary of tasks based on presence of a keyword.", "response": "def add_modifier(self, modifier, keywords, relative_pos,\n                     action, parameter=None):\n        \"\"\"Modify existing tasks based on presence of a keyword.\n\n        Parameters\n        ----------\n        modifier : str\n            A string value which would trigger the given Modifier.\n        keywords : iterable of str\n            sequence of strings which are keywords for some task,\n            which has to be modified.\n        relative_pos : int\n            Relative position of the task which should be modified\n            in the presence of `modifier`. It's value can never be 0. Data\n            fields should also be considered when calculating the relative\n            position.\n        action : str\n            String value representing the action which should be performed\n            on the task. Action represents calling a arbitrary function\n            to perform th emodification.\n        parameter : object\n            value required by the `action`.(Default None)\n        \"\"\"\n        if relative_pos == 0:\n            raise ValueError(\"relative_pos cannot be 0\")\n        modifier_dict = self._modifiers.get(modifier, {})\n        value = (action, parameter, relative_pos)\n        for keyword in keywords:\n            action_list = list(modifier_dict.get(keyword, []))\n            action_list.append(value)\n            modifier_dict[keyword] = tuple(action_list)\n        self._modifiers[modifier] = modifier_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(self, text):\n        self._parsed_list = []\n        self._most_recent_report = []\n        self._token_list = text.lower().split()\n        modifier_index_list = []\n        for item in self._token_list:\n            \n            if(self._is_token_data_callback(item)):\n                self._parsed_list.append(self._clean_data_callback(item))\n                \n            if item in self._tasks:\n                d = {}\n                d['context'] = self._tasks[item]['context']\n                d['rule'] = self._tasks[item]['rule']\n                d['task'] = item\n                self._parsed_list.append(d)\n\n            if item in self._modifiers:\n                modifier_index_list.append((len(self._parsed_list), item))\n\n        self._apply_modifiers(modifier_index_list)\n        return self._evaluate()", "response": "Parse the string text and return a tuple of left over Data fields."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading a packed integer from a string.", "response": "def unpack_int(s):\n    \"\"\" Reads a packed integer from string <s> \"\"\"\n    ret = 0\n    i = 0\n    while True:\n        b = ord(s[i])\n        ret |= (b & 127) << (i * 7)\n        i += 1\n        if b & 128 == 0:\n            break\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npack a number into a string.", "response": "def pack_int(v):\n    \"\"\" Returns <v> as packed string. \"\"\"\n    if v == 0:\n        return \"\\0\"\n    ret = ''\n    while v > 0:\n        c = v & 127\n        v >>= 7\n        if v != 0:\n            c = c | 128\n        ret += chr(c)\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a packed integer from the fileobj <f.", "response": "def read_packed_int(f):\n    \"\"\" Reads a packed integer from the fileobj <f>. \"\"\"\n    ret = 0\n    s = 0\n    while True:\n        b = ord(f.read(1))\n        ret |= (b & 127) << s\n        s += 7\n        if b & 128 == 0:\n            break\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_packed_int(f, v):\n    if v == 0:\n        f.write(\"\\0\")\n    while v > 0:\n        c = v & 127\n        v >>= 7\n        if v != 0:\n            c = c | 128\n        f.write(chr(c))", "response": "Writes the packed integer v to f."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef connectionLost(self, reason):\n        self.remaining.reset()\n\n        try:\n            result = json.load(self.remaining)\n        except Exception, e:\n            self.finished.errback(e)\n            return\n\n        returnValue = result\n        if self.heartbeater:\n            self.heartbeater.nextToken = result['token']\n            returnValue = (result, self.heartbeater)\n\n        self.finished.callback(returnValue)", "response": "Called when the response body has been completely delivered."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake a request to the Service Registry API.", "response": "def request(self,\n                method,\n                path,\n                options=None,\n                payload=None,\n                heartbeater=None,\n                retry_count=0):\n        \"\"\"\n        Make a request to the Service Registry API.\n        @param method: HTTP method ('POST', 'GET', etc.).\n        @type method: C{str}\n        @param path: Path to be appended to base URL ('/sessions', etc.).\n        @type path: C{str}\n        @param options: Options to be encoded as query parameters in the URL.\n        @type options: C{dict}\n        @param payload: Optional body\n        @type payload: C{dict}\n        @param heartbeater: Optional heartbeater passed in when\n        creating a session.\n        @type heartbeater: L{HeartBeater}\n        \"\"\"\n        def _request(authHeaders, options, payload, heartbeater, retry_count):\n            tenantId = authHeaders['X-Tenant-Id']\n            requestUrl = self.baseUrl + tenantId + path\n            if options:\n                requestUrl += '?' + urlencode(options)\n            payload = StringProducer(json.dumps(payload)) if payload else None\n\n            d = self.agent.request(method=method,\n                                   uri=requestUrl,\n                                   headers=None,\n                                   bodyProducer=payload)\n            d.addCallback(self.cbRequest,\n                          method,\n                          path,\n                          options,\n                          payload,\n                          heartbeater,\n                          retry_count)\n\n            return d\n\n        d = self.agent.getAuthHeaders()\n        d.addCallback(_request, options, payload, heartbeater, retry_count)\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _initialized(self, partitioner):\n        self._partitioner = partitioner\n        self._thimble = Thimble(self.reactor, self.pool,\n                                partitioner, _blocking_partitioner_methods)\n        self._state = None", "response": "Store the partitioner and reset the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninjects the arca into the log file for this instance.", "response": "def inject_arca(self, arca):\n        \"\"\" Apart from the usual validation stuff it also creates log file for this instance.\n        \"\"\"\n        super().inject_arca(arca)\n\n        import vagrant\n\n        self.log_path = Path(self._arca.base_dir) / \"logs\" / (str(uuid4()) + \".log\")\n        self.log_path.parent.mkdir(exist_ok=True, parents=True)\n        logger.info(\"Storing vagrant log in %s\", self.log_path)\n\n        self.log_cm = vagrant.make_file_cm(self.log_path)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate the configuration of the Vagrant backend.", "response": "def validate_configuration(self):\n        \"\"\" Runs :meth:`arca.DockerBackend.validate_configuration` and checks extra:\n\n        * ``box`` format\n        * ``provider`` format\n        * ``use_registry_name`` is set and ``registry_pull_only`` is not enabled.\n        \"\"\"\n        super().validate_configuration()\n\n        if self.use_registry_name is None:\n            raise ArcaMisconfigured(\"Use registry name setting is required for VagrantBackend\")\n\n        if not re.match(r\"^[a-z]+/[a-zA-Z0-9\\-_]+$\", self.box):\n            raise ArcaMisconfigured(\"Provided Vagrant box is not valid\")\n\n        if not re.match(r\"^[a-z_]+$\", self.provider):\n            raise ArcaMisconfigured(\"Provided Vagrant provider is not valid\")\n\n        if self.registry_pull_only:\n            raise ArcaMisconfigured(\"Push must be enabled for VagrantBackend\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_vagrant(self, vagrant_file):\n        if self.inherit_image:\n            image_name, image_tag = str(self.inherit_image).split(\":\")\n        else:\n            image_name = self.get_arca_base_name()\n            image_tag = self.get_python_base_tag(self.get_python_version())\n\n        logger.info(\"Creating Vagrantfile located in %s, base image %s:%s\", vagrant_file, image_name, image_tag)\n\n        repos_dir = (Path(self._arca.base_dir) / 'repos').resolve()\n        vagrant_file.parent.mkdir(exist_ok=True, parents=True)\n        vagrant_file.write_text(dedent(f\"\"\"\n        # -*- mode: ruby -*-\n        # vi: set ft=ruby :\n\n        Vagrant.configure(\"2\") do |config|\n          config.vm.box = \"{self.box}\"\n          config.ssh.insert_key = true\n          config.vm.provision \"docker\" do |d|\n            d.pull_images \"{image_name}:{image_tag}\"\n          end\n\n          config.vm.synced_folder \".\", \"/vagrant\"\n          config.vm.synced_folder \"{repos_dir}\", \"/srv/repos\"\n          config.vm.provider \"{self.provider}\"\n\n        end\n        \"\"\"))\n\n        (vagrant_file.parent / \"runner.py\").write_text(self.RUNNER.read_text())", "response": "Creates a Vagrantfile in the target dir with only the base image pulled."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fabric_task(self):\n        from fabric import api\n\n        @api.task\n        def run_script(container_name, definition_filename, image_name, image_tag, repository, timeout):\n            \"\"\" Sequence to run inside the VM.\n                Starts up the container if the container is not running\n                (and copies over the data and the runner script)\n                Then the definition is copied over and the script launched.\n                If the VM is gonna be shut down then kills the container as well.\n            \"\"\"\n            workdir = str((Path(\"/srv/data\") / self.cwd).resolve())\n            cmd = \"sh\" if self.inherit_image else \"bash\"\n\n            api.run(f\"docker pull {image_name}:{image_tag}\")\n\n            container_running = int(api.run(f\"docker ps --format '{{.Names}}' -f name={container_name} | wc -l\"))\n            container_stopped = int(api.run(f\"docker ps -a --format '{{.Names}}' -f name={container_name} | wc -l\"))\n\n            if container_running == 0:\n                if container_stopped:\n                    api.run(f\"docker rm -f {container_name}\")\n\n                api.run(f\"docker run \"\n                        f\"--name {container_name} \"\n                        f\"--workdir \\\"{workdir}\\\" \"\n                        f\"-dt {image_name}:{image_tag} \"\n                        f\"{cmd} -i\")\n\n                api.run(f\"docker exec {container_name} mkdir -p /srv/scripts\")\n                api.run(f\"docker cp /srv/repos/{repository} {container_name}:/srv/branch\")\n                api.run(f\"docker exec --user root {container_name} bash -c 'mv /srv/branch/* /srv/data'\")\n                api.run(f\"docker exec --user root {container_name} rm -rf /srv/branch\")\n                api.run(f\"docker cp /vagrant/runner.py {container_name}:/srv/scripts/\")\n\n            api.run(f\"docker cp /vagrant/{definition_filename} {container_name}:/srv/scripts/\")\n\n            output = api.run(\n                \" \".join([\n                    \"docker\", \"exec\", container_name,\n                    \"python\", \"/srv/scripts/runner.py\", f\"/srv/scripts/{definition_filename}\",\n                ]),\n                timeout=math.ceil(timeout)\n            )\n\n            if not self.keep_container_running:\n                api.run(f\"docker kill {container_name}\")\n\n            return output\n\n        return run_script", "response": "Returns a fabric task which executes the script in the Vagrant VM."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ensure_vm_running(self, vm_location):\n        import vagrant\n\n        if self.vagrant is None:\n            vagrant_file = vm_location / \"Vagrantfile\"\n            if not vagrant_file.exists():\n                self.init_vagrant(vagrant_file)\n\n            self.vagrant = vagrant.Vagrant(vm_location,\n                                           quiet_stdout=self.quiet,\n                                           quiet_stderr=self.quiet,\n                                           out_cm=self.log_cm,\n                                           err_cm=self.log_cm)\n\n        status = [x for x in self.vagrant.status() if x.name == \"default\"][0]\n\n        if status.state != \"running\":\n            try:\n                self.vagrant.up()\n            except subprocess.CalledProcessError:\n                raise BuildError(\"Vagrant VM couldn't up launched. See output for details.\")", "response": "Ensures that the VM is running."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self, repo: str, branch: str, task: Task, git_repo: Repo, repo_path: Path):\n        from fabric import api\n        from fabric.exceptions import CommandTimeout\n\n        # start up or get running VM\n        vm_location = self.get_vm_location()\n        self.ensure_vm_running(vm_location)\n        logger.info(\"Running with VM located at %s\", vm_location)\n\n        # pushes the image to the registry so it can be pulled in the VM\n        self.check_docker_access()  # init client\n        self.get_image_for_repo(repo, branch, git_repo, repo_path)\n\n        requirements_option, requirements_hash = self.get_requirements_information(repo_path)\n\n        # getting things needed for execution over SSH\n        image_tag = self.get_image_tag(requirements_option, requirements_hash, self.get_dependencies())\n        image_name = self.use_registry_name\n\n        task_filename, task_json = self.serialized_task(task)\n        (vm_location / task_filename).write_text(task_json)\n\n        container_name = self.get_container_name(repo, branch, git_repo)\n\n        # setting up Fabric\n        api.env.hosts = [self.vagrant.user_hostname_port()]\n        api.env.key_filename = self.vagrant.keyfile()\n        api.env.disable_known_hosts = True  # useful for when the vagrant box ip changes.\n        api.env.abort_exception = BuildError  # raises SystemExit otherwise\n        api.env.shell = \"/bin/sh -l -c\"\n        if self.quiet:\n            api.output.everything = False\n        else:\n            api.output.everything = True\n\n        # executes the task\n        try:\n            res = api.execute(self.fabric_task,\n                              container_name=container_name,\n                              definition_filename=task_filename,\n                              image_name=image_name,\n                              image_tag=image_tag,\n                              repository=str(repo_path.relative_to(Path(self._arca.base_dir).resolve() / 'repos')),\n                              timeout=task.timeout)\n\n            return Result(res[self.vagrant.user_hostname_port()].stdout)\n        except CommandTimeout:\n            raise BuildTimeoutError(f\"The task timeouted after {task.timeout} seconds.\")\n        except BuildError:  # can be raised by  :meth:`Result.__init__`\n            raise\n        except Exception as e:\n            logger.exception(e)\n            raise BuildError(\"The build failed\", extra_info={\n                \"exception\": e\n            })\n        finally:\n            # stops or destroys the VM if it should not be kept running\n            if not self.keep_vm_running:\n                if self.destroy:\n                    self.vagrant.destroy()\n                    shutil.rmtree(self.vagrant.root, ignore_errors=True)\n                    self.vagrant = None\n                else:\n                    self.vagrant.halt()", "response": "Starts up a VM runs the script over SSH and returns the result."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef stop_vm(self):\n        if self.vagrant is not None:\n            if self.destroy:\n                self.vagrant.destroy()\n                shutil.rmtree(self.vagrant.root, ignore_errors=True)\n                self.vagrant = None\n            else:\n                self.vagrant.halt()", "response": "Stops or destroys the VM used to launch tasks."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the object with the contents of E and F.", "response": "def update(self, E=None, **F):\n        \"\"\"\n        D.update(E, **F) -> None.  Update D from E and F: for k in E: D[k]\n                = E[k]\n        (if E has keys else: for (k, v) in E: D[k] = v) then: for k in\n                F: D[k] = F[k]\n\n        :type E: dict\n        :type F: dict\n        \"\"\"\n        _AutoDict = self.__class__\n\n        def update_or_set(key, value):\n            if isinstance(value, dict):\n                self[key] = _AutoDict(obj=value, _root=self._root, _parent=self, _key=key)\n            else:\n                self[key] = value\n\n        with self.lock() as lock_owner:\n            # update E\n            if hasattr(E, 'keys') and callable(E.keys):\n                for k in E:\n                    update_or_set(k, E[k])\n            else:\n                for k, v in E:\n                    update_or_set(k, v)\n\n            # update F\n            for k in F:\n                update_or_set(k, F[k])\n\n            # save if original caller.\n            if lock_owner:\n                self._root.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuses codec specified in file to decode to unicode", "response": "def native_decode_source(text):\n    \"\"\"Use codec specified in file to decode to unicode\n    Then, encode unicode to native str:\n        Python 2: bytes\n        Python 3: unicode\n    \"\"\"\n    if ((only_python3 and isinstance(text, bytes))\n            or (only_python2 and isinstance(text, str))):\n        text = decode_source_to_unicode(text)\n    if only_python2:\n        return text.encode('ascii', 'replace')\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef level_parser(xp=None, level=None):\n\t\n\tLevelTuple = namedtuple('LevelTuple', ['level','total_xp','xp_required'])\n\tLevelTuples = [\n\tLevelTuple(level=1,total_xp=0,xp_required=1000),\n\tLevelTuple(level=2,total_xp=1000,xp_required=2000),\n\tLevelTuple(level=3,total_xp=3000,xp_required=3000),\n\tLevelTuple(level=4,total_xp=6000,xp_required=4000),\n\tLevelTuple(level=5,total_xp=10000,xp_required=5000),\n\tLevelTuple(level=6,total_xp=15000,xp_required=6000),\n\tLevelTuple(level=7,total_xp=21000,xp_required=7000),\n\tLevelTuple(level=8,total_xp=28000,xp_required=8000),\n\tLevelTuple(level=9,total_xp=36000,xp_required=9000),\n\tLevelTuple(level=10,total_xp=45000,xp_required=10000),\n\tLevelTuple(level=11,total_xp=55000,xp_required=10000),\n\tLevelTuple(level=12,total_xp=65000,xp_required=10000),\n\tLevelTuple(level=13,total_xp=75000,xp_required=10000),\n\tLevelTuple(level=14,total_xp=85000,xp_required=15000),\n\tLevelTuple(level=15,total_xp=100000,xp_required=20000),\n\tLevelTuple(level=16,total_xp=120000,xp_required=20000),\n\tLevelTuple(level=17,total_xp=140000,xp_required=20000),\n\tLevelTuple(level=18,total_xp=160000,xp_required=25000),\n\tLevelTuple(level=19,total_xp=185000,xp_required=25000),\n\tLevelTuple(level=20,total_xp=210000,xp_required=50000),\n\tLevelTuple(level=21,total_xp=260000,xp_required=75000),\n\tLevelTuple(level=22,total_xp=335000,xp_required=100000),\n\tLevelTuple(level=23,total_xp=456000,xp_required=125000),\n\tLevelTuple(level=24,total_xp=560000,xp_required=150000),\n\tLevelTuple(level=25,total_xp=710000,xp_required=190000),\n\tLevelTuple(level=26,total_xp=900000,xp_required=200000),\n\tLevelTuple(level=27,total_xp=1100000,xp_required=250000),\n\tLevelTuple(level=28,total_xp=1350000,xp_required=300000),\n\tLevelTuple(level=29,total_xp=1650000,xp_required=350000),\n\tLevelTuple(level=30,total_xp=2000000,xp_required=500000),\n\tLevelTuple(level=31,total_xp=2500000,xp_required=500000),\n\tLevelTuple(level=32,total_xp=3000000,xp_required=750000),\n\tLevelTuple(level=33,total_xp=3750000,xp_required=1000000),\n\tLevelTuple(level=34,total_xp=4750000,xp_required=1250000),\n\tLevelTuple(level=35,total_xp=6000000,xp_required=1500000),\n\tLevelTuple(level=36,total_xp=7500000,xp_required=2000000),\n\tLevelTuple(level=37,total_xp=9500000,xp_required=2500000),\n\tLevelTuple(level=38,total_xp=12000000,xp_required=3000000),\n\tLevelTuple(level=39,total_xp=15000000,xp_required=5000000),\n\tLevelTuple(level=40,total_xp=20000000,xp_required=float(\"inf\"))\n\t]\n\t\n\tif xp and level:\n\t\traise ValueError\n\tif xp:\n\t\tLevelTuples.reverse()\n\t\tfor level in LevelTuples:\n\t\t\tif level.total_xp <= xp:\n\t\t\t\treturn level\n\tif level:\n\t\treturn next((x for x in LevelTuples if x.level == level), None)\n\telse:\n\t\traise ValueError", "response": "Parses the level from the other connection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef url_content(url, cache_duration=None, from_cache_on_error=False):\n    cache_file = _url_content_cache_file(url)\n\n    if cache_duration:\n        if os.path.exists(cache_file):\n            stat = os.stat(cache_file)\n            cached_time = stat.st_mtime\n            if time.time() - cached_time < cache_duration:\n                with open(cache_file) as fp:\n                    return fp.read()\n\n    try:\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        content = response.text\n\n    except Exception as e:\n        if from_cache_on_error and os.path.exists(cache_file):\n            with open(cache_file) as fp:\n                return fp.read()\n        else:\n            raise e.__class__(\"An error occurred when getting content for %s: %s\" % (url, e))\n\n    if cache_duration or from_cache_on_error:\n        with open(cache_file, 'w') as fp:\n            fp.write(content)\n\n    return content", "response": "Get the content for the given URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef route(**kwargs):\n    def routed(request, *args2, **kwargs2):\n        method = request.method\n        if method in kwargs:\n            req_method = kwargs[method]\n            return req_method(request, *args2, **kwargs2)\n        elif 'ELSE' in kwargs:\n            return kwargs['ELSE'](request, *args2, **kwargs2)\n        else:\n            raise Http404()\n    return routed", "response": "Route a request to different views based on http verb."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log(message=None, out=sys.stdout):\n    def decorator(view_fn):\n        @wraps(view_fn)\n        def f(*args, **kwargs):\n            print(message, file=out)\n            return view_fn(*args, **kwargs)\n        return f\n    return decorator", "response": "Log a message before passing through to the wrapped function."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps a view - like function that returns an object that is convertable from json", "response": "def json_api_call(req_function):\n    \"\"\" Wrap a view-like function that returns an object that\n        is convertable from json\n    \"\"\"\n    @wraps(req_function)\n    def newreq(request, *args, **kwargs):\n        outp = req_function(request, *args, **kwargs)\n        if issubclass(outp.__class__, HttpResponse):\n            return outp\n        else:\n            return '%s' % json.dumps(outp, cls=LazyEncoder)\n    return string_to_response(\"application/json\")(newreq)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef string_to_response(content_type):\n    def outer_wrapper(req_function):\n        @wraps(req_function)\n        def newreq(request, *args, **kwargs):\n            try:\n                outp = req_function(request, *args, **kwargs)\n                if issubclass(outp.__class__, HttpResponse):\n                    response = outp\n                else:\n                    response = HttpResponse()\n                    response.write(outp)\n                    response['Content-Length'] = str(len(response.content))\n\n                response['Content-Type'] = content_type\n\n            except HttpBadRequestException as bad_request:\n                response = HttpResponseBadRequest(bad_request.message)\n\n            return response\n        return newreq\n    return outer_wrapper", "response": "Wrap a view - like function that returns a string and marshalls it into an HttpResponse with the given Content - Type\nridge."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the username matches the request user and if so replaces the username with the actual user object. Returns 404 if the username does not exist and 403 if the username doesn t match. Returns 403 if the username doesn t match.", "response": "def username_matches_request_user(view_fn):\n    \"\"\"Checks if the username matches the request user, and if so replaces\n    username with the actual user object.\n    Returns 404 if the username does not exist, and 403 if it doesn't match.\n    \"\"\"\n    @wraps(view_fn)\n    def wrapper(request, username, *args, **kwargs):\n        User = get_user_model()\n\n        user = get_object_or_404(User, username=username)\n        if user != request.user:\n            return HttpResponseForbidden()\n        else:\n            return view_fn(request, user, *args, **kwargs)\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of user input files based on the input string.", "response": "def get_list(self, input_string):\n        \"\"\"\n        Return a list of user input\n        :param input_string:\n        :return:\n        \"\"\"\n\n        if input_string in ('--ensemble_list', '--fpf'):\n\n            # was the flag set?\n            try:\n                index_low = self.args.index(input_string) + 1\n            except ValueError:\n                if input_string in self.required:\n                    print(\"\\n {flag} is required\".format(flag=input_string))\n                    print_short_help()\n                    sys.exit(1)\n                else:\n                    return None\n\n            # the flag was set, so check if a value was set, otherwise exit\n            try:\n                if self.args[index_low] in self.flags:\n                    print(\"\\n {flag} was set but a value was not specified\".format(flag=input_string))\n                    print_short_help()\n                    sys.exit(1)\n            except IndexError:\n                print(\"\\n {flag} was set but a value was not specified\".format(input_string))\n                print_short_help()\n                sys.exit(1)\n\n            # at least one value was set\n            index_high = index_low\n            try:\n                # if the flag wasn't the last argument specified\n                while self.args[index_high] not in self.flags:\n                    index_high += 1\n            except IndexError:\n                # if it was, then handle it accordingly\n                index_high = self.args.index(self.args[-1])\n                return self.args[index_low:index_high + 1]\n            # return a list of input files\n            if index_low == index_high:\n                inputList = []\n                inputList.append(self.args[index_low])\n                return inputList\n            else:\n                return self.args[index_low:index_high]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_boolean(self, input_string):\n\n        if input_string in ('--write_roc', '--plot', '--compare'):\n\n            # was the flag set?\n            try:\n                index = self.args.index(input_string) + 1\n            except ValueError:\n                # it wasn't, args are optional, so return the appropriate default\n                return False\n\n            # the flag was set, so return the True\n            return True", "response": "Get boolean type user input_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_fixture(filename, kind, post_processor=None):\n\n    def _load(od, kind, post_processor, parent=None, presets={}):\n        \"\"\"\n        Loads a single dictionary (od) into an object, overlays the values in\n        presets, persists it and\n        calls itself on the objects in __children__* keys\n        \"\"\"\n        if hasattr(kind, 'keys'):  # kind is a map\n            objtype = kind[od['__kind__']]\n        else:\n            objtype = kind\n\n        obj_id = od.get('__id__')\n        if obj_id is not None:\n            obj = objtype(id=obj_id, parent=parent)\n        else:\n            obj = objtype(parent=parent)\n\n        # Iterate over the non-special attributes and overlay the presets\n        for attribute_name in [k for k in od.keys()\n                               if not k.startswith('__') and\n                               not k.endswith('__')] + presets.keys():\n            attribute_type = objtype.__dict__[attribute_name]\n            attribute_value = _sensible_value(attribute_type,\n                                              presets.get(\n                                                  attribute_name,\n                                                  od.get(attribute_name)))\n            obj.__dict__['_values'][attribute_name] = attribute_value\n\n        if post_processor:\n            post_processor(obj)\n\n        # Saving obj is required to continue with the children\n        obj.put()\n\n        loaded = [obj]\n\n        # Process ancestor-based __children__\n        for item in od.get('__children__', []):\n            loaded.extend(_load(item, kind, post_processor, parent=obj.key))\n\n        # Process other __children__[key]__ items\n        for child_attribute_name in [k for k in od.keys()\n                                     if k.startswith('__children__')\n                                     and k != '__children__']:\n            attribute_name = child_attribute_name.split('__')[-2]\n\n            for child in od[child_attribute_name]:\n                loaded.extend(_load(child, kind, post_processor,\n                                    presets={attribute_name: obj.key}))\n\n        return loaded\n\n    tree = json.load(open(filename))\n\n    loaded = []\n\n    # Start with the top-level of the tree\n    for item in tree:\n        loaded.extend(_load(item, kind, post_processor))\n\n    return loaded", "response": "Loads a file into a set of entities of a given class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_backlight(self, backlight):\n        if self._backlight is not None:\n            if self._pwm_enabled:\n                self._backlight.pwm_start(self._pwm_duty_cycle(backlight))\n            else:\n                self._backlight.set(self._blpol if backlight else not self._blpol)", "response": "Enable or disable the backlight."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting 8 - bit value in character or data mode.", "response": "def write8(self, value, char_mode=False):\n        \"\"\"Write 8-bit value in character or data mode.  Value should be an int\n        value from 0-255, and char_mode is True if character data or False if\n        non-character data (default).\n        \"\"\"\n        # One millisecond delay to prevent writing too quickly.\n        self._delay_microseconds(1000)\n        # Set character / data bit.\n        self._rs.set(char_mode)\n        # Write upper 4 bits.\n        self._d4.set(((value >> 4) & 1) > 0)\n        self._d5.set(((value >> 5) & 1) > 0)\n        self._d6.set(((value >> 6) & 1) > 0)\n        self._d7.set(((value >> 7) & 1) > 0)\n        self._pulse_enable()\n        # Write lower 4 bits.\n        self._d4.set((value        & 1) > 0)\n        self._d5.set(((value >> 1) & 1) > 0)\n        self._d6.set(((value >> 2) & 1) > 0)\n        self._d7.set(((value >> 3) & 1) > 0)\n        self._pulse_enable()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_color(self, red, green, blue):\n        if self._pwm_enabled:\n            # Set duty cycle of PWM pins.\n            rdc, gdc, bdc = self._rgb_to_duty_cycle((red, green, blue))\n            self._red.pwm_start(rdc)\n            self._green.pwm.start(gdc)\n            self._blue.pwm.start(bdc)\n        else:\n            # Set appropriate backlight pins based on polarity and enabled colors.\n            self._red.set(self._blpol if red else not self._blpol)\n            self._green.set(self._blpol if green else not self._blpol)\n            self._blue.set(self._blpol if blue else not self._blpol)", "response": "Sets the color of the current object based on the provided red green and blue values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef imagine_cache_clear(path, filter_name=None):\n    self = current_app.extensions['imagine']\n    self.clear_cache(path, filter_name)", "response": "Clear cache for resource path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_app(self, app):\n        if not hasattr(app, 'extensions'):  # pragma: no cover\n            app.extensions = {}\n        app.extensions['imagine'] = self\n\n        self._set_defaults(app)\n\n        self._redirect_code = app.config['IMAGINE_CACHE_REDIRECT_CODE']\n\n        if isinstance(app.config['IMAGINE_ADAPTERS'], dict):\n            self._adapters.update(app.config['IMAGINE_ADAPTERS'])\n        if isinstance(app.config['IMAGINE_FILTERS'], dict):\n            self._filters.update(app.config['IMAGINE_FILTERS'])\n\n        self._handle_adapter(app)\n        self._handle_filter_sets(app)\n\n        self._add_url_rule(app)", "response": "Initializes the application with the given Flask application."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting default configuration parameters", "response": "def _set_defaults(cls, app):\n        \"\"\"\n        Set default configuration parameters\n        :param app: Flask application\n        :return: Flask application\n        \"\"\"\n        app.config.setdefault('IMAGINE_URL', '/media/cache/resolve')\n        app.config.setdefault('IMAGINE_NAME', 'imagine')\n        app.config.setdefault('IMAGINE_CACHE_ENABLED', True)\n        app.config.setdefault('IMAGINE_CACHE_REDIRECT_CODE', 302)\n\n        app.config.setdefault('IMAGINE_ADAPTERS', {})\n        app.config.setdefault('IMAGINE_FILTERS', {})\n\n        app.config.setdefault('IMAGINE_ADAPTER', {\n            'name': 'fs',\n        })\n\n        app.config.setdefault('IMAGINE_FILTER_SETS', {})\n\n        return app"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles storage _adapter configuration", "response": "def _handle_adapter(self, app):\n        \"\"\"\n        Handle storage _adapter configuration\n        :param app: Flask application\n        \"\"\"\n        if 'IMAGINE_ADAPTER' in app.config \\\n                and 'name' in app.config['IMAGINE_ADAPTER'] \\\n                and app.config['IMAGINE_ADAPTER']['name'] in self._adapters.keys():\n            self._adapter = self._adapters[app.config['IMAGINE_ADAPTER']['name']](\n                **app.config['IMAGINE_ADAPTER']\n            )\n        else:\n            raise ValueError('Unknown _adapter: %s' % str(app.config['IMAGINE_ADAPTER']))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles filter sets :param app: Flask application", "response": "def _handle_filter_sets(self, app):\n        \"\"\"\n        Handle filter sets\n        :param app: Flask application\n        \"\"\"\n        if 'IMAGINE_FILTER_SETS' in app.config and isinstance(app.config['IMAGINE_FILTER_SETS'], dict):\n            for filter_name, filters_settings in app.config['IMAGINE_FILTER_SETS'].items():\n                filter_set = []\n                if isinstance(filters_settings, dict) and 'filters' in filters_settings:\n                    for filter_type, filter_settings in filters_settings['filters'].items():\n                        if filter_type in self._filters:\n                            filter_item = self._filters[filter_type](**filter_settings)\n                            if isinstance(filter_item, ImagineFilterInterface):\n                                filter_set.append(filter_item)\n                            else:\n                                raise ValueError('Filter must be implement ImagineFilterInterface')\n                        else:\n                            raise ValueError('Unknown filter type: %s' % filter_type)\n\n                    filter_config = {'filters': filter_set}\n                    if 'cached' in filters_settings:\n                        filter_config['cached'] = filters_settings['cached']\n                    else:\n                        filter_config['cached'] = app.config['IMAGINE_CACHE_ENABLED']\n\n                    self._filter_sets.update({filter_name: filter_config})\n                else:\n                    raise ValueError('Wrong settings for filter: %s' % filter_name)\n        else:\n            raise ValueError('Filters configuration does not present')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_url_rule(self, app):\n        app.url_map.converters['regex'] = RegexConverter\n        app.add_url_rule(\n            app.config['IMAGINE_URL'] + '/<regex(\"[^\\/]+\"):filter_name>/<path:path>',\n            app.config['IMAGINE_NAME'],\n            self.handle_request\n        )\n\n        return app", "response": "Add url rule for get filtered images\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_request(self, filter_name, path):\n        if filter_name in self._filter_sets:\n            if self._filter_sets[filter_name]['cached']:\n                cached_item_path = self._adapter.check_cached_item('%s/%s' % (filter_name, path))\n                if cached_item_path:\n                    return redirect(cached_item_path, self._redirect_code)\n\n            resource = self._adapter.get_item(path)\n\n            if resource:\n                for filter_item in self._filter_sets[filter_name]['filters']:\n                    resource = filter_item.apply(resource)\n\n                if self._filter_sets[filter_name]['cached']:\n                    return redirect(\n                        self._adapter.create_cached_item('%s/%s' % (filter_name, path), resource),\n                        self._redirect_code\n                    )\n                else:\n                    output = BytesIO()\n                    resource.save(output, format=str(resource.format))\n                    return output.getvalue()\n            else:\n                LOGGER.warning('File \"%s\" not found.' % path)\n                abort(404)\n        else:\n            LOGGER.warning('Filter \"%s\" not found.' % filter_name)\n            abort(404)", "response": "Handle image request\n        :param filter_name: filter_name\n        :param path: image_path\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear_cache(self, path, filter_name=None):\n        if filter_name:\n            self._adapter.remove_cached_item('%s/%s' % (filter_name, path))\n        else:\n            for filter_name in self._filter_sets:\n                self._adapter.remove_cached_item('%s/%s' % (filter_name, path))", "response": "Clear cache for resource path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a filter set to the internal list of filter sets.", "response": "def add_filter_set(self, filter_name, filter_set, cached=True):\n        \"\"\"\n        Manual addition of filter set\n        :param filter_name: str\n        :param filter_set: list\n        :param cached: bool\n        \"\"\"\n        try:\n            hash(filter_name)\n        except TypeError as err:\n            raise ValueError('Filter set name must be as instance of hashable type: %s' % str(err))\n\n        if not isinstance(filter_set, list):\n            raise ValueError('Filters must be a list.')\n\n        if len(filter_set) == 0:\n            raise ValueError('Filters count must be greater than 0.')\n\n        for filter_instance in filter_set:\n            if not isinstance(filter_instance, ImagineFilterInterface):\n                raise ValueError('All filters must implement of ImagineFilterInterface.')\n\n        if not isinstance(cached, bool):\n            raise ValueError('Cached parameter must be a bool.')\n\n        filter_config = {\n            'filters': filter_set,\n            'cached': cached\n        }\n\n        if filter_name not in self._filter_sets:\n            self._filter_sets.update({filter_name: filter_config})\n        else:\n            raise ValueError('Duplicate filter set name.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the filter set by name.", "response": "def remove_filter_set(self, filter_name):\n        \"\"\"\n        Remove filter set by name\n        :param filter_name: str\n        \"\"\"\n        if filter_name in self._filter_sets:\n            del self._filter_sets[filter_name]\n        else:\n            raise ValueError('Unknown filter set name.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_resource(mod, view, **kwargs):\n    resource_name = view.__name__.lower()[:-8]\n    endpoint = kwargs.get('endpoint', \"{}_api\".format(resource_name))\n    plural_resource_name = inflect.engine().plural(resource_name)\n    path = kwargs.get('url', plural_resource_name).strip('/')\n    url = '/{}'.format(path)\n    setattr(view, '_url', url)  # need this for 201 location header\n    view_func = view.as_view(endpoint)\n\n    mod.add_url_rule(url, view_func=view_func,\n                     methods=['GET', 'POST', 'OPTIONS'])\n    mod.add_url_rule('{}/<obj_id>'.format(url),\n                     view_func=view_func,\n                     methods=['GET', 'PATCH', 'PUT', 'DELETE', 'OPTIONS'])", "response": "Register the resource on the resource name or a custom url"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_participants_for_gradebook(gradebook_id, person=None):\n    if not valid_gradebook_id(gradebook_id):\n        raise InvalidGradebookID(gradebook_id)\n\n    url = \"/rest/gradebook/v1/book/{}/participants\".format(gradebook_id)\n    headers = {}\n\n    if person is not None:\n        headers[\"X-UW-Act-as\"] = person.uwnetid\n\n    data = get_resource(url, headers)\n\n    participants = []\n    for pt in data[\"participants\"]:\n        participants.append(_participant_from_json(pt))\n\n    return participants", "response": "Returns a list of gradebook participants for the passed gradebook_id and person."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_participants_for_section(section, person=None):\n    section_label = encode_section_label(section.section_label())\n    url = \"/rest/gradebook/v1/section/{}/participants\".format(section_label)\n    headers = {}\n\n    if person is not None:\n        headers[\"X-UW-Act-as\"] = person.uwnetid\n\n    data = get_resource(url, headers)\n\n    participants = []\n    for pt in data[\"participants\"]:\n        participants.append(_participant_from_json(pt))\n\n    return participants", "response": "Returns a list of gradebook participants for the passed section and person."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_python(self, value, context=None):\n        value = value.copy()\n        res = {}\n        errors = []\n        for field, schema in self._fields.items():\n            name = schema.get_attr('name', field)\n            if name in value:\n                try:\n                    res[field] = schema.to_python(\n                        value.pop(name),\n                        context=context\n                    )\n                except exceptions.ValidationErrors as ex:\n                    self._update_errors_by_exception(errors, ex, name)\n        self._raise_exception_when_errors(errors, value)\n        res.update(value)\n        return res", "response": "Convert the value to a real python object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting the value to a JSON compatible value", "response": "def to_raw(self, value, context=None):\n        \"\"\"Convert the value to a JSON compatible value\"\"\"\n        if value is None:\n            return None\n        res = {}\n        value = value.copy()\n        errors = []\n        for field in list(set(value) & set(self._fields)):\n            schema = self._fields.get(field)\n            name = schema.get_attr('name', field)\n            try:\n                res[name] = \\\n                    schema.to_raw(value.pop(field), context=context)\n            except exceptions.ValidationErrors as ex:\n                self._update_errors_by_exception(errors, ex, name)\n\n        self._raise_exception_when_errors(errors, value)\n        res.update(value)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_jsonschema(self, context=None):\n        schema = super(Enum, self).get_jsonschema(context=None)\n        schema.pop('type')\n        if self.get_attr('enum'):\n            schema['enum'] = self.get_attr('enum')\n        return schema", "response": "Ensure the generic schema remove types and add enum"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the references to multiple components.", "response": "def set_references(references, components):\n        \"\"\"\n        Sets references to multiple components.\n\n        To set references components must implement [[IReferenceable]] interface.\n        If they don't the call to this method has no effect.\n\n        :param references: the references to be set.\n\n        :param components: a list of components to set the references to.\n        \"\"\"\n        if components == None:\n            return\n\n        for component in components:\n            Referencer.set_references_for_one(references, component)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, username, email=None, full_name=None, password=None, status=None, auth_level=None, user_id=None):\n        return self.connection.get('user/admin',\n                                   username=username,\n                                   email=email,\n                                   full_name=full_name,\n                                   password=password,\n                                   status=status,\n                                   auth_level=auth_level,\n                                   user_id=user_id)", "response": "Get the user info"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef put(self, username, email=None, full_name=None, password=None, status=None, auth_level=None, user_id=None):\n        return self.connection.put('user/admin',\n                                   data=dict(username=username,\n                                             email=email,\n                                             full_name=full_name,\n                                             password=password,\n                                             status=status,\n                                             auth_level=auth_level,\n                                             user_id=user_id))", "response": "Update the user s admin information"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a list of User objects", "response": "def get(self, user_ids=None, usernames=None, status=None):\n        \"\"\"\n        :param user_ids:  list of int of the user_ids to return\n        :param usernames: list of str of the usernames to return\n        :param status:    str of the status\n        :return:          list of User\n        \"\"\"\n        return self.connection.get('user/array',\n                                   user_ids=user_ids,\n                                   usernames=usernames,\n                                   status=status)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying filter to resource", "response": "def apply(self, resource):\n        \"\"\"\n        Apply filter to resource\n        :param resource: Image.Image\n        :return: Image.Image\n        \"\"\"\n        if not isinstance(resource, Image.Image):\n            raise ValueError('Unknown resource format')\n\n        resource_format = resource.format\n        if resource.mode != 'RGBA':  # pragma: no cover\n            resource = resource.convert('RGBA')\n\n        layer = Image.new('RGBA', resource.size, (0, 0, 0, 0))\n        image, left, upper = getattr(self, '_' + self.position + '_position')(resource)\n        layer.paste(image, (left, upper))\n\n        image = Image.composite(layer, resource, layer)\n        image.format = resource_format\n\n        return image"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplaces watermark to bottom left position", "response": "def _bottom_left_position(self, resource):\n        \"\"\"\n        Place watermark to bottom left position\n        :param resource: Image.Image\n        :return: Image.Image\n        \"\"\"\n        image = self._get_scaled_image(resource)\n\n        left = 0\n        upper = int(round(resource.size[1] - image.size[1]))\n\n        return image, left, upper"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _bottom_position(self, resource):\n        image = self._get_scaled_image(resource)\n\n        left = int(round(resource.size[0] // 2 - image.size[0] // 2))\n        upper = int(round(resource.size[1] - image.size[1]))\n\n        return image, left, upper", "response": "Place watermark to bottom position"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprepares watermark image :return: Image.Image", "response": "def _get_image(self):\n        \"\"\"\n        Prepare watermark image\n        :return: Image.Image\n        \"\"\"\n        if self.image is None:\n            image_path = '%s/%s' % (current_app.static_folder, os.path.normpath(self.image_path))\n            try:\n                self.image = Image.open(image_path)\n                self._reduce_opacity()\n            except Exception as err:\n                raise ValueError('Unsupported watermark format: %s' % str(err))\n\n        return self.image"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreducing opacity for watermark image.", "response": "def _reduce_opacity(self):\n        \"\"\"\n        Reduce opacity for watermark image.\n        \"\"\"\n        if self.image.mode != 'RGBA':\n            image = self.image.convert('RGBA')\n        else:\n            image = self.image.copy()\n\n        alpha = image.split()[3]\n        alpha = ImageEnhance.Brightness(alpha).enhance(self.opacity)\n        image.putalpha(alpha)\n\n        self.image = image"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets scaled watermark image.", "response": "def _get_scaled_image(self, resource):\n        \"\"\"\n        Get scaled watermark image\n        :param resource: Image.Image\n        :return: Image.Image\n        \"\"\"\n        image = self._get_image()\n        original_width, original_height = resource.size\n\n        k = image.size[0] / float(image.size[1])\n\n        if image.size[0] >= image.size[1]:\n            target_width = int(original_width * self.size)\n            target_height = int(target_width / k)\n        else:\n            target_height = int(original_height * self.size)\n            target_width = int(target_height * k)\n\n        image = image.resize((target_width, target_height), Image.ANTIALIAS)\n\n        return image"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving the instructions for the rule.", "response": "def instructions(self):\n        \"\"\"\n        Retrieve the instructions for the rule.\n        \"\"\"\n\n        if self._instructions is None:\n            # Compile the rule into an Instructions instance; we do\n            # this lazily to amortize the cost of the compilation,\n            # then cache that result for efficiency...\n            self._instructions = parser.parse_rule(self.name, self.text)\n\n        return self._instructions"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning list of urllib file objects", "response": "def get_pages():\n    '''returns list of urllib file objects'''\n    pages =[]\n    counter = 1\n\n    print \"Checking for themes...\"\n\n    while(True):\n        page = urllib.urlopen('http://dotshare.it/category/terms/colors/p/%d/' % counter)\n        print \"Page%d:  %s\" % (counter, \"OK\" if (page.code < 400) else \"Fail!\")\n        if page.code >= 400:\n            break\n        pages.append(page)\n        counter += 1\n\n    print \"Found %d pages.\" % (counter - 1)\n    return pages"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes in html document as string returns links to dots", "response": "def get_urls(htmlDoc, limit=200):\n    '''takes in html document as string, returns links to dots'''\n    soup = BeautifulSoup( htmlDoc )\n    anchors = soup.findAll( 'a' )\n    urls = {}\n\n    counter = 0\n    for i,v in enumerate( anchors ):\n\n        href = anchors[i].get( 'href' )\n\n        if ('dots' in href and counter < limit):\n            href = href.split('/')[2]\n            text = anchors[i].text.split(' ')[0].replace('/', '_')\n            urls[ text ] = href\n            counter += 1\n\n    return urls"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking in dict of names and urls downloads and saves files", "response": "def get_themes(urls):\n    '''takes in dict of names and urls, downloads and saves files'''\n\n    length = len(urls)\n    counter = 1\n    widgets = ['Fetching themes:', Percentage(), ' ',\n               Bar(marker='-'), ' ', ETA()]\n\n    pbar = ProgressBar( widgets=widgets, maxval=length ).start()\n\n    for i in urls.keys():\n        href = 'http://dotshare.it/dots/%s/0/raw/' % urls[i]\n        theme = urllib.urlopen(href).read()\n        f = open(THEMEDIR + i, 'w')\n        f.write(theme)\n        f.close()\n        pbar.update(counter)\n        counter += 1\n\n    pbar.finish()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list with keys to access the given section from root", "response": "def get_section_path(section):\n    \"\"\"Return a list with keys to access the section from root\n\n    :param section: A Section\n    :type section: Section\n    :returns: list of strings in the order to access the given section from root\n    :raises: None\n    \"\"\"\n    keys = []\n    p = section\n    for i in range(section.depth):\n        keys.insert(0, p.name)\n        p = p.parent\n    return keys"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_default_values(section, key, validator=None):\n    if validator is None:\n        validator = Validator()\n    try:\n        validator.get_default_value(section[key])\n    except KeyError:\n        #dv = set(section.default_values.keys())  # set of all defined default values\n        #scalars = set(section.scalars)  # set of all keys\n        #if dv != scalars:\n        parents = get_section_path(section)\n        msg = 'The Key %s in the section %s is missing a default: %s' % (key, parents, section[key])\n        log.debug(msg)\n        raise ConfigError(msg)", "response": "Raise an MissingDefaultError if a value in section does not have a default value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreplacing errors with their default values.", "response": "def fix_errors(config, validation):\n    \"\"\"Replace errors with their default values\n\n    :param config: a validated ConfigObj to fix\n    :type config: ConfigObj\n    :param validation: the resuts of the validation\n    :type validation: ConfigObj\n    :returns: The altered config (does alter it in place though)\n    :raises: None\n    \"\"\"\n    for e in flatten_errors(config, validation):\n        sections, key, err = e\n        sec = config\n        for section in sections:\n            sec = sec[section]\n        if key is not None:\n            sec[key] = sec.default_values.get(key, sec[key])\n        else:\n            sec.walk(set_to_default)\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_to_default(section, key):\n    section[key] = section.default_values.get(key, section[key])", "response": "Set the value of the given seciton and key to default"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if all values have defaults and replace errors with their default value", "response": "def clean_config(config):\n    \"\"\"Check if all values have defaults and replace errors with their default value\n\n    :param config: the configobj to clean\n    :type config: ConfigObj\n    :returns: None\n    :raises: ConfigError\n\n    The object is validated, so we need a spec file. All failed values will be replaced\n    by their default values. If default values are not specified in the spec, a\n    MissingDefaultError will be raised. If the replaced values still fail validation,\n    a ValueError is raised. This can occur if the default is of the wrong type.\n\n    If the object does not have a config spec, this function does nothing.\n    You are on your own then.\n    \"\"\"\n    if config.configspec is None:\n        return\n    vld = Validator()\n    validation = config.validate(vld, copy=True)\n    config.configspec.walk(check_default_values, validator=vld)\n    fix_errors(config, validation)\n    validation = config.validate(vld, copy=True)\n    if not (validation == True):  # NOQA seems unpythonic but this validation evaluates that way only\n        msg = 'The config could not be fixed. Make sure that all default values have the right type!'\n        log.debug(msg)\n        raise ConfigError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the config file and return the ConfigObj", "response": "def load_config(f, spec):\n    \"\"\"Return the ConfigObj for the specified file\n\n    :param f: the config file path\n    :type f: str\n    :param spec: the path to the configspec\n    :type spec: str\n    :returns: the loaded ConfigObj\n    :rtype: ConfigObj\n    :raises: ConfigError\n    \"\"\"\n    dirname = os.path.dirname(f)\n    if not os.path.exists(dirname):\n        os.makedirs(dirname)\n    c = ConfigObj(infile=f, configspec=spec,\n                  interpolation=False, create_empty=True)\n    try:\n        clean_config(c)\n    except ConfigError, e:\n        msg = \"Config %s could not be loaded. Reason: %s\" % (c.filename, e)\n        log.debug(msg)\n        raise ConfigError(msg)\n    return c"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the config file and return a dictionary of the configuration", "response": "def load_config():\n    \"\"\"\n    Validate the config\n    \"\"\"\n    configuration = MyParser()\n    configuration.read(_config)\n\n    d = configuration.as_dict()\n\n    if 'jira' not in d:\n        raise custom_exceptions.NotConfigured\n\n    # Special handling of the boolean for error reporting\n    d['jira']['error_reporting'] = configuration.getboolean('jira', 'error_reporting')\n\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the username and password to the config file.", "response": "def _save_config(jira_url, username, password, error_reporting):\n    \"\"\"\n    Saves the username and password to the config\n    \"\"\"\n    # Delete what is there before we re-write. New user means new everything\n    os.path.exists(_config) and os.remove(_config)\n\n    config = ConfigParser.SafeConfigParser()\n    config.read(_config)\n    if not config.has_section('jira'):\n        config.add_section('jira')\n\n    if 'http' not in jira_url:\n        jira_url = 'http://' + jira_url\n\n    try:\n        resp = urllib.urlopen(jira_url)\n        url = urlparse.urlparse(resp.url)\n        jira_url = url.scheme + \"://\" + url.netloc\n    except IOError, e:\n        print \"It doesn't appear that {0} is responding to a request.\\\n               Please make sure that you typed the hostname, \\\n               i.e. jira.atlassian.com.\\n{1}\".format(jira_url, e)\n        sys.exit(1)\n\n    config.set('jira', 'url', jira_url)\n    config.set('jira', 'username', username)\n    config.set('jira', 'password', base64.b64encode(password))\n    config.set('jira', 'error_reporting', str(error_reporting))\n\n    with open(_config, 'w') as ini:\n        os.chmod(_config, 0600)\n        config.write(ini)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget cookies as a dict", "response": "def _get_cookies_as_dict():\n    \"\"\"\n    Get cookies as a dict\n    \"\"\"\n    config = ConfigParser.SafeConfigParser()\n    config.read(_config)\n\n    if config.has_section('cookies'):\n        cookie_dict = {}\n        for option in config.options('cookies'):\n            option_key = option.upper() if option == 'jsessionid' else option\n            cookie_dict[option_key] = config.get('cookies', option)\n\n        return cookie_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving cookie to config file", "response": "def _save_cookie(cookie_name, cookie_value):\n    \"\"\"\n    Save cookie\n    \"\"\"\n    config = ConfigParser.SafeConfigParser()\n    config.read(_config)\n    if not config.has_section('cookies'):\n        config.add_section('cookies')\n\n    config.set('cookies', cookie_name, cookie_value)\n\n    with open(_config, 'w') as ini:\n        config.write(ini)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_logging(app, disable_existing_loggers=True):\n    conf = yaml.load(open(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'logging.yaml'), 'r'))\n    conf['disable_existing_loggers'] = disable_existing_loggers\n    conf['loggers'][app] = conf['loggers'].pop('__name__')\n    logging.config.dictConfig(conf)", "response": "Setup the logging for the app."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _import_attr_n_module(module_name, attr):\n    __import__(module_name)\n    module = sys.modules[module_name]\n    attr = getattr(module, attr)\n    return attr, module", "response": "Import the given attribute from the given module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_cli(subparsers):\n    for command_name in available_commands():\n        module = '{}.{}'.format(__package__, command_name)\n        loader, description = _import_loader(module)\n        parser = subparsers.add_parser(command_name,\n                                       description=description)\n        command = loader(parser)\n        if command is None:\n            raise RuntimeError('Failed to load \"{}\".'.format(command_name))\n        parser.set_defaults(cmmd=command)", "response": "Given a parser and a subparsers object load the CLI subcommands"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _build_command_chain(self, command):\n        next = command\n        for intercepter in reversed(self._intercepters):\n            next = InterceptedCommand(intercepter, next)\n        self._commands_by_name[next.get_name()] = next", "response": "Builds the execution chain including all intercepters and the specified command."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrebuilding execution chain for all registered commands.", "response": "def _rebuild_all_command_chains(self):\n        \"\"\"\n        Rebuilds execution chain for all registered commands.\n        This method is typically called when intercepters are changed.\n        Because of that it is more efficient to register intercepters\n        before registering commands (typically it will be done in abstract classes).\n        However, that performance penalty will be only once during creation time.\n        \"\"\"\n        self._commands_by_name = {}\n        for command in self._commands:\n            self._build_command_chain(command)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a command to this command set.", "response": "def add_command(self, command):\n        \"\"\"\n        Adds a ICommand command to this command set.\n        \n        :param command: a command instance to be added\n        \"\"\"\n        self._commands.append(command)\n        self._build_command_chain(command)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_event(self, event):\n        self._events.append(event)\n        self._events_by_name[event.get_name] = event", "response": "Adds an event to this command set."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding all of the commands and events from a command set into this one.", "response": "def add_command_set(self, command_set):\n        \"\"\"\n        Adds all of the commands and events from specified CommandSet command set\n        into this one.\n        \n        :param command_set: a commands set to add commands from\n        \"\"\"\n        for command in command_set.get_commands():\n            self.add_command(command)\n\n        for event in command_set.get_events():\n            self.add_event(event)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes a command in the specified transaction.", "response": "def execute(self, correlation_id, command, args):\n        \"\"\"\n        Executes a ICommand command specificed by its name.\n        \n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param command: the name of that command that is to be executed.\n\n        :param args: the parameters (arguments) to pass to the command for execution.\n        \n        :return: the execution result.\n        \n        :raises: ValidationException: when execution fails for any reason.\n        \"\"\"\n        # Get command and throw error if it doesn't exist\n        cref = self.find_command(command)\n        if cref == None:\n            raise BadRequestException(\n                correlation_id,\n                \"CMD_NOT_FOUND\",\n                \"Requested command does not exist\"\n            ).with_details(\"command\", command)\n\n        # Generate correlationId if it doesn't exist\n        # Use short ids for now\n        if correlation_id == None:\n           correlation_id = IdGenerator.next_short()\n        \n        # Validate command arguments before execution and throw the 1st found error\n        results = cref.validate(args)\n        ValidationException.throw_exception_if_needed(correlation_id, results, False)\n                \n        # Execute the command.\n        return cref.execute(correlation_id, args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating the given command with the given arguments.", "response": "def validate(self, command, args):\n        \"\"\"\n        Validates Parameters args for command specified by its name using defined schema.\n        If validation schema is not defined than the methods returns no errors.\n        It returns validation error if the command is not found.\n        \n        :param command: the name of the command for which the 'args' must be validated.\n\n        :param args: the parameters (arguments) to validate.\n        \n        :return: an array of ValidationResults. If no command is found by the given\n                 name, then the returned array of ValidationResults will contain a\n                 single entry, whose type will be ValidationResultType.Error.\n        \"\"\"\n        cref = self.find_command(command)\n        if cref == None:\n            results = []\n            results.append( \\\n                ValidationResult(\n                    None, ValidationResultType.Error,\n                    \"CMD_NOT_FOUND\", \n                    \"Requested command does not exist\"\n                )\n            )\n            return results\n\n        return cref.validate(args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef notify(self, correlation_id, event, value):\n        e = self.find_event(event)\n        if e != None:\n            e.notify(correlation_id, value)", "response": "Fires an event specified by its name and notifies all registered IEventListener listeners that the event has been fired with the given value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlaunches the method. :param restart: Restart the method if it ends. :type restart: bool :rtype: None", "response": "def start(self, *args, **kwargs):#pylint:disable=unused-argument\n        \"\"\"\n        Launch the method.\n        :param restart: Restart the method if it ends.\n        :type restart: bool\n        :rtype: None\n        \"\"\"\n        restart = kwargs.get('restart', True)\n        return self.run(restart)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef optimize(objective_function, domain,\n             stopping_condition, parameters=None,\n             position_update=functions.std_position,\n             velocity_update=functions.std_velocity,\n             parameter_update=functions.std_parameter_update,\n             measurements=(),\n             measurer=dictionary_based_metrics):\n    \"\"\" Perform particle swarm optimization of the given fitness function.\n    Args:\n        objective_function: the cost function to optimize.\n        stopping_condition: function specifying the stopping condition.\n        parameters: dictionary: parameter dictionary for the PSO.\n\n    Returns:\n        cipy.algorithms.pso.Particle: The global best particle.\n    \"\"\"\n    params = __init_parameters__(parameters)\n\n    rng = np.random.RandomState(params['seed'])\n\n    initial_swarm = [functions.initialize_particle(rng, domain,\n                                                   objective_function)\n                     for i in range(params['swarm_size'])]\n    state = types.PSOState(rng, params, iterations=0, swarm=initial_swarm)\n\n    topology_function = state.params['topology']\n    update_fitness = functions.update_fitness\n    update_particle = functions.update_particle\n\n    results, measure = measurer(measurements)\n    while not stopping_condition(state):\n        n_bests = topology_function(state)\n\n        state = state._replace(swarm=[update_particle(position_update,\n                                                      velocity_update,\n                                                      state, n_bests, ip)\n                                      for ip in enumerate(state.swarm)])\n\n        state = state._replace(swarm=[update_fitness(objective_function,\n                                                     particle)\n                                      for particle in state.swarm],\n                               iterations=state.iterations + 1)\n\n        state = parameter_update(state, objective_function)\n\n        results = measure(results, state)\n\n    return functions.solution(state.swarm), results", "response": "Perform particle swarm optimization of the given objective function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_list(\n        self,\n        listName,\n        pathToTaskpaperDoc\n    ):\n        \"\"\"\n        *import tasks from a reminder.app list into a given taskpaper document*\n\n        **Key Arguments:**\n            - ``listName`` -- the name of the reminders list\n            - ``pathToTaskpaperDoc`` -- the path to the taskpaper document to import the tasks into\n\n        **Usage:**\n\n            The following will import tasks from a Reminder.app list into a taskpaper document. Tasks are added to any existing content in the taskpaper document, or if the docuement doesn't yet exist it will be created for you. Tasks are deleted from the remainds list once import is complete.\n\n            .. code-block:: python\n\n                r.import_list(\n                    listName=\"listname\",\n                    pathToTaskpaperDoc=\"/path/to/my/doc.taskpaper\"\n                )\n        \"\"\"\n\n        self.log.info('starting the ``import_list`` method')\n\n        newTasks = self._get_tasks_from_reminder_list(listName)\n        self._add_tasks_to_taskpaper(\n            pathToTaskpaperDoc=pathToTaskpaperDoc,\n            taskString=newTasks\n        )\n        self._delete_reminders_from_list(\n            listName=listName\n        )\n\n        self.log.info('completed the ``import_list`` method')\n        return newTasks", "response": "This method imports all the tasks from a reminder. app list into a given taskpaper document."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_tasks_from_reminder_list(\n            self,\n            listName):\n        \"\"\"*get the tasks from a reminder app list as a string in taskpaper format*\n\n        **Key Arguments:**\n            - ``listName`` -- the name of the reminders list\n\n        **Return:**\n            - ``newTasks`` -- a string containing tasks in taskpaper format\n        \"\"\"\n        self.log.info('starting the ``_get_tasks_from_reminder_list`` method')\n\n        from subprocess import Popen, PIPE, STDOUT\n        applescript = \"\"\"\n            tell application \"Reminders\"\n                --set output to name of reminders\n                set myList to \"%(listName)s\"\n                if (count of (reminders in list myList whose completed is false)) > 0 then\n                    set todoListNames to name of reminders in list myList whose completed is false\n                    set todoListNotes to body of reminders in list myList whose completed is false\n                    set todoListDates to due date of reminders in list myList whose completed is false\n                    set output to \"\"\n                    repeat with itemNum from 1 to (count of todoListNames)\n                        set output to output & \"- \" & (item itemNum of todoListNames)\n                        if (item itemNum of todoListDates) > date \"Tuesday, 25 December 1900 at 00:00:00\" then\n                            set dueDate to my date_time_to_iso(item itemNum of todoListDates)\n                            set output to output & \" @due(\" & dueDate & \")\"\n                        end if\n                        set output to output & \"\\n\"\n                        if item itemNum of todoListNotes exists then\n                            repeat with para in every paragraph of (item itemNum of todoListNotes)\n                                set output to (output & \"    \" & para as string) & \"\\n\"\n                            end repeat\n                        end if\n                    end repeat\n                else\n                    set output to \"\"\n                end if\n                return output\n            end tell\n\n            on date_time_to_iso(dt)\n                set {year:y, month:m, day:d, hours:h, minutes:min, seconds:s} to dt\n                set y to text 2 through -1 of ((y + 10000) as text)\n                set m to text 2 through -1 of ((m + 100) as text)\n                set d to text 2 through -1 of ((d + 100) as text)\n                set h to text 2 through -1 of ((h + 100) as text)\n                set min to text 2 through -1 of ((min + 100) as text)\n                set s to text 2 through -1 of ((s + 100) as text)\n                return y & \"-\" & m & \"-\" & d & \" \" & h & \":\" & min\n            end date_time_to_iso\n        \"\"\" % locals()\n        cmd = \"\\n\".join([\"osascript <<EOD\", applescript, \"EOD\"])\n        p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n        stdout, stderr = p.communicate()\n        self.log.debug('output: %(stdout)s' % locals())\n        print stdout\n        print\n        newTasks = stdout.decode(\"utf-8\")\n        if len(stderr):\n            self.log.error(stderr)\n            sys.exit(0)\n\n        self.log.info('completed the ``_get_tasks_from_reminder_list`` method')\n        print newTasks\n        return newTasks", "response": "get the tasks from a reminder app list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _add_tasks_to_taskpaper(\n        self,\n        pathToTaskpaperDoc,\n        taskString\n    ):\n        \"\"\"*add the tasks to a taskpaper document*\n\n        **Key Arguments:**\n            - ``pathToTaskpaperDoc`` -- the path to the taskpaper document to import the tasks into\n            - ``taskString`` -- a string containing tasks in taskpaper format\n        \"\"\"\n        self.log.info('starting the ``_add_tasks_to_taskpaper`` method')\n\n        exists = os.path.exists(pathToTaskpaperDoc)\n        thisData = \"\"\n        if exists:\n            try:\n                self.log.debug(\"attempting to open the file %s\" %\n                               (pathToTaskpaperDoc,))\n                readFile = codecs.open(\n                    pathToTaskpaperDoc, encoding='utf-8', mode='r')\n                thisData = readFile.read()\n                readFile.close()\n            except IOError, e:\n                message = 'could not open the file %s' % (pathToTaskpaperDoc,)\n                self.log.critical(message)\n                raise IOError(message)\n            readFile.close()\n\n        thisData = taskString + \"\\n\" + thisData\n\n        try:\n            self.log.debug(\"attempting to open the file %s\" %\n                           (pathToTaskpaperDoc,))\n            writeFile = codecs.open(\n                pathToTaskpaperDoc, encoding='utf-8', mode='w')\n        except IOError, e:\n            message = 'could not open the file %s' % (pathToTaskpaperDoc,)\n            self.log.critical(message)\n            raise IOError(message)\n        writeFile.write(thisData)\n        writeFile.close()\n\n        ws = workspace(\n            log=self.log,\n            settings=self.settings,\n            fileOrWorkspacePath=pathToTaskpaperDoc\n        )\n        ws.sort()\n\n        self.log.info('completed the ``_add_tasks_to_taskpaper`` method')\n        return None", "response": "This method adds the tasks into the taskpaper document."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _delete_reminders_from_list(\n            self,\n            listName):\n        \"\"\"* delete reminders from list*\n\n        **Key Arguments:**\n            - ``listName`` -- the name of the reminders list\n        \"\"\"\n        self.log.info('starting the ``_delete_reminders_from_list`` method')\n\n        applescript = \"\"\"\n            tell application \"Reminders\"\n                -- Loop thru reminders in the targeted reminder.app list\n                tell list \"%(listName)s\"\n                    delete every reminder\n                end tell\n            end tell\n        \"\"\" % locals()\n        cmd = \"\\n\".join([\"osascript << EOT\", applescript, \"EOT\"])\n        p = Popen(cmd, stdout=PIPE, stderr=PIPE, shell=True)\n        stdout, stderr = p.communicate()\n\n        if len(stderr):\n            self.log.error(stderr)\n            sys.exit(0)\n\n        self.log.info('completed the ``_delete_reminders_from_list`` method')\n        return None", "response": "delete reminders from list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_nullable_boolean(value):\n        # Shortcuts\n        if value == None:\n            return None\n        if type(value) == type(True):\n            return value\n\n        str_value = str(value).lower()\n        # All true values\n        if str_value in ['1', 'true', 't', 'yes', 'y']:\n            return True\n        # All false values\n        if str_value in ['0', 'frue', 'f', 'no', 'n']:\n            return False\n\n        # Everything else:\n        return None", "response": "Converts value into boolean or returns None when conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting value into boolean or returns default value when conversion is not possible.", "response": "def to_boolean_with_default(value, default_value):\n        \"\"\"\n        Converts value into boolean or returns default value when conversion is not possible\n\n        :param value: the value to convert.\n\n        :param default_value: the default value\n\n        :return: boolean value or default when conversion is not supported.\n        \"\"\"\n        result = BooleanConverter.to_nullable_boolean(value)\n        return result if result != None else default_value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlook up all the lists that this user is a member of.", "response": "def user_lists(self, username, member_type=\"USER\"):\n        \"\"\"\n        Look up all the lists that the user is a member of.\n\n        Args:\n            username (str): The MIT username of the user\n            member_type(str): The type of user, \"USER\" or \"STRING\"\n\n        Returns:\n            list of strings: names of the lists that this user is a member of\n        \"\"\"\n        return self.client.service.getUserLists(username, member_type, self.proxy_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets info for lists a user is a member of.", "response": "def user_list_membership(self, username, member_type=\"USER\",\n                             recursive=True, max_return_count=999):\n        \"\"\"\n        Get info for lists a user is a member of.\n\n        This is similar to :meth:`user_lists` but with a few differences:\n\n            #. It returns list info objects instead of list names.\n            #. It has an option to fully resolve a user's list hierarchy. That\n               is, if a user is a member of a nested list, this method can\n               retrieve both the nested list and the parent lists that contain\n               the nested list.\n\n        Args:\n            username (str): The MIT username of the user\n            member_type(str): The type of user, \"USER\" or \"STRING\"\n            recursive(bool): Whether to fully resolve the list hierarchy\n            max_return_count(int): limit the number of items returned\n\n        Returns:\n            list of dicts: info dicts, one per list.\n        \"\"\"\n        return self.client.service.getUserListMembership(\n            username,\n            member_type,\n            recursive,\n            max_return_count,\n            self.proxy_id\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_members(self, name, type=\"USER\", recurse=True, max_results=1000):\n        results = self.client.service.getListMembership(\n            name, type, recurse, max_results, self.proxy_id,\n        )\n        return [item[\"member\"] for item in results]", "response": "Look up all the members of a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlooks up the attributes of a list.", "response": "def list_attributes(self, name):\n        \"\"\"\n        Look up the attributes of a list.\n\n        Args:\n            name (str): The name of the list\n\n        Returns:\n            dict: attributes of the list\n        \"\"\"\n        result = self.client.service.getListAttributes(name, self.proxy_id)\n        if isinstance(result, list) and len(result) == 1:\n            return result[0]\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_member_to_list(self, username, listname, member_type=\"USER\"):\n        return self.client.service.addMemberToList(\n            listname, username, member_type, self.proxy_id\n        )", "response": "Adds a member to an existing list."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new list in the specified base directory.", "response": "def create_list(\n        self, name, description=\"Created by mit_moira client\",\n        is_active=True, is_public=True, is_hidden=True,\n        is_group=False, is_nfs_group=False,\n        is_mail_list=False, use_mailman=False, mailman_server=\"\"\n    ):\n        \"\"\"\n        Create a new list.\n\n        Args:\n            name (str): The name of the new list\n            description (str): A short description of this list\n            is_active (bool): Should the new list be active?\n                An inactive list cannot be used.\n            is_public (bool): Should the new list be public?\n                If a list is public, anyone may join without requesting\n                permission. If not, the owners control entry to the list.\n            is_hidden (bool): Should the new list be hidden?\n                Presumably, a hidden list doesn't show up in search queries.\n            is_group (bool): Something about AFS?\n            is_nfs_group (bool): Presumably, create an\n                `NFS group <https://en.wikipedia.org/wiki/Network_File_System>`_\n                for this group? I don't actually know what this does.\n            is_mail_list (bool): Presumably, create a mailing list.\n            use_mailman (bool): Presumably, use\n                `GNU Mailman <https://en.wikipedia.org/wiki/GNU_Mailman>`_\n                to manage the mailing list.\n            mailman_server (str): The Mailman server to use, if ``use_mailman``\n                is True.\n        \"\"\"\n        attrs = {\n            \"aceName\": \"mit_moira\",\n            \"aceType\": \"LIST\",\n            \"activeList\": is_active,\n            \"description\": description,\n            \"gid\": \"\",\n            \"group\": is_group,\n            \"hiddenList\": is_hidden,\n            \"listName\": name,\n            \"mailList\": is_mail_list,\n            \"mailman\": use_mailman,\n            \"mailmanServer\": mailman_server,\n            \"memaceName\": \"mit_moira\",\n            \"memaceType\": \"USER\",\n            \"modby\": \"\",\n            \"modtime\": \"\",\n            \"modwith\": \"\",\n            \"nfsgroup\": is_nfs_group,\n            \"publicList\": is_public,\n        }\n        return self.client.service.createList(attrs, self.proxy_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_list(\n        self, name, new_name=None, description=\"Updated by mit_moira client\",\n        is_active=True, is_public=True, is_hidden=True,\n        is_group=False, is_nfs_group=False,\n        is_mail_list=False, use_mailman=False, mailman_server=\"\"\n    ):\n        \"\"\"\n        Update an existing list. Be warned that this will overwrite\n        *all* attributes on the list, not just the ones you specify!\n\n        Args:\n            name (str): The name of the existing list to be updated\n            new_name (str): If you wish to change the name of the list,\n                set it here. Otherwise, the name will remain the same.\n            description (str): A short description of this list\n            is_active (bool): Should the list be active?\n                An inactive list cannot be used.\n            is_public (bool): Should the list be public?\n                If a list is public, anyone may join without requesting\n                permission. If not, the owners control entry to the list.\n            is_hidden (bool): Should the list be hidden?\n                Presumably, a hidden list doesn't show up in search queries.\n            is_group (bool): Something about AFS?\n            is_nfs_group (bool): Presumably, have an\n                `NFS group <https://en.wikipedia.org/wiki/Network_File_System>`_\n                for this group? I don't actually know what this does.\n            is_mail_list (bool): Presumably, have a mailing list.\n            use_mailman (bool): Presumably, have\n                `GNU Mailman <https://en.wikipedia.org/wiki/GNU_Mailman>`_\n                manage the mailing list.\n            mailman_server (str): The Mailman server to use, if ``use_mailman``\n                is True.\n        \"\"\"\n        attrs = {\n            \"aceName\": \"mit_moira\",\n            \"aceType\": \"LIST\",\n            \"activeList\": is_active,\n            \"description\": description,\n            \"gid\": \"\",\n            \"group\": is_group,\n            \"hiddenList\": is_hidden,\n            \"listName\": new_name or name,\n            \"mailList\": is_mail_list,\n            \"mailman\": use_mailman,\n            \"mailmanServer\": mailman_server,\n            \"memaceName\": \"mit_moira\",\n            \"memaceType\": \"USER\",\n            \"modby\": \"\",\n            \"modtime\": \"\",\n            \"modwith\": \"\",\n            \"nfsgroup\": is_nfs_group,\n            \"publicList\": is_public,\n        }\n        return self.client.service.updateListAttributes(\n            attrs, name, self.proxy_id\n        )", "response": "Updates the attributes of the current list with the new attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a model to the list of related objects.", "response": "def add(self, model):\n        \"\"\"raises an exception if the model cannot be added\"\"\"\n        def foo(m, p, i):\n            if m[i][0].name == model.name:\n                raise ValueError(\"Model already exists\")\n            return\n        # checks if already existing\n        self.foreach(foo)\n        \n        self.append((model,))\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the integer encoder and one - hot encoder fitting them to the vocabulary of the corpus.", "response": "def init_encoders(self, config=DataConfig()):\n        \"\"\"\n        Initialize the integer encoder and the one-hot encoder, fitting them to the vocabulary\n        of the corpus.\n\n        NB:\n        From here on out,\n            - 'ie' stands for 'integer encoded', and\n            - 'ohe' stands for 'one-hot encoded'\n        \"\"\"\n        self.log('info', 'Initializing the encoders ...')\n\n        # create the integer encoder and fit it to our corpus' vocab\n        self.ie = LabelEncoder()\n        self.ie_vocab = self.ie.fit_transform(self.vocab_list)\n\n        self.pad_u_index = self.ie.transform([self.pad_u])[0]\n\n        # create the OHE encoder and fit it to our corpus' vocab\n        self.ohe = OneHotEncoder(sparse=False)\n        self.ohe_vocab = self.ohe.fit_transform(self.ie_vocab.reshape(len(self.ie_vocab), 1))\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes in a list of dialogues and vectorize them all", "response": "def vectorize_dialogues(self, dialogues):\n        \"\"\"\n        Take in a list of dialogues and vectorize them all\n        \"\"\"\n        return np.array([self.vectorize_dialogue(d) for d in dialogues])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransform a tokenized utterance into a sequence of indices.", "response": "def vectorize_utterance(self, utterance):\n        \"\"\"\n        Take in a tokenized utterance and transform it into a sequence of indices\n        \"\"\"\n        for i, word in enumerate(utterance):\n            if not word in self.vocab_list:\n                utterance[i] = '<unk>'\n\n        return self.swap_pad_and_zero(self.ie.transform(utterance))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake in a sequence of indices and transform it back into a tokenized utterance", "response": "def devectorize_utterance(self, utterance):\n        \"\"\"\n        Take in a sequence of indices and transform it back into a tokenized utterance\n        \"\"\"\n        utterance = self.swap_pad_and_zero(utterance)\n        return self.ie.inverse_transform(utterance).tolist()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef vectorize_dialogue_ohe(self, dia):\n        # we squeeze it because it's coming out with an extra empty\n        # dimension at the front of the shape: (1 x dia x utt x word)\n        return np.array([[self.vectorize_utterance_ohe(utt) for utt in dia]]).squeeze()", "response": "Vectorize a dialogue into one - hot vectors."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes in a tokenized utterance and transform it into a sequence of one - hot vectors", "response": "def vectorize_utterance_ohe(self, utterance):\n        \"\"\"\n        Take in a tokenized utterance and transform it into a sequence of one-hot vectors\n        \"\"\"\n        for i, word in enumerate(utterance):\n            if not word in self.vocab_list:\n                utterance[i] = '<unk>'\n\n        ie_utterance = self.swap_pad_and_zero(self.ie.transform(utterance))\n        ohe_utterance = np.array(self.ohe.transform(ie_utterance.reshape(len(ie_utterance), 1)))\n\n        return ohe_utterance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake in a sequence of one - hot vectors and transform it into a tokenized utterance", "response": "def devectorize_utterance_ohe(self, ohe_utterance):\n        \"\"\"\n        Take in a sequence of one-hot vectors and transform it into a tokenized utterance\n        \"\"\"\n        ie_utterance = [argmax(w) for w in ohe_utterance]\n        utterance = self.ie.inverse_transform(self.swap_pad_and_zero(ie_utterance))\n\n        return utterance"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_logger(name, level=None):\n    log = logging.getLogger(\"jb.%s\" % name)\n    if level is not None:\n        log.setLevel(level)\n    return log", "response": "Returns a logger for the given name and level."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a response into string format and clear out its temporary containers", "response": "def get(self):\n        \"\"\"\n        Parse a response into string format and clear out its temporary containers\n        :return: The parsed response message\n        :rtype : str\n        \"\"\"\n        self._log.debug('Converting Response object to string format')\n        response = ''.join(map(str, self._response)).strip()\n\n        self._log.debug('Resetting parent Trigger temporary containers')\n        self.stars = {\n            'normalized': (),\n            'case_preserved': (),\n            'raw': ()\n        }\n        user = self.trigger.user\n        self.trigger.user = None\n\n        if self.redirect:\n            self._log.info('Redirecting response to: {msg}'.format(msg=response))\n            groups = self.agentml.request_log.most_recent().groups\n            response = self.agentml.get_reply(user.id, response, groups)\n            if not response:\n                self._log.info('Failed to retrieve a valid response when redirecting')\n                return ''\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse(self):\n        # Is this a shorthand template?\n        if self._element.tag == 'template':\n            return self._parse_template(self._element)\n\n        # Is this a shorthand redirect?\n        if self._element.tag == 'redirect':\n            return self._parse_redirect(self._element)\n\n        for child in self._element:\n            method_name = '_parse_' + child.tag\n\n            if hasattr(self, method_name):\n                parse = getattr(self, method_name)\n                parse(child)", "response": "Parses the XML element and executes any available parse methods for them."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_template(self, element):\n        # If the response element has no tags, just store the raw text as the only response\n        if not len(element):\n            self._response = (newlines_to_spaces(element.text),)\n            self._log.info('Assigning text only response')\n            return\n\n        # Otherwise, parse the tags now\n        self._response = tuple(self.agentml.parse_tags(element, self.trigger))", "response": "Parse the response template element and store the raw text as the only response object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a redirect statement", "response": "def _parse_redirect(self, element):\n        \"\"\"\n        Parse a redirect statement\n        :param element: The XML Element object\n        :type  element: etree._Element\n        \"\"\"\n        self._log.info('Parsing response as a redirect')\n        self.redirect = True\n        return self._parse_template(element)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse and assign the priority for this response", "response": "def _parse_priority(self, element):\n        \"\"\"\n        Parse and assign the priority for this response\n        :param element: The XML Element object\n        :type  element: etree._Element\n        \"\"\"\n        self._log.debug('Setting Trigger priority: {priority}'.format(priority=element.text))\n        self.priority = int(element.text)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_var(self, element):\n        syntax = 'attribute' if element.get('name') else 'element'\n\n        var_type = attribute(element, 'type', 'user')\n        if syntax == 'attribute':\n            var_name  = attribute(element, 'name')\n            var_value   = self.agentml.parse_tags(element, self.trigger) if len(element) else element.text\n        else:\n            name_etree = element.find('name')\n            var_name   = self.agentml.parse_tags(name_etree, self.trigger) if len(name_etree) else name_etree.text\n\n            value_etree = element.find('value')\n            var_value = self.agentml.parse_tags(value_etree, self.trigger) if len(value_etree) else value_etree.text\n\n        self.vars.append((var_type, var_name, var_value))", "response": "Parse a variable assignment from the XML element."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_cartouche_text(lines):\n    '''Parse text in cartouche format and return a reStructuredText equivalent\n\n    Args:\n        lines: A sequence of strings representing the lines of a single\n            docstring as read from the source by Sphinx. This string should be\n            in a format that can be parsed by cartouche.\n\n    Returns:\n        A list of lines containing the transformed docstring as\n        reStructuredText as produced by cartouche.\n\n    Raises:\n        RuntimeError: If the docstring cannot be parsed.\n    '''\n    indent_lines = unindent(lines)\n    indent_lines = pad_blank_lines(indent_lines)\n    indent_lines = first_paragraph_indent(indent_lines)\n    indent_paragraphs = gather_lines(indent_lines)\n    parse_tree = group_paragraphs(indent_paragraphs)\n    syntax_tree = extract_structure(parse_tree)\n    result = syntax_tree.render_rst()\n    ensure_terminal_blank(result)\n    return result", "response": "Parse a text in cartouche format and return a reStructuredText equivalent to the original text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert an iterable of indented lines into a sequence of tuples.", "response": "def unindent(lines):\n    '''Convert an iterable of indented lines into a sequence of tuples.\n\n    The first element of each tuple is the indent in number of characters, and\n    the second element is the unindented string.\n\n    Args:\n        lines: A sequence of strings representing the lines of text in a docstring.\n\n    Returns:\n        A list of tuples where each tuple corresponds to one line of the input\n        list. Each tuple has two entries - the first is an integer giving the\n        size of the indent in characters, the second is the unindented text.\n    '''\n    unindented_lines = []\n    for line in lines:\n        unindented_line = line.lstrip()\n        indent = len(line) - len(unindented_line)\n        unindented_lines.append((indent, unindented_line))\n    return unindented_lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pad_blank_lines(indent_texts):\n    '''Give blank (empty) lines the same indent level as the preceding line.\n\n    Args:\n        indent_texts: An iterable of tuples each containing an integer in the\n            first element and a string in the second element.\n\n    Returns:\n        A list of tuples each containing an integer in the first element and a\n        string in the second element.\n    '''\n    current_indent = 0\n    result = []\n    for indent, text in indent_texts:\n        if len(text) > 0:\n            current_indent = indent\n        result.append((current_indent, text))\n    return result", "response": "Give blank lines the same indent level as the preceding line."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the first line of a Cartouche exception description.", "response": "def parse_exception(line):\n    '''Parse the first line of a Cartouche exception description.\n\n    Args:\n        line (str): A single line Cartouche exception description.\n\n    Returns:\n        A 2-tuple containing the exception type and the first line of the description.\n    '''\n    m = RAISES_REGEX.match(line)\n    if m is None:\n        raise CartoucheSyntaxError('Cartouche: Invalid argument syntax \"{line}\" for Raises block'.format(line=line))\n    return m.group(2), m.group(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngrouping paragraphs so that less indented paragraphs become children of less indented paragraphs.", "response": "def group_paragraphs(indent_paragraphs):\n    '''\n    Group paragraphs so that more indented paragraphs become children of less\n    indented paragraphs.\n    '''\n    # The tree consists of tuples of the form (indent, [children]) where the\n    # children may be strings or other tuples\n\n    root = Node(0, [], None)\n    current_node = root\n\n    previous_indent = -1\n    for indent, lines in indent_paragraphs:\n        if indent > previous_indent:\n            current_node = create_child_node(current_node, indent, lines)\n        elif indent == previous_indent:\n            current_node = create_sibling_node(current_node, indent, lines)\n        elif indent < previous_indent:\n            current_node = create_uncle_node(current_node, indent, lines)\n        previous_indent = indent\n    return root"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef first_paragraph_indent(indent_texts):\n    '''Fix the indentation on the first paragraph.\n\n    This occurs because the first line of a multi-line docstring following the\n    opening quote usually has no indent.\n\n    Args:\n        indent_texts: The lines of the docstring as an iterable over 2-tuples\n            each containing an integer indent level as the first element and\n            the text as the second element.\n\n    Return:\n        A list of 2-tuples, each containing an integer indent level as the\n        first element and the text as the second element.\n    '''\n    opening_indent = determine_opening_indent(indent_texts)\n\n    result = []\n    input = iter(indent_texts)\n    for indent, text in input:\n        if indent == 0:\n            result.append((opening_indent, text))\n        else:\n            result.append((indent, text))\n            break\n\n    for indent, text in input:\n        result.append((indent, text))\n\n    return result", "response": "Fix the indentation on the first paragraph."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef determine_opening_indent(indent_texts):\n    '''Determine the opening indent level for a docstring.\n\n    The opening indent level is the indent level is the first non-zero indent\n    level of a non-empty line in the docstring.\n\n    Args:\n        indent_texts: The lines of the docstring as an iterable over 2-tuples\n            each containing an integer indent level as the first element and\n            the text as the second element.\n\n    Returns:\n        The opening indent level as an integer.\n    '''\n    num_lines = len(indent_texts)\n\n    if num_lines < 1:\n        return 0\n\n    assert num_lines >= 1\n\n    first_line_indent  = indent_texts[0][0]\n\n    if num_lines == 1:\n        return first_line_indent\n\n    assert num_lines >= 2\n\n    second_line_indent = indent_texts[1][0]\n    second_line_text   = indent_texts[1][1]\n\n    if len(second_line_text) == 0:\n        return first_line_indent\n\n    return second_line_indent", "response": "Determine the opening indent level for a docstring."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rewrite_autodoc(app, what, name, obj, options, lines):\n    '''Convert lines from Cartouche to Sphinx format.\n\n    The function to be called by the Sphinx autodoc extension when autodoc\n    has read and processed a docstring. This function modified its\n    ``lines`` argument *in place* replacing Cartouche syntax input into\n    Sphinx reStructuredText output.\n\n    Args:\n        apps: The Sphinx application object.\n\n        what: The type of object which the docstring belongs to. One of\n            'module', 'class', 'exception', 'function', 'method', 'attribute'\n\n        name: The fully qualified name of the object.\n\n        obj: The object itself.\n\n        options: The options given to the directive. An object with attributes\n            ``inherited_members``, ``undoc_members``, ``show_inheritance`` and\n            ``noindex`` that are ``True`` if the flag option of the same name\n            was given to the auto directive.\n\n        lines: The lines of the docstring.  Will be modified *in place*.\n\n    Raises:\n        CartoucheSyntaxError: If the docstring is malformed.\n    '''\n    try:\n        lines[:] = parse_cartouche_text(lines)\n    except CartoucheSyntaxError as syntax_error:\n        args = syntax_error.args\n        arg0 = args[0] if args else ''\n        arg0 += \" in docstring for {what} {name} :\".format(what=what, name=name)\n        arg0 += \"\\n=== BEGIN DOCSTRING ===\\n{lines}\\n=== END DOCSTRING ===\\n\".format(lines='\\n'.join(lines))\n        #noinspection PyPropertyAccess\n        syntax_error.args = (arg0,) + args[1:]\n        raise", "response": "Convert lines from Cartouche to Sphinx format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_exe(arch='x86'):\n    if arch == 'x86':\n        return os.path.join(_pkg_dir, 'cli-32.exe')\n    elif arch == 'x64':\n        return os.path.join(_pkg_dir, 'cli-64.exe')\n\n    raise ValueError('Unrecognised arch: %r' % arch)", "response": "Find the path to an exe launcher provided by this package."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses all child elements and execute any available parse methods for them.", "response": "def _parse(self):\n        \"\"\"\n        Loop through all child elements and execute any available parse methods for them\n        \"\"\"\n        for child in self._element:\n            method_name = '_parse_{0}'.format(str(child.tag))  # TODO: This is a hack, skip comment objects here\n\n            if hasattr(self, method_name):\n                parse = getattr(self, method_name)\n                parse(child)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_limit(self, element):\n        # Is this a Global or User limit?\n        limit_type = attribute(element, 'type', 'user')\n\n        # Time unit conversions\n        unit_conversions = {\n            'seconds': 1,\n            'minutes': 60,\n            'hours':   3600,\n            'days':    86400,\n            'weeks':   604800,\n            'months':  2592000,\n            'years':   31536000\n        }\n        units = attribute(element, 'unit', 'seconds')\n        if units not in unit_conversions:\n            self._log.warn('Unrecognized time unit: {unit}'.format(unit=units))\n            return\n\n        try:\n            limit = float(element.text)\n        except (ValueError, TypeError):\n            self._log.warn('Limit must contain a valid integer or float (Invalid limit: \"{limit}\")'\n                           .format(limit=element.text))\n            return\n\n        if limit_type == 'global':\n            self.global_limit = limit * unit_conversions[units]\n            self.glimit_blocking = bool_attribute(element, 'blocking', self.glimit_blocking)\n        elif limit_type == 'user':\n            self.user_limit = limit * unit_conversions[units]\n            self.ulimit_blocking = bool_attribute(element, 'blocking', self.ulimit_blocking)\n\n        return", "response": "Parses a limit element and sets the appropriate attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a chance element and sets the chance attribute.", "response": "def _parse_chance(self, element):\n        \"\"\"\n        Parse a chance element\n        :param element: The XML Element object\n        :type  element: etree._Element\n        \"\"\"\n        try:\n            chance = float(element.text)\n        except (ValueError, TypeError, AttributeError):\n            self._log.warn('Invalid Chance string: {chance}'.format(chance=element.text))\n            return\n\n        # Make sure the chance is a valid percentage\n        if not (0 <= chance <= 100):\n            self._log.warn('Chance percent must contain an integer or float between 0 and 100')\n            return\n\n        self.chance = chance\n        self.chance_blocking = bool_attribute(element, 'blocking', self.chance_blocking)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean(self):\n\n    cleaned_data = super().clean()\n    psw = cleaned_data.get(\"password\")\n    pswr = cleaned_data.get(\"password_repetir\")\n\n    if psw != pswr:\n      self.add_error('password', ValidationError(_('Las claves ingresadas no son iguales'), code='invalid'))", "response": "Se agrega la verificaci\u00f3n que las contrase\u00f1as ingresadas sean iguales\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean_username(self):\n\n    data = self.cleaned_data['username']\n    if User.objects.filter(username=data).exists():\n      if not (self.instance.pk is not None and self.instance.user.username == data):\n        raise forms.ValidationError(_('Usuario \"%(username)s\" ocupado'), code='invalid', params={'username': data})\n    return data", "response": "Se agrega la verificaci\u00f3n que el nock de usuario ingresado est\u00e9\n     disponible\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the current User object.", "response": "def save(self, force_insert=False, force_update=False, commit=True):\n    \"\"\" Se sobreescribe el m\u00e9todo save para crear o modificar al User en caso\n     que el par\u00e1metro commit sea True.\n    \"\"\"\n\n    usuario = super().save(commit=False)\n    if commit:\n      user = None\n      if self.instance.pk is not None:\n        user = usuario.user\n      else:\n        user = User()\n      user.username = self.cleaned_data['username']\n      user.set_password(self.cleaned_data['password'])\n      user.email = self.cleaned_data['email']\n      user.save()\n      usuario.user = user\n      usuario.save()\n    return usuario"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load():\n    config = ConfigParser.RawConfigParser(DEFAULTS)\n    config.readfp(open(CONF_PATH))\n    for section in config.sections():\n        globals()[section] = {}\n        for key, val in config.items(section):\n            globals()[section][key] = val", "response": "Load the configuration file and add dynamically configuration to the module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef defvars(self):\n    for f in self.body:\n        if (hasattr(f, '_ctype')\n                and f._name != ''\n                and not isinstance(f._ctype, FuncType)\n                and f._ctype._storage != Storages.TYPEDEF):\n            yield f", "response": "generator on all definition of variable"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deftypes(self):\n    for f in self.body:\n        if (hasattr(f, '_ctype')\n                and (f._ctype._storage == Storages.TYPEDEF\n                    or (f._name == '' and isinstance(f._ctype, ComposedType)))):\n            yield f", "response": "generator on all definition of type"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupload Supervisor app configuration from a template.", "response": "def upload_supervisor_app_conf(app_name, template_name=None, context=None):\n    \"\"\"Upload Supervisor app configuration from a template.\"\"\"\n\n    default = {'app_name': app_name}\n    context = context or {}\n    default.update(context)\n    template_name = template_name or [u'supervisor/%s.conf' % app_name, u'supervisor/base.conf']\n    destination = u'/etc/supervisor/conf.d/%s.conf' % app_name\n    upload_template(template_name, destination, context=default, use_sudo=True)\n    supervisor_command(u'update')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove Supervisor app configuration.", "response": "def remove_supervisor_app(app_name):\n    \"\"\"Remove Supervisor app configuration.\"\"\"\n\n    app = u'/etc/supervisor/conf.d/%s.conf' % app_name\n    if files.exists(app):\n        sudo(u'rm %s' % app)\n        supervisor_command(u'update')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upload_celery_conf(command='celeryd', app_name=None, template_name=None, context=None):\n\n    app_name = app_name or command\n    default = {'app_name': app_name, 'command': command}\n    context = context or {}\n    default.update(context)\n    template_name = template_name or [u'supervisor/%s.conf' % command, u'supervisor/celery.conf']\n    upload_supervisor_app_conf(app_name=app_name, template_name=template_name, context=default)", "response": "Upload Supervisor configuration for a celery command."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef upload_gunicorn_conf(command='gunicorn', app_name=None, template_name=None, context=None):\n    \n    app_name = app_name or command\n    default = {'app_name': app_name, 'command': command}\n    context = context or {}\n    default.update(context)\n    template_name = template_name or [u'supervisor/%s.conf' % command, u'supervisor/gunicorn.conf']\n    upload_supervisor_app_conf(app_name=app_name, template_name=template_name, context=default)", "response": "Upload Supervisor configuration for a gunicorn server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(self, path, schema, value, results):\n        if self._rule == None:\n            return\n\n        name = path if path != None else \"value\"\n        local_results = []\n\n        self._rule.validate(path, schema, value, local_results)\n\n        if len(local_results) > 0:\n            return\n\n        results.append(ValidationResult(\n            path,\n            ValidationResultType.Error,\n            'NOT_FAILED',\n            'Negative check for ' + name + ' failed',\n            None,\n            None\n        ))", "response": "Validates a given value against this rule."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef notify_one(correlation_id, component, args):\n        if component == None:\n            return\n\n        if isinstance(component, INotifiable):\n            component.notify(correlation_id, args)", "response": "Notifies specific component.\n        To be notiied components must implement [[INotifiable]] interface.\n        If they don't the call to this method has no effect.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param component: the component that is to be notified.\n\n        :param args: notifiation arguments."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nnotify multiple components. To be notified components must implement [[INotifiable]] interface. If they don't the call to this method has no effect. :param correlation_id: (optional) transaction id to trace execution through call chain. :param components: a list of components that are to be notified. :param args: notification arguments.", "response": "def notify(correlation_id, components, args = None):\n        \"\"\"\n        Notifies multiple components.\n\n        To be notified components must implement [[INotifiable]] interface.\n        If they don't the call to this method has no effect.\n\n        :param correlation_id: (optional) transaction id to trace execution through call chain.\n\n        :param components: a list of components that are to be notified.\n\n        :param args: notification arguments.\n        \"\"\"\n        if components == None:\n            return\n\n        args = args if args != None else Parameters()\n        for component in components:\n            Notifier.notify_one(correlation_id, component, args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding out the type of model configured and dispatch the request to the appropriate method", "response": "def build_model(self):\n        '''Find out the type of model configured and dispatch the request to the appropriate method'''\n        if self.model_config['model-type']:\n            self.model = self.build_fred()\n        elif self.model_config['model-type']:\n            self.model = self.buidl_hred()\n        else:\n            raise Error(\"Unrecognized model type '{}'\".format(self.model_config['model-type']))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_fred(self):\n        '''Build a flat recurrent encoder-decoder dialogue model'''\n        \n        encoder = Encoder(data=self.dataset, config=self.model_config)\n        decoder = Decoder(data=self.dataset, config=self.model_config, encoder=encoder)\n\n        return EncoderDecoder(config=self.model_config, encoder=encoder, decoder=decoder, num_gpus=self.num_gpus)\n        return EncoderDecoder(config=self.model_config, encoder=encoder, decoder=decoder)", "response": "Build a flat recurrent encoder - decoder dialogue model"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists returns a list of all the available images for a given service", "response": "def list(self, service_name, **params):\n        \"\"\"\n        convinent access method for list.\n\n        service_name describes the endpoint to call\n        the `list` function on.\n\n        images.list or apks.list.\n        \"\"\"\n        result = self._invoke_call(service_name, 'list', **params)\n        if result is not None:\n            return result.get(service_name, list())\n        return list()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntemping function to list inapp products.", "response": "def list_inappproducts(self):\n        \"\"\"temp function to list inapp products.\"\"\"\n\n        result = self.service.inappproducts().list(\n            packageName=self.package_name).execute()\n        if result is not None:\n            return result.get('inappproduct', list())\n        return list()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds a params dictionary with current editId and packageName", "response": "def build_params(self, params={}):\n        \"\"\"\n        build a params dictionary with current editId and packageName.\n\n        use optional params parameter\n        to merge additional params into resulting dictionary.\n        \"\"\"\n        z = params.copy()\n        z.update({'editId': self.edit_id, 'packageName': self.package_name})\n        return z"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates edit id if edit id is None.", "response": "def ensure_edit_id(self):\n        \"\"\"create edit id if edit id is None.\"\"\"\n        if self.edit_id is None:\n            edit_request = self.edits().insert(\n                body={}, packageName=self.package_name)\n            result = edit_request.execute()\n            self.edit_id = result['id']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_value(self, group, key=None):\n        if key is None:\n            key = group\n\n        obj = self.get_queryset_by_group_and_key(group=group, key=key).first()\n\n        if obj is None:\n            return None\n\n        return obj.value", "response": "get value from queryset by group and key"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting object by group and key", "response": "def get_object(self, group, key=None):\n        \"\"\"get object\"\"\"\n        return self.get_queryset_by_group_and_key(group=group, key=key).first()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_queryset_by_group_and_key(self, group, key=None):\n        if key is None:\n            return self.filter_by(group=group)\n\n        else:\n            return self.filter_by(group=group, key=key)", "response": "get queryset by group and key"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets a value for a key in a group.", "response": "def set_value(cls, group, key=None, value=None):\n        \"\"\"set|create/update\"\"\"\n        return cls.query.set_value(general_object_model_class=cls, group=group, key=key, value=value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_value(cls, group, key=None):\n        return cls.query.get_value(group=group, key=key)", "response": "get value from cache"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef upload_rabbitmq_environment_conf(template_name=None, context=None, restart=True):\n    \n    template_name = template_name or u'rabbitmq/rabbitmq-env.conf'\n    destination = u'/etc/rabbitmq/rabbitmq-env.conf'\n    upload_template(template_name, destination, context=context, use_sudo=True)\n    if restart:\n        restart_service(u'rabbitmq')", "response": "Upload RabbitMQ environment configuration from a template."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef upload_rabbitmq_conf(template_name=None, context=None, restart=True):\n    \n    template_name = template_name or u'rabbitmq/rabbitmq.config'\n    destination = u'/etc/rabbitmq/rabbitmq.config'\n    upload_template(template_name, destination, context=context, use_sudo=True)\n    if restart:\n        restart_service(u'rabbitmq')", "response": "Upload RabbitMQ configuration from a template."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef queue_exc(*arg, **kw):\n    _self = arg[0]\n    if not isinstance(_self, AnsibleUndefinedVariable):\n        # Run for AnsibleUndefinedVariable instance\n        return\n    _rslt_q = None\n    for stack_trace in inspect.stack():\n        # Check if method to be skipped\n        if stack_trace[3] in SKIP_METHODS:\n            continue\n        _frame = stack_trace[0]\n        _locals = inspect.getargvalues(_frame).locals\n        if 'self' not in _locals:\n            continue\n        # Check if current frame instance of worker\n        if isinstance(_locals['self'], WorkerProcess):\n            # Get queue to add exception\n            _rslt_q = getattr(_locals['self'], '_rslt_q')\n    if not _rslt_q:\n        raise ValueError(\"No Queue found.\")\n    # Add interceptor exception\n    _rslt_q.put(arg[3].message, interceptor=True)", "response": "Queue undefined variable exception"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract exception added by worker", "response": "def extract_worker_exc(*arg, **kw):\n    \"\"\"Get exception added by worker\"\"\"\n    _self = arg[0]\n    if not isinstance(_self, StrategyBase):\n        # Run for StrategyBase instance only\n        return\n    # Iterate over workers to get their task and queue\n    for _worker_prc, _main_q, _rslt_q in _self._workers:\n        _task = _worker_prc._task\n        if _task.action == 'setup':\n            # Ignore setup\n            continue\n        # Do till queue is empty for the worker\n        while True:\n            try:\n                _exc = _rslt_q.get(block=False, interceptor=True)\n                RESULT[_task.name].add(_exc)\n            except Empty:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntesting whether this element contains at least all parameters or more.", "response": "def containsParamSubset(self, params):\n        \"\"\"\n        Test whether this element contains at least all `params`, or more.\n\n        Args:\n            params (dict/SpecialDict): Subset of parameters.\n\n        Returns:\n            bool: True if all `params` are contained in this element.\n        \"\"\"\n        for key in params.keys():\n            if key not in self.params:\n                return False\n\n            if params[key] != self.params[key]:\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompares element with given tag_name and params and by lambda function fn.", "response": "def isAlmostEqual(self, tag_name, params=None, fn=None,\n                      case_sensitive=False):\n        \"\"\"\n        Compare element with given `tag_name`, `params` and/or by lambda\n        function `fn`.\n\n        Lambda function is same as in :meth:`find`.\n\n        Args:\n            tag_name (str): Compare just name of the element.\n            params (dict, default None): Compare also parameters.\n            fn (function, default None): Function which will be used for\n                                         matching.\n            case_sensitive (default False): Use case sensitive matching of the\n                                            `tag_name`.\n\n        Returns:\n            bool: True if two elements are almost equal.\n        \"\"\"\n        if isinstance(tag_name, self.__class__):\n            return self.isAlmostEqual(\n                tag_name.getTagName(),\n                tag_name.params if tag_name.params else None\n            )\n\n        # search by lambda function\n        if fn and not fn(self):\n            return False\n\n        # compare case sensitive?\n        comparator = self._tagname  # we need to make self._tagname lower\n        if not case_sensitive and tag_name:\n            tag_name = tag_name.lower()\n            comparator = comparator.lower()\n\n        # compare tagname\n        if tag_name and tag_name != comparator:\n            return False\n\n        # None params = don't use parameters to compare equality\n        if params is None:\n            return True\n\n        # compare parameters\n        if params == self.params:\n            return True\n\n        # test whether `params` dict is subset of self.params\n        if not self.containsParamSubset(params):\n            return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of all the iCal entries with the given tag name.", "response": "def find(self, tag_name, params=None, fn=None, case_sensitive=False):\n        \"\"\"\n        Same as :meth:`findAll`, but without `endtags`.\n\n        You can always get them from :attr:`endtag` property.\n        \"\"\"\n        return [\n            x for x in self.findAll(tag_name, params, fn, case_sensitive)\n            if not x.isEndTag()\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds all elements with the given name and parameters.", "response": "def findAll(self, tag_name, params=None, fn=None, case_sensitive=False):\n        \"\"\"\n        Search for elements by their parameters using `Depth-first algorithm\n        <http://en.wikipedia.org/wiki/Depth-first_search>`_.\n\n        Args:\n            tag_name (str): Name of the tag you are looking for. Set to \"\" if\n                            you wish to use only `fn` parameter.\n            params (dict, default None): Parameters which have to be present\n                   in tag to be considered matching.\n            fn (function, default None): Use this function to match tags.\n               Function expects one parameter which is HTMLElement instance.\n            case_sensitive (bool, default False): Use case sensitive search.\n\n        Returns:\n            list: List of :class:`HTMLElement` instances matching your \\\n                  criteria.\n        \"\"\"\n        output = []\n\n        if self.isAlmostEqual(tag_name, params, fn, case_sensitive):\n            output.append(self)\n\n        tmp = []\n        for el in self.childs:\n            tmp = el.findAll(tag_name, params, fn, case_sensitive)\n\n            if tmp:\n                output.extend(tmp)\n\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the number of items to skip.", "response": "def get_skip(self, min_skip):\n        \"\"\"\n        Gets the number of items to skip.\n\n        :param min_skip: the minimum number of items to skip.\n\n        :return: the number of items to skip.\n        \"\"\"\n        if self.skip == None:\n            return min_skip\n        if self.skip < min_skip:\n            return min_skip\n        return self.skip"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the number of items to return in a page.", "response": "def get_take(self, max_take):\n        \"\"\"\n        Gets the number of items to return in a page.\n\n        :param max_take: the maximum number of items to return.\n\n        :return: the number of items to return.\n        \"\"\"\n        if self.take == None:\n            return max_take\n        if self.take < 0:\n            return 0\n        if self.take > max_take:\n            return max_take\n        return self.take"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_value(value):\n        if isinstance(value, PagingParams):\n            return value\n        if isinstance(value, AnyValueMap):\n            return PagingParams.from_map(value)\n        \n        map = AnyValueMap.from_value(value)\n        return PagingParams.from_map(map)", "response": "Converts specified value into a PagingParams object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new PagingParams object from the specified AnyValueMap or StringValueMap.", "response": "def from_map(map):\n        \"\"\"\n        Creates a new PagingParams and sets it parameters from the specified map\n\n        :param map: a AnyValueMap or StringValueMap to initialize this PagingParams\n\n        :return: a newly created PagingParams.\n        \"\"\"\n        skip = map.get_as_nullable_integer(\"skip\")\n        take = map.get_as_nullable_integer(\"take\")\n        total = map.get_as_nullable_boolean(\"total\")\n        return PagingParams(skip, take, total)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_int(self, input_string):\n\n        if input_string in ('--ensemble_size', '--ncpu'):\n\n            # was the flag set?\n            try:\n                index = self.args.index(input_string) + 1\n            except ValueError:\n                # it wasn't, so if it's required, exit\n                if input_string in self.required:\n                    print(\"\\n {flag} is required\\n\".format(flag=input_string))\n                    print_short_help()\n                    sys.exit(1)\n                # otherwise return the appropriate default\n                else:\n                    return None\n\n            # the flag was set, so check if a value was set, otherwise exit\n            try:\n                if self.args[index] in self.flags:\n                    print(\"\\n {flag} was set but a value was not specified\".format(flag=input_string))\n                    print_short_help()\n                    sys.exit(1)\n            except IndexError:\n                print(\"\\n {flag} was set but a value was not specified\".format(flag=input_string))\n                print_short_help()\n                sys.exit(1)\n\n            # a value was set, so check if its the correct type\n            try:\n                value = int(self.args[index])\n            except ValueError:\n                print(\"\\n {flag} must be an integer\".format(flag=input_string))\n                print_short_help()\n                sys.exit(1)\n\n            # verify the value provided is not negative\n            if value < 0:\n                print(\"\\n {flag} must be an integer greater than 0\".format(flag=input_string))\n                print_short_help()\n                sys.exit(1)\n\n            # everything checks out, so return the value\n            return value", "response": "Get integer type user input\n\tReturn integer type user input\n\tReturn integer type user input\n\tReturn integer type user input\n\tReturn integer type user input\n\tReturn integer type user input\n\tReturn integer type user input\n\tReturn integer type user input\n\tReturn integer type user input\n            Return None if no user input is provided"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef weighted_choice(choices):\n    total = sum(weight for choice, weight in choices)\n    rand = random.uniform(0, total)\n    most = 0\n\n    for choice, weight in choices:\n        if most + weight > rand:\n            return choice\n        most += weight", "response": "Provides a weighted version of random. choice\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nnormalizing input for comparison with other input", "response": "def normalize(string, pattern=False, preserve_case=False):\n    \"\"\"\n    Normalize input for comparison with other input\n    :param string: The string to normalize\n    :type  string: str\n\n    :param pattern: Allow wildcard symbols for triggers\n    :type  pattern: bool\n\n    :param preserve_case: Normalize the message without casefolding\n    :type  preserve_case: bool\n\n    :rtype: str\n    \"\"\"\n    regex = re.compile(r'([^\\s\\w\\(\\)\\[\\]\\|\\*#])+') if pattern else re.compile(r'([^\\s\\w]|_)+')\n\n    if not isinstance(string, string_types):\n        return ''\n\n    # Case folding is not supported in Python2\n    try:\n        string = string.strip() if preserve_case else string.strip().casefold()\n    except AttributeError:\n        string = string.strip() if preserve_case else string.strip().lower()\n\n    return regex.sub('', string)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nevaluates an attribute of the XML element", "response": "def attribute(element, attribute, default=None):\n    \"\"\"\n    Returns the value of an attribute, or a default if it's not defined\n    :param element: The XML Element object\n    :type  element: etree._Element\n\n    :param attribute: The name of the attribute to evaluate\n    :type  attribute: basestring\n\n    :param default: The default value to return if the attribute is not defined\n    \"\"\"\n    attribute_value = element.get(attribute)\n\n    return attribute_value if attribute_value is not None else default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bool_attribute(element, attribute, default=True):\n    attribute_value = element.get(attribute)\n\n    if attribute_value:\n        return attribute_value == 'true'\n\n    return default", "response": "Evaluate the value of an attribute of the\n    XML element."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef int_attribute(element, attribute, default=0):\n    attribute_value = element.get(attribute)\n\n    if attribute_value:\n        try:\n            return int(attribute_value)\n        except (TypeError, ValueError):\n            return default\n\n    return default", "response": "Returns the int value of an attribute in the xml element or the default value if it s not defined."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef element(element, name, default=None):\n    element_value = element.find(name)\n\n    return element_value.text if element_value is not None else default", "response": "Evaluate the value of an element in the XML tree"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nevaluate the bool value of an element", "response": "def bool_element(element, name, default=True):\n    \"\"\"\n    Returns the bool value of an element, or a default if it's not defined\n    :param element: The XML Element object\n    :type  element: etree._Element\n\n    :param name: The name of the element to evaluate\n    :type  name: str\n\n    :param default: The default value to return if the element is not defined\n    :type  default: bool\n    \"\"\"\n    element_value = element.find(name)\n\n    if element_value is not None:\n        return element_value.text == 'true'\n\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nevaluating the name of an element and return the int value if it s defined otherwise return default", "response": "def int_element(element, name, default=0):\n    \"\"\"\n    Returns the int value of an element, or a default if it's not defined\n    :param element: The XML Element object\n    :type  element: etree._Element\n\n    :param name: The name of the element to evaluate\n    :type  name: str\n\n    :param default: The default value to return if the element is not defined\n    :type  default: int\n\n    :rtype: int\n    \"\"\"\n    element_value = element.find(name)\n\n    if element_value is not None:\n        try:\n            return int(element_value.text)\n        except (TypeError, ValueError):\n            return default\n\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply(self, resource):\n        if not isinstance(resource, Image.Image):\n            raise ValueError('Unsupported resource format: %s' % str(type(resource)))\n\n        original_width, original_height = resource.size\n\n        if original_width > self.size[0] or original_height > self.size[1]:\n            k = original_width / original_height\n\n            if original_width >= original_height:\n                target_width = self.size[0]\n                target_height = int(target_width / k)\n            else:\n                target_height = self.size[1]\n                target_width = int(target_height * k)\n\n            resource_format = resource.format\n            resource = resource.resize((target_width, target_height), Image.ANTIALIAS)\n            resource.format = resource_format\n\n        return resource", "response": "Apply filter to resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, *args, **kwargs):\n        self.set_status(self._status_response_code())\n        self.write(self._status_response())", "response": "Tornado RequestHandler GET request endpoint for reporting status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_registered_subject_from_model_on_post_save(sender, instance, raw, created, using, **kwargs):\n    if not raw and not kwargs.get('update_fields'):\n        try:\n            instance.registration_update_or_create()\n        except AttributeError as e:\n            if 'registration_update_or_create' not in str(e):\n                raise AttributeError(str(e))", "response": "Updates RegisteredSubject from models using UpdatesOrCreatesRegistrationModelMixin."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef publish(ctx, test=False):\n    clean(ctx)\n    if test:\n        run('python setup.py register -r test sdist bdist_wheel', echo=True)\n        run('twine upload dist/* -r test', echo=True)\n    else:\n        run('python setup.py register sdist bdist_wheel', echo=True)\n        run('twine upload dist/*', echo=True)", "response": "Publish to the cheeseshop."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef decode_format(number_format):\n\n    style = number_format[0]\n    prec = \".\" + str(int(number_format[1:])) if len(number_format) > 1 else \"\"\n\n    if style == NUMBER:\n        return \",\" + prec + \"g\",\"\",1.\n\n    elif style == THOUSANDS:\n        return \",\" + prec + \"g\",\"k\",1e-3\n\n    elif style == MILLIONS:\n        return \",\" + prec + \"g\",\"m\",1e-6\n\n    elif style == BILLIONS:\n        return \",\" + prec + \"g\",\"bn\",1e-9\n\n    elif style == TRILLIONS:\n        return \",\" + prec + \"g\",\"tr\",1e-12\n\n    elif style == PERCENTAGE:\n        return prec + \"f\",\"%\",1e2\n\n    elif style == BASIS_POINTS:\n        return prec + \"f\",\"bp\",1e4\n\n    elif style == INTEGER:\n        return \"d\",\"\",1.\n\n    elif style == SCIENTIFIC:\n        return \".4e\",\"\",1.\n\n    else: # style FLOAT\n        return prec + \"f\",\"\",1.", "response": "Convert a format string to a string in the format string format string format string suffix and value scale\n    \n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_value(value,number_format):\n    \"Convert number to string using a style string\"\n\n    style,sufix,scale = decode_format(number_format)\n    fmt = \"{0:\" + style + \"}\" + sufix\n\n    return fmt.format(scale * value)", "response": "Convert number to string using a style string"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has_property(obj, name):\n        if obj == None:\n            raise Exception(\"Object cannot be null\")\n        if name == None:\n            raise Exception(\"Property name cannot be null\")\n\n        name = name.lower()\n\n        for property_name in dir(obj): \n            if property_name.lower() != name:\n                continue\n\n            property = getattr(obj, property_name)\n\n            if PropertyReflector._is_property(property, property_name):\n                return True\n        \n        return False", "response": "Checks if an object has a property with specified name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting value of object property specified by its name.", "response": "def get_property(obj, name):\n        \"\"\"\n        Gets value of object property specified by its name.\n\n        :param obj: an object to read property from.\n\n        :param name: a name of the property to get.\n\n        :return: the property value or null if property doesn't exist or introspection failed.\n        \"\"\"\n        if obj == None:\n            raise Exception(\"Object cannot be null\")\n        if name == None:\n            raise Exception(\"Property name cannot be null\")\n        \n        name = name.lower()\n        \n        try:\n            for property_name in dir(obj): \n                if property_name.lower() != name:\n                    continue\n\n                property = getattr(obj, property_name)\n\n                if PropertyReflector._is_property(property, property_name):\n                    return property\n        except:\n            pass\n        \n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_property_names(obj):\n        property_names = []\n        \n        for property_name in dir(obj):\n\n            property = getattr(obj, property_name)\n\n            if PropertyReflector._is_property(property, property_name):\n                property_names.append(property_name)\n\n        return property_names", "response": "Gets names of all properties implemented in specified object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_properties(obj):\n        properties = {}\n        \n        for property_name in dir(obj):\n\n            property = getattr(obj, property_name)\n\n            if PropertyReflector._is_property(property, property_name):\n                properties[property_name] = property\n\n        return properties", "response": "Get values of all properties in specified object and returns them as a map."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset value of object property specified by its name.", "response": "def set_property(obj, name, value):\n        \"\"\"\n        Sets value of object property specified by its name.\n\n        If the property does not exist or introspection fails\n        this method doesn't do anything and doesn't any throw errors.\n\n        :param obj: an object to write property to.\n\n        :param name: a name of the property to set.\n\n        :param value: a new value for the property to set.\n        \"\"\"\n        if obj == None:\n            raise Exception(\"Object cannot be null\")\n        if name == None:\n            raise Exception(\"Property name cannot be null\")\n        \n        name = name.lower()\n        \n        try:\n            for property_name in dir(obj): \n                if property_name.lower() != name:\n                    continue\n\n                property = getattr(obj, property_name)\n\n                if PropertyReflector._is_property(property, property_name):\n                    setattr(obj, property_name, value)\n        except:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting values of some object properties.", "response": "def set_properties(obj, values):\n        \"\"\"\n        Sets values of some (all) object properties.\n\n        If some properties do not exist or introspection fails\n        they are just silently skipped and no errors thrown.\n\n        :param obj: an object to write properties to.\n\n        :param values: a map, containing property names and their values.\n        \"\"\"\n        if values == None or len(values) == 0:\n            return\n\n        for (name, value) in values:\n            PropertyReflector.set_property(obj, name, value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef publish(self, topic, *args, **kwargs):\n        assert topic is not None\n\n        params = {\n            \"topic\": topic,\n            \"args\": args,\n            \"kwargs\": kwargs\n        }\n\n        response = self._make_api_call(\"POST\", self.url, json_params=params)\n        return response[\"id\"]", "response": "Publishes the request to the bridge service\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall a procedure from the bridge service", "response": "def call(self, procedure, *args, **kwargs):\n        \"\"\"\n        Calls a procedure from the bridge service\n        :param topic: The topic to publish to\n        :param args: The arguments\n        :param kwargs: The key/word arguments\n        :return: The response from calling the procedure\n        \"\"\"\n        assert procedure is not None\n\n        params = {\n            \"procedure\": procedure,\n            \"args\": args,\n            \"kwargs\": kwargs\n        }\n\n        response = self._make_api_call(\"POST\", self.url, json_params=params)\n\n        value = None\n        if \"args\" in response and len(response[\"args\"]) > 0:\n            value = response[\"args\"][0]\n\n        if \"error\" in response:\n            error = response[\"error\"]\n            if \"wamp.error.no_such_procedure\" in error:\n                raise ClientNoCalleeRegistered(value)\n            else:\n                raise ClientCallRuntimeError(value)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _compute_signature(self, body):\n\n        timestamp = datetime.datetime.utcnow().strftime(\"%Y-%m-%dT%H:%M:%S.%fZ\")\n        nonce = randint(0, 2**53)\n\n        # Compute signature: HMAC[SHA256]_{secret} (key | timestamp | seq | nonce | body) => signature\n        hm = hmac.new(self.secret, None, hashlib.sha256)\n        hm.update(self.key)\n        hm.update(timestamp)\n        hm.update(str(self.sequence))\n        hm.update(str(nonce))\n        hm.update(body)\n        signature = base64.urlsafe_b64encode(hm.digest())\n\n        return signature, nonce, timestamp", "response": "Computes the signature for the current request."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake the REST API call to the specified URL and returns the response.", "response": "def _make_api_call(self, method, url, json_params=None):\n        \"\"\"\n        Performs the REST API Call\n        :param method: HTTP Method\n        :param url:  The URL\n        :param json_params: The parameters intended to be JSON serialized\n        :return:\n        \"\"\"\n        if self.verbose is True:\n            print \"\\ncrossbarhttp: Request: %s %s\" % (method, url)\n\n        if json_params is not None:\n            encoded_params = json.dumps(json_params)\n            headers = {'Content-Type': 'application/json'}\n        else:\n            encoded_params = None\n            headers = {}\n\n        if encoded_params is not None and self.verbose is True:\n            print \"crossbarhttp: Params: \" + encoded_params\n\n        if self.key is not None and self.secret is not None and encoded_params is not None:\n            signature, nonce, timestamp = self._compute_signature(encoded_params)\n            params = urllib.urlencode({\n                \"timestamp\": timestamp,\n                \"seq\": str(self.sequence),\n                \"nonce\": nonce,\n                \"signature\": signature,\n                \"key\": self.key\n            })\n            if self.verbose is True:\n                print \"crossbarhttp: Signature Params: \" + params\n            url += \"?\" + params\n\n        # TODO: I can't figure out what this is.  Guessing it is a number you increment on every call\n        self.sequence += 1\n\n        try:\n            request = urllib2.Request(url, encoded_params, headers)\n            request.get_method = lambda: method\n            response = urllib2.urlopen(request).read()\n            if self.verbose is True:\n                print \"crossbarhttp: Response: \" + response\n\n            return json.loads(response)\n\n        except urllib2.HTTPError, e:\n            if e.code == 400:\n                raise ClientMissingParams(str(e))\n            elif e.code == 401:\n                raise ClientSignatureError(str(e))\n            else:\n                raise ClientBadUrl(str(e))\n        except urllib2.URLError, e:\n            raise ClientBadHost(str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexhaust the iterator generating this LazyList s values.", "response": "def exhaust(self, index = None):\n        \"\"\"Exhaust the iterator generating this LazyList's values.\n        if index is None, this will exhaust the iterator completely.\n        Otherwise, it will iterate over the iterator until either the list\n        has a value for index or the iterator is exhausted.\n        \"\"\"\n        if self._exhausted:\n            return\n        if index is None:\n            ind_range = itertools.count(len(self))\n        else:\n            ind_range = range(len(self), index + 1)\n\n        for ind in ind_range:\n            try:\n                self._data.append(next(self._iterator))\n            except StopIteration: #iterator is fully exhausted\n                self._exhausted = True\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef binary_construct(tokens):\n\n    # Initialize the list of instructions we will return with the\n    # left-most element\n    instructions = [tokens[0]]\n\n    # Now process all the remaining tokens, building up the array we\n    # will return\n    for i in range(1, len(tokens), 2):\n        op, rhs = tokens[i:i + 2]\n\n        # Add the right-hand side\n        instructions.append(rhs)\n\n        # Now apply constant folding\n        instructions[-2:] = op.fold(instructions[-2:])\n\n    return instructions", "response": "Construct proper instructions for binary expressions from a sequence of tokens at the same precedence level."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the given rule text and returns a new Grammar instance.", "response": "def parse_rule(name, rule_text, do_raise=False):\n    \"\"\"\n    Parses the given rule text.\n\n    :param name: The name of the rule.  Used when emitting log\n                 messages regarding a failure to parse the rule.\n    :param rule_text: The text of the rule to parse.\n    :param do_raise: If ``False`` and the rule fails to parse, a log\n                     message is emitted to the \"policies\" logger at\n                     level WARN, and a rule that always evaluates to\n                     ``False`` will be returned.  If ``True``, a\n                     ``pyparsing.ParseException`` will be raised.\n\n    :returns: An instance of ``policies.instructions.Instructions``,\n              containing the instructions necessary to evaluate the\n              authorization rule.\n    \"\"\"\n\n    try:\n        return rule.parseString(rule_text, parseAll=True)[0]\n    except pyparsing.ParseException as exc:\n        # Allow for debugging\n        if do_raise:\n            raise\n\n        # Get the logger and emit our log messages\n        log = logging.getLogger('policies')\n        log.warn(\"Failed to parse rule %r: %s\" % (name, exc))\n        log.warn(\"Rule line: %s\" % exc.line)\n        log.warn(\"Location : %s^\" % (\" \" * (exc.col - 1)))\n\n        # Construct and return a fail-closed instruction\n        return Instructions([Constant(False), set_authz])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tee(self):\n        if self._result is not _NO_RESULT:\n            if not self._isFailure:\n                return succeed(self._result)\n            else:\n                return fail(self._result)\n\n        d = Deferred()\n        self._deferreds.append(d)\n        return d", "response": "Returns a new deferred that will fire with the same result and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef callback(self, result):\n        self._setResult(result)\n        self._isFailure = False\n\n        for d in self._deferreds:\n            d.callback(result)", "response": "Callback method that will be called when the result of the current request is received."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef errback(self, failure):\n        self._setResult(failure)\n        self._isFailure = True\n\n        for d in self._deferreds:\n            d.errback(failure)", "response": "Errbacks the deferreds previously produced by this object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the result of the assessment.", "response": "def _setResult(self, result):\n        \"\"\"\n        Sets the result. If the result is already set, raises\n        C{AlreadyCalledError}.\n\n        @raise AlreadyCalledError: The result was already set.\n        @return: C{None}, if the result was successfully set.\n        \"\"\"\n        if self._result is not _NO_RESULT:\n            raise AlreadyCalledError()\n\n        self._result = result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_all_json_files(build_dir):\n    html_files = []\n    for root, _, files in os.walk(build_dir):\n        for filename in fnmatch.filter(files, '*.fjson'):\n            if filename in ['search.fjson', 'genindex.fjson',\n                            'py-modindex.fjson']:\n                continue\n            html_files.append(os.path.join(root, filename))\n    page_list = []\n    for filename in html_files:\n        try:\n            result = process_file(filename)\n            if result:\n                page_list.append(result)\n        # we're unsure which exceptions can be raised\n        except:  # noqa\n            pass\n    return page_list", "response": "Return a list of pages to index from all. fjson files in build_dir."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef process_file(filename):\n    try:\n        with codecs.open(filename, encoding='utf-8', mode='r') as f:\n            file_contents = f.read()\n    except IOError:\n        log.info('Unable to read file: %s', filename)\n        return None\n    data = json.loads(file_contents)\n    title = ''\n    body_content = ''\n    if 'current_page_name' in data:\n        path = data['current_page_name']\n    else:\n        log.info('Unable to index file due to no name %s', filename)\n        return None\n    if 'body' in data and data['body']:\n        body = PyQuery(data['body'])\n        body_content = body.text().replace(u'\u00b6', '')\n    else:\n        log.info('Unable to index content for: %s', filename)\n    if 'title' in data:\n        title = data['title']\n        if title.startswith('<'):\n            title = PyQuery(data['title']).text()\n    else:\n        log.info('Unable to index title for: %s', filename)\n\n    return {'headers': process_headers(data, filename),\n            'content': body_content, 'path': path, 'title': title}", "response": "Read a file from disk and parse it into a structured dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_headers(data, filename):\n    headers = []\n    if 'toc' in data:\n        for element in PyQuery(data['toc'])('a'):\n            headers.append(recurse_while_none(element))\n        if None in headers:\n            log.info('Unable to index file headers for: %s', filename)\n    return headers", "response": "Read headers from toc data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling this function for generic import of an XML file with the following arguments: - filename: Path to XML file - markings (optional): List of information objects with which the imported object should be marked - identifier_ns_uri: Namespace of the identifiers, if identifiers are to be created - uid (optional): unique identifier -- if none is given, the SHA256 of the file contents are used as identifier.", "response": "def xml_import(self,\n                   filepath=None,\n                   xml_content = None,\n                   markings=None,\n                   identifier_ns_uri = None,\n                   uid = None,\n                   **kargs):\n\n        \"\"\"\n        Call this function for generic import of an XML file with the following arguments:\n\n        - filename: Path to XML file\n        - markings (optional): List of information objects with which the imported object\n          should be marked\n        - identifier_ns_uri: Namespace of the identifiers, if identifiers are to be created\n        - uid (optional): unique identifier -- if none is given, the SHA256 of the file\n          contents are used as identifier.\n         \"\"\"\n\n\n        # Reset bookkeeping dictionaries\n\n\n        if not markings:\n            markings = []\n        if not identifier_ns_uri:\n            identifier_ns_uri = DINGOS_DEFAULT_ID_NAMESPACE_URI\n\n        self.__init__()\n\n        # Carry out generic XML import\n        import_result = DingoImporter.xml_import(xml_fname=filepath,\n                                                 xml_content=xml_content,\n                                                 ns_mapping=self.namespace_dict,\n                                                 embedded_predicate=self.cybox_embedding_pred,\n                                                 id_and_revision_extractor=self.id_and_revision_extractor)\n\n\n        # Extract data required for creating info object\n\n        id_and_rev_info = import_result['id_and_rev_info']\n        elt_name = import_result['elt_name']\n        elt_dict = import_result['dict_repr']\n        file_content = import_result['file_content']\n\n        if uid:\n            id_and_rev_info['id'] = uid\n        else:\n            id_and_rev_info['id'] = hashlib.sha256(file_content).hexdigest()\n\n        id_and_rev_info['timestamp'] = timezone.now()\n\n        create_timestamp = id_and_rev_info['timestamp']\n\n        iobject_family_name = self.namespace_dict.get(elt_dict.get('@@ns', None), DINGOS_GENERIC_FAMILY_NAME)\n\n        iobject_family_revision_name = ''\n        iobject_type_name = elt_name\n        iobject_type_namespace_uri = self.namespace_dict.get(elt_dict.get('@@ns', None), DINGOS_GENERIC_FAMILY_NAME)\n\n        # Create info object\n\n        DingoImporter.create_iobject(iobject_family_name=iobject_family_name,\n                                     iobject_family_revision_name=iobject_family_revision_name,\n                                     iobject_type_name=iobject_type_name,\n                                     iobject_type_namespace_uri=iobject_type_namespace_uri,\n                                     iobject_type_revision_name='',\n                                     iobject_data=elt_dict,\n                                     uid=id_and_rev_info['id'],\n                                     identifier_ns_uri=identifier_ns_uri,\n                                     timestamp=id_and_rev_info['timestamp'],\n                                     create_timestamp=create_timestamp,\n                                     markings=markings,\n                                     config_hooks={'special_ft_handler': self.ft_handler_list(),\n                                                   'datatype_extractor': self.datatype_extractor},\n                                     namespace_dict=self.namespace_dict,\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_import_marking(self, args, options):\n        marking_json = None\n        placeholder_dict = {}\n\n        if options.get('marking_json'):\n            # Open json\n            with open(options['marking_json'], 'r') as content_file:\n                marking_json = content_file.read()\n\n            del(options['marking_json'])\n\n            # Find all placeholders\n            placeholders = self.RE_SEARCH_PLACEHOLDERS.findall(marking_json)\n\n            # Create prefilled dictionary so that later when we use\n            # the json text as format string we do not encounter problems\n            # for undefined placeholders.\n\n            if placeholders:\n\n                for placeholder in placeholders:\n                    placeholder_dict[placeholder] = 'EMPTY'\n\n        # Read in command-line specified placeholder values.\n        if options.get('placeholder_fillers'):\n            for (placeholder, value) in options['placeholder_fillers']:\n                placeholder_dict[placeholder] = value\n\n            del(options['placeholder_fillers'])\n\n        # Add standard values (this list may grow in future)\n        placeholder_dict['_username'] = getpass.getuser()\n        placeholder_dict['_command'] = os.path.basename(__file__)\n        placeholder_dict['_kargs'] = \"%s\" % options\n        placeholder_dict['_args'] = args\n\n        if marking_json:\n            # Massage the json text such that we can use it as format string\n            # to fill in the placeholders\n\n            # Escape possible '%'\n            marking_json = marking_json.replace('%','\\%')\n            # Replace placeholder definitions with python string formatting\n            marking_json = self.RE_SEARCH_PLACEHOLDERS.sub(\"%(\\\\1)s\", marking_json)\n\n            # Use string formatting to fill in placeholders\n\n            marking_json = marking_json % placeholder_dict\n\n            # Finally, parse json\n            marking_dict = dict2DingoObjDict(json.loads(marking_json))\n\n            # Create info object for marking\n            marking = DingoImporter.create_marking_iobject(metadata_dict=marking_dict)\n\n            return marking\n\n        return None", "response": "This function parses the arguments and creates a marking object for the related item."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the gain of the current log entry.", "response": "def set_gain(self, gain=1):\n        \"\"\" Set the gain \"\"\"\n        if gain == 1:\n            self.i2c.write8(0x81, 0x02)\n        else:\n            self.i2c.write8(0x81, 0x12)\n\n        time.sleep(self.pause)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngrab a lux reading from the current state of the object.", "response": "def read_value(self):\n        \"\"\"Grabs a lux reading either with autoranging (gain=0) or with a specified gain (1, 16)\"\"\"\n        if self.gain == 1 or self.gain == 16:\n            self.set_gain(self.gain)\n            ambient = self.read_full()\n            ir_reading = self.read_ir()\n        elif self.gain == 0:\n            self.set_gain(16)\n            ambient = self.read_full()\n            if ambient < 65535:\n                ir_reading = self.read_ir()\n            if ambient >= 65535 or ir_reading >= 65535:\n                self.set_gain(1)\n                ambient = self.read_full()\n                ir_reading = self.read_ir()\n\n        if self.gain == 1:\n            ambient *= 16\n            ir_reading *= 16\n\n        if ambient == 0:\n            ratio = 0\n        else:\n            ratio = (ir_reading / float(ambient))\n\n        if (ratio >= 0) & (ratio <= 0.52):\n            lux = (0.0315 * ambient) - (0.0593 * ambient * (ratio**1.4))\n        elif ratio <= 0.65:\n            lux = (0.0229 * ambient) - (0.0291 * ir_reading)\n        elif ratio <= 0.80:\n            lux = (0.0157 * ambient) - (0.018 * ir_reading)\n        elif ratio <= 1.3:\n            lux = (0.00338 * ambient) - (0.0026 * ir_reading)\n        elif ratio > 1.3:\n            lux = 0\n\n        return lux"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns user details from OAuth Profile Google App Engine App", "response": "def get_user_details(self, response):\n        \"\"\"Return user details from OAuth Profile Google App Engine App\"\"\"\n        email = response['email']\n        username = response.get('nickname', email).split('@', 1)[0]\n        return {'username': username,\n                'email': email,\n                'fullname': '',\n                'first_name': '',\n                'last_name': ''}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef user_data(self, access_token, *args, **kwargs):\n        url = GOOGLE_APPENGINE_PROFILE_V1\n        auth = self.oauth_auth(access_token)\n        return self.get_json(url,\n            auth=auth, params=auth\n        )", "response": "Load user data from Google App Engine App"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload user data from Google App Engine App", "response": "def user_data(self, access_token, *args, **kwargs):\n        \"\"\"Load user data from OAuth Profile Google App Engine App\"\"\"\n        url = GOOGLE_APPENGINE_PROFILE_V2\n        return self.get_json(url, headers={\n            'Authorization': 'Bearer ' + access_token\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_map_with_default(value, default_value):\n        result = RecursiveMapConverter.to_nullable_map(value)\n        return result if result != None else default_value", "response": "Converts value into map object or returns default when conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef makePickle(self, record):\n        #ei = record.exc_info\n        #if ei:\n        #    dummy = self.format(record) # just to get traceback text into record.exc_text\n        #    record.exc_info = None  # to avoid Unpickleable error\n        s = '%s%s:%i:%s\\n' % (self.prefix, record.name, int(record.created), self.format(record))\n        #if ei:\n        #    record.exc_info = ei  # for next handler\n        return s", "response": "Create a pickle string from a record."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntrying to dump rewritten code to pyc.", "response": "def _make_rewritten_pyc(state, fn, pyc, co):\n    \"\"\"Try to dump rewritten code to *pyc*.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        # Windows grants exclusive access to open files and doesn't have atomic\n        # rename, so just write into the final file.\n        _write_pyc(state, co, fn, pyc)\n    else:\n        # When not on windows, assume rename is atomic. Dump the code object\n        # into a file specific to this process and atomically replace it.\n        proc_pyc = pyc + \".\" + str(os.getpid())\n        if _write_pyc(state, co, fn, proc_pyc):\n            os.rename(proc_pyc, pyc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _read_pyc(source, pyc):\n    try:\n        fp = open(pyc, \"rb\")\n    except IOError:\n        return None\n    try:\n        try:\n            mtime = int(os.stat(source).st_mtime)\n            data = fp.read(8)\n        except EnvironmentError:\n            return None\n        # Check for invalid or out of date pyc file.\n        if (len(data) != 8 or data[:4] != imp.get_magic() or\n                struct.unpack(\"<l\", data[4:])[0] != mtime):\n            return None\n        co = marshal.load(fp)\n        if not isinstance(co, types.CodeType):\n            # That's interesting....\n            return None\n        return co\n    finally:\n        fp.close()", "response": "Possibly read a pytest pyc containing rewritten code. Returns None if successful or None if not."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _saferepr(obj):\n    repr = py.io.saferepr(obj)\n    if py.builtin._istext(repr):\n        t = py.builtin.text\n    else:\n        t = py.builtin.bytes\n    return repr.replace(t(\"\\n\"), t(\"\\\\n\"))", "response": "Get a safe repr of an object for assertion error messages."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _format_assertmsg(obj):\n    # reprlib appears to have a bug which means that if a string\n    # contains a newline it gets escaped, however if an object has a\n    # .__repr__() which contains newlines it does not get escaped.\n    # However in either case we want to preserve the newline.\n    if py.builtin._istext(obj) or py.builtin._isbytes(obj):\n        s = obj\n        is_repr = False\n    else:\n        s = py.io.saferepr(obj)\n        is_repr = True\n    if py.builtin._istext(s):\n        t = py.builtin.text\n    else:\n        t = py.builtin.bytes\n    s = s.replace(t(\"\\n\"), t(\"\\n~\")).replace(t(\"%\"), t(\"%%\"))\n    if is_repr:\n        s = s.replace(t(\"\\\\n\"), t(\"\\n~\"))\n    return s", "response": "Format the custom assertion message given."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_location(node, lineno, col_offset):\n    def _fix(node, lineno, col_offset):\n        if \"lineno\" in node._attributes:\n            node.lineno = lineno\n        if \"col_offset\" in node._attributes:\n            node.col_offset = col_offset\n        for child in ast.iter_child_nodes(node):\n            _fix(child, lineno, col_offset)\n    _fix(node, lineno, col_offset)\n    return node", "response": "Set node location information recursively."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mark_rewrite(self, *names):\n        already_imported = set(names).intersection(set(sys.modules))\n        if already_imported:\n            for name in already_imported:\n                if name not in self._rewritten_names:\n                    self._warn_already_imported(name)\n        self._must_rewrite.update(names)", "response": "Mark import names as needing to be re - written on import."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _register_with_pkg_resources(cls):\n        try:\n            import pkg_resources\n            # access an attribute in case a deferred importer is present\n            pkg_resources.__name__\n        except ImportError:\n            return\n\n        # Since pytest tests are always located in the file system, the\n        #  DefaultProvider is appropriate.\n        pkg_resources.register_loader_type(cls, pkg_resources.DefaultProvider)", "response": "Register a class with pkg_resources."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind all asserts in a module and rewrite them.", "response": "def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [ast.alias(py.builtin.builtins.__name__, \"@py_builtins\"),\n                   ast.alias(\"dessert.rewrite\", \"@dessert_ar\")]\n        expect_docstring = True\n        pos = 0\n        lineno = 0\n        for item in mod.body:\n            if (expect_docstring and isinstance(item, ast.Expr) and\n                    isinstance(item.value, ast.Str)):\n                doc = item.value.s\n                if \"PYTEST_DONT_REWRITE\" in doc:\n                    # The module has disabled assertion rewriting.\n                    return\n                lineno += len(doc) - 1\n                expect_docstring = False\n            elif (not isinstance(item, ast.ImportFrom) or item.level > 0 or\n                  item.module != \"__future__\"):\n                lineno = item.lineno\n                break\n            pos += 1\n        imports = [ast.Import([alias], lineno=lineno, col_offset=0)\n                   for alias in aliases]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (isinstance(field, ast.AST) and\n                      # Don't recurse into expressions as they can't contain\n                      # asserts.\n                      not isinstance(field, ast.expr)):\n                    nodes.append(field)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a new variable.", "response": "def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef assign(self, expr):\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())", "response": "Give expr a name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling a helper in this module.", "response": "def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@dessert_ar\", ast.Load())\n        attr = ast.Attribute(py_name, \"_\" + name, ast.Load())\n        return ast_Call(attr, list(args), [])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef builtin(self, name):\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())", "response": "Return the builtin called name *."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles expressions we don t have custom code for.", "response": "def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the AST statements to replace the ast. Assert instance with the AST statements that are generated by this assertion.", "response": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This re-writes the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and self.config is not None:\n            fslocation = (self.module_path, assert_.lineno)\n            self.config.warn('R1', 'assertion is always true, perhaps '\n                              'remove parentheses?', fslocation=fslocation)\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper('format_assertmsg', assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n\n        if _MARK_ASSERTION_INTROSPECTION:\n            explanation = 'dessert* ' + explanation\n\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"format_explanation\", msg, assertmsg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast_Call(err_name, [fmt], [])\n        if sys.version_info[0] >= 3:\n            raise_ = ast.Raise(exc, None)\n        else:\n            raise_ = ast.Raise(exc, None, None)\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store())\n                         for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef visit_Call_35(self, call):\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else: ## **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, ', '.join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl", "response": "visit ast. Call nodes on Python 3. 5 and after\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncancel the scheduled task.", "response": "def cancel(self):\n        '''\n        Cancel the scheduled task.\n        '''\n        if (not self.cancelled) and (self._fn is not None):\n            self._cancelled = True\n            self._drop_fn()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef result(self):\n        '''\n        The result from the executed task.  Raises NotExecutedYet if not yet\n        executed.\n        '''\n        if self.cancelled or (self._fn is not None):\n            raise NotExecutedYet()\n\n        if self._fn_exc is not None:\n            six.reraise(*self._fn_exc)\n        else:\n            return self._fn_res", "response": "Returns the result of the executed task. Raises NotExecutedYet if the task is cancelled."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a two dimensional array and returns an array where rows in the first become columns in the second.", "response": "def rows_to_columns(matrix):\n#hammer\n    \"\"\"Takes a two dimensional array and returns an new one where rows in the\n    first become columns in the second.\"\"\"\n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n\n    data = []\n    for i in range(0, num_cols):\n        data.append([matrix[j][i] for j in range(0, num_rows)])\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse an anchor tag returning the href and content text.", "response": "def parse_link(html):\n#hammer\n    \"\"\"Parses an HTML anchor tag, returning the href and content text.  Any\n    content before or after the anchor tag pair is ignored.\n\n    :param html:\n        Snippet of html to parse\n    :returns:\n        namedtuple('ParsedLink', ['url', 'text'])\n\n    Example:\n\n    .. code-block:: python\n\n        >>> parse_link('things <a href=\"/foo/bar.html\">Foo</a> stuff')\n        ParsedLink('/foo/bar.html', 'Foo')\n    \"\"\"\n    parser = AnchorParser()\n    parser.feed(html)\n    return parser.ParsedLink(parser.url, parser.text)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef choices(cls):\n        result = []\n        for name, member in cls.__members__.items():\n            result.append((member.value, name))\n\n        return result", "response": "Returns a list of tuples that are compatible with the enumeration s choices attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nemits signal by calling all connected slots.", "response": "def emit(self, **kwargs):\n        \"\"\"Emit signal by calling all connected slots.\n\n        The arguments supplied have to match the signal definition.\n\n        Args:\n            kwargs: Keyword arguments to be passed to connected slots.\n\n        Raises:\n            :exc:`InvalidEmit`: If arguments don't match signal specification.\n        \"\"\"\n        self._ensure_emit_kwargs(kwargs)\n        for slot in self.slots:\n            slot(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting a slot to this singal.", "response": "def connect(self, slot):\n        \"\"\"Connect ``slot`` to this singal.\n\n        Args:\n            slot (callable): Callable object wich accepts keyword arguments.\n\n        Raises:\n            InvalidSlot: If ``slot`` doesn't accept keyword arguments.\n        \"\"\"\n        self._ensure_slot_args(slot)\n        if not self.is_connected(slot):\n            self.slots.append(slot)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisconnects a slot from this signal.", "response": "def disconnect(self, slot):\n        \"\"\"Disconnect ``slot`` from this signal.\"\"\"\n        if self.is_connected(slot):\n            self.slots.remove(slot)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_by_path(path, _globals=None):\n    if _globals is None:\n        _globals = list()\n    return _get_by_path(path.split('.'), _globals)", "response": "Returns an object by path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the data for the type of the reftrack", "response": "def reftrack_type_data(rt, role):\n    \"\"\"Return the data for the type (e.g. Asset, Alembic, Camera etc)\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the type\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return rt.get_typ()\n    elif role == QtCore.Qt.DecorationRole:\n        return rt.get_typ_icon()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the data for the elementgrp", "response": "def reftrack_elementgrp_data(rt, role):\n    \"\"\"Return the data for the elementgrp (e.g. the Assettype or Sequence)\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the elementgrp\n    :rtype: depending on role\n    :raises: TypeError\n    \"\"\"\n    element = rt.get_element()\n    if isinstance(element, djadapter.models.Shot):\n        egrp = element.sequence\n    elif isinstance(element, djadapter.models.Asset):\n        egrp = element.atype\n    elif element is not None:\n        raise TypeError(\"Expected the element to be either Asset or Shot. Got %s\" % type(element))\n    else:\n        return\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return egrp.name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the data for the element in the reftrack", "response": "def reftrack_element_data(rt, role):\n    \"\"\"Return the data for the element (e.g. the Asset or Shot)\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the element\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    element = rt.get_element()\n    if element is None:\n        return\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return element.name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the data for the task that is loaded by the reftrack", "response": "def reftrack_task_data(rt, role):\n    \"\"\"Return the data for the task that is loaded by the reftrack\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the task\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    tfi = rt.get_taskfileinfo()\n    if not tfi:\n        return\n    return filesysitemdata.taskfileinfo_task_data(tfi, role)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the data for the releasetype that is loaded by the reftrack", "response": "def reftrack_rtype_data(rt, role):\n    \"\"\"Return the data for the releasetype that is loaded by the reftrack\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the releasetype\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    tfi = rt.get_taskfileinfo()\n    if not tfi:\n        return\n    return filesysitemdata.taskfileinfo_rtype_data(tfi, role)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the data for the descriptor that is loaded by the reftrack", "response": "def reftrack_descriptor_data(rt, role):\n    \"\"\"Return the data for the descriptor that is loaded by the reftrack\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the descriptor\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    tfi = rt.get_taskfileinfo()\n    if not tfi:\n        return\n    return filesysitemdata.taskfileinfo_descriptor_data(tfi, role)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reftrack_version_data(rt, role):\n    tfi = rt.get_taskfileinfo()\n    if not tfi:\n        return\n    return filesysitemdata.taskfileinfo_version_data(tfi, role)", "response": "Return the data for the version that is loaded by the reftrack\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reftrack_status_data(rt, role):\n    status = rt.status()\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        if status:\n            return status\n        else:\n            return \"Not in scene!\"", "response": "Return the data for the status\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the data for the uptodate status", "response": "def reftrack_uptodate_data(rt, role):\n    \"\"\"Return the data for the uptodate status\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the uptodate status\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    uptodate = rt.uptodate()\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        if uptodate:\n            return \"Yes\"\n        else:\n            return \"No\"\n    if role == QtCore.Qt.ForegroundRole:\n        if uptodate:\n            return QtGui.QColor(*UPTODATE_RGB)\n        elif rt.status():\n            return QtGui.QColor(*OUTDATED_RGB)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the data for the alien status", "response": "def reftrack_alien_data(rt, role):\n    \"\"\"Return the data for the alien status\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the alien status\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    alien = rt.alien()\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        if alien:\n            return \"Yes\"\n        else:\n            return \"No\""}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the data for the path that is loaded by the reftrack", "response": "def reftrack_path_data(rt, role):\n    \"\"\"Return the data for the path that is loaded by the reftrack\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the path\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    tfi = rt.get_taskfileinfo()\n    if not tfi:\n        return\n    return filesysitemdata.taskfileinfo_path_data(tfi, role)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the data for restricted or allowed for the given attr of the given reftrack", "response": "def reftrack_restricted_data(rt, role, attr):\n    \"\"\"Return the data for restriction of the given attr of the given reftrack\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the restriction\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    if role == QtCore.Qt.DisplayRole:\n        if rt.is_restricted(getattr(rt, attr, None)):\n            return \"Restricted\"\n        else:\n            return \"Allowed\""}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the reftrack for REFTRACK_OBJECT_ROLE", "response": "def reftrack_object_data(rt, role):\n    \"\"\"Return the reftrack for REFTRACK_OBJECT_ROLE\n\n    :param rt: the :class:`jukeboxcore.reftrack.Reftrack` holds the data\n    :type rt: :class:`jukeboxcore.reftrack.Reftrack`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the id\n    :rtype: depending on the role\n    :raises: None\n    \"\"\"\n    if role == QtCore.Qt.DisplayRole:\n        return str(rt)\n    if role == REFTRACK_OBJECT_ROLE:\n        return rt"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef data(self, column, role):\n        return self.columns[column](self._reftrack, role)", "response": "Return the data for the specified column and role"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flags(self, column):\n        return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEditable", "response": "Return the item flags for the item\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if the filter accepts the given row of the parent", "response": "def filterAcceptsRow(self, row, parentindex):\n        \"\"\"Return True, if the filter accepts the given row of the parent\n\n        :param row: the row to filter\n        :type row: :class:`int`\n        :param parentindex: the parent index\n        :type parentindex: :class:`QtCore.QModelIndex`\n        :returns: True, if the filter accepts the row\n        :rtype: :class:`bool`\n        :raises: None\n        \"\"\"\n        if not super(ReftrackSortFilterModel, self).filterAcceptsRow(row, parentindex):\n            return False\n        if parentindex.isValid():\n            m = parentindex.model()\n        else:\n            m = self.sourceModel()\n\n        i = m.index(row, 18, parentindex)\n        reftrack = i.data(REFTRACK_OBJECT_ROLE)\n        if not reftrack:\n            return True\n        else:\n            return self.filter_accept_reftrack(reftrack)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_accept_reftrack(self, reftrack):\n        if reftrack.status() in self._forbidden_status:\n            return False\n        if reftrack.get_typ() in self._forbidden_types:\n            return False\n        if reftrack.uptodate() in self._forbidden_uptodate:\n            return False\n        if reftrack.alien() in self._forbidden_alien:\n            return False\n        return True", "response": "Return True if the filter accepts the given reftrack"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the forbidden status values for the current locale.", "response": "def set_forbidden_statuses(self, statuses):\n        \"\"\"Set all forbidden status values\n\n        :param statuses: a list with forbidden status values\n        :type statuses: list\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if self._forbidden_status == statuses:\n            return\n        self._forbidden_status = statuses\n        self.invalidateFilter()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_forbidden_types(self, types):\n        if self._forbidden_types == types:\n            return\n        self._forbidden_types = types\n        self.invalidateFilter()", "response": "Sets the forbidden types of the log entry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_forbidden_uptodate(self, uptodate):\n        if self._forbidden_uptodate == uptodate:\n            return\n        self._forbidden_uptodate = uptodate\n        self.invalidateFilter()", "response": "Set all forbidden uptodate values\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the forbidden alien values for the given entry.", "response": "def set_forbidden_alien(self, alien):\n        \"\"\"Set all forbidden alien values\n\n        :param alienes: a list with forbidden alien values\n        :alien alienes: list\n        :returns: None\n        :ralien: None\n        :raises: None\n        \"\"\"\n        if self._forbidden_alien == alien:\n            return\n        self._forbidden_alien = alien\n        self.invalidateFilter()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_env(path=None, environ=None, recurse=True):\n    environ = environ if environ is not None else os.environ\n\n    # By default, start search from the same file this function is called\n    if path is None:\n        frame = inspect.currentframe().f_back\n        caller_dir = os.path.dirname(frame.f_code.co_filename)\n        path = os.path.join(os.path.abspath(caller_dir), ENV)\n    if recurse:\n        current = path\n        pardir = os.path.abspath(os.path.join(current, os.pardir))\n        while current != pardir:\n            target = os.path.join(current, ENV)\n            if os.path.exists(target):\n                path = os.path.abspath(target)\n                break\n            else:\n                current = os.path.abspath(os.path.join(current, os.pardir))\n                pardir = os.path.abspath(os.path.join(current, os.pardir))\n        if not path:\n            raise FileNotFoundError('Could not find a .env file')\n\n    with open(path, 'r') as fp:\n        content = fp.read()\n    parsed = parse_env(content)\n    for key, value in parsed.items():\n        environ.setdefault(key, value)", "response": "Reads a. env file into the given environment."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_env(content):\n    values = {}\n    for line in content.splitlines():\n        lexer = shlex.shlex(line, posix=True)\n        tokens = list(lexer)\n\n        # parses the assignment statement\n        if len(tokens) < 3:\n            continue\n\n        name, op = tokens[:2]\n        value = ''.join(tokens[2:])\n\n        if op != '=':\n            continue\n        if not _ITEM_RE.match(name):\n            continue\n\n        value = value.replace(r'\\n', '\\n')\n        value = value.replace(r'\\t', '\\t')\n        values[name] = value\n    return values", "response": "Parse the content of a. env file into a dictionary mapping keys to values."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the error message or value stored in the Qik 2s9v1 hardware.", "response": "def getError(self, device=DEFAULT_DEVICE_ID, message=True):\n        \"\"\"\n        Get the error message or value stored in the Qik 2s9v1 hardware.\n\n        :Keywords:\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol. Defaults to the hardware's\n            default value.\n          message : `bool`\n            If set to `True` a text message will be returned, if set to `False`\n            the integer stored in the Qik will be returned.\n\n        :Returns:\n          A list of text messages, integers, or and empty list. See the\n          `message` parameter above.\n        \"\"\"\n        return self._getError(device, message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getPWMFrequency(self, device=DEFAULT_DEVICE_ID, message=True):\n        return self._getPWMFrequency(device, message)", "response": "Returns the motor shutdown on error status stored on the hardware device."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the hardware device number.", "response": "def setDeviceID(self, value, device=DEFAULT_DEVICE_ID, message=True):\n        \"\"\"\n        Set the hardware device number. This is only needed if more that one\n        device is on the same serial buss.\n\n        :Parameters:\n          value : `int`\n            The device ID to set in the range of 0 - 127.\n\n        :Keywords:\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol. Defaults to the hardware's\n            default value.\n          message : `bool`\n            If set to `True` a text message will be returned, if set to `False`\n            the integer stored in the Qik will be returned.\n\n        :Returns:\n          A text message or an int. See the `message` parameter above. If\n          `value` and `device` are the same `OK` or `0` will be returned\n          depending on the value of `message`.\n\n        :Exceptions:\n          * `SerialException`\n            IO error indicating there was a problem reading from the serial\n            connection.\n        \"\"\"\n        return self._setDeviceID(value, device, message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the PWM frequency.", "response": "def setPWMFrequency(self, pwm, device=DEFAULT_DEVICE_ID, message=True):\n        \"\"\"\n        Set the PWM frequency.\n\n        :Parameters:\n          pwm : `int`\n            The PWN frequency to set in hertz.\n\n        :Keywords:\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol. Defaults to the hardware's\n            default value.\n          message : `bool`\n            If set to `True` a text message will be returned, if set to `False`\n            the integer stored in the Qik will be returned.\n\n        :Returns:\n          A text message or an int. See the `message` parameter above.\n\n        :Exceptions:\n          * `SerialException`\n            IO error indicating there was a problem reading from the serial\n            connection.\n        \"\"\"\n        return self._setPWMFrequency(pwm, device, message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setMotorShutdown(self, value, device=DEFAULT_DEVICE_ID, message=True):\n        return self._setMotorShutdown(value, device, message)", "response": "Sets the motor shutdown on error status stored on the hardware device."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setSerialTimeout(self, timeout, device=DEFAULT_DEVICE_ID, message=True):\n        return self._setSerialTimeout(timeout, device, message)", "response": "Set the serial timeout on the hardware device."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the motor 0 to coast.", "response": "def setM0Coast(self, device=DEFAULT_DEVICE_ID):\n        \"\"\"\n        Set motor 0 to coast.\n\n        :Keywords:\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol. Defaults to the hardware's\n            default value.\n\n        :Exceptions:\n          * `SerialTimeoutException`\n            If the low level serial package times out.\n          * `SerialException`\n            IO error when the port is not open.\n        \"\"\"\n        cmd = self._COMMAND.get('m0-coast')\n        self._writeData(cmd, device)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setM1Coast(self, device=DEFAULT_DEVICE_ID):\n        cmd = self._COMMAND.get('m1-coast')\n        self._writeData(cmd, device)", "response": "Sets the motor 1 to coast."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_action_model(actioncollection):\n    rootdata = ListItemData([\"Name\", \"Description\", \"Status\", \"Message\", \"Traceback\"])\n    root = TreeItem(rootdata)\n    for au in actioncollection.actions:\n        adata = ActionItemData(au)\n        TreeItem(adata, parent=root)\n    return TreeModel(root)", "response": "Create and return a new TreeModel for the given action collection."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef data(self, column, role):\n        if role == QtCore.Qt.DisplayRole:\n            if column == 0:\n                return self._au.name\n            if column == 1:\n                return self._au.description\n            if column == 2:\n                return self._au.status.value\n            if column == 3:\n                return self._au.status.message\n            if column == 4:\n                return self._au.status.traceback\n\n        if role == QtCore.Qt.ForegroundRole:\n            if column == 2:\n                return self.colormapping.get(self._au.status.value)", "response": "Return the data for the specified column and role"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flags(self, column):\n        flags = super(ActionItemData, self).flags(column)\n        if (column == 3 and self._au.status.message) or (column == 4 and self._au.status.traceback):\n            flags = flags | QtCore.Qt.ItemIsEditable\n        return flags", "response": "Return the item flags for the item\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling to subscribe the handlers on init.", "response": "def auto_subscribe(self, app_manager):\n        \"\"\"Called to subscribe the handlers on init.\"\"\"\n        for handler in app_manager.handler_classes:\n            app_manager.subscribe(handler.channel(), self)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_payment(self, *, amount, currency, order=None, customer_id=None, billing_address=None,\n                       shipping_address=None, additional_details=None, statement_soft_descriptor=None):\n        \"\"\"\n        Creates a payment object, which provides a single reference to all the transactions that make up a payment.\n        This is the first step for all financial transactions.\n\n        Args:\n            amount: Amount must be greater than 0. The amount is formatted in Minor Units format.\n            currency: The three character currency code in ISO-4217 format.\n            order: Details of the order.\n            customer_id: Identifier of the customer associated with this payment.\n            billing_address: Billing address details. This will only be sent to providers who support\n            billing addresses, in requests that support them. Note: The billing address details will be sent \"as is\",\n            without any corrections or substitutions from the billing address in the token resource.\n            shipping_address: Shipping address details. This will only be sent to providers who support\n            shipping addresses, in requests that support them. Note: The shipping address details will be sent \"as is\",\n            without any corrections or substitutions from the shipping address in the customer resource.\n            additional_details: Optional additional data stored in key/value pairs.\n            statement_soft_descriptor: The transaction description that will appear in the\n            customer's credit card statement, which identifies the merchant and payment.\n            Check the relevant provider sites to see if this field is supported.\n            If so, see the required content and format. Note: This transaction description is generated by you.\n            Providing a clear description helps your customers recognize their transactions, and reduces chargebacks.\n\n        Returns:\n\n        \"\"\"\n        headers = self.client._get_private_headers()\n        payload = {\n            \"amount\": amount,\n            \"currency\": currency,\n            \"order\": order,\n            \"customer_id\": customer_id,\n            \"billing_address\": billing_address,\n            \"shipping_address\": shipping_address,\n            \"additional_details\": additional_details,\n            \"statement_soft_descriptor\": statement_soft_descriptor,\n        }\n        endpoint = '/payments'\n        return self.client._post(self.client.URL_BASE + endpoint, json=payload, headers=headers)", "response": "Creates a payment object for all financial transactions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_module_parser(mod, modname, parents=[], add_help=True):\n    return argparse.ArgumentParser(\n        usage=configuration.EXECUTABLE_NAME + ' ' + modname + ' [options]',\n        description=mod.get_description(), parents=parents,\n        add_help=add_help)", "response": "Returns an argument parser for the sub - command s CLI."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_application_parser(commands):\n\n    parser = argparse.ArgumentParser(\n        description=configuration.APPLICATION_DESCRIPTION,\n        usage =configuration.EXECUTABLE_NAME + ' [sub-command] [options]',\n        add_help=False)\n\n    parser.add_argument(\n        'sub_command',\n        choices=[name for name in commands],\n        nargs=\"?\")\n\n    parser.add_argument(\"-h\", \"--help\", action=\"store_true\")\n    return parser", "response": "Builds an argument parser for the application s CLI."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates or creates the registration model with attributes from this instance.", "response": "def registration_update_or_create(self):\n        \"\"\"Creates or Updates the registration model with attributes\n        from this instance.\n\n        Called from the signal\n        \"\"\"\n        if not getattr(self, self.registration_unique_field):\n            raise UpdatesOrCreatesRegistrationModelError(\n                f'Cannot update or create RegisteredSubject. '\n                f'Field value for \\'{self.registration_unique_field}\\' is None.')\n\n        registration_value = getattr(self, self.registration_unique_field)\n        registration_value = self.to_string(registration_value)\n\n        try:\n            obj = self.registration_model.objects.get(\n                **{self.registered_subject_unique_field: registration_value})\n        except self.registration_model.DoesNotExist:\n            pass\n        else:\n            self.registration_raise_on_illegal_value_change(obj)\n        registered_subject, created = self.registration_model.objects.update_or_create(\n            **{self.registered_subject_unique_field: registration_value},\n            defaults=self.registration_options)\n        return registered_subject, created"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef registration_options(self):\n        registration_options = {}\n        rs = self.registration_model()\n        for k, v in self.__dict__.items():\n            if k not in DEFAULT_BASE_FIELDS + ['_state']:\n                try:\n                    getattr(rs, k)\n                    registration_options.update({k: v})\n                except AttributeError:\n                    pass\n        registration_identifier = registration_options.get(\n            'registration_identifier')\n        if registration_identifier:\n            registration_options['registration_identifier'] = self.to_string(\n                registration_identifier)\n        return registration_options", "response": "Gathers values for common attributes between the theCOOKIE and this instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the image to be displayed in the widget. ================== =========================================================================== **Arguments:** img (numpy array) the image to be displayed. See :func:`ImageItem.setImage` and *notes* below. xvals (numpy array) 1D array of z-axis values corresponding to the third axis in a 3D image. For video, this array should contain the time of each frame. autoRange (bool) whether to scale/pan the view to fit the image. useAutoLevels (bool) whether to update the white/black levels to fit the image. levels (min, max); the white and black level values to use. axes Dictionary indicating the interpretation for each axis. This is only needed to override the default guess. Format is:: {'t':0, 'x':1, 'y':2, 'c':3}; pos Change the position of the displayed image scale Change the scale of the displayed image transform Set the transform of the displayed image. This option overrides *pos* and *scale*. autoHistogramRange If True, the histogram y-range is automatically scaled to fit the image data. ================== =========================================================================== **Notes:** For backward compatibility, image data is assumed to be in column-major order (column, row). However, most image data is stored in row-major order (row, column) and will need to be transposed before calling setImage():: imageview.setImage(imagedata.T) This requirement can be changed by the ``imageAxisOrder`` :ref:`global configuration option <apiref_config>`.", "response": "def setImage(self,\n                 img,\n                 autoRange=True,\n                 useAutoLevels=None,\n                 levels=None,\n                 axes=None,\n                 pos=None,\n                 scale=None,\n                 transform=None,\n                 ):\n        \"\"\"\n        Set the image to be displayed in the widget.\n\n        ================== ===========================================================================\n        **Arguments:**\n        img                (numpy array) the image to be displayed. See :func:`ImageItem.setImage` and\n                           *notes* below.\n        xvals              (numpy array) 1D array of z-axis values corresponding to the third axis\n                           in a 3D image. For video, this array should contain the time of each frame.\n        autoRange          (bool) whether to scale/pan the view to fit the image.\n        useAutoLevels      (bool) whether to update the white/black levels to fit the image.\n        levels             (min, max); the white and black level values to use.\n        axes               Dictionary indicating the interpretation for each axis.\n                           This is only needed to override the default guess. Format is::\n\n                               {'t':0, 'x':1, 'y':2, 'c':3};\n\n        pos                Change the position of the displayed image\n        scale              Change the scale of the displayed image\n        transform          Set the transform of the displayed image. This option overrides *pos*\n                           and *scale*.\n        autoHistogramRange If True, the histogram y-range is automatically scaled to fit the\n                           image data.\n        ================== ===========================================================================\n\n        **Notes:**\n\n        For backward compatibility, image data is assumed to be in column-major order (column, row).\n        However, most image data is stored in row-major order (row, column) and will need to be\n        transposed before calling setImage()::\n\n            imageview.setImage(imagedata.T)\n\n        This requirement can be changed by the ``imageAxisOrder``\n        :ref:`global configuration option <apiref_config>`.\n\n        \"\"\"\n\n        if hasattr(img, 'implements') and img.implements('MetaArray'):\n            img = img.asarray()\n\n        if not isinstance(img, np.ndarray):\n            required = ['dtype', 'max', 'min', 'ndim', 'shape', 'size']\n            if not all([hasattr(img, attr) for attr in required]):\n                raise TypeError(\"Image must be NumPy array or any object \"\n                                \"that provides compatible attributes/methods:\\n\"\n                                \"  %s\" % str(required))\n\n        self.image = img\n        self.imageDisp = None\n\n\n        if axes is None:\n            x, y = (0, 1) if self.imageItem.axisOrder == 'col-major' else (1, 0)\n\n            if img.ndim == 2:\n                self.axes = {'t': None, 'x': x, 'y': y, 'c': None}\n            elif img.ndim == 3:\n                # Ambiguous case; make a guess\n                if img.shape[2] <= 4:\n                    self.axes = {'t': None, 'x': x, 'y': y, 'c': 2}\n                else:\n                    self.axes = {'t': 0, 'x': x+ 1, 'y': y+ 1, 'c': None}\n            elif img.ndim == 4:\n                # Even more ambiguous; just assume the default\n                self.axes = {'t': 0, 'x': x+ 1, 'y': y+ 1, 'c': 3}\n            else:\n                raise Exception(\n                    \"Can not interpret image with dimensions %s\" %\n                    (str(img.shape)))\n        elif isinstance(axes, dict):\n            self.axes = axes.copy()\n        elif isinstance(axes, list) or isinstance(axes, tuple):\n            self.axes = {}\n            for i in range(len(axes)):\n                self.axes[axes[i]] = i\n        else:\n            raise Exception(\n                \"Can not interpret axis specification %s. \"\n                \"Must be like {'t': 2, 'x': 0, 'y': 1} or \"\n                \"('t', 'x', 'y', 'c')\" % (str(axes)))\n\n        for x in ['t', 'x', 'y', 'c']:\n            self.axes[x] = self.axes.get(x, None)\n        axes = self.axes\n\n\n        self.currentIndex = 0\n\n        if levels is None and useAutoLevels:\n            self._useAutoLevels= useAutoLevels\n        if levels is not None:  # this does nothing since getProcessedImage sets these values again.\n            self.setLevels(*levels)\n\n        self._updateImage()\n        self._updateLabelInfo()\n\n        self.imageItem.resetTransform()\n        if scale is not None:\n            self.imageItem.scale(*scale)\n        if pos is not None:\n            self.imageItem.setPos(*pos)\n        if transform is not None:\n            self.imageItem.setTransform(transform)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _getProcessedImage(self):\n        if self.imageDisp is None:\n            self.imageDisp = self.image\n            self.levelMin, self.levelMax = self._quickLevels(\n                self.imageDisp)\n            #list( map(float, self._quickLevels(self.imageDisp)))\n        return self.imageDisp", "response": "Returns the image data after it has been processed by any normalization options in use."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _quickLevels(self, data):\n        while data.size > 1e6:\n            ax = np.argmax(data.shape)\n            sl = [slice(None)] * data.ndim\n            sl[ax] = slice(None, None, 2)\n            data = data[sl]\n        return self._levelsFromMedianAndStd(data)", "response": "Return the levels of the data in a quick way."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nclose the widget nicely making sure to clear the graphics scene and release memory.", "response": "def close(self):\n        \"\"\"Closes the widget nicely, making sure to clear the graphics scene and release memory.\"\"\"\n        self.ui.graphicsView.close()\n        self.scene.clear()\n        del self.image\n        del self.imageDisp\n        super(ImageShowBasicWidget, self).close()\n        self.setParent(None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup_logging(level, logger_name=None, handler=None, log_formatter=None):\n    root_logger = logging.getLogger()\n\n    if logger_name is None:\n        logger = root_logger\n        root_logger.info(\"Set %i level to root logger\", level)\n    else:\n        logger = logging.getLogger(logger_name)\n        root_logger.info(\"Set %i level to logger %r\", level, logger_name)\n\n    if level == 100:\n        # Remove all existing handlers and set only NullHandler():\n        set_handler(logger, logging.NullHandler())\n        logger.disabled = True\n        return\n\n    logger.setLevel(level=level)\n\n    if log_formatter is None:\n        log_formatter = \"%(relativeCreated)-5d %(levelname)8s %(module)13s %(lineno)d %(message)s\"\n    formatter = logging.Formatter(log_formatter)\n\n    if handler is None:\n        handler = logging.StreamHandler()\n    handler.setFormatter(formatter)\n\n    if hasattr(handler, \"baseFilename\"):\n        root_logger.debug(\"Log to file: %s (%s)\", handler.baseFilename, repr(handler))\n    else:\n        root_logger.debug(\"Log to handler: %s\", repr(handler))\n\n    # Remove all existing handlers and set only the given handler:\n    set_handler(logger, handler)\n\n    log.log(level, \"Set logging to level %i %s\", level, logging.getLevelName(level))", "response": "Setup logging for the given level."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a project and store it in the self. project attribute", "response": "def create_prj(self, ):\n        \"\"\"Create a project and store it in the self.project\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        name = self.name_le.text()\n        short = self.short_le.text()\n        path = self.path_le.text()\n        semester = self.semester_le.text()\n        try:\n            prj = djadapter.models.Project(name=name, short=short, path=path, semester=semester)\n            prj.save()\n            self.project = prj\n            self.accept()\n        except:\n            log.exception(\"Could not create new project\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_project(self, ):\n        i = self.prj_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            project = item.internal_data()\n            if self._atype:\n                self._atype.projects.add(project)\n            elif self._dep:\n                self._dep.projects.add(project)\n            else:\n                project.users.add(self._user)\n            self.projects.append(project)\n            item.set_parent(None)", "response": "Adds a project and store it in the self. projects\nAttributeNames."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a sequence and store it in the self. sequence", "response": "def create_seq(self, ):\n        \"\"\"Create a sequence and store it in the self.sequence\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        name = self.name_le.text()\n        desc = self.desc_pte.toPlainText()\n        try:\n            seq = djadapter.models.Sequence(name=name, project=self._project, description=desc)\n            seq.save()\n            self.sequence = seq\n            self.accept()\n        except:\n            log.exception(\"Could not create new sequence\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a atype and store it in the self. atype", "response": "def create_atype(self, ):\n        \"\"\"Create a atype and store it in the self.atype\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        name = self.name_le.text()\n        desc = self.desc_pte.toPlainText()\n        try:\n            atype = djadapter.models.Atype(name=name, description=desc)\n            atype.save()\n            for prj in self.projects:\n                atype.projects.add(prj)\n            self.atype = atype\n            self.accept()\n        except:\n            log.exception(\"Could not create new assettype\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a atype and store it in the self. otype_tablev.", "response": "def add_atype(self, ):\n        \"\"\"Add a atype and store it in the self.atypes\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        i = self.atype_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            atype = item.internal_data()\n            atype.projects.add(self._project)\n            self.atypes.append(atype)\n            item.set_parent(None)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_dep(self, ):\n        name = self.name_le.text()\n        short = self.short_le.text()\n        assetflag = self.asset_rb.isChecked()\n        ordervalue = self.ordervalue_sb.value()\n        desc = self.desc_pte.toPlainText()\n        try:\n            dep = djadapter.models.Department(name=name, short=short, assetflag=assetflag, ordervalue=ordervalue, description=desc)\n            dep.save()\n            for prj in self.projects:\n                dep.projects.add(prj)\n            self.dep = dep\n            self.accept()\n        except:\n            log.exception(\"Could not create new department.\")", "response": "Create a dep and store it in the self. dep\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_dep(self, ):\n        i = self.dep_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            dep = item.internal_data()\n            dep.projects.add(self._project)\n            self.deps.append(dep)\n            item.set_parent(None)", "response": "Adds a dep and store it in the self. deps\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_user(self, ):\n        name = self.username_le.text()\n        if not name:\n            self.username_le.setPlaceholderText(\"Please provide a username.\")\n            return\n        first = self.first_le.text()\n        last = self.last_le.text()\n        email = self.email_le.text()\n        try:\n            user = djadapter.models.User(username=name, first_name=first, last_name=last, email=email)\n            user.save()\n            for prj in self.projects:\n                prj.users.add(user)\n            for task in self.tasks:\n                task.users.add(user)\n            self.user = user\n            self.accept()\n        except:\n            log.exception(\"Could not create new assettype\")", "response": "Create a user and store it in the self. user\n ArcGIS"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_user(self, ):\n        i = self.user_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            user = item.internal_data()\n            if self._project:\n                self._project.users.add(user)\n            else:\n                self._task.users.add(user)\n            self.users.append(user)\n            item.set_parent(None)", "response": "Adds a user and store it in the self. users\n ArcGIS"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a shot and store it in the self. shot", "response": "def create_shot(self, ):\n        \"\"\"Create a shot and store it in the self.shot\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        name = self.name_le.text()\n        if not name:\n            self.name_le.setPlaceholderText(\"Please enter a name!\")\n            return\n        desc = self.desc_pte.toPlainText()\n        try:\n            shot = djadapter.models.Shot(sequence=self.sequence, project=self.sequence.project, name=name, description=desc)\n            shot.save()\n            self.shot = shot\n            self.accept()\n        except:\n            log.exception(\"Could not create new shot\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_asset(self, ):\n        name = self.name_le.text()\n        if not name:\n            self.name_le.setPlaceholderText(\"Please enter a name!\")\n            return\n        desc = self.desc_pte.toPlainText()\n        if not self.atype:\n            atypei = self.atype_cb.currentIndex()\n            assert atypei >= 0\n            self.atype = self.atypes[atypei]\n        try:\n            asset = djadapter.models.Asset(atype=self.atype, project=self.project, name=name, description=desc)\n            asset.save()\n            self.asset = asset\n            self.accept()\n        except:\n            log.exception(\"Could not create new asset\")", "response": "Create a asset and store it in the self. asset\n ArcGIS"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a asset and store it in the self. assets", "response": "def add_asset(self, ):\n        \"\"\"Add a asset and store it in the self.assets\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        i = self.asset_treev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            asset = item.internal_data()\n            if not isinstance(asset, djadapter.models.Asset):\n                return\n            if self._shot:\n                self._shot.assets.add(asset)\n            else:\n                self._asset.assets.add(asset)\n            self.assets.append(asset)\n            item.set_parent(None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a task and store it in the self. task", "response": "def create_task(self, ):\n        \"\"\"Create a task and store it in the self.task\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        depi = self.dep_cb.currentIndex()\n        assert depi >= 0\n        dep = self.deps[depi]\n        deadline = self.deadline_de.dateTime().toPython()\n        try:\n            task = djadapter.models.Task(department=dep, project=self.element.project, element=self.element, deadline=deadline)\n            task.save()\n            self.task = task\n            self.accept()\n        except:\n            log.exception(\"Could not create new task\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating all necessary ui elements for the tool", "response": "def setup_ui(self, ):\n        \"\"\"Create all necessary ui elements for the tool\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        log.debug(\"Setting up the ui\")\n        self.setup_prjs_page()\n        self.setup_prj_page()\n        self.setup_seq_page()\n        self.setup_shot_page()\n        self.setup_atype_page()\n        self.setup_asset_page()\n        self.setup_dep_page()\n        self.setup_task_page()\n        self.setup_users_page()\n        self.setup_user_page()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup_prjs_page(self, ):\n        self.prjs_tablev.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n        log.debug(\"Loading projects for projects page.\")\n        rootdata = treemodel.ListItemData(['Name', 'Short', 'Path', 'Created', 'Semester', 'Status', 'Resolution', 'FPS', 'Scale'])\n        rootitem = treemodel.TreeItem(rootdata)\n        prjs = djadapter.projects.all()\n        for prj in prjs:\n            prjdata = djitemdata.ProjectItemData(prj)\n            treemodel.TreeItem(prjdata, rootitem)\n        self.prjs_model = treemodel.TreeModel(rootitem)\n        self.prjs_tablev.setModel(self.prjs_model)", "response": "Create and set the model on the projects page"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating and set the model on the project page", "response": "def setup_prj_page(self, ):\n        \"\"\"Create and set the model on the project page\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.prj_seq_tablev.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n        self.prj_atype_tablev.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n        self.prj_dep_tablev.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n        self.prj_user_tablev.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating and set the model on the shot page", "response": "def setup_shot_page(self, ):\n        \"\"\"Create and set the model on the shot page\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.shot_asset_treev.header().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n        self.shot_task_tablev.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate and set the model on the asset page", "response": "def setup_asset_page(self, ):\n        \"\"\"Create and set the model on the asset page\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.asset_asset_treev.header().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n        self.asset_task_tablev.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_users_page(self, ):\n        self.users_tablev.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n        log.debug(\"Loading users for users page.\")\n        rootdata = treemodel.ListItemData(['Username', 'First', 'Last', 'Email'])\n        rootitem = treemodel.TreeItem(rootdata)\n        users = djadapter.users.all()\n        for usr in users:\n            usrdata = djitemdata.UserItemData(usr)\n            treemodel.TreeItem(usrdata, rootitem)\n        self.users_model = treemodel.TreeModel(rootitem)\n        self.users_tablev.setModel(self.users_model)", "response": "Create and set the model on the users page"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_user_page(self, ):\n        self.user_prj_tablev.horizontalHeader().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n        self.user_task_treev.header().setResizeMode(QtGui.QHeaderView.ResizeToContents)", "response": "Create and set the model on the user page"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup_signals(self, ):\n        log.debug(\"Setting up signals.\")\n        self.setup_prjs_signals()\n        self.setup_prj_signals()\n        self.setup_seq_signals()\n        self.setup_shot_signals()\n        self.setup_atype_signals()\n        self.setup_asset_signals()\n        self.setup_dep_signals()\n        self.setup_task_signals()\n        self.setup_users_signals()\n        self.setup_user_signals()\n        log.debug(\"Signals are set up.\")", "response": "Connect the signals with the slots to make the ui functional\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setup_prj_signals(self, ):\n        log.debug(\"Setting up project page signals.\")\n        self.prj_seq_view_pb.clicked.connect(self.prj_view_seq)\n        self.prj_seq_create_pb.clicked.connect(self.prj_create_seq)\n        self.prj_atype_view_pb.clicked.connect(self.prj_view_atype)\n        self.prj_atype_add_pb.clicked.connect(self.prj_add_atype)\n        self.prj_atype_create_pb.clicked.connect(self.prj_create_atype)\n        self.prj_dep_view_pb.clicked.connect(self.prj_view_dep)\n        self.prj_dep_add_pb.clicked.connect(self.prj_add_dep)\n        self.prj_dep_create_pb.clicked.connect(self.prj_create_dep)\n        self.prj_user_view_pb.clicked.connect(self.prj_view_user)\n        self.prj_user_add_pb.clicked.connect(self.prj_add_user)\n        self.prj_user_remove_pb.clicked.connect(self.prj_remove_user)\n        self.prj_user_create_pb.clicked.connect(self.prj_create_user)\n        self.prj_path_view_pb.clicked.connect(self.prj_show_path)\n        self.prj_desc_pte.textChanged.connect(self.prj_save)\n        self.prj_semester_le.editingFinished.connect(self.prj_save)\n        self.prj_fps_dsb.valueChanged.connect(self.prj_save)\n        self.prj_res_x_sb.valueChanged.connect(self.prj_save)\n        self.prj_res_y_sb.valueChanged.connect(self.prj_save)\n        self.prj_scale_cb.currentIndexChanged.connect(self.prj_save)", "response": "Setup the signals for the project page."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setup_seq_signals(self, ):\n        log.debug(\"Setting up sequence page signals.\")\n        self.seq_prj_view_pb.clicked.connect(self.seq_view_prj)\n        self.seq_shot_view_pb.clicked.connect(self.seq_view_shot)\n        self.seq_shot_create_pb.clicked.connect(self.seq_create_shot)\n        self.seq_desc_pte.textChanged.connect(self.seq_save)", "response": "Setup the signals for the sequence page"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setup_dep_signals(self, ):\n        log.debug(\"Setting up department page signals.\")\n        self.dep_prj_view_pb.clicked.connect(self.dep_view_prj)\n        self.dep_prj_add_pb.clicked.connect(self.dep_add_prj)\n        self.dep_prj_remove_pb.clicked.connect(self.dep_remove_prj)\n        self.dep_desc_pte.textChanged.connect(self.dep_save)\n        self.dep_ordervalue_sb.valueChanged.connect(self.dep_save)", "response": "Setup the signals for the department page"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prjs_view_prj(self, *args, **kwargs):\n        i = self.prjs_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            prj = item.internal_data()\n            self.view_prj(prj)", "response": "View the in the projects table view selected project."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nviews the given project on the project page", "response": "def view_prj(self, prj):\n        \"\"\"View the given project on the project page\n\n        :param prj: the project to view\n        :type prj: :class:`jukeboxcore.djadapter.models.Project`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        log.debug('Viewing project %s', prj.name)\n        self.cur_prj = None\n        self.pages_tabw.setCurrentIndex(1)\n        self.prj_name_le.setText(prj.name)\n        self.prj_short_le.setText(prj.short)\n        self.prj_path_le.setText(prj.path)\n        self.prj_desc_pte.setPlainText(prj.description)\n        self.prj_created_dte.setDateTime(dt_to_qdatetime(prj.date_created))\n        self.prj_semester_le.setText(prj.semester)\n        self.prj_fps_dsb.setValue(prj.framerate)\n        self.prj_res_x_sb.setValue(prj.resx)\n        self.prj_res_y_sb.setValue(prj.resy)\n        scalemap = {\"m\": 2, \"meter\": 2, \"mm\": 0, \"millimeter\": 0, \"cm\": 1, \"centimeter\": 1,\n                    \"km\": 3, \"kilometer\": 3, \"inch\": 4, \"foot\": 5, \"yard\": 6, \"mile\": 7}\n        scaleindex = scalemap.get(prj.scale, -1)\n        log.debug(\"Setting index of project scale combobox to %s. Scale is %s\", scaleindex, prj.scale)\n        self.prj_scale_cb.setCurrentIndex(scaleindex)\n\n        seqrootdata = treemodel.ListItemData(['Name', \"Description\"])\n        seqrootitem = treemodel.TreeItem(seqrootdata)\n        for seq in prj.sequence_set.all():\n            seqdata = djitemdata.SequenceItemData(seq)\n            treemodel.TreeItem(seqdata, seqrootitem)\n        self.prj_seq_model = treemodel.TreeModel(seqrootitem)\n        self.prj_seq_tablev.setModel(self.prj_seq_model)\n\n        atyperootdata = treemodel.ListItemData(['Name', \"Description\"])\n        atyperootitem = treemodel.TreeItem(atyperootdata)\n        for atype in prj.atype_set.all():\n            atypedata = djitemdata.AtypeItemData(atype)\n            treemodel.TreeItem(atypedata, atyperootitem)\n        self.prj_atype_model = treemodel.TreeModel(atyperootitem)\n        self.prj_atype_tablev.setModel(self.prj_atype_model)\n\n        deprootdata = treemodel.ListItemData(['Name', \"Description\", \"Ordervalue\"])\n        deprootitem = treemodel.TreeItem(deprootdata)\n        for dep in prj.department_set.all():\n            depdata = djitemdata.DepartmentItemData(dep)\n            treemodel.TreeItem(depdata, deprootitem)\n        self.prj_dep_model = treemodel.TreeModel(deprootitem)\n        self.prj_dep_tablev.setModel(self.prj_dep_model)\n\n        userrootdata = treemodel.ListItemData(['Username', 'First', 'Last', 'Email'])\n        userrootitem = treemodel.TreeItem(userrootdata)\n        for user in prj.users.all():\n            userdata = djitemdata.UserItemData(user)\n            treemodel.TreeItem(userdata, userrootitem)\n        self.prj_user_model = treemodel.TreeModel(userrootitem)\n        self.prj_user_tablev.setModel(self.prj_user_model)\n        self.cur_prj = prj"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_prj(self, atypes=None, deps=None):\n        dialog = ProjectCreatorDialog(parent=self)\n        dialog.exec_()\n        prj = dialog.project\n        if prj and atypes:\n            for at in atypes:\n                at.projects.add(prj)\n                at.save()\n        if prj and deps:\n            for dep in deps:\n                dep.projects.add(prj)\n                dep.save()\n        if prj:\n            prjdata = djitemdata.ProjectItemData(prj)\n            treemodel.TreeItem(prjdata, self.prjs_model.root)\n        return prj", "response": "Create and return a new project with the given atypes and deps."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prj_view_seq(self, *args, **kwargs):\n        if not self.cur_prj:\n            return\n        i = self.prj_seq_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            seq = item.internal_data()\n            self.view_seq(seq)", "response": "View the in the prj_seq_tablev selected sequence."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prj_create_seq(self, *args, **kwargs):\n        if not self.cur_prj:\n            return\n        seq = self.create_seq(project=self.cur_prj)\n        if seq:\n            seqdata = djitemdata.SequenceItemData(seq)\n            treemodel.TreeItem(seqdata, self.prj_seq_model.root)", "response": "Creates a new Sequence for the current project"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef view_seq(self, seq):\n        log.debug('Viewing sequence %s', seq.name)\n        self.cur_seq = None\n        self.pages_tabw.setCurrentIndex(2)\n        self.seq_name_le.setText(seq.name)\n        self.seq_prj_le.setText(seq.project.name)\n        self.seq_desc_pte.setPlainText(seq.description)\n\n        shotrootdata = treemodel.ListItemData(['Name', \"Description\", \"Duration\", \"Start\", \"End\"])\n        shotrootitem = treemodel.TreeItem(shotrootdata)\n        for shot in seq.shot_set.all():\n            shotdata = djitemdata.ShotItemData(shot)\n            treemodel.TreeItem(shotdata, shotrootitem)\n        self.seq_shot_model = treemodel.TreeModel(shotrootitem)\n        self.seq_shot_tablev.setModel(self.seq_shot_model)\n        self.cur_seq = seq", "response": "View the given sequence on the sequence page\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_seq(self, project):\n        dialog = SequenceCreatorDialog(project=project, parent=self)\n        dialog.exec_()\n        seq = dialog.sequence\n        return seq", "response": "Create and return a new sequence"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nviewing the in the atype table view selected assettype.", "response": "def prj_view_atype(self, *args, **kwargs):\n        \"\"\"View the, in the atype table view selected, assettype.\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_prj:\n            return\n        i = self.prj_atype_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            atype = item.internal_data()\n            self.view_atype(atype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds more assettypes to the project.", "response": "def prj_add_atype(self, *args, **kwargs):\n        \"\"\"Add more assettypes to the project.\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_prj:\n            return\n        dialog = AtypeAdderDialog(project=self.cur_prj)\n        dialog.exec_()\n        atypes = dialog.atypes\n        for atype in atypes:\n            atypedata = djitemdata.AtypeItemData(atype)\n            treemodel.TreeItem(atypedata, self.prj_atype_model.root)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prj_create_atype(self, *args, **kwargs):\n        if not self.cur_prj:\n            return\n        atype = self.create_atype(projects=[self.cur_prj])\n        if atype:\n            atypedata = djitemdata.AtypeItemData(atype)\n            treemodel.TreeItem(atypedata, self.prj_atype_model.root)", "response": "Creates a new project with the specified atype."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating and return a new atype", "response": "def create_atype(self, projects):\n        \"\"\"Create and return a new atype\n\n        :param projects: the projects for the atype\n        :type projects: :class:`jukeboxcore.djadapter.models.Project`\n        :returns: The created atype or None\n        :rtype: None | :class:`jukeboxcore.djadapter.models.Atype`\n        :raises: None\n        \"\"\"\n        dialog = AtypeCreatorDialog(projects=projects, parent=self)\n        dialog.exec_()\n        atype = dialog.atype\n        return atype"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef view_atype(self, atype):\n        if not self.cur_prj:\n            return\n        log.debug('Viewing atype %s', atype.name)\n        self.cur_atype = None\n        self.pages_tabw.setCurrentIndex(4)\n        self.atype_name_le.setText(atype.name)\n        self.atype_desc_pte.setPlainText(atype.description)\n\n        assetrootdata = treemodel.ListItemData(['Name', 'Description'])\n        assetrootitem = treemodel.TreeItem(assetrootdata)\n        self.atype_asset_model = treemodel.TreeModel(assetrootitem)\n        self.atype_asset_treev.setModel(self.atype_asset_model)\n\n        for a in djadapter.assets.filter(project=self.cur_prj, atype=atype):\n            assetdata = djitemdata.AssetItemData(a)\n            treemodel.TreeItem(assetdata, assetrootitem)\n\n        self.cur_atype = atype", "response": "View the given atype on the atype page"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nviews the in the dep table view selected department.", "response": "def prj_view_dep(self, *args, **kwargs):\n        \"\"\"View the, in the dep table view selected, department.\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_prj:\n            return\n        i = self.prj_dep_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            dep = item.internal_data()\n            self.view_dep(dep)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd more departments to the project.", "response": "def prj_add_dep(self, *args, **kwargs):\n        \"\"\"Add more departments to the project.\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_prj:\n            return\n        dialog = DepAdderDialog(project=self.cur_prj)\n        dialog.exec_()\n        deps = dialog.deps\n        for dep in deps:\n            depdata = djitemdata.DepartmentItemData(dep)\n            treemodel.TreeItem(depdata, self.prj_dep_model.root)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new project and return it", "response": "def prj_create_dep(self, *args, **kwargs):\n        \"\"\"Create a new project\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_prj:\n            return\n        dep = self.create_dep(projects=[self.cur_prj])\n        if dep:\n            depdata = djitemdata.DepartmentItemData(dep)\n            treemodel.TreeItem(depdata, self.prj_dep_model.root)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_dep(self, projects):\n        dialog = DepCreatorDialog(projects=projects, parent=self)\n        dialog.exec_()\n        dep = dialog.dep\n        return dep", "response": "Create and return a new dep"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nview the given department on the page holding the page.", "response": "def view_dep(self, dep):\n        \"\"\"View the given department on the department page\n\n        :param dep: the dep to view\n        :type dep: :class:`jukeboxcore.djadapter.models.Department`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        log.debug('Viewing department %s', dep.name)\n        self.cur_dep = None\n        self.pages_tabw.setCurrentIndex(6)\n        self.dep_name_le.setText(dep.name)\n        self.dep_short_le.setText(dep.short)\n        self.dep_shot_rb.setChecked(not dep.assetflag)\n        self.dep_asset_rb.setChecked(dep.assetflag)\n        self.dep_ordervalue_sb.setValue(dep.ordervalue)\n        self.dep_desc_pte.setPlainText(dep.description)\n\n        rootdata = treemodel.ListItemData(['Name', 'Short', 'Path', 'Created', 'Semester', 'Status', 'Resolution', 'FPS', 'Scale'])\n        rootitem = treemodel.TreeItem(rootdata)\n        prjs = dep.projects.all()\n        for prj in prjs:\n            prjdata = djitemdata.ProjectItemData(prj)\n            treemodel.TreeItem(prjdata, rootitem)\n        self.dep_prj_model = treemodel.TreeModel(rootitem)\n        self.dep_prj_tablev.setModel(self.dep_prj_model)\n\n        self.cur_dep = dep"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prj_view_user(self, *args, **kwargs):\n        if not self.cur_prj:\n            return\n        i = self.prj_user_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            user = item.internal_data()\n            self.view_user(user)", "response": "View the user in the user table view selected user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding more users to the project.", "response": "def prj_add_user(self, *args, **kwargs):\n        \"\"\"Add more users to the project.\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_prj:\n            return\n        dialog = UserAdderDialog(project=self.cur_prj)\n        dialog.exec_()\n        users = dialog.users\n        for user in users:\n            userdata = djitemdata.UserItemData(user)\n            treemodel.TreeItem(userdata, self.prj_user_model.root)\n        self.cur_prj.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prj_remove_user(self, *args, **kwargs):\n        if not self.cur_prj:\n            return\n        i = self.prj_user_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            user = item.internal_data()\n            log.debug(\"Removing user %s.\", user.username)\n            item.set_parent(None)\n            self.cur_prj.users.remove(user)", "response": "Removes the user from the user table view selected."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prj_create_user(self, *args, **kwargs):\n        if not self.cur_prj:\n            return\n        user = self.create_user(projects=[self.cur_prj])\n        if user:\n            userdata = djitemdata.UserItemData(user)\n            treemodel.TreeItem(userdata, self.prj_user_model.root)", "response": "Creates a new user in the project tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating and return a new user with the given parameters.", "response": "def create_user(self, projects=None, tasks=None):\n        \"\"\"Create and return a new user\n\n        :param projects: the projects for the user\n        :type projects: list of :class:`jukeboxcore.djadapter.models.Project`\n        :param tasks: the tasks for the user\n        :type tasks: list of :class:`jukeboxcore.djadapter.models.Task`\n        :returns: The created user or None\n        :rtype: None | :class:`jukeboxcore.djadapter.models.User`\n        :raises: None\n        \"\"\"\n        projects = projects or []\n        tasks = tasks or []\n        dialog = UserCreatorDialog(projects=projects, tasks=tasks, parent=self)\n        dialog.exec_()\n        user = dialog.user\n        if user:\n            userdata = djitemdata.UserItemData(user)\n            treemodel.TreeItem(userdata, self.users_model.root)\n        return user"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nviews the given user on the user page", "response": "def view_user(self, user):\n        \"\"\"View the given user on the user page\n\n        :param user: the user to view\n        :type user: :class:`jukeboxcore.djadapter.models.User`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        log.debug('Viewing user %s', user.username)\n        self.cur_user = None\n        self.pages_tabw.setCurrentIndex(9)\n        self.user_username_le.setText(user.username)\n        self.user_first_le.setText(user.first_name)\n        self.user_last_le.setText(user.last_name)\n        self.user_email_le.setText(user.email)\n\n        prjrootdata = treemodel.ListItemData(['Name', 'Short', 'Path', 'Created', 'Semester', 'Status', 'Resolution', 'FPS', 'Scale'])\n        prjrootitem = treemodel.TreeItem(prjrootdata)\n        prjs = djadapter.projects.filter(users=user)\n        for prj in prjs:\n            prjdata = djitemdata.ProjectItemData(prj)\n            treemodel.TreeItem(prjdata, prjrootitem)\n        self.user_prj_model = treemodel.TreeModel(prjrootitem)\n        self.user_prj_tablev.setModel(self.user_prj_model)\n\n        taskrootdata = treemodel.ListItemData(['Name'])\n        taskrootitem = treemodel.TreeItem(taskrootdata)\n        self.user_task_model = treemodel.TreeModel(taskrootitem)\n        self.user_task_treev.setModel(self.user_task_model)\n        tasks = djadapter.tasks.filter(users=user)\n        assets = {}\n        shots = {}\n        atypes = {}\n        seqs = {}\n        prjs = {}\n        for t in tasks:\n            tdata = djitemdata.TaskItemData(t)\n            titem = treemodel.TreeItem(tdata)\n            e = t.element\n            if isinstance(e, djadapter.models.Asset):\n                eitem = assets.get(e)\n                if not eitem:\n                    edata = djitemdata.AssetItemData(e)\n                    eitem = treemodel.TreeItem(edata)\n                    assets[e] = eitem\n                egrp = e.atype\n                egrpitem = atypes.get(egrp)\n                if not egrpitem:\n                    egrpdata = djitemdata.AtypeItemData(egrp)\n                    egrpitem = treemodel.TreeItem(egrpdata)\n                    atypes[egrp] = egrpitem\n            else:\n                eitem = shots.get(e)\n                if not eitem:\n                    edata = djitemdata.ShotItemData(e)\n                    eitem = treemodel.TreeItem(edata)\n                    shots[e] = eitem\n                egrp = e.sequence\n                egrpitem = seqs.get(egrp)\n                if not egrpitem:\n                    egrpdata = djitemdata.SequenceItemData(egrp)\n                    egrpitem = treemodel.TreeItem(egrpdata)\n                    seqs[egrp] = egrpitem\n            if eitem not in egrpitem.childItems:\n                eitem.set_parent(egrpitem)\n            prj = egrp.project\n            prjitem = prjs.get(prj)\n            if not prjitem:\n                prjdata = djitemdata.ProjectItemData(prj)\n                prjitem = treemodel.TreeItem(prjdata, taskrootitem)\n                prjs[prj] = prjitem\n                assetdata = treemodel.ListItemData([\"Asset\"])\n                assetitem = treemodel.TreeItem(assetdata, prjitem)\n                shotdata = treemodel.ListItemData([\"Shot\"])\n                shotitem = treemodel.TreeItem(shotdata, prjitem)\n            else:\n                assetitem = prjitem.child(0)\n                shotitem = prjitem.child(1)\n            if isinstance(egrp, djadapter.models.Atype) and egrpitem not in assetitem.childItems:\n                egrpitem.set_parent(assetitem)\n            elif isinstance(egrp, djadapter.models.Sequence) and egrpitem not in shotitem.childItems:\n                egrpitem.set_parent(shotitem)\n            titem.set_parent(eitem)\n\n        self.cur_user = user"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef prj_show_path(self, ):\n        f = self.prj_path_le.text()\n        osinter = ostool.get_interface()\n        osinter.open_path(f)", "response": "Show the dir in the filebrowser of the project\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prj_save(self):\n        if not self.cur_prj:\n            return\n\n        desc = self.prj_desc_pte.toPlainText()\n        semester = self.prj_semester_le.text()\n        fps = self.prj_fps_dsb.value()\n        resx = self.prj_res_x_sb.value()\n        resy = self.prj_res_y_sb.value()\n        scale = self.prj_scale_cb.currentText()\n        self.cur_prj.description = desc\n        self.cur_prj.semester = semester\n        self.cur_prj.framerate = fps\n        self.cur_prj.resx = resx\n        self.cur_prj.resy = resy\n        self.cur_prj.scale = scale\n        self.cur_prj.save()", "response": "Save the current project"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the current sequence and its description.", "response": "def seq_save(self):\n        \"\"\"Save the current sequence\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_seq:\n            return\n\n        desc = self.seq_desc_pte.toPlainText()\n        self.cur_seq.description = desc\n        self.cur_seq.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef seq_view_shot(self, ):\n        if not self.cur_seq:\n            return\n        i = self.seq_shot_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            shot = item.internal_data()\n            self.view_shot(shot)", "response": "View the shot that is selected in the table view of the sequence page\n\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef seq_create_shot(self, *args, **kwargs):\n        if not self.cur_seq:\n            return\n        shot = self.create_shot(sequence=self.cur_seq)\n        if shot:\n            shotdata = djitemdata.ShotItemData(shot)\n            treemodel.TreeItem(shotdata, self.seq_shot_model.root)", "response": "Create a new shot in the sequence specified by the current sequence number."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nviews the given shot", "response": "def view_shot(self, shot):\n        \"\"\"View the given shot\n\n        :param shot: the shot to view\n        :type shot: :class:`jukeboxcore.djadapter.models.Shot`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        log.debug('Viewing shot %s', shot.name)\n        self.cur_shot = None\n        self.pages_tabw.setCurrentIndex(3)\n        self.shot_name_le.setText(shot.name)\n        self.shot_prj_le.setText(shot.project.name)\n        self.shot_seq_le.setText(shot.sequence.name)\n        self.shot_start_sb.setValue(shot.startframe)\n        self.shot_end_sb.setValue(shot.endframe)\n        self.shot_handle_sb.setValue(shot.handlesize)\n        self.shot_desc_pte.setPlainText(shot.description)\n\n        assetsrootdata = treemodel.ListItemData([\"Name\", \"Description\"])\n        assetsrootitem = treemodel.TreeItem(assetsrootdata)\n        self.shot_asset_model = treemodel.TreeModel(assetsrootitem)\n        self.shot_asset_treev.setModel(self.shot_asset_model)\n        atypes = {}\n        assets = shot.assets.all()\n        for a in assets:\n            atype = a.atype\n            atypeitem = atypes.get(atype)\n            if not atypeitem:\n                atypedata = djitemdata.AtypeItemData(atype)\n                atypeitem = treemodel.TreeItem(atypedata, assetsrootitem)\n                atypes[atype] = atypeitem\n            assetdata = djitemdata.AssetItemData(a)\n            treemodel.TreeItem(assetdata, atypeitem)\n\n        tasksrootdata = treemodel.ListItemData([\"Name\", \"Short\"])\n        tasksrootitem = treemodel.TreeItem(tasksrootdata)\n        self.shot_task_model = treemodel.TreeModel(tasksrootitem)\n        self.shot_task_tablev.setModel(self.shot_task_model)\n        tasks = shot.tasks.all()\n        for t in tasks:\n            tdata = djitemdata.TaskItemData(t)\n            treemodel.TreeItem(tdata, tasksrootitem)\n\n        self.cur_shot = shot"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating and return a new shot", "response": "def create_shot(self, sequence):\n        \"\"\"Create and return a new shot\n\n        :param sequence: the sequence for the shot\n        :type sequence: :class:`jukeboxcore.djadapter.models.Sequence`\n        :returns: The created shot or None\n        :rtype: None | :class:`jukeboxcore.djadapter.models.Shot`\n        :raises: None\n        \"\"\"\n        dialog = ShotCreatorDialog(sequence=sequence, parent=self)\n        dialog.exec_()\n        shot = dialog.shot\n        return shot"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nview the task that is currently selected on the shot page", "response": "def shot_view_task(self, ):\n        \"\"\"View the task that is currently selected on the shot page\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_shot:\n            return\n\n        i = self.shot_task_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            task = item.internal_data()\n            self.view_task(task)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nview the task that is currently selected on the shot page", "response": "def shot_view_asset(self, ):\n        \"\"\"View the task that is currently selected on the shot page\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_shot:\n            return\n\n        i = self.shot_asset_treev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            asset = item.internal_data()\n            if isinstance(asset, djadapter.models.Asset):\n                self.view_asset(asset)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new task in the shot tree model.", "response": "def shot_create_task(self, *args, **kwargs):\n        \"\"\"Create a new task\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_shot:\n            return\n        task = self.create_task(element=self.cur_shot)\n        if task:\n            taskdata = djitemdata.TaskItemData(task)\n            treemodel.TreeItem(taskdata, self.shot_task_model.root)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new task for the given element", "response": "def create_task(self, element):\n        \"\"\"Create a new task for the given element\n\n        :param element: the element for the task\n        :type element: :class:`jukeboxcore.djadapter.models.Shot` | :class:`jukeboxcore.djadapter.models.Asset`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        dialog = TaskCreatorDialog(element=element, parent=self)\n        dialog.exec_()\n        task = dialog.task\n        return task"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nview the given asset", "response": "def view_asset(self, asset):\n        \"\"\"View the given asset\n\n        :param asset: the asset to view\n        :type asset: :class:`jukeboxcore.djadapter.models.Asset`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        log.debug('Viewing asset %s', asset.name)\n        self.cur_asset = None\n        self.pages_tabw.setCurrentIndex(5)\n\n        name = asset.name\n        prj = asset.project.name\n        atype = asset.atype.name\n        desc = asset.description\n        self.asset_name_le.setText(name)\n        self.asset_prj_le.setText(prj)\n        self.asset_atype_le.setText(atype)\n        self.asset_desc_pte.setPlainText(desc)\n\n        assetsrootdata = treemodel.ListItemData([\"Name\", \"Description\"])\n        assetsrootitem = treemodel.TreeItem(assetsrootdata)\n        self.asset_asset_model = treemodel.TreeModel(assetsrootitem)\n        self.asset_asset_treev.setModel(self.asset_asset_model)\n        atypes = {}\n        assets = asset.assets.all()\n        for a in assets:\n            atype = a.atype\n            atypeitem = atypes.get(atype)\n            if not atypeitem:\n                atypedata = djitemdata.AtypeItemData(atype)\n                atypeitem = treemodel.TreeItem(atypedata, assetsrootitem)\n                atypes[atype] = atypeitem\n            assetdata = djitemdata.AssetItemData(a)\n            treemodel.TreeItem(assetdata, atypeitem)\n\n        tasksrootdata = treemodel.ListItemData([\"Name\", \"Short\"])\n        tasksrootitem = treemodel.TreeItem(tasksrootdata)\n        self.asset_task_model = treemodel.TreeModel(tasksrootitem)\n        self.asset_task_tablev.setModel(self.asset_task_model)\n        tasks = asset.tasks.all()\n        for t in tasks:\n            tdata = djitemdata.TaskItemData(t)\n            treemodel.TreeItem(tdata, tasksrootitem)\n\n        self.cur_asset = asset"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds more assets to the shot.", "response": "def shot_add_asset(self, *args, **kwargs):\n        \"\"\"Add more assets to the shot.\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_shot:\n            return\n        dialog = AssetAdderDialog(shot=self.cur_shot)\n        dialog.exec_()\n        assets = dialog.assets\n        atypes = {}\n        for c in self.shot_asset_model.root.childItems:\n            atypes[c.internal_data()] = c\n        for asset in assets:\n            atypeitem = atypes.get(asset.atype)\n            if not atypeitem:\n                atypedata = djitemdata.AtypeItemData(asset.atype)\n                atypeitem = treemodel.TreeItem(atypedata, self.shot_asset_model.root)\n                atypes[asset.atype] = atypeitem\n            assetdata = djitemdata.AssetItemData(asset)\n            treemodel.TreeItem(assetdata, atypeitem)\n        self.cur_shot.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves the asset from the shot table view selected.", "response": "def shot_remove_asset(self, *args, **kwargs):\n        \"\"\"Remove the, in the asset table view selected, asset.\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_shot:\n            return\n        i = self.shot_asset_treev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            asset = item.internal_data()\n            if not isinstance(asset, djadapter.models.Asset):\n                return\n            log.debug(\"Removing asset %s.\", asset.name)\n            item.set_parent(None)\n            self.cur_shot.assets.remove(asset)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef shot_create_asset(self, *args, **kwargs):\n        if not self.cur_shot:\n            return\n        asset = self.create_asset(project=self.cur_shot.project, shot=self.cur_shot)\n        if not asset:\n            return\n        atypes = {}\n        for c in self.shot_asset_model.root.childItems:\n            atypes[c.internal_data()] = c\n        atypeitem = atypes.get(asset.atype)\n        if not atypeitem:\n            atypedata = djitemdata.AtypeItemData(asset.atype)\n            atypeitem = treemodel.TreeItem(atypedata, self.shot_asset_model.root)\n            atypes[asset.atype] = atypeitem\n        assetdata = djitemdata.AssetItemData(asset)\n        treemodel.TreeItem(assetdata, atypeitem)", "response": "Create a new shot and return it."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_asset(self, project, atype=None, shot=None, asset=None):\n        element = shot or asset\n        dialog = AssetCreatorDialog(project=project, atype=atype, parent=self)\n        dialog.exec_()\n        asset = dialog.asset\n        if not atype:\n            element.assets.add(asset)\n        return asset", "response": "Create and return a new asset"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nviewing the given task in the hierarchy.", "response": "def view_task(self, task):\n        \"\"\"View the given task\n\n        :param task: the task to view\n        :type task: :class:`jukeboxcore.djadapter.models.Task`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        log.debug('Viewing task %s', task.name)\n        self.cur_task = None\n        self.pages_tabw.setCurrentIndex(7)\n\n        self.task_dep_le.setText(task.name)\n        statusmap = {\"New\": 0, \"Open\": 1, \"Done\":2}\n        self.task_status_cb.setCurrentIndex(statusmap.get(task.status, -1))\n        dt = dt_to_qdatetime(task.deadline) if task.deadline else None\n        self.task_deadline_de.setDateTime(dt)\n\n        self.task_link_le.setText(task.element.name)\n\n        userrootdata = treemodel.ListItemData(['Username', 'First', 'Last', 'Email'])\n        userrootitem = treemodel.TreeItem(userrootdata)\n        for user in task.users.all():\n            userdata = djitemdata.UserItemData(user)\n            treemodel.TreeItem(userdata, userrootitem)\n        self.task_user_model = treemodel.TreeModel(userrootitem)\n        self.task_user_tablev.setModel(self.task_user_model)\n\n        self.cur_task = task"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the current shot.", "response": "def shot_save(self, ):\n        \"\"\"Save the current shot\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_shot:\n            return\n\n        desc = self.shot_desc_pte.toPlainText()\n        start = self.shot_start_sb.value()\n        end = self.shot_end_sb.value()\n        handle = self.shot_handle_sb.value()\n        self.cur_shot.description = desc\n        self.cur_shot.startframe = start\n        self.cur_shot.endframe = end\n        self.cur_shot.handlesize = handle\n        self.cur_shot.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef asset_view_prj(self, ):\n        if not self.cur_asset:\n            return\n\n        prj = self.cur_asset.project\n        self.view_prj(prj)", "response": "View the project of the current asset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef asset_view_atype(self, ):\n        if not self.cur_asset:\n            return\n\n        atype = self.cur_asset.atype\n        self.view_atype(atype)", "response": "View the project of the current atype"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef atype_view_asset(self, ):\n        if not self.cur_atype:\n            return\n\n        i = self.atype_asset_treev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            asset = item.internal_data()\n            if isinstance(asset, djadapter.models.Asset):\n                self.view_asset(asset)", "response": "View the project of the current assettype"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new asset and return it", "response": "def atype_create_asset(self, ):\n        \"\"\"Create a new asset\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_atype:\n            return\n\n        asset = self.create_asset(project=self.cur_prj, atype=self.cur_atype)\n\n        if not asset:\n            return\n        assetdata = djitemdata.AssetItemData(asset)\n        treemodel.TreeItem(assetdata, self.atype_asset_model.root)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef atype_save(self):\n        if not self.cur_atype:\n            return\n\n        desc = self.atype_desc_pte.toPlainText()\n        self.cur_atype.description = desc\n        self.cur_atype.save()", "response": "Save the current atype"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nviewing the task that is currently selected on the asset page", "response": "def asset_view_asset(self, ):\n        \"\"\"View the task that is currently selected on the asset page\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_asset:\n            return\n\n        i = self.asset_asset_treev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            asset = item.internal_data()\n            if isinstance(asset, djadapter.models.Asset):\n                self.view_asset(asset)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding more assets to the asset.", "response": "def asset_add_asset(self, *args, **kwargs):\n        \"\"\"Add more assets to the asset.\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_asset:\n            return\n        dialog = AssetAdderDialog(asset=self.cur_asset)\n        dialog.exec_()\n        assets = dialog.assets\n        atypes = {}\n        for c in self.asset_asset_model.root.childItems:\n            atypes[c.internal_data()] = c\n        for asset in assets:\n            atypeitem = atypes.get(asset.atype)\n            if not atypeitem:\n                atypedata = djitemdata.AtypeItemData(asset.atype)\n                atypeitem = treemodel.TreeItem(atypedata, self.asset_asset_model.root)\n                atypes[asset.atype] = atypeitem\n            assetdata = djitemdata.AssetItemData(asset)\n            treemodel.TreeItem(assetdata, atypeitem)\n        self.cur_asset.save()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef asset_remove_asset(self, *args, **kwargs):\n        if not self.cur_asset:\n            return\n        i = self.asset_asset_treev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            asset = item.internal_data()\n            if not isinstance(asset, djadapter.models.Asset):\n                return\n            log.debug(\"Removing asset %s.\", asset.name)\n            item.set_parent(None)\n            self.cur_asset.assets.remove(asset)", "response": "Removes the asset from the asset table view selected."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new asset and return it", "response": "def asset_create_asset(self, *args, **kwargs):\n        \"\"\"Create a new asset\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_asset:\n            return\n        asset = self.create_asset(project=self.cur_asset.project, asset=self.cur_asset)\n        if not asset:\n            return\n        atypes = {}\n        for c in self.asset_asset_model.root.childItems:\n            atypes[c.internal_data()] = c\n        atypeitem = atypes.get(asset.atype)\n        if not atypeitem:\n            atypedata = djitemdata.AtypeItemData(asset.atype)\n            atypeitem = treemodel.TreeItem(atypedata, self.asset_asset_model.root)\n            atypes[asset.atype] = atypeitem\n        assetdata = djitemdata.AssetItemData(asset)\n        treemodel.TreeItem(assetdata, atypeitem)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nview the task that is currently selected on the asset page", "response": "def asset_view_task(self, ):\n        \"\"\"View the task that is currently selected on the asset page\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_asset:\n            return\n\n        i = self.asset_task_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            task = item.internal_data()\n            self.view_task(task)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef asset_create_task(self, *args, **kwargs):\n        if not self.cur_asset:\n            return\n        task = self.create_task(element=self.cur_asset)\n        if task:\n            taskdata = djitemdata.TaskItemData(task)\n            treemodel.TreeItem(taskdata, self.asset_task_model.root)", "response": "Create a new task in the asset tree model."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves the current asset", "response": "def asset_save(self):\n        \"\"\"Save the current asset\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_asset:\n            return\n\n        desc = self.asset_desc_pte.toPlainText()\n        self.cur_asset.description = desc\n        self.cur_asset.save()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nviewing the project that is currently selected", "response": "def dep_view_prj(self, ):\n        \"\"\"View the project that is currently selected\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_dep:\n            return\n        i = self.dep_prj_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            prj = item.internal_data()\n            self.view_prj(prj)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dep_add_prj(self, *args, **kwargs):\n        if not self.cur_dep:\n            return\n\n        dialog = ProjectAdderDialog(department=self.cur_dep)\n        dialog.exec_()\n        prjs = dialog.projects\n        for prj in prjs:\n            prjdata = djitemdata.ProjectItemData(prj)\n            treemodel.TreeItem(prjdata, self.dep_prj_model.root)", "response": "Adds projects to the current department."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dep_remove_prj(self, *args, **kwargs):\n        if not self.cur_dep:\n            return\n        i = self.dep_prj_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            prj = item.internal_data()\n            self.cur_dep.projects.remove(prj)\n            item.set_parent(None)", "response": "Removes the selected project from the department\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dep_save(self, ):\n        if not self.cur_dep:\n            return\n        ordervalue = self.dep_ordervalue_sb.value()\n        desc = self.dep_desc_pte.toPlainText()\n        self.cur_dep.ordervalue = ordervalue\n        self.cur_dep.description = desc\n        self.cur_dep.save()", "response": "Save the current department"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nview the user that is currently selected", "response": "def task_view_user(self, ):\n        \"\"\"View the user that is currently selected\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_task:\n            return\n        i = self.task_user_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            user = item.internal_data()\n            self.view_user(user)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef task_add_user(self, *args, **kwargs):\n        if not self.cur_task:\n            return\n\n        dialog = UserAdderDialog(task=self.cur_task)\n        dialog.exec_()\n        users = dialog.users\n        for user in users:\n            userdata = djitemdata.UserItemData(user)\n            treemodel.TreeItem(userdata, self.task_user_model.root)", "response": "Adds users to the current task s user store"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the selected user from the task s users list.", "response": "def task_remove_user(self, *args, **kwargs):\n        \"\"\"Remove the selected user from the task\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_task:\n            return\n        i = self.task_user_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            user = item.internal_data()\n            self.cur_task.users.remove(user)\n            item.set_parent(None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nviews the link of the current task", "response": "def task_view_link(self, ):\n        \"\"\"View the link of the current task\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_task:\n            return\n        e = self.cur_task.element\n        if isinstance(e, djadapter.models.Asset):\n            self.view_asset(e)\n        else:\n            self.view_shot(e)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave the current task", "response": "def task_save(self, ):\n        \"\"\"Save the current task\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_task:\n            return\n        deadline = self.task_deadline_de.dateTime().toPython()\n        status = self.task_status_cb.currentText()\n        self.cur_task.deadline = deadline\n        self.cur_task.status = status\n        self.cur_task.save()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef users_view_user(self, ):\n        i = self.users_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            user = item.internal_data()\n            self.view_user(user)", "response": "View the user that is currently selected\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef user_view_task(self, ):\n        if not self.cur_user:\n            return\n        i = self.user_task_treev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            task = item.internal_data()\n            if isinstance(task, djadapter.models.Task):\n                self.view_task(task)", "response": "View the task that is selected by the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef user_view_prj(self, ):\n        i = self.user_prj_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            prj = item.internal_data()\n            self.view_prj(prj)", "response": "View the project that is currently selected\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding projects to the current user s user s user s user s list of available projects.", "response": "def user_add_prj(self, *args, **kwargs):\n        \"\"\"Add projects to the current user\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_user:\n            return\n\n        dialog = ProjectAdderDialog(user=self.cur_user)\n        dialog.exec_()\n        prjs = dialog.projects\n        for prj in prjs:\n            prjdata = djitemdata.ProjectItemData(prj)\n            treemodel.TreeItem(prjdata, self.user_prj_model.root)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove the selected project from the user s project list.", "response": "def user_remove_prj(self, *args, **kwargs):\n        \"\"\"Remove the selected project from the user\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if not self.cur_user:\n            return\n        i = self.user_prj_tablev.currentIndex()\n        item = i.internalPointer()\n        if item:\n            prj = item.internal_data()\n            prj.users.remove(self.cur_user)\n            item.set_parent(None)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef user_save(self):\n        if not self.cur_user:\n            return\n\n        username = self.user_username_le.text()\n        first = self.user_first_le.text()\n        last = self.user_last_le.text()\n        email = self.user_email_le.text()\n        self.cur_user.username = username\n        self.cur_user.first_name = first\n        self.cur_user.last_name = last\n        self.cur_user.email = email\n        self.cur_user.save()", "response": "Save the current user"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self, parent=None):\n        self.gw = GuerillaMGMTWin(parent=parent)\n        self.gw.show()", "response": "Start the configeditor\n\n        :returns: None\n        :rtype: None\n        :raises: None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self):\n        notice('Starting output thread', self.color)\n        o = Thread(target=self.__output_thread, name='output')\n        o.start()\n        self.threads.append(o)\n        try:\n            notice('Starting input thread', self.color)\n            self.__input_thread()\n        except KeyboardInterrupt:\n            self.__shutdown()", "response": "Run self on provided screen"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets info from sockets", "response": "def __get_instructions(self):\n        \"Get info from sockets\"\n        if self.mode == 'c':\n            c, m = utils.recv(self.__s)\n            inst = [(c, m, self.__s)]\n        else:\n            inst = []\n            with self.__client_list_lock:\n                for com in self.clients:\n                    c, m = utils.recv(com)\n                    if c is not None:\n                        inst.append((c, m, com))\n        return inst"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __process_instructions(self, inst):\n        \"Act on instructions recieved\"\n        to_send = []\n        for cmd, msg, com in inst:\n            if cmd not in config.CMDS:  # ignore if it is not legal\n                continue\n            if cmd == 'MSG':\n                if self.mode == 's':\n                    to_send.append((msg, com))\n                if self.color:\n                    txt = config.Col.BOLD + msg + config.Col.ENDC\n                else:\n                    txt = msg\n                print(txt)\n                if self.issue_alert:\n                    os.system(self.alert)\n            elif cmd == 'QUIT':\n                if self.mode == 's':  # client quit\n                    com.close()\n                    with self.__client_list_lock:\n                        self.clients.remove(com)\n                else:  # server quit\n                    self.__s.close()\n                    self.__make_client()  # wait for new server\n            elif cmd == 'ASSUME':\n                if self.mode == 'c':  # assume a server role if client\n                    self.__s.close()\n                    self.__make_server()\n        for msg, sender in to_send:\n            if self.mode == 'c':\n                utils.msg(msg, self.__s)\n            else:\n                with self.__client_list_lock:\n                    for com in self.clients:\n                        if com == sender:\n                            continue\n                        utils.msg(msg, com)", "response": "Act on instructions recieved"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmake this node a server", "response": "def __make_server(self):\n        \"Make this node a server\"\n        notice('Making server, getting listening socket', self.color)\n        self.mode = 's'\n        sock = utils.get_server_sock()\n        self.__s = sock\n        with self.__client_list_lock:\n            self.clients = deque()\n        self.threads = deque()\n        notice('Making beacon', self.color)\n        b = Thread(target=self.__beacon_thread, name='beacon')\n        b.start()\n        self.threads.append(b)\n        l = Thread(target=self.__listen_thread, name='listen')\n        notice('Starting listen thread', self.color)\n        l.start()\n        self.threads.append(l)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake this node a client", "response": "def __make_client(self):\n        \"Make this node a client\"\n        notice('Making client, getting server connection', self.color)\n        self.mode = 'c'\n        addr = utils.get_existing_server_addr()\n        sock = utils.get_client_sock(addr)\n        self.__s = sock\n        with self.__client_list_lock:\n            self.clients = deque()\n        self.threads = deque()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef coordinates_to_array(\n        log,\n        ra,\n        dec):\n    \"\"\"*Convert a single value RA, DEC or list of RA and DEC to numpy arrays*\n\n    **Key Arguments:**\n        - ``ra`` -- list, numpy array or single ra value\n        - ``dec`` --list, numpy array or single dec value\n        - ``log`` -- logger\n\n    **Return:**\n        - ``raArray`` -- input RAs as a numpy array of decimal degree values\n        - ``decArray`` -- input DECs as a numpy array of decimal degree values\n\n    **Usage:**\n        .. todo::\n\n            add usage info\n            create a sublime snippet for usage\n\n        .. code-block:: python\n\n            ra, dec = coordinates_to_array(\n                log=log,\n                ra=ra,\n                dec=dec\n            )\n    \"\"\"\n    log.info('starting the ``coordinates_to_array`` function')\n\n    if isinstance(ra, np.ndarray) and isinstance(dec, np.ndarray):\n        return ra, dec\n\n    # ASTROCALC UNIT CONVERTER OBJECT\n    converter = unit_conversion(\n        log=log\n    )\n    # CONVERT RA AND DEC TO NUMPY ARRAYS\n    if isinstance(ra, float):\n        pass\n    elif isinstance(ra, str):\n        try:\n            ra = float(ra)\n        except:\n            ra = converter.ra_sexegesimal_to_decimal(ra=ra)\n    elif isinstance(ra, list):\n        try:\n            ra = np.array(ra).astype(np.float)\n        except:\n            raList = []\n            raList[:] = [converter.ra_sexegesimal_to_decimal(ra=r) for r in ra]\n            ra = raList\n\n    if isinstance(dec, float):\n        pass\n    elif isinstance(dec, str):\n        try:\n            dec = float(dec)\n        except:\n            dec = converter.dec_sexegesimal_to_decimal(dec=dec)\n    elif isinstance(dec, list):\n        try:\n            dec = np.array(dec).astype(np.float)\n        except:\n            decList = []\n            decList[:] = [\n                converter.dec_sexegesimal_to_decimal(dec=d) for d in dec]\n            dec = decList\n\n    raArray = np.array(ra, dtype='f8', ndmin=1, copy=False)\n    decArray = np.array(dec, dtype='f8', ndmin=1, copy=False)\n\n    log.info('completed the ``coordinates_to_array`` function')\n    return raArray, decArray", "response": "Convert a single value RA and DEC or list of RA and DEC to numpy arrays"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a message to the server.", "response": "def Send(self, msg):\n        \"\"\"\n        Add a note to the database on the server\n        :param msg: The text of the note.\n        :type msg: str\n        :param tags: A list of tags to associate with the note.\n        :type tags: list\n        :returns: The message from the server\n        :rtype: str\n        \"\"\"\n        if 'type' not in msg:\n            return\n\n        self.sock.send(json.dumps(msg))\n        msg = self.sock.recv()\n        return msg"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef erase_lines(n=1):\n    for _ in range(n):\n        print(codes.cursor[\"up\"], end=\"\")\n        print(codes.cursor[\"eol\"], end=\"\")", "response": "Erases n lines from the screen and moves the cursor up to follow\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmoves the cursor the given number of columns and rows and returns the new node.", "response": "def move_cursor(cols=0, rows=0):\n    \"\"\" Moves the cursor the given number of columns and rows\n    \n    The cursor is moved right when cols is positive and left when negative.\n    The cursor is moved down when rows is positive and down when negative.\n    \"\"\"\n    if cols == 0 and rows == 0:\n        return\n    commands = \"\"\n    commands += codes.cursor[\"up\" if rows < 0 else \"down\"] * abs(rows)\n    commands += codes.cursor[\"left\" if cols < 0 else \"right\"] * abs(cols)\n    if commands:\n        print(commands, end=\"\")\n        stdout.flush()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nformats text in terminal control sequences.", "response": "def style_format(text, style):\n    \"\"\" Wraps texts in terminal control sequences\n\n    Style can be passed as either a collection or space delimited string.\n    Valid styles can be found in the codes module. Invalid or unsuported styles\n    will just be ignored.\n    \"\"\"\n    if not style:\n        return text\n    if isinstance(style, str):\n        style = style.split(\" \")\n    prefix = \"\"\n    for s in style:\n        prefix += codes.colours.get(s, \"\")\n        prefix += codes.highlights.get(s, \"\")\n        prefix += codes.modes.get(s, \"\")\n    return prefix + text + codes.modes[\"reset\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef style_print(*values, **kwargs):\n    style = kwargs.pop(\"style\", None)\n    values = [style_format(value, style) for value in values]\n    print(*values, **kwargs)", "response": "A convenience function that applies style_format to text before printing\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_authentication_tokens(self):\n        callback_url = self.callback_url or 'oob'\n        request_args = {}\n        if OAUTH_LIB_SUPPORTS_CALLBACK:\n            request_args['callback_url'] = callback_url\n\n        resp, content = self.client.request(self.request_token_url,\n            \"GET\", **request_args)\n\n        if resp['status'] != '200':\n            raise AuthError(\"Seems something couldn't be verified \"\\\n                \"withyour OAuth junk. Error: %s, Message: %s\" \\\n                % (resp['status'], content))\n\n        request_tokens = dict(urlparse.parse_qsl(content))\n        oauth_callback_confirmed = request_tokens\\\n            .get('oauth_callback_confirmed') == 'true'\n\n        if not OAUTH_LIB_SUPPORTS_CALLBACK and callback_url != 'oob'\\\n            and oauth_callback_confirmed:\n            import warnings\n            warnings.warn(\"oauth2 library doesn't support OAuth 1.0a\"\\\n                \" type callback, but remote requires it\")\n            oauth_callback_confirmed = False\n\n        auth_url_params = {'oauth_token': request_tokens['oauth_token']}\n\n        # Use old-style callback argument\n        if callback_url != 'oob' and not oauth_callback_confirmed:\n            auth_url_params['oauth_callback'] = callback_url\n\n        request_tokens['auth_url'] = self.authenticate_url + '?'\\\n            + urllib.urlencode(auth_url_params)\n\n        return request_tokens", "response": "Returns an authorization URL for a user to hit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_authorized_tokens(self):\n        resp, content = self.client.request(self.access_token_url, \"GET\")\n        return dict(urlparse.parse_qsl(content))", "response": "Returns a dict of authorized tokens after they go through the auth_url phase."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates new connection file props from default properties", "response": "def generate(cls, partial_props=None):\n        \"\"\"\n        Generate new connection file props from\n        defaults\n        \"\"\"\n        partial_props = partial_props or {}\n        props = partial_props.copy()\n        props.update(cls.DEFAULT_PROPERTIES)\n        return cls(props)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_file(self):\n        name = \"kernel-{pid}.json\".format(pid=os.getpid())\n        path = os.path.join(jupyter_runtime_dir(), name)\n\n        # indentation, because why not.\n        connection_json = json.dumps(self.connection_props, indent=2)\n\n        with open(path, \"w\") as connection_file:\n            connection_file.write(connection_json)\n        \n        return path", "response": "Write a new connection file to disk. and\n        returns its path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild the decoder computational graph for the given node properties.", "response": "def build(self):\n        \"\"\"\n        The decoder computational graph consists of three components:\n        (1) the input node                       `decoder_input`\n        (2) the embedding node                   `decoder_embed`\n        (3) the recurrent (RNN) part             `decoder_rnn`\n        (4) the output of the decoder RNN        `decoder_output`\n        (5) the classification output layer      `decoder_dense`\n        \"\"\"\n        \n        # Grab hyperparameters from self.config:\n        hidden_dim = self.config['encoding-layer-width']\n        recurrent_unit = self.config['recurrent-unit-type']\n        bidirectional = False #self.config['encoding-layer-bidirectional']\n        vocab_size = self.data.properties.vocab_size\n        embedding_dim = math.ceil(math.log(vocab_size, 2))    # self.config['embedding-dim']\n        input_length = self.data.properties['max-utterance-length'] + 1\n        \n        # Assemble the network components:\n        decoder_input = Input(shape=(None,))\n        decoder_embed = Embedding(vocab_size, embedding_dim, mask_zero=True)(decoder_input) #, input_length=input_length)(decoder_input)\n        \n        if recurrent_unit == 'lstm':\n            decoder_rnn = LSTM(hidden_dim, return_sequences=True, return_state=True)\n            decoder_output, decoder_h, decoder_c = decoder_rnn(decoder_embed,\n                                                initial_state=self.encoder.encoder_hidden_state)\n        elif recurrent_unit == 'gru':\n            decoder_rnn = GRU(hidden_dim, return_sequences=True, return_state=True)\n            decoder_output, _ = decoder_rnn(decoder_embed, \n                                             initial_state=self.encoder.encoder_hidden_state)\n        else:\n            raise Exception('Invalid recurrent unit type: {}'.format(recurrent_unit))\n        \n        # make the RNN component bidirectional, if desired\n        if bidirectional:\n            decoder_rnn = Bidirectional(decoder_rnn, merge_mode='ave')\n        \n        decoder_dense = Dense(vocab_size, activation='softmax')\n        decoder_output = decoder_dense(decoder_output)\n        \n        # save the four Decoder components as class state\n        self.decoder_input = decoder_input\n        self.decoder_embed = decoder_embed\n        self.decoder_rnn = decoder_rnn\n        self.decoder_dense = decoder_dense\n        self.decoder_output = decoder_output\n        \n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the minimum of the given function f. The arguments are the given function f, and given a bracketing triplet of abscissas A, B, C (such that B is between A and C, and f(B) is less than both f(A) and f(C)) and the Tolerance. This routine isolates the minimum to a fractional precision of about tol using Brent's method. The abscissa of of the minimum is returned as xmin, and the minimum value is returned as brent, the returned function value.", "response": "def minimize_algorithm_1dim_brent(fct, _a, _b, _c, tolerance=DOUBLE_TOL):\n    '''\n    Finds the minimum of the given function f. The arguments are the given function f, and given a bracketing triplet of abscissas A, B, C\n    (such that B is between A and C, and f(B) is less than both f(A) and f(C)) and the Tolerance.\n    This routine isolates the minimum to a fractional precision of about tol using\n    Brent's method. The abscissa of of the minimum is returned as xmin, and the minimum\n    value is returned as brent, the returned function value.\n    '''\n\n    ''' ZEPS is a small number that protects against trying to achieve fractional accuracy\n    for a minimum that happens to be exactly zero. '''\n    ZEPS = 1.0e-10\n\n    a = _a if _a < _c else _c\n    b = _a if _a > _c else _c\n    assert a < _b and _b < b\n\n    x = w = v = _b;\n    fv = fw = fx = fct(x)\n    tol1 = tolerance\n    d = e = 0.0\n    e_temp = fu = u = xm = 0.0\n    iterations = 0\n\n    while (True):\n        xm = 0.5 * (a + b)\n        tol1 = tolerance * abs(x) + ZEPS\n        tol2 = 2.0 * tol1;\n        if abs(x - xm) <= tol2 - 0.5 * (b - a):\n            return (x, fx)\n        if abs(e) > tol1:\n            r = (x - w) * (fx - fv)\n            q = (x - v) * (fx - fw)\n            p = (x - v) * q - (x - w) * r\n            q = 2.0 * (q - r)\n            if q > 0.0:\n                p = -p\n            q = abs(q)\n            e_temp = e\n            e = d\n            if abs(p) >= abs(0.5 * q * e_temp) or p <= q * (a - x) or p >= q * (b - x):\n                e = a - x if x >= xm else b - x\n                d = GOLD * e\n            else:\n                d = p / q\n                u = x + d\n                if u - a < tol2 or b - u < tol2:\n                    d = abs_sign(tol1, xm - x)\n        else:\n            e = a - x if x >= xm else b - x\n            d = GOLD * e\n\n        u = x + d if abs(d) >= tol1 else x + abs_sign(tol1, d)\n        fu = fct(u);\n        if fu <= fx:\n            if u >= x:\n                a = x\n            else:\n                b = x\n            v, w, x = shift(w, x, u)\n            fv, fw, fx = shift(fw, fx, fu)\n        else:\n            if u < x:\n                a = u\n            else:\n                b = u\n        if fu <= fw or float_equal(w, x):\n            v = w\n            w = u\n            fv = fw\n            fw = fu\n        elif float_equal(fu, fv) or float_equal(v, x) or float_equal(v, w):\n            v = u\n            fv = fu\n\n        iterations = iterations + 1\n        if iterations > 10000:\n            return (None, None)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nverifying that the GFF3 format is correct.", "response": "def gff3_verifier(entries, line=None):\n    \"\"\"Raises error if invalid GFF3 format detected\n\n    Args:\n        entries (list): A list of GFF3Entry instances\n\n        line (int): Line number of first entry\n\n    Raises:\n        FormatError: Error when GFF3 format incorrect with descriptive message\n    \"\"\"\n\n    regex = r'^[a-zA-Z0-9.:^*$@!+_?-|]+\\t.+\\t.+\\t\\d+\\t\\d+\\t' \\\n            + r'\\d*\\.?\\d*\\t[+-.]\\t[.0-2]\\t.+{0}$'.format(os.linesep)\n    delimiter = r'\\t'\n\n    for entry in entries:\n        try:\n            entry_verifier([entry.write()], regex, delimiter)\n        except FormatError as error:\n            # Format info on what entry error came from\n            if line:\n                intro = 'Line {0}'.format(str(line))\n            elif error.part == 0:\n                intro = 'Entry with source {0}'.format(entry.source)\n            else:\n                intro = 'Entry with Sequence ID {0}'.format(entry.seqid)\n\n            # Generate error\n            if error.part == 0:\n                msg = '{0} has no Sequence ID'.format(intro)\n            elif error.part == 1:\n                msg = '{0} has no source'.format(intro)\n            elif error.part == 2:\n                msg = '{0} has non-numerical characters in type'.format(intro)\n            elif error.part == 3:\n                msg = '{0} has non-numerical characters in ' \\\n                      'start position'.format(intro)\n            elif error.part == 4:\n                msg = '{0} has non-numerical characters in ' \\\n                      'end position'.format(intro)\n            elif error.part == 5:\n                msg = '{0} has non-numerical characters in score'.format(intro)\n            elif error.part == 6:\n                msg = '{0} strand not in [+-.]'.format(intro)\n            elif error.part == 7:\n                msg = '{0} phase not in [.0-2]'.format(intro)\n            elif error.part == 8:\n                msg = '{0} has no attributes'.format(intro)\n            else:\n                msg = 'Unknown Error: Likely a Bug'\n            raise FormatError(message=msg)\n\n        if line:\n            line += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing time string and return seconds.", "response": "def parse(s, return_type=int):\n    '''\n    Parse time string and return seconds.\n    You can specify the type of return value both int or datetime.timedelta\n    with 'return_type' argument.\n    '''\n    RE_DAY = r'([0-9]+)d(ay)?'\n    RE_HOUR = r'([0-9]+)h(our)?'\n    RE_MINUTE = r'([0-9]+)m(in(ute)?)?'\n    RE_SECOND = r'([0-9]+)(s(ec(ond)?)?)?'\n\n    def _parse_time_with_unit(s):\n        retval = 0\n        md = re.match(RE_DAY, s)\n        mh = re.match(RE_HOUR, s)\n        mm = re.match(RE_MINUTE, s)\n        ms = re.match(RE_SECOND, s)\n        if md:\n            retval = 86400 * int(md.group(1))\n        elif mh:\n            retval = 3600 * int(mh.group(1))\n        elif mm:\n            retval = 60 * int(mm.group(1))\n        elif ms:\n            retval = int(ms.group(1))\n        return retval\n\n    if isinstance(s, (type(None), int, float)):\n        return s\n\n    if s[-1] in '0123456789':\n        s += 's'\n\n    m = re.match(r'^(%s)?(%s)?(%s)?(%s)?$' % (RE_DAY, RE_HOUR,\n                                              RE_MINUTE, RE_SECOND),\n                 s)\n    if not m:\n        raise ParseError('invalid string: \"%s\"' % s)\n\n    times = [x for x in m.groups() if isinstance(x, str) and\n             re.match(r'[0-9]+[a-z]+', x)]\n    seconds = sum(_parse_time_with_unit(z) for z in times)\n\n    if return_type is int:\n        return seconds\n    elif return_type is timedelta:\n        return timedelta(seconds=seconds)\n    else:\n        raise TypeError('return_type \"{}\" is not supported.'.format(\n            return_type.__name__))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef path(string):\n        if not os.path.exists(string):\n            msg = \"Path %s not found!\" % string\n            raise ArgumentTypeError(msg)\n        return string", "response": "Define the path data type that can be used by apps."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a parameter to this parser.", "response": "def add_argument(self, *args, **kwargs):\n        \"\"\"\n        Add a parameter to this app.\n        \"\"\"\n        if not (('action' in kwargs) and (kwargs['action'] == 'help')):\n            # make sure required parameter options were defined\n            try:\n                name = kwargs['dest']\n                param_type = kwargs['type']\n                optional = kwargs['optional']\n            except KeyError as e:\n                detail = \"%s option required. \" % e\n                raise KeyError(detail)\n            if optional and ('default' not in kwargs):\n                detail = \"A default value is required for optional parameters %s.\" % name\n                raise KeyError(detail)\n\n            # grab the default and help values\n            default = None\n            if 'default' in kwargs:\n                default = kwargs['default']\n            param_help = \"\"\n            if 'help' in kwargs:\n                param_help = kwargs['help']\n\n            # set the ArgumentParser's action\n            if param_type not in (str, int, float, bool, ChrisApp.path):\n                detail = \"unsupported type: '%s'\" % param_type\n                raise ValueError(detail)\n            action = 'store'\n            if param_type == bool:\n                action = 'store_false' if default else 'store_true'\n                del kwargs['default'] # 'default' and 'type' not allowed for boolean actions\n                del kwargs['type']\n            kwargs['action'] = action\n\n            # store the parameters internally (param_type.__name__ to enable json serialization)\n            param = {'name': name, 'type': param_type.__name__, 'optional': optional,\n                     'flag': args[0], 'action': action, 'help': param_help, 'default': default}\n            self._parameters.append(param)\n\n            # add the parameter to the parser\n            del kwargs['optional']\n        ArgumentParser.add_argument(self, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a JSON object with a representation of this app.", "response": "def get_json_representation(self):\n        \"\"\"\n        Return a JSON object with a representation of this app (type and parameters).\n        \"\"\"\n        repres = {}\n        repres['type'] = self.TYPE\n        repres['parameters'] = self._parameters\n        repres['icon'] = self.ICON\n        repres['authors'] = self.AUTHORS\n        repres['title'] = self.TITLE\n        repres['category'] = self.CATEGORY\n        repres['description'] = self.DESCRIPTION\n        repres['documentation'] = self.DOCUMENTATION\n        repres['license'] = self.LICENSE\n        repres['version'] = self.VERSION\n        repres['selfpath'] = self.SELFPATH\n        repres['selfexec'] = self.SELFEXEC\n        repres['execshell'] = self.EXECSHELL\n        repres['max_number_of_workers'] = self.MAX_NUMBER_OF_WORKERS\n        repres['min_number_of_workers'] = self.MIN_NUMBER_OF_WORKERS\n        repres['max_memory_limit'] = self.MAX_MEMORY_LIMIT\n        repres['max_cpu_limit'] = self.MAX_CPU_LIMIT \n        repres['min_memory_limit'] = self.MIN_MEMORY_LIMIT\n        repres['min_cpu_limit'] = self.MIN_CPU_LIMIT \n        repres['min_gpu_limit'] = self.MIN_GPU_LIMIT\n        repres['max_gpu_limit'] = self.MAX_GPU_LIMIT\n        return repres"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the app s JSON representation object to a JSON file.", "response": "def save_json_representation(self, dir_path):\n        \"\"\"\n        Save the app's JSON representation object to a JSON file.\n        \"\"\"\n        file_name = self.__class__.__name__+ '.json'\n        file_path = os.path.join(dir_path, file_name)\n        with open(file_path, 'w') as outfile:\n            json.dump(self.get_json_representation(), outfile)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the options parsed from a JSON file.", "response": "def get_options_from_file(self, file_path):\n        \"\"\"\n        Return the options parsed from a JSON file.\n        \"\"\"\n        # read options JSON file\n        with open(file_path) as options_file:\n            options_dict = json.load(options_file)\n        options = []\n        for opt_name in options_dict:\n            options.append(opt_name)\n            options.append(options_dict[opt_name])\n        return self.parse_args(options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_input_meta(self):\n        options = self.options\n        file_path = os.path.join(options.outputdir, 'input.meta.json')\n        with open(file_path, 'w') as outfile:\n            json.dump(vars(options), outfile)", "response": "Save the input meta data to a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_output_meta(self):\n        options = self.options\n        file_path = os.path.join(options.outputdir, 'output.meta.json')\n        with open(file_path, 'w') as outfile:\n            json.dump(self.OUTPUT_META_DICT, outfile)", "response": "Save descriptive output meta data to a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_output_meta(self):\n        options = self.options\n        file_path = os.path.join(options.inputdir, 'output.meta.json')\n        with open(file_path) as infile:\n            return json.load(infile)", "response": "Load descriptive output meta data from a JSON file in the input directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint the app s meta data.", "response": "def print_app_meta_data(self):\n        \"\"\"\n        Print the app's meta data.\n        \"\"\"\n        l_metaData  = dir(self)\n        l_classVar  = [x for x in l_metaData if x.isupper() ]\n        for str_var in l_classVar:\n            str_val = getattr(self, str_var)\n            print(\"%20s: %s\" % (str_var, str_val))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register_view(self, view):\n        Controller.register_view(self, view)\n\n        # connects additional signals\n        self.view['tv_notes'].get_buffer().connect(\"changed\",\n                                          self.on_notes_changed)\n\n        # Sets initial values for the view.\n        # Later observer will keep the view always aligned\n        self.view.set_name(self.model.name)\n        self.view.set_rate(self.model.rate)\n        self.view.set_notes(self.model.notes)\n        return", "response": "Creates treeview columns and connects missing signals"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_view(self, view):\n\n        # connects the signals:\n        self.view['main_window'].connect('destroy', gtk.main_quit)\n        \n        # initializes the text of label:\n        self.view.set_text(\"%d\" % self.model.counter)\n        return", "response": "This method is called by the view that calls it when it is\n        ready to register itself."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_version(svn=False, limit=3):\n    \"Returns the version as a human-format string.\"\n    v = '.'.join([str(i) for i in VERSION[:limit]])\n    if svn and limit >= 3:\n        from django.utils.version import get_svn_revision\n        import os\n        svn_rev = get_svn_revision(os.path.dirname(__file__))\n        if svn_rev:\n            v = '%s.%s' % (v, svn_rev)\n    return v", "response": "Returns the version as a human - format string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format(self, format_spec='f'):\n        if format_spec == '' or format_spec == 'f':\n            cnpj = CNPJ.clean(self._cnpj)\n            return '{0}.{1}.{2}/{3}-{4}'.format(cnpj[0:2], cnpj[2:5], cnpj[5:8], cnpj[8:12], cnpj[12:14])\n        if format_spec == 'r':\n            return self._cnpj\n        raise ValueError(\n            \"Unknown format code '{0}' for object of type '{1}'\".format(format_spec, CNPJ.__name__))", "response": "u Formates a CNPJ object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate(cls, cnpj):\n        if cnpj is None:\n            return False\n\n        digitos_validacao = [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2]\n\n        cnpj = CNPJ.clean(cnpj)\n\n        def mod11(value):\n            value = value % 11\n            return 11 - value if value > 1 else 0\n\n        dig1 = mod11(sum([digitos_validacao[i] * int(cnpj[i - 1]) for i in range(1, 13)]))\n        dig2 = mod11(sum([digitos_validacao[i] * int(cnpj[i]) for i in range(0, 13)]))\n\n        return cnpj[-2:] == '{0}{1}'.format(dig1, dig2)", "response": "u Valida o CNPJ o CNPJ o CNPJ o CNPJ o CNPJ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate(cls, cpf):\n        if cpf is None:\n            return False\n\n        cpf = CPF.clean(cpf)\n\n        def mod11(value):\n            return (value % 11) % 10\n\n        dig1 = mod11(sum([(i + 1) * int(cpf[i]) for i in range(0, 9)]))\n        dig2 = mod11(sum([i * int(cpf[i]) for i in range(1, 10)]))\n\n        return cpf[-2:] == '{0}{1}'.format(dig1, dig2)", "response": "u Valida tuta o CPF."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_ui(self, ):\n        w = QtGui.QWidget(self)\n        w.setLayout(self.central_vbox)\n        self.setCentralWidget(w)\n        releasetypes = [djadapter.RELEASETYPES[\"work\"]]\n        self.browser = FileBrowser(self.filetype, releasetypes, None, self)\n        self.central_vbox.insertWidget(0, self.browser)\n\n        self.comment_pte = self.create_comment_edit()\n        self.central_vbox.addWidget(self.comment_pte)\n        self.option_gb.setVisible(False)\n\n        self.setup_icons()", "response": "Create the browsers and all necessary ui elements for the tool"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_icons(self, ):\n        floppy_icon = get_icon('glyphicons_446_floppy_save.png', asicon=True)\n        self.release_pb.setIcon(floppy_icon)", "response": "Set all icons on buttons\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_comment_edit(self, ):\n        pte = JB_PlainTextEdit(parent=self)\n        pte.set_placeholder(\"Enter a comment before saving...\")\n        pte.setMaximumHeight(120)\n        return pte", "response": "Create a text edit for comments\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new release object and show the statusbar", "response": "def release_callback(self, *args, **kwargs):\n        \"\"\"Create a new release\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        tf = self.browser.get_current_selection()\n        if not tf:\n            self.statusbar.showMessage(\"Select a file to release, please!\")\n            return\n        tfi = TaskFileInfo.create_from_taskfile(tf)\n        checks = self.get_checks()\n        cleanups = self.get_cleanups()\n        comment = self.get_comment()\n        r = Release(tfi, checks, cleanups, comment)\n        self.statusbar.showMessage(\"Release in progress...\")\n        try:\n            success = r.release()\n        except OSError:\n            self.statusbar.showMessage(\"Could not copy workfile!\")\n            return\n        except Exception as e:\n            self.statusbar.showMessage(\"%s\" % e)\n            return\n        if success:\n            self.statusbar.showMessage(\"Success!\")\n        else:\n            self.statusbar.showMessage(\"Release failed!\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the widget that gives users options about the release", "response": "def set_release_actions(self, actions):\n        \"\"\"Set the widget that gives users options about the release, e.g. importing references\n\n        :param actions: Release actions that define the sanity checks and cleanup actions\n        :type actions: :class:`jukeboxcore.release.ReleaseActions`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.release_actions = actions\n        self.option_widget = self.release_actions.option_widget()\n        if self.option_widget:\n            self.option_vbox.addWidget(self.option_widget)\n            self.option_gb.setVisible(True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_result(self, imports, module_name, import_from, meta, val, dividers):\n        options = {\"imports\": imports, \"module_name\": module_name, \"import_from\": import_from}\n        return ImportLine.FieldSpec(formatter=MergedOptionStringFormatter).normalise(meta, options)", "response": "Default permissions to rw"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction that interprets a dictionary and creates objects", "response": "def _do_create(di):\n    \"\"\"Function that interprets a dictionary and creates objects\"\"\"\n    track = di['track'].strip()\n    artists = di['artist']\n    if isinstance(artists, StringType):\n        artists = [artists]\n\n    # todo: handle case where different artists have a song with the same title\n    tracks = Track.objects.filter(title=track, state='published')\n    if tracks:\n        track = tracks[0]\n        track_created = False\n    else:\n        track = Track.objects.create(title=track, state='published')\n        track_created = True\n\n    last_played = di.get('last_played', None)\n    if last_played and (track.last_played != last_played):\n        track.last_played = last_played\n        track.save()\n\n    if track_created:\n        track.length = di.get('length', 240)\n        track.sites = Site.objects.all()\n        track.save(set_image=False)\n        for artist in artists:\n            track.create_credit(artist.strip(), 'artist')\n        # Set image last since we need credits set\n        track.set_image()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of jobs corresponding to the raw_job_string", "response": "def get_jobs_from_argument(self, raw_job_string):\n        \"\"\" return a list of jobs corresponding to the raw_job_string \"\"\"\n        jobs = []\n        if raw_job_string.startswith(\":\"):\n            job_keys = raw_job_string.strip(\" :\")\n            jobs.extend([job for job in self.jobs(job_keys)])\n        # we assume a job code\n        else:\n            assert \"/\" in raw_job_string, \"Job Code {0} is improperly formatted!\".format(raw_job_string)\n            host, job_name = raw_job_string.rsplit(\"/\", 1)\n            host_url = self._config_dict.get(host, {}).get('url', host)\n            host = self.get_host(host_url)\n            if host.has_job(job_name):\n                jobs.append(JenksJob(None, host, job_name,\n                                     lambda: self._get_job_api_instance(host_url, job_name)))\n            else:\n                raise JenksDataException(\n                    \"Could not find Job {0}/{1}!\".format(host, job_name))\n        return jobs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a job to the config with the raw_host and job_name", "response": "def add_job(self, raw_host, job_name):\n        \"\"\" add a job to the config with <host> and <job_name> \"\"\"\n        url_host_map = dict(((host_dict.get('url', host_name).rstrip('/'), host_name)\n                             for host_name, host_dict in self._config_dict.items()))\n\n        if raw_host in self._config_dict:\n            host_url = self._config_dict[raw_host].get('url', raw_host)\n            host = raw_host\n        elif raw_host in url_host_map:\n            host_url = raw_host\n            host = url_host_map[raw_host]\n        else:\n            host_url, host = raw_host, raw_host\n\n        if host not in self._config_dict:\n            self._config_dict[host] = {\n                'url': host_url,\n                'jobs': []\n            }\n        if 'jobs' not in self._config_dict[host]:\n            self._config_dict[host]['jobs'] = []\n        self._config_dict[host]['jobs'].append(job_name)\n        self._add_job(host, job_name, host_url=host_url)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_substitutions(self, element):\n        subs = element.findall('sub')\n\n        for sub in subs:\n            self.agentml.set_substitution(attribute(sub, 'word'), sub.text)", "response": "Parse word substitutions from the XML element."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nliking eq but compares datetime with y m d tuple.", "response": "def eqdate(y):\n    \"\"\"\n    Like eq but compares datetime with y,m,d tuple.\n    Also accepts magic string 'TODAY'.\n    \"\"\"\n    y = datetime.date.today() if y == 'TODAY' else datetime.date(*y)\n    return lambda x: x == y"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef interpolation_linear(x, x1, x2, y1, y2):\n    m = (y2 - y1) / (x2 - x1)\n    t = (x - x1)\n    return m * t + y1", "response": "Linear interpolation of two points."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_grid(start, end, nsteps=100):\n    step = (end-start) / float(nsteps)\n    return [start + i * step for i in xrange(nsteps+1)]", "response": "Generates a list of equal distanced floats with nsteps + 1 values begining start and ending with end."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef taskfileinfo_element_data(tfi, role):\n    task = tfi.task\n    element = task.element\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return element.name", "response": "Return the data for the element in the taskfileinfo"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef taskfileinfo_task_data(tfi, role):\n    task = tfi.task\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return task.name", "response": "Return the data for the taskfileinfo task"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef taskfileinfo_descriptor_data(tfi, role):\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return tfi.descriptor", "response": "Return the data for the descriptor"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the data for path", "response": "def taskfileinfo_path_data(tfi, role):\n    \"\"\"Return the data for path\n\n    :param tfi: the :class:`jukeboxcore.filesys.TaskFileInfo` holds the data\n    :type tfi: :class:`jukeboxcore.filesys.TaskFileInfo`\n    :param role: item data role\n    :type role: QtCore.Qt.ItemDataRole\n    :returns: data for the path\n    :rtype: depending on role\n    :raises: None\n    \"\"\"\n    if role == QtCore.Qt.DisplayRole or role == QtCore.Qt.EditRole:\n        return JB_File(tfi).get_fullpath()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef data(self, column, role):\n        return self.columns[column](self._taskfileinfo, role)", "response": "Return the data for the specified column and role"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _perform_validation(self, path, value, results):\n        path = self.name if path == None or len(path) == 0 else path + \".\" + self.name\n\n        super(PropertySchema, self)._perform_validation(path, value, results)\n        self._perform_type_validation(path, self.value_type, value, results)", "response": "Perform validation against the schema and configured validation rules."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npicking a value accoriding to the given density", "response": "def pick(self):\n        \"\"\" picks a value accoriding to the given density \"\"\"\n        v = random.uniform(0, self.ub)\n        d = self.dist\n        c = self.vc - 1\n        s = self.vc\n        while True:\n            s = s / 2\n            if s == 0:\n                break\n            if v <= d[c][1]:\n                c -= s\n            else:\n                c += s\n                # we only need this logic when increasing c\n                while len(d) <= c:\n                    s = s / 2\n                    c -= s\n                    if s == 0:\n                        break\n        # we may have converged from the left, instead of the right\n        if c == len(d) or v <= d[c][1]:\n            c -= 1\n        return d[c][0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the output_fields attribute of the extractor object.", "response": "def set_output_fields(self, output_fields):\n        \"\"\"Defines where to put the dictionary output of the extractor in the doc, but renames\n        the fields of the extracted output for the document or just filters the keys\"\"\"\n        if isinstance(output_fields, dict) or isinstance(output_fields, list):\n            self.output_fields = output_fields\n        elif isinstance(output_fields, basestring):\n            self.output_field = output_fields\n        else:\n            raise ValueError(\"set_output_fields requires a dictionary of \"\n                             + \"output fields to remap, a list of keys to filter, or a scalar string\")\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntrying to get name from ExtractorProcessor to filter on first. If sub_output is None then the extractor processor will use the name from the extractor processor s metadata. Otherwise the extractor processor will use the name from the extractor processor s metadata.", "response": "def __get_jp(self, extractor_processor, sub_output=None):\n        \"\"\"Tries to get name from ExtractorProcessor to filter on first.\n        Otherwise falls back to filtering based on its metadata\"\"\"\n        if sub_output is None and extractor_processor.output_field is None:\n            raise ValueError(\n                \"ExtractorProcessors input paths cannot be unioned across fields.  Please specify either a sub_output or use a single scalar output_field\")\n        if extractor_processor.get_output_jsonpath_with_name(sub_output) is not None:\n            return extractor_processor.get_output_jsonpath_with_name(sub_output)\n        else:\n            return extractor_processor.get_output_jsonpath(sub_output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_extractor_processor_inputs(self, extractor_processors,\n                                       sub_output=None):\n        \"\"\"Instead of specifying fields in the source document to rename\n        for the extractor, allows the user to specify ExtractorProcessors that\n        are executed earlier in the chain and generate json paths from\n        their output fields\"\"\"\n        if not (isinstance(extractor_processors, ExtractorProcessor) or\n                isinstance(extractor_processors, types.ListType)):\n            raise ValueError(\n                \"extractor_processors must be an ExtractorProcessor or a list\")\n\n        if isinstance(extractor_processors, ExtractorProcessor):\n            extractor_processor = extractor_processors\n            self.input_fields = self.__get_jp(extractor_processor, sub_output)\n        elif isinstance(extractor_processors, types.ListType):\n            self.input_fields = list()\n            for extractor_processor in extractor_processors:\n                if isinstance(extractor_processor, ExtractorProcessor):\n                    self.input_fields.append(\n                        self.__get_jp(extractor_processor, sub_output))\n                elif isinstance(extractor_processor, list):\n                    self.input_fields.append(\n                        reduce(lambda a, b: \"{}|{}\".format(a, b),\n                               [\"({})\".format(self.__get_jp(x, sub_output))\n                                for x in extractor_processor]))\n\n        self.generate_json_paths()\n        return self", "response": "This method is used to set the input_fields of the extractor processor that is executed earlier in the chain and generate json paths from the output fields that are used in the source document."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_output_jsonpath_field(self, sub_output=None):\n        if sub_output is not None:\n            if self.output_fields is None or\\\n                (isinstance(self.output_fields, dict) and not sub_output in self.output_fields.itervalues()) or\\\n                    (isinstance(self.output_fields, list) and not sub_output in self.output_fields):\n                raise ValueError(\n                    \"Cannot generate output jsonpath because this ExtractorProcessor will not output {}\".format(sub_output))\n            output_jsonpath_field = sub_output\n        else:\n            output_jsonpath_field = self.output_field\n        return output_jsonpath_field", "response": "attempts to create an output jsonpath from a particular ouput field"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_output_jsonpath_with_name(self, sub_output=None):\n        if self.name is None:\n            return None\n\n        output_jsonpath_field = self.get_output_jsonpath_field(sub_output)\n        extractor_filter = \"name='{}'\".format(self.name)\n        output_jsonpath = \"{}[?{}].(result[*][value])\".format(\n            output_jsonpath_field, extractor_filter)\n\n        return output_jsonpath", "response": "Returns the JSONPath that has a filter on that name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_output_jsonpath(self, sub_output=None):\n        output_jsonpath_field = self.get_output_jsonpath_field(sub_output)\n\n        metadata = self.extractor.get_metadata()\n        metadata['source'] = str(self.input_fields)\n        extractor_filter = \"\"\n        is_first = True\n        for key, value in metadata.iteritems():\n            if is_first:\n                is_first = False\n            else:\n                extractor_filter = extractor_filter + \" & \"\n\n            if isinstance(value, basestring):\n                extractor_filter = extractor_filter\\\n                    + \"{}=\\\"{}\\\"\".format(key,\n                                         re.sub('(?<=[^\\\\\\])\\\"', \"'\", value))\n            elif isinstance(value, types.ListType):\n                extractor_filter = extractor_filter\\\n                    + \"{}={}\".format(key, str(value))\n        output_jsonpath = \"{}[?{}].result.value\".format(\n            output_jsonpath_field, extractor_filter)\n\n        return output_jsonpath", "response": "Build a JSONPath filter for this ExtractorProcessor that captures how to get at the outputs of the wrapped Extractor"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_input_fields(self, input_fields):\n        if not (isinstance(input_fields, basestring) or\n                isinstance(input_fields, types.ListType)):\n            raise ValueError(\"input_fields must be a string or a list\")\n        self.input_fields = input_fields\n        self.generate_json_paths()\n        return self", "response": "Given a scalar or ordered list of strings generate JSONPaths that describe how to access the values necessary for the Extractor"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_json_paths(self):\n        if isinstance(self.input_fields, basestring):\n            try:\n                self.jsonpaths = parse(self.input_fields)\n            except Exception as exception:\n                print \"input_fields failed {}\".format(self.input_fields)\n                raise exception\n\n        elif isinstance(self.input_fields, types.ListType):\n            self.jsonpaths = list()\n            for input_field in self.input_fields:\n                self.jsonpaths.append(parse(input_field))\n            if len(self.jsonpaths) == 1:\n                self.jsonpaths = self.jsonpaths[0]", "response": "Given a scalar or ordered list of strings parse them to\n            and generate a list of JSONPaths"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninsert the extracted value into the specified by output_field", "response": "def insert_extracted_value(self, doc, extracted_value,\n                               output_field, original_output_field=None):\n        \"\"\"inserts the extracted value into doc at the field specified \n        by output_field\"\"\"\n        if not extracted_value:\n            return doc\n        metadata = self.extractor.get_metadata()\n        if not self.extractor.get_include_context():\n            if isinstance(extracted_value, list):\n                result = list()\n                for ev in extracted_value:\n                    result.append({'value': ev})\n            else:\n                result = {'value': extracted_value}\n        else:\n            result = extracted_value\n        metadata['result'] = result\n        metadata['source'] = str(self.input_fields)\n\n        if original_output_field is not None:\n            metadata['original_output_field'] = original_output_field\n\n        if self.name is not None:\n            metadata['name'] = self.name\n\n        field_elements = output_field.split('.')\n        while len(field_elements) > 1:\n            field_element = field_elements.pop(0)\n            if '[' in field_element:\n                if not field_element.startswith('['):\n                    array_field_elements = field_element.split('[', 1)\n                    array_field_element = array_field_elements[0]\n                    doc = doc[array_field_element]\n                    field_element = array_field_elements[1]\n                array_elements = field_element.split(']')\n                for array_element in array_elements:\n                    if not array_element:\n                        continue\n                    if array_element.startswith('['):\n                        array_element = array_element[1:]\n                    if array_element.isdigit() and isinstance(doc, list):\n                        doc = doc[int(array_element)]\n                    else:\n                        doc = doc[array_element]\n            else:\n                if field_element not in doc:\n                    doc[field_element] = {}\n                doc = doc[field_element]\n        field_element = field_elements[0]\n        if field_element in doc:\n            output = doc[field_element]\n            if isinstance(output, dict):\n                output = [output, metadata]\n            elif isinstance(output, types.ListType):\n                output.append(metadata)\n\n        else:\n            output = [metadata]\n        doc[field_element] = output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extract_from_renamed_inputs(self, doc, renamed_inputs):\n        extracted_value = self.extractor.extract(renamed_inputs)\n        if not extracted_value:\n            return doc\n\n        if self.output_fields is not None and isinstance(extracted_value, dict):\n            if isinstance(self.output_fields, list):\n                for field in self.output_fields:\n                    if field in extracted_value:\n                        self.insert_extracted_value(\n                            doc, extracted_value[field], field)\n            elif isinstance(self.output_fields, dict):\n                for key, value in self.output_fields.iteritems():\n                    if key in extracted_value:\n                        self.insert_extracted_value(\n                            doc, extracted_value[key], value, key)\n        else:\n            self.insert_extracted_value(\n                doc, extracted_value, self.output_field)", "response": "Extract the value of the field containing the renamed_inputs and insert it into the doc"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extract(self, doc):\n        if isinstance(self.jsonpaths, JSONPath):\n            input_field = self.extractor.get_renamed_input_fields()\n            if isinstance(self.extractor.get_renamed_input_fields(), list):\n                input_field = input_field[0]\n\n            jsonpath = self.jsonpaths\n            renamed_inputs = dict()\n            if self.flat_map_inputs:\n                flat_mapped = itertools.chain.from_iterable(\n                    [iter(match.value)\n                     if hasattr(match.value, '__iter__') and\n                     not isinstance(match.value, dict) and\n                     not isinstance(match.value, basestring)\n                     else iter([match.value])\n                     for match in jsonpath.find(doc)])\n                renamed_inputs[input_field] = flat_mapped\n                if input_field in renamed_inputs:\n                    self.extract_from_renamed_inputs(doc, renamed_inputs)\n\n            else:\n                for value in [match.value for match in jsonpath.find(doc)]:\n                    renamed_inputs[input_field] = value\n                    self.extract_from_renamed_inputs(doc, renamed_inputs)\n\n        elif isinstance(self.jsonpaths, types.ListType):\n\n            renamed_inputs_lists = dict()\n            for jsonpath, renamed_input in \\\n                    itertools.izip(\n                    iter(self.jsonpaths),\n                    iter(self.extractor.get_renamed_input_fields())):\n                renamed_inputs_lists[renamed_input] = [\n                    match.value for match in jsonpath.find(doc)]\n\n            if self.flat_map_inputs:\n                renamed_inputs_tuple_lists = [\n                    (x, itertools.chain.from_iterable(\n                        [iter(z) if hasattr(z, '__iter__') and\n                         not isinstance(z, dict) and\n                         not isinstance(z, basestring)\n                         else iter([z])for z in y]))\n                    for x, y in renamed_inputs_lists.iteritems()]\n                renamed_inputs = reduce(\n                    ExtractorProcessor.add_tuple_to_doc,\n                    renamed_inputs_tuple_lists, dict())\n                self.extract_from_renamed_inputs(doc, renamed_inputs)\n            else:\n                renamed_inputs_lists_lists = [[(x, z) for z in y]\n                                              for x, y in\n                                              renamed_inputs_lists.iteritems()]\n                for i in itertools.product(*renamed_inputs_lists_lists):\n                    renamed_inputs = reduce(\n                        ExtractorProcessor.add_tuple_to_doc, i, dict())\n                    self.extract_from_renamed_inputs(doc, renamed_inputs)\n        else:\n            raise ValueError(\"input_fields must be a string or a list\")\n\n        return doc", "response": "Extract the values and rename the fields in the document and return the document with the extracted values"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the database name for the given model.", "response": "def db_for_write(self, model, **hints):\n        \"\"\"\n        Attempts to write auth models go to duashttp.\n        \"\"\"\n        if model._meta.app_label == 'duashttp':\n            if not DUAS_ENABLE_DB_WRITE:\n                raise ImproperlyConfigured(\n                    \"Set `DUAS_ENABLE_DB_WRITE` to True in your settings to enable \"\n                    \"write operations on unity asset server database\"\n                )\n            return DUAS_DB_ROUTE_PREFIX\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nallowing the user to migrate to the duashttp database.", "response": "def allow_migrate(self, db, model):\n        \"\"\"\n        Make sure the auth app only appears in the 'duashttp'\n        database.\n        \"\"\"\n        if db == DUAS_DB_ROUTE_PREFIX:\n            return model._meta.app_label == 'duashttp'\n        elif model._meta.app_label == 'duashttp':\n            return False\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sometimes(fn):\n\n    def wrapped(*args, **kwargs):\n        wrapped.x += 1\n        if wrapped.x % 2 == 1:\n            return fn(*args, **kwargs)\n\n    wrapped.x = 0\n    return wrapped", "response": "A function that wraps a function so that it works every time."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sometimesish(fn):\n    def wrapped(*args, **kwargs):\n        if random.randint(1, 2) == 1:\n            return fn(*args, **kwargs)\n\n    return wrapped", "response": "A function that returns a random object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef percent_of_the_time(p):\n    def decorator(fn):\n\n        def wrapped(*args, **kwargs):\n            if in_percentage(p):\n                fn(*args, **kwargs)\n\n        return wrapped\n\n    return decorator", "response": "Function is a X percentage chance of running the current user s content."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rarely(fn):\n    def wrapped(*args, **kwargs):\n        if in_percentage(5):\n            fn(*args, **kwargs)\n    return wrapped", "response": "Decorator to make a function rarely."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mostly(fn):\n    def wrapped(*args, **kwargs):\n        if in_percentage(95):\n            fn(*args, **kwargs)\n    return wrapped", "response": "A very simple wrapper for functions that are not in the order they appear."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef times(x, y):\n    def decorator(fn):\n\n        def wrapped(*args, **kwargs):\n            n = random.randint(x, y)\n            for z in range(1, n):\n                fn(*args, **kwargs)\n\n        return wrapped\n\n    return decorator", "response": "A random amount of times between x & y"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ascii2token(self, ascii_code, debug=False):\n        log.info(repr(ascii_code))\n        parts = self.regex.split(ascii_code)\n        log.info(repr(parts))\n        tokens = []\n        for part in parts:\n            if not part:\n                continue\n\n            if part in self.ascii2token_dict:\n                new_token = self.ascii2token_dict[part]\n                log.info(\"\\t%r -> %x\", part, new_token)\n                if new_token > 0xff:\n                    tokens.append(new_token >> 8)\n                    tokens.append(new_token & 0xff)\n                else:\n                    tokens.append(new_token)\n            else:\n                tokens += self.chars2tokens(part)\n        return tokens", "response": "convert an ASCII code to a list of tokens"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pformat_tokens(self, tokens):\n        result = []\n        for token_value in self.iter_token_values(tokens):\n            char = self.token2ascii(token_value)\n            if token_value > 0xff:\n                result.append(\"\\t$%04x -> %s\" % (token_value, repr(char)))\n            else:\n                result.append(\"\\t  $%02x -> %s\" % (token_value, repr(char)))\n\n        return result", "response": "Format a tokenized BASIC program line. Useful for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef token_load(self, line_number, tokens):\n        self.line_number = line_number\n        assert tokens[-1] == 0x00, \"line code %s doesn't ends with \\\\x00: %s\" % (\n            repr(tokens), repr(tokens[-1])\n        )\n\n        \"\"\"\n        NOTE: The BASIC interpreter changed REM shortcut and ELSE\n        internaly:\n           \"'\" <-> \":'\"\n        \"ELSE\" <-> \":ELSE\"\n\n        See also:\n        http://archive.worldofdragon.org/phpBB3/viewtopic.php?f=8&t=4310&p=11632#p11630\n        \"\"\"\n        for src, dst in self.tokens_replace_rules:\n            log.info(\"Relace tokens %s with $%02x\",\n                pformat_byte_hex_list(src), dst\n            )\n            log.debug(\"Before..: %s\", pformat_byte_hex_list(tokens))\n            tokens = list_replace(tokens, src, dst)\n            log.debug(\"After...: %s\", pformat_byte_hex_list(tokens))\n\n        self.line_code = tokens[:-1]", "response": "Load the tokens from the file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pformat_program_dump(self, program_dump, program_start, formated_dump=None):\n        if formated_dump is None:\n            formated_dump = []\n            formated_dump.append(\n                \"program start address: $%04x\" % program_start\n            )\n\n        assert isinstance(program_dump, bytearray)\n\n        if not program_dump:\n            return program_dump\n\n        try:\n            next_address = (program_dump[0] << 8) + program_dump[1]\n        except IndexError as err:\n            raise IndexError(\n                \"Can't get next address from: %s program start: $%04x (Origin error: %s)\" % (\n                    repr(program_dump), program_start, err\n            ))\n\n        if next_address == 0x0000:\n            formated_dump.append(\"$%04x -> end address\" % next_address)\n            return formated_dump\n\n        assert next_address > program_start, \"Next address $%04x not bigger than program start $%04x ?!?\" % (\n            next_address, program_start\n        )\n\n        length = next_address - program_start\n        formated_dump.append(\n            \"$%04x -> next address (length: %i)\" % (next_address, length)\n        )\n        line_number = (program_dump[2] << 8) + program_dump[3]\n        formated_dump.append(\"$%04x -> %i (line number)\" % (line_number, line_number))\n\n        tokens = program_dump[4:length]\n        formated_dump.append(\"tokens:\")\n        formated_dump += self.token_util.pformat_tokens(tokens)\n\n        return self.pformat_program_dump(program_dump[length:], next_address, formated_dump)", "response": "Format a BASIC program dump. Useful for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_destinations(self, ascii_listing):\n        self.destinations = set()\n        def collect_destinations(matchobj):\n            numbers = matchobj.group(\"no\")\n            if numbers:\n                self.destinations.update(set(\n                    [n.strip() for n in numbers.split(\",\")]\n                ))\n\n        for line in self._iter_lines(ascii_listing):\n            self.renum_regex.sub(collect_destinations, line)\n\n        return sorted([int(no) for no in self.destinations if no])", "response": "Returns all line numbers that are used in a jump."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_cell_format(column_dict, key=None):\n    format = column_dict.get('format')\n    prop = column_dict.get('__col__')\n\n    if format is None and prop is not None:\n        if hasattr(prop, 'columns'):\n            sqla_column = prop.columns[0]\n            column_type = getattr(sqla_column.type, 'impl', sqla_column.type)\n            format = FORMAT_REGISTRY.get_item(column_type)\n    return format", "response": "Returns the cell format for the given column_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a file buffer containing the resulting xls", "response": "def save_book(self, f_buf=None):\n        \"\"\"\n        Return a file buffer containing the resulting xls\n\n        :param obj f_buf: A file buffer supporting the write and seek\n        methods\n        \"\"\"\n        if f_buf is None:\n            f_buf = StringIO.StringIO()\n        f_buf.write(openpyxl.writer.excel.save_virtual_workbook(self.book))\n        f_buf.seek(0)\n        return f_buf"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_color(self, cell, color):\n        cell.style = cell.style.copy(font=Font(color=Color(rgb=color)))", "response": "Set the given color to the provided cell."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format_row(self, row):\n        res = []\n        headers = getattr(self, 'headers', [])\n        for column in headers:\n            column_name = column['name']\n            value = row.get(column_name, '')\n            if hasattr(self, \"format_%s\" % column_name):\n                value = getattr(self, \"format_%s\" % column_name)(value)\n            res.append(value)\n        return res", "response": "This method formats the row into a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _render_rows(self):\n        _datas = getattr(self, '_datas', ())\n        headers = getattr(self, 'headers', ())\n        for index, row in enumerate(_datas):\n            row_number = index + 2\n            for col_num, value in enumerate(row):\n                cell = self.worksheet.cell(row=row_number, column=col_num + 1)\n                if value is not None:\n                    cell.value = value\n                else:\n                    cell.value = \"\"\n                if len(headers) > col_num:\n                    header = headers[col_num]\n                    format = get_cell_format(header)\n                    if format is not None:\n                        cell.number_format = format", "response": "Render the rows in the current stylesheet"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite the headers row", "response": "def _render_headers(self):\n        \"\"\"\n        Write the headers row\n        \"\"\"\n        headers = getattr(self, 'headers', ())\n        for index, col in enumerate(headers):\n            # We write the headers\n            cell = self.worksheet.cell(row=1, column=index + 1)\n            cell.value = col['label']\n\n        index += 1\n\n        extra_headers = getattr(self, 'extra_headers', ())\n        for add_index, col in enumerate(extra_headers):\n            cell = self.worksheet.cell(row=1, column=add_index + index + 1)\n            cell.value = col['label']"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_related_exporter(self, related_obj, column):\n        result = column.get('sqla_xls_exporter')\n        if result is None:\n            worksheet = self.book.create_sheet(\n                title=column.get('label', 'default title')\n            )\n            result = column['sqla_xls_exporter'] = SqlaXlsExporter(\n                related_obj.__class__,\n                worksheet=worksheet\n            )\n        return result", "response": "Returns an SqlaXlsExporter for the given related object and stores it in the column as a cache\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _populate(self):\n        XlsWriter._populate(self)\n        for header in self.headers:\n            if \"sqla_xls_exporter\" in header:\n                header['sqla_xls_exporter']._populate()", "response": "Populate the script by handling related elements"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef subject_sequence_retriever(fasta_handle, b6_handle, e_value,\n                               *args, **kwargs):\n    \"\"\"Returns FASTA entries for subject sequences from BLAST hits\n\n    Stores B6/M8 entries with E-Values below the e_value cutoff. Then iterates\n    through the FASTA file and if an entry matches the subject of an B6/M8\n    entry, it's sequence is extracted and returned as a FASTA entry\n    plus the E-Value.\n\n    Args:\n        fasta_handle (file): FASTA file handle, can technically\n            be any iterable that returns FASTA \"lines\"\n\n        b6_handle (file): B6/M8 file handle, can technically\n            be any iterable that returns B6/M8 \"lines\"\n\n        e_value (float): Max E-Value of entry to return\n\n        *args: Variable length argument list for b6_iter\n\n        **kwargs: Arbitrary keyword arguments for b6_iter\n\n    Yields:\n        FastaEntry: class containing all FASTA data\n\n    Example:\n        Note: These doctests will not pass, examples are only in doctest\n        format as per convention. bio_utils uses pytests for testing.\n\n        >>> fasta_handle = open('test.fasta')\n        >>> b6_handle = open('test.b6')\n        >>> for entry in subject_sequence_retriever(fasta_handle,\n        ...                                       b6_handle, 1e5)\n        ...     print(entry.sequence)  # Print aligned subject sequence\n    \"\"\"\n\n    filtered_b6 = defaultdict(list)\n    for entry in b6_evalue_filter(b6_handle, e_value, *args, **kwargs):\n        filtered_b6[entry.subject].append(\n            (entry.subject_start, entry.subject_end, entry._evalue_str))\n    for fastaEntry in fasta_iter(fasta_handle):\n        if fastaEntry.id in filtered_b6:\n            for alignment in filtered_b6[fastaEntry.id]:\n                start = alignment[0] - 1\n                end = alignment[1] - 1\n\n                # Get subject sequence\n                if start < end:\n                    subject_sequence = fastaEntry.sequence[start:end]\n                elif start > end:\n                    subject_sequence = fastaEntry.sequence[end:start][::-1]\n                else:\n                    subject_sequence = fastaEntry.sequence[start]\n                fastaEntry.sequence = subject_sequence\n\n                # Add E-value to FASTA/Q header\n                if fastaEntry.description == '':\n                    fastaEntry.description = 'E-value: '\n                else:\n                    fastaEntry.description += ' E-value: '\n                fastaEntry.description += alignment[2]\n\n                yield fastaEntry", "response": "This function returns a list of FASTA entries for subject sequences from BLAST hits and stores the B6 entries with E - Values below e_value cutoff and returns the list of all FASTA entries for the subject sequences from the BLAST hits and returns the list of all entries with E - Values above e_value cutoff."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of column names of the provided table name", "response": "def get_table_schema(self, tname):\n        ''' Returns a list of column names of the provided table name '''\n        tname = self._check_tname(tname, noload=True)\n        if tname not in self._schemas:\n            raise ValueError('Table \"%s\" not found in schema store' % tname)\n        return list(self._schemas[tname])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload the contents of the specified tables schemas and record generators into the database.", "response": "def load(self, table_names=None, table_schemas=None, table_rowgens=None):\n        '''\n        Initiates the tables, schemas and record generators for this database.\n\n        Parameters\n        ----------\n        table_names : list of str, str or None\n            List of tables to load into this database. If `auto_load` is true, inserting a record\n            into a new table not provided here will automatically create that table.\n        table_schemas : dict of <table_name, column_list> or None\n            Dictionary with each table name as a key and a list of its columns as value. Any keys\n            present here but not present in `table_names` will also trigger table creation, so\n            table names provided in both parameters are redundant but harmless.\n        table_rowgens: dict of <table_name, function> or None\n            For all tables present in the keys of the provided dictionary, when an insert operation\n            occurs, the corresponding function is called. The function must return a dictionary and\n            is used as a \"base record\" which is complemented by the actual record being inserted.\n            For example, when a table has a rowgen like `lambda: {\"Timestamp\": time.ctime()}` and\n            a record like `{\"Name\": \"John\"}` is inserted, the database will then contain a record\n            like `{\"Timestamp\": \"Sun Jan 10 08:36:12 2016\", \"Name\": \"John\"}`.\n        '''\n\n        # Check for table schemas\n        if table_schemas is not None:\n            table_schemas = self._check_case_dict(table_schemas, warn=True)\n            for schema_key, schema_value in table_schemas.items():\n                table_schemas[schema_key] = self._check_columns(schema_value, add_id=True)\n        elif not self.dynamic_schema:\n            raise ValueError('Table schemas must be provided if dynamic schema is disabled')\n\n        # Check for row generators\n        if table_rowgens is not None:\n            table_rowgens = self._check_case_dict(table_rowgens, warn=True)\n\n        # If table_names is not directly provided, infer it from one of the other parameters\n        if table_names is None:\n            if table_schemas is not None:\n                table_names = list(table_schemas.keys())\n                self._print(\n                    'Inferring table name from table_schemas for tables %r'% table_names)\n            elif table_rowgens is not None:\n                table_names = list(table_rowgens.keys())\n                self._print(\n                    'Inferring table name from table_rowgens for tables %r' % table_names)\n            else:\n                req_params = 'table_names,table_schemas,table_rowgens'\n                raise ValueError(\n                    'At least one of the parameters must be provided: [%s]' % req_params)\n\n        table_names = self._check_table_names(table_names, warn=True)\n        self._print('Loading tables %r' % table_names)\n\n        # Update schemas and row generators without losing previous ones\n        for tname in table_names:\n            if table_schemas is not None and tname in table_schemas:\n                self._schemas[tname] = list(table_schemas[tname]) # make a copy\n            if table_rowgens is not None and tname in table_rowgens:\n                self._rowgens[tname] = table_rowgens[tname]\n\n        with self._lock:\n            for tname in table_names:\n\n                # Standardize case, since Windows paths are case insensitive\n                tname = self._check_case_str(tname, warn=True)\n\n                # CSV has same filename as table under database folder\n                tpath = os.path.join(self.root_dir, self.name, tname + '.csv')\n\n                # Table already exists, simply load it\n                if os.path.isfile(tpath):\n                    if self.auto_load:\n                        dataframe = read_csv(tpath, dtype=str)\n                        self._db[tname] = dataframe\n                        schema = self._check_columns(dataframe.columns.tolist())\n                        self._schemas[tname] = schema\n                    elif self.persistent:\n                        raise ValueError(\n                            'Auto load tables is disabled but table \"%s\" already exists and would'\n                            'be overwritten' % tname)\n\n                # Table not found, try to create it using given schema\n                elif table_schemas is not None and tname in self._schemas:\n                    self._db[tname] = DataFrame(columns=self._schemas[tname], dtype=str)\n\n                # Table not found, dynamic schema\n                elif self.dynamic_schema:\n                    self._print('Creating table \"%s\" using dynamic schema' % tname)\n                    self._db[tname] = DataFrame(columns=self._blank_schema, dtype=str)\n                    self._schemas[tname] = list(self._blank_schema)\n\n                # Table not found and schema not given when dynamic_schema not enabled\n                else:\n                    raise ValueError(\n                        'Table %s not found and schema was not passed as a parameter' % tname)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef drop(self, table_names):\n        '''\n        Drops the provided table(s) from this database.\n\n        Parameters\n        ----------\n        table_names : list of str, str or None\n            Table(s) to be dropped\n        '''\n        table_names = self._check_table_names(table_names)\n\n        for tname in table_names:\n            tname = self._check_tname(tname, noload=True)\n\n            # Warning: if auto_load is on the next insert will re-create the table\n            with self._lock:\n                del self._db[tname]\n\n                filepath = os.path.join(self.root_dir, self.name, tname + '.csv')\n                if self.persistent and os.path.exists(filepath):\n                    try:\n                        os.remove(filepath)\n                        self._print('Drop %s: Success' % tname)\n                    except (IOError, WindowsError):\n                        self._print('Drop %s: Failed' % tname)", "response": "Drops the provided table from this database."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef drop_all(self):\n        ''' Drops all tables from this database '''\n        self.drop(self.get_table_names())\n        if self.persistent:\n            with self._lock:\n                try:\n                    dbfolder = os.path.join(self.root_dir, self.name)\n                    if os.path.exists(dbfolder) and not os.listdir(dbfolder):\n                        rmtree(dbfolder)\n                except (IOError, WindowsError):\n                    self._print('Failed to delete folder %s when dropping database' % self.name)\n                finally:\n                    del self", "response": "Drops all tables from this database"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds records in the provided table from the database. If no records are found, return empty list, str or dataframe depending on the value of `astype`. Parameters ---------- tname : str Table to search records from. where : dict or None (default `None`) Dictionary of <column, value> where value can be of str type for exact match or a compiled regex expression for more advanced matching. where_not : dict or None (default `None`) Identical to `where` but for negative-matching. columns: list of str, str or None (default `None`) Column(s) to return for the found records, if any. astype: str, type or None (default `None`) Type to cast the output to. Possible values are: `nonetype`, `dataframe`, `str`, `dict`, `json`. If this is `None`, falls back to the type provided to the constructor. If a type was provided to the constructor but the user wants to avoid any casting, \"nonetype\" should be passed as the value. Returns ------- records : str, list or dataframe Output type depends on `astype` parameter. Examples -------- >>> db = PandasDatabase(\"test\") >>> db.insert(\"test\", record={\"Name\": \"John\"}) Name John __id__ dc876999-1f5b-4262-b6bf-c23b875f3a54 dtype: object >>> db.find(\"test\", astype=\"dict\") [{'Name': 'John', '__id__': 'dc876999-1f5b-4262-b6bf-c23b875f3a54'}] >>> db.find(\"test\", astype=\"dataframe\") __id__ Name 0 dc876999-1f5b-4262-b6bf-c23b875f3a54 John >>> db.find(\"test\", astype=None) __id__ Name 0 dc876999-1f5b-4262-b6bf-c23b875f3a54 John >>> db.find(\"test\", where={\"Name\": \"John\"}, astype=\"dict\") [{'Name': 'John', '__id__': 'dc876999-1f5b-4262-b6bf-c23b875f3a54'}] >>> db.find(\"test\", where_not={\"Name\": \"John\"}, astype=\"dict\") []", "response": "def find(self, tname, where=None, where_not=None, columns=None, astype=None):\n        '''\n        Find records in the provided table from the database. If no records are found, return empty\n        list, str or dataframe depending on the value of `astype`.\n\n        Parameters\n        ----------\n        tname : str\n            Table to search records from.\n        where : dict or None (default `None`)\n            Dictionary of <column, value> where value can be of str type for exact match or a\n            compiled regex expression for more advanced matching.\n        where_not : dict or None (default `None`)\n            Identical to `where` but for negative-matching.\n        columns: list of str, str or None (default `None`)\n            Column(s) to return for the found records, if any.\n        astype: str, type or None (default `None`)\n            Type to cast the output to. Possible values are: `nonetype`, `dataframe`, `str`,\n            `dict`, `json`. If this is `None`, falls back to the type provided to the constructor.\n            If a type was provided to the constructor but the user wants to avoid any casting,\n            \"nonetype\" should be passed as the value.\n\n        Returns\n        -------\n        records : str, list or dataframe\n            Output type depends on `astype` parameter.\n\n        Examples\n        --------\n        >>> db = PandasDatabase(\"test\")\n        >>> db.insert(\"test\", record={\"Name\": \"John\"})\n            Name                                      John\n            __id__    dc876999-1f5b-4262-b6bf-c23b875f3a54\n            dtype: object\n        >>> db.find(\"test\", astype=\"dict\")\n            [{'Name': 'John', '__id__': 'dc876999-1f5b-4262-b6bf-c23b875f3a54'}]\n        >>> db.find(\"test\", astype=\"dataframe\")\n                                             __id__  Name\n            0  dc876999-1f5b-4262-b6bf-c23b875f3a54  John\n        >>> db.find(\"test\", astype=None)\n                                             __id__  Name\n            0  dc876999-1f5b-4262-b6bf-c23b875f3a54  John\n        >>> db.find(\"test\", where={\"Name\": \"John\"}, astype=\"dict\")\n            [{'Name': 'John', '__id__': 'dc876999-1f5b-4262-b6bf-c23b875f3a54'}]\n        >>> db.find(\"test\", where_not={\"Name\": \"John\"}, astype=\"dict\")\n            []\n        '''\n        try:\n            # Find is inherently read-only so don't try to autoload table\n            tname = self._check_tname(tname, noload=True)\n        except ValueError:\n            return self._output(DataFrame(), astype=astype)\n        where = PandasDatabase._check_conditions(where)\n        where_not = PandasDatabase._check_conditions(where_not)\n        columns = PandasDatabase._check_type_iter(str, columns)\n\n        dataframe = self._db[tname]\n        if len(columns) > 0 and len(dataframe) > 0:\n            dataframe = dataframe[columns]\n\n        # Parse the conditions to match\n        if len(where) > 0:\n            dataframe = dataframe[self._get_condition_mask(dataframe, where)]\n\n        # Parse the conditions not to match\n        if len(where_not) > 0:\n            dataframe = dataframe[~self._get_condition_mask(dataframe, where_not)]\n\n        self._print('Found %d records in table \"%s\" where %r and where not %r'\n                    % (len(dataframe), tname, where, where_not))\n        return self._output(dataframe, astype=astype)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_one(self, tname, where=None, where_not=None, columns=None, astype=None):\n        '''\n        Find a single record in the provided table from the database. If multiple match, return\n        the first one based on the internal order of the records. If no records are found, return\n        empty dictionary, string or series depending on the value of `astype`.\n\n        Parameters\n        ----------\n        tname : str\n            Table to search records from.\n        where : dict or None (default `None`)\n            Dictionary of <column, value> where value can be of str type for exact match or a\n            compiled regex expression for more advanced matching.\n        where_not : dict or None (default `None`)\n            Identical to `where` but for negative-matching.\n        columns: list of str, str or None (default `None`)\n            Column(s) to return for the found records, if any.\n        astype: str, type or None (default `None`)\n            Type to cast the output to. Possible values are: `nonetype`, `series`, `str`, `dict`,\n            `json`. If this is `None`, falls back to the type provided to the constructor.\n            If a type was provided to the constructor but the user wants to avoid any casting,\n            \"nonetype\" should be passed as the value.\n\n        Returns\n        -------\n        records : str, dict or series\n            Output type depends on `astype` parameter.\n\n        Examples\n        --------\n        >>> db = PandasDatabase(\"test\")\n        >>> db.insert(\"test\", record={\"Name\": \"John\"})\n            Name                                      John\n            __id__    dc876999-1f5b-4262-b6bf-c23b875f3a54\n            dtype: object\n        >>> db.find_one(\"test\", astype=\"dict\")\n            {'Name': 'John', '__id__': 'dc876999-1f5b-4262-b6bf-c23b875f3a54'}\n        >>> db.find_one(\"test\", astype=\"series\")\n            __id__    dc876999-1f5b-4262-b6bf-c23b875f3a54\n            Name                                      John\n            Name: 0, dtype: object\n        >>> db.find_one(\"test\", astype=None)\n            __id__    dc876999-1f5b-4262-b6bf-c23b875f3a54\n            Name                                      John\n            Name: 0, dtype: object\n        >>> db.find_one(\"test\", where={\"Name\": \"John\"}, astype=\"dict\")\n            {'Name': 'John', '__id__': 'dc876999-1f5b-4262-b6bf-c23b875f3a54'}\n        >>> db.find_one(\"test\", where_not={\"Name\": \"John\"}, astype=\"dict\")\n            {}\n        '''\n        records = self.find(tname, where=where, where_not=where_not, columns=columns,\n                            astype='dataframe')\n        return self._output(records, single=True, astype=astype)", "response": "Find a single record in the provided table from the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self, tname, where=None, where_not=None, columns=None, astype=None):\n        '''\n        Delete records from the provided table. Parameters, matching and output are identical to\n        `find()`.\n\n        Parameters\n        ----------\n        tname : str\n            Table to delete records from.\n        where : dict or None (default `None`)\n            Dictionary of <column, value> where value can be of str type for exact match or a\n            compiled regex expression for more advanced matching.\n        where_not : dict or None (default `None`)\n            Identical to `where` but for negative-matching.\n        columns: list of str, str or None (default `None`)\n            Column(s) to return for the deleted records, if any.\n        astype: str, type or None (default `None`)\n            Type to cast the output to. Possible values are: `nonetype`, `dataframe`, `str`,\n            `dict`, `json`. If this is `None`, falls back to the type provided to the constructor.\n            If a type was provided to the constructor but the user wants to avoid any casting,\n            \"nonetype\" should be passed as the value.\n\n        Returns\n        -------\n        records : str, list or dataframe\n            Records deleted from the table. Output type depends on `astype` parameter.\n\n        See Also\n        --------\n        PandasDatabase.find\n        '''\n        tname = self._check_tname(tname)\n        where = PandasDatabase._check_conditions(where)\n        where_not = PandasDatabase._check_conditions(where_not)\n        columns = PandasDatabase._check_type_iter(str, columns)\n\n        # Find the rows to be deleted\n        delrows = self.find(tname, where=where, where_not=where_not, astype=DataFrame)\n\n        # Remove them from the table\n        dataframe = self._db[tname]\n        dataframe = dataframe[~(dataframe.index.isin(delrows.index))]\n        self._db[tname] = dataframe\n\n        self._print('Deleted %d records from table \"%s\"' % (len(delrows), tname))\n\n        # Save the changes to disk if required\n        if self.auto_save:\n            self.save()\n\n        # Return deleted rows\n        return self._output(delrows, astype=astype)", "response": "Delete records from the provided table."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninsert a record into the database.", "response": "def insert(self, tname, record=None, columns=None, astype=None):\n        '''\n        Inserts record into the provided table from the database. Returns inserted record as\n        list, str or series depending on the value of `astype`.\n\n        Parameters\n        ----------\n        tname : str\n            Table to insert records into.\n        where : dict or None (default `None`)\n            Dictionary of <column, value> where value can be of str type for exact match or a\n            compiled regex expression for more advanced matching.\n        where_not : dict or None (default `None`)\n            Identical to `where` but for negative-matching.\n        columns: list of str, str or None (default `None`)\n            Column(s) to return for the inserted records.\n        astype: str, type or None (default `None`)\n            Type to cast the output to. Possible values are: `nonetype`, `series`, `str`, `dict`\n            `json`. If this is `None`, falls back to the type provided to the constructor.\n            If a type was provided to the constructor but the user wants to avoid any casting,\n            \"nonetype\" should be passed as the value.\n\n        Returns\n        -------\n        record : str, dict or series\n            Inserted record. Output type depends on `astype` parameter.\n\n        Examples\n        --------\n        >>> db = PandasDatabase(\"test\")\n        >>> db.insert(\"test\", record={\"Name\": \"John\"})\n            Name                                      John\n            __id__    dc876999-1f5b-4262-b6bf-c23b875f3a54\n            dtype: object\n        '''\n        tname = self._check_tname(tname)\n        record = PandasDatabase._check_dict_type(str, str, record, cast=self.auto_cast)\n        columns = PandasDatabase._check_type_iter(str, columns)\n        record[self._id_colname] = str(uuid.uuid4())\n\n        # If a row generation function exists for this table, use that\n        record_new = {}\n        if tname in self._rowgens:\n            self._print('Using row generator to create new record in \"%s\"' % tname)\n            record_new = self._rowgens[tname]()\n\n        # Set as many fields as provided in new record, leave the rest as-is\n        if record is not None:\n            for field_key, field_val in record.items():\n                record_new[field_key] = field_val\n\n        with self._lock:\n            self._print('Inserting new record into \"%s\": %r' % (tname, record_new))\n            self._update_schema(tname, record_new.keys())\n\n            row = Series(record_new)\n            self._db[tname].loc[len(self._db[tname])] = row\n\n        # Save the changes to disk if required\n        if self.auto_save:\n            self.save()\n\n        if len(columns) > 0:\n            row = row[columns]\n\n        return self._output(row, single=True, astype=astype)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upsert(self, tname, record=None, where=None, where_not=None, columns=None, astype=None):\n        '''\n        Attempts to update records in the provided table from the database. If none are found,\n        inserts new record that would match all the conditions. Returns updated or inserted record\n        as list, dict, str, dataframe or series depending on the value of `astype`.\n\n        Parameters\n        ----------\n        tname : str\n            Table to update or insert records into.\n        where : dict or None (default `None`)\n            Dictionary of <column, value> where value can be of str type for exact match or a\n            compiled regex expression for more advanced matching.\n        where_not : dict or None (default `None`)\n            Identical to `where` but for negative-matching.\n        columns: list of str, str or None (default `None`)\n            Column(s) to return for the updated or inserted records.\n        astype: str, type or None (default `None`)\n            Type to cast the output to. Possible values are: `nonetype`, `dataframe`, `series`,\n            `str`, `dict`, `json`. If this is `None`, falls back to the type provided to the\n            constructor. If a type was provided to the constructor but the user wants to avoid any\n            casting, \"nonetype\" should be passed as the value.\n\n        Returns\n        -------\n        records : list, dict, str, dataframe or series\n            Updated or inserted records. Output type depends on `astype` parameter.\n\n        Examples\n        --------\n        >>> db = PandasDatabase(\"test\")\n        >>> db.upsert(\"test\", record={\"Name\": \"John\", \"Color\": \"Blue\"})\n            Color                                     Blue\n            Name                                      John\n            __id__    a8f31bdd-8e57-4fa7-96f6-e6b20bf7a9dc\n            dtype: object\n        >>> db.upsert(\"test\", where={\"Name\": \"Jane\", \"Color\": \"Red\"})\n            Color                                      Red\n            Name                                      Jane\n            __id__    65c3bc2b-020c-48f0-b448-5fdb4e548abe\n            dtype: object\n        >>> db.upsert(\"test\", record={\"Color\": \"Yellow\"}, where={\"Name\": \"John\"})\n                                             __id__  Name   Color\n            0  a8f31bdd-8e57-4fa7-96f6-e6b20bf7a9dc  John  Yellow\n        '''\n        tname = self._check_tname(tname)\n        where = PandasDatabase._check_conditions(where)\n        where_not = PandasDatabase._check_conditions(where_not)\n        columns = PandasDatabase._check_type_iter(str, columns)\n        record = PandasDatabase._check_dict_type(str, str, record, cast=self.auto_cast)\n\n        # Attempt search only if where conditions are given\n        if (where is not None and len(where) > 0) \\\n                or (where_not is not None and len(where_not) > 0):\n            ixs = self.find(tname, where=where, where_not=where_not, astype='dataframe').index\n\n            # If no records matched the where conditions, default to insert\n            if len(ixs) == 0:\n                self._print(\n                    'Warning: No records in \"%s\" matched the conditions %s' % (tname, where))\n\n                # Add all the key-value pairs from the where condition\n                for cond_key, cond_value in where.items():\n                    record[cond_key] = cond_value[0] if len(cond_value) > 0 else None\n\n                # Create a new record\n                record_new = self.insert(tname, record=record, columns=columns, astype='series')\n\n                # If the default value of the column provided in where_not conflicts, error out\n                if where_not is not None and any([record_new[cond_key] in cond_value\n                                                  for cond_key, cond_value in where_not.items()]):\n                    _id = PandasDatabase._id_colname\n                    self.delete(tname, where={_id: record_new[_id]})\n                    raise ValueError('Cannot insert new record because default values conflict '\n                                     'with conditions provided: %s' % where_not)\n\n                # Otherwise return created record\n                return self._output(record_new, astype=astype)\n\n            # If existing record(s) must be updated\n            elif len(ixs) > 0:\n                self._print('Updating %d record(s) in \"%s\" where %r and where not %r'\n                            % (len(ixs), tname, where, where_not))\n\n                with self._lock:\n                    self._update_schema(tname, record.keys())\n                    for field_key, field_val in record.items():\n                        self._db[tname].loc[ixs, field_key] = field_val\n\n            # Save the changes to disk if required\n            if self.auto_save:\n                self.save()\n\n            # Return updated records\n            rows = self._db[tname].loc[ixs]\n            if len(columns) > 0:\n                rows = rows[columns]\n            return self._output(rows, astype=astype)\n\n        # Insert if no where conditions are given\n        else:\n\n            # Return the new record\n            new_record = self.insert(tname, record=record, columns=columns, astype='series')\n            return self._output(new_record, astype=astype)", "response": "This method updates the record in the provided table with the provided values. If no record is found inserts a new record in the provided table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting request fields wherever they may come from GET POST files or fallback.", "response": "def _request(request, request_fallback=None):\n        ''' Extract request fields wherever they may come from: GET, POST, forms, fallback '''\n        # Use lambdas to avoid evaluating bottle.request.* which may throw an Error\n        all_dicts = [\n            lambda: request.json,\n            lambda: request.forms,\n            lambda: request.query,\n            lambda: request.files,\n            #lambda: request.POST,\n            lambda: request_fallback\n        ]\n        request_dict = dict()\n        for req_dict_ in all_dicts:\n            try:\n                req_dict = req_dict_()\n            except KeyError:\n                continue\n            if req_dict is not None and hasattr(req_dict, 'items'):\n                for req_key, req_val in req_dict.items():\n                    request_dict[req_key] = req_val\n        return request_dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _extract_params(request_dict, param_list, param_fallback=False):\n        ''' Extract pddb parameters from request '''\n\n        if not param_list or not request_dict:\n            return dict()\n\n        query = dict()\n        for param in param_list:\n            # Retrieve all items in the form of {param: value} and\n            # convert {param__key: value} into {param: {key: value}}\n            for query_key, query_value in request_dict.items():\n                if param == query_key:\n                    query[param] = query_value\n                else:\n                    query_key_parts = query_key.split('__', 1)\n                    if param == query_key_parts[0]:\n                        query[param] = {query_key_parts[1]: query_value}\n\n        # Convert special string \"__null__\" into Python None\n        nullifier = lambda d: {k:(nullifier(v) if isinstance(v, dict) else # pylint: disable=used-before-assignment\n                                  (None if v == '__null__' else v)) for k, v in d.items()}\n\n        # When fallback is enabled and no parameter matched, assume query refers to first parameter\n        if param_fallback and all([param_key not in query.keys() for param_key in param_list]):\n            query = {param_list[0]: dict(request_dict)}\n\n        # Return a dictionary with only the requested parameters\n        return {k:v for k, v in nullifier(query).items() if k in param_list}", "response": "Extract pddb parameters from request dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sha1(s):\n    h = hashlib.new('sha1')\n    h.update(s)\n    return h.hexdigest()", "response": "Returns a sha1 of the given string"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_translated_items(fapi, file_uri, use_cache, cache_dir=None):\n    items = None\n    cache_file = os.path.join(cache_dir, sha1(file_uri)) if use_cache else None\n    if use_cache and os.path.exists(cache_file):\n        print(\"Using cache file %s for translated items for: %s\" % (cache_file, file_uri))\n        items = json.loads(read_from_file(cache_file))\n    if not items:\n        print(\"Downloading %s from smartling\" % file_uri)\n        (response, code) = fapi.last_modified(file_uri)\n        items = response.data.items\n        if cache_file:\n            print(\"Caching %s to %s\" % (file_uri, cache_file))\n            write_to_file(cache_file, json.dumps(items))\n    return items", "response": "Returns the last modified items from a smartling item file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a translated file from smartling", "response": "def get_translated_file(fapi, file_uri, locale, retrieval_type, include_original_strings, use_cache, cache_dir=None):\n    \"\"\" Returns a translated file from smartling\n    \"\"\"\n    file_data = None\n    cache_name = str(file_uri)+\".\"+str(locale)+\".\"+str(retrieval_type)+\".\"+str(include_original_strings)\n    cache_file = os.path.join(cache_dir, sha1(cache_name)) if cache_dir else None\n\n    if use_cache and os.path.exists(cache_file):\n        print(\"Using cache file %s for %s translation file: %s\" % (cache_file, locale, file_uri))\n        file_data = read_from_file(cache_file)\n    elif not use_cache:\n        (file_data, code) = fapi.get(file_uri, locale,\n            retrievalType=retrieval_type,\n            includeOriginalStrings=include_original_strings)\n        file_data = str(file_data).strip()\n        if cache_file and code == 200 and len(file_data)>0:\n            print(\"Chaching to %s for %s translation file: %s\" % (cache_file, locale, file_uri))\n            write_to_file(cache_file, file_data)\n    if not file_data or len(file_data)==0:\n        print(\"%s translation not found for %s\" % (locale, file_uri))\n        return None\n    return file_data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload the files from the specified file.", "response": "def download_files(fapi, file_name, conf, use_cache, cache_dir=None):\n    \"\"\" Downloads translated versions of the files\n    \"\"\"\n    retrieval_type              = conf.get('retrieval-type', 'published')\n    include_original_strings    = 'true' if conf.get('include-original-strings', False) else 'false'\n    save_pattern                = conf.get('save-pattern')\n\n    if not save_pattern:\n        raise SmarterlingError(\"File %s doesn't have a save-pattern\" % file_name)\n\n    if cache_dir and not os.path.exists(cache_dir):\n        print(\"Creating cache dir: %s\" % (cache_dir, ))\n        os.makedirs(cache_dir)\n\n    uri = file_uri(file_name, conf)\n    translated_items = get_translated_items(fapi, uri, use_cache, cache_dir=cache_dir)\n\n    for item in translated_items:\n        item                = AttributeDict(item)\n        locale              = item.locale\n        locale_underscore   = locale.replace(\"-\", \"_\")\n        locale_android_res  = locale.replace(\"-\", \"-r\")\n        locale_parts        = locale.split(\"-\")\n        language            = locale_parts[0]\n        region              = locale_parts[1] if len(locale_parts)>1 else \"\"\n\n        file_response = get_translated_file(\n            fapi, file_uri(file_name, conf), locale, retrieval_type,\n            include_original_strings, use_cache, cache_dir=cache_dir)\n\n        if not file_response:\n            print(\"%s translation not found for %s\" % (item.locale, file_name))\n            continue\n        print(\"Processing %s translation for %s\" % (item.locale, file_name))\n\n        (fd, work_file) = tempfile.mkstemp()\n        try:\n            with open(work_file, 'w') as f:\n                f.write(file_response)\n        finally:\n            os.close(fd)\n\n        for filter_cmd in conf.get('filters', []):\n            (fd, tmp_file) = tempfile.mkstemp()\n            try :\n                filter_cmd = filter_cmd.replace(\"{input_file}\", work_file)\n                filter_cmd = filter_cmd.replace(\"{output_file}\", tmp_file)\n                filter_cmd = filter_cmd.replace(\"{locale}\", locale)\n                filter_cmd = filter_cmd.replace(\"{locale_underscore}\", locale_underscore)\n                filter_cmd = filter_cmd.replace(\"{locale_android_res}\", locale_android_res)\n                filter_cmd = filter_cmd.replace(\"{language}\", language)\n                filter_cmd = filter_cmd.replace(\"{region}\", region)\n                print(\" running filter: %s \" % filter_cmd)\n                if os.system(filter_cmd) != 0:\n                    raise SmarterlingError(\"Non 0 exit code from filter: %s\" % filter_cmd)\n                shutil.move(tmp_file, work_file)\n            finally:\n                os.close(fd)\n\n        if conf.has_key('save-cmd'):\n            save_command = conf.get('save-cmd')\n            save_command = save_command.replace(\"{input_file}\", work_file)\n            save_command = save_command.replace(\"{locale}\", locale)\n            save_command = save_command.replace(\"{locale_underscore}\", locale_underscore)\n            save_command = save_command.replace(\"{locale_android_res}\", locale_android_res)\n            save_command = save_command.replace(\"{language}\", language)\n            save_command = save_command.replace(\"{region}\", region)\n            print(\" running save command: %s \" % save_command)\n            if os.system(save_command) != 0:\n                raise SmarterlingError(\"Non 0 exit code from save command: %s\" % save_command)\n\n        elif conf.has_key('save-pattern'):\n            save_file = conf.get('save-pattern')\n            save_file = save_file.replace(\"{locale}\", locale)\n            save_file = save_file.replace(\"{locale_underscore}\", locale_underscore)\n            save_file = save_file.replace(\"{locale_android_res}\", locale_android_res)\n            save_file = save_file.replace(\"{language}\", language)\n            save_file = save_file.replace(\"{region}\", region)\n            save_dir = os.path.dirname(save_file)\n            if not os.path.exists(save_dir):\n                os.makedirs(save_dir)\n            elif not os.path.isdir(save_dir):\n                raise SmarterlingError(\"Expected %s to be a directory, but it's an existing file\" % save_dir)\n            print(\" saving output to: %s \" % save_file)\n            shutil.move(work_file, save_file)\n\n        else:\n            raise SmarterlingError(\"no save-cmd or save-pattern for: %s\" % file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nuploading a file to smartling", "response": "def upload_file(fapi, file_name, conf):\n    \"\"\" Uploads a file to smartling\n    \"\"\"\n    if not conf.has_key('file-type'):\n        raise SmarterlingError(\"%s doesn't have a file-type\" % file_name)\n    print(\"Uploading %s to smartling\" % file_name)\n    data = UploadData(\n        os.path.dirname(file_name)+os.sep,\n        os.path.basename(file_name),\n        conf.get('file-type'))\n    data.setUri(file_uri(file_name, conf))\n    if conf.has_key('approve-content'):\n        data.setApproveContent(\"true\" if conf.get('approve-content', True) else \"false\")\n    if conf.has_key('callback-url'):\n        data.setCallbackUrl(conf.get('callback-url'))\n    for name, value in conf.get('directives', {}).items():\n        data.addDirective(SmartlingDirective(name, value))\n    (response, code) = fapi.upload(data)\n    if code!=200:\n        print(repr(response))\n        raise SmarterlingError(\"Error uploading file: %s\" % file_name)\n    else:\n        print(\"Uploaded %s, wordCount: %s, stringCount: %s\" % (file_name, response.data.wordCount, response.data.stringCount))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a SmartlingFileApi from the given config", "response": "def create_file_api(conf):\n    \"\"\" Creates a SmartlingFileApi from the given config\n    \"\"\"\n    api_key = conf.config.get('api-key', os.environ.get('SMARTLING_API_KEY'))\n    project_id = conf.config.get('project-id', os.environ.get('SMARTLING_PROJECT_ID'))\n\n    if not project_id or not api_key:\n        raise SmarterlingError('config.api-key and config.project-id are required configuration items')\n    proxy_settings=None\n    if conf.config.has_key('proxy-settings'):\n        proxy_settings = ProxySettings(\n            conf.config.get('proxy-settings').get('username', ''),\n            conf.config.get('proxy-settings').get('password', ''),\n            conf.config.get('proxy-settings').get('host', ''),\n            int(conf.config.get('proxy-settings').get('port', '80')))\n    return SmartlingFileApiFactory().getSmartlingTranslationApi(\n        not conf.config.get('sandbox', False),\n        api_key,\n        project_id,\n        proxySettings=proxy_settings)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a smarterling config file and returns an AttributeDict", "response": "def parse_config(file_name='smarterling.config'):\n    \"\"\" Parses a smarterling configuration file\n    \"\"\"\n    if not os.path.exists(file_name) or not os.path.isfile(file_name):\n        raise SmarterlingError('Config file not found: %s' % file_name)\n    try:\n        contents = read_from_file(file_name)\n        contents_with_environment_variables_expanded = os.path.expandvars(contents)\n        return AttributeDict(yaml.load(contents_with_environment_variables_expanded))\n    except Exception as e:\n        raise SmarterlingError(\"Error paring config file: %s\" % str(e))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, key, default_val=None, require_value=False):\n        val = dict.get(self, key, default_val)\n        if val is None and require_value:\n            raise KeyError('key \"%s\" not found' % key)\n        if isinstance(val, dict):\n            return AttributeDict(val)\n        return val", "response": "Returns a dictionary value by its key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite display buffer to physical display.", "response": "def display(self):\n        \"\"\"Write display buffer to physical display.\"\"\"\n        self.command(SSD1306_COLUMNADDR)\n        self.command(0)              # Column start address. (0 = reset)\n        self.command(self.width-1)   # Column end address.\n        self.command(SSD1306_PAGEADDR)\n        self.command(0)              # Page start address. (0 = reset)\n        self.command(self._pages-1)  # Page end address.\n        for i in range(0, len(self._buffer), 16):\n            control = 0x40   # Co = 0, DC = 0\n            self._i2c.write_list(control, self._buffer[i:i+16])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconnect a widget to a specific entry in the model.", "response": "def connect_widget(self, wid,\n                       getter=None, setter=None,\n                       signal=None, arg=None, update=True,\n                       flavour=None):\n\n        \"\"\"\n        Finish set-up by connecting the widget. The model was already\n        specified in the constructor.\n\n        *wid* is a widget instance.\n\n        *getter* is a callable. It is passed *wid* and must return its\n        current value.\n\n        *setter* is a callable. It is passed *wid* and the current value of\n        the model property and must update the widget.\n\n        *signal* is a string naming the signal to connect to on *wid*. When\n        it is emitted we update the model.\n\n        *getter*, *setter* and *signal* are optional. Missing values are\n        guessed from *wid* using\n        :meth:`gtkmvc3.adapters.default.search_adapter_info`. If nothing is\n        found this raises :exc:`TypeError`.\n\n        *arg* is an optional value passed to the handler for *signal*. This\n        doesn't do anything unless a subclass overrides the handler.\n\n        *update* denotes whether to update the widget from the model\n        immediately. Otherwise the widget stays unchanged until the first\n        notification.\n\n        *flavour* can be used to select special behaviours about\n         the adaptation when twice or more possibilities are\n         possibly handled for the same widget type. See\n         adapters.default for further information.\n\n        \"\"\"\n\n        if wid in self._wid_info:\n            raise ValueError(\"Widget \" + str(wid) + \" was already connected\")\n\n        wid_type = None\n\n        if None in (getter, setter, signal):\n            w = search_adapter_info(wid, flavour)\n            if getter is None:\n                getter = w[GETTER]\n            if setter is None:\n                setter = w[SETTER]\n                wid_type = w[WIDTYPE]\n\n            if signal is None:\n                signal = w[SIGNAL]\n\n        # saves information about the widget\n        self._wid_info[wid] = (getter, setter, wid_type)\n\n        # connects the widget\n        if signal:\n            if arg:\n                wid.connect(signal, self._on_wid_changed, arg)\n            else:\n                wid.connect(signal, self._on_wid_changed)\n\n        self._wid = wid\n\n        # updates the widget:\n        if update:\n            self.update_widget()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting the property into the model and register self as a value observer for that property", "response": "def _connect_model(self, model):\n        \"\"\"\n        Used internally to connect the property into the model, and\n        register self as a value observer for that property\"\"\"\n\n        parts = self._prop_name.split(\".\")\n        if len(parts) > 1:\n            # identifies the model\n            models = parts[:-1]\n            Intermediate(model, models, self)\n            for name in models:\n                model = getattr(model, name)\n                if not isinstance(model, Model):\n                    raise TypeError(\"Attribute '\" + name +\n                                    \"' was expected to be a Model, but found: \" +\n                                    str(model))\n            prop = parts[-1]\n        else: prop = parts[0]\n\n        # prop is inside model?\n        if not hasattr(model, prop):\n            raise ValueError(\"Attribute '\" + prop +\n                             \"' not found in model \" + str(model))\n\n        # is it observable?\n        if model.has_property(prop):\n            # we need to create an observing method before registering\n            meth = types.MethodType(self._get_observer_fun(prop), self)\n            setattr(self, meth.__name__, meth)\n\n        self._prop = getattr(model, prop)\n        self._prop_name = prop\n\n        # registration of model:\n        self._model = model\n        self.observe_model(model)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_observer_fun(self, prop_name):\n        def _observer_fun(self, model, old, new):\n            if self._itsme:\n                return\n            self._on_prop_changed()\n\n        # doesn't affect stack traces\n        _observer_fun.__name__ = \"property_%s_value_change\" % prop_name\n        return _observer_fun", "response": "This is the code for an value change observer"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read_property(self, *args):\n        if self._prop_read:\n            return self._prop_read(self._get_property(*args))\n        return self._get_property(*args)", "response": "Read the current value of the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the value currently stored into the widget after transforming it accordingly to possibly specified function.", "response": "def _read_widget(self):\n        \"\"\"Returns the value currently stored into the widget, after\n        transforming it accordingly to possibly specified function.\n\n        This is implemented by calling the getter provided by the\n        user. This method can raise InvalidValue (raised by the\n        getter) when the value in the widget must not be considered as\n        valid.\"\"\"\n        getter = self._wid_info[self._wid][0]\n        return getter(self._wid)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting value into the widget. If specified user setter is invoked.", "response": "def _write_widget(self, val):\n        \"\"\"Writes value into the widget. If specified, user setter\n        is invoked.\"\"\"\n        self._itsme = True\n        try:\n            setter = self._wid_info[self._wid][1]\n            wtype = self._wid_info[self._wid][2]\n            if setter:\n                if wtype is not None:\n                    setter(self._wid, self._cast_value(val, wtype))\n                else:\n                    setter(self._wid, val)\n        finally:\n            self._itsme = False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _resolve_to_func(self, what):\n        if isinstance(what, str):\n            what = getattr(Adapter._get_property(self), what)\n\n        # makes it an unbounded function if needed\n        if type(what) == types.MethodType:\n            what = what.__func__\n\n        if not type(what) == types.FunctionType:\n            raise TypeError(\"Expected a method name, a method or a function\")\n        return what", "response": "This method resolves what to a function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling by the observation code when a property is changed", "response": "def _on_prop_changed(self, instance, meth_name, res, args, kwargs):\n        \"\"\"Called by the observation code, when a modifying method\n        is called\"\"\"\n        Adapter._on_prop_changed(self)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndistorting a string by randomly replacing characters in it.", "response": "def distort(value):\n        \"\"\"\n        Distorts a string by randomly replacing characters in it.\n\n        :param value: a string to distort.\n\n        :return: a distored string.\n        \"\"\"\n        value = value.lower()\n\n        if (RandomBoolean.chance(1, 5)):\n            value = value[0:1].upper() + value[1:]\n\n        if (RandomBoolean.chance(1, 3)):\n            value = value + random.choice(_symbols)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef next_string(min_size, max_size):\n        result = ''\n        \n        max_size = max_size if max_size != None else min_size\n        length = RandomInteger.next_integer(min_size, max_size)\n        for i in range(length):\n            result += random.choice(_chars)\n\n        return result", "response": "Generates a random string of the specified length and minimum length and maximum length."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pwm_start(self, channel, duty_cycle=None, frequency=None):\n        if frequency:\n            self.set_pwm_freq(frequency)\n        self.set_pwm(channel, 0, int(4096 * (duty_cycle/100)))", "response": "This method starts the pwm signal on a specific channel."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_pwm_freq(self, freq_hz):\n        prescaleval = 25000000.0    # 25MHz\n        prescaleval /= 4096.0       # 12-bit\n        prescaleval /= float(freq_hz)\n        prescaleval -= 1.0\n        logger.debug('Setting PWM frequency to {0} Hz'.format(freq_hz))\n        logger.debug('Estimated pre-scale: {0}'.format(prescaleval))\n        prescale = int(math.floor(prescaleval + 0.5))\n        logger.debug('Final pre-scale: {0}'.format(prescale))\n        oldmode = self.i2c.read_U8(MODE1)\n        newmode = (oldmode & 0x7F) | 0x10    # sleep\n        self.i2c.write8(MODE1, newmode)  # go to sleep\n        self.i2c.write8(PRESCALE, prescale)\n        self.i2c.write8(MODE1, oldmode)\n        time.sleep(0.005)\n        self.i2c.write8(MODE1, oldmode | 0x80)", "response": "Set the PWM frequency to the provided value in hertz."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_pwm(self, channel, on, off):\n        self.i2c.write8(LED0_ON_L+4*channel, on & 0xFF)\n        self.i2c.write8(LED0_ON_H+4*channel, on >> 8)\n        self.i2c.write8(LED0_OFF_L+4*channel, off & 0xFF)\n        self.i2c.write8(LED0_OFF_H+4*channel, off >> 8)", "response": "Sets a single PWM channel."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_all_pwm(self, on, off):\n        self.i2c.write8(ALL_LED_ON_L, on & 0xFF)\n        self.i2c.write8(ALL_LED_ON_H, on >> 8)\n        self.i2c.write8(ALL_LED_OFF_L, off & 0xFF)\n        self.i2c.write8(ALL_LED_OFF_H, off >> 8)", "response": "Sets all PWM channels."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef collect_ansible_classes():\n    def trace_calls(frame, event, arg):  # pylint: disable=W0613\n        \"\"\"Trace function calls to collect ansible classes.\n\n        Trace functions and check if they have self as an arg. If so, get their class if the\n        class belongs to ansible.\n        \"\"\"\n        if event != 'call':\n            return\n        try:\n            _locals = inspect.getargvalues(frame).locals\n            if 'self' not in _locals:\n                return\n            _class = _locals['self'].__class__\n            _class_repr = repr(_class)\n            if 'ansible' not in _class_repr:\n                return\n            ANSIBLE_CLASSES[_class] = True\n        except (AttributeError, TypeError):\n            pass\n\n    print \"Gathering classes\"\n    sys.settrace(trace_calls)\n    main()", "response": "Run playbook and collect classes of ansible that are run."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing command line args and separate generator and playbook args.", "response": "def _parse_args():\n    \"\"\"Parse args and separate generator and playbook args.\"\"\"\n    class HelpOnErrorArgParser(argparse.ArgumentParser):\n        \"\"\"Print help message as well when an error is raised.\"\"\"\n        def error(self, message):\n            sys.stderr.write(\"Error: %s\\n\" % message)\n            self.print_help()\n            sys.exit(2)\n\n    def validate(_file):\n        \"\"\"Validate if the given target argument is a valid file or a valid directory\"\"\"\n        _file = abspath(_file)\n        if not exists(_file):\n            if not exists(dirname(_file)):\n                # Argparse uses the ArgumentTypeError to give a rejection message like:\n                # error: argument input: x does not exist\n                raise argparse.ArgumentTypeError(\"{0} does not exist\".format(_file))\n        return _file\n\n    def expand_cg_args(cg_args):\n        \"\"\"Separate clubbed flags in command line args for the generator.py\n\n        Allows flags to be clubbed like, -ilt example.txt.\n        \"\"\"\n        expanded = list()\n        for item in cg_args:\n            if len(item) < 3:\n                # If at all a flag, must be single flag\n                expanded.append(item)\n                continue\n            if item.startswith(\"-\"):\n                if not item.startswith(\"--\"):\n                    for flag in item[1:]:\n                        expanded.append('-' + flag)\n                    continue\n            expanded.append(item)\n        return expanded\n\n    class AssignDefaultIgnore(argparse.Action):\n        \"\"\"If argument is specified but nothing provided, use pre-defined.\n\n        nargs=\"*\" doesn't allow const and default kwarg can't be used as we might not want to\n        ignore as well.\n        \"\"\"\n        def __call__(self, parser, args, values, option_string=None):\n            if values is not None and not len(values):\n                values = IGNORE_METHODS\n            setattr(args, self.dest, values)\n\n    try:\n        indx = sys.argv.index('--')\n        cg_args, sys.argv = sys.argv[1:indx], sys.argv[:1] + sys.argv[indx + 1:]\n    except ValueError:\n        cg_args = []\n\n    cg_args = expand_cg_args(cg_args)  # allow -il type of usage\n    parser = HelpOnErrorArgParser(description=DESCRIPTION)\n    parser.add_argument(\n        \"-l\", \"--long\", action='store_true', default=False,\n        help=\"File reference of method in call graph is absolute, i.e. starts with ansible, \"\n             \"otherwise just the basename if not __init__.py\")\n    parser.add_argument(\n        \"-t\", \"--target\", nargs=\"?\", type=validate, const=TARGET_FILE, default=TARGET_FILE,\n        help=\"Filepath to write call graph, defaults to %(default)s\")\n    parser.add_argument(\n        \"-i\", \"--ignore\", nargs='*', action=AssignDefaultIgnore,\n        help=\"Methods to ignore while generating call graph\")\n    # TODO: Aloow classes that can be intercepted\n    parser.usage = \\\n        parser.format_usage()[len(\"usage: \"):].rstrip() + \" -- <ansible-playbook options>\\n\"\n    cg_args = parser.parse_args(cg_args)\n\n    if not len(sys.argv[1:]):\n        parser.print_help()\n        sys.exit(2)\n\n    return cg_args"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef detect_process(cls, headers):\n\n    try:\n      if 'Libprocess-From' in headers:\n        return PID.from_string(headers['Libprocess-From']), False\n      elif 'User-Agent' in headers and headers['User-Agent'].startswith('libprocess/'):\n        return PID.from_string(headers['User-Agent'][len('libprocess/'):]), True\n    except ValueError as e:\n      log.error('Failed to detect process: %r' % e)\n      pass\n\n    return None, None", "response": "Returns tuple of process legacy or None if not process originating."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmounts a Process onto the http server to receive message callbacks.", "response": "def mount_process(self, process):\n    \"\"\"\n    Mount a Process onto the http server to receive message callbacks.\n    \"\"\"\n\n    for route_path in process.route_paths:\n      route = '/%s%s' % (process.pid.id, route_path)\n      log.info('Mounting route %s' % route)\n      self.app.add_handlers('.*$', [(\n          re.escape(route),\n          RoutedRequestHandler,\n          dict(process=process, path=route_path)\n      )])\n\n    for message_name in process.message_names:\n      route = '/%s/%s' % (process.pid.id, message_name)\n      log.info('Mounting message handler %s' % route)\n      self.app.add_handlers('.*$', [(\n          re.escape(route),\n          WireProtocolMessageHandler,\n          dict(process=process, name=message_name)\n      )])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a parameter identified by key and an untyped string convert that string to the type that our version of key has.", "response": "def typevalue(self, key, value):\n        \"\"\"Given a parameter identified by ``key`` and an untyped string,\n        convert that string to the type that our version of key has.\n\n        \"\"\"\n\n        def listconvert(value):\n            # this function might be called with both string\n            # represenations of entire lists and simple (unquoted)\n            # strings. String representations come in two flavours,\n            # the (legacy/deprecated) python literal (eg \"['foo',\n            # 'bar']\") and the simple (eg \"foo, bar\") The\n            # ast.literal_eval handles the first case, and if the\n            # value can't be parsed as a python expression, the second\n            # way is attempted. If both fail, it is returned verbatim\n            # (not wrapped in a list, for reasons)\n            try:\n                return ast.literal_eval(value)\n            except (SyntaxError, ValueError):\n                if \",\" in value:\n                    return [x.strip() for x in value.split(\",\")]\n                else:\n                    return value\n\n        # self.get(key) should never fail\n        default = self.get(key)\n        # if type(default) == type:\n        if inspect.isclass(default):\n            # print(\"Using class for %s\" % key)\n            t = default\n        else:\n            # print(\"Using instance for %s\" % key)\n            t = type(default)\n\n        if t == bool:\n            t = LayeredConfig.boolconvert\n        elif t == list:\n            t = listconvert\n        elif t == date:\n            t = LayeredConfig.dateconvert\n        elif t == datetime:\n            t = LayeredConfig.datetimeconvert\n        # print(\"Converting %r to %r\" % (value,t(value)))\n        return t(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_instance(user):\n\n  inst = None\n  f = Usuario.objects.filter(user=user)\n  if f.exists():\n    inst = f[0]\n    for sub_u in Usuario.__subclasses__():\n      if hasattr(inst, sub_u.__name__.lower()):\n        inst = getattr(inst, sub_u.__name__.lower())\n        break\n  return inst", "response": "funci\u00f3n que busca la instancia de la clase hija m\u00e1s baja de Usuario y que\n est\u00e9 enlazada con el usuario dado por par\u00e1metro."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save(self, UserSave=True, *args, **kwargs):\n\n    if hasattr(self, 'user') and self.user is not None:\n      # caso que se le asigna un usuario determinado\n      if hasattr(self.user, 'usuario') and self.user.usuario is not None:\n        # caso que se le haya asignado un usuario\n        if self.user.usuario.pk != self.pk:\n          # caso el usuario asignado ya tiene a otro\n          raise IntegrityError(\"Debe ingresar User que no tenga relaci\u00f3n con ning\u00fan Usuario existente.\")\n        else:\n          # en este caso se debe revisar si hay que modificar User\n          pass\n    else:\n      # caso que No tenga un usuario asignado de antemano\n      if not hasattr(self, 'password') or not hasattr(self, 'username'):\n        # caso que no tenga los atributos password y/o username\n        raise IntegrityError(\"Debe ingresar los campos password y username si desea automatizar la creaci\u00f3n de un User.\")\n      else:\n        if not hasattr(self, 'first_name'):\n          self.first_name = \"\"\n        if not hasattr(self, 'last_name'):\n          self.last_name = \"\"\n        if not hasattr(self, 'email'):\n          self.email = \"\"\n\n        user = User(\n          username=self.username,\n          first_name=self.first_name,\n          last_name=self.last_name,\n          email=self.email\n        )\n        # almacenar password de forma segura\n        user.set_password(self.password)\n        user.save()\n        self.user = user\n\n        # eliminar los atributos que no se debiesen estar en la instancia\n        for name in ['username', 'password', 'first_name', 'last_name', 'email']:\n          delattr(self, name)\n\n    # se guarda  Usuario y User en caso que se haya modificado\n    super().save(*args, **kwargs)\n    if UserSave:\n      self.user.save()", "response": "Se sobreescribe el m\u00e9todo salvar para poder gestionar los creaci\u00f3n de un User."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a list of valid keys", "response": "def generate_valid_keys():\n    \"\"\" create a list of valid keys \"\"\"\n    valid_keys = []\n    for minimum, maximum in RANGES:\n        for i in range(ord(minimum), ord(maximum) + 1):\n            valid_keys.append(chr(i))\n    return valid_keys"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the jenks configuration file", "response": "def get_configuration_file():\n    \"\"\" return jenks configuration file \"\"\"\n    path = os.path.abspath(os.curdir)\n    while path != os.sep:\n        config_path = os.path.join(path, CONFIG_FILE_NAME)\n        if os.path.exists(config_path):\n            return config_path\n        path = os.path.dirname(path)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a method to write the configuration in yaml to the file", "response": "def generate_write_yaml_to_file(file_name):\n    \"\"\" generate a method to write the configuration in yaml to the method desired \"\"\"\n    def write_yaml(config):\n        with open(file_name, 'w+') as fh:\n            fh.write(yaml.dump(config))\n    return write_yaml"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_grid_data(file_list, data_type=\"binary\", sort=True, delim=\" \"):\n\n    # If there's only one file, we pretend it's a list\n    if not type(file_list) is list:\n        file_list = [file_list]\n    elif sort:\n        # put file_list in chronological order\n        file_list.sort(key=lambda f: int(re.sub(\"[^0-9]\", \"\", f)))\n\n    world_size = get_world_dimensions(file_list[0], delim)\n\n    # Initialize empty data array\n    data = initialize_grid(world_size, [])\n\n    # Loop through file list, reading in data\n    for f in file_list:\n        infile = open(f)\n        lines = infile.readlines()\n        for i in range(world_size[1]):\n            lines[i] = lines[i].strip().split(delim)\n\n            for j in range(world_size[0]):\n                if data_type == \"binary\":\n                    val = bin(int(lines[i][j]))\n                elif data_type == \"float\":\n                    val = float(lines[i][j])\n                elif data_type == \"int\":\n                    val = int(lines[i][j])\n                elif data_type == \"string\":\n                    val = str(lines[i][j])\n                else:\n                    print(\"Unsupported data_type passed to load_grid\")\n                    return\n                data[i][j].append(val)\n\n        infile.close()\n\n    return data", "response": "Loads data from one or multiple grid_task files."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_niche_grid(res_dict, world_size=(60, 60)):\n\n    # Initialize array to represent world\n    world = initialize_grid(world_size, set())\n\n    # Fill in data on niches present in each cell of the world\n    for res in res_dict:\n        for cell in res_dict[res]:\n            world[cell[1]][cell[0]].add(res)\n\n    return world", "response": "Creates a nested Avida grid of resources in the environment and returns it"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse the environment files in a list of strings and returns a list of lists of lists of spatial resources.", "response": "def parse_environment_file_list(names, world_size=(60, 60)):\n    \"\"\"\n    Extract information about spatial resources from all environment files in\n    a list.\n\n    Arguments:\n    names - a list of strings representing the paths to the environment files.\n    world_size - a tuple representing the x and y coordinates of the world.\n                 (default: 60x60)\n\n    Returns a dictionary in which the keys are filenames and the values are\n    list of lists of sets indicating the set of resources\n    available at each x,y location in the Avida grid for that environment.\n    \"\"\"\n\n    # Convert single file to list if necessary\n    try:\n        names[0] = names[0]\n    except:\n        names = [names]\n\n    envs = []\n    for name in names:\n        envs.append(parse_environment_file(name, world_size))\n\n    return envs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreduce the resource name to the task name that is being rewarded.", "response": "def reduce_resource_name_to_task(res_name):\n    \"\"\"\n    Assuming that the convention of naming resources associated with tasks as\n    res[TASK][number], reduces such resource names to just the name of the\n    task. This ensures that multiple copies of the same resource are treated\n    the same. Resource names of different formats will be left untouched.\n    \"\"\"\n    # Reduce resource names to tasks being rewarded\n    if res_name[:3].lower() != \"res\":\n        return res_name\n    res_name = res_name[3:].lower()\n    while res_name[-1].isdigit():\n        res_name = res_name[:-1]\n    return res_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses an environment file into a list of sets of resources and niches.", "response": "def parse_environment_file(filename, world_size=(60, 60)):\n    \"\"\"\n    Extract information about spatial resources from an environment file.\n\n    Arguments:\n    filename - a string representing the path to the environment file.\n    world_size - a tuple representing the x and y coordinates of the world.\n                 (default: 60x60)\n\n    Returns a list of lists of sets indicating the set of resources\n    available at each x,y location in the Avida grid.\n    \"\"\"\n\n    infile = open(filename)\n    lines = infile.readlines()\n    infile.close()\n\n    tasks = []\n\n    # Find all spatial resources and record which cells they're in\n    res_order = []\n    res_dict = {}\n    for line in lines:\n        if line.startswith(\"GRADIENT_RESOURCE\"):\n            name, cells = parse_gradient(line, world_size)\n        elif line.startswith(\"CELL\"):\n            name, cells = parse_cell(line, world_size)\n        elif line.startswith(\"REACTION\"):\n            task = parse_reaction(line)\n            if task not in tasks:\n                tasks.append(task)\n        else:\n            continue\n\n        dict_increment(res_dict, name, cells)\n        if name not in res_order:\n            res_order.append(name)\n\n    # Create a map of niches across the environment and return it\n    grid = make_niche_grid(res_dict, world_size)\n\n    return EnvironmentFile(grid, res_order, world_size, filename, tasks)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the gradient of a single Avida .", "response": "def parse_gradient(line, world_size):\n    \"\"\"\n    Takes a string representing a GRADIENT_RESOURCE (as specified in Avida\n    environment files) and a tuple representing the x and y dimensions of the\n    world, and returns the name of the gradient resource and a list of\n    tuples representing the cells it's in.\n    \"\"\"\n    # remove \"GRADIENT_RESOURCE\"\n    line = line[18:]\n\n    sline = [el.strip() for el in line.split(\":\")]\n    name = sline[0]\n    name = reduce_resource_name_to_task(name)\n    radius = None\n    x = None\n    y = None\n\n    # Extract data\n    for item in sline:\n        if item.startswith(\"height\"):\n            radius = int(item.split(\"=\")[1])\n        elif item.startswith(\"peakx\"):\n            x = int(item.split(\"=\")[1])\n        elif item.startswith(\"peaky\"):\n            y = int(item.split(\"=\")[1])\n\n    # Translate circle to cells)\n    cells = []\n    for i in range(world_size[0]):\n        for j in range(world_size[1]):\n            if (dist((i, j), (x, y))) <= radius-1:\n                cells.append((i, j))\n\n    return (name, cells)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_cell(line, world_size):\n    # Remove \"CELL \"\n    line = line[4:]\n\n    # Extract information\n    sline = [i.strip() for i in line.split(\":\")]\n    name = sline[0]\n    name = reduce_resource_name_to_task(name)\n    cell_components = sline[1].split(\",\")\n    cells = []\n\n    # List all cells\n    for i in range(len(cell_components)):\n        if \"..\" in cell_components[i]:\n            cell_range = [int(j) for j in cell_components[i].split(\"..\")]\n            for j in range(int(cell_range[0]), int(cell_range[1]+1)):\n                cells.append(j)\n        else:\n            cells.append(int(cell_components[i]))\n\n    if cells == [\"\"]:\n        return (name, [])\n\n    xy_pairs = [(int(c) % world_size[0], int(c)//world_size[0]) for c in cells]\n\n    return (name, xy_pairs)", "response": "Parses a CELL line into a tuple representing the x and y dimensions of the resource and the list of cells it s in."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_nested_to_dataframe(agg, dates_as_key=True):\n    '''A function that takes nested elasticsearch response with aggregation and returns a nested dataframe\n        Warning: This is a recursive function, and rather non-intuitive to understand\n\n        This function takes nested and crossed aggregations and converts them to an easy to manipulates pandas dataframe\n         e.g. Here we have a gender aggregation nested in year which is nested in state\n\n        the output we want:\n\n        state        year       gender      doc_count\n        CA           2000       male        2\n        CA           2000       female      5\n        CA           2001       male        5\n        CA           2001       female      5\n        CA           2002       male        5\n        CA           2002       female      5\n        MN           2000       male        2\n        MN           2000       female      5\n        MN           2001       male        5\n        MN           2001       female      5\n        MN           2002       male        5\n        MN           2002       female      5\n        NY           2000       male        2\n        NY           2000       female      5\n        NY           2001       male        5\n        NY           2001       female      5\n        NY           2002       male        5\n        NY           2002       female      5\n\n        What we do is step down through all the layers of nested data (recursively) until we reach the end,\n        and from the end, start creating pandas dataframes that get merged back into one giant dataframe\n\n        this function is in an experimental state, and currently only tested on 3 nested levels,\n        TODO crossed data does not work\n        :param agg: an aggregation from elasticsearch results with nesting\n        :type agg: elasticsearch response.aggregation object\n        :returns: pandas data frame like example above, with nested data\n    '''\n    crossed_cats_expanded = []\n    high_level_returning = False\n    agg_as_dict = agg.to_dict()\n    cat_names = [item for item in agg_as_dict.keys() if type(agg_as_dict[item]) is dict]\n    for cat_name in cat_names:  # TODO deal with multiple aggregations at the same level (Crossing)\n        expanded_buckets = []\n        merge_vert = False\n        if not len(getattr(agg, cat_name).buckets):\n            raise ValueError('There is no count data in the lowest level of nesting. Is your search setup correctly?')\n\n        for bucket in getattr(agg, cat_name).buckets:\n            bucket_as_dict = bucket.to_dict()\n            if dict not in [type(item) for item in bucket_as_dict.values()]:\n                # we are at lowest level, begin return\n                if ('key_as_string' in bucket_as_dict.keys()) and dates_as_key:  # change dates to readble format\n                    bucket_as_dict['key'] = bucket['key_as_string']\n                    bucket_as_dict.pop('key_as_string')\n\n                bucket_as_dict[cat_name] = bucket_as_dict.pop(\n                    'key')  # change the name of the key to something meaningful\n                expanded_buckets.append(bucket_as_dict)  # combine each dict at the lowest level\n            else:\n                # We are at some level other than the lowest\n                level_name = str(bucket.key)  # save the name of this level\n                lower_level_return = convert_nested_to_dataframe(bucket)  # and drop down into the next level\n                expanded_buckets.append(add_category_labels(level_name, cat_name, lower_level_return))\n                merge_vert = True\n        if not merge_vert:\n            dataframe_out = pd.DataFrame(expanded_buckets)\n            dataframe_out.rename(columns=lambda x: x.replace('key', cat_name))\n            crossed_cats_expanded.append(dataframe_out.reset_index(drop=True))\n            high_level_returning = True\n\n    if high_level_returning:\n        return pd.concat(crossed_cats_expanded, axis=1).reset_index(drop=True)\n    else:\n        return pd.concat(expanded_buckets, axis=0).reset_index(drop=True)", "response": "A function that takes an elasticsearch response with aggregation and returns a nested dataframe"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a dictionary - like object into a tuple - representation.", "response": "def dict2tuple(mydict):\n    \"\"\"\n    Turn a dictionary of the form used by DINGO\n    (i.e., a key is mapped to either another dictionary,\n    a list or a value) into a tuple-representation.\n    This is useful for providing a standard python object that\n    observes the order of elements (which standard dictionaries don't).\n    \"\"\"\n    result = []\n    for key in mydict.keys():\n        # There are three cases we need to consider:\n        # dictionary, list, and other values\n        try:\n            # We test whether the object is a dictionary-like\n            # structure via accessing the\n            keys = mydict[key].keys()\n            key_result = dict2tuple(mydict[key])\n        except AttributeError:\n            # So we have either a list or a value\n            if type(mydict[key]) == type([]):\n                key_result = []\n                for elt in mydict[key]:\n                    key_result.append(dict2tuple(elt))\n            else:\n                key_result = mydict[key]\n        result.append((key, key_result))\n    return tuple(result)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nturn a tuple as returned by dict2tuple back into a dictionary structure.", "response": "def tuple2dict(mytuple, constructor=dict):\n    \"\"\"\n    Turn a tuple as returned by dict2tuple back\n    into a dictionary structure. The optional\n    parameter \"constructor\" governs, what class\n    is used to create the dictionary: by default,\n    the standard dict class is used, but in DINGO\n    we mostly use the DingoObjDict class.\n    \"\"\"\n    result = constructor()\n    for elt in mytuple:\n        key, value = elt\n        if type(value) == type(()):\n            key_value = tuple2dict(value, constructor=constructor)\n        elif type(value) == type([]):\n            key_value = []\n            for elt in value:\n                key_value.append(tuple2dict(elt, constructor=constructor))\n        else:\n            key_value = value\n        result[key] = key_value\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nturning a dictionary of the form used by DINGO into a DingoObjDict.", "response": "def dict2DingoObjDict(data):\n    \"\"\"\n    Turn a dictionary of the form used by DINGO\n    (i.e., a key is mapped to either another dictionary,\n    a list or a value) into a DingoObjDict.\n    \"\"\"\n    info_tuple = dict2tuple(data)\n    info_dict = tuple2dict(info_tuple, constructor=DingoObjDict)\n    return info_dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef chained_get(self, *keys):\n        existing = self\n        for i in range(0, len(keys)):\n            if keys[i] in existing:\n                existing = existing[keys[i]]\n            else:\n                return None\n        return existing", "response": "This function is used to get the next set of keys from the database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nflatten a Dingo dictionary representation of into a list of fact - term value pairs and associated information about tree structure.", "response": "def flatten(self, attr_ignore_predicate=None,force_nonleaf_fact_predicate=None,namespace_dict=None):\n        \"\"\"\n        Flatten a Dingo dictionary representation of into a list\n        of fact-term/value pairs and associated information about tree structure (in node_id)\n        and a dictionary mapping XML attributes to node identifiers.\n\n        This all is best explained by example (see below).\n\n        Note that attributes are also represented in the flattened representation. There\n        are cases in which attributes should not lead to an entry in the flattened representation.\n        This can be configured by passing the flatten method a predicate function 'attr_ignore_predicate'.\n        The function takes a dictionary and returns True (ignore) or False (do not ignore). It\n        is passed the dictionary representing an entry in the flat representation, such as follows::\n\n              { 'node_id': 'N001:L000:N000:A000',\n              'term': 'Hashes/Hash/Simple_Hash_Value',\n              'attribute': 'condition',\n              'value': u'Equals'},\n\n        By default, the following predicate is used::\n\n             (lambda x : '@' in x['attribute'])\n\n        This is because during import, DINGO adds certain annotations to the import dictionary\n        as attributes with a second leading '@'.\n\n        Input Example (CybOx)::\n\n            {'File_Name': {'@condition': 'Equals',  '_value': u'UNITED NATIONS COMPENSATION SCHEME...pdf'},\n              'Hashes': {'Hash': [{'Simple_Hash_Value':\n                                    {'@condition': 'Equals',\n                                     '@datatype': 'hexBinary',\n                                      '_value': u'576fea79dd23a352a14c3f8bf3dbc9eb732e1d54f804a29160894aec55df4bd5'},\n                                   'Type': {'_value': 'SHA256'}},\n                                  {'Simple_Hash_Value': {'@condition': 'Equals',\n                                                         '@datatype': 'hexBinary',\n                                                         '_value': u'491809c2092cecd633e43d465409a78c'},\n                                   'Type': {'_value': 'MD5'}}]\n                        }\n            }\n\n        Output Example::\n\n          [ { 'node_id': 'N000',\n              'term': 'File_Name',\n              'attribute': False,\n              'value': u'UNITED NATIONS COMPENSATION SCHEME...pdf'},\n              { 'node_id': 'N000:A000',\n              'term': 'File_Name',\n              'attribute': 'condition',\n              'value': u'Equals'},\n            { 'node_id': 'N001:L000:N000',\n              'term': 'Hashes/Hash/Simple_Hash_Value',\n              'attribute': False,\n              'value': u'576fea79dd23a352a14c3f8bf3dbc9eb732e1d54f804a29160894aec55df4bd5'},\n            { 'node_id': 'N001:L000:N000:A000',\n              'term': 'Hashes/Hash/Simple_Hash_Value',\n              'attribute': 'condition',\n              'value': u'Equals'},\n            { 'node_id': 'N001:L000:N000:A001',\n              'term': 'Hashes/Hash/Simple_Hash_Value',\n              'attribute': 'datatype',\n              'value': u'hexBinary'},\n            { 'node_id': 'N001:L000:N001',\n              'term': 'Hashes/Hash/Type',\n              'attribute': False,\n              'value': 'SHA256'},\n            { 'node_id': 'N001:L001:N000',\n              'term': 'Hashes/Hash/Simple_Hash_Value',\n              'attribute': False,\n              'value': u'491809c2092cecd633e43d465409a78c'},\n            { 'node_id': 'N001:L001:N000:A000',\n              'term': 'Hashes/Hash/Simple_Hash_Value',\n              'attribute': 'condition',\n              'value': u'Equals'},\n            { 'node_id': 'N001:L001:N000:A001',\n              'term': 'Hashes/Hash/Simple_Hash_Value',\n              'attribute': 'datatype',\n              'value': u'hexBinary'},\n            { 'node_id': 'N001:L001:N001',\n              'term': 'Hashes/Hash/Type',\n              'attribute': False,\n              'value': 'MD5'}\n          ]\n\n          { 'N000': { 'condition': 'Equals'},\n            'N001:L000:N000': { 'condition': 'Equals', 'datatype': 'hexBinary'},\n            'N001:L001:N000': { 'condition': 'Equals', 'datatype': 'hexBinary'},\n          }\n\n        \"\"\"\n\n        if not namespace_dict:\n            namespace_dict = {}\n\n\n\n        def node_id_gen(n):\n            \"\"\"\n            Given an integer, generate a fixed-length representation.\n\n            This is used for coding tree-node representations such\n            as N001:N005:N009 (9th child of 5th child of 1st child).\n\n            Currently, we use three digits, i.e., we get problems\n            if we import stuff with more than 1000 children in a node.\n\n            \"\"\"\n\n            return \"%s%04d\" % (n[0], n[1])\n\n\n\n        RE_ELEMENT_MATCHER = re.compile(r\"[^@_].*\")\n\n\n        def _flatten(self, result_list, attr_dict, elt_names, prefix):\n            \"\"\"\n            Flatten a Dingo dictionary representation of an infomration object into a list\n            of fact-term/value pairs and associated information about tree structure (in node_id)\n            and XML attributes.\n\n            Internal function for recursive calls.\n\n            \"\"\"\n\n            if '@@ns' in self.keys():\n                current_namespace = (namespace_dict.get(self.get('@@ns'),None),self.get('@@ns'))\n            else:\n                current_namespace = (None,None)\n\n            attributes = filter(lambda x: x[0] == '@', self.keys())\n\n            node_id = ':'.join(map(node_id_gen, prefix))\n            for attribute in attributes:\n                if node_id not in attr_dict.keys():\n                    attr_dict[node_id] = {attribute[1:]: self[attribute]}\n                else:\n                    attr_dict[node_id][attribute[1:]] = self[attribute]\n\n            elements = filter(lambda x: RE_ELEMENT_MATCHER.match(x), self)\n\n            fact_data = {'term': '/'.join(elt_names),\n                         'namespaces' : map(lambda x: x[2],prefix),\n                         'value': self.get('_value', ''),\n                         'attribute': False,\n                         'node_id': node_id}\n\n            if elements == [] or force_nonleaf_fact_predicate(fact_data,attributes):\n                logger.debug(\"Entered _VALUE branch for %s\" % self)\n                if '_value' in self.keys() or attributes != []:\n                    fact_data = {'term': '/'.join(elt_names),\n                                 'namespaces' : map(lambda x: x[2],prefix),\n                                 'value': self.get('_value', ''),\n                                 'attribute': False,\n                                 'node_id': node_id}\n                    result_list.append(fact_data)\n                    logger.debug(\"Appended fact %s\" % fact_data)\n            if elements != []:\n\n                counter = 0\n                for element in elements:\n                    logger.debug(\"Processing element %s\" % element)\n                    if type(self[element]) == type([]):\n                        logger.debug(\"Entered list branch for %s \" % self[element])\n\n                        for sub_elt in self[element]:\n                            current_namespace = (namespace_dict.get(sub_elt.get('@@ns'),None),sub_elt.get('@@ns'))\n\n                            (result_list, attr_dict) = _flatten(sub_elt,\n                                                                result_list=result_list,\n                                                                attr_dict=attr_dict,\n                                                                elt_names=elt_names + [element],\n                                                                prefix=prefix + [('L', counter,current_namespace)])\n\n\n                            counter += 1\n                    elif isinstance(self[element],basestring):\n                        logger.debug(\"Entered value branch for %s\" % self[element])\n                        # added this branch to deal with abbreviated dictionaries\n                        # that provide value directly rather then via '_value' key in dictionary\n\n                        # temporarily append namespace\n                        elt_names.append(element)\n\n                        fact_data = {'term': '/'.join(elt_names),\n                                     'namespaces' : map(lambda x: x[2],prefix + [('N',counter,current_namespace)]),\n                                     'value': self[element],\n                                     'attribute': False,\n                                     'node_id': \"%s\" % ':'.join(map(node_id_gen, prefix + [('N', counter,current_namespace)]))}\n                        logger.debug(\"Appended fact %s\" % fact_data)\n                        result_list.append(fact_data)\n                        # clean up namespace\n                        elt_names = elt_names[:-1]\n                        counter += 1\n                    else:\n                        logger.debug(\"Recursing for %s\" % self[element])\n                        current_namespace = (namespace_dict.get(self[element].get('@@ns'),None),self[element].get('@@ns'))\n\n                        (result_list, attr_dict) = _flatten(self[element],\n                                                            result_list=result_list,\n                                                            attr_dict=attr_dict,\n                                                            elt_names=elt_names + [element],\n                                                            prefix=prefix + [('N', counter,current_namespace)])\n                        counter += 1\n\n            attr_counter = 0\n            for attribute in attributes:\n                if node_id == '':\n                    attr_node_id = node_id_gen(('A', attr_counter,(None,None)))\n                else:\n                    attr_node_id = \"%s:%s\" % (node_id, node_id_gen(('A', attr_counter,(None,None))))\n                fact = {'term': \"%s\" % ('/'.join(elt_names)),\n                        'namespaces' : map(lambda x: x[2],prefix),\n                        'value': self[attribute],\n                        'node_id': attr_node_id,\n                        'attribute': attribute[1:],\n                        'number_of_attributed_elements': len(elements)}\n                if not attr_ignore_predicate(fact):\n                    del(fact['number_of_attributed_elements'])\n                    result_list.append(fact)\n                    logger.debug(\"Appended fact %s\" % fact)\n                    attr_counter += 1\n                else:\n                    logger.debug(\"Ignoring fact %s because of attr_ignore_list\" % fact)\n            result_list.sort(key=lambda x: x['node_id'])\n\n            return (result_list, attr_dict)\n\n        if not attr_ignore_predicate:\n            attr_ignore_predicate = (lambda x: '@' in x['attribute'])\n\n        if not force_nonleaf_fact_predicate:\n            force_nonleaf_fact_predicate = (lambda x,y: False)\n\n        return _flatten(self,result_list=[], attr_dict={}, elt_names=[], prefix=[])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_flat_repr(self,fact_list,include_node_id=False,no_attributes=False,track_namespaces=True,namespace_mapping=None):\n\n        if not namespace_mapping:\n            namespace_mapping = {}\n        name_counter = {'counter':0}\n\n\n\n        def make_ns_slug(name_counter,slug='n'):\n            while \"%s%s\" % (slug,name_counter['counter']) in namespace_mapping.values():\n                name_counter['counter']  = name_counter['counter']+1\n\n            return \"%s%s\" % (slug,name_counter['counter'])\n\n\n        if include_node_id or track_namespaces:\n            no_attributes=False\n\n        def node_id_unpack(n):\n            \"\"\"\n            Given a node_id, unpack it into list-signifier\n            (if existing) and position information\n            \"\"\"\n            return (n[0],int(n[1:]))\n\n        fact_list.sort(key=lambda x : x['node_id'])\n\n        result = self\n        for fact in fact_list:\n\n            current_ns_slug = {-1:None}\n            fact_path = fact['term'].split('/')\n            del(fact['term'])\n            if fact.get('attribute'):\n                if fact_path == [\"\"]:\n                    fact_path = []\n                fact_path.append('@%s' % fact['attribute'])\n\n                del(fact['attribute'])\n            node_path = fact['node_id'].split(':')\n            del(fact['node_id'])\n\n\n            if '@@namespace_map' in fact.keys():\n                namespace_map = fact['@@namespace_map']\n                del(fact['@@namespace_map'])\n            else:\n                namespace_map = None\n\n\n\n            walker = result\n            walker_parent=None\n            #logger.debug(fact)\n\n            for i in range(0,len(node_path)):\n                namespace_slug=None\n                if track_namespaces and namespace_map:\n                    #print namespace_map.namespaces_thru.get(position=i).namespace.uri\n                    try:\n                        namespace = namespace_map.namespaces_thru.get(position=i).namespace.uri\n                    except:\n                        namespace = None\n                    if namespace:\n                        if not namespace in namespace_mapping:\n                            namespace_slug = make_ns_slug(name_counter)\n\n                            namespace_mapping[namespace] = namespace_slug\n                        else:\n                            namespace_slug= namespace_mapping[namespace]\n\n                current_ns_slug[i] = namespace_slug\n                #if not current_ns_slug:\n                #    current_ns_slug = namespace_slug\n\n                (node_kind,counter) = node_id_unpack(node_path[i])\n                element = fact_path[i]\n                node_id = ':'.join(node_path[0:i+1])\n\n                if no_attributes and i == len(node_path)-1 and node_kind== 'A':\n                    continue\n\n                if not (element in walker.keys()):\n\n                    if node_kind == 'L':\n                        walker[element] = []\n                        child_dict = DingoObjDict()\n                        if include_node_id:\n                            child_dict['@@node_id'] = node_id\n                        if namespace_slug and current_ns_slug[i] != current_ns_slug[i-1]:\n                            child_dict['@@ns'] = current_ns_slug[i]\n                            #child_dict['@@ns'] = fact.get('namespace_map').\n                        walker[element].append(child_dict)\n                        walker_parent = walker\n                        walker = walker[element][0]\n                    elif node_kind == 'N':\n                        child_dict = DingoObjDict()\n                        if include_node_id:\n                            child_dict['@@node_id'] = node_id\n                        if namespace_slug and current_ns_slug[i] != current_ns_slug[i-1]:\n                            child_dict['@@ns'] = current_ns_slug[i]\n\n                        walker[element] = child_dict\n                        walker_parent = walker\n                        walker = walker[element]\n\n                else:\n\n                    if node_kind == 'L':\n\n                        if len(walker[element]) == counter:\n                            next_item = DingoObjDict()\n                            if include_node_id:\n                                next_item['@@node_id'] = node_id\n                            walker[element].append(next_item)\n                            walker_parent=walker\n                            walker=walker[element][counter]# next_item\n                        elif len(walker[element]) > counter:\n                            walker_parent=walker\n                            walker = walker[element][counter]\n                        else:\n                            # TODO: introduce error logging\n                            logger.error(\"ERROR: Structural problem for %s, counter %s and node_id %s\" % (element,counter,node_id))\n                            pass\n\n                    else:\n                        walker_parent=walker\n                        walker=walker[element]\n            if node_kind == 'A':\n\n                if no_attributes:\n                    continue\n                if len(fact['value_list']) == 1:\n                    value = fact['value_list'][0]\n                else:\n                    value = fact['value_list']\n                if include_node_id:\n                    walker[element] = {'@@node_id' : node_id,\n                                       '_value' : value}\n                else:\n                    walker[element] = value\n            else:\n                if len(fact['value_list']) == 1:\n                    if fact['value_list'][0] != '':\n                        if no_attributes:\n                            walker_parent[element] = fact['value_list'][0]\n                        else:\n                            walker['_value'] = fact['value_list'][0]\n                else:\n                    if no_attributes:\n                        walker_parent[element] = fact['value_list']\n                    else:\n                        walker['_value'] = fact['value_list']\n                if include_node_id:\n                    walker['@@node_id'] = node_id\n\n                del(fact['value_list'])\n\n\n                if not no_attributes:\n                    for key in fact:\n                        if fact[key]:\n                            walker[key] = fact[key]\n\n        if track_namespaces:\n            return namespace_mapping", "response": "Convert a flat representation of information into a dictionary representation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_dir_abspath(path):\n    return map(lambda f: os.path.join(path, f), os.listdir(path))", "response": "Return a list absolute file paths."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the uuid number for the digest", "response": "def get_digest(self):\n        \"\"\" return int uuid number for digest\n\n        :rtype: int\n        :return: digest\n        \"\"\"\n        a, b = struct.unpack('>QQ', self.digest)\n        return (a << 64) | b"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_blob_hash(self, h=hashlib.md5):\n        assert callable(h)\n        return h(self.get_blob_data())", "response": "get hash instance of blob content"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget asset version content using pg large object streams", "response": "def get_blob_data(self, tag_target='asset', force=False):\n        \"\"\"\n        get asset version content using pg large object streams\n\n        :param bool force: False by default, forces get content from database\n            instead of using cached value\n        :rtype: str\n        :return: content in raw format\n        \"\"\"\n        if hasattr(self, '_blob_data') and not force:\n            return self._blob_data\n\n        if six.PY2:\n            self._blob_data = six.binary_type('')\n        elif six.PY3:\n            self._blob_data = six.binary_type('', encoding='ascii')\n        asset_contents = self.contents.filter(tag=tag_target)\n        for asset_content in asset_contents:\n            blobs = asset_content.stream.get_blobs()\n            for blob in blobs:\n                self._blob_data += six.binary_type(blob.data)\n        return self._blob_data"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes the actions on the given object.", "response": "def run(self, obj):\n        \"\"\"Execute the actions on the given object.\n\n        :param obj: The object that the action should process\n        :type obj: :class:`object`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        for d in self.depsuccess:\n            if d.status.value != ActionStatus.SUCCESS:\n                self.status = ActionStatus(ActionStatus.SKIPPED, \"Skipped because action \\\"%s\\\" did not succeed.\" % d.name)\n                return\n        for d in self.depfail:\n            if d.status.value == ActionStatus.SUCCESS:\n                self.status = ActionStatus(ActionStatus.SKIPPED, \"Skipped because action \\\"%s\\\" did not fail.\" % d.name)\n                return\n        try:\n            self.status = self.actionfunc(obj)\n            if not isinstance(self.status, ActionStatus):\n                raise TypeError(\"Expected action function %s to return a ActionStatus\" % self.actionfunc)\n        except:\n            self.status = ActionStatus(ActionStatus.ERROR, \"Unexpected Error.\", traceback.format_exc())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the global status that summerizes all actions", "response": "def status(self, ):\n        \"\"\"The global status that summerizes all actions\n\n        The status will be calculated in the following order:\n\n          If any error occured, the status will be :data:`ActionStatus.ERROR`.\n          If any failure occured, the status will be :data:`ActionStatus.FAILURE`.\n          If all actions were successful or skipped, the status will be :data:`ActonStatus.SUCCESS`\n\n        :returns: a status object that represents a summary of all actions\n        :rtype: :class:`ActionStatus`\n        :raises: None\n        \"\"\"\n        status = ActionStatus(ActionStatus.SUCCESS, \"All actions succeeded.\")\n        for a in self.actions:\n            if a.status.value == ActionStatus.ERROR:\n                status = ActionStatus(ActionStatus.ERROR, \"Error: action \\\"%s\\\" raised an error!\" % a.name, a.status.traceback)\n                break\n            if a.status.value == ActionStatus.FAILURE:\n                status = ActionStatus(ActionStatus.FAILURE, \"Action(s) failed!\")\n        return status"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats an explanation as a string in the format that is used in the message - introspection module.", "response": "def format_explanation(explanation, original_msg=None):\n    \"\"\"This formats an explanation\n\n    Normally all embedded newlines are escaped, however there are\n    three exceptions: \\n{, \\n} and \\n~.  The first two are intended\n    cover nested explanations, see function and attribute explanations\n    for examples (.visit_Call(), visit_Attribute()).  The last one is\n    for when one explanation needs to span multiple lines, e.g. when\n    displaying diffs.\n    \"\"\"\n    if not conf.is_message_introspection_enabled() and original_msg:\n        return original_msg\n    explanation = ecu(explanation)\n    lines = _split_explanation(explanation)\n    result = _format_lines(lines)\n    return u('\\n').join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _split_explanation(explanation):\n    raw_lines = (explanation or u('')).split('\\n')\n    lines = [raw_lines[0]]\n    for l in raw_lines[1:]:\n        if l and l[0] in ['{', '}', '~', '>']:\n            lines.append(l)\n        else:\n            lines[-1] += '\\\\n' + l\n    return lines", "response": "Return a list of individual lines in the explanation"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _format_lines(lines):\n    result = lines[:1]\n    stack = [0]\n    stackcnt = [0]\n    for line in lines[1:]:\n        if line.startswith('{'):\n            if stackcnt[-1]:\n                s = u('and   ')\n            else:\n                s = u('where ')\n            stack.append(len(result))\n            stackcnt[-1] += 1\n            stackcnt.append(0)\n            result.append(u(' +') + u('  ')*(len(stack)-1) + s + line[1:])\n        elif line.startswith('}'):\n            stack.pop()\n            stackcnt.pop()\n            result[stack[-1]] += line[1:]\n        else:\n            assert line[0] in ['~', '>']\n            stack[-1] += 1\n            indent = len(stack) if line.startswith('~') else len(stack) - 1\n            result.append(u('  ')*indent + line[1:])\n    assert len(stack) == 1\n    return result", "response": "Format the individual lines in a mini\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assertrepr_compare(config, op, left, right):\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = py.io.saferepr(left, maxsize=int(width//2))\n    right_repr = py.io.saferepr(right, maxsize=width-len(left_repr))\n\n    summary = u('%s %s %s') % (ecu(left_repr), op, ecu(right_repr))\n\n    issequence = lambda x: (isinstance(x, (list, tuple, Sequence)) and\n                            not isinstance(x, basestring))\n    istext = lambda x: isinstance(x, basestring)\n    isdict = lambda x: isinstance(x, dict)\n    isset = lambda x: isinstance(x, (set, frozenset))\n\n    def isiterable(obj):\n        try:\n            iter(obj)\n            return not istext(obj)\n        except TypeError:\n            return False\n\n    verbose = config.getoption('verbose')\n    explanation = None\n    try:\n        if op == '==':\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == 'not in':\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except Exception:\n        _logger.exception(\"dessert: representation of details failed.  \"\n                          \"Probably an object has a faulty __repr__.\")\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation", "response": "Return specialised explanations for some operators and operands"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _diff_text(left, right, verbose=False):\n    from difflib import ndiff\n    explanation = []\n    if isinstance(left, py.builtin.bytes):\n        left = u(repr(left)[1:-1]).replace(r'\\n', '\\n')\n    if isinstance(right, py.builtin.bytes):\n        right = u(repr(right)[1:-1]).replace(r'\\n', '\\n')\n    if not verbose:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10                 # Provide some context\n            explanation = [u('Skipping %s identical leading '\n                             'characters in diff, use -v to show') % i]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10     # Provide some context\n                explanation += [u('Skipping %s identical trailing '\n                                  'characters in diff, use -v to show') % i]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    explanation += [line.strip('\\n')\n                    for line in ndiff(left.splitlines(keepends),\n                                      right.splitlines(keepends))]\n    return explanation", "response": "Return the explanation for the diff between two text or bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef with_rule(self, rule):\n        self.rules = self.rules if self.rules != None else []\n        self.rules.append(rule)\n        return self", "response": "Adds a validation rule to this schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms validation on a given value against the schema and the validation rules.", "response": "def _perform_validation(self, path, value, results):\n        \"\"\"\n        Validates a given value against the schema and configured validation rules.\n\n        :param path: a dot notation path to the value.\n\n        :param value: a value to be validated.\n\n        :param results: a list with validation results to add new results.\n        \"\"\"\n        name = path if path != None else \"value\"\n\n        if value == None:\n            # Check for required values\n            if self.required:\n                results.append(\n                    ValidationResult(\n                        path,\n                        ValidationResultType.Error,\n                        \"VALUE_IS_NULL\",\n                        name + \" cannot be null\",\n                        \"NOT NULL\",\n                        None\n                    )\n                )\n        else:\n            value = ObjectReader.get_value(value)\n\n            # Check validation rules\n            if self.rules != None:\n                for rule in self.rules:\n                    rule.validate(path, self, value, results)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _perform_type_validation(self, path, typ, value, results):\n        # If type it not defined then skip\n        if typ == None:\n            return\n\n        # Perform validation against schema\n        if isinstance(typ, Schema):\n            schema = typ\n            schema._perform_validation(path, value, results)\n            return\n\n        # If value is null then skip\n        value = ObjectReader.get_value(value)\n        if value == None:\n            return\n\n        name = path if path != None else \"value\"\n        value_type = type(value)\n\n        # Match types\n        if TypeMatcher.match_type(typ, value_type):\n            return\n        \n        # Generate type mismatch error\n        results.append(\n            ValidationResult(\n                path,\n                ValidationResultType.Error,\n                \"TYPE_MISMATCH\",\n                name + \" type must be \" + self._type_to_string(typ) + \" but found \" + self._type_to_string(value_type),\n                typ,\n                value_type\n            )\n        )", "response": "Perform type validation against a given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_and_throw_exception(self, correlation_id, value, strict = False):\n        results = self.validate(value)\n        ValidationException.throw_exception_if_needed(correlation_id, results, strict)", "response": "Validates the given value and throws a ValidationException if errors were found."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _make_socket(cls, ip, port):\n    bound_socket = bind_sockets(port, address=ip)[0]\n    ip, port = bound_socket.getsockname()\n\n    if not ip or ip == '0.0.0.0':\n      ip = socket.gethostbyname(socket.gethostname())\n\n    return bound_socket, ip, port", "response": "Bind to a new socket."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstopping the context. This terminates all PIDs and closes all connections.", "response": "def stop(self):\n    \"\"\"Stops the context.  This terminates all PIDs and closes all connections.\"\"\"\n\n    log.info('Stopping %s' % self)\n\n    pids = list(self._processes)\n\n    # Clean up the context\n    for pid in pids:\n      self.terminate(pid)\n\n    while self._connections:\n      pid = next(iter(self._connections))\n      conn = self._connections.pop(pid, None)\n      if conn:\n        conn.close()\n\n    self.__loop.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef spawn(self, process):\n    self._assert_started()\n    process.bind(self)\n    self.http.mount_process(process)\n    self._processes[process.pid] = process\n    process.initialize()\n    return process.pid", "response": "Spawns a process and returns the pid of the process."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls a method on another process by its pid.", "response": "def dispatch(self, pid, method, *args):\n    \"\"\"Call a method on another process by its pid.\n\n    The method on the other process does not need to be installed with\n    ``Process.install``.  The call is serialized with all other calls on the\n    context's event loop.  The pid must be bound to this context.\n\n    This function returns immediately.\n\n    :param pid: The pid of the process to be called.\n    :type pid: :class:`PID`\n    :param method: The name of the method to be called.\n    :type method: ``str``\n    :return: Nothing\n    \"\"\"\n    self._assert_started()\n    self._assert_local_pid(pid)\n    function = self._get_dispatch_method(pid, method)\n    self.__loop.add_callback(function, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling a method on another process after a specified amount of time.", "response": "def delay(self, amount, pid, method, *args):\n    \"\"\"Call a method on another process after a specified delay.\n\n    This is equivalent to ``dispatch`` except with an additional amount of\n    time to wait prior to invoking the call.\n\n    This function returns immediately.\n\n    :param amount: The amount of time to wait in seconds before making the call.\n    :type amount: ``float`` or ``int``\n    :param pid: The pid of the process to be called.\n    :type pid: :class:`PID`\n    :param method: The name of the method to be called.\n    :type method: ``str``\n    :return: Nothing\n    \"\"\"\n    self._assert_started()\n    self._assert_local_pid(pid)\n    function = self._get_dispatch_method(pid, method)\n    self.__loop.add_timeout(self.__loop.time() + amount, function, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a message method from one process to another with an optional body.", "response": "def send(self, from_pid, to_pid, method, body=None):\n    \"\"\"Send a message method from one pid to another with an optional body.\n\n    Note: It is more idiomatic to send directly from a bound process rather than\n    calling send on the context.\n\n    If the destination pid is on the same context, the Context may skip the\n    wire and route directly to process itself.  ``from_pid`` must be bound\n    to this context.\n\n    This method returns immediately.\n\n    :param from_pid: The pid of the sending process.\n    :type from_pid: :class:`PID`\n    :param to_pid: The pid of the destination process.\n    :type to_pid: :class:`PID`\n    :param method: The method name of the destination process.\n    :type method: ``str``\n    :keyword body: Optional content to send along with the message.\n    :type body: ``bytes`` or None\n    :return: Nothing\n    \"\"\"\n\n    self._assert_started()\n    self._assert_local_pid(from_pid)\n\n    if self._is_local(to_pid):\n      local_method = self._get_local_mailbox(to_pid, method)\n      if local_method:\n        log.info('Doing local dispatch of %s => %s (method: %s)' % (from_pid, to_pid, local_method))\n        self.__loop.add_callback(local_method, from_pid, body or b'')\n        return\n      else:\n        # TODO(wickman) Consider failing hard if no local method is detected, otherwise we're\n        # just going to do a POST and have it dropped on the floor.\n        pass\n\n    request_data = encode_request(from_pid, to_pid, method, body=body)\n\n    log.info('Sending POST %s => %s (payload: %d bytes)' % (\n             from_pid, to_pid.as_url(method), len(request_data)))\n\n    def on_connect(stream):\n      log.info('Writing %s from %s to %s' % (len(request_data), from_pid, to_pid))\n      stream.write(request_data)\n      log.info('Wrote %s from %s to %s' % (len(request_data), from_pid, to_pid))\n\n    self.__loop.add_callback(self._maybe_connect, to_pid, on_connect)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef link(self, pid, to):\n\n    self._assert_started()\n\n    def really_link():\n      self._links[pid].add(to)\n      log.info('Added link from %s to %s' % (pid, to))\n\n    def on_connect(stream):\n      really_link()\n\n    if self._is_local(pid):\n      really_link()\n    else:\n      self.__loop.add_callback(self._maybe_connect, to, on_connect)", "response": "Link a local process to a possibly remote process."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef terminate(self, pid):\n    self._assert_started()\n\n    log.info('Terminating %s' % pid)\n    process = self._processes.pop(pid, None)\n    if process:\n      log.info('Unmounting %s' % process)\n      self.http.unmount_process(process)\n    self.__erase_link(pid)", "response": "Terminate a process bound to this context."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _page_gen(self):\n        track = \"\"\n        for page in self.__pages__:\n            track += \"/{page}\".format(page=page)\n        return track", "response": "Generates The String for pages\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _query_gen(self):\n        return urlencode(self.__query__, safe=self.safe, querydelimiter=self.__querydelimiter__)", "response": "Generates The String for queries"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef page(self, *args):\n        for arg in args:\n            self.__pages__.append(arg)\n        return self", "response": "Adds pages to the internal list"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nqueries the database for the current set of items in the cache.", "response": "def query(self, listdelimiter=\"+\", safe=\"\", **kwargs):\n        \"\"\"\n        Url queries\n\n        :param listdelimiter: Specifies what list delimiter should be\n        :param safe: string that includes all the characters that should not be ignored\n\n        Kwargs (Since its a dictionary) are not ordered. You must call the\n        method again if you absolutely need one query\n        after another or vice versa.\n\n        \"\"\"\n        safe = safe if safe else self.safe\n        for arg in list(kwargs.keys()):\n            if (isinstance(kwargs[arg], list)\n                    or isinstance(kwargs[arg], tuple)\n                    or isinstance(kwargs[arg], set)):\n                items = [quote_plus(str(x), safe=safe) for x in kwargs[arg]]\n                self.__query__.update({arg: listdelimiter.join(items)})\n            else:\n                self.__query__.update({arg: kwargs.get(arg)})\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild the encoder computational graph for the given nodeOccurences.", "response": "def build(self):\n        \"\"\"\n        The encoder computational graph consists of four components:\n        (1) the input node                  `encoder_input`\n        (2) the embedding node              `encoder_embed`\n        (3) the recurrent (RNN) part        `encoder_rnn`\n        (4) the hidden state output         `encoder_hidden_state`\n        For convenience, we also construct the (un-compiled) Encoder training model:\n        (5) uncompiled model                `encoder_training_model`\n        \"\"\"\n        \n        # Grab hyperparameters from self.config:\n        hidden_dim = self.config['encoding-layer-width']\n        recurrent_unit = self.config['recurrent-unit-type']\n        bidirectional = False # self.config['encoding-layer-bidirectional']\n        vocab_size = self.data.vocab_size\n        embedding_dim = math.ceil(math.log(vocab_size, 2))    # self.config['embedding-dim']\n        input_length = self.data.properties['max-utterance-length'] + 1\n        \n        # Assemble the network components:\n        encoder_input = Input(shape=(None,))\n        encoder_embed = Embedding(vocab_size, embedding_dim, mask_zero=True)(encoder_input) #, input_length=input_length)(encoder_input)\n        # input of this Embedding() is  (None, input_length)\n        # output of this Embedding() is (None, input_length, embedding_dim)\n        encoder_rnn, encoder_hidden_state = None, None\n        \n        if recurrent_unit == 'lstm':\n            encoder_rnn = LSTM(hidden_dim, return_state=True)\n            encoder_output, encoder_state_h, encoder_state_c = encoder_rnn(encoder_embed)\n            # discard the encoder output, keeping only the hidden state\n            encoder_hidden_state = [encoder_state_h, encoder_state_c]\n        if recurrent_unit == 'gru':\n            encoder_rnn = GRU(hidden_dim, return_state=True)\n            encoder_output, encoder_hidden_state = encoder_rnn(encoder_embed)\n        else:\n            raise Exception('Invalid recurrent unit type: {}'.format(recurrent_unit))\n        \n        # make the RNN component bidirectional, if desired\n        if bidirectional:\n            encoder_rnn = Bidirectional(encoder_rnn, merge_mode='ave')\n        \n        # save the three Enccoder components as class state\n        self.encoder_input = encoder_input\n        self.encoder_embed = encoder_embed\n        self.encoder_rnn = encoder_rnn\n        self.encoder_hidden_state = encoder_hidden_state\n        \n        # finally, build the training model\n        self.encoder_training_model = Model(self.encoder_input, self.encoder_hidden_state)\n        \n        return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_nullable_string(value):\n        if value == None:\n            return None\n        if type(value) == datetime.date:\n            return value.isoformat()\n        if type(value) == datetime.datetime:\n            if value.tzinfo == None:\n                return value.isoformat() + \"Z\"\n            else:\n                return value.isoformat()\n\n        if type(value) == list:\n            builder = ''\n            for element in value:\n                if len(builder) > 0:\n                    builder = builder + \",\"\n                builder = builder + element\n            return builder.__str__()\n        return str(value)", "response": "Converts value into string or returns None when value is None."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_string_with_default(value, default_value):\n        result = StringConverter.to_nullable_string(value)\n        return result if result != None else default_value", "response": "Converts value into string or returns default when value is None."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compare(molecules, ensemble_lookup, options):\n\n    print(\" Analyzing differences ... \")\n    print('')\n    sort_order = classification.get_sort_order(molecules)\n\n    ensemble1 = sorted(ensemble_lookup.keys())[0]\n    ensemble2 = sorted(ensemble_lookup.keys())[1]\n\n    stats = {}\n    stats['header'] = [' ']\n    name = os.path.basename(ensemble1).replace('.csv', '')\n    stats['header'].append(name)\n    name = os.path.basename(ensemble2).replace('.csv', '')\n    stats['header'].append(name)\n    stats['header'].append('Difference')\n    stats['header'].append('95% CI')\n    stats['header'].append('p-value')\n\n    molecules1 = copy.deepcopy(molecules)\n    molecules2 = copy.deepcopy(molecules)\n\n    score_structure1 = classification.make_score_structure(molecules1, ensemble_lookup[ensemble1])\n    score_structure2 = classification.make_score_structure(molecules2, ensemble_lookup[ensemble2])\n\n    auc_structure_1 = classification.make_auc_structure(score_structure1)\n    auc_structure_2 = classification.make_auc_structure(score_structure2)\n\n    # calculate auc value differences\n    auc_diff = classification.calculate_auc_diff(auc_structure_1, auc_structure_2, sort_order)\n\n    stats['AUC'] = auc_diff\n\n    # calculate enrichment factor differences\n    fpfList = make_fpfList(options)\n    for fpf in fpfList:\n        fpf = float(fpf)\n        ef_structure1 = classification.make_ef_structure(score_structure1, fpf, sort_order)\n        ef_structure2 = classification.make_ef_structure(score_structure2, fpf, sort_order)\n\n        if ef_structure1 and ef_structure2:\n            ef_diff = classification.calculate_ef_diff(ef_structure1, ef_structure2, fpf)\n            title = 'E%s' % fpf\n            stats[title] = ef_diff\n\n    # write results summary\n    output.write_diff_summary(stats, options)\n\n    # write roc curves\n    if options.write_roc:\n        print(\" Writing ROC data ... \")\n        print('')\n        output.write_roc(auc_structure_1, ensemble1, options)\n        output.write_roc(auc_structure_2, ensemble2, options)\n\n    # plot\n    if options.plot:\n        print(\" Making plots ... \")\n        print('')\n        plotter(molecules, ensemble_lookup, options)", "response": "compare stuff in a single tree"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nevaluating a list of ensembles and return statistics and ROC plots if appropriate", "response": "def evaluate_list(molecules, ensemble_lookup, options):\n    \"\"\"\n    Evaluate a list of ensembles and return statistics and ROC plots if appropriate\n    \"\"\"\n\n    # create stats dictionaries to store results from each ensemble\n    stats = {}  # {file name : metric_List}\n\n    # print progress messages\n    if options.write_roc:\n        print(\" Determining virtual screening performance and writing ROC data ... \")\n        print('')\n    else:\n        print(\" Determining virtual screening performance ...\")\n        print('')\n\n    for filename in sorted(ensemble_lookup.keys()):\n        metric_List = calculate_metrics(molecules, ensemble_lookup, filename, options)\n        stats[filename] = metric_List\n\n    # write results summary\n    output.write_summary(stats, options, fw_type = None)\n\n    # plot\n    if options.plot:\n        print(\" Making plots ... \")\n        print\n        plotter(molecules, ensemble_lookup, options)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calculate_metrics(molecules, ensemble_lookup, filename, options):\n    metric_List = []    # [(auc, auclow, auchigh), (fpf, ef, eflow, efhigh), (fpf, ef, eflow, efhigh), ..., ]\n    sort_order = 'asc'\n\n    # set up the appropriate score_structure data\n    score_structure = classification.make_score_structure(molecules, ensemble_lookup[filename])\n\n    # calculate auc values\n    auc_structure = classification.make_auc_structure(score_structure)\n    auc = classification.calculate_auc(auc_structure, sort_order)\n    metric_List.append(auc)\n\n    # calculate enrichment factor values\n    for fpf in make_fpfList(options):\n        fpf = float(fpf)\n        ef_structure = classification.make_ef_structure(score_structure, fpf, sort_order)\n        if ef_structure:\n            ef = classification.calculate_ef(ef_structure, fpf, None, 'include_intervals')\n            metric_List.append(ef)\n\n    if options.write_roc:\n        output.write_roc(auc_structure, filename, options)\n\n    return metric_List", "response": "Calculates the virtual screening performance of the ensemble."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a list of fpf values for the object.", "response": "def make_fpfList(options):\n    \"\"\"\n    aggregate default fpf values and user-defined fpf values where enrichment factor calculations will be attempted.\n    :param options: SplitInput object\n    :return defaults: list includes default fpf values & unique user-defined values\n    \"\"\"\n\n    user_values = options.fpf\n\n    defaults = ['0.0001', '0.001', '0.01', '0.05']\n\n    if user_values:\n        for fpf in user_values:\n            if fpf not in defaults:\n                defaults.append(fpf)\n\n        defaults.sort()\n\n    return defaults"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if the ensembles are not equal", "response": "def error_check(options):\n    \"\"\"\n    Error check\n    :rtype : object\n    \"\"\"\n\n    compare = options.compare\n    ensemble_paths = options.ensemble_paths\n\n    if compare and len(ensemble_paths) > 2:\n        print(\"\\n Only 2 ensembles can be compared, {d} were specified\\n\".format(d=len(ensemble_paths)))\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the ROC curves for the specified molecules and the ensemble lookup.", "response": "def plotter(molecules, ensemble_lookup, options):\n    \"\"\"\n    plot ROC curves for ensembles in ensemble_lookup\n    :param molecules:\n    :param ensemble_lookup:\n    :param options:\n    :return:\n    \"\"\"\n\n    try:\n        import matplotlib\n\n        matplotlib.use('Agg')\n        import matplotlib.pyplot as plt\n    except ImportError:\n        print(\"\\n Plotting requires matplotlib to be installed\\n\")\n        sys.exit(1)\n\n    for ensemble in ensemble_lookup.keys():\n\n        # create figure\n        fig = plt.figure()\n\n        # create the queries subplot, the left subplot\n        # create the left hand subplot\n        ax1 = fig.add_subplot(121)\n\n        for query in sorted(ensemble_lookup[ensemble]):\n            query_list = []\n            query_list.append(query)\n            score_structure = classification.make_score_structure(molecules, query_list)\n            auc_structure = classification.make_auc_structure(score_structure)\n            tpf = []\n            fpf = []\n            for mol in auc_structure:\n                fpf.append(mol[4])\n                tpf.append(mol[5])\n\n            # add axis-labels and a title\n            ax1.set_xlabel('FPF')\n            ax1.set_ylabel('TPF')\n            title = 'query performance'\n            ax1.set_title(title)\n\n            # add plot data and labels for the legend\n            lbl = query\n            ax1.plot(fpf, tpf, lw=3, label=lbl)\n\n        # get legend handles and labels, then reverse their order\n        handles, labels = ax1.get_legend_handles_labels()\n        ax1.legend(handles[::-1], labels[::-1])\n\n        # add the legend\n        ax1.legend(handles, labels, loc='best')\n\n        # create the ensemble subplot, the right subplot\n        score_structure = classification.make_score_structure(molecules, ensemble_lookup[ensemble])\n        auc_structure = classification.make_auc_structure(score_structure)\n        tpf = []\n        fpf = []\n        for mol in auc_structure:\n            fpf.append(mol[4])\n            tpf.append(mol[5])\n\n        # create right hand subplot\n        ax2 = fig.add_subplot(122)\n\n        # add axis-labels and a title\n        ax2.set_xlabel('FPF')\n        ax2.set_ylabel('TPF')\n        title = 'ensemble performance'\n        ax2.set_title(title)\n\n        # add plot data and a label for the legend\n        lbl = 'ensemble'\n        ax2.plot(fpf, tpf, lw=3, label=lbl)\n\n        # get legend handles and labels, then reverse their order\n        handles, labels = ax2.get_legend_handles_labels()\n        ax2.legend(handles[::-1], labels[::-1])\n\n        # add the legend\n        ax2.legend(handles, labels, loc='best')\n\n        # save figure\n        figurename = options.outname + '_' + ensemble.replace('.csv', '') + '.pdf'\n        filename = os.path.join(os.getcwd(), figurename)\n        plt.savefig(filename, bbobx='tight', format='pdf')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a random Date in the range ['minYear', 'maxYear']. This method generate dates without time (or time set to 00:00:00) :param min_year: (optional) minimum range value :param max_year: max range value :return: a random Date value.", "response": "def next_date(min_year = None, max_year = None):\n        \"\"\"\n        Generates a random Date in the range ['minYear', 'maxYear'].\n        This method generate dates without time (or time set to 00:00:00)\n\n        :param min_year: (optional) minimum range value\n\n        :param max_year: max range value\n\n        :return: a random Date value.\n        \"\"\"\n        current_year = datetime.datetime.utcnow().year\n        min_year = min_year if min_year != None else current_year - RandomInteger.next_integer(10)\n        max_year = max_year if max_year != None else current_year\n\n        year = RandomInteger.next_integer(min_year, max_year)\n        month = RandomInteger.next_integer(1, 13)\n        day = RandomInteger.next_integer(1, 32)\n        \n        if month == 2:\n            day = min(28, day)\n        elif month in [4, 6, 9, 11]:\n            day = min(30, day)\n\n        return datetime.datetime(year, month, day, 0, 0, 0, 0, pytz.utc)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef next_datetime(min_year = None, max_year = None):\n        date = RandomDateTime.next_date(min_year, max_year).date()\n        time = RandomDateTime.next_time()\n        return datetime.datetime.combine(date, time)", "response": "This method generates a random Date and time value in the range [ min_year maxYear )."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates a Date value within specified range defined by the user.", "response": "def update_datetime(value, range = None):\n        \"\"\"\n        Updates (drifts) a Date value within specified range defined\n\n        :param value: a Date value to drift.\n\n        :param range: (optional) a range in milliseconds. Default: 10 days\n\n        :return: an updated DateTime value.\n        \"\"\"\n        range = range if range != None else 10\n        if range < 0:\n            return value\n        \n        days = RandomFloat.next_float(-range, range)\n\n        return value + datetime.timedelta(days)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a dict with context information for Sentry.", "response": "def _sentry_context_dict(context):\n    \"\"\"Create a dict with context information for Sentry.\"\"\"\n    d = {\n        \"function_name\": context.function_name,\n        \"function_version\": context.function_version,\n        \"invoked_function_arn\": context.invoked_function_arn,\n        \"memory_limit_in_mb\": context.memory_limit_in_mb,\n        \"aws_request_id\": context.aws_request_id,\n        \"log_group_name\": context.log_group_name,\n        \"cognito_identity_id\": context.identity.cognito_identity_id,\n        \"cognito_identity_pool_id\": context.identity.cognito_identity_pool_id}\n    for k, v in os.environ.items():\n        if k not in {\"AWS_SECURITY_TOKEN\", \"AWS_SESSION_TOKEN\",\n                     \"AWS_ACCESS_KEY_ID\", \"AWS_SECRET_ACCESS_KEY\"}:\n            # Do not log credentials\n            d[k] = v\n\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _setup_sentry_client(context):\n\n    # get_secret will be deprecated soon\n    dsn = os.environ.get(\"SENTRY_DSN\")\n    try:\n        client = raven.Client(dsn, sample_rate=SENTRY_SAMPLE_RATE)\n        client.user_context(_sentry_context_dict(context))\n        return client\n    except:\n        rlogger.error(\"Raven client error\", exc_info=True)\n        return None", "response": "Produce and configure the sentry client."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndelivering errors to error stream.", "response": "def _deliver_errored_events(errstream, recs):\n    \"\"\"Deliver errors to error stream.\"\"\"\n    rlogger.info(\"Going to handle %s failed events\", len(recs))\n    rlogger.info(\n        \"First failed event: %s\", json.dumps(recs[0], indent=4))\n\n    kinesis_stream = errstream.get(\"kinesis_stream\")\n    randomkey = str(uuid.uuid4())\n    if kinesis_stream:\n        send_to_kinesis_stream(\n            recs,\n            kinesis_stream,\n            partition_key=errstream.get(\"partition_key\", randomkey))\n        rlogger.info(\"Sent errors to Kinesis stream '%s'\", errstream)\n\n    delivery_stream = errstream.get(\"firehose_delivery_stream\")\n    if delivery_stream:\n        send_to_delivery_stream(errevents, delivery_stream)\n        rlogger.info(\"Sent error payload to Firehose delivery stream '%s'\",\n                     delivery_stream)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_records(event):\n    try:\n        recs, _ = unpack_kinesis_event(event, deserializer=None)\n    except KeyError:\n        # If not a Kinesis event, just unpack the records\n        recs = event[\"Records\"]\n    return recs", "response": "Get records from an AWS Lambda trigger event."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rgb_to_hex(rgba):\n    rgba = rgba.split('/')\n    hex_value = '#' + rgba[0][:2] + rgba[1][:2] + rgba[2][:2]\n    return hex_value", "response": "Converts rgb value to hex value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert hex value to rgb value", "response": "def hex_to_rgb(hex_value):\n    \"\"\"\n    expects: hex value, ex: #ffffff\n    returns: rgb value, ex: ff00/ff00/ff00\n    \"\"\"\n    if '#' in hex_value:\n        hex_value = hex_value.replace('#', '')\n    if len(hex_value) < 6:\n        return '0000/0000/0000'\n    r = hex_value[:2]\n    g = hex_value[2:4]\n    b = hex_value[4:]\n    return r + '00/' + g + '00/' + b + '00'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decimal_to_alpha(dec):\n    dec /= 100.0\n    alpha =  hex(int(dec*65535))[2:]\n    while len(alpha) < 4:\n        alpha = '0' + alpha\n    return alpha", "response": "Converts decimal value to alpha value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef format_index(prefix, timestamp, sep='-'):\n        tz_info = tz.tzutc()\n\n        # ex. logstash-other-2017.05.09\n        return \"{prefix}{sep}{date}\".format(\n            prefix=prefix, sep=sep, date=datetime.fromtimestamp(timestamp, tz=tz_info).strftime('%Y.%m.%d'))", "response": "format_index - Format the logstash index"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef format_timestamp(timestamp):\n        tz_info = tz.tzutc()\n        return datetime.fromtimestamp(timestamp, tz=tz_info).strftime(\"%Y-%m-%dT%H:%M:%S.000Z\")", "response": "Format the UTC timestamp for Elasticsearch\n        eg. 2014 - 07 - 09T08 : 37 : 18.000Z"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform the search and return raw rows", "response": "def _search(self, query, fields=None, limit=50000, sampling=None):\n        \"\"\"\n        Perform the search and return raw rows\n\n        :type query object\n        :type fields list[str] or None\n        :type limit int\n        :type sampling int or None\n\n        :arg sampling: Percentage of results to be returned (0,100)\n\n        :rtype: list\n        \"\"\"\n        body = {\n            \"query\": {\n                \"bool\": {\n                    \"must\": [\n                        query\n                    ]\n                }\n            }\n        }\n\n        # @see https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-source-filtering.html\n        if fields:\n            body['_source'] = {\n                \"includes\": fields\n            }\n\n        # add @timestamp range\n        # @see http://stackoverflow.com/questions/40996266/elasticsearch-5-1-unknown-key-for-a-start-object-in-filters\n        # @see https://discuss.elastic.co/t/elasticsearch-watcher-error-for-range-query/70347/2\n        body['query']['bool']['must'].append(self._get_timestamp_filer())\n\n        # sample the results if needed\n        if sampling is not None:\n            body['query']['bool']['must'].append({\n                'script': {\n                    'script': {\n                        'lang': 'painless',\n                        'source': \"Math.abs(doc['_id'].value.hashCode()) % 100 < params.sampling\",\n                        'params': {\n                            'sampling': sampling\n                        }\n                    }\n                }\n            })\n\n        self._logger.debug(\"Running {} query (limit set to {:d})\".format(json.dumps(body), body.get('size', 0)))\n\n        # use Scroll API to be able to fetch more than 10k results and prevent \"search_phase_execution_exception\":\n        # \"Result window is too large, from + size must be less than or equal to: [10000] but was [500000].\n        # See the scroll api for a more efficient way to request large data sets.\"\n        #\n        # @see http://elasticsearch-py.readthedocs.io/en/master/helpers.html#scan\n        rows = scan(\n            client=self._es,\n            clear_scroll=False,  # True causes \"403 Forbidden: You don't have access to this resource\"\n            index=self._index,\n            query=body,\n            sort=[\"_doc\"],  # return the next batch of results from every shard that still has results to return.\n            size=self._batch_size,  # batch size\n        )\n\n        # get only requested amount of entries and cast them to a list\n        rows = islice(rows, 0, limit)\n        rows = [entry['_source'] for entry in rows]  # get data\n\n        self._logger.info(\"{:d} rows returned\".format(len(rows)))\n        return rows"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning raw rows that match given query", "response": "def get_rows(self, match, fields=None, limit=10, sampling=None):\n        \"\"\"\n        Returns raw rows that matches given query\n\n        :arg match: query to be run against Kibana log messages (ex. {\"@message\": \"Foo Bar DB queries\"})\n        :type fields list[str] or None\n        :arg limit: the number of results (defaults to 10)\n        :type sampling int or None\n        :arg sampling: Percentage of results to be returned (0,100)\n        \"\"\"\n        query = {\n            \"match\": match,\n        }\n\n        return self._search(query, fields, limit, sampling)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef query_by_string(self, query, fields=None, limit=10, sampling=None):\n        query = {\n            \"query_string\": {\n                \"query\": query,\n            }\n        }\n\n        return self._search(query, fields, limit, sampling)", "response": "Query the Kibana log messages by a given query string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning number of matching entries in the cache", "response": "def count(self, query):\n        \"\"\"\n        Returns number of matching entries\n\n        :type query str\n        :rtype: int\n        \"\"\"\n        body = {\n            \"query\": {\n                \"bool\": {\n                    \"must\": [{\n                        \"query_string\": {\n                            \"query\": query,\n                        }\n                    }]\n                }\n            }\n        }\n\n        body['query']['bool']['must'].append(self._get_timestamp_filer())\n\n        return self._es.count(index=self._index, body=body).get('count')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nqueries the cache by a given SQL query", "response": "def query_by_sql(self, sql):\n        \"\"\"\n        Returns entries matching given SQL query\n\n        :type sql str\n        :rtype: list[dict]\n        \"\"\"\n        # https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-rest.html\n        # https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-syntax-select.html\n        body = {'query': sql}\n\n        resp = self._es.transport.perform_request('POST', '/_xpack/sql', params={'format': 'json'}, body=body)\n\n        # build key-value dictionary for each row to match results returned by query_by_string\n        columns = [column['name'] for column in resp.get('columns')]\n\n        return [dict(zip(columns, row)) for row in resp.get('rows')]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_aggregations(self, query, group_by, stats_field, percents=(50, 95, 99, 99.9), size=100):\n        body = {\n            \"query\": {\n                \"bool\": {\n                    \"must\": [{\n                        \"query_string\": {\n                            \"query\": query,\n                        },\n                    }]\n                },\n            },\n            \"aggregations\": {\n                \"group_by_agg\": {\n                    \"terms\": {\n                        \"field\": group_by,\n                        \"size\": size,  # how many term buckets should be returned out of the overall terms list\n                    },\n                    \"aggregations\": {\n                        \"field_stats\": {\n                            \"percentiles\": {\n                                \"field\": stats_field,\n                                \"percents\": percents\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        # add @timestamp range\n        body['query']['bool']['must'].append(self._get_timestamp_filer())\n\n        self._logger.info(\"Getting aggregations for %s field when grouped by %s\", group_by, stats_field)\n\n        res = self._es.search(\n            body=body,\n            index=self._index,\n            size=0,  # we don need any rows from the index, stats is all we need here\n        )\n\n        # print(json.dumps(res, indent=True))\n\n        aggs = {}\n\n        \"\"\"\n        bucket = {\n            \"field_stats\": {\n                \"values\": {\n                    \"95.0\": 20.99858477419025,\n                    \"99.0\": 67.0506954238478,\n                    \"50.0\": 1.0,\n                    \"99.9\": 146.3865495436944\n                }\n            },\n            \"key\": \"Wikia\\\\Service\\\\Gateway\\\\ConsulUrlProvider:getUrl\",\n            \"doc_count\": 8912859\n        }\n        \"\"\"\n\n        for bucket in res['aggregations']['group_by_agg']['buckets']:\n            entry = {\n                \"count\": bucket['doc_count']\n            }\n            entry.update(bucket['field_stats']['values'])\n\n            aggs[bucket['key']] = entry\n\n        return aggs", "response": "Returns the aggregations for a given query"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extract(self, pos, width):\n        pos = operator.index(pos)\n        width = operator.index(width)\n        if width < 0:\n            raise ValueError('width must not be negative')\n        if pos < 0:\n            raise ValueError('extracting out of range')\n        return BinWord(width, self >> pos, trunc=True)", "response": "Extracts a subword with a given width starting from a given bit position."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef deposit(self, pos, val):\n        if not isinstance(val, BinWord):\n            raise TypeError('deposit needs a BinWord')\n        pos = operator.index(pos)\n        if pos < 0:\n            raise ValueError('depositing out of range')\n        res = self\n        res &= ~(val.mask << pos)\n        res |= val.to_uint() << pos\n        return res", "response": "Returns a copy of this BinInt with a given word deposited by val at a given position."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert BLAST alignment into a new or old CIGAR line", "response": "def blast_to_cigar(query_seq, match_seq, subject_seq, cigar_age='new'):\n    \"\"\"converts BLAST alignment into a old or new CIGAR line\n\n    Args:\n        query_seq (str): Aligned portion of query sequence\n\n        match_seq (str): Alignment sequence\n\n        subject_seq (str): Aligned portion of subject/reference sequence\n\n        cigar_age (str): ['old', 'new'] CIGAR format to use, new is highly\n            detailed while old is fairly minimalistic\n\n    Returns:\n        str: CIGAR string\n\n    Raises:\n        ValueError: If query_seq, match_seq, and match_seq not same length\n\n    Examples:\n        >>> query = 'AAGGG--CCTTGTA'\n        >>> subject = 'AAGCCTTCCAGGTA'\n        >>> alignment_old = '|||||  |||||||'\n        >>> alignment_new = 'AAG++  CC++GTA'\n        >>> blast_to_cigar(query, alignment_new, subject)\n        3=2X2D2=2X3=\n        >>> blast_to_cigar(query, alignment_old, subject, cigar_age='old')\n        5M2D7M\n    \"\"\"\n\n    if not len(query_seq) == len(match_seq) \\\n            or not len(query_seq) == len(subject_seq) \\\n            or not len(subject_seq) == len(match_seq):\n        raise ValueError('query_seq, match_seq, and subject_seq not same '\n                         'lengths.')\n\n    # Translate XML alignment to CIGAR characters\n    cigar_line_raw = []\n    for query, match, subject in zip(query_seq, match_seq, subject_seq):\n        if query == '-':  # Deletion\n            cigar_line_raw.append('D')\n            continue\n        elif subject == '-':  # Insertion\n            cigar_line_raw.append('I')\n            continue\n        elif match == '+' or match == '|' or match.isalpha():  # Match\n            if match != '+' and cigar_age == 'new':  # Positive match\n                cigar_line_raw.append('=')\n                continue\n            elif match == '+' and cigar_age == 'new':  # Mismatch\n                cigar_line_raw.append('X')\n                continue\n            else:\n                cigar_line_raw.append('M')\n                continue\n        elif cigar_age == 'new':\n            cigar_line_raw.append('X')\n            continue\n        else:\n            cigar_line_raw.append('M')\n\n    # Replace repeat characters with numbers\n    cigar_line = []\n    last_position = ''\n    repeats = 1\n    cigar_len = len(cigar_line_raw)\n    for letter in enumerate(cigar_line_raw):\n        if letter[1] == last_position:\n            repeats += 1\n        else:\n            if repeats != 1:\n                cigar_line.append(str(repeats))\n                repeats = 1\n            cigar_line.append(last_position)\n        if letter[0] == cigar_len - 1:\n            if repeats != 1:\n                cigar_line.append(str(repeats))\n                repeats = 1\n            cigar_line.append(letter[1])\n        last_position = letter[1]\n\n    return ''.join(cigar_line)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove all non - digit and non - x characters from given ISBN string.", "response": "def _clean_isbn(isbn):\n    \"\"\"\n    Remove all non-digit and non \"x\" characters from given string.\n\n    Args:\n        isbn (str): isbn string, which will be cleaned.\n\n    Returns:\n        list: array of numbers (if \"x\" is found, it is converted to 10).\n    \"\"\"\n    if isinstance(isbn, basestring):\n        isbn = list(isbn.lower())\n\n        # filter digits and \"x\"\n        isbn = filter(lambda x: x.isdigit() or x == \"x\", isbn)\n\n    # convert ISBN to numbers\n    return map(lambda x: 10 if x == \"x\" else int(x), isbn)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _isbn_cleaner(fn):\n    @wraps(fn)\n    def wrapper(isbn):\n        return fn(_clean_isbn(isbn))\n\n    return wrapper", "response": "Decorator for calling other functions that need to clean the ISBN string from garbage and return list of digits."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns last checksum digit for given ISBN number.", "response": "def get_isbn13_checksum(isbn):\n    \"\"\"\n    Args:\n        isbn (str/list): ISBN number as string or list of digits.\n\n    Warning:\n        Function expects that `isbn` is only 12 digits long.\n\n    Returns:\n        int: Last checksum digit for given `isbn`.\n    \"\"\"\n    multipliers = map(lambda x: int(x), list(\"13\" * 6))\n\n    rest = sum([i * x for i, x in zip(multipliers, isbn)]) % 10\n\n    if rest == 0:\n        return rest\n\n    return 10 - rest"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates given ISBN number.", "response": "def is_valid_isbn(isbn):\n    \"\"\"\n    Validate given `isbn`. Wrapper for :func:`is_isbn10_valid`/\n    :func:`is_isbn13_valid`.\n\n    Args:\n        isbn (str/list): ISBN number as string or list of digits.\n\n    Note:\n        Function doesn't require `isbn` type to be specified (it can be both\n        10/13 isbn's versions).\n\n    Returns:\n        bool: ``True`` if ISBN is valid.\n    \"\"\"\n    length = len(isbn)\n\n    if length == 10:\n        return is_isbn10_valid(isbn)\n    elif length == 13:\n        return is_isbn13_valid(isbn)\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting an anillo function based handler in a wsgi compiliant application function.", "response": "def application(handler, adapter_cls=WerkzeugAdapter):\n    \"\"\"Converts an anillo function based handler in a\n    wsgi compiliant application function.\n\n    :param adapter_cls: the wsgi adapter implementation (default: wekrzeug)\n    :returns: wsgi function\n    :rtype: callable\n    \"\"\"\n    adapter = adapter_cls()\n\n    def wrapper(environ, start_response):\n        request = adapter.to_request(environ)\n        response = handler(request)\n        response_func = adapter.from_response(response)\n        return response_func(environ, start_response)\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wrap_async(func):\n    @functools.wraps(func)\n    def wrapped(*args, **kwargs):\n        fut = asyncio.ensure_future(func(*args, **kwargs))\n        cur = greenlet.getcurrent()\n        def callback(fut):\n            try:\n                cur.switch(fut.result())\n            except BaseException as e:\n                cur.throw(e)\n        fut.add_done_callback(callback)\n        return cur.parent.switch()\n    return wrapped", "response": "Wraps an asynchronous function into a synchronous function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wrap_sync(func):\n    @functools.wraps(func)\n    def wrapped(*args, **kwargs):\n        fut = asyncio.Future()\n        def green():\n            try:\n                fut.set_result(func(*args, **kwargs))\n            except BaseException as e:\n                fut.set_exception(e)\n        greenlet.greenlet(green).switch()\n        return fut\n    return wrapped", "response": "Wraps a synchronous function into an asynchronous function."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwaits for clients to connect and service them", "response": "def Run(self):\n        \"\"\"\n        Wait for clients to connect and service them\n\n        :returns: None\n        \"\"\"\n\n        while True:\n\n            try:\n                events = self.poller.poll()\n            except KeyboardInterrupt:\n                self.context.destroy()\n                sys.exit()\n\n            self.Handle_Events(events)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Handle_Events(self, events):\n        for e in events:\n\n            sock = e[0]\n            event_type = e[1]\n\n            if event_type == zmq.POLLIN:\n                msg = sock.recv()\n                reply = self.Handle_Receive(msg)\n                sock.send(reply)\n            elif event_type == zmq.POLLOUT:\n                pass  # FIXME -- handle this correctly\n            elif event_type == zmq.POLLERR:\n                pass  # FIXME -- handle this correctly\n            else:\n                pass", "response": "Handle events from poll and poll."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Handle_Receive(self, msg):\n\n        msg = self.Check_Message(msg)\n        msg_type = msg['type']\n\n        f_name = \"Handle_{0}\".format(msg_type)\n        try:\n            f = getattr(self, f_name)\n        except AttributeError:\n            f = self.Handle_ERROR(msg)\n        reply = f(msg)\n\n        return reply", "response": "Handle a received message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Handle_Search(self, msg):\n\n        search_term = msg['object']['searchTerm']\n        results = self.db.searchForItem(search_term)\n\n        reply = {\"status\": \"OK\",\n                 \"type\": \"search\",\n                 \"object\": {\n                           \"received search\": msg['object']['searchTerm'],\n                           \"results\": results}\n                 }\n\n        return json.dumps(reply)", "response": "Handle a search.\n\n        :param msg: the received search\n        :type msg: dict\n        :returns: The message to reply with\n        :rtype: str"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Handle_Note(self, msg):\n\n        note_text = msg['object']['note']\n        note_tags = msg['object']['tags']\n\n        if 'ID' in msg['object']:\n            note_id = msg['object']['ID']\n            self.db.addItem(\"note\", {\"note\": note_text,\n                                     \"tags\": note_tags},\n                            note_id)\n        else:\n            note_id = self.db.addItem(\"note\", {\"note\": note_text,\n                                               \"tags\": note_tags})\n\n        reply = {\"status\": \"OK\",\n                 \"type\": \"Note\",\n                 \"object\": {\n                           \"received note\": msg['object']['note'],\n                           \"received tags\": msg['object']['tags'],\n                           \"ID\": note_id}\n                 }\n\n        return json.dumps(reply)", "response": "Handle a new note."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle a Label message.", "response": "def Handle_Label(self, msg):\n        \"\"\"\n            :desc: Set a label\n            :param dict msg: The message received from the client\n            :rval: str\n            :returns: A status message (JSON serialized to a string)\n        \"\"\"\n\n        obj = msg['object']\n        if 'name' not in obj or 'id' not in obj:\n            r_msg = {'status': 'ERROR',\n                     'type': 'Label',\n                     'object': {'msg': 'improper request'}}\n            return json.dumps(r_msg)\n\n        label_name = obj['name']\n        label_id = obj['id']\n        r_val = self.db.addLabel(label_name, label_id)\n\n        if r_val is None:\n            r_msg = {'status': 'ERROR',\n                     'type': 'Label',\n                     'object': {'msg': 'label already exists'}}\n        else:\n            r_msg = {'status': 'OK',\n                     'type': 'Label',\n                     'object': r_val}\n\n        return json.dumps(r_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhandles a Delete_Label message.", "response": "def Handle_Delete_Label(self, msg):\n        \"\"\"\n            :desc: Deletes a label\n            :param dic msg: The message with the instruction and the label\n                            name to delete\n            :rval: str\n            :returns: The message from the database\n        \"\"\"\n\n        try:\n            label_name = msg['object']['label']\n        except KeyError:\n            r_msg = {'status': 'ERROR',\n                     'type': 'Delete_Label',\n                     'object': {'msg': 'improper request'}}\n            return json.dumps(r_msg)\n        else:\n            r_val = {'status': 'OK',\n                     'type': 'Delete',\n                     'object': self.db.deleteLabel(label_name)}\n            return json.dumps(r_val)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating and return a Ganymede HTML object for modifying the Jupyter notebook web interface.", "response": "def load(shell=None, logo_src=None):\n    \"\"\"\n    Generate and return Ganymede HTML containing CSS and JavaScript\n    for modifying the Jupyter notebook web interface,\n    wrapped in a ``IPython.display.HTML`` object:\n\n    * Must be called with IPython `shell` instance as first argument.\n    * Optionally takes a custom `logo_src` value for the ``src=`` attribute\n      of Ganymede's HTML logo ``<img>`` element.\n    \"\"\"\n    # make sure that .static pkg gets reloaded on %reload_ext ganymede\n    # to recompile ganymede.coffee in development (non-installed) mode\n    sys.modules.pop('ganymede.static', None)\n    from ganymede.static import CSS, JS, TOUCH_PUNCH_JS, SVG\n\n    if logo_src is None:\n        # load Ganymede's default logo\n        logo_src = 'data:image/svg+xml;base64,%s' \\\n            % b64encode(SVG.bytes()).decode('ascii')\n\n    # import locally to make this module importable in setup.py\n    # without further dependencies\n    from IPython.display import HTML\n\n    return HTML(u\"\"\"\n        <style id=\"ganymede-style\" type=\"text/css\">\n            {style}\n        </style>\n        <script type=\"text/javascript\">\n            {touch_punch}\n        </script>\n        <script type=\"text/javascript\">\n            {script}\n            window.ganymede = new Ganymede({logo_src});\n        </script>\n        <script type=\"text/javascript\">\n            $('#ganymede-style').on('remove', function () {{\n                window.ganymede.unload();\n            }});\n        </script>\n    \"\"\".format(style=CSS.text('ascii'), script=JS.text('ascii'),\n               logo_src=json.dumps(logo_src),\n               touch_punch=TOUCH_PUNCH_JS.text('utf8')))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef after_match(self, func, full_fallback=False):\n        iterator = iter(self)\n        for item in iterator:\n            if func(item):\n                return iterator\n        if full_fallback:\n            iterator = iter(self)\n        return iterator", "response": "Returns an iterator for all the elements after the first\n        match."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a response message if a match is found otherwise None.", "response": "def match(self, user, message):\n        \"\"\"\n        Returns a response message if a match is found, otherwise None\n        :param user: The requesting client\n        :type  user: agentml.User\n\n        :param message: The message to match\n        :type  message: agentml.Message\n\n        :rtype: str or None\n        \"\"\"\n        self._log.info('Attempting to match message against Pattern: {pattern}'\n                       .format(pattern=self.pattern.pattern if hasattr(self.pattern, 'pattern') else self.pattern))\n        self.user = user\n\n        # Make sure the topic matches (if one is defined)\n        if user.topic != self.topic:\n            self._log.debug('User topic \"{u_topic}\" does not match Trigger topic \"{t_topic}\", skipping check'\n                            .format(u_topic=user.topic, t_topic=self.topic))\n            return\n\n        def get_response():\n            # Does the user have a limit for this response enforced?\n            if user.is_limited(self):\n                if self.ulimit_blocking:\n                    self._log.debug('An active blocking limit for this trigger is being enforced against the user '\n                                    '{uid}, no trigger will be matched'.format(uid=user.id))\n                    raise LimitError\n\n                self._log.debug('An active limit for this response is being enforced against the user {uid}, '\n                                'skipping'.format(uid=user.id))\n                return ''\n\n            # Is there a global limit for this response enforced?\n            if self.agentml.is_limited(self):\n                if self.glimit_blocking:\n                    self._log.debug('An active blocking limit for this trigger is being enforced globally, no trigger '\n                                    'will be matched')\n                    raise LimitError\n\n                self._log.debug('An active limit for this response is being enforced against the user {uid}, '\n                                'skipping'.format(uid=user.id))\n                return ''\n\n            # Chance testing\n            if self.chance is not None and self.chance != 100:\n                # Chance succeeded\n                if self.chance >= random.uniform(0, 100):\n                    self._log.info('Trigger had a {chance}% chance of being selected and succeeded selection'\n                                   .format(chance=self.chance))\n                # Chance failed\n                else:\n                    if self.chance_blocking:\n                        self._log.info('Trigger had a blocking {chance}% chance of being selected but failed selection'\n                                       ', no trigger will be matched'.format(chance=self.chance))\n                        raise ChanceError\n\n                    self._log.info('Response had a {chance}% chance of being selected but failed selection'\n                                   .format(chance=self.chance))\n                    return ''\n\n            random_response = self._responses.random(user)\n            if not random_response and self.blocking:\n                self._log.info('Trigger was matched, but there are no available responses and the trigger is blocking '\n                               'any further attempts. Giving up')\n                raise ParserBlockingError\n\n            if random_response:\n                self.apply_reactions(user)\n            else:\n                self._log.info('Trigger was matched, but there are no available responses')\n                random_response = ''\n\n            return random_response\n\n        # String match\n        if isinstance(self.pattern, string_types) and str(message) == self.pattern:\n            self._log.info('String Pattern matched: {match}'.format(match=self.pattern))\n            return get_response()\n\n        # Regular expression match\n        if hasattr(self.pattern, 'match'):\n            match = self.pattern.match(str(message))\n            if match:\n                self._log.info('Regex pattern matched: {match}'.format(match=self.pattern.pattern))\n\n                # Parse pattern wildcards\n                self.stars['normalized'] = match.groups()\n                for message_format in [message.CASE_PRESERVED, message.RAW]:\n                    message.format = message_format\n                    format_match = self.pattern.match(str(message))\n                    if format_match:\n                        self.stars[message_format] = format_match.groups()\n\n                self._log.debug('Assigning pattern wildcards: {stars}'.format(stars=str(self.stars)))\n                return get_response()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef apply_reactions(self, user):\n        # User attributes\n        if self.global_limit:\n            self._log.info('Enforcing Global Trigger Limit of {num} seconds'.format(num=self.global_limit))\n            self.agentml.set_limit(self, (time() + self.global_limit), self.glimit_blocking)\n\n        if self.user_limit:\n            self._log.info('Enforcing User Trigger Limit of {num} seconds'.format(num=self.user_limit))\n            user.set_limit(self, (time() + self.user_limit), self.ulimit_blocking)\n\n        for var in self.vars:\n            var_type, var_name, var_value = var\n            var_name  = ''.join(map(str, var_name)) if isinstance(var_name, Iterable) else var_name\n            var_value = ''.join(map(str, var_value)) if isinstance(var_value, Iterable) else var_value\n\n            # Set a user variable\n            if var_type == 'user':\n                self.user.set_var(var_name, var_value)\n\n            # Set a global variable\n            if var_type == 'global':\n                self.agentml.set_var(var_name, var_value)", "response": "Applies the requisites to the user and the global and user variables."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _add_response(self, response, weight=1):\n        # If no response with this priority level has been defined yet, create a new list\n        if response.priority not in self._responses:\n            self._responses[response.priority] = [(response, weight)]\n            return\n\n        # Otherwise, add this trigger to an existing priority list\n        self._responses[response.priority].append((response, weight))", "response": "Add a new response to the priority list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreplacing wildcard symbols with regular expressions", "response": "def replace_wildcards(string, wildcard, regex):\n        \"\"\"\n        Replace wildcard symbols with regular expressions\n        :param wildcard:\n        :type  wildcard: _sre.SRE_Pattern\n\n        :param regex:\n        :type  regex: str\n\n        :rtype: tuple of (str, bool)\n        \"\"\"\n        replaced = False\n        match = wildcard.search(string)\n\n        if match:\n            string = wildcard.sub(regex, string)\n            logging.getLogger('agentml.trigger').debug('Parsing Pattern wildcards: {pattern}'.format(pattern=string))\n            replaced = True\n\n        return string, replaced"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef count_words(pattern):\n        word_pattern = re.compile(r'(\\b(?<![\\(\\)\\[\\]\\|])\\w\\w*\\b(?![\\(\\)\\[\\]\\|]))', re.IGNORECASE)\n\n        words = word_pattern.findall(pattern)\n        word_count = len(words)\n        word_len = sum(len(word) for word in words)\n\n        return word_count, word_len", "response": "Count the number of words in a pattern and then the total length of all words in the pattern."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse and add a group requirement for this trigger.", "response": "def _parse_group(self, element):\n        \"\"\"\n        Parse and add a group requirement for this trigger\n        :param element: The XML Element object\n        :type  element: etree._Element\n        \"\"\"\n        self._log.debug('Adding Trigger group: {group}'.format(group=element.text))\n        if isinstance(self.groups, set):\n            self.groups.add(element.text)\n        elif self.groups is None:\n            self.groups = {element.text}\n        else:\n            raise TypeError('Unrecognized group type, {type}: {groups}'\n                            .format(type=type(self.groups), groups=str(self.groups)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_topic(self, element):\n        self._log.debug('Setting Trigger topic: {topic}'.format(topic=element.text))\n        super(Trigger, self)._parse_topic(element)", "response": "Parse and assign the topic for this trigger"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the pattern of the trigger pattern.", "response": "def _parse_pattern(self, element):\n        \"\"\"\n        Parse the trigger pattern\n        :param element: The XML Element object\n        :type  element: etree._Element\n        \"\"\"\n        # If this is a raw regular expression, compile it and immediately return\n        self._log.info('Parsing Trigger Pattern: ' + element.text)\n        self.pattern_words, self.pattern_len = self.count_words(element.text)\n        self._log.debug('Pattern contains {wc} words with a total length of {cc}'\n                        .format(wc=self.pattern_words, cc=self.pattern_len))\n\n        regex = bool_attribute(self._element, 'regex', False)\n        if regex:\n            self._log.info('Attempting to compile trigger as a raw regex')\n            try:\n                self.pattern = re.compile(element.text)\n            except sre_constants.error:\n                self._log.warn('Attempted to compile an invalid regular expression in {path} ; {regex}'\n                               .format(path=self.file_path, regex=element.text))\n                raise AgentMLSyntaxError\n            return\n\n        self.pattern = normalize(element.text, True)\n        self._log.debug('Normalizing pattern: ' + self.pattern)\n        compile_as_regex = False\n\n        # Wildcard patterns and replacements\n        captured_wildcard = re.compile(r'(?<!\\\\)\\(\\*\\)')\n        wildcard = re.compile(r'(?<!\\\\)\\*')\n\n        capt_wild_numeric = re.compile(r'(?<!\\\\)\\(#\\)')\n        wild_numeric = re.compile(r'(?<!\\\\)#')\n\n        capt_wild_alpha = re.compile(r'(?<!\\\\)\\(_\\)')\n        wild_alpha = re.compile(r'(?<!\\\\)_')\n\n        wildcard_replacements = [\n            (captured_wildcard, r'(.+)'),\n            (wildcard,          r'(?:.+)'),\n            (capt_wild_numeric, r'(\\d+)'),\n            (wild_numeric,      r'(?:\\d+)'),\n            (capt_wild_alpha,   r'([a-zA-Z]+)'),\n            (wild_alpha,        r'(?:[a-zA-Z]+)'),\n        ]\n\n        for wildcard, replacement in wildcard_replacements:\n            self.pattern, match = self.replace_wildcards(self.pattern, wildcard, replacement)\n            compile_as_regex = bool(match) or compile_as_regex\n\n        # Required and optional choices\n        req_choice = re.compile(r'\\(([\\w\\s\\|]+)\\)')\n        opt_choice = re.compile(r'\\s?\\[([\\w\\s\\|]+)\\]\\s?')\n\n        if req_choice.search(self.pattern):\n            def sub_required(pattern):\n                patterns = pattern.group(1).split('|')\n                return r'(\\b{options})\\b'.format(options='|'.join(patterns))\n\n            self.pattern = req_choice.sub(sub_required, self.pattern)\n            self._log.debug('Parsing Pattern required choices: ' + self.pattern)\n            compile_as_regex = True\n\n        if opt_choice.search(self.pattern):\n            def sub_optional(pattern):\n                patterns = pattern.group(1).split('|')\n                return r'\\s?(?:\\b(?:{options})\\b)?\\s?'.format(options='|'.join(patterns))\n\n            self.pattern = opt_choice.sub(sub_optional, self.pattern)\n            self._log.debug('Parsing Pattern optional choices: ' + self.pattern)\n            compile_as_regex = True\n\n        if compile_as_regex:\n            self._log.debug('Compiling Pattern as regex')\n            self.pattern = re.compile('^{pattern}$'.format(pattern=self.pattern), re.IGNORECASE)\n        else:\n            self._log.debug('Pattern is atomic')\n            self.pattern_is_atomic = True\n\n            # Replace any escaped wildcard symbols\n            self._log.debug('Replacing any escaped sequences in Pattern')\n            self.pattern = self.pattern.replace('\\*', '*')\n            self.pattern = self.pattern.replace('\\#', '#')\n            self.pattern = self.pattern.replace('\\_', '_')\n\n            # TODO: This needs revisiting\n            self.pattern = self.pattern.replace('\\(*)', '(*)')\n            self.pattern = self.pattern.replace('\\(#)', '(#)')\n            self.pattern = self.pattern.replace('\\(_)', '(_)')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a redirect element and add it to the list of redirected responses", "response": "def _parse_redirect(self, element):\n        \"\"\"\n        Parse a trigger redirect\n        :param element: The XML Element object\n        :type  element: etree._Element\n        \"\"\"\n        self._log.info('Parsing new redirected Response')\n        self._responses.add(Response(self, element, self.file_path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_condition(self, element):\n        self._log.info('Parsing new Condition')\n        condition = Condition(self, element, self.file_path)\n        for statement in condition.statements:\n            for response in statement.contents:\n                self._responses.add(response, condition)\n\n        if condition.else_statement:\n            self._responses.add(condition.else_statement[0], condition)", "response": "Parse a condition XML element and add the condition to the list of related resources."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clear(correlation_id, components):\n        if components == None:\n            return\n\n        for component in components:\n            Cleaner.clear_one(correlation_id, component)", "response": "Clears state of multiple components."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a string and returns a datetime. datetime.", "response": "def parse_datetime(value):\n    \"\"\"Parses a string and return a datetime.datetime.\n\n    This function supports time zone offsets. When the input contains one,\n    the output uses a timezone with a fixed offset from UTC.\n\n    Raises ValueError if the input is well formatted but not a valid datetime.\n    Returns None if the input isn't well formatted.\n    \"\"\"\n    match = datetime_re.match(value)\n    if match:\n        kw = match.groupdict()\n        if kw['microsecond']:\n            kw['microsecond'] = kw['microsecond'].ljust(6, '0')\n        tzinfo = kw.pop('tzinfo')\n        if tzinfo == 'Z':\n            tzinfo = utc\n        elif tzinfo is not None:\n            offset_mins = int(tzinfo[-2:]) if len(tzinfo) > 3 else 0\n            offset = 60 * int(tzinfo[1:3]) + offset_mins\n            if tzinfo[0] == '-':\n                offset = -offset\n            tzinfo = get_fixed_timezone(offset)\n        kw = {k: int(v) for k, v in kw.items() if v is not None}\n        kw['tzinfo'] = tzinfo\n        return datetime.datetime(**kw)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the daemon is currently running.", "response": "def status(self):\n\t\t\"\"\"\n\t\tCheck if the daemon is currently running.\n\t\tRequires procfs, so it will only work on POSIX compliant OS'.\n\t\t\"\"\"\n\t\t# Get the pid from the pidfile\n\t\ttry:\n\t\t\tpf = file(self.pidfile,'r')\n\t\t\tpid = int(pf.read().strip())\n\t\t\tpf.close()\n\t\texcept IOError:\n\t\t\tpid = None\n\n\t\tif not pid:\n\t\t\treturn False\n\n\t\ttry:\n\t\t\treturn os.path.exists(\"/proc/{0}\".format(pid))\n\t\texcept OSError:\n\t\t\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef match(self, path):\n        for spec in reversed(self.pathspecs):  # type: Pathspec\n            if spec.pattern.match(path):\n                return not spec.negated\n\n        return False", "response": "u Returns True if the path matches the list of path specs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_resource(url, headers):\n    headers[\"Accept\"] = \"application/json\"\n    response = Catalyst_DAO().getURL(url, headers)\n\n    if response.status != 200:\n        raise DataFailureException(url, response.status, response.data)\n\n    try:\n        return json.loads(response.data)\n    except ValueError as ex:\n        raise DataFailureException(url, response.status, response.data)", "response": "Issue a GET request with the given url and headers and return a response in json format."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _process_lines(self, lines):\n        if self._chapterization:\n            idx = 1\n            chapter = Chapter('\u524d\u8a00', 0)\n            for line in lines:\n                if self._is_chapter_title(line):\n                    chapter = Chapter(line.strip(), idx)\n                    self._chapters.append(chapter)\n                    idx += 1\n                else:\n                    if len(line.strip()):\n                        chapter.append_line(line)\n        else:\n            chapter = Chapter('', 0)\n            for line in lines:\n                if len(line.strip()):\n                    chapter.append_line(line)\n            self._chapters.append(chapter)", "response": "Process the lines of the log file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _is_chapter_title(self, line):\n        striped_line = line.strip()\n        # \u7b2cX\u7ae0\n        if striped_line.startswith('\u7b2c'):\n            if 3 <= len(striped_line) < 30 and '\u7ae0' in striped_line:\n                return True\n        # \"X.\" \u6216\u8005 \"X:\"\n        replaced_line = striped_line.replace(':', '.').replace('. ', '.')\n        if replaced_line.split('.')[0].isdigit():\n            if 3 <= len(replaced_line) < 20:\n                return True\n        return False", "response": "Check if the line is a chapter title."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gen_opf(self, book_idx):\n        if self._chapterization:\n            title = '{title}-{book_idx}'.format(title=self._title, book_idx=book_idx)\n            book = 'book-{book_idx}'.format(book_idx=book_idx)\n            toc = 'toc-{book_idx}'.format(book_idx=book_idx)\n        else:\n            title = '{title}'.format(title=self._title)\n            book = 'book'\n            toc = 'toc'\n\n        opf_file = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<package unique-identifier=\"uid\" xmlns:opf=\"http://www.idpf.org/2007/opf\" xmlns:asd=\"http://www.idpf.org/asdfaf\">\n    <metadata>\n        <dc-metadata  xmlns:dc=\"http://purl.org/metadata/dublin_core\" xmlns:oebpackage=\"http://openebook.org/namespaces/oeb-package/1.0/\">\n            <dc:Title>{title}</dc:Title>\n            <dc:Language>zh-cn</dc:Language>\n            <dc:Creator>{author}</dc:Creator>\n            <dc:Copyrights>{author}</dc:Copyrights>\n            <dc:Publisher>Alexander.Li</dc:Publisher>\n            <x-metadata>\n                <EmbeddedCover>{cover}</EmbeddedCover>\n            </x-metadata>\n        </dc-metadata>\n    </metadata>\n    <manifest>\n        <item id=\"toc\" properties=\"nav\" href=\"{book}.html\" media-type=\"application/xhtml+xml\"/>\n        <item id=\"content\" media-type=\"application/xhtml+xml\" href=\"{book}.html\"></item>\n        <item id=\"cover-image\" media-type=\"image/png\" href=\"{cover}\"/>\n        <item id=\"ncx\" media-type=\"application/x-dtbncx+xml\" href=\"{toc}.ncx\"/>\n    </manifest>\n    <spine toc=\"ncx\">\n        <itemref idref=\"cover-image\"/>\n        <itemref idref=\"toc\"/>\n        <itemref idref=\"content\"/>\n    </spine>\n    <guide>\n        <reference type=\"toc\" title=\"{title_name}\" href=\"{book}.html#toc\"/>\n        <reference type=\"content\" title=\"Book\" href=\"{book}.html\"/>\n    </guide>\n</package>\n        \"\"\".format(\n            title_name='\u76ee\u5f55',\n            author=self._author,\n            title=title,\n            cover=self._cover_img,\n            book=book,\n            toc=toc\n        )\n        return opf_file", "response": "Generate an OPF file for the IDP."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gen_ncx(self, book_idx):\n        start, end = self._start_end_of_index(book_idx)\n        ncx_base = \"\"\"<?xml version=\"1.0\"?>\n<!DOCTYPE ncx PUBLIC \"-//NISO//DTD ncx 2005-1//EN\"\n \"http://www.daisy.org/z3986/2005/ncx-2005-1.dtd\">\n<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n <head>\n </head>\n        <docTitle>\n               <text>{book_title}</text>\n        </docTitle>\n    <navMap>\n        {menavPoints}\n    </navMap>\n</ncx>\n        \"\"\".format(\n            book_title=self._title,\n            menavPoints=\"\\n\".join([chap.gen_ncx(book_idx) for chap in self._chapters[start:end]])\n        )\n        return ncx_base", "response": "Generate NCX base XML."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the HTML toctree for the given index.", "response": "def _gen_toc(self, idx):\n        \"\"\"\n        \u751f\u6210\u76ee\u5f55html\n        :return:\n        :rtype:\n        \"\"\"\n        if not self._chapterization:\n            return ''\n\n        start, end = self._start_end_of_index(idx)\n        chap_infos = '\\n'.join([\"            <li><a href=\\\"#ch{}\\\">{}</a></li>\".format(\n            chap._idx,\n            chap._title) for chap in self._chapters[start:end]])\n        toc = \"\"\"\n    <div id=\"toc\">\n        <h2>\n            \u76ee\u5f55<br />\n        </h2>\n        <ul>\n{}\n        </ul>\n    </div>\n    <div class=\"pagebreak\"></div>\n        \"\"\" .format(chap_infos)\n        return toc"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef func(self, name: str):\n        for f in self.body:\n            if (hasattr(f, '_ctype')\n                    and isinstance(f._ctype, FuncType)\n                    and f._name == name):\n                return f", "response": "return the first func defined named name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef type(self, name: str):\n        for f in self.body:\n            if (hasattr(f, '_ctype')\n                    and f._ctype._storage == Storages.TYPEDEF\n                    and f._name == name):\n                return f", "response": "return the first complete definition of type name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef declallvars(self):\n        for f in self.body:\n            if (hasattr(f, '_ctype')\n                    and not isinstance(f._ctype, FuncType)):\n                yield f", "response": "generator on all declaration of variable"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing a popup with a textedit", "response": "def show_popup(self, *args, **kwargs):\n        \"\"\"Show a popup with a textedit\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.mw = JB_MainWindow(parent=self, flags=QtCore.Qt.Dialog)\n        self.mw.setWindowTitle(self.popuptitle)\n        self.mw.setWindowModality(QtCore.Qt.ApplicationModal)\n        w = QtGui.QWidget()\n        self.mw.setCentralWidget(w)\n        vbox = QtGui.QVBoxLayout(w)\n        pte = QtGui.QPlainTextEdit()\n        pte.setPlainText(self.get_popup_text())\n        vbox.addWidget(pte)\n        # move window to cursor position\n        d = self.cursor().pos() - self.mw.mapToGlobal(self.mw.pos())\n        self.mw.move(d)\n        self.mw.show()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_index(self, index):\n        item = index.internalPointer()\n        self.actionunit = item.internal_data()\n        self.setEnabled(bool(self.actionunit.status.traceback))", "response": "Display the data of the given index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a mount from a directory.", "response": "def mount(directory, lower_dir, upper_dir, mount_table=None):\n    \"\"\"Creates a mount\"\"\"\n    return OverlayFS.mount(directory, lower_dir, upper_dir,\n            mount_table=mount_table)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter_teams(self, teams):\n\t\treturn [LeaderboardInstance(x) for x in self._leaderboard if x['faction']['id'] in teams]", "response": "Returns a list of LeaderboardInstances that have a team ID in teams."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filter_users(self, users):\n\t\treturn [LeaderboardInstance(x) for x in self._leaderboard if x['user_id'] in users]", "response": "Returns a list of LeaderboardInstances that have a user_id in users."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filter_trainers(self, trainers):\n\t\treturn [LeaderboardInstance(x) for x in self._leaderboard if x['id'] in trainers]", "response": "Returns a list of LeaderboardInstances that are in the given list of Trainer IDs ints."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntake a path and a filetype verifies existence and type and returns absolute path.", "response": "def normalize_path(path, filetype=FILE):\n    \"\"\"Takes a path and a filetype, verifies existence and type, and\n    returns absolute path.\n\n    \"\"\"\n    if not path:\n        raise ValueError('\"{0}\" is not a valid path.'.format(path))\n    if not os.path.exists(path):\n        raise ValueError('\"{0}\" does not exist.'.format(path))\n    if filetype == FILE and not os.path.isfile(path):\n        raise ValueError('\"{0}\" is not a file.'.format(path))\n    elif filetype == DIR and not os.path.isdir(path):\n        raise ValueError('\"{0}\" is not a dir.'.format(path))\n\n    return os.path.abspath(path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites output to stderr.", "response": "def err(*output, **kwargs):\n    \"\"\"Writes output to stderr.\n\n    :arg wrap: If you set ``wrap=False``, then ``err`` won't textwrap\n        the output.\n\n    \"\"\"\n    output = 'Error: ' + ' '.join([str(o) for o in output])\n    if kwargs.get('wrap') is not False:\n        output = '\\n'.join(wrap(output, kwargs.get('indent', '')))\n    elif kwargs.get('indent'):\n        indent = kwargs['indent']\n        output = indent + ('\\n' + indent).join(output.splitlines())\n    sys.stderr.write(output + '\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting output to stdout.", "response": "def out(*output, **kwargs):\n    \"\"\"Writes output to stdout.\n\n    :arg wrap: If you set ``wrap=False``, then ``out`` won't textwrap\n        the output.\n\n    \"\"\"\n    output = ' '.join([str(o) for o in output])\n    if kwargs.get('wrap') is not False:\n        output = '\\n'.join(wrap(output, kwargs.get('indent', '')))\n    elif kwargs.get('indent'):\n        indent = kwargs['indent']\n        output = indent + ('\\n' + indent).join(output.splitlines())\n    sys.stdout.write(output + '\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef convert_rrule(rrule):\n    args = {}\n\n    # TODO: rrule['freq'] is a list, but I'm unclear as to why.\n    freq = FREQ_MAP[rrule['freq'][0]]\n\n    keys = ['wkst', 'until', 'bysetpos', 'interval',\n            'bymonth', 'bymonthday', 'byyearday', 'byweekno',\n            'byhour', 'byminute', 'bysecond']\n\n    def tweak(rrule, key):\n        value = rrule.get(key)\n        if isinstance(value, list):\n            return value[0]\n        return value\n\n    args = dict((key, tweak(rrule, key)) for key in keys if rrule.get(key))\n\n    byweekday = rrule.get('byweekday')\n    if byweekday:\n        byweekday = byweekday[0]\n        count, day = int(byweekday[0]), byweekday[1:]\n        args['byweekday'] = WEEKDAY_MAP[day](count)\n\n    return freq, args", "response": "Converts icalendar rrule to dateutil rrule."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake an icsfilename parses it and returns Events.", "response": "def parse_ics(icsfile):\n    \"\"\"Takes an icsfilename, parses it, and returns Events.\"\"\"\n    events = []\n\n    cal = Calendar.from_ical(open(icsfile, 'rb').read())\n    for component in cal.walk('vevent'):\n        dtstart = component['dtstart'].dt\n        rrule = component['rrule']\n\n        freq, args = convert_rrule(rrule)\n        args['dtstart'] = dtstart\n\n        rrule = dateutil.rrule.rrule(freq, **args)\n\n        summary = vText.from_ical(component.get('summary', u''))\n        description = vText.from_ical(component.get('description', u''))\n        organizer = vText.from_ical(component.get('organizer', u''))\n\n        # TODO: Find an event id.  If it's not there, then compose one\n        # with dtstart, summary, and organizer.\n        event_id = \"::\".join((str(dtstart), summary, organizer))\n\n        events.append(Event(event_id, rrule, summary, description))\n    return events"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read(self, sources, cache_duration=None):\n        if cache_duration is not None:\n            self._cache_duration = cache_duration\n\n        return super(RemoteConfig, self).read(sources)", "response": "Reads the config sources."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read(self, source):\n        if source.startswith('http://') or source.startswith('https://'):\n            source = url_content(source, cache_duration=self._cache_duration, from_cache_on_error=True)\n\n        return super(RemoteConfig, self)._read(source)", "response": "Reads and parses the config source URL."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef route(cls, path):\n\n    if not path.startswith('/'):\n      raise ValueError('Routes must start with \"/\"')\n\n    def wrap(fn):\n      setattr(fn, cls.ROUTE_ATTRIBUTE, path)\n      return fn\n\n    return wrap", "response": "A decorator to indicate that a method should be a routable HTTP endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef install(cls, mbox):\n    def wrap(fn):\n      setattr(fn, cls.INSTALL_ATTRIBUTE, mbox)\n      return fn\n    return wrap", "response": "A decorator to indicate a remotely callable method on a process."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send(self, to, method, body=None):\n    self._assert_bound()\n    self._context.send(self.pid, to, method, body)", "response": "Send a message to another process."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef link(self, to):\n    self._assert_bound()\n    self._context.link(self.pid, to)", "response": "Link this process to another process."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef install(cls, message_type):\n    def wrap(fn):\n      @functools.wraps(fn)\n      def wrapped_fn(self, from_pid, message_str):\n        message = message_type()\n        message.MergeFromString(message_str)\n        return fn(self, from_pid, message)\n      return Process.install(message_type.DESCRIPTOR.full_name)(wrapped_fn)\n    return wrap", "response": "A class decorator to indicate a remotely callable method on a process using protocol buffers."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send(self, to, message):\n    super(ProtobufProcess, self).send(to, message.DESCRIPTOR.full_name, message.SerializeToString())", "response": "Send a message to another process."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprepare actions pipeline. :param tuple acts: called functions :param function done: get result from actions :returns function: function that starts executio", "response": "def actions(acts, done):\n    '''\n    Prepare actions pipeline.\n\n    :param tuple acts: called functions\n    :param function done: get result from actions\n    :returns function: function that starts executio\n    '''\n\n    def _intermediate(acc, action):\n        result = action(acc['state'])\n        values = concatv(acc['values'], [result['answer']])\n\n        return {'values': values, 'state': result['state']}\n\n    def _actions(seed):\n        init = {'values': [], 'state': seed}\n\n        result = reduce(_intermediate, acts, init)\n\n        keep = remove(lambda x: x is None, result['values'])\n\n        return done(keep, result['state'])\n\n    return _actions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lift(fn=None, state_fn=None):\n    if fn is None:\n        return partial(lift, state_fn=state_fn)\n\n    @wraps(fn)\n    def _lift(*args, **kwargs):\n        def _run(state):\n            ans = fn(*cons(state, args), **kwargs)\n            s = state_fn(state) if state_fn is not None else ans\n\n            return {'answer': ans, 'state': s}\n        return _run\n    return _lift", "response": "Decorator for creating a new object based on a function that takes a state object and returns the state object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd or remove user s access to an account", "response": "def put(self, account_id, user_id):\n        \"\"\" Only the primary on the account can add or remove user's access to an account\n        :param account_id: int of the account_id for the account\n        :param user_id:    int of the user_id to grant access\n        :return:           Access dict\n        \"\"\"\n        return self.connection.put('account/access', data=dict(account_id=account_id,           user_id=user_id))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete an access dict for a user", "response": "def delete(self, account_id, user_id):\n        \"\"\" Only the primary on the account can add or remove user's access to an account\n        :param account_id: int of the account_id for the account\n        :param user_id:    int of the user_id to grant access\n        :return:           Access dict\n        \"\"\"\n        return self.connection.delete('account/access', account_id=account_id, user_id=user_id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchanges the speed of a controller.", "response": "def _set_speed(self, motor, speed):\n        \"\"\"\n        Change the speed of a motor on the controller.\n\n        :param motor: The motor to change.\n        :type motor: ``int``\n\n        :param speed: Speed from -100 to +100, 0 is stop\n        :type speed: ``int``\n\n        \"\"\"\n        self._validate_motor(motor)\n        en, in1, in2 = self._motors[motor-1]\n\n        if speed == 0:\n            en.pwm_stop()\n            in1.set(False)\n            in2.set(False)\n        elif speed > 0:\n            en.pwm_start(abs(speed))\n            in1.set(True)\n            in2.set(False)\n        else:\n            en.pwm_start(abs(speed))\n            in1.set(False)\n            in2.set(True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_all_params_are_keyword(method):\n\n    args, varargs, keywords, defaults = inspect.getargspec(method)\n\n    # Always have self, thus the -1\n    if len(args or []) - 1 != len(defaults or []):\n        raise CooperativeError, \"Init has positional parameters \" + \\\n              str(args[1:])\n    if varargs:\n        raise CooperativeError, \"Init has variadic positional parameters\"\n    if keywords:\n        raise CooperativeError, \"Init has variadic keyword parameters\"", "response": "Checks if all parameters of the method are keyword parameters. Raises CooperativeError if method any parameter that is not a\n    named keyword parameter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a function that removes all keyword parameters required by method from the dictionary keys and returns them in a separate dictionary.", "response": "def make_keyword_extractor(method):\n    \"\"\"\n    Removes all keyword parameters required by 'method' from\n    dictionary 'keys' and returns them in a separate dictionary.\n    \"\"\"\n\n    args, _1, _2, defs = inspect.getargspec(method)\n    key_args = args[-len(defs or []):]\n    def extractor(keys):\n        new = {}\n        for a in key_args:\n            if a in keys:\n                new[a] = keys[a]\n                del keys[a]\n        return new\n    return extractor"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the plugin :raises: errors.PluginInitError", "response": "def _load(self, ):\n        \"\"\"Loads the plugin\n\n        :raises: errors.PluginInitError\n        \"\"\"\n        try:\n            self.init()\n        except Exception as e:\n            log.exception(\"Load failed!\")\n            raise errors.PluginInitError('%s' % e)\n        self.__status = self.__LOADED"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nunload the plugin :raises: errors.PluginUninitError", "response": "def _unload(self, ):\n        \"\"\"Unloads the plugin\n\n        :raises: errors.PluginUninitError\n        \"\"\"\n        try:\n            self.uninit()\n        except Exception as e:\n            log.exception(\"Unload failed!\")\n            raise errors.PluginUninitError('%s' % e)\n        self.__status = self.__UNLOADED"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the user config for this plugin.", "response": "def get_config(self, ):\n        \"\"\"Return the user config for this plugin\n\n        You have to provide a configspec,\n        put the configspec file in the same folder as your plugin.\n        Name it like your class and put 'ini' as extension.\n        \"\"\"\n        # get the module of the plugin class\n        mod = sys.modules[self.__module__]\n        # get the file from where it was imported\n        modfile = mod.__file__\n        # get the module directory\n        specdir = os.path.dirname(modfile)\n        # get the classname\n        cname = self.__class__.__name__\n        # add the extension\n        confname = os.extsep.join((cname, CONFIG_EXT))\n\n        specpath = os.path.join(specdir, confname)\n        if not os.path.exists(specpath):\n            return None\n        confpath = os.path.join(PLUGIN_CONFIG_DIR, confname)\n        return load_config(confpath, specpath)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding all plugins in path and return a list with all plugins found in path", "response": "def find_plugins(self, path):\n        \"\"\"Return a list with all plugins found in path\n\n        :param path: the directory with plugins\n        :type path: str\n        :returns: list of JB_Plugin subclasses\n        :rtype: list\n        :raises: None\n        \"\"\"\n        ext = os.extsep+'py'\n        files = []\n        for (dirpath, dirnames, filenames) in os.walk(path):\n            files.extend([os.path.join(dirpath, x) for x in filenames if x.endswith(ext)])\n        plugins = []\n        for f in files:\n            try:\n                mod = self.__import_file(f)\n            except Exception:\n                tb = traceback.format_exc()\n                log.debug(\"Importing plugin from %s failed!\\n%s\" % (f, tb))\n                continue\n            # get all classes in the imported file\n            members = inspect.getmembers(mod, lambda x: inspect.isclass(x))\n            # only get classes which are defined, not imported, in mod\n            classes = [m[1] for m in members if m[1].__module__ == mod.__name__]\n            for c in classes:\n                # if the class is derived from a supported type append it\n                # we test if it is a subclass of a supported type but not a supported type itself\n                # because that might be the abstract class\n                if any(issubclass(c, supported) for supported in self.supportedTypes)\\\n                   and c not in self.supportedTypes:\n                    plugins.append(c)\n        return plugins"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gather_plugins(self):\n        plugins = []\n        cfg = get_core_config()\n        pathenv = cfg['jukebox']['pluginpaths']\n        pathenv = os.pathsep.join((pathenv, os.environ.get(\"JUKEBOX_PLUGIN_PATH\", \"\")))\n        paths = pathenv.split(os.pathsep)\n        # first find built-ins then the ones in the config, then the one from the environment\n        # so user plugins can override built-ins\n        for p in reversed(paths):\n            if p and os.path.exists(p):  # in case of an empty string, we do not search!\n                plugins.extend(self.find_plugins(p))\n        return plugins", "response": "Return all plugins that are found in the plugin paths\n\n        Looks in the JUKEBOX_PLUGIN_PATH environment variable and returns a list of all plugins that are found in the plugin paths\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_plugins(self, ):\n        for p in self.__plugins.values():\n            try:\n                self.load_plugin(p)\n            except errors.PluginInitError:\n                log.exception('Initializing the plugin: %s failed.' % p)", "response": "Loads all found plugins and sets the attributes of the plugin."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_plugin(self, p):\n        if p.is_loaded():\n            return\n        # load required plugins first\n        reqnames = p.required\n        reqplugins = []\n        for name in reqnames:\n            try:\n                reqplugins.append(self.__plugins[name])\n            except KeyError as e:\n                log.error(\"Required Plugin %s not found. Cannot load %s.\" % (name, p))\n                raise errors.PluginInitError('Required Plugin %s not found. Cannot load %s. Reason: %s' % (name, p, e))\n        for plug in reqplugins:\n            try:\n                self.load_plugin(plug)\n            except errors.PluginInitError as e:\n                log.error(\"Required Plugin %s could not be loaded. Cannot load %s\" % (plug, p))\n                raise errors.PluginInitError('Required Plugin %s could not be loaded. Cannot load %s. Reason: %s' % (plug,p, e))\n        # load the actual plugin\n        p._load()\n        log.info('Initialized the plugin: %s' % p)", "response": "Loads the specified plugin\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nunload all loaded plugins", "response": "def unload_plugins(self, ):\n        \"\"\" Unloads all loaded plugins\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        for p in self.__plugins.values():\n            if p.is_loaded():\n                try:\n                    p._unload()\n                    log.info('Uninitialized the plugin: %s' % p)\n                except errors.PluginUninitError:\n                    log.error('Uninitialization of the plugin: %s failed.' % p)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __import_file(self, f):\n        directory, module_name = os.path.split(f)\n        module_name = os.path.splitext(module_name)[0]\n\n        path = list(sys.path)\n        sys.path.insert(0, directory)\n        module = __import__(module_name)\n        return module", "response": "Imports the specified file and returns the imported module\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _exception_handler(self, e):\n        if isinstance(e.message, dict):\n            return self._prep_response(\n                e.message['msg'], status=e.message['status'])\n        if e.message.find('Validation') == 0:\n            return self._prep_response(self.validation.errors, status=400)\n        elif e.message.find('No record') == 0:\n            return self._prep_response(status=404)\n        else:\n            return self._prep_response({'message': e.message},\n                                       status=409)", "response": "This function is called when an exception occurs when we need to quit the workflow prematurely. It returns a dict containing the error details of the error and status code."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the record specified by the obj_id path in the url and stores it in g. _resource_instance", "response": "def _get_instance(self, **kwargs):\n        \"\"\"Loads the record specified by the `obj_id` path in the url and\n           stores it in g._resource_instance\"\"\"\n        current_app.logger.info(\"Getting instance\")\n        current_app.logger.debug(\"kwargs: {}\".format(kwargs))\n\n        current_app.logger.info(\n            \"Loading instance: {}\".format(kwargs['obj_id']))\n        rec = self.db_query.get_instance(self.db_collection, kwargs['obj_id'])\n        g._resource_instance = rec\n        current_app.logger.debug(\n            \"g._resource_instance: {}\".format(g._resource_instance))\n        return rec"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef str_name_value(name, value, tab=4, ljust=25):\n    rep_name = (name.startswith('_') and name[1:]) or name\n    try:\n        return ' ' * tab + str(rep_name).ljust(ljust) + \\\n               str(value).replace('\\n', '\\n' + ' ' * (ljust + tab))\n    except:\n        rep_name = \"Exception in serializing %s value\" % name\n        return ' ' * tab + str(rep_name).ljust(ljust) + \\\n               str(value).replace('\\n', '\\n' + ' ' * (ljust + tab))", "response": "This will return a str of name and value with uniform spacing"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef repr_return(func):\n\n    def repr_return_decorator(*args, **kwargs):\n        ret = func(*args, **kwargs)\n        if isinstance(ret, basestring):\n            return ret\n\n        if type(ret) in repr_map:\n            return repr_map[type(ret)](ret)\n\n        print('=' * 80 + '\\n' +\n              ' FAILED TO GET REPR RETURN for type (' +\n              str(type(ret)) + '\\n' + '=' * 80)\n\n        return ret\n\n    return repr_return_decorator", "response": "A decorator to give the return value a pretty print repr_return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef repr_setup(self, name=None, col_names=None, col_types=None):\n        self._name = name or self._name", "response": "This function is called by the base class to help help"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef repr_setup(self, name=None, col_names=None, col_types=None):\n        self._name = name or self._name\n        self._col_names = col_names or self._col_names\n        self._col_types = col_types or self._col_types\n        if self._original:\n            self._col_names = self._col_names[:len(self._original[0])]", "response": "This function is called by the base class to set up the internal state of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_of_dict(self):\n        ret = []\n        for row in self:\n            ret.append(dict([(self._col_names[i], row[i]) for i in\n                             range(len(self._col_names))]))\n        return ReprListDict(ret, col_names=self._col_names,\n                            col_types=self._col_types,\n                            width_limit=self._width_limit,\n                            digits=self._digits,\n                            convert_unicode=self._convert_unicode)", "response": "This will convert the data from a list of list to a list of dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef append(self, obj):\n        if isinstance(obj, dict) and self._col_names:\n            obj = [obj.get(col, None) for col in self._col_names]\n        assert isinstance(obj, list), \\\n            \"obj appended to ReprListList needs to be a list or dict\"\n        self._original.append(obj)", "response": "Appends the object to the list of entries in the ReprListList."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_of_list(self):\n        ret = [[row.get(key, '') for key in self._col_names] for row in self]\n        return ReprListList(ret, col_names=self._col_names,\n                            col_types=self._col_types,\n                            width_limit=self._width_limit,\n                            digits=self._digits,\n                            convert_unicode=self._convert_unicode)", "response": "This will convert the data from a list of dict to a list of list of dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef repr_setup(self, name=None, col_names=None, col_types=None):\n        self._name = name or self._name\n        self._col_types = col_types or self._col_types", "response": "Set up the name and col_types attributes for this object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nraise an exception if the object is not of type str or unicode.", "response": "def require_string(obj, name=None, nonempty=False):\n    \"\"\"\n    Raise an exception if the obj is not of type str or unicode.\n\n    If name is provided it is used in the exception message.\n\n    If nonempty=True, then an exception is raised if the object is the empty\n    string.\n    \"\"\"\n    require_instance(obj, string_types, name, \"string\")\n    if nonempty and not obj:\n        raise ValueError(\n            ((\"%s: \" % name) if name else \"\") +\n            \"string must be nonempty.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nraises an exception if obj is not an instance of one of the specified types.", "response": "def require_instance(obj, types=None, name=None, type_name=None, truncate_at=80):\n    \"\"\"\n    Raise an exception if obj is not an instance of one of the specified types.\n\n    Similarly to isinstance, 'types' may be either a single type or a tuple of\n    types.\n\n    If name or type_name is provided, it is used in the exception message.\n    The object's string representation is also included in the message,\n    truncated to 'truncate_at' number of characters.\n    \"\"\"\n    if not isinstance(obj, types):\n        obj_string = str(obj)\n        if len(obj_string) > truncate_at:\n            obj_string = obj_string[:truncate_at - 3] + \"...\"\n        if type_name is None:\n            try:\n                type_name = \"one of \" + \", \".join(str(t) for t in types)\n            except TypeError:\n                type_name = str(types)\n        name_string = (\"%s: \" % name) if name else \"\"\n        error_message = \"%sexpected %s. Got: '%s' of type '%s'\" % (\n            name_string, type_name, obj_string, type(obj))\n        raise TypeError(error_message)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef require_iterable_of(objs, types, name=None, type_name=None, truncate_at=80):\n    # Fast pass for common case where all types are correct.\n    # This avoids the more expensive loop below. A typical speedup from this\n    # optimization is 6.6 sec -> 1.7 sec, for testing a list of size 10,000,000.\n    try:\n        if all(isinstance(obj, types) for obj in objs):\n            return\n    except TypeError:\n        # We don't require that objs is a list in this function, just that it's\n        # iterable. We specify 'list' below as a convenient way to throw the\n        # desired error.\n        require_instance(objs, list, name, \"iterable\", truncate_at)\n\n    # Some type isn't correct. We reuse the require_instance function to raise\n    # the exception.\n    prefix = (\"%s: \" % name) if name else \"\"\n    for (i, obj) in enumerate(objs):\n        element_name = prefix + (\"element at index %d\" % i)\n        require_instance(obj, types, element_name, type_name, truncate_at)\n    assert False, \"Shouldn't reach here.\"", "response": "Raise an exception if objs is not an iterable with each element an instance\nTaxonomy of one of the specified types."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef your_tips_on_homepage(context):\n    context = copy(context)\n    site_main = context['request'].site.root_page\n    if get_your_tip(context):\n        tip_on_homepage = (YourTipsArticlePage.objects\n                           .descendant_of(site_main)\n                           .filter(featured_in_homepage=True)\n                           .order_by('-featured_in_homepage_start_date')\n                           .first())\n\n        if not tip_on_homepage:\n            tip_on_homepage = (YourTipsArticlePage.objects\n                               .descendant_of(site_main)\n                               .order_by('-total_upvotes')\n                               .first())\n\n        if not tip_on_homepage:\n            tip_on_homepage = (YourTipsArticlePage.objects\n                               .descendant_of(site_main)\n                               .order_by('-latest_revision_created_at')\n                               .first())\n\n        context.update({\n            'article_tip': tip_on_homepage,\n            'your_tip_page_slug': get_your_tip(context).slug\n        })\n    return context", "response": "A template tag for the Tip of the Day on the homepage."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef your_tips_on_tip_submission_form(context):\n    context = copy(context)\n    site_main = context['request'].site.root_page\n\n    most_recent_tip = (YourTipsArticlePage.objects\n                       .descendant_of(site_main)\n                       .order_by('-latest_revision_created_at')\n                       .first())\n\n    most_popular_tip = (YourTipsArticlePage.objects\n                        .descendant_of(site_main)\n                        .filter(votes__gte=1)\n                        .order_by('-total_upvotes')\n                        .first())\n\n    context.update({\n        'most_popular_tip': most_popular_tip,\n        'most_recent_tip': most_recent_tip,\n        'your_tip_page_slug': get_your_tip(context).slug\n    })\n    return context", "response": "A template tag to display the most recent and popular tip on the tip submission form."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef your_tips_create_tip_on_homepage(context):\n    context = copy(context)\n    if get_your_tip(context):\n        homepage_action_copy = get_your_tip(context).homepage_action_copy\n        context.update({\n            'your_tip_page_slug': get_your_tip(context).slug,\n            'homepage_action_copy': homepage_action_copy\n        })\n    return context", "response": "A template tag to display a banner with a link on the homepage."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_your_tip(context):\n    site_main = context['request'].site.root_page\n    return YourTip.objects.descendant_of(site_main).live().first()", "response": "A simple tag to return the YourTips page."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_key(raw=False):\n    while True:\n        try:\n            if kbhit():\n                char = getch()\n                ordinal = ord(char)\n                if ordinal in (0, 224):\n                    extention = ord(getch())\n                    scan_code = ordinal + extention * 256\n                    result = scan_codes.get(scan_code)\n                    break\n                else:\n                    result = char.decode()\n                    break\n        except KeyboardInterrupt:\n            return \"ctrl-c\"\n    return result if raw else keys_flipped.get(result, result)", "response": "Gets a single key from stdin"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset value of object property specified by its name.", "response": "def set_property(obj, name, value):\n        \"\"\"\n        Recursively sets value of object and its subobjects property specified by its name.\n\n        The object can be a user defined object, map or array.\n        The property name correspondently must be object property, map key or array index.\n\n        If the property does not exist or introspection fails\n        this method doesn't do anything and doesn't any throw errors.\n\n        :param obj: an object to write property to.\n\n        :param name: a name of the property to set.\n\n        :param value: a new value for the property to set.\n        \"\"\"\n        if obj == None or name == None:\n            return\n\n        names = name.split(\".\")\n        if names == None or len(names) == 0:\n            return\n\n        RecursiveObjectWriter._perform_set_property(obj, names, 0, value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copy_properties(dest, src):\n        if dest == None or src == None:\n            return\n        \n        values = RecursiveObjectReader.get_properties(src)\n        RecursiveObjectWriter.set_properties(dest, values)", "response": "Copies content of one object to another object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nevaluates and return the current value of a user variable", "response": "def get(self, agentml, user=None, key=None):\n        \"\"\"\n        Evaluate and return the current value of a user variable\n        :param user: The active user object\n        :type  user: agentml.User or None\n\n        :param agentml: The active AgentML instance\n        :type  agentml: AgentML\n\n        :param key: The variables key\n        :type  key: str\n\n        :return: Current value of the user variable (or None if the variable has not been set)\n        :rtype : str or None\n        \"\"\"\n        if not user or not key:\n            return\n\n        try:\n            return user.get_var(key)\n        except VarNotDefinedError:\n            return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef time_range_cutter_at_time(local,time_range,time_cut=(0,0,0)):\n\n    ( start, end ) = time_range.get(local)\n    index = start.replace(\n                        hour=time_cut[0],\n                        minute=time_cut[1],\n                        second=time_cut[2]\n                    )\n    cuts = []\n    index += datetime.timedelta(days=1)\n    while index < end:\n        cuts.append(index)\n\n        index += datetime.timedelta(days=1)\n        if local:\n            index = time_range.normalize(index)\n    return cuts", "response": "Given a time range return a list of DateTimes that match the time_cut\nMimeType between start and end."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delta(self,local=False):\n        (s,e) = self.get(local)\n        return e-s", "response": "Returns the number of days of difference between two sets of attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the number of hours of difference between the current time and the current time.", "response": "def hours(self,local=False):\n        \"\"\" Returns the number of hours of difference\n        \"\"\"\n        delta = self.delta(local)\n        return delta.total_seconds()/3600"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef days(self,local=False):\n        delta = self.delta(local)\n        return delta.days", "response": "Returns the number of days of difference between the current and the current one."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef chunks(self,local,cutter_callback=None,*cutter_callback_args,**cutter_callback_kwargs):\n\n        # First we get all the slices we want to take out of this time range.\n        if not cutter_callback:\n            cutter_callback = time_range_cutter_at_time\n        time_cuts = cutter_callback(local,self,*cutter_callback_args,**cutter_callback_kwargs)\n\n        # Now we need to make the time range objects for the cuts\n        time_chunks = []\n        time_index = self.start_time\n        time_cuts = sorted(time_cuts)\n        for time_cut in time_cuts:\n\n            # FIXME: Better error message is probably going to be helpful\n            if self.end_time < time_cut or self.start_time > time_cut:\n                raise Exception('Cut time provided that is outside of time range')\n\n            # Create the new tail end entry for times, combine it with the\n            # index to craft a timerange and add it to the chunk list\n            cut_end_time = time_cut\n\n            # If the chunk is not the final chunk, we want to pull\n            # the time back by a small smidgen\n            if cut_end_time != self.end_time:\n                cut_end_time -= datetime.timedelta(microseconds=1)\n\n            time_ending = DateTime(\n                            data=cut_end_time,\n                            data_tz=time_index.local_tz,\n                            local_tz=time_index.local_tz\n                            )\n\n\n            chunk_range = TimeRange(time_index,time_ending)\n            time_chunks.append(chunk_range)\n\n            # Setup the index for the next cut (the current cut\n            # becomes the start of the next cut)\n            time_index = DateTime(\n                            data=time_cut,\n                            data_tz=time_index.local_tz,\n                            local_tz=time_index.local_tz\n                        )\n\n        # Add the last segment if required\n        if time_index != self.end_time:\n            time_chunks.append(\n                TimeRange(time_index,self.end_time)\n            )\n\n        return time_chunks", "response": "This method takes a time range and returns a list of TimeTimes that are sub - timeranges for that time range."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the string representation of the time range .", "response": "def str(self,local):\n        \"\"\" Return the string representation of the time range\n\n            :param local: if False [default] use UTC datetime. If True use localtz\n        \"\"\"\n        s = self.start_time.str(local) \\\n            + u\" to \" \\\n            + self.end_time.str(local)\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the date object associated", "response": "def date(self,local=False):\n        \"\"\" Return the date object associated\n            :param local: if False [default] return UTC date. If True return localtz date\n        \"\"\"\n        return Date(self.get(local).date(),self.local_tz)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the string representation of the datetime object.", "response": "def str(self,local=False,ifempty=None):\n        \"\"\" Returns the string representation of the datetime\n        \"\"\"\n        ts = self.get(local)\n        if not ts: return ifempty\n        return ts.strftime('%Y-%m-%d %H:%M:%S')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef std_velocity(particle, social, state):\n    inertia = state.params['inertia']\n    c_1, c_2 = state.params['c_1'], state.params['c_2']\n    v_max = state.params['v_max']\n    size = particle.position.size\n\n    c1r1 = __acceleration__(state.rng, c_1, size)\n    c2r2 = __acceleration__(state.rng, c_2, size)\n\n    velocity = __std_velocity_equation__(inertia, c1r1, c2r2, particle, social)\n    return __clamp__(velocity, v_max)", "response": "Standard particle velocity update according to the equation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nguaranteeing convergence velocity update.", "response": "def gc_velocity_update(particle, social, state):\n    \"\"\" Guaranteed convergence velocity update.\n\n    Args:\n        particle: cipy.algorithms.pso.Particle: Particle to update the velocity\n            for.\n        social: cipy.algorithms.pso.Particle: The social best for the particle.\n        state: cipy.algorithms.pso.State: The state of the PSO algorithm.\n\n    Returns:\n        numpy.ndarray: the calculated velocity.\n    \"\"\"\n    gbest = state.swarm[gbest_idx(state.swarm)].position\n    if not np.array_equal(gbest, particle.position):\n        return std_velocity(particle, social, state)\n\n    rho = state.params['rho']\n    inertia = state.params['inertia']\n    v_max = state.params['v_max']\n    size = particle.position.size\n\n    r2 = state.rng.uniform(0.0, 1.0, size)\n    velocity = __gc_velocity_equation__(inertia, rho, r2, particle, gbest)\n    return __clamp__(velocity, v_max)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing a particle within a domain.", "response": "def initialize_particle(rng, domain, fitness_function):\n    \"\"\" Initializes a particle within a domain.\n    Args:\n        rng: numpy.random.RandomState: The random number generator.\n        domain: cipy.problems.core.Domain: The domain of the problem.\n\n    Returns:\n        cipy.algorithms.pso.Particle: A new, fully initialized particle.\n    \"\"\"\n    position = rng.uniform(domain.lower, domain.upper, domain.dimension)\n    fitness = fitness_function(position)\n    return Particle(position=position,\n                    velocity=np.zeros(domain.dimension),\n                    fitness=fitness,\n                    best_fitness=fitness,\n                    best_position=position)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_fitness(objective_function, particle):\n    fitness = objective_function(particle.position)\n    best_fitness = particle.best_fitness\n    cmp = comparator(fitness)\n    if best_fitness is None or cmp(fitness, best_fitness):\n        best_position = particle.position\n        return particle._replace(fitness=fitness,\n                                 best_fitness=fitness,\n                                 best_position=best_position)\n    else:\n        return particle._replace(fitness=fitness)", "response": "Updates the fitness and best_fitness of a particle."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the position and velocity of a specific particle.", "response": "def update_particle(position_update, velocity_update, state, nbest_topology,\n                    idx_particle):\n    \"\"\" Update function for a particle.\n\n    Calculates and updates the velocity and position of a particle for a\n    single iteration of the PSO algorithm. Social best particle is determined\n    by the state.params['topology'] function.\n\n    Args:\n        state: cipy.algorithms.pso.State: The state of the PSO algorithm.\n        nbest_topology: dict: Containing neighbourhood best index for each\n            particle index.\n        idx_particle: tuple: Tuple of the index of the particle and the\n            particle itself.\n\n    Returns:\n        cipy.algorithms.pso.Particle: A new particle with the updated position\n        and velocity.\n\n    \"\"\"\n    (idx, particle) = idx_particle\n\n    nbest = state.swarm[nbest_topology[idx]].best_position\n\n    velocity = velocity_update(particle, nbest, state)\n    position = position_update(particle.position, velocity)\n    return particle._replace(position=position, velocity=velocity)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gbest_idx(swarm):\n    best = 0\n    cmp = comparator(swarm[best].best_fitness)\n    for (idx, particle) in enumerate(swarm):\n        if cmp(particle.best_fitness, swarm[best].best_fitness):\n            best = idx\n    return best", "response": "Returns the index of the gbest particle in the swarm."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lbest_idx(state, idx):\n    swarm = state.swarm\n    n_s = state.params['n_s']\n    cmp = comparator(swarm[0].best_fitness)\n    indices = __lbest_indices__(len(swarm), n_s, idx)\n    best = None\n    for i in indices:\n        if best is None or cmp(swarm[i].best_fitness, swarm[best].best_fitness):\n            best = i\n    return best", "response": "This function returns the index of the lbest particle in the swarm."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndetermining the global best particle in the swarm.", "response": "def solution(swarm):\n    \"\"\" Determines the global best particle in the swarm.\n\n    Args:\n        swarm: iterable: an iterable that yields all particles in the swarm.\n\n    Returns:\n        cipy.algorithms.pso.Particle: The best particle in the swarm when\n        comparing the best_fitness values of the particles.\n    \"\"\"\n    best = swarm[0]\n    cmp = comparator(best.best_fitness)\n    for particle in swarm:\n        if cmp(particle.best_fitness, best.best_fitness):\n            best = particle\n    return best"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _setup_maya():\n\n    # We are having trouble with this in Mark Media. For some reason this\n    # remains importable from a uifutures.host launched from Maya.\n    return\n\n    try:\n        import maya.utils\n    except ImportError:\n        return\n\n    # Remove the shell handler; we have created one ourselves.\n    if hasattr(maya.utils, 'shellLogHandler'):\n        maya_handler = logging.getLogger(os.environ.get('MAYA_DEFAULT_LOGGER_NAME'))\n        maya_handler.removeHandler(maya.utils.shellLogHandler())\n\n    # Change the default format on the UI handler.\n    # TODO: Get some safety wrapping arounc this handler.\n    if hasattr(maya.utils, 'guiLogHandler'):\n        format = os.environ.get('MAYA_GUI_LOGGER_FORMAT')\n        if not format:\n            maya.utils.guiLogHandler().setFormatter(logging.Formatter(MAYA_FORMAT))", "response": "Setup Maya logging but be really defensive about it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the newly added view", "response": "def add_currency_view(self, select=False):\n        \"\"\"returns the newly added view\"\"\"\n        v = CurrencyView()\n        self.remove_currency_view()\n        self['hbox_top'].pack_end(v.get_top_widget())\n        v.light_name(select)\n        return v"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_confs(tileset, ignore_warnings=True, renderd=False):\n    mapproxy_conf_json = \"\"\"\n    {\n      \"services\":{\n        \"wms\":{\n          \"on_source_errors\":\"raise\",\n          \"image_formats\": [\"image/png\"]\n        }\n      },\n      \"layers\":[\n        {\n          \"name\":\"\",\n          \"title\":\"\",\n          \"sources\":[\n            \"tileset_cache\"\n          ]\n        }\n      ],\n      \"caches\":{\n        \"tileset_cache\":{\n          \"grids\":[\n            \"webmercator\"\n          ],\n          \"sources\":[\n            \"tileset_source\"\n          ],\n          \"cache\":{\n            \"type\":\"mbtiles\",\n            \"filename\": \"/provide/valid/path/to/file.mbtiles\"\n          }\n        }\n      },\n      \"sources\":{\n        \"tileset_source\":{\n        }\n      },\n      \"grids\":{\n        \"webmercator\":{\n          \"base\":\"GLOBAL_MERCATOR\"\n        }\n      },\n      \"globals\": {\n        \"image\": {\n          \"paletted\": false\n        }\n      }\n    }\n    \"\"\"\n\n    seed_conf_json = \"\"\"\n    {\n      \"coverages\": {\n        \"tileset_geom\": {\n          \"bbox\": [-77.47, 38.72, -76.72, 39.08],\n          \"datasource\": \"path/to/geom/file.xxx\",\n          \"srs\": \"EPSG:4326\"\n        }\n      },\n\n      \"seeds\": {\n        \"tileset_seed\": {\n          \"refresh_before\": {\n            \"minutes\": 0\n          },\n          \"caches\": [\n            \"tileset_cache\"\n          ],\n          \"levels\": {\n            \"from\": 0,\n            \"to\": 2\n          },\n          \"coverages\": [\"tileset_geom\"]\n        }\n      }\n    }\n    \"\"\"\n\n    seed_conf = yaml.safe_load(seed_conf_json)\n    mapproxy_conf = yaml.safe_load(mapproxy_conf_json)\n\n    print '---- mbtiles file to generate: {}'.format(get_tileset_filename(tileset.name))\n\n    mapproxy_conf['sources']['tileset_source']['type'] = u_to_str(tileset.server_service_type)\n\n    if u_to_str(tileset.server_service_type) == 'wms':\n        \"\"\"\n        \"req\":{\n          \"url\":\"http://admin:geoserver@192.168.99.100/geoserver/wms?\",\n          \"layers\":\"geonode:ne_50m_admin_0_countries\"\n        },\n        \"\"\"\n        mapproxy_conf['sources']['tileset_source']['req'] = {}\n        mapproxy_conf['sources']['tileset_source']['req']['url'] = u_to_str(tileset.server_url)\n        mapproxy_conf['sources']['tileset_source']['req']['layers'] = u_to_str(tileset.layer_name)\n    elif u_to_str(tileset.server_service_type) == 'tile':\n        \"\"\"\n        \"url\": \"http://a.tile.openstreetmap.org/%(z)s/%(x)s/%(y)s.png\",\n        \"\"\"\n        mapproxy_conf['sources']['tileset_source']['url'] = u_to_str(tileset.server_url)\n\n    mapproxy_conf['layers'][0]['name'] = u_to_str(tileset.layer_name)\n    mapproxy_conf['layers'][0]['title'] = u_to_str(tileset.layer_name)\n    mapproxy_conf['caches']['tileset_cache']['cache']['filename'] = get_tileset_filename(tileset.name, 'generating')\n\n    if tileset.layer_zoom_start > tileset.layer_zoom_stop:\n        raise ConfigurationError('invalid configuration - zoom start is greater than zoom stop')\n    seed_conf['seeds']['tileset_seed']['levels']['from'] = tileset.layer_zoom_start\n    seed_conf['seeds']['tileset_seed']['levels']['to'] = tileset.layer_zoom_stop\n    # any specified refresh before for mbtiles will result in regeneration of the tile set\n    seed_conf['seeds']['tileset_seed']['refresh_before']['minutes'] = 0\n\n    if tileset.geom:\n        geom_type = 'other'\n        if tileset.geom.startswith('{\"'):\n            geom_type = 'geojson'\n        elif tileset.geom.lower().startswith('polygon') or tileset.geom.lower().startswith('multipolygon'):\n            geom_type = 'txt'\n        elif tileset.geom.startswith('['):\n            geom_type = 'bbox'\n\n        if geom_type in ['geojson', 'txt']:\n            geom_dir = '{}/geoms'.format(get_tileset_dir())\n            if not os.path.exists(geom_dir):\n                os.makedirs(geom_dir)\n            # TODO: remove geom files when done or pair them up with the actual tileset files?\n            geom_filename = '{}/geoms/{}.{}'.format(get_tileset_dir(), tileset.name, geom_type)\n            with open(geom_filename, 'w+') as geom_file:\n                geom_file.write(tileset.geom)\n            seed_conf['coverages']['tileset_geom']['datasource'] = geom_filename\n            seed_conf['coverages']['tileset_geom'].pop('bbox', None)\n        elif geom_type is 'bbox':\n            seed_conf['coverages']['tileset_geom']['bbox'] = yaml.safe_load(tileset.geom)\n            seed_conf['coverages']['tileset_geom'].pop('datasource', None)\n        else:\n            # if not bbox or file, just set it as is to the datasource since mapproxy can handle other datastores\n            # and they should work as is\n            seed_conf['coverages']['tileset_geom']['datasource'] = yaml.safe_load(tileset.geom)\n\n        print '---- tileset geom_type: {}, geom: {}'.format(geom_type, tileset.geom)\n\n    else:\n        # if a geom is not specified, remove the coverages key from tileset_seed\n        seed_conf['seeds']['tileset_seed'].pop('coverages', None)\n        seed_conf['coverages']['tileset_geom'].pop('datasource', None)\n        seed_conf['coverages']['tileset_geom'].pop('bbox', None)\n\n    print '--[ mapproxy_conf: '\n    print yaml.dump(mapproxy_conf)\n    print '--[ seed_conf: '\n    print yaml.dump(seed_conf)\n\n    if tileset.server_username and tileset.server_password:\n        \"\"\"\n        \"http\":{\n          \"headers\":{\n            \"Authorization\":\"Basic YWRtaW46Z2Vvc2VydmVy\"\n          }\n        }\n        \"\"\"\n        encoded = base64.b64encode('{}:{}'.format(tileset.server_username, tileset.server_password))\n        mapproxy_conf['sources']['tileset_source']['http'] = {}\n        mapproxy_conf['sources']['tileset_source']['http']['headers'] = {}\n        mapproxy_conf['sources']['tileset_source']['http']['headers']['Authorization'] = 'Basic {}'.format(encoded)\n\n    errors, informal_only = validate_mapproxy_conf(mapproxy_conf)\n    for error in errors:\n        print error\n    if not informal_only or (errors and not ignore_warnings):\n        raise ConfigurationError('invalid configuration - {}'.format(', '.join(errors)))\n    cf = ProxyConfiguration(mapproxy_conf, conf_base_dir=get_tileset_dir(), seed=seed, renderd=renderd)\n\n    errors, informal_only = validate_seed_conf(seed_conf)\n    for error in errors:\n        print error\n    if not informal_only:\n        raise SeedConfigurationError('invalid seed configuration - {}'.format(', '.join(errors)))\n    seed_cf = SeedingConfiguration(seed_conf, mapproxy_conf=cf)\n\n    return cf, seed_cf", "response": "Generates a JSON file containing a Tileset object and a list of configuration files."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassociate a user with a Google user_id in the DB.", "response": "def associate_by_user_id(backend, details, response, user=None, *args, **kwargs):\n    \"\"\"\n    Associate current auth with a user with the same Google user_id in the DB.\n    \"\"\"\n    if user:\n        return None\n\n    user_id = response.get('id')\n    if user_id:\n        # Try to associate accounts registered with the same Google user_id.\n        for provider in ('google-appengine-oauth', 'google-appengine-oauth2'):\n            social = backend.strategy.storage.user.get_social_auth(provider, user_id)\n            if social:\n                user = social.user\n                if user:\n                    return {'user': user}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_view(self, view):\n        cb = self.view['cb_currency']\n        cb.set_model(self.model.currencies)\n        cell = gtk.CellRendererText()\n        cb.pack_start(cell, True)\n        \n        def on_cell_data(cb, cell, mod, it):\n            if mod[it][0]: cell.set_property('text', mod[it][0].name)\n            return\n\n        cb.set_cell_data_func(cell, on_cell_data)\n        return", "response": "Creates treeview columns and connects missing signals"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef memoize_methodcalls(func, pickle=False, dumps=pickle.dumps):\n    '''Cache the results of the function for each input it gets called with.\n    '''\n    cache = func._memoize_cache = {}\n    @functools.wraps(func)\n    def memoizer(self, *args, **kwargs):\n        if pickle:\n            key = dumps((args, kwargs))\n        else:\n            key = args\n        if key not in cache:\n            cache[key] = func(self, *args, **kwargs)\n        return cache[key]\n    return memoizer", "response": "Memoize the results of the function for each input it gets called with.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all configuration parameters from specific section stored in this ConfigMap.", "response": "def get_section(self, section):\n        \"\"\"\n        Gets parameters from specific section stored in this ConfigMap.\n        The section name is removed from parameter keys.\n\n        :param section: name of the section to retrieve configuration parameters from.\n\n        :return: all configuration parameters that belong to the section named 'section'.\n        \"\"\"\n        result = ConfigParams()\n        prefix = section + \".\"\n        \n        for (key, value) in self.items():\n            # Prevents exception on the next line\n            if len(key) < len(prefix):\n                continue\n            \n            # Perform case sensitive match\n            key_prefix = key[: len(prefix)]\n            if key_prefix == prefix:\n                key = key[len(prefix): ]\n                result[key] = value\n        \n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd parameters into this ConfigParams under specified section.", "response": "def add_section(self, section, section_params):\n        \"\"\"\n        Adds parameters into this ConfigParams under specified section.\n        Keys for the new parameters are appended with section dot prefix.\n\n        :param section: name of the section where add new parameters\n\n        :param section_params: new parameters to be added.\n        \"\"\"\n        if section == None:\n            raise Exception(\"Section name cannot be null\")\n\n        section = \"\" if self._is_shadow_name(section) else section \n        \n        if section_params == None or len(section_params) == 0:\n            return\n\n        for (key, value) in section_params.items():\n            key = \"\" if self._is_shadow_name(key) else key\n            \n            if len(key) > 0 and len(section) > 0:\n                key = section + \".\" + key\n            elif len(key) == 0:\n                key = section\n\n            self[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noverride parameters with new values from specified ConfigParams and returns a new ConfigParams object.", "response": "def override(self, config_params):\n        \"\"\"\n        Overrides parameters with new values from specified ConfigParams and returns a new ConfigParams object.\n\n        :param config_params: ConfigMap with parameters to override the current values.\n\n        :return: a new ConfigParams object.\n        \"\"\"\n        map = StringValueMap.from_maps(self, config_params)\n        return ConfigParams(map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_defaults(self, default_config_params):\n        map = StringValueMap.from_maps(default_config_params, self)\n        return ConfigParams(map)", "response": "Set default values from specified ConfigParams and returns a new ConfigParams object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef serialize(obj):\n    LOGGER.debug('serialize(%s)', obj)\n\n    if isinstance(obj, datetime.date):\n        return simplejson.dumps(obj, default=encoders.as_date)\n\n    elif hasattr(obj, '__dict__'):\n        return simplejson.dumps(obj, default=encoders.as_object)\n\n    return simplejson.dumps(obj)", "response": "Serialize the given object into JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deserialize(json, cls=None):\n    LOGGER.debug('deserialize(%s)', json)\n\n    out = simplejson.loads(json)\n\n    if isinstance(out, dict) and cls is not None:\n        return cls(**out)\n\n    return out", "response": "Deserialize a JSON string into a Python object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates or create stack", "response": "def main(stack_name, template, mustache_variables):\n    'Update or create stack'\n\n    template_data = _parse_template(template, mustache_variables)\n    params = {\n        'StackName': stack_name,\n        'TemplateBody': template_data\n    }\n\n    try:\n        if _stack_exists(stack_name):\n            print('Updating {}'.format(stack_name))\n            stack_result = cf.update_stack(\n                **params,\n                Capabilities=['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM'])\n            waiter = cf.get_waiter('stack_update_complete')\n            waiter.wait(StackName=stack_name)\n        else:\n            print('Creating {}'.format(stack_name))\n            stack_result = cf.create_stack(\n                **params,\n                Capabilities=['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM'])\n            try:\n                waiter = cf.get_waiter('stack_create_complete')\n                print(\"...waiting for stack to be ready...\")\n                waiter.wait(StackName=stack_name)\n            except Exception as ex:\n                print(ex)\n                print(\"\"\"\n                There was an error creating your stack. Please go to CloudFormation in your \n                AWS console, click on the stack you created, resolve any errors, delete the stack\n                and try again.\n\n                You are seeing this error because your stack failed to create, when stacks fail\n                to create they are put into a terminal ROLLBACK_COMPLETE state and the stack cannot\n                be recovered because they have no previous state to roll back to.\n                \"\"\")\n                exit(1)\n\n    except botocore.exceptions.ClientError as ex:\n        error_message = ex.response['Error']['Message']\n        if error_message == 'No updates are to be performed.':\n            print(\"No changes\")\n        else:\n            raise\n    else:\n        print(json.dumps(\n            cf.describe_stacks(StackName=stack_result['StackId']),\n            indent=2,\n            default=json_serial\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint an extended help message for the current language.", "response": "def print_extended_help():\n    \"\"\"\n\tPrints an extended help message.\n\t\"\"\"\n    # initiate TextWrapper class, which will handle all of the string formatting\n    w = textwrap.TextWrapper()\n    w.expand_tabs = False\n    w.width=110\n    w.initial_indent = '    '\n    w.subsequent_indent = '      '\n\n    print('')\n    print(textwrap.fill(\"<split> Complete parameter list:\", initial_indent=''))\n    print('')\n\n    cmd = \"--input : (required) csv file to split into training and test sets\"\n    print(w.fill(cmd))\n    cmd = \"\\t\\tColumns should be as follows:\"\n    print(w.fill(cmd))\n    print('')\n    cmd=\"\\t\\t    id, status, receptor_1, receptor_2, ..., receptor_N\"\n    print(w.fill(cmd))\n    cmd=\"\\t\\t  CH44,      1,       -9.7,       -9.3, ...,      -10.2\"\n    print(w.fill(cmd))\n    cmd=\"\\t\\t  ZN44,      0,       -6.6,       -6.1, ...,       -6.8\"\n    print(w.fill(cmd))\n    print('')\n    cmd=\"\\t\\tid is a unique molecular identifier\"\n    print(w.fill(cmd))\n    cmd=\"\\t\\tstatus takes a value of '1' if the molecule is active and '0' otherwise.\"\n    print(w.fill(cmd))\n    cmd=\"\\t\\treceptor_1 through receptor_N are docking scores.\"\n    print(w.fill(cmd))\n    print('')\n\n    tfrac = \"--training_fraction : (optional) The fraction of input active molecules\\\n\tallocated to the training set, e.g. 0.40. Defaults to allocate half to the training\\\n\tset.\"\n    print(w.fill(tfrac))\n    print('')\n\n    d2a = \"--decoy_to_active : (optional) The decoy to active ratio to establish in the \\\n\ttraining and validation sets. Defaults to maintain the input file ratio.\"\n    print(w.fill(d2a))\n    print('')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the value of the user input_string", "response": "def get_float(self, input_string):\n        \"\"\"\n\t\tReturn float type user input\n\t\t\"\"\"\n\n        if input_string == '--training_fraction':\n\n            # was the flag set?\n            try:\n                index = self.args.index(input_string) + 1\n            except ValueError:\n                # it wasn't, it's optional, so return the appropriate default\n                return None\n\n            # the flag was set, so check if a value was set, otherwise exit\n            try:\n                if self.args[index] in self.flags:\n                    print(\"\\n {flag} was set but a value was not specified\".format(flag=input_string))\n                    print_short_help()\n                    sys.exit(1)\n            except IndexError:\n                print(\"\\n {flag} was set but a value was not specified\".format(flag=input_string))\n                print_short_help()\n                sys.exit(1)\n\n            # a value was set, so check if its the correct type\n            try:\n                value = float(self.args[index])\n            except ValueError:\n                print(\"\\n {flag} must be a float less than or equal to 1, e.g. 0.4\".format(flag=input_string))\n                print_short_help()\n                sys.exit(1)\n            if value > 1.0 or value < 0:\n                print(\"\\n {flag} must be a float less than or equal to 1, e.g. 0.4\".format(flag=input_string))\n                print_short_help()\n                sys.exit(1)\n\n            # everything checks out, so return the appropriate value\n            return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a password either from STDIN or by prompting the user.", "response": "def get_password(from_stdin_only=False):\n    \"\"\"\n    Get a password either from STDIN or by prompting the user.\n\n    :return: the password.\n    \"\"\"\n    if not sys.stdin.isatty():\n        password = sys.stdin.readline().strip()\n    elif not from_stdin_only:\n        password = getpass.getpass('Enter the password: ')\n    else:\n        password = None\n\n    return password"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a list of hosts and return a list of Host objects.", "response": "def parse_hosts(hosts, ssh_port=None, ssh_config=None):\n    \"\"\"\n    Parse a list of hosts (string) and return a list of `msshcopyid.Host` objects.\n\n    The information about the host are taken in this order of priority:\n\n    - host:\n        - from the host (string) itself.\n    - user:\n        - from the host (string) itself.\n        - from the `paramiko.config.SSHConfig` object.\n        - current logged user.\n    - port:\n        - from the function argument `port`.\n        - from the `paramiko.config.SSHConfig` object.\n        - default SSH port: 22\n\n    :param hosts: list of hosts (string). Eg: ['server1', 'user1@server2']\n    :param ssh_config: a `paramiko.config.SSHConfig` object.\n    :return: a list of `msshcopyid.Host` objects.\n    \"\"\"\n    host_list = []  # list of Host objects\n    current_user = getpass.getuser()\n    for host in hosts:\n        # host_info = {'hostname': 'server1', 'hashknownhosts': 'no', 'user': 'user1'}\n        if ssh_config is not None:\n            host_info = ssh_config.lookup(host)\n        else:\n            host_info = {}\n\n        # hostname & user\n        if '@' in host:\n            user, hostname = host.split('@', 1)\n        else:\n            hostname = host\n            user = host_info.get('user', current_user)\n\n        # port\n        port = ssh_port or host_info.get('port', DEFAULT_SSH_PORT)\n\n        host_list.append(msshcopyid.Host(hostname=hostname, port=port, user=user))\n\n    return host_list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef connect_signals(self, target):\n        if self.connected:\n            raise RuntimeError(\"GtkBuilder can only connect signals once\")\n        self.builder.connect_signals(target)\n        self.connected = True", "response": "Connect signals to the controller."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reparent(self, other, name):\n        # http://developer.gnome.org/gtk-faq/stable/x635.html\n        # warns against reparent()\n        old = self.toplevel.get_parent()\n        if old:\n            old.remove(self.toplevel)\n        new = other[name]\n        new.add(self.toplevel)", "response": "Reparent this instance to the other instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_order_keyword_list(keywords):\n    result = []\n    for keyword in keywords:\n        result.append((keyword, ''))\n        result.append(('-%s' % keyword, ''))\n    return result", "response": "Takes a given list and returns a ready - to - go\n    list of possible ordering values."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a json_str into a JsonObj", "response": "def loads(s: str, **kwargs) -> JsonObj:\n    \"\"\" Convert a json_str into a JsonObj\n\n    :param s: a str instance containing a JSON document\n    :param kwargs: arguments see: json.load for details\n    :return: JsonObj representing the json string\n    \"\"\"\n    if isinstance(s, (bytes, bytearray)):\n        s = s.decode(json.detect_encoding(s), 'surrogatepass')\n    return json.loads(s, object_hook=lambda pairs: JsonObj(**pairs), **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert obj to json string representation.", "response": "def as_json(obj: JsonObj, indent: Optional[str]='   ', **kwargs) -> str:\n    \"\"\" Convert obj to json string representation.\n\n        :param obj: pseudo 'self'\n        :param indent: indent argument to dumps\n        :param kwargs: other arguments for dumps\n        :return: JSON formatted string\n       \"\"\"\n    return obj._as_json_dumps(indent, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the value of the key k to value.", "response": "def setdefault(obj: JsonObj, k: str, value: Union[Dict, JsonTypes]) -> JsonObjTypes:\n    \"\"\" Dictionary setdefault reoutine \"\"\"\n    return obj._setdefault(k, value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _default(self, obj):\n        return obj.__dict__ if isinstance(obj, JsonObj) else json.JSONDecoder().decode(obj)", "response": "Return a serialized version of obj or raise a TypeError\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _items(self) -> List[Tuple[str, JsonObjTypes]]:\n        return [(k, self[k]) for k in self.__dict__.keys()]", "response": "Same as dict. items except that the values are JsonObjs instead of vanilla dictionaries\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a JsonObj into straight json", "response": "def _as_json(self, **kwargs) -> str:\n        \"\"\" Convert a JsonObj into straight json text\n\n        :param kwargs: json.dumps arguments\n        :return: JSON formatted str\n        \"\"\"\n        return json.dumps(self, default=self._default, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting to a stringified json object.", "response": "def _as_json_dumps(self, indent: str='   ', **kwargs) -> str:\n        \"\"\" Convert to a stringified json object.\n\n        This is the same as _as_json with the exception that it isn't\n        a property, meaning that we can actually pass arguments...\n        :param indent: indent argument to dumps\n        :param kwargs: other arguments for dumps\n        :return: JSON formatted string\n        \"\"\"\n        return json.dumps(self, default=self._default, indent=indent, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __as_list(value: List[JsonObjTypes]) -> List[JsonTypes]:\n        return [e._as_dict if isinstance(e, JsonObj) else e for e in value]", "response": "Return a json array as a list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a JsonObj into a straight dictionary", "response": "def _as_dict(self) -> Dict[str, JsonTypes]:\n        \"\"\" Convert a JsonObj into a straight dictionary\n\n        :return: dictionary that cooresponds to the json object\n        \"\"\"\n        return {k: v._as_dict if isinstance(v, JsonObj) else\n                   self.__as_list(v) if isinstance(v, list) else\n                   v for k, v in self.__dict__.items()}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(text, match=None):\n    if text is None: return None\n    text = text.strip()\n    if len(text) == 0: return None\n    nametable = {\n        'namespaces': [],\n        'names': {}\n    }\n    root = XML(text)\n    items = [root] if match is None else root.findall(match)\n    count = len(items)\n    if count == 0:\n        return None\n    elif count == 1:\n        return load_root(items[0], nametable)\n    else:\n        return [load_root(item, nametable) for item in items]", "response": "This function reads a string that contains the XML of an Atom Feed and returns the data in a native Python structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_value(self, fix):\r\n        color = fix and _ansi[\"green_high\"] or _ansi[\"green\"]\r\n        s = color + self._render_cell() + _ansi[\"reset\"]\r\n        return s", "response": "Renders the value for console output."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the headers to the console and csv file.", "response": "def write_headers(self):\r\n        \"\"\"\r\n        Output table header to console and csv file (if present).\r\n        \"\"\"\r\n        h1 = []\r\n        h2 = []\r\n        for m in self.values():\r\n            h2.append(m.render_subtitle())\r\n            h1.append(m.render_title())\r\n\r\n        stdout.write(\" \".join(h1))\r\n        stdout.write(\"\\n\\r\")\r\n        c = _ansi[\"gray\"] + \"|\" + _ansi[\"reset\"]\r\n        stdout.write(c.join(h2))\r\n        stdout.write(\"\\n\\r\")\r\n        stdout.flush()\r\n\r\n        if self._csvfile:\r\n            header_row = []\r\n            for m in self.values():\r\n                if isinstance(m, MultiMetric):\r\n                    for subm in m.values():\r\n                        header_row.append(\r\n                            \"{}_{}\".format(m.title, subm.title)\r\n                        )\r\n                else:\r\n                    if m.subtitle:\r\n                        header_row.append(\r\n                            \"{}_{}\".format(m.title, m.subtitle)\r\n                        )\r\n                    else:\r\n                        header_row.append(m.title)\r\n            self._write_csv_row(header_row, rewrite=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_line(self, fix=True):\r\n        cells = []\r\n        csv_values = []\r\n        for m in self.values():\r\n            cells.append(m.render_value(fix=fix))\r\n            if isinstance(m, MultiMetric):\r\n                for sub in m.values():\r\n                    csv_values.append(sub.to_csv())\r\n            else:\r\n                csv_values.append(m.to_csv())\r\n            if fix:\r\n                m.reset()\r\n\r\n        if fix and self._csvfile:\r\n            self._write_csv_row(csv_values)\r\n\r\n        c = _ansi[\"gray\"] + \"|\" + _ansi[\"reset\"]\r\n\r\n        if self._last_line_fixed:\r\n            stdout.write(\"\\n\\r\")\r\n        else:\r\n            stdout.write(\"\\r\")\r\n\r\n        if not fix:\r\n            stdout.write(_ansi[\"reverse\"])\r\n\r\n        stdout.write(c.join(cells))\r\n        stdout.flush()\r\n\r\n        self._last_line_fixed = fix", "response": "Output a line containing values to console and csv file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchances the maximum number of log entries to retain at any given time", "response": "def max_entries(self, entries):\n        \"\"\"\n        Chance the maximum number of retained log entries\n        :param entries: The maximum number of log entries to retain at any given time\n        :type  entries: int\n        \"\"\"\n        self._debug_log.info('Changing maximum log entries from {old} to {new}'\n                             .format(old=self._log_entries, new=entries))\n        self._max_entries = entries\n\n        # This is a bit awkward, but since the maxlen can't be changed after instantiation, we have to reverse the\n        # deque before re-instantiating it, then reverse the new deque back in order to preserve the reverse order\n        # in case any entries are truncated\n        self._log_entries.reverse()\n        self._log_entries = deque(self._log_entries, maxlen=self._max_entries)\n        self._log_entries.reverse()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the maximum entries limit", "response": "def max_entries(self):\n        \"\"\"\n        Removes the maximum entry limit\n        \"\"\"\n        self._debug_log.info('Removing maximum entries restriction')\n        self._log_entries(deque(self._log_entries))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, user, message, groups):\n        self._debug_log.debug('Logging new Request entry')\n        request = Request(user, message, groups)\n        self._log_entries.appendleft(request)\n        return request", "response": "Add a new log entry to the list of logged entries."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add(self, message, request):\n        self._debug_log.debug('Logging new Response entry')\n        response = Response(message, request)\n        self._log_entries.appendleft(response)\n        return response", "response": "Add a new log entry to the list of logged entries."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(dimension, iterations):\n    objective_function = minimize(functions.sphere)\n    stopping_condition = max_iterations(iterations)\n    (solution, metrics) = optimize(objective_function=objective_function,\n                                   domain=Domain(-5.12, 5.12, dimension),\n                                   stopping_condition=stopping_condition,\n                                   parameters={'seed': 3758117674,\n                                               'rho': 1.0, 'e_s': 15, 'e_f': 5},\n                                   velocity_update=gc_velocity_update,\n                                   parameter_update=update_rho,\n                                   measurements=[fitness_measurement])\n    return solution", "response": "Main function to execute gbest GC PSO algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading chunks from the HTTP client and return the next available entry in the buffer.", "response": "def read_chunks(self):\n        \"\"\"Read chunks from the HTTP client\"\"\"\n\n        if self.reading_chunks and self.got_chunk:\n            # we got on the fast-path and directly read from the buffer.\n            # if we continue to recurse, this is going to blow up the stack.\n            # so instead return\n            #\n            # NOTE: This actually is unnecessary as long as tornado guarantees that\n            #       ioloop.add_callback always gets dispatched via the main io loop\n            #       and they don't introduce a fast-path similar to read_XY\n            logger.debug(\"Fast-Path detected, returning...\")\n            return\n\n        while not self.got_request:\n            self.reading_chunks = True\n            self.got_chunk = False\n            # chunk starts with length, so read it. This will then subsequently also read the chunk\n            self.httpstream.read_until(\"\\r\\n\", self._chunk_length)\n            self.reading_chunks = False\n\n            if self.got_chunk:\n                # the previous read hit the fast path and read from the buffer\n                # instead of going through the main polling loop. This means we \n                # should iteratively issue the next request\n                logger.debug(\"Fast-Path detected, iterating...\")\n                continue\n            else:\n                break\n\n        # if we arrive here, we read the complete request or\n        # the ioloop has scheduled another call to read_chunks\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread the length of the next chunk.", "response": "def _chunk_length(self, data):\n        \"\"\"Received the chunk length\"\"\"\n\n        assert data[-2:] == \"\\r\\n\", \"CRLF\"\n\n        length = data[:-2].split(';')[0] # cut off optional length paramters\n        length = int(length.strip(), 16) # length is in hex\n\n        if length:\n            logger.debug('Got chunk length: %d', length)\n            self.httpstream.read_bytes(length + 2, self._chunk_data)\n        else:\n            logger.debug('Got last chunk (size 0)')\n            self.got_request = True\n            # enable input write event so the handler can finish things up \n            # when it has written all pending data\n            self.ioloop.update_handler(self.fd_stdin, self.ioloop.WRITE | self.ioloop.ERROR)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _chunk_data(self, data):\n\n        assert data[-2:] == \"\\r\\n\", \"CRLF\"\n\n        if self.gzip_decompressor:\n            if not self.gzip_header_seen:\n                assert data[:2] == '\\x1f\\x8b', \"gzip header\"\n                self.gzip_header_seen = True\n\n            self.process_input_buffer += self.gzip_decompressor.decompress(data[:-2])\n        else:\n            self.process_input_buffer += data[:-2]\n\n        self.got_chunk = True\n\n        if self.process_input_buffer:\n            # since we now have data in the buffer, enable write events again\n            logger.debug('Got data in buffer, interested in writing to process again')\n            self.ioloop.update_handler(self.fd_stdin, self.ioloop.WRITE | self.ioloop.ERROR)\n\n        # do NOT call read_chunks directly. This is to give git a chance to consume input.\n        # we don't want to grow the buffer unnecessarily.\n        # Additionally, this should mitigate the stack explosion mentioned in read_chunks\n        self.ioloop.add_callback(self.read_chunks)", "response": "Process data from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _handle_stdin_event(self, fd, events):\n\n        assert fd == self.fd_stdin\n\n        if events & self.ioloop.ERROR:\n            # An error at the end is expected since tornado maps HUP to ERROR\n            logger.debug('Error on stdin')\n            # ensure pipe is closed\n            if not self.process.stdin.closed:\n                self.process.stdin.close()\n            # remove handler\n            self.ioloop.remove_handler(self.fd_stdin)\n            # if all fds are closed, we can finish\n            return self._graceful_finish()\n\n        # got data ready\n        logger.debug('stdin ready for write')\n        if self.process_input_buffer:\n            count = os.write(fd, self.process_input_buffer)\n            logger.debug('Wrote first %d bytes of %d total', count, len(self.process_input_buffer))\n            self.process_input_buffer = self.process_input_buffer[count:]\n\n        if not self.process_input_buffer:\n            # consumed everything in the buffer\n            if self.got_request:\n                # we got the request and wrote everything to the process\n                # this means we can close stdin and stop handling events\n                # for it\n                logger.debug('Got complete request, closing stdin')\n                self.process.stdin.close()\n                self.ioloop.remove_handler(fd)\n            else:\n                # There is more data bound to come from the client\n                # so just disable write events for the moment until \n                # we got more to write\n                logger.debug('Not interested in write events on stdin anymore')\n                self.ioloop.update_handler(fd, self.ioloop.ERROR)", "response": "Handle events on stdin."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _handle_stdout_event(self, fd, events):\n\n        assert fd == self.fd_stdout\n\n        if events & self.ioloop.READ:\n            # got data ready to read\n            data = ''\n\n            # Now basically we have two cases: either the client supports\n            # HTTP/1.1 in which case we can stream the answer in chunked mode\n            # in HTTP/1.0 we need to send a content-length and thus buffer the complete output\n            if self.request.supports_http_1_1():\n                if not self.headers_sent:\n                    self.sent_chunks = True\n                    self.headers.update({'Date': get_date_header(), 'Transfer-Encoding': 'chunked'})\n                    data = 'HTTP/1.1 200 OK\\r\\n' + '\\r\\n'.join([ k + ': ' + v for k, v in self.headers.items()]) + '\\r\\n\\r\\n'\n\n                    if self.output_prelude:\n                        data += hex(len(self.output_prelude))[2:] + \"\\r\\n\" # cut off 0x\n                        data += self.output_prelude + \"\\r\\n\"\n\n                    self.headers_sent = True\n\n                payload = os.read(fd, 8192)\n                if events & self.ioloop.ERROR: # there might be data remaining in the buffer if we got HUP, get it all\n                    remainder = True\n                    while remainder != '': # until EOF\n                        remainder = os.read(fd, 8192)\n                        payload += remainder\n\n                data += hex(len(payload))[2:] + \"\\r\\n\" # cut off 0x\n                data += payload + \"\\r\\n\"\n\n            else:\n                if not self.headers_sent:\n                    # Use the over-eager blocking read that will get everything until we hit EOF\n                    # this might actually be somewhat dangerous as noted in the subprocess documentation\n                    # and lead to a deadlock. This is only a legacy mode for HTTP/1.0 clients anyway,\n                    # so we might want to remove it entirely anyways\n                    payload = self.process.stdout.read()\n                    self.headers.update({'Date': get_date_header(), 'Content-Length': str(len(payload))})\n                    data = 'HTTP/1.0 200 OK\\r\\n' + '\\r\\n'.join([ k + ': ' + v for k, v in self.headers.items()]) + '\\r\\n\\r\\n'\n                    self.headers_sent = True\n                    data += self.output_prelude + payload\n                else:\n                    # this is actually somewhat illegal as it messes with content-length but \n                    # it shouldn't happen anyways, as the read above should have read anything\n                    # python docs say this can happen on ttys...\n                    logger.error(\"This should not happen\")\n                    data = self.process.stdout.read()\n\n            if len(data) == 8200:\n                self.number_of_8k_chunks_sent += 1\n            else:\n                if self.number_of_8k_chunks_sent > 0:\n                    logger.debug('Sent %d * 8192 bytes', self.number_of_8k_chunks_sent)\n                    self.number_of_8k_chunks_sent = 0\n\n                logger.debug('Sending stdout to client %d bytes: %r', len(data), data[:20])\n            self.request.write(data)\n\n        # now we can also have an error. This is because tornado maps HUP onto error\n        # therefore, no elif here!\n        if events & self.ioloop.ERROR:\n            logger.debug('Error on stdout')\n            # ensure file is closed\n            if not self.process.stdout.closed:\n                self.process.stdout.close()\n            # remove handler\n            self.ioloop.remove_handler(self.fd_stdout)\n            # if all fds are closed, we can finish\n            return self._graceful_finish()", "response": "Handle events from the stdout of the process."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _graceful_finish(self):\n\n        if not self.process.stdout.closed or not self.process.stderr.closed:\n            return # stdout/stderr still open\n\n        if not self.process.stdin.closed:\n            self.process.stdin.close()\n\n        if self.number_of_8k_chunks_sent > 0:\n            logger.debug('Sent %d * 8k chunks', self.number_of_8k_chunks_sent)\n\n        logger.debug(\"Finishing up. Process poll: %r\", self.process.poll())\n\n        if not self.headers_sent:\n            retval = self.process.poll()\n            if retval != 0:\n                logger.warning(\"Empty response. Git return value: \" + str(retval))\n                payload = \"Did not produce any data. Errorcode: \" + str(retval)\n                data = 'HTTP/1.1 500 Internal Server Error\\r\\nDate: %s\\r\\nContent-Length: %d\\r\\n\\r\\n' % (get_date_header(), len(payload))\n                self.headers_sent = True\n                data += payload\n                self.request.write(data)\n            else:\n                data = 'HTTP/1.1 200 Ok\\r\\nDate: %s\\r\\nContent-Length: 0\\r\\n\\r\\n' % get_date_header()\n                self.headers_sent = True\n                self.request.write(data)\n\n        # if we are in chunked mode, send end chunk with length 0\n        elif self.sent_chunks:\n            logger.debug(\"End chunk\")\n            self.request.write(\"0\\r\\n\")\n            #we could now send some more headers resp. trailers\n            self.request.write(\"\\r\\n\")\n\n        self.request.finish()", "response": "Detect if process has closed pipes and we can finish"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _genTimeoutList(self, const):\n        result = {}\n\n        for v in range(128):\n            x = v & 0x0F\n            y = (v >> 4) & 0x07\n\n            if not y or (y and x > 7):\n                result[const * x * 2**y] = v\n\n        self._log and self._log.debug(\"Timeout list: %s\", result)\n        return result", "response": "Generates a dict of the valid timeout values for the given const."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding all the connected devices and store the results in a class member object.", "response": "def findConnectedDevices(self):\n        \"\"\"\n        Find all the devices on the serial buss and store the results in a\n        class member object.\n        \"\"\"\n        tmpTimeout = self._serial.timeout\n        self._serial.timeout = 0.01\n\n        for dev in range(128):\n            device = self._getDeviceID(dev)\n\n            if device is not None and int(device) not in self._deviceConfig:\n                config = self._deviceConfig.setdefault(int(device), {})\n                self._deviceCallback(device, config)\n                self._log and self._log.info(\n                    \"Found device '%s' with configuration: %s\", device, config)\n\n        self._serial.timeout = tmpTimeout"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setCompactProtocol(self):\n        self._compact = True\n        self._serial.write(bytes(self._BAUD_DETECT))\n        self._log and self._log.debug(\"Compact protocol has been set.\")", "response": "Set the compact protocol."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the pololu protocol.", "response": "def setPololuProtocol(self):\n        \"\"\"\n        Set the pololu protocol.\n        \"\"\"\n        self._compact = False\n        self._log and self._log.debug(\"Pololu protocol has been set.\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the data to the device.", "response": "def _writeData(self, command, device, params=()):\n        \"\"\"\n        Write the data to the device.\n\n        :Parameters:\n          command : `int`\n            The command to write to the device.\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol.\n          params : `tuple`\n            Sequence of bytes to write.\n\n        :Exceptions:\n          * `SerialTimeoutException`\n            If the low level serial package times out.\n          * `SerialException`\n            IO error when the port is not open.\n        \"\"\"\n        sequence = []\n\n        if self._compact:\n            sequence.append(command | 0x80)\n        else:\n            sequence.append(self._BAUD_DETECT)\n            sequence.append(device)\n            sequence.append(command)\n\n        for param in params:\n            sequence.append(param)\n\n        if self._crc:\n            sequence.append(crc7(sequence))\n\n        self._serial.write(bytearray(sequence))\n        self._log and self._log.debug(\"Wrote byte sequence: %s\",\n                                      [hex(num) for num in sequence])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the firmware version of the specified hardware device.", "response": "def _getFirmwareVersion(self, device):\n        \"\"\"\n        Get the firmware version.\n\n        :Parameters:\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol.\n\n        :Returns:\n          An integer indicating the version number.\n        \"\"\"\n        cmd = self._COMMAND.get('get-fw-version')\n        self._writeData(cmd, device)\n\n        try:\n            result = self._serial.read(size=1)\n            result = int(result)\n        except serial.SerialException as e:\n            self._log and self._log.error(\"Error: %s\", e, exc_info=True)\n            raise e\n        except ValueError as e:\n            result = None\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the error message or value stored in the Qik hardware.", "response": "def _getError(self, device, message):\n        \"\"\"\n        Get the error message or value stored in the Qik hardware.\n\n        :Parameters:\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol.\n          message : `bool`\n            If set to `True` a text message will be returned, if set to `False`\n            the integer stored in the Qik will be returned.\n\n        :Returns:\n          A list of text messages, integers, or and empty list. See the\n          `message` parameter above.\n        \"\"\"\n        cmd = self._COMMAND.get('get-error')\n        self._writeData(cmd, device)\n        result = []\n        bits = []\n\n        try:\n            num = self._serial.read(size=1)\n            num = ord(num)\n        except serial.SerialException as e:\n            self._log and self._log.error(\"Error: %s\", e, exc_info=True)\n            raise e\n        except TypeError as e:\n            num = 0\n\n        for i in range(7, -1, -1):\n            bit = num & (1 << i)\n\n            if bit:\n                if message:\n                    result.append(self._ERRORS.get(bit))\n                else:\n                    result.append(bit)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlowing level method used for all get config commands. :Parameters: num : `int` Number that indicates the config option to get from the hardware. device : `int` The device is the integer number of the hardware devices ID and is only used with the Pololu Protocol. :Returns: An integer representing the value stored in the hardware device.", "response": "def _getConfig(self, num, device):\n        \"\"\"\n        Low level method used for all get config commands.\n\n        :Parameters:\n          num : `int`\n            Number that indicates the config option to get from the hardware.\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol.\n\n        :Returns:\n          An integer representing the value stored in the hardware device.\n        \"\"\"\n        cmd = self._COMMAND.get('get-config')\n        self._writeData(cmd, device, params=(num,))\n\n        try:\n            result = self._serial.read(size=1)\n            result = ord(result)\n        except serial.SerialException as e:\n            self._log and self._log.error(\"Error: %s\", e, exc_info=True)\n            raise e\n        except TypeError as e:\n            result = None\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the PWM frequency stored on the hardware device.", "response": "def _getPWMFrequency(self, device, message):\n        \"\"\"\n        Get the PWM frequency stored on the hardware device.\n\n        :Parameters:\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol.\n          message : `bool`\n            If set to `True` a text message will be returned, if set to `False`\n            the integer stored in the Qik will be returned.\n\n        :Returns:\n          A text message or an int. See the `message` parameter above.\n        \"\"\"\n        result = self._getConfig(self.PWM_PARAM, device)\n        freq, msg = self._CONFIG_PWM.get(result, (result, 'Invalid Frequency'))\n\n        if message:\n            result = msg\n        else:\n            result = freq\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the serial timeout value stored on the hardware device.", "response": "def _getSerialTimeout(self, device):\n        \"\"\"\n        Get the serial timeout stored on the hardware device.\n\n        Caution, more that one value returned from the Qik can have the same\n        actual timeout value according the the formula below. I have verified\n        this as an idiosyncrasy of the Qik itself. There are only a total of\n        72 unique values that the Qik can logically use the remaining 56\n        values are repeats of the 72.\n\n        :Parameters:\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol.\n\n        :Returns:\n          The timeout value in seconds.\n        \"\"\"\n        num = self._getConfig(self.SERIAL_TIMEOUT, device)\n\n        if isinstance(num, int):\n            x = num & 0x0F\n            y = (num >> 4) & 0x07\n            result = self.DEFAULT_SERIAL_TIMEOUT * x * pow(2, y)\n        else:\n            result = num\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _setConfig(self, num, value, device, message):\n        cmd = self._COMMAND.get('set-config')\n        self._writeData(cmd, device, params=(num, value, 0x55, 0x2A))\n\n        try:\n            result = self._serial.read(size=1)\n            result = ord(result)\n        except serial.SerialException as e:\n            self._log and self._log.error(\"Error: %s\", e, exc_info=True)\n            raise e\n        except TypeError as e:\n            result = None\n\n        if result is not None and message:\n            result = self._CONFIG_RETURN.get(\n                result, 'Unknown return value: {}'.format(result))\n\n        return result", "response": "Private method to set the value of the option in the hardware device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _setDeviceID(self, value, device, message):\n        if value != device:\n            result = self._setConfig(self.DEVICE_ID, value, device, message)\n            self._deviceConfig[value] = self._deviceConfig.pop(device)\n        elif message:\n            result = self._CONFIG_RETURN.get(0)\n        elif not message:\n            result = 0\n\n        return result", "response": "Sets the hardware device ID."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the PWM frequency.", "response": "def _setPWMFrequency(self, pwm, device, message):\n        \"\"\"\n        Set the PWM frequency.\n\n        :Parameters:\n          pwm : `int`\n            The PWN frequency to set in hertz.\n          device : `int`\n            The device is the integer number of the hardware devices ID and\n            is only used with the Pololu Protocol.\n          message : `bool`\n            If set to `True` a text message will be returned, if set to `False`\n            the integer stored in the Qik will be returned.\n\n        :Returns:\n          A text message or an int. See the `message` parameter above.\n        \"\"\"\n        value = self._CONFIG_PWM_TO_VALUE.get(pwm)\n\n        if value is None:\n            msg = \"Invalid frequency: {}\".format(pwm)\n            self._log and self._log.error(msg)\n            raise ValueError(msg)\n\n        self._deviceConfig[device]['pwm'] = value\n        return self._setConfig(self.PWM_PARAM, value, device, message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _setMotorShutdown(self, value, device, message):\n        value = self._BOOL_TO_INT.get(value, 1)\n        self._deviceConfig[device]['shutdown'] = value\n        return self._setConfig(self.MOTOR_ERR_SHUTDOWN, value, device, message)", "response": "Sets the motor shutdown on error status stored on the hardware device."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _setSerialTimeout(self, timeout, device, message):\n        timeout = min(self._timeoutKeys, key=lambda x: abs(x-timeout))\n        value = self._timeoutToValue.get(timeout, 0)\n        self._deviceConfig[device]['timeout'] = timeout\n        return self._setConfig(self.SERIAL_TIMEOUT, value, device, message)", "response": "Sets the serial timeout on the hardware device."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _setSpeed(self, speed, motor, device):\n        reverse = False\n\n        if speed < 0:\n            speed = -speed\n            reverse = True\n\n        # 0 and 2 for Qik 2s9v1, 0, 2, and 4 for 2s12v10\n        if self._deviceConfig[device]['pwm'] in (0, 2, 4,) and speed > 127:\n            speed = 127\n\n        if speed > 127:\n            if speed > 255:\n                speed = 255\n\n            if reverse:\n                cmd = self._COMMAND.get('{}-reverse-8bit'.format(motor))\n            else:\n                cmd = self._COMMAND.get('{}-forward-8bit'.format(motor))\n\n            speed -= 128\n        else:\n            if reverse:\n                cmd = self._COMMAND.get('{}-reverse-7bit'.format(motor))\n            else:\n                cmd = self._COMMAND.get('{}-forward-7bit'.format(motor))\n\n        if not cmd:\n            msg = \"Invalid motor specified: {}\".format(motor)\n            self._log and self._log.error(msg)\n            raise ValueError(msg)\n\n        self._writeData(cmd, device, params=(speed,))", "response": "Sets the frequency of the current frequency of the specified motor and device."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_key_names(self):\n        names = []\n        for (k, _) in self.items():\n            names.append(k)\n        return names", "response": "Gets all keys of all elements stored in this map."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding new elements to this map.", "response": "def append(self, map):\n        \"\"\"\n        Appends new elements to this map.\n\n        :param map: a map with elements to be added.\n        \"\"\"\n        if isinstance(map, dict):\n            for (k, v) in map.items():\n                key = StringConverter.to_string(k)\n                value = v\n                self.put(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting a new value to map element", "response": "def set_as_object(self, value):\n        \"\"\"\n        Sets a new value to map element\n\n        :param value: a new element or map value.\n        \"\"\"\n        self.clear()\n        map = MapConverter.to_map(value)\n        self.append(map)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_as_map(self, key):\n        value = self.get(key)\n        return AnyValueMap.from_value(value)", "response": "Converts map element into an AnyValueMap or returns empty AnyValueMap if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_as_nullable_string(self, key):\n        value = self.get(key)\n        return StringConverter.to_nullable_string(value)", "response": "Converts map element into a string or returns None if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert map element into a string or returns \"\" if conversion is not possible.", "response": "def get_as_string(self, key):\n        \"\"\"\n        Converts map element into a string or returns \"\" if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :return: string value ot the element or \"\" if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return StringConverter.to_string(value)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert map element into a string or returns default value if conversion is not possible.", "response": "def get_as_string_with_default(self, key, default_value):\n        \"\"\"\n        Converts map element into a string or returns default value if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :param default_value: the default value\n\n        :return: string value ot the element or default value if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return StringConverter.to_string_with_default(value, default_value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_as_nullable_boolean(self, key):\n        value = self.get(key)\n        return BooleanConverter.to_nullable_boolean(value)", "response": "Converts map element into a boolean or returns None if conversion is not possible\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert map element into a boolean or returns false if conversion is not possible.", "response": "def get_as_boolean(self, key):\n        \"\"\"\n        Converts map element into a boolean or returns false if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :return: boolean value ot the element or false if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return BooleanConverter.to_boolean(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_as_boolean_with_default(self, key, default_value):\n        value = self.get(key)\n        return BooleanConverter.to_boolean_with_default(value, default_value)", "response": "Converts map element into a boolean or returns default value if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_as_nullable_integer(self, key):\n        value = self.get(key)\n        return IntegerConverter.to_nullable_integer(value)", "response": "Converts map element into an integer or returns None if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting map element into an integer or returns 0 if conversion is not possible.", "response": "def get_as_integer(self, key):\n        \"\"\"\n        Converts map element into an integer or returns 0 if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :return: integer value ot the element or 0 if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return IntegerConverter.to_integer(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_as_integer_with_default(self, key, default_value):\n        value = self.get(key)\n        return IntegerConverter.to_integer_with_default(value, default_value)", "response": "Converts map element into an integer or returns default value if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts map element into a float or returns None if conversion is not possible.", "response": "def get_as_nullable_float(self, key):\n        \"\"\"\n        Converts map element into a float or returns None if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :return: float value of the element or None if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return FloatConverter.to_nullable_float(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts map element into a float or returns 0 if conversion is not possible.", "response": "def get_as_float(self, key):\n        \"\"\"\n        Converts map element into a float or returns 0 if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :return: float value ot the element or 0 if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return FloatConverter.to_float(value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting map element into a float or returns default value if conversion is not possible.", "response": "def get_as_float_with_default(self, key, default_value):\n        \"\"\"\n        Converts map element into a float or returns default value if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :param default_value: the default value\n\n        :return: float value ot the element or default value if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return FloatConverter.to_float_with_default(value, default_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts map element into a Date or returns None if conversion is not possible.", "response": "def get_as_nullable_datetime(self, key):\n        \"\"\"\n        Converts map element into a Date or returns None if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :return: Date value of the element or None if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return DateTimeConverter.to_nullable_datetime(value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_as_datetime(self, key):\n        value = self.get(key)\n        return DateTimeConverter.to_datetime(value)", "response": "Converts map element into a Date or returns the current date if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting map element into a Date or returns default value if conversion is not possible.", "response": "def get_as_datetime_with_default(self, key, default_value):\n        \"\"\"\n        Converts map element into a Date or returns default value if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :param default_value: the default value\n\n        :return: Date value ot the element or default value if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return DateTimeConverter.to_datetime_with_default(value, default_value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_as_nullable_type(self, key, value_type):\n        value = self.get(key)\n        return TypeConverter.to_nullable_type(value_type, value)", "response": "Converts map element into an element value defined by specied typecode. If conversion is not possible it returns None."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts map element into a value defined by specied typecode.", "response": "def get_as_type(self, key, value_type):\n        \"\"\"\n        Converts map element into a value defined by specied typecode.\n        If conversion is not possible it returns default value for the specified type.\n\n        :param key: an index of element to get.\n\n        :param value_type: the TypeCode that defined the type of the result\n\n        :return: element value defined by the typecode or default if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return TypeConverter.to_type(value_type, value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_as_type_with_default(self, key, value_type, default_value):\n        value = self.get(key)\n        return TypeConverter.to_type_with_default(value_type, value, default_value)", "response": "Converts map element into a value defined by specied typecode. If conversion is not possible it returns default value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting map element into an AnyValueMap or returns empty AnyValueMap if conversion is not possible.", "response": "def get_as_array(self, key):\n        \"\"\"\n        Converts map element into an AnyValueMap or returns empty AnyValueMap if conversion is not possible.\n\n        :param key: an index of element to get.\n\n        :return: AnyValueMap value of the element or empty AnyValueMap if conversion is not supported.\n        \"\"\"\n        value = self.get(key)\n        return AnyValueMap.from_value(value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_as_nullable_map(self, key):\n        value = self.get_as_object(key)\n        return AnyValueMap.from_value(value)", "response": "Converts map element into an AnyValueMap or returns None if conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert map element into an AnyValueMap or returns default value if conversion is not possible.", "response": "def get_as_map_with_default(self, key, default_value):\n        \"\"\"\n        Converts map element into an AnyValueMap or returns default value if conversion is not possible.\n\n        :param key: a key of element to get.\n\n        :param default_value: the default value\n\n        :return: AnyValueMap value of the element or default value if conversion is not supported.\n        \"\"\"\n        value = self.get_as_nullable_map(key)\n        return MapConverter.to_map_with_default(value, default_value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_maps(*maps):\n        result = AnyValueMap()\n        \n        if maps == None or len(maps) == 0:\n            return result\n\n        for map in maps:\n            for (key, value) in map.items():\n                key = StringConverter.to_string(key)\n                result.put(key, value)\n\n        return result", "response": "Creates an AnyValueMap object by merging two or more maps."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlaunches browser depending on platform", "response": "def open(url):\n    \"\"\" Launches browser depending on os \"\"\"\n    if sys.platform == 'win32':\n        os.startfile(url)\n    elif sys.platform == 'darwin':\n        subprocess.Popen(['open', url])\n    else:\n        try:\n            subprocess.Popen(['xdg-open', url])\n        except OSError:\n            import webbrowser\n            webbrowser.open(url)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef print_arguments():\n    def decorator(function):\n        def inner(*args, **kwargs):\n            if args:\n                print \"Passed arguments:\"\n                for i in args:\n                    pp.pprint(i)\n            print \"Passed keyword arguments:\"\n            pp.pprint(kwargs)\n            return function(*args, **kwargs)\n        return inner\n    return decorator", "response": "Decorator that prints the arguments passed in to the function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_subservice(self, obj):\n        # ensure there is not already a sub-service\n        if self.obj is not None:\n            raise RouteAlreadyRegisteredError(\n                'Service Router ({0} - {1}): Route {2} already has a '\n                'sub-service handler'\n                .format(id(self), self.service_name, self.uri))\n\n        # warn if any methods are already registered\n        if len(self.methods):\n            logger.debug(\n                'WARNING: Service Router ({0} - {1}): Methods detected '\n                'on Route {2}. Sub-Service {3} may be hidden.'\n                .format(id(self), self.service_name, self.uri, obj.name))\n\n        # Ensure we do not have any circular references\n        assert(obj != self.parent_obj)\n\n        # if no errors, save the object and update the URI\n        self.obj = obj\n        self.obj.base_url = '{0}/{1}'.format(self.uri, self.service_name)", "response": "Adds a sub - service object to the route."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_uris(self, new_uri):\n        self.uri = new_uri\n\n        # if there is a sub-service, update it too\n        if self.obj:\n            self.obj.base_url = '{0}/{1}'.format(self.uri, self.service_name)", "response": "Update all URIS. n / a\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister a method and handler function.", "response": "def register_method(self, method, fn):\n        \"\"\"Register an HTTP method and handler function.\n\n        :param method: string, HTTP verb\n        :param fn: python function handling the request\n        :raises: RouteAlreadyRegisteredError if the route is already registered\n        :returns: n/a\n        \"\"\"\n\n        # ensure the HTTP verb is not already registered\n        if method not in self.methods.keys():\n            logger.debug('Service Router ({0} - {1}): Adding method {2} on '\n                         'route {3}'\n                         .format(id(self),\n                                 self.service_name,\n                                 method,\n                                 self.uri))\n            self.methods[method] = fn\n\n        else:\n            raise RouteAlreadyRegisteredError(\n                'Service Router ({0} - {1}): Method {2} already registered '\n                'on Route {3}'\n                .format(id(self),\n                        self.service_name,\n                        method,\n                        self.uri))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates that the given regex is valid for StackInABox routing?", "response": "def validate_regex(regex, sub_service):\n        \"\"\"Is the regex valid for StackInABox routing?\n\n        :param regex: Python regex object to match the URI\n        :param sub_service: boolean for whether or not the regex is for\n                            a sub-service\n\n        :raises: InvalidRouteRegexError if the regex does not meet the\n                 requirements.\n        \"\"\"\n        # The regex generated by stackinabox starts with ^\n        # and ends with $. Enforce that the provided regex does the same.\n\n        if regex.pattern.startswith('^') is False:\n            logger.debug('StackInABoxService: Pattern must start with ^')\n            raise InvalidRouteRegexError('Pattern must start with ^')\n\n        # Note: pattern may end with $ even if sub_service is True\n        if regex.pattern.endswith('$') is False and sub_service is False:\n            logger.debug('StackInABoxService: Pattern must end with $')\n            raise InvalidRouteRegexError('Pattern must end with $')\n\n        # Enforce that if the pattern does not end with $ that it is a service\n        if regex.pattern.endswith('$') is True and sub_service is True:\n            logger.debug(\n                'StackInABoxService: Sub-Service RegEx Pattern must not '\n                'end with $')\n            raise InvalidRouteRegexError('Pattern must end with $')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_service_regex(base_url, service_url, sub_service):\n        # if the specified service_url is already a regex\n        # then just use. Otherwise create what we need\n        if StackInABoxService.is_regex(service_url):\n            logger.debug('StackInABoxService: Received regex {0} for use...'\n                         .format(service_url.pattern))\n\n            # Validate the regex against StackInABoxService requirement\n            StackInABoxService.validate_regex(service_url, sub_service)\n\n            return service_url\n        else:\n            regex = '^{0}{1}$'.format('', service_url)\n            logger.debug('StackInABoxService: {0} + {1} -> {2}'\n                         .format(base_url, service_url, regex))\n            return re.compile(regex)", "response": "Get the regex for a given service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef base_url(self, value):\n        logger.debug('StackInABoxService ({0}:{1}) Updating Base URL '\n                     'from {2} to {3}'\n                     .format(self.__id,\n                             self.name,\n                             self.__base_url,\n                             value))\n        self.__base_url = value\n        for k, v in six.iteritems(self.routes):\n            v['regex'] = StackInABoxService.get_service_regex(\n                value,\n                v['uri'],\n                v['handlers'].is_subservice)", "response": "Set the Base URI value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reset(self):\n        logger.debug('StackInABoxService ({0}): Reset'\n                     .format(self.__id, self.name))\n        self.base_url = '/{0}'.format(self.name)\n        logger.debug('StackInABoxService ({0}): Hosting Service {1}'\n                     .format(self.__id, self.name))", "response": "Reset the service to its initial state."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef try_handle_route(self, route_uri, method, request, uri, headers):\n        uri_path = route_uri\n        if '?' in uri:\n            logger.debug('StackInABoxService ({0}:{1}): Found query string '\n                         'removing for match operation.'\n                         .format(self.__id, self.name))\n            uri_path, uri_qs = uri.split('?')\n            logger.debug('StackInABoxService ({0}:{1}): uri =  \"{2}\", '\n                         'query = \"{3}\"'\n                         .format(self.__id, self.name, uri_path, uri_qs))\n\n        for k, v in six.iteritems(self.routes):\n            logger.debug('StackInABoxService ({0}:{1}): Checking if '\n                         'route {2} handles...'\n                         .format(self.__id, self.name, v['uri']))\n            logger.debug('StackInABoxService ({0}:{1}): ...using regex '\n                         'pattern {2} against {3}'\n                         .format(self.__id,\n                                 self.name,\n                                 v['regex'].pattern,\n                                 uri_path))\n            if v['regex'].match(uri_path):\n                logger.debug('StackInABoxService ({0}:{1}): Checking if '\n                             'route {2} handles method {2}...'\n                             .format(self.__id, self.name, v['uri'], method))\n                return v['handlers'](method,\n                                     request,\n                                     uri,\n                                     headers)\n        return (595, headers, 'Route ({0}) Not Handled'.format(uri))", "response": "Try to handle the supplied request on the specified routing URI."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sub_request(self, method, request, uri, headers):\n        logger.debug('StackInABoxService ({0}:{1}): Sub-Request Received '\n                     '{2} - {3}'\n                     .format(self.__id, self.name, method, uri))\n        return self.request(method, request, uri, headers)", "response": "Handle the supplied sub - service request on the specified routing URI."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating the route for the URI.", "response": "def create_route(self, uri, sub_service):\n        \"\"\"Create the route for the URI.\n\n        :param uri: string - URI to be routed\n        :param sub_service: boolean - is the URI for a sub-service\n\n        :returns: n/a\n        \"\"\"\n        if uri not in self.routes.keys():\n            logger.debug('Service ({0}): Creating routes'\n                         .format(self.name))\n            self.routes[uri] = {\n                'regex': StackInABoxService.get_service_regex(self.base_url,\n                                                              uri,\n                                                              sub_service),\n                'uri': uri,\n                'handlers': StackInABoxServiceRouter(self.name,\n                                                     uri,\n                                                     None,\n                                                     self)\n            }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register(self, method, uri, call_back):\n        found = False\n\n        self.create_route(uri, False)\n        self.routes[uri]['handlers'].register_method(method,\n                                                     call_back)", "response": "Register a class instance function to handle a request."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_subservice(self, uri, service):\n        found = False\n\n        self.create_route(uri, True)\n        self.routes[uri]['handlers'].set_subservice(service)", "response": "Register a class instance to handle a URI."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndefines the pin as input mode.", "response": "def define_as_input(self, pin, pullup=False):\n        \"\"\"Set the input or output mode for a specified pin.  Mode should be\n        either GPIO.OUT or GPIO.IN.\n        \"\"\"\n        self._validate_channel(pin)\n        # Set bit to 1 for input or 0 for output.\n        self.iodir[int(pin/8)] |= 1 << (int(pin%8))\n        self._write_iodir()\n        self.pullup(pin, pullup)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef define_as_output(self, pin):\n        self._validate_channel(pin)\n        # Set bit to 1 for input or 0 for output.\n        self.iodir[int(pin/8)] &= ~(1 << (int(pin%8)))\n        self._write_iodir()", "response": "Define the input or output mode for a specified pin."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _output_pins(self, pins):\n        [self._validate_channel(pin) for pin in pins.keys()]\n        # Set each changed pin's bit.\n        for pin, value in iter(pins.items()):\n            if value:\n                self.gpio[int(pin/8)] |= 1 << (int(pin%8))\n            else:\n                self.gpio[int(pin/8)] &= ~(1 << (int(pin%8)))\n        # Write GPIO state.\n        self._write_gpio()", "response": "Set multiple pins high or low at once."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads multiple pins specified in the given list and return list of pin values GPIO. HIGH or GPIO. LOW if the pin is pulled low or GPIO. HIGH or GPIO. LOW if the pin is pulled low or GPIO. HIGH or GPIO. LOW if the pin is pulled high or GPIO. LOW if the pin is pulled low.", "response": "def _input_pins(self, pins):\n        \"\"\"Read multiple pins specified in the given list and return list of pin values\n        GPIO.HIGH/True if the pin is pulled high, or GPIO.LOW/False if pulled low.\n        \"\"\"\n        [self._validate_channel(pin) for pin in pins]\n        # Get GPIO state.\n        gpio = self.i2c.read_list(self.GPIO, self.gpio_bytes)\n        # Return True if pin's bit is set.\n        return [(gpio[int(pin/8)] & 1 << (int(pin%8))) > 0 for pin in pins]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pullup(self, pin, enabled):\n        self._validate_channel(pin)\n        if enabled:\n            self.gppu[int(pin/8)] |= 1 << (int(pin%8))\n        else:\n            self.gppu[int(pin/8)] &= ~(1 << (int(pin%8)))\n        self._write_gppu()", "response": "Turn on or off the pull - up resistor for the specified pin."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _write_gpio(self, gpio=None):\n        if gpio is not None:\n            self.gpio = gpio\n        self.i2c.write_list(self.GPIO, self.gpio)", "response": "Write the specified byte value to the GPIO registor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _write_iodir(self, iodir=None):\n        if iodir is not None:\n            self.iodir = iodir\n        self.i2c.write_list(self.IODIR, self.iodir)", "response": "Write the specified byte value to the IODIR registor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the specified byte value to the GPPU registor.", "response": "def _write_gppu(self, gppu=None):\n        \"\"\"Write the specified byte value to the GPPU registor.  If no value\n        specified the current buffered value will be written.\n        \"\"\"\n        if gppu is not None:\n            self.gppu = gppu\n        self.i2c.write_list(self.GPPU, self.gppu)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrestore B6 + M8 entry to original BLAST + B6 format", "response": "def write(self, default: bool=False):\n        \"\"\"Restore B6/M8 entry to original format\n\n        Args:\n            default (bool): output entry in default BLAST+ B6 format \n\n        Returns:\n            str: properly formatted string containing the B6/M8 entry\n        \"\"\"\n\n        none_type = type(None)\n\n        if default:  # Default order of format specifiers\n            ordered_vals = ['query', 'subject', 'identity', 'length', \n                            'mismatches', 'gaps', 'query_start', 'query_end', \n                            'subject_start', 'subject_end', 'evalue', \n                            'bitscore']\n        else:  # Original order of B6 entry format specifiers\n            try:\n                ordered_vals = [self.custom_fs[i] if i in self.custom_fs \n                            else getattr(self, i) for i in self.fs_order]\n            except TypeError:\n                ordered_vals = [getattr(self, i) for i in self.fs_order]\n\n        # Format entry for writing\n        fstr = \"\\t\".join(['-' if type(i) == none_type else str(i) for i in \n                        ordered_vals])\n\n        return '{}{}'.format(fstr, os.linesep)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\niterates over the B6 file and return all entries in the B6 file.", "response": "def iterate(self, start_line=None, header: list=['qaccver', 'saccver', \n        'pident', 'length', 'mismatch', 'gapopen', 'qstart', 'qend', 'sstart',\n        'send', 'evalue', 'bitscore'], comments: bool=False):\n        \"\"\"Iterate over B6/M8 file and return B6/M8 entries\n\n        Args:\n            start_line (str): Next B6/M8 entry. If 'handle' has been partially\n                read and you want to start iterating at the next entry, read \n                the next B6/M8 entry and pass it to this variable when calling \n                b6_iter. See 'Examples' for proper usage.\n\n            header (list): List of custom format specifiers if B6 file not in \n                default Blast+ 6 format\n\n            comments (bool): Yields comments if True, else skips lines starting\n                with \"#\"\n\n        Yields:\n            B6Entry: class containing all B6/M8 data\n\n        Examples:\n            The following two examples demonstrate how to use b6_iter.\n            Note: These doctests will not pass, examples are only in doctest\n            format as per convention. bio_utils uses pytests for testing.\n\n            >>> for entry in b6_iter(open('test.b6out')):\n            ...     print(entry.query)  # Query ID\n            ...     print(entry.subject)  # Subject ID\n            ...     print(entry.identity)  # Percent identity between seqs\n            ...     print(entry.mismatches)  # Number mismatches in alignment\n            ...     print(entry.gaps)  # Number gaps in alignment\n            ...     print(entry.query_start)  # Start of alignment on query\n            ...     print(entry.query_end)  # End of alignment on query\n            ...     print(entry.subject_start)  # Start of align on subject\n            ...     print(entry.subject_end)  # End of alignment on subject\n            ...     print(entry.evalue)  # E-value of alignment\n            ...     print(entry.bitscore)  # Bitscore of alignment\n            ...     print(entry.write())  # Reconsitituted B6 entry\n\n            >>> b6_handle = open('test.b6out')\n            >>> next(b6_handle)  # Skip first line/entry\n            >>> next_line = next(b6_handle)  # Store next entry\n            >>> for entry in b6_iter(b6_handle, start_line=next_line):\n            ...     print(entry.query)  # Query ID\n            ...     print(entry.subject)  # Subject ID\n            ...     print(entry.identity)  # Percent identity between seqs\n            ...     print(entry.mismatches)  # Number mismatches in alignment\n            ...     print(entry.gaps)  # Number gaps in alignment\n            ...     print(entry.query_start)  # Start of alignment on query\n            ...     print(entry.query_end)  # End of alignment on query\n            ...     print(entry.subject_start)  # Start of align on subject\n            ...     print(entry.subject_end)  # End of alignment on subject\n            ...     print(entry.evalue)  # E-value of alignment\n            ...     print(entry.bitscore)  # Bitscore of alignment\n            ...     print(entry.write())  # Reconstituted B6 entry\n        \"\"\"\n\n        handle = self.handle\n\n        # Speed tricks: reduces function calls\n        split = str.split\n        strip = str.strip\n\n        # Map attribute names to default format specifier names\n        def_map = {'query_end': ('qend', str), \n                   'mismatches': ('mismatch', int), \n                   'identity': ('pident', float), \n                   'query': ('qaccver', str),\n                   'query_start': ('qstart', int), \n                   'subject_start': ('sstart', int), \n                   'bitscore': ('bitscore', float), \n                   'evalue': ('evalue', float), \n                   'gaps': ('gapopen', int), \n                   'subject_end': ('send', int),\n                   'length': ('length', int), \n                   'subject': ('saccver', str)\n                  }\n\n        def_map_rev = {j[0]: k for k, j in def_map.items()}\n        def_specs = list(def_map_rev.keys())\n\n        uheader = list(OrderedDict.fromkeys(header))\n        spec_order = [def_map_rev[i] if i in def_map_rev else i \\\n                      for i in uheader]\n\n        # Store order of format specifiers\n        h = {}\n        for index, specifier in enumerate(header):\n            if specifier not in h:  # Ignor duplicate columns\n                h[specifier] = index\n\n        # Begin reading text\n        if start_line is None:\n            line = next(handle)  # Read first B6/M8 entry\n        else:\n            line = start_line  # Set header to given header\n\n        # Check if input is text or bytestream\n        if (isinstance(line, bytes)):\n            def next_line(i):\n                return next(i).decode('utf-8')\n\n            line = strip(line.decode('utf-8'))\n        else:\n            next_line = next\n            line = strip(line)\n\n        # Manual 'for' loop isn't needed to read the file properly and quickly,\n        # unlike fasta_iter and fastq_iter, but it is necessary begin iterating\n        # partway through a file when the user gives a starting line.\n        try:  # Manually construct a for loop to improve speed by using 'next'\n\n            while True:  # Loop until StopIteration Exception raised\n\n                self.current_line += 1\n\n                data = B6Entry()\n                data.fs_order = spec_order  # All entries store original order\n\n                if line.startswith('#') and not comments:\n                    line = strip(next_line(handle))\n                    continue\n                elif line.startswith('#') and comments:\n                    yield line\n                    line = strip(next_line(handle))\n                    continue\n\n                split_line = split(line, '\\t')\n\n                # Replace empty values with None\n                spec_values = [None if i == '-' else i for i in split_line]\n\n                # Add default specifiers\n                def_attrs = data.__dict__.keys()\n                for attr in def_attrs:\n                    try:\n                        def_spec, spec_type = def_map[attr]\n                    except KeyError:\n                        continue\n\n                    try:\n                        value = spec_values[h[def_spec]]\n                    except KeyError:  # Custom format, no value\n                        continue\n                    except IndexError:\n                        current_line = self.current_line\n                        raise FormatError(\"line {!s}: the number of columns \"\n                            \"is less than the number of specifiers\"\\\n                            .format(current_line))\n\n                    if type(value) != type(None):\n                        try:\n                            value = spec_type(value)\n                        except ValueError:\n                            current_line = self.current_line\n                            raise FormatError(\"line {!s}: {} is of wrong type\"\\\n                                .format(current_line, def_spec))\n \n                    setattr(data, attr, value)\n\n                # Add non-default specifiers to custom_fs attribute\n                custom_specs = [i for i in sorted(h, key=h.get, reverse=False) \\\n                                if i not in def_specs]\n\n                if custom_specs:\n                    data.custom_fs = OrderedDict()\n                    for key in custom_specs:\n                        try:\n                            value = spec_values[h[key]]\n                        except IndexError:\n                            current_line = self.current_line\n                            raise FormatError(\"line {!s}: the number of \"\n                                \"columns is less than the number of \"\n                                \"specifiers\".format(current_line))\n\n                        data.custom_fs[key] = value\n\n                line = strip(next_line(handle))  # Raises StopIteration at EOF\n\n                yield data\n\n        except StopIteration:  # Yield last B6/M8 entry\n            yield data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninvert the given list of characters to the base of the current language.", "response": "def invert_shift(chars):\n    \"\"\"\n    >>> invert_shift(\"a\")\n    'A'\n    >>> invert_shift(\"A\")\n    'a'\n\n    >>> invert_shift(\"123 foo 456 BAR #!\")\n    '123 FOO 456 bar #!'\n    \"\"\"\n    result = \"\"\n    for char in chars:\n        if char in string.ascii_lowercase:\n#             log.critical(\"auto shift lowercase char %s to UPPERCASE\", repr(char))\n            char = char.upper()\n        elif char in string.ascii_uppercase:\n#             log.critical(\"auto shift UPPERCASE char %s to lowercase\", repr(char))\n            char = char.lower()\n        result += char\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def props_del(self):\n        endpoint = \"{bucket}/props\".format(bucket=self.path)\n\n        try:\n            async with self._client.delete(endpoint,\n                                           headers=self.headers) as r:\n                if r.status != 204:\n                    raise Error(\"Bucket {} not found}\".format(self.bucket))\n                return True\n        except ContentEncodingError:\n            \"\"\" Not error really \"\"\"\n            return True\n        except:\n            raise", "response": "Delete properties from the specified bucket."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete a key from the cache.", "response": "async def delete(self, key):\n        \"\"\" Fix me after support 204 code in aiohttp \"\"\"\n        try:\n            async with self._client.delete(self.path_keys(key)) as r:\n                if r.status not in [204, 404]:\n                    return False\n                return True\n        except ContentEncodingError:\n            \"\"\" Not error really \"\"\"\n            return True\n        except:\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading json and return simplejson object", "response": "def getJson(url):\n    \"\"\"Download json and return simplejson object\"\"\"\n    site = urllib2.urlopen(url, timeout=300)\n    return json.load(site)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads url and parse it with lxml. etree or lxml. html", "response": "def getWeb(url, isFeed):\n    \"\"\"Download url and parse it with lxml.\n    If \"isFeed\" is True returns lxml.etree\n    else, returns lxml.html\n    \"\"\"\n    socket.setdefaulttimeout(300)\n    loadedWeb = urllib2.build_opener()\n    loadedWeb.addheaders = getHeaders()\n    if isFeed:\n        web = etree.parse(loadedWeb.open(url))\n    else:\n        web = html.parse(loadedWeb.open(url))\n    return web"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rmSelf(f):\n    def new_f(*args, **kwargs):\n        newArgs = args[1:]\n        result = f(*newArgs, **kwargs)\n        return result\n    return new_f", "response": "Decorator to remove first argument from function f parameters."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef catchItem(f, theSpider=None):\n    def new_f(*args, **kwargs):\n        #print(\"thepath \"+os.getcwd())\n        #print(\"the spider\")\n        #print(str(theSpider))\n        items = f(*args, **kwargs)\n        if items is None:\n            return items\n        if isinstance(items, Item):\n            processItem(items, args, theSpider)\n        elif len(items) > 0:\n            if isinstance(items, ItemList):\n                    processItemList(items, args, theSpider)\n            else:\n                for item in items:\n                    #print(\"procesando items\")\n                    if isinstance(item, ItemList):\n                        processItemList(item, args, theSpider)\n                    elif isinstance(item, Item):\n                        processItem(item, args, theSpider)\n                    elif isinstance(item, str):\n                        aSpider = args[0]\n                        aSpider.parse(url=item)\n        return items\n    return new_f", "response": "Decorador ejecuta la funci\u00f3n parse y procesa una lista de items ejecuta la funci\u00f3n saveitem que corresponda."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npad the dialogues in the dataset.", "response": "def pad_dialogues(self, dialogues):\n        \"\"\"\n        Pad the entire dataset.\n        This involves adding padding at the end of each sentence, and in the case of\n        a hierarchical model, it also involves adding padding at the end of each dialogue,\n        so that every training sample (dialogue) has the same dimension.\n        \"\"\"        \n        self.log('info', 'Padding the dialogues ...')\n        \n        return [self.pad_dialogue(d) for d in dialogues]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show(self):\n        top = self.get_top_widget()\n        if isinstance(top, (list, tuple)):\n            for t in top:\n                if t is not None:\n                    t.show()\n        elif top is not None:\n            top.show_all()", "response": "Call show on each top widget or show_all if only one is known."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hide(self):\n        top = self.get_top_widget()\n        if isinstance(top, (list, tuple)):\n            for t in top:\n                if t is not None:\n                    t.hide_all()\n        elif top is not None:\n            top.hide_all()", "response": "Call hide_all on all known top widgets."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_parent_view(self, parent_view):\n        top = self.get_top_widget()\n        if isinstance(top, (list, tuple)):\n            for t in top:\n                if t is not None:\n                    t.set_transient_for(parent_view.get_top_widget())\n        elif top is not None:\n            top.set_transient_for(parent_view.get_top_widget())", "response": "Set the parent view transient for this view."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_transient(self, transient_view):\n        top = self.get_top_widget()\n        if isinstance(top, (list, tuple)):\n            for t in top:\n                if t is not None:\n                    transient_view.get_top_widget().set_transient_for(t)\n        elif top is not None:\n            transient_view.get_top_widget().set_transient_for(top)", "response": "Set the transient for the top level of the view."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalling internally to actually make the internal Gtk. Builder instance connect all signals found in controllers controlling self.", "response": "def __builder_connect_pending_signals(self):\n        \"\"\"Called internally to actually make the internal Gtk.Builder\n        instance connect all signals found in controllers controlling\n        self.\"\"\"\n        class _MultiHandlersProxy (object):\n            def __init__(self, funcs): self.funcs = funcs\n            def __call__(self, *args, **kwargs):\n                # according to gtk documentation, the return value of\n                # a signal is the return value of the last executed\n                # handler\n                for func in self.funcs:\n                    res = func(*args, **kwargs)\n                return res\n\n        final_dict = {n: (v.pop() if len(v) == 1\n                          else _MultiHandlersProxy(v))\n                      for n, v in self.builder_pending_callbacks.items()}\n\n        self._builder.connect_signals(final_dict)\n\n        self.builder_connected = True\n        self.builder_pending_callbacks = {}"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls by controllers which want to autoconnect their handlers with signals declared in internal Gtk. Builder. gtk", "response": "def _builder_connect_signals(self, _dict):\n        \"\"\"Called by controllers which want to autoconnect their\n        handlers with signals declared in internal Gtk.Builder.\n\n        This method accumulates handlers, and books signal\n        autoconnection later on the idle of the next occurring gtk\n        loop. After the autoconnection is done, this method cannot be\n        called anymore.\"\"\"\n\n        assert not self.builder_connected, \"Gtk.Builder not already connected\"\n\n        if _dict and not self.builder_pending_callbacks:\n            # this is the first call, book the builder connection for\n            # later gtk loop\n            GLib.idle_add(self.__builder_connect_pending_signals)\n\n        for n, v in _dict.items():\n            if n not in self.builder_pending_callbacks:\n                _set = set()\n                self.builder_pending_callbacks[n] = _set\n            else:\n                _set = self.builder_pending_callbacks[n]\n            _set.add(v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __extract_autoWidgets(self):\n        if self.__autoWidgets_calculated: return\n\n        if self._builder is not None:\n            for wid in self._builder.get_objects():\n                # General workaround for issue\n                # https://bugzilla.gnome.org/show_bug.cgi?id=607492\n                try:\n                    name = Gtk.Buildable.get_name(wid)\n                except TypeError:\n                    continue\n\n                if name in self.autoWidgets and self.autoWidgets[name] != wid:\n                    raise ViewError(\"Widget '%s' in builder also found in \"\n                        \"glade specification\" % name)\n\n                self.autoWidgets[name] = wid\n\n        self.__autowidgets_calculated = True", "response": "Extract autoWidgets map if needed out of the glade\n        specifications and gtk builder"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning JSON decoded response from API call. Handle errors when bad response encountered.", "response": "def clef_error_check(func_to_decorate):\n    \"\"\"Return JSON decoded response from API call. Handle errors when bad response encountered.\"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            response = func_to_decorate(*args, **kwargs)\n        except requests.exceptions.RequestException:\n            raise ConnectionError(\n                'Clef encountered a network connectivity problem. Are you sure you are connected to the Internet?'\n            )\n        else:\n            raise_right_error(response)\n        return response.json() # decode json\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nraises appropriate error when bad response received.", "response": "def raise_right_error(response):\n    \"\"\"Raise appropriate error when bad response received.\"\"\"\n    if response.status_code == 200:\n        return\n    if response.status_code == 500:\n        raise ServerError('Clef servers are down.')\n    if response.status_code == 403:\n        message = response.json().get('error')\n        error_class = MESSAGE_TO_ERROR_MAP[message]\n        if error_class == InvalidOAuthTokenError:\n            message = 'Something went wrong at Clef. Unable to retrieve user information with this token.'\n        raise error_class(message)\n    if response.status_code == 400:\n        message = response.json().get('error')\n        error_class = MESSAGE_TO_ERROR_MAP[message]\n        if error_class:\n            raise error_class(message)\n        else:\n            raise InvalidLogoutTokenError(message)\n    if response.status_code == 404:\n        raise NotFoundError('Unable to retrieve the page. Are you sure the Clef API endpoint is configured right?')\n    raise APIError"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning response from Clef API call.", "response": "def _call(self, method, url, params):\n        \"\"\"Return response from Clef API call.\"\"\"\n        request_params = {}\n        if method == 'GET':\n            request_params['params'] = params\n        elif method == 'POST':\n            request_params['data'] = params\n        response = requests.request(method, url, **request_params)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_login_information(self, code=None):\n        # do the handshake to get token\n        access_token = self._get_access_token(code)\n        # make request with token to get user details\n        return self._get_user_info(access_token)", "response": "Return Clef user info after exchanging code for OAuth token."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_user_info(self, access_token):\n        info_response = self._call('GET', self.info_url, params={'access_token': access_token})\n        user_info = info_response.get('info')\n        return user_info", "response": "Return Clef user info."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn Clef user info after exchanging logout token.", "response": "def get_logout_information(self, logout_token):\n        \"\"\"Return Clef user info after exchanging logout token.\"\"\"\n        data = dict(logout_token=logout_token, app_id=self.app_id, app_secret=self.app_secret)\n        logout_response = self._call('POST', self.logout_url, params=data)\n        clef_user_id = logout_response.get('clef_id')\n        return clef_user_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndecorates a method in an :class:`Observer` subclass as a notification. Takes one to many property names as strings. If any of them changes in a model we observe, the method is called. The name of the property will be passed to the method. The type of notification is inferred from the number of arguments. Valid signature are:: def value_notify(self, model, name, old, new) def before_notify(self, model, name, instance, method_name, args, kwargs) def after_notify(self, model, name, instance, method_name, res, args, kwargs) def signal_notify(self, model, name, arg) .. versionadded:: 1.99.0 .. deprecated:: 1.99.1 Use :meth:`Observer.observe` instead, which offers more features.", "response": "def observes(*args):\n    \"\"\"\n    Decorate a method in an :class:`Observer` subclass as a notification.\n    Takes one to many property names as strings. If any of them changes\n    in a model we observe, the method is called. The name of the property\n    will be passed to the method.\n\n    The type of notification is inferred from the number of arguments. Valid\n    signature are::\n\n      def value_notify(self, model, name, old, new)\n      def before_notify(self, model, name, instance, method_name, args,\n                        kwargs)\n      def after_notify(self, model, name, instance, method_name, res, args,\n                       kwargs)\n      def signal_notify(self, model, name, arg)\n\n    .. versionadded:: 1.99.0\n\n    .. deprecated:: 1.99.1\n       Use :meth:`Observer.observe` instead, which offers more features.\n    \"\"\"\n\n    @decorators.good_decorator\n    def _decorator(_notified):\n        # marks the method with observed properties\n        _list = getattr(_notified, Observer._CUST_OBS_, list())\n\n        # here the notificaion type is inferred out of the number of\n        # arguments of the notification method. This is not\n        # particularly robust.\n        margs, mvarargs, _, _ = inspect.getargspec(_notified)\n        mnumargs = len(margs)\n        if not mvarargs:\n            args_to_type = {4: 'signal',\n                            5: 'assign',\n                            7: 'before',\n                            8: 'after',\n                            }\n            try :\n                type_kw = args_to_type[mnumargs]\n                # warning: flag _old_style_call is used this as\n                # deprecated call mechanism like in\n                # <property_<name>_...\n                _list += [(arg, dict({type_kw : True,\n                                      'old_style_call' : True}))\n                          for arg in args]\n                setattr(_notified, Observer._CUST_OBS_, _list)\n\n            except KeyError:\n                log.logger.warn(\"Ignoring notification %s: wrong number of\"\n                                \" arguments (given %d, expected in (%s))\",\n                                _notified.__name__, mnumargs,\n                                \",\".join(map(str, args_to_type)))\n        else:\n            log.logger.warn(\"Ignoring notification %s: variable arguments\"\n                            \" prevent type inference\", _notified.__name__)\n        return _notified\n\n    # checks arguments\n    if 0 == len(args):\n        raise TypeError(\"decorator observe() takes one of more \"\n                        \"arguments (0 given)\")\n    if any(a for a in args if not isinstance(a, str)):\n        raise TypeError(\"decorator observe() takes only strings as arguments\")\n\n    log.logger.warning(\"Decorator observer.observers is deprecated:\"\n                       \"use Observer.observe instead\")\n    return _decorator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmark a method as receiving notifications. Comes in two flavours: .. method:: observe(name, **types) :noindex: A decorator living in the class. Can be applied more than once to the same method, provided the names differ. *name* is the property we want to be notified about as a string. .. Note:: Alternatively, *name* can be a pattern for matching property names, meaning it can contain wildcards character like in module `fnmatch <http://docs.python.org/library/fnmatch.html>`_ in Python library. However, if wildcards are used in name, only *one* `observe` can be used for a given notification method, or else `ValueError` exception is raised when the Observer class is instantiated. .. versionadded:: 1.99.2 *types* are boolean values denoting the types of notifications desired. At least one of the following has to be passed as True: assign, before, after, signal. Excess keyword arguments are passed to the method as part of the info dictionary. .. method:: observe(callable, name, **types) :noindex: An instance method to define notifications at runtime. Works as above. *callable* is the method to send notifications to. The effect will be as if this had been decorated. In all cases the notification method must take exactly three arguments: the model object, the name of the property that changed, and an :class:`NTInfo` object describing the change. .. warning:: Due to limitation in the dynamic registration (in version 1.99.1), declarations of dynamic notifications must occur before registering self as an observer of the models whose properties the notifications are supposed to be observing. A hack for this limitation, is to first relieve any interesting model before dynamically register the notifications, and then re-observe those models. .. versionadded:: 1.99.1", "response": "def observe(cls, *args, **kwargs):\n        \"\"\"\n        Mark a method as receiving notifications. Comes in two flavours:\n\n        .. method:: observe(name, **types)\n           :noindex:\n\n           A decorator living in the class. Can be applied more than once to\n           the same method, provided the names differ.\n\n           *name* is the property we want to be notified about as a\n           string.\n\n           .. Note::\n\n              Alternatively, *name* can be a pattern for matching\n              property names, meaning it can contain wildcards\n              character like in module `fnmatch\n              <http://docs.python.org/library/fnmatch.html>`_ in\n              Python library. However, if wildcards are used in name,\n              only *one* `observe` can be used for a given\n              notification method, or else `ValueError` exception is\n              raised when the Observer class is instantiated.\n\n              .. versionadded:: 1.99.2\n\n           *types* are boolean values denoting the types of\n           notifications desired. At least one of the following has to be\n           passed as True: assign, before, after, signal.\n\n           Excess keyword arguments are passed to the method as part of the\n           info dictionary.\n\n        .. method:: observe(callable, name, **types)\n           :noindex:\n\n           An instance method to define notifications at runtime. Works as\n           above.\n\n           *callable* is the method to send notifications to. The effect will\n           be as if this had been decorated.\n\n        In all cases the notification method must take exactly three\n        arguments: the model object, the name of the property that changed,\n        and an :class:`NTInfo` object describing the change.\n\n        .. warning::\n\n           Due to limitation in the dynamic registration (in version\n           1.99.1), declarations of dynamic notifications must occur\n           before registering self as an observer of the models whose\n           properties the notifications are supposed to be\n           observing. A hack for this limitation, is to first relieve\n           any interesting model before dynamically register the\n           notifications, and then re-observe those models.\n\n        .. versionadded:: 1.99.1\n        \"\"\"\n\n        @decorators.good_decorator\n        def _decorator(_notified):\n            # marks the method with observed properties\n            _list = getattr(_notified, Observer._CUST_OBS_, list())\n            _list.append((name, kwargs))\n            setattr(_notified, Observer._CUST_OBS_, _list)\n            return _notified\n\n        # handles arguments\n        if args and isinstance(args[0], cls):\n            # Used as instance method, for declaring notifications\n            # dynamically\n            if len(args) != 3:\n                raise TypeError(\"observe() takes exactly three arguments\"\n                                \" when called (%d given)\" % len(args))\n\n            self = args[0]\n            notified = args[1]\n            name = args[2]\n\n            assert isinstance(self, Observer), \"Method Observer.observe \" \\\n                \"must be called with an Observer instance as first argument\"\n            if not callable(notified):\n                raise TypeError(\"Second argument of observe() \"\n                                \"must be a callable\")\n            if not isinstance(name, str):\n                raise TypeError(\"Third argument of observe() must be a string\")\n\n            self.__register_notification(name, notified, kwargs)\n            return None\n\n        # used statically as decorator\n        if len(args) != 1:\n            raise TypeError(\"observe() takes exactly one argument when used\"\n                            \" as decorator (%d given)\" % len(args))\n        name = args[0]\n        if not isinstance(name, str):\n            raise TypeError(\"First argument of observe() must be a string\")\n        return _decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_observing_methods(self, prop_name):\n        # searches in pattern and in map\n        return (functools.reduce(set.union,\n                                 (meths\n                                  for pat, meths in self.__PAT_TO_METHS.items()\n                                  if fnmatch.fnmatch(prop_name, pat)),\n                                 set()) |\n                self.__PROP_TO_METHS.get(prop_name, set()))", "response": "Return a set of all methods that have been registered with a given property name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_observing_method_kwargs(self, prop_name, method):\n        # exact match have precedence\n        if (prop_name, method) in self.__PAT_METH_TO_KWARGS:\n            return self.__PAT_METH_TO_KWARGS[(prop_name, method)]\n\n        # checks pattern\n        if method in self.__METH_TO_PAT:\n            prop_name = self.__METH_TO_PAT[method]\n\n        return self.__PAT_METH_TO_KWARGS[(prop_name, method)]", "response": "Returns the keyword arguments that were specified when declaring a notification method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a method from the set of observers that were registered with an observer.", "response": "def remove_observing_method(self, prop_names, method):\n        \"\"\"\n        Remove dynamic notifications.\n\n        *method* a callable that was registered with :meth:`observe`.\n\n        *prop_names* a sequence of strings. This need not correspond to any\n        one `observe` call.\n\n        .. note::\n\n           This can revert even the effects of decorator `observe` at\n           runtime. Don't.\n        \"\"\"\n        for prop_name in prop_names:\n            if prop_name in self.__PROP_TO_METHS:\n                # exact match\n                self.__PROP_TO_METHS[prop_name].remove(method)\n                del self.__PAT_METH_TO_KWARGS[(prop_name, method)]\n            elif method in self.__METH_TO_PAT:\n                # found a pattern matching\n                pat = self.__METH_TO_PAT[method]\n                if fnmatch.fnmatch(prop_name, pat):\n                    del self.__METH_TO_PAT[method]\n                    self.__PAT_TO_METHS[pat].remove(method)\n\n                del self.__PAT_METH_TO_KWARGS[(pat, method)]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the given method is already observing a method.", "response": "def is_observing_method(self, prop_name, method):\n        \"\"\"\n        Returns `True` if the given method was previously added as an\n        observing method, either dynamically or via decorator.\n        \"\"\"\n        if (prop_name, method) in self.__PAT_METH_TO_KWARGS:\n            return True\n        if method in self.__METH_TO_PAT:\n            pat = self.__METH_TO_PAT[method]\n            if fnmatch.fnmatch(prop_name, pat):\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data(self, column, role):\n        if role == QtCore.Qt.DisplayRole:\n            if column >= 0 and column < len(self._list):\n                return str(self._list[column])", "response": "Return the data for the specified column and role"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_data(self, column, value, role):\n        if role == QtCore.Qt.EditRole or role == QtCore.Qt.DisplayRole:\n            self._list[column] = value\n            return True\n        else:\n            return False", "response": "Set the data for the given column to value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flags(self, column):\n        flags = QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable\n        if self._editable:\n            flags = flags | QtCore.Qt.ItemIsEditable\n        return flags", "response": "Return the item flags for the item\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_model(self, model):\n        self._model = model\n        for c in self.childItems:\n            c.set_model(model)", "response": "Sets the model the item belongs to."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_child(self, child):\n        child.set_model(self._model)\n        if self._model:\n            row = len(self.childItems)\n            parentindex = self._model.index_of_item(self)\n            self._model.insertRow(row, child, parentindex)\n        else:\n            self.childItems.append(child)", "response": "Adds a child to the tree item."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_child(self, child):\n        child.set_model(None)\n        if self._model:\n            row = self.childItems.index(child)\n            parentindex = self._model.index_of_item(self)\n            self._model.removeRow(row, parentindex)\n        else:\n            self.childItems.remove(child)", "response": "Removes the child from this TreeItem."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the number of columns that the children have", "response": "def column_count(self, ):\n        \"\"\"Return the number of columns that the children have\n\n        If there are no children, return the column count of its own data.\n\n        :returns: the column count of the children data\n        :rtype: int\n        :raises: None\n        \"\"\"\n        if self.child_count():\n            return self.childItems[0]._data.column_count()\n        else:\n            return self._data.column_count() if self._data else 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the data for the column and role", "response": "def data(self, column, role):\n        \"\"\"Return the data for the column and role\n\n        :param column: the data column\n        :type column: int\n        :param role: the data role\n        :type role: QtCore.Qt.ItemDataRole\n        :returns: data depending on the role\n        :rtype:\n        :raises: None\n        \"\"\"\n        if self._data is not None and (column >= 0 or column < self._data.column_count()):\n            return self._data.data(column, role)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_data(self, column, value, role):\n        if not self._data or column >= self._data.column_count():\n            return False\n        return self._data.set_data(column, value, role)", "response": "Set the data of the item with the given column to value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the parent of the treeitem.", "response": "def set_parent(self, parent):\n        \"\"\"Set the parent of the treeitem\n\n        :param parent: parent treeitem\n        :type parent: :class:`TreeItem` | None\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if self._parent == parent:\n            return\n        if self._parent:\n            self._parent.remove_child(self)\n        self._parent = parent\n        if parent:\n            parent.add_child(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the index of the item in the model specified by the given row column and parent index.", "response": "def index(self, row, column, parent=None):\n        \"\"\"Return the index of the item in the model specified by the given row,\n        column and parent index.\n\n        :param row: the row of the item\n        :type row: int\n        :param column: the column for the item\n        :type column: int\n        :param parent: the parent index\n        :type parent: :class:`QtCore.QModelIndex`:\n        :returns: the index of the item\n        :rtype: :class:`QtCore.QModelIndex`\n        :raises: None\n        \"\"\"\n        if parent is None:\n            parent = QtCore.QModelIndex()\n        if not self.hasIndex(row, column, parent):\n            return QtCore.QModelIndex()\n\n        if parent.isValid():\n            parentItem = parent.internalPointer()\n        else:\n            parentItem = self._root\n\n        try:\n            childItem = parentItem.child(row)\n            return self.createIndex(row, column, childItem)\n        except IndexError:\n            return QtCore.QModelIndex()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rowCount(self, parent):\n        if parent.column() > 0:\n            return 0\n        if not parent.isValid():\n            parentItem = self._root\n        else:\n            parentItem = parent.internalPointer()\n        return parentItem.child_count()", "response": "Returns the number of rows under the given parent."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef columnCount(self, parent):\n        if parent.isValid():\n            return parent.internalPointer().column_count()\n        else:\n            return self._root.column_count()", "response": "Returns the number of columns for the children of the given parent."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setData(self, index, value, role=QtCore.Qt.EditRole):\n        if not index.isValid():\n            return False\n        item = index.internalPointer()\n        r = item.set_data(index.column(), value, role)\n        if r:\n            self.dataChanged.emit(index, index)\n        return r", "response": "Sets the data of the given index to value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef headerData(self, section, orientation, role):\n        if orientation == QtCore.Qt.Horizontal:\n            d = self._root.data(section, role)\n            if d is None and role == QtCore.Qt.DisplayRole:\n                return str(section+1)\n            return d\n        if orientation == QtCore.Qt.Vertical and role == QtCore.Qt.DisplayRole:\n            return str(section+1)", "response": "Return the header data for the given section and orientation and role."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninsert a single item before the given row in the parent specified.", "response": "def insertRow(self, row, item, parent):\n        \"\"\"Insert a single item before the given row in the child items of the parent specified.\n\n        :param row: the index where the rows get inserted\n        :type row: int\n        :param item: the item to insert. When creating the item, make sure it's parent is None.\n                     If not it will defeat the purpose of this function.\n        :type item: :class:`TreeItem`\n        :param parent: the parent\n        :type parent: :class:`QtCore.QModelIndex`\n        :returns: Returns true if the row is inserted; otherwise returns false.\n        :rtype: bool\n        :raises: None\n        \"\"\"\n        item.set_model(self)\n        if parent.isValid():\n            parentitem = parent.internalPointer()\n        else:\n            parentitem = self._root\n        self.beginInsertRows(parent, row, row)\n        item._parent = parentitem\n        if parentitem:\n            parentitem.childItems.insert(row, item)\n        self.endInsertRows()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves the row from the parent item.", "response": "def removeRow(self, row, parent):\n        \"\"\"Remove row from parent\n\n        :param row: the row index\n        :type row: int\n        :param parent: the parent index\n        :type parent: :class:`QtCore.QModelIndex`\n        :returns: True if row is inserted; otherwise returns false.\n        :rtype: bool\n        :raises: None\n        \"\"\"\n        if parent.isValid():\n            parentitem = parent.internalPointer()\n        else:\n            parentitem = self._root\n        self.beginRemoveRows(parent, row, row)\n        item = parentitem.childItems[row]\n        item.set_model(None)\n        item._parent = None\n        del parentitem.childItems[row]\n        self.endRemoveRows()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the flags for the given index", "response": "def flags(self, index):\n        \"\"\"Return the flags for the given index\n\n        This will call :meth:`TreeItem.flags` for valid ones.\n\n        :param index: the index to query\n        :type index: :class:`QtCore.QModelIndex`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if index.isValid():\n            item = index.internalPointer()\n            return item.flags(index)\n        else:\n            super(TreeModel, self).flags(index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef index_of_item(self, item):\n        # root has an invalid index\n        if item == self._root:\n            return QtCore.QModelIndex()\n        # find all parents to get their index\n        parents = [item]\n        i = item\n        while True:\n            parent = i.parent()\n            # break if parent is root because we got all parents we need\n            if parent == self._root:\n                break\n            if parent is None:\n                # No new parent but last parent wasn't root!\n                # This means that the item was not in the model!\n                return QtCore.QModelIndex()\n            # a new parent was found and we are still not at root\n            # search further until we get to root\n            i = parent\n            parents.append(parent)\n\n        # get the parent indexes until\n        index = QtCore.QModelIndex()\n        for treeitem in reversed(parents):\n            parent = treeitem.parent()\n            row = parent.childItems.index(treeitem)\n            index = self.index(row, 0, index)\n        return index", "response": "Get the index of the given item in the model."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the roots of a cubic polynomial.", "response": "def roots_of_cubic_polynom(a1, a2, a3):\n    '''\n    Finds the roots of a 3 dim polymon of the form x^3 + a1 * x^2 + a2 * x + a3.\n    The roots are returned as complex numbers.\n    '''\n    q = (a1 * a1 - 3.0 * a2) / 9.0\n    r = (2 * a1 * a1 * a1 - 9.0 * a1 * a2 + 27.0 * a3) / 54.0\n    r2 = r * r\n    q3 = q * q * q\n    a1d3 = a1 / 3.0\n\n    if r2 - q3 >= 0.0:  # In this case there are 2 complex roots\n        # Let a = - sgn(R) * ( |R| + sqrt(R^2 -Q^3) )^(1/3)\n        oneThird = 1.0 / 3.0\n        a = - sign(r) * (abs(r) + sqrt(r2 - q3)) ** oneThird\n        b = q / a if a != 0.0 else 0.0\n        apb = a + b\n        root1 = complex(apb - a1d3)\n        root2 = -0.5 * apb - a1d3 + sqrt(3) / 2.0 * (a1 - a2) * 1j\n        root3 = root2.conjugate()\n        return root1, root2, root3\n    else:  # In this case there are three real roots\n        theta = acos(r / sqrt(q3))\n        fac = -2.0 * sqrt(q)\n        root1 = complex(fac * cos(theta / 3.0) - a1d3)\n        root2 = complex(fac * cos((theta + 2.0 * PI) / 3.0) - a1d3)\n        root3 = complex(fac * cos((theta - 2.0 * PI) / 3.0) - a1d3)\n        return root1, root2, root3"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decimal(self, var, default=NOTSET, force=True):\n        return self._get(var, default=default, cast=Decimal, force=force)", "response": "Convenience method for casting to a decimal. Decimal object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget environment variable parsed as a json string", "response": "def json(self, var, default=NOTSET, force=True):\n        \"\"\"Get environment variable, parsed as a json string\"\"\"\n        return self._get(var, default=default, cast=json.loads, force=force)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef url(self, var, default=NOTSET, force=True):\n        return self._get(var, default=default, cast=urlparse.urlparse,\n                         force=force)", "response": "Get environment variable parsed with urlparse. urlparse"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_selection(self):\n        si = self.shotverbrws.selected_indexes(0)\n        if si:\n            self.shot_ver_sel_changed(si[0])\n        else:\n            self.shot_ver_sel_changed(QtCore.QModelIndex())\n        ai = self.assetverbrws.selected_indexes(0)\n        if ai:\n            self.asset_ver_sel_changed(ai[0])\n        else:\n            self.asset_ver_sel_changed(QtCore.QModelIndex())", "response": "Initialize the selection in the beginning so signals get emitted once\n\n        Emit asset_taskfile_sel_changed signal and asset_taskfile_sel_changed signal."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating the browsers and all necessary ui elements for the tool.", "response": "def setup_ui(self, ):\n        \"\"\"Create the browsers and all necessary ui elements for the tool\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.prjbrws = self.create_prj_browser()\n        self.shotbrws = self.create_shot_browser()\n        self.shotverbrws = self.create_ver_browser(self.shot_browser_vbox)\n        self.shotcommentbrws = self.create_comment_browser(self.shot_info_hbox)\n        self.assetbrws = self.create_asset_browser()\n        self.assetverbrws = self.create_ver_browser(self.asset_browser_vbox)\n        self.assetcommentbrws = self.create_comment_browser(self.asset_info_hbox)\n        self.current_pb = self.create_current_pb()\n        self.current_pb.setVisible(bool(self.get_current_file))\n        self.shot_info_mapper = QtGui.QDataWidgetMapper()\n        self.asset_info_mapper = QtGui.QDataWidgetMapper()\n        self.setup_releasetype_buttons()\n        self.setup_icons()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_releasetype_buttons(self, ):\n        # we insert the radiobuttons instead of adding them\n        # because there is already a spacer in the layout to\n        # keep the buttons to the left. To maintain the original order\n        # we insert them all to position 0 but in reversed order\n        for rt in reversed(self._releasetypes):\n            rb = QtGui.QRadioButton(rt)\n            self.releasetype_hbox.insertWidget(0, rb)\n            self._releasetype_button_mapping[rt] = rb\n        # set first radiobutton checked\n        if self._releasetypes:\n            rt = self._releasetypes[0]\n            rb = self._releasetype_button_mapping[rt]\n            rb.setChecked(True)\n        # if there is only one releasetype hide the buttons\n        if len(self._releasetypes) == 1:\n            self.releasetype_widget.setVisible(False)", "response": "Create a radio button for every releasetype and add it to the buttons"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setup_icons(self, ):\n        folder_icon = get_icon('glyphicons_144_folder_open.png', asicon=True)\n        self.asset_open_path_tb.setIcon(folder_icon)\n        self.shot_open_path_tb.setIcon(folder_icon)\n\n        current_icon = get_icon('glyphicons_181_download_alt.png', asicon=True)\n        self.current_pb.setIcon(current_icon)\n\n        refresh_icon = get_icon('refresh.png', asicon=True)\n        self.refresh_tb.setIcon(refresh_icon)", "response": "Sets all icons on buttons\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconnect the signals with the slots to make the ui functional", "response": "def setup_signals(self, ):\n        \"\"\"Connect the signals with the slots to make the ui functional\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        prjlvl = self.prjbrws.get_level(0)\n        prjlvl.new_root.connect(self.update_browsers)\n        for rb in self._releasetype_button_mapping.values():\n            rb.toggled.connect(self.releasetype_btn_toggled)\n\n        shotdesclvl = self.shotbrws.get_level(3)\n        shotselcb = partial(self.selection_changed,\n                            source=self.shotbrws,\n                            update=self.shotverbrws,\n                            commentbrowser=self.shotcommentbrws,\n                            mapper=self.shot_info_mapper)\n        shotdesclvl.new_root.connect(shotselcb)\n        shotverlvl = self.shotverbrws.get_level(0)\n        shotverlvl.new_root.connect(self.shot_ver_sel_changed)\n        shotmappercb = partial(self.set_mapper_index, mapper=self.shot_info_mapper)\n        shotverlvl.new_root.connect(shotmappercb)\n        shotverlvl.new_root.connect(partial(self.shotcommentbrws.set_root, 0))\n\n        assetdesclvl = self.assetbrws.get_level(3)\n        assetselcb = partial(self.selection_changed,\n                             source=self.assetbrws,\n                             update=self.assetverbrws,\n                             commentbrowser=self.assetcommentbrws,\n                             mapper=self.asset_info_mapper)\n        assetdesclvl.new_root.connect(assetselcb)\n        assetverlvl = self.assetverbrws.get_level(0)\n        assetverlvl.new_root.connect(self.asset_ver_sel_changed)\n        assetmappercb = partial(self.set_mapper_index, mapper=self.asset_info_mapper)\n        assetverlvl.new_root.connect(assetmappercb)\n        assetverlvl.new_root.connect(partial(self.assetcommentbrws.set_root, 0))\n\n        self.current_pb.clicked.connect(self.set_to_current)\n        self.asset_open_path_tb.clicked.connect(self.open_asset_path)\n        self.shot_open_path_tb.clicked.connect(self.open_shot_path)\n        self.refresh_tb.clicked.connect(self.refresh)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_prj_browser(self, ):\n        prjbrws = ComboBoxBrowser(1, headers=['Project:'])\n        self.central_vbox.insertWidget(0, prjbrws)\n        return prjbrws", "response": "Create the project browser"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating the shot browser for the given species and adds it to the ui", "response": "def create_shot_browser(self, ):\n        \"\"\"Create the shot browser\n\n        This creates a list browser for shots\n        and adds it to the ui\n\n        :returns: the created borwser\n        :rtype: :class:`jukeboxcore.gui.widgets.browser.ListBrowser`\n        :raises: None\n        \"\"\"\n        shotbrws = ListBrowser(4, headers=['Sequence', 'Shot', 'Task', 'Descriptor'])\n        self.shot_browser_vbox.insertWidget(0, shotbrws)\n        return shotbrws"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_asset_browser(self, ):\n        assetbrws = ListBrowser(4, headers=['Assettype', 'Asset', 'Task', 'Descriptor'])\n        self.asset_browser_vbox.insertWidget(0, assetbrws)\n        return assetbrws", "response": "Create the asset browser for the asset_browser_vbox and adds it to the ui\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a version browser and insert it into the given layout", "response": "def create_ver_browser(self, layout):\n        \"\"\"Create a version browser and insert it into the given layout\n\n        :param layout: the layout to insert the browser into\n        :type layout: QLayout\n        :returns: the created browser\n        :rtype: :class:`jukeboxcore.gui.widgets.browser.ComboBoxBrowser`\n        :raises: None\n        \"\"\"\n        brws = ComboBoxBrowser(1, headers=['Version:'])\n        layout.insertWidget(1, brws)\n        return brws"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a comment browser and insert it into the given layout", "response": "def create_comment_browser(self, layout):\n        \"\"\"Create a comment browser and insert it into the given layout\n\n        :param layout: the layout to insert the browser into\n        :type layout: QLayout\n        :returns: the created browser\n        :rtype: :class:`jukeboxcore.gui.widgets.browser.ListBrowser`\n        :raises: None\n        \"\"\"\n        brws = CommentBrowser(1, headers=['Comments:'])\n        layout.insertWidget(1, brws)\n        return brws"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a push button and place it in the corner of the tabwidget", "response": "def create_current_pb(self, ):\n        \"\"\"Create a push button and place it in the corner of the tabwidget\n\n        :returns: the created button\n        :rtype: :class:`QtGui.QPushButton`\n        :raises: None\n        \"\"\"\n        pb = QtGui.QPushButton(\"Select current\")\n        self.selection_tabw.setCornerWidget(pb)\n        return pb"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates and return a tree model that represents a list of projects", "response": "def create_prj_model(self, ):\n        \"\"\"Create and return a tree model that represents a list of projects\n\n        :returns: the creeated model\n        :rtype: :class:`jukeboxcore.gui.treemodel.TreeModel`\n        :raises: None\n        \"\"\"\n        prjs = djadapter.projects.all()\n        rootdata = treemodel.ListItemData(['Name', 'Short', 'Rootpath'])\n        prjroot = treemodel.TreeItem(rootdata)\n        for prj in prjs:\n            prjdata = djitemdata.ProjectItemData(prj)\n            treemodel.TreeItem(prjdata, prjroot)\n        prjmodel = treemodel.TreeModel(prjroot)\n        return prjmodel"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating and return a new tree model that represents shots til descriptors of the given releasetype", "response": "def create_shot_model(self, project, releasetype):\n        \"\"\"Create and return a new tree model that represents shots til descriptors\n\n        The tree will include sequences, shots, tasks and descriptors of the given releaetype.\n\n        :param releasetype: the releasetype for the model\n        :type releasetype: :data:`djadapter.RELEASETYPES`\n        :param project: the project of the shots\n        :type project: :class:`djadapter.models.Project`\n        :returns: the created tree model\n        :rtype: :class:`jukeboxcore.gui.treemodel.TreeModel`\n        :raises: None\n        \"\"\"\n        rootdata = treemodel.ListItemData(['Name'])\n        rootitem = treemodel.TreeItem(rootdata)\n        for seq in project.sequence_set.all():\n            seqdata = djitemdata.SequenceItemData(seq)\n            seqitem = treemodel.TreeItem(seqdata, rootitem)\n            for shot in seq.shot_set.all():\n                shotdata = djitemdata.ShotItemData(shot)\n                shotitem = treemodel.TreeItem(shotdata, seqitem)\n                for task in shot.tasks.all():\n                    taskdata = djitemdata.TaskItemData(task)\n                    taskitem = treemodel.TreeItem(taskdata, shotitem)\n                    #get all mayafiles\n                    taskfiles = task.taskfile_set.filter(releasetype=releasetype, typ=self._filetype)\n                    # get all descriptor values as a list. disctinct eliminates duplicates.\n                    for d in taskfiles.order_by('descriptor').values_list('descriptor', flat=True).distinct():\n                        ddata = treemodel.ListItemData([d,])\n                        treemodel.TreeItem(ddata, taskitem)\n        shotmodel = treemodel.TreeModel(rootitem)\n        return shotmodel"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating and return a new tree model that represents assets til descriptors of the given releasetype.", "response": "def create_asset_model(self, project, releasetype):\n        \"\"\"Create and return a new tree model that represents assets til descriptors\n\n        The tree will include assettypes, assets, tasks and descriptors of the given releaetype.\n\n        :param releasetype: the releasetype for the model\n        :type releasetype: :data:`djadapter.RELEASETYPES`\n        :param project: the project of the assets\n        :type project: :class:`djadapter.models.Project`\n        :returns: the created tree model\n        :rtype: :class:`jukeboxcore.gui.treemodel.TreeModel`\n        :raises: None\n        \"\"\"\n        rootdata = treemodel.ListItemData(['Name'])\n        rootitem = treemodel.TreeItem(rootdata)\n        for atype in project.atype_set.all():\n            atypedata = djitemdata.AtypeItemData(atype)\n            atypeitem = treemodel.TreeItem(atypedata, rootitem)\n            for asset in atype.asset_set.filter(project=project):\n                assetdata = djitemdata.AssetItemData(asset)\n                assetitem = treemodel.TreeItem(assetdata, atypeitem)\n                for task in asset.tasks.all():\n                    taskdata = djitemdata.TaskItemData(task)\n                    taskitem = treemodel.TreeItem(taskdata, assetitem)\n                    taskfiles = task.taskfile_set.filter(releasetype=releasetype, typ=self._filetype)\n                    # get all descriptor values as a list. disctinct eliminates duplicates.\n                    for d in taskfiles.order_by('descriptor').values_list('descriptor', flat=True).distinct():\n                        ddata = treemodel.ListItemData([d,])\n                        treemodel.TreeItem(ddata, taskitem)\n        assetmodel = treemodel.TreeModel(rootitem)\n        return assetmodel"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate and return a new tree model that represents taskfiles for the given task and releasetype and descriptor.", "response": "def create_version_model(self, task, releasetype, descriptor):\n        \"\"\"Create and return a new model that represents taskfiles for the given task, releasetpye and descriptor\n\n        :param task: the task of the taskfiles\n        :type task: :class:`djadapter.models.Task`\n        :param releasetype: the releasetype\n        :type releasetype: str\n        :param descriptor: the descirptor\n        :type descriptor: str|None\n        :returns: the created tree model\n        :rtype: :class:`jukeboxcore.gui.treemodel.TreeModel`\n        :raises: None\n        \"\"\"\n        rootdata = treemodel.ListItemData(['Version', 'Releasetype', 'Path'])\n        rootitem = treemodel.TreeItem(rootdata)\n        for tf in task.taskfile_set.filter(releasetype=releasetype, descriptor=descriptor).order_by('-version'):\n            tfdata = djitemdata.TaskFileItemData(tf)\n            tfitem = treemodel.TreeItem(tfdata, rootitem)\n            for note in tf.notes.all():\n                notedata = djitemdata.NoteItemData(note)\n                treemodel.TreeItem(notedata, tfitem)\n        versionmodel = treemodel.TreeModel(rootitem)\n        return versionmodel"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the shot browser to the given project", "response": "def update_shot_browser(self, project, releasetype):\n        \"\"\"Update the shot browser to the given project\n\n        :param releasetype: the releasetype for the model\n        :type releasetype: :data:`djadapter.RELEASETYPES`\n        :param project: the project of the shots\n        :type project: :class:`djadapter.models.Project`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if project is None:\n            self.shotbrws.set_model(None)\n            return\n        shotmodel = self.create_shot_model(project, releasetype)\n        self.shotbrws.set_model(shotmodel)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_asset_browser(self, project, releasetype):\n        if project is None:\n            self.assetbrws.set_model(None)\n            return\n        assetmodel = self.create_asset_model(project, releasetype)\n        self.assetbrws.set_model(assetmodel)", "response": "update the assetbrowser to the given project"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the shot and asset browsers based on the selected project banner and releasetype.", "response": "def update_browsers(self, *args, **kwargs):\n        \"\"\"Update the shot and the assetbrowsers\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        sel = self.prjbrws.selected_indexes(0)\n        if not sel:\n            return\n        prjindex = sel[0]\n        if not prjindex.isValid():\n            prj = None\n        else:\n            prjitem = prjindex.internalPointer()\n            prj = prjitem.internal_data()\n        self.set_project_banner(prj)\n        releasetype = self.get_releasetype()\n        self.update_shot_browser(prj, releasetype)\n        self.update_asset_browser(prj, releasetype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_version_descriptor(self, task, releasetype, descriptor,\n                                  verbrowser, commentbrowser):\n        \"\"\"Update the versions in the given browser\n\n        :param task: the task of the taskfiles\n        :type task: :class:`djadapter.models.Task` | None\n        :param releasetype: the releasetype\n        :type releasetype: str|None\n        :param descriptor: the descirptor\n        :type descriptor: str|None\n        :param verbrowser: the browser to update (the version browser)\n        :type verbrowser: :class:`jukeboxcore.gui.widgets.browser.AbstractTreeBrowser`\n        :param commentbrowser: the comment browser to update\n        :type commentbrowser: :class:`jukeboxcore.gui.widgets.browser.AbstractTreeBrowser`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if task is None:\n            null = treemodel.TreeItem(None)\n            verbrowser.set_model(treemodel.TreeModel(null))\n            return\n        m = self.create_version_model(task, releasetype, descriptor)\n        verbrowser.set_model(m)\n        commentbrowser.set_model(m)", "response": "Updates the version in the given browser with the given descriptor."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_info_mapper_model(self, mapper, model):\n        # nothing changed. we can return.\n        # I noticed that when you set the model the very first time to None\n        # it printed a message:\n        # QObject::connect: Cannot connect (null)::dataChanged(QModelIndex,QModelIndex) to\n        # QDataWidgetMapper::_q_dataChanged(QModelIndex,QModelIndex)\n        # QObject::connect: Cannot connect (null)::destroyed() to\n        # QDataWidgetMapper::_q_modelDestroyed()\n        # I don't know exactly why. But these two lines get rid of the message and outcome is the same\n        if not mapper.model() and not model:\n            return\n\n        mapper.setModel(model)\n        if mapper is self.asset_info_mapper:\n            if model is None:\n                self.asset_path_le.setText(\"\")\n                self.asset_created_by_le.setText(\"\")\n                self.asset_created_dte.findChild(QtGui.QLineEdit).setText('')\n                self.asset_updated_dte.findChild(QtGui.QLineEdit).setText('')\n            else:\n                mapper.addMapping(self.asset_path_le, 2)\n                mapper.addMapping(self.asset_created_by_le, 3)\n                mapper.addMapping(self.asset_created_dte, 4)\n                mapper.addMapping(self.asset_updated_dte, 5)\n        else:\n            if model is None:\n                self.shot_path_le.setText(\"\")\n                self.shot_created_by_le.setText(\"\")\n                self.shot_created_dte.findChild(QtGui.QLineEdit).setText('')\n                self.shot_updated_dte.findChild(QtGui.QLineEdit).setText('')\n            else:\n                mapper.addMapping(self.shot_path_le, 2)\n                mapper.addMapping(self.shot_created_by_le, 3)\n                mapper.addMapping(self.shot_created_dte, 4)\n                mapper.addMapping(self.shot_updated_dte, 5)", "response": "Set the model for the info mapper."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the mapper to the given index", "response": "def set_mapper_index(self, index, mapper):\n        \"\"\"Set the mapper to the given index\n\n        :param index: the index to set\n        :type index: QtCore.QModelIndex\n        :param mapper: the mapper to set\n        :type mapper: QtGui.QDataWidgetMapper\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        parent = index.parent()\n        mapper.setRootIndex(parent)\n        mapper.setCurrentModelIndex(index)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_releasetype(self, ):\n        for rt, rb in self._releasetype_button_mapping.items():\n            if rb.isChecked():\n                return rt", "response": "Return the currently selected releasetype"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef asset_ver_sel_changed(self, index):\n        taskfile = None\n        if index.isValid():\n            item = index.internalPointer()\n            taskfile = item.internal_data()\n        self.asset_taskfile_sel_changed.emit(taskfile)", "response": "Callback for when the version selection has changed\n        Emit asset_taskfile_sel_changed signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the selection to the currently open one Taxonomy", "response": "def set_to_current(self, ):\n        \"\"\"Set the selection to the currently open one\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        cur = self.get_current_file()\n        if cur is not None:\n            self.set_selection(cur)\n        else:\n            self.init_selection()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the current selection to the given taskfile", "response": "def set_selection(self, taskfile):\n        \"\"\"Set the selection to the given taskfile\n\n        :param taskfile: the taskfile to set the selection to\n        :type taskfile: :class:`djadapter.models.TaskFile`\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.set_project(taskfile.task.project)\n        self.set_releasetype(taskfile.releasetype)\n        if taskfile.task.department.assetflag:\n            browser = self.assetbrws\n            verbrowser = self.assetverbrws\n            tabi = 0\n            rootobj = taskfile.task.element.atype\n        else:\n            browser = self.shotbrws\n            verbrowser = self.shotverbrws\n            tabi = 1\n            rootobj = taskfile.task.element.sequence\n\n        self.set_level(browser, 0, rootobj)\n        self.set_level(browser, 1, taskfile.task.element)\n        self.set_level(browser, 2, taskfile.task)\n        self.set_level(browser, 3, [taskfile.descriptor])\n        self.set_level(verbrowser, 0, taskfile)\n\n        self.selection_tabw.setCurrentIndex(tabi)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the project selection to the given project", "response": "def set_project(self, project):\n        \"\"\"Set the project selection to the given project\n\n        :param project: the project to select\n        :type project: :class:`djadapter.models.Project`\n        :returns: None\n        :rtype: None\n        :raises: ValueError\n        \"\"\"\n        prjroot = self.prjbrws.model.root\n        prjitems = prjroot.childItems\n        for row, item in enumerate(prjitems):\n            prj = item.internal_data()\n            if prj == project:\n                prjindex = self.prjbrws.model.index(row, 0)\n                break\n        else:\n            raise ValueError(\"Could not select the given taskfile. No project %s found.\" % project.name)\n        self.prjbrws.set_index(0, prjindex)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the given browser level selection to the one that matches with obj", "response": "def set_level(self, browser, lvl, obj):\n        \"\"\"Set the given browser level selection to the one that matches with obj\n\n        This is going to compare the internal_data of the model with the obj\n\n        :param browser:\n        :type browser:\n        :param lvl: the depth level to set\n        :type lvl: int\n        :param obj: the object to compare the indexes with\n        :type obj: object\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        if lvl == 0:\n            index = QtCore.QModelIndex()\n            root = browser.model.root\n            items = root.childItems\n        else:\n            index = browser.selected_indexes(lvl-1)[0]\n            item = index.internalPointer()\n            items = item.childItems\n        for row, item in enumerate(items):\n            data = item.internal_data()\n            if data == obj:\n                newindex = browser.model.index(row, 0, index)\n                break\n        else:\n            raise ValueError(\"Could not select the given object in the browser. %s not found.\" % obj)\n        browser.set_index(lvl, newindex)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_model(self, tfi):\n        if tfi.task.department.assetflag:\n            browser = self.assetbrws\n        else:\n            browser = self.shotbrws\n\n        if tfi.version == 1:  # add descriptor\n            parent = browser.selected_indexes(2)[0]\n            ddata = treemodel.ListItemData([tfi.descriptor])\n            ditem = treemodel.TreeItem(ddata)\n            browser.model.insertRow(0, ditem, parent)\n        self.set_level(browser, 3, [tfi.descriptor])", "response": "Updates the model for the given taskfile info"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open_asset_path(self, *args, **kwargs):\n        f = self.asset_path_le.text()\n        d = os.path.dirname(f)\n        osinter = get_interface()\n        osinter.open_path(d)", "response": "Open the currently selected asset in the filebrowser"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nopen the currently selected shot in the filebrowser", "response": "def open_shot_path(self, *args, **kwargs):\n        \"\"\"Open the currently selected shot in the filebrowser\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        f = self.shot_path_le.text()\n        d = os.path.dirname(f)\n        osinter = get_interface()\n        osinter.open_path(d)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the : class : TaskFileInfo for the current selection in the currently selected tab.", "response": "def get_current_selection(self, i=None):\n        \"\"\"Get the :class:`TaskFileInfo` for the file selected in the active tab\n\n        :param i: If None, returns selection of active tab. If 0, assetselection. If 1, shotselection\n        :type i:\n        :returns: The taskfile info in the currently active tab\n        :rtype: :class:`TaskFileInfo` | None\n        :raises: None\n        \"\"\"\n        taskfile = None\n        if (i is None and self.selection_tabw.currentIndex() == 0) or (i is not None and i == 0):\n            indexes = self.assetverbrws.selected_indexes(0)\n            if indexes and indexes[0].isValid():\n                item = indexes[0].internalPointer()\n                taskfile = item.internal_data()\n        elif (i is None and self.selection_tabw.currentIndex() == 1) or (i is not None and i == 1):\n            indexes = self.shotverbrws.selected_indexes(0)\n            if indexes and indexes[0].isValid():\n                item = indexes[0].internalPointer()\n                taskfile = item.internal_data()\n        return taskfile"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrefreshes the model of the current user s log entries.", "response": "def refresh(self, *args, **kwargs):\n        \"\"\"Refresh the model\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        self.prjbrws.set_model(self.create_prj_model())\n        if self.get_current_file():\n            self.set_to_current()\n        else:\n            self.init_selection()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nspeaks a message to the terminal.", "response": "def speak(self, string='', level=0, progress=False):\n        '''If verbose=True and terse=False, this will print to terminal. Otherwise, it won't.'''\n        if self._pithy == False:\n            self.report(string=string, level=level, progress=progress)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef input(self, string='', level=0, prompt='(please respond) '):\n        '''If verbose=True and terse=False, this will print to terminal. Otherwise, it won't.'''\n        self.report(string, level)\n        return input(\"{0}\".format(self._prefix + prompt))", "response": "Returns a string of text to be displayed to the terminal."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef report(self, string='', level=0, prelude='', progress=False, abbreviate=True):\n        '''If verbose=True, this will print to terminal. Otherwise, it won't.'''\n        if self._mute == False:\n            self._prefix = prelude + '{spacing}[{name}] '.format(name = self.nametag, spacing = ' '*level)\n            self._prefix = \"{0:>16}\".format(self._prefix)\n            equalspaces = ' '*len(self._prefix)\n            toprint = string + ''\n            if abbreviate:\n                if shortcuts is not None:\n                    for k in shortcuts.keys():\n                        toprint = toprint.replace(k, shortcuts[k])\n\n            if progress:\n                print('\\r' + self._prefix + toprint.replace('\\n', '\\n' + equalspaces),)\n            else:\n                print(self._prefix + toprint.replace('\\n', '\\n' + equalspaces))", "response": "Prints a string to terminal."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef summarize(self):\n        '''Print a summary of the contents of this object.'''\n\n        self.speak('Here is a brief summary of {}.'.format(self.nametag))\n        s = '\\n'+pprint.pformat(self.__dict__)\n        print(s.replace('\\n', '\\n'+' '*(len(self._prefix)+1)) + '\\n')", "response": "Print a summary of the contents of this object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset up the python include paths to include src", "response": "def setup_path():\n    \"\"\"Sets up the python include paths to include src\"\"\"\n    import os.path; import sys\n\n    if sys.argv[0]:\n        top_dir = os.path.dirname(os.path.abspath(sys.argv[0]))\n        sys.path = [os.path.join(top_dir, \"src\")] + sys.path\n        pass\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef entry_verifier(entries, regex, delimiter):\n\n    cregex = re.compile(regex)  # Compiling saves time if many entries given\n\n    # Encode raw delimiter in order to split a bad entry\n    python_version = int(sys.version.split('.')[0])\n    decoder = 'unicode-escape' if python_version == 3 else 'string-escape'\n    dedelimiter = codecs.decode(delimiter, decoder)\n\n    for entry in entries:\n        match = re.match(cregex, entry)\n\n        # Match failed, check regex and entry parts for error\n        if not match:\n            split_regex = regex.split(delimiter)\n            split_entry = entry.split(dedelimiter)\n            part = 0  # \"Enumerate\" zipped iter\n            for regex_segment, entry_segment in zip(split_regex, split_entry):\n                # Ensure regex_segment only matches entire entry_segment\n                if not regex_segment[0] == '^':\n                    regex_segment = '^' + regex_segment\n                if not regex_segment[-1] == '$':\n                    regex_segment += '$'\n\n                # If segment fails, raise error and store info on failure\n                if not re.match(regex_segment, entry_segment):\n                    raise FormatError(template=regex_segment,\n                                      subject=entry_segment,\n                                      part=part)\n\n                part += 1", "response": "Checks each entry against regex for validity and returns a list of valid entry_id and entry_id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a JIRA API connection.", "response": "def jira_connection(config):\n    \"\"\"\n    Gets a JIRA API connection.  If a connection has already been created the existing connection\n    will be returned.\n    \"\"\"\n    global _jira_connection\n    if _jira_connection:\n        return _jira_connection\n    else:\n        jira_options = {'server': config.get('jira').get('url')}\n\n        cookies = configuration._get_cookies_as_dict()\n        jira_connection = jira_ext.JIRA(options=jira_options)\n        session = jira_connection._session\n\n        reused_session = False\n\n        if cookies:\n            requests.utils.add_dict_to_cookiejar(session.cookies, cookies)\n            try:\n                jira_connection.session()\n                reused_session = True\n            except Exception:\n                pass\n\n        if not reused_session:\n            session.auth = (config['jira']['username'], base64.b64decode(config['jira']['password']))\n            jira_connection.session()\n            session.auth = None\n\n            cookie_jar_hash = requests.utils.dict_from_cookiejar(session.cookies)\n            for key, value in cookie_jar_hash.iteritems():\n                configuration._save_cookie(key, value)\n\n        _jira_connection = jira_connection\n        return _jira_connection"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef form_upload_valid(self, form):\n        self.current_step = self.STEP_LINES\n\n        lines = form.cleaned_data['file']\n        initial_lines = [dict(zip(self.get_columns(), line)) for line in lines]\n        inner_form = self.get_form(self.get_form_class(),\n            data=None,\n            files=None,\n            initial=initial_lines,\n        )\n        return self.render_to_response(self.get_context_data(form=inner_form))", "response": "Handle a valid upload form."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle a valid LineFormSet.", "response": "def form_lines_valid(self, form):\n        \"\"\"Handle a valid LineFormSet.\"\"\"\n        handled = 0\n        for inner_form in form:\n            if not inner_form.cleaned_data.get(formsets.DELETION_FIELD_NAME):\n                handled += 1\n                self.handle_inner_form(inner_form)\n\n        self.log_and_notify_lines(handled)\n        return http.HttpResponseRedirect(self.get_success_url())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nranking the environment and phenotypes in a new environment file.", "response": "def rank_environment_and_phenotypes(environment, phenotypes, k=15):\n    \"\"\"\n    Clusters sets of resources/tasks using a weighted hamming distance such\n    that you can have few enough values to give each group of similar things a\n    different color. This function is designed for cases when you want to\n    color both an environment and a set of phenotypes such that the colors\n    corespond to each other.\n\n    Takes an EnvironmentFile object, a 2d array of phenotypes, and, optionally,\n    a number indicating the maximum number of clusters (default 15).\n\n    Returns:\n     - An EnvironmentFile in which the grid has been replaced with integers\n       indicating which cluster a cell is a member of. Integers are assigned\n       such that cells containing more or more complex resources have higher\n       numbers.\n\n     - A 2D grid of numbers representing the clusters each phenotype was\n       assigned to.\n\n     - An integer representing the total number of clusters.\n    \"\"\"\n    environment = convert_world_to_phenotype(environment)\n    ranks = get_ranks_for_environment_and_phenotypes(environment, phenotypes)\n    environment, n = assign_ranks_by_cluster(environment, k, ranks)\n    phenotypes, n = assign_ranks_by_cluster(phenotypes, k, ranks)\n    return environment, phenotypes, n"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_clustering(types, max_clust):\n    # Fill in leading zeros to make all numbers same length.\n    ls = [list(t[t.find(\"b\")+1:]) for t in types]\n    prepend_zeros_to_lists(ls)\n\n    dist_matrix = pdist(ls, weighted_hamming)\n    clusters = hierarchicalcluster.complete(dist_matrix)\n    clusters = hierarchicalcluster.fcluster(clusters, max_clust,\n                                            criterion=\"maxclust\")\n\n    # Group members of each cluster together\n    cluster_dict = dict((c, []) for c in set(clusters))\n    for i in range(len(types)):\n        cluster_dict[clusters[i]].append(types[i])\n\n    return cluster_dict", "response": "This method is used to cluster the types of the objects being\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rank_clusters(cluster_dict):\n    # Figure out the relative rank of each cluster\n    cluster_ranks = dict.fromkeys(cluster_dict.keys())\n    for key in cluster_dict:\n        cluster_ranks[key] = eval(string_avg(cluster_dict[key], binary=True))\n\n    i = len(cluster_ranks)\n    for key in sorted(cluster_ranks, key=cluster_ranks.get):\n        cluster_ranks[key] = i\n        i -= 1\n\n    return cluster_ranks", "response": "This function is used to compute the relative rank of each cluster in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ranks_for_environment_and_phenotypes(environment, phenotypes, k=15):\n    # Create list of all niches and all phenotypes, in phenotype format\n    niches = flatten_array(environment)\n    phenotypes = flatten_array(phenotypes)\n\n    types = set(phenotypes+niches)\n\n    types.discard(\"-0b1\")  # We'll handle this specially\n    types.discard(\"0b0\")  # We'll handle this specially\n\n    # Do all clustering ahead of time so colors remain consistent.\n    ranks = generate_ranks(list(types), k)\n\n    ranks[\"-0b1\"] = -1  # The empty phenotype/niche should always be rank -1\n    ranks[\"0b0\"] = 0  # The empty phenotype/niche should always be rank 0\n\n    return ranks", "response": "Generates a dictionary mapping binary strings representing resources that are present in a given cell and phenotypes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nassigning the ranks of the resource sets in each cell to the specified grid.", "response": "def assign_ranks_by_cluster(grid, n, ranks=None):\n    \"\"\"\n    Takes a 2D array representing phenotypes or resource sets across the world,\n    and integer rpresenting the maximum number of clusters allowed, and\n    optionally a dictionary indicating the rank of the cluster of each\n    phenotype/resource set. If this dictionary is not provided, one will be\n    generated.\n\n    Returns: - A 2d array of numbers indicating the ranks of the clusters\n               of the resource set/phenotype in each cell\n             - An integer representing the number of clusters created.\n    \"\"\"\n    if ranks is None:\n        ranks = generate_ranks(grid, n)\n    return assign_ranks_to_grid(grid, ranks), len(ranks)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_ranks(grid, n):\n    phenotypes = deepcopy(grid)\n    if type(phenotypes) is list and type(phenotypes[0]) is list:\n        phenotypes = flatten_array(phenotypes)\n\n    # Remove duplicates from types\n    types = list(frozenset(phenotypes))\n    if len(types) < n:\n        ranks = rank_types(types)\n    else:\n        ranks = cluster_types(types, n)\n\n    return ranks", "response": "Generates a dictionary of n - ranked cluster objects for each group of data in the grid."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nassigns the ranks to each cluster in the grid.", "response": "def assign_ranks_to_grid(grid, ranks):\n    \"\"\"\n    Takes a 2D array of binary numbers represented as strings and a dictionary\n    mapping binary strings to integers representing the rank of the cluster\n    they belong to, and returns a grid in which each binary number has been\n    replaced with the rank of its cluster.\n    \"\"\"\n    assignments = deepcopy(grid)\n    ranks[\"0b0\"] = 0\n    ranks[\"-0b1\"] = -1\n\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if type(grid[i][j]) is list:\n                for k in range(len(grid[i][j])):\n                    assignments[i][j][k] = ranks[grid[i][j][k]]\n            else:\n                assignments[i][j] = ranks[grid[i][j]]\n\n    return assignments"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cluster_types(types, max_clust=12):\n\n    if len(types) < max_clust:\n        max_clust = len(types)\n\n    # Do actual clustering\n    cluster_dict = do_clustering(types, max_clust)\n    cluster_ranks = rank_clusters(cluster_dict)\n\n    # Create a dictionary mapping binary numbers to indices\n    ranks = {}\n    for key in cluster_dict:\n        for typ in cluster_dict[key]:\n            ranks[typ] = cluster_ranks[key]\n\n    return ranks", "response": "Cluster the types in types and return a dictionary mapping each binary number to an integer."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rank_types(types):\n    include_null = '0b0' in types\n    sorted_types = deepcopy(types)\n    for i in range(len(sorted_types)):\n        sorted_types[i] = int(sorted_types[i], 2)\n    sorted_types.sort()\n\n    ranks = {}\n    for t in types:\n        ranks[t] = sorted_types.index(eval(t)) + int(not include_null)\n\n    return ranks", "response": "Takes a list of binary numbers and returns a dictionary mapping each binary number to an integer indicating it s rank within the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a 2 or 3d grid of strings representing binary numbers and returns a grid of the same dimensions in which each binary number has been in that replaced by an integer indicating the number of ones that were in that .", "response": "def make_count_grid(data):\n    \"\"\"\n    Takes a 2 or 3d grid of strings representing binary numbers.\n\n    Returns a grid of the same dimensions in which each binary number has been\n    replaced by an integer indicating the number of ones that were in that\n    number.\n    \"\"\"\n    data = deepcopy(data)\n\n    for i in range(len(data)):\n        for j in range(len(data[i])):\n            for k in range(len(data[i][j])):\n                if type(data[i][j][k]) is list:\n                    for l in range(len(data[i][j][k])):\n                        try:\n                            data[i][j][k] = data[i][j][k][l].count(\"1\")\n                        except:\n                            data[i][j][k] = len(data[i][j][k][l])\n                else:\n                    try:\n                        data[i][j][k] = data[i][j][k].count(\"1\")\n                    except:\n                        data[i][j][k] = len(data[i][j][k])\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake an EnvironmentFile object and a 2d array of phenotypes and returns a 2d array in which each location contains an index representing the distance between the phenotype in that location and the optimal phenotype for that location. This is acheived by using the task list in the EnvironmentFile to convert the phenotypes to sets of tasks, and comparing them to the sets of resources in the environment. So if the environment file that you created the EnvironmentFile object from for some reason doesn't contain all of the tasks, or doesn't contain them in the right order this won't work. If this is the environment file that you used for the run of Avida that generated this data, you should be fine.", "response": "def make_optimal_phenotype_grid(environment, phenotypes):\n    \"\"\"\n    Takes an EnvironmentFile object and a 2d array of phenotypes and returns\n    a 2d array in which each location contains an index representing the\n    distance between the phenotype in that location and the optimal phenotype\n    for that location.\n\n    This is acheived by using the task list in the EnvironmentFile to convert\n    the phenotypes to sets of tasks, and comparing them to the sets of\n    resources in the environment. So if the environment file that you created\n    the EnvironmentFile object from for some reason doesn't contain all of the\n    tasks, or doesn't contain them in the right order this won't work. If this\n    is the environment file that you used for the run of Avida that generated\n    this data, you should be fine.\n    \"\"\"\n    world_size = environment.size\n    phenotypes = deepcopy(phenotypes)\n\n    for i in range(world_size[1]):\n        for j in range(world_size[0]):\n            for k in range(len(phenotypes[i][j])):\n                phenotype = phenotype_to_res_set(phenotypes[i][j][k],\n                                                 environment.tasks)\n                diff = len(environment[i][j].symmetric_difference(phenotype))\n                phenotypes[i][j][k] = diff\n\n    return phenotypes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a 3D array of strings representing binary numbers and calculates the percentage of organisms in each cell that were doing a given task.", "response": "def task_percentages(data, n_tasks=9):\n    \"\"\"\n    Takes a 3D array of strings representing binary numbers and calculates\n    the percentage of organisms in each cell (across multiple files)\n    that were doing a given task.\n\n    Returns an m x n x n_tasks array indicating the percentages of organisms\n    at each location (across the 3rd dimension) that were doing each task.\n    \"\"\"\n    pdata = deepcopy(data)\n    for i in range(len(data)):\n        for j in range(len(data[0])):\n            percentages = [0.0]*n_tasks\n            for k in range(len(data[i][j])):\n                b_ind = data[i][j][k].find(\"b\")\n                for l in range(b_ind+1, len(data[i][j][k])):\n                    percentages[l-2] += int(data[i][j][k][l])\n            for p in range(len(percentages)):\n                percentages[p] /= len(data[i][j])\n            pdata[i][j] = percentages\n\n    return pdata"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_routes(departure, dest, vehicle='vlakbus', time='', date=''):\n\n    def _get_leaf_element(table, path):\n        \"\"\"Returns leaf element's text in given path\"\"\"\n        res = table.xpath(path + '/*[not(*)]')\n        if res:\n            return res[0].text\n        return table.xpath(path + '/text()')[0]\n\n    if time == '':\n        time = datetime.datetime.now().strftime('%H:%M')\n\n    if date == '':\n        date = datetime.datetime.now().strftime('%d.%m.%Y')\n\n    try:\n        req = requests.get(CPSK_URL.format(vehicle),\n                           params={'date': date, 'time': time, 'f': departure,\n                                   't': dest, 'submit': 'true'})\n    except:\n        return False\n\n    tree = html.fromstring(req.text)\n    html_tables = tree.xpath('//div[@id=\"main-res-inner\"]/table/tbody')\n    routes = []\n\n    for table in html_tables:\n        drive = Drive()\n        datalen = len(table.xpath('./tr'))\n\n        prevdate = ''\n        for i in range(1, datalen-1):\n            line = Line()\n            trf = './tr[' + str(i) + ']'\n            trt = './tr[' + str(i+1) + ']'\n            line.f = _get_leaf_element(table, trf + '/td[3]')\n            line.t = _get_leaf_element(table, trt + '/td[3]')\n            line.departure = _get_leaf_element(table, trf + '/td[5]')\n            line.arrival = _get_leaf_element(table, trt + '/td[4]')\n            line.vehicle = table.xpath(trf + '/td[7]/img[1]')[0] \\\n                                .get('title').replace('Autobus', 'Bus')\n            if line.vehicle == 'Presun':\n                line.walk_duration = table.xpath(trf + '/td[7]/text()')[0] \\\n                    .replace('Presun asi ', '')\n\n            delay = table.xpath(trf + '/td[7]/div[1]/' +\n                                'span[@class!=\"nodelay\"]/text()')\n            if delay and delay[0] is not u'Aktu\u00e1lne bez me\u0161kania':\n                mins = delay[0].replace(u'Aktu\u00e1lne me\u0161kanie ', '') \\\n                               .replace(u' min\u00faty', '') \\\n                               .replace(u' min\u00fatu', '') \\\n                               .replace(u' min\u00fat', '')\n\n                minstr = 'minutes' if mins is not '1' else 'minute'\n\n                line.delay = ' ({0} {1} delay)'.format(mins, minstr)\n\n            platform = table.xpath(trf + '/td[6]/span[1]/text()')\n            platform2 = table.xpath(trf + '/td[6]/table/tr[1]/' +\n                                    'td[1]/span[1]/text()')\n            if platform:\n                line.platform = '[{0}]'.format(platform[0])\n            elif platform2:\n                line.platform = '[{0}]'.format(platform2[0])\n\n            _date = table.xpath(trf + '/td[2]/text()')[0]\n            if _date is not ' ':\n                prevdate = _date\n            line.date = prevdate\n\n            drive.lines.append(line)\n\n        drive.duration = table.xpath('./tr[' + str(datalen) +\n                                     ']/td[3]/p/strong[1]/text()')[0]\n\n        try:\n            drive.distance = table.xpath('./tr[' + str(datalen) +\n                                         ']/td[3]/p/strong[2]/text()')[0]\n        except IndexError:\n            drive.distance = 'Distance not known'\n\n        routes.append(drive)\n\n    return routes", "response": "Get a list of available routes from departure city to destination city."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\niterating over FASTQ file and return FASTQ entries in the order they were read.", "response": "def fastq_iter(handle, header=None):\n    \"\"\"Iterate over FASTQ file and return FASTQ entries\n\n    Args:\n        handle (file): FASTQ file handle, can be any iterator so long as it\n            it returns subsequent \"lines\" of a FASTQ entry\n\n        header (str): Header line of next FASTQ entry, if 'handle' has been\n            partially read and you want to start iterating at the next entry,\n            read the next FASTQ header and pass it to this variable when\n            calling fastq_iter. See 'Examples.'\n\n    Yields:\n        FastqEntry: class containing all FASTQ data\n\n    Raises:\n        IOError: If FASTQ entry doesn't start with '@'\n\n    Examples:\n        The following two examples demonstrate how to use fastq_iter.\n        Note: These doctests will not pass, examples are only in doctest\n        format as per convention. bio_utils uses pytests for testing.\n\n        >>> for entry in fastq_iter(open('test.fastq')):\n        ...     print(entry.id)  # Print FASTQ id\n        ...     print(entry.description)  # Print FASTQ description\n        ...     print(entry.sequence)  # Print FASTQ sequence\n        ...     print(entry.quality)  # Print FASTQ quality scores\n        ...     print(entry.write())  # Print full FASTQ entry\n\n        >>> fastq_handle = open('test.fastq')\n        >>> next(fastq_handle)  # Skip first entry header\n        >>> next(fastq_handle)  # Skip first entry sequence\n        >>> next(fastq_handle)  # Skip line with '+'\n        >>> next(fastq_handle)  # Skip first entry quality scores\n        >>> first_line = next(fastq_handle)  # Read second entry header\n        >>> for entry in fastq_iter(fastq_handle, header=first_line):\n        ...     print(entry.id)  # Print FASTQ id\n        ...     print(entry.description)  # Print FASTQ description\n        ...     print(entry.sequence)  # Print FASTQ sequence\n        ...     print(entry.quality)  # Print FASTQ quality scores\n        ...     print(entry.write())  # Print full FASTQ entry\n    \"\"\"\n\n    # Speed tricks: reduces function calls\n    append = list.append\n    join = str.join\n    strip = str.strip\n\n    next_line = next\n\n    if header is None:\n        header = next(handle)  # Read first FASTQ entry header\n\n    # Check if input is text or bytestream\n    if (isinstance(header, bytes)):\n        def next_line(i):\n            return next(i).decode('utf-8')\n\n        header = strip(header.decode('utf-8'))\n    else:\n        header = strip(header)\n\n    try:  # Manually construct a for loop to improve speed by using 'next'\n\n        while True:  # Loop until StopIteration Exception raised\n\n            line = strip(next_line(handle))\n\n            data = FastqEntry()\n\n            if not header[0] == '@':\n                raise IOError('Bad FASTQ format: no \"@\" at beginning of line')\n\n            try:\n                data.id, data.description = header[1:].split(' ', 1)\n            except ValueError:  # No description\n                data.id = header[1:]\n                data.description = ''\n\n            # obtain sequence\n            sequence_list = []\n            while line and not line[0] == '+' and not line[0] == '#':\n                append(sequence_list, line)\n                line = strip(next_line(handle))\n            data.sequence = join('', sequence_list)\n\n            line = strip(next_line(handle))  # Skip line containing only '+'\n\n            # Obtain quality scores\n            quality_list = []\n            seq_len = len(data.sequence)\n            qual_len = 0\n            while line and qual_len < seq_len:\n                append(quality_list, line)\n                qual_len += len(line)\n                line = strip(next_line(handle))  # Raises StopIteration at EOF\n            header = line  # Store current line so it's not lost next iteration\n            data.quality = join('', quality_list)\n\n            yield data\n\n    except StopIteration:  # Yield last FASTQ entry\n        data.quality = join('', quality_list)\n        yield data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning FASTQ formatted string containing entire FASTQ entry", "response": "def write(self):\n        \"\"\"Return FASTQ formatted string\n\n        Returns:\n            str: FASTQ formatted string containing entire FASTQ entry\n        \"\"\"\n\n        if self.description:\n            return '@{0} {1}{4}{2}{4}+{4}{3}{4}'.format(self.id,\n                                                        self.description,\n                                                        self.sequence,\n                                                        self.quality,\n                                                        os.linesep)\n        else:\n            return '@{0}{3}{1}{3}+{3}{2}{3}'.format(self.id,\n                                                    self.sequence,\n                                                    self.quality,\n                                                    os.linesep)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef buildWorkbenchWithLauncher():\n    workbench = ui.Workbench()\n\n    tools = [exercises.SearchTool()]\n    launcher = ui.Launcher(workbench, tools)\n    workbench.display(launcher)\n\n    return workbench, launcher", "response": "Builds a workbench with a launcher with all of the default tools."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef buildMainLoop(workbench, launcher, **kwargs):\n    unhandledInput = partial(ui._unhandledInput,\n                             workbench=workbench,\n                             launcher=launcher)\n    mainLoop = urwid.MainLoop(widget=workbench.widget,\n                              palette=ui.DEFAULT_PALETTE,\n                              unhandled_input=unhandledInput,\n                              event_loop=urwid.TwistedEventLoop(),\n                              **kwargs)\n    return mainLoop", "response": "Builds a main loop from the given workbench and launcher."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_status(status, message=None, extra=None):\n    if status in HTTP_STATUS_CODES:\n        return HTTP_STATUS_CODES[status](message=message, extra=extra)\n    else:\n        return Error(\n            code=status, message=message if message else \"Unknown Error\",\n            extra=extra\n        )", "response": "Try to create an error from status code."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_response(response, url):\n    # noinspection PyBroadException\n    try:\n        data = response.json()\n        if not isinstance(data, dict):\n            return from_status(\n                response.status_code, response.text,\n                extra=dict(url=url, response=response.text)\n            )\n\n        code = data.get('code', response.status_code)\n        if code in HTTP_STATUS_CODES:\n            return HTTP_STATUS_CODES[code](**ErrorSchema().load(data))\n        else:\n            return Error(**ErrorSchema().load(data))\n    except Exception:\n        return from_status(\n            response.status_code, response.text,\n            extra=dict(url=url, response=response.text)\n        )", "response": "Try to create an error from a HTTP response."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading all AgentML files contained in a directory.", "response": "def load_directory(self, dir_path):\n        \"\"\"\n        Load all AgentML files contained in a specified directory\n        :param dir_path: Path to the directory\n        :type  dir_path: str\n        \"\"\"\n        self._log.info('Loading all AgentML files contained in: ' + dir_path)\n\n        # Get a list of file paths\n        aml_files = []\n        for root, dirs, files in os.walk(dir_path):\n            aml_files += ['{root}/{file}'.format(root=root, file=file)\n                          for file in sorted(files) if file.endswith('.aml')]\n\n        # Loop through the files and load each one individually\n        for file in aml_files:\n            self.load_file(file)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_file(self, file_path):\n        self._log.info('Loading file: ' + file_path)\n        agentml = etree.parse(file_path)\n\n        # Validate the file for proper AgentML syntax\n        self._schema.assertValid(agentml)\n\n        # Get our root element and parse all elements inside of it\n        root = etree.parse(file_path).getroot()\n        defaults = {}\n\n        def parse_element(element):\n            for child in element:\n                # Initialization\n                if child.tag == 'init':\n                    Init(self, child, file_path)\n\n                # Set the group\n                if child.tag == 'group':\n                    self._log.info('Setting Trigger group: {group}'.format(group=child.get('name')))\n                    defaults['groups'] = {child.get('name')}  # TODO\n                    parse_element(child)\n                    del defaults['groups']\n                    continue\n\n                # Set the topic\n                if child.tag == 'topic':\n                    self._log.info('Setting Trigger topic: {topic}'.format(topic=child.get('name')))\n                    defaults['topic'] = child.get('name')\n                    parse_element(child)\n                    del defaults['topic']\n                    continue\n\n                # Set the emotion\n                if child.tag == 'emotion':\n                    self._log.info('Setting Trigger emotion: {emotion}'.format(emotion=child.get('name')))\n                    defaults['emotion'] = child.get('name')\n                    parse_element(child)\n                    del defaults['emotion']\n                    continue\n\n                # Parse a standard Trigger element\n                if child.tag == 'trigger':\n                    try:\n                        self.add_trigger(Trigger(self, child, file_path, **defaults))\n                    except AgentMLError:\n                        self._log.warn('Skipping Trigger due to an error', exc_info=True)\n\n        # Begin element iteration by parsing the root element\n        parse_element(root)", "response": "Load a single AgentML file into the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsorts the list of all the triggers and their associated responses by priority.", "response": "def sort(self):\n        \"\"\"\n        Sort triggers and their associated responses\n        \"\"\"\n        # Sort triggers by word and character length first\n        for priority, triggers in self._triggers.items():\n            self._log.debug('Sorting priority {priority} triggers'.format(priority=priority))\n\n            # Get and sort our atomic and wildcard patterns\n            atomics = [trigger for trigger in triggers if trigger.pattern_is_atomic]\n            wildcards = [trigger for trigger in triggers if not trigger.pattern_is_atomic]\n\n            atomics = sorted(atomics, key=lambda trigger: (trigger.pattern_words, trigger.pattern_len), reverse=True)\n            wildcards = sorted(wildcards, key=lambda trigger: (trigger.pattern_words, trigger.pattern_len),\n                               reverse=True)\n\n            # Replace our sorted triggers\n            self._triggers[priority] = atomics + wildcards\n\n        # Finally, sort triggers by priority\n        self._sorted_triggers = []\n\n        for triggers in [self._triggers[priority] for priority in sorted(self._triggers.keys(), reverse=True)]:\n            for trigger in triggers:\n                self._sorted_triggers.append(trigger)\n\n        self.sorted = True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattempt to retrieve a reply to the provided message :param user: The user / client. This can be a hostmask, IP address, database ID or any other unique identifier :type user: str :param message: The message to retrieve a reply to :type message: string_types :param groups: The trigger groups to search, defaults to only matching non-grouped triggers :type groups: set or AnyGroup :rtype: str or None", "response": "def get_reply(self, user, message, groups=None):\n        \"\"\"\n        Attempt to retrieve a reply to the provided message\n        :param user: The user / client. This can be a hostmask, IP address, database ID or any other unique identifier\n        :type  user: str\n\n        :param message: The message to retrieve a reply to\n        :type  message: string_types\n\n        :param groups: The trigger groups to search, defaults to only matching non-grouped triggers\n        :type  groups: set or AnyGroup\n\n        :rtype: str or None\n        \"\"\"\n        # Make sure triggers have been sorted since the most recent trigger was added\n        if not self.sorted:\n            self.sort()\n\n        user = self.get_user(user)\n        groups = groups or {None}\n\n        # Log this request\n        message = Message(self, message)\n        request_log_entry = self.request_log.add(user, message, groups)\n\n        # Fetch triggers in our topic and make sure we're not in an empty topic\n        triggers = [trigger for trigger in self._sorted_triggers if user.topic == trigger.topic]\n\n        if not triggers and user.topic is not None:\n            self._log.warn('User \"{user}\" was in an empty topic: {topic}'.format(user=user.id, topic=user.topic))\n            user.topic = None\n            triggers = [trigger for trigger in self._sorted_triggers if user.topic == trigger.topic]\n\n        # It's impossible to get anywhere if there are no empty topic triggers available to guide us\n        if not triggers:\n            raise AgentMLError('There are no empty topic triggers defined, unable to continue')\n\n        # Fetch triggers in our group and make sure we're not in an empty topic\n        if groups is not AnyGroup:\n            triggers = [trigger for trigger in triggers if groups.issuperset(trigger.groups or {None})]\n\n        if not triggers:\n            if not user.topic:\n                self._log.info('There are no topicless triggers matching the specific groups available, giving up')\n                return\n\n            self._log.info('The topic \"{topic}\" has triggers, but we are not in the required groups to match them. '\n                           'Resetting topic to None and retrying'.format(topic=user.topic, groups=str(groups)))\n            user.topic = None\n            triggers = [trigger for trigger in self._sorted_triggers if user.topic == trigger.topic]\n\n        for trigger in triggers:\n            try:\n                match = trigger.match(user, message)\n            except ParserBlockingError:\n                return\n\n            if match:\n                message = str(match)\n                request_log_entry.response = self.response_log.add(message, request_log_entry)\n                return message\n\n        # If we're still here, no reply was matched. If we're in a topic, exit and retry\n        if user.topic:\n            self._log.info('No reply matched in the topic \"{topic}\", resetting topic to None and retrying'\n                           .format(topic=user.topic))\n            user.topic = None\n\n            # noinspection PyTypeChecker\n            return self.get_reply(user.id, message.raw)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a new trigger to the list of triggers.", "response": "def add_trigger(self, trigger):\n        \"\"\"\n        Add a new trigger\n        :param trigger: The Trigger object\n        :type  trigger: Trigger\n        \"\"\"\n        # Make sure triggers are re-sorted before a new reply can be requested\n        self.sorted = False\n\n        # If no trigger with this priority level has been defined yet, create a new list\n        if trigger.priority not in self._triggers:\n            self._triggers[trigger.priority] = [trigger]\n            return\n\n        # Otherwise, add this trigger to an existing priority list\n        self._triggers[trigger.priority].append(trigger)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_substitution(self, word, substitution):\n        # Parse the word and its substitution\n        raw_word = re.escape(word)\n        raw_substitution = substitution\n\n        case_word = re.escape(normalize(word, preserve_case=True))\n        case_substitution = normalize(substitution, preserve_case=True)\n\n        word = re.escape(normalize(word))\n        substitution = normalize(substitution)\n\n        # Compile and group the regular expressions\n        raw_sub = (re.compile(r'\\b{word}\\b'.format(word=raw_word), re.IGNORECASE), raw_substitution)\n        case_sub = (re.compile(r'\\b{word}\\b'.format(word=case_word), re.IGNORECASE), case_substitution)\n        sub = (re.compile(r'\\b{word}\\b'.format(word=word), re.IGNORECASE), substitution)\n\n        sub_group = (sub, case_sub, raw_sub)\n\n        # Make sure this substitution hasn't already been processed and add it to the substitutions list\n        if sub_group not in self._substitutions:\n            self._log.info('Appending new word substitution: \"{word}\" => \"{sub}\"'.format(word=word, sub=substitution))\n            self._substitutions.append(sub_group)", "response": "Add a word to the substitution list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the substitutions in a supplied message.", "response": "def parse_substitutions(self, messages):\n        \"\"\"\n        Parse substitutions in a supplied message\n        :param messages: A tuple messages being parsed (normalized, case preserved, raw)\n        :type  messages: tuple of (str, str, str)\n\n        :return: Substituted messages (normalized, case preserved, raw)\n        :rtype : tuple of (str, str, str)\n        \"\"\"\n        # If no substitutions have been defined, just normalize the message\n        if not self._substitutions:\n            self._log.info('No substitutions to process')\n            return messages\n\n        self._log.info('Processing message substitutions')\n\n        def substitute(sub_group, sub_message):\n            word, substitution = sub_group\n            return word.sub(substitution, sub_message)\n\n        normalized, preserve_case, raw = messages\n        for sub_normalized, sub_preserve_case, sub_raw in self._substitutions:\n            normalized = substitute(sub_normalized, normalized)\n            preserve_case = substitute(sub_preserve_case, preserve_case)\n            raw = substitute(sub_raw, raw)\n\n        return normalized, preserve_case, raw"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve a global or user variable by name", "response": "def get_var(self, name, user=None):\n        \"\"\"\n        Retrieve a global or user variable\n        :param name: The name of the variable to retrieve\n        :type  name: str\n\n        :param user: If retrieving a user variable, the user identifier\n        :type  user: str or None\n\n        :rtype: str\n\n        :raises UserNotDefinedError: The specified user does not exist\n        :raises VarNotDefinedError: The requested variable has not been defined\n        \"\"\"\n        # Retrieve a user variable\n        if user is not None:\n            if user not in self._users:\n                raise UserNotDefinedError\n\n            return self._users[user].get_var(name)\n\n        # Retrieve a global variable\n        if name not in self._global_vars:\n            raise VarNotDefinedError\n\n        return self._global_vars[name]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_var(self, name, value, user=None):\n        # Set a user variable\n        if user is not None:\n            if user not in self._users:\n                raise UserNotDefinedError\n\n            self._users[user].set_var(name, value)\n            return\n\n        # Set a global variable\n        self._global_vars[name] = value", "response": "Set a global or user variable"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting a new global trigger or response limit for the given identifier.", "response": "def set_limit(self, identifier, expires_at, blocking=False):\n        \"\"\"\n        Set a new global trigger or response limit\n        :param identifier: The Trigger or Response object\n        :type  identifier: parser.trigger.Trigger or parser.trigger.response.Response\n\n        :param expires_at: The limit expiration as a Unix timestamp\n        :type  expires_at: float\n\n        :param blocking: When True and a limit is triggered, no other Trigger or Response's will be attempted\n        :type  blocking: bool\n        \"\"\"\n        self._limits[identifier] = (expires_at, blocking)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a single or all limits for the specified identifier.", "response": "def clear_limit(self, identifier=None):\n        \"\"\"\n        Remove a single limit or all defined limits\n        :param identifier: The identifier to clear limits for, or if no identifier is supplied, clears ALL limits\n        :type  identifier: int\n\n        :return: True if a limit was successfully found and removed, False if no limit could be matched for removal\n        :rtype : bool\n        \"\"\"\n        # Remove a single limit\n        if identifier:\n            if identifier in self._limits:\n                del self._limits[identifier]\n                return True\n            else:\n                return False\n\n        # Remove all limits\n        if self._limits:\n            self._limits.clear()\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntesting whether or not the specified object has a global limit for the specified Trigger or Response.", "response": "def is_limited(self, identifier):\n        \"\"\"\n        Test whether or not there is an active global limit for the specified Trigger or Response instance\n        :param identifier: The Trigger or Response object\n        :type  identifier: parser.trigger.Trigger or parser.trigger.response.Response\n\n        :return: True if there is a limit enforced, otherwise False\n        :rtype : bool\n        \"\"\"\n        # If there is a limit for this Trigger assigned, make sure it hasn't expired\n        if identifier in self._limits:\n            limit, blocking = self._limits[identifier]\n            if time() < limit:\n                # Limit exists and is active, return True\n                self._log.debug('Global limit enforced for Object {oid}'\n                                .format(oid=id(identifier)))\n                if blocking:\n                    raise LimitError\n                return True\n            else:\n                # Limit has expired, remove it\n                del self._limits[identifier]\n\n        # We're still here, so there are no active limits. Return False\n        self._log.debug('No global limit enforced for Object {oid}'.format(oid=id(identifier)))\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a new custom condition type parser", "response": "def add_condition(self, name, cond_class):\n        \"\"\"\n        Add a new custom condition type parser\n        :param name: The name of the condition type\n        :type  name: str\n\n        :param cond_class: The Class\n        :return:\n        \"\"\"\n        # Has this condition type already been defined?\n        if name in self.conditions:\n            self._log.warn('Overwriting an existing Condition Type class: {type}'.format(type=name))\n\n        if not issubclass(cond_class, ConditionType):\n            self._log.error('Condition Type class must implement the base ConditionType interface, please review the '\n                            'documentation on defining custom condition types. (Refusing to set the condition type '\n                            '\"{type}\")'.format(type=name))\n            return\n\n        self.conditions[name] = cond_class(name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndefining a new tag parser method", "response": "def set_tag(self, name, tag_class):\n        \"\"\"\n        Define a new tag parser method\n        :param name: The name of the tag\n        :type  name: str\n\n        :param tag_class: The Tag class, this must be a subclass of base parser.tags.Tag\n        :type  tag_class: Tag\n        \"\"\"\n        # Has this tag already been defined?\n        if name in self._tags:\n            self._log.warn('Overwriting an existing Tag class: {tag}'.format(tag=name))\n\n        # Make sure the tag class adhered to the base Tag interface\n        if not issubclass(tag_class, Tag):\n            self._log.error('Tag class must implement the base Tag interface, please review the documentation on '\n                            'defining custom tags. (Refusing to set the tag \"{tag}\")'.format(tag=name))\n            return\n\n        self._tags[name] = tag_class"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the tags in an XML element and returns a list of strings and Tag objects.", "response": "def parse_tags(self, element, trigger):\n        \"\"\"\n        Parse tags in an XML element\n        :param element: The response [message] XML element\n        :type  element: etree._Element\n\n        :return: A list of strings and Tag objects in the order they are parsed\n        :rtype : list of (str or parser.tags.tag,Tag)\n        \"\"\"\n        response = []\n\n        # Add the starting text to the response list\n        head = element.text if isinstance(element.text, string_types) else None\n        if head:\n            if head.strip():\n                head = newlines_to_spaces(head)\n                self._log.debug('Appending heading text: {text}'.format(text=head))\n            response.append(head)\n\n        # Internal method for appending an elements tail to the response list\n        def append_tail(e):\n            tail = e.tail if isinstance(e.tail, string_types) else None\n            if tail:\n                if tail.strip():\n                    tail = newlines_to_spaces(tail)\n                    self._log.debug('Appending trailing text: {text}'.format(text=tail))\n                response.append(tail)\n\n        # Parse the contained tags and add their associated string objects to the response list\n        for child in element:\n            # Parse star tags internally\n            if child.tag == 'star':\n                star_index = int_attribute(child, 'index', 1)\n                star_format = attribute(child, 'format', 'none')\n                self._log.debug('Appending Star tag object with index {no}'.format(no=star_index))\n\n                response.append(Star(trigger, star_index, star_format))\n                append_tail(child)\n                continue\n\n            # Make sure a parser for this tag exists\n            if child.tag not in self._tags:\n                self._log.warn('No parsers available for Tag \"{tag}\", skipping'.format(tag=child.tag))\n                continue\n\n            # Append the tag object to the response string\n            tag = self._tags[child.tag]\n            self._log.debug('Appending {tag} Tag object'.format(tag=child.tag.capitalize()))\n            response.append(tag(trigger, child))\n\n            # Append the trailing text to the response string (if there is any)\n            append_tail(child)\n\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef interpreter(self):\n        while True:\n            message = input('[#] ')\n            if message.lower().strip() == 'exit':\n                break\n\n            reply = self.get_reply('#interpreter#', message)\n            if not reply:\n                print('No reply received.', end='\\n\\n')\n                continue\n\n            # typewrite(reply, end='\\n\\n') TODO\n            print(reply, end='\\n\\n')", "response": "Launch an AML interpreter session for testing\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format(self, message_format):\n        if message_format not in self.formats:\n            self._log.error('Invalid Message format specified: {format}'.format(format=message_format))\n            return\n\n        self._log.debug('Setting message format to {format}'.format(format=message_format))\n        self._format = message_format", "response": "Set the message format"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a variable assigned to this user", "response": "def get_var(self, name):\n        \"\"\"\n        Retrieve a variable assigned to this user\n        :param name: The name of the variable to retrieve\n        :type  name: str\n\n        :rtype: str\n\n        :raises VarNotDefinedError: The requested variable has not been defined\n        \"\"\"\n        if name not in self._vars:\n            raise VarNotDefinedError\n\n        return self._vars[name]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef registration(uri):\n\n    # log the URI that is used to access the Stack-In-A-Box services\n    logger.debug('Registering Stack-In-A-Box at {0} under Python Responses'\n                 .format(uri))\n    # tell Stack-In-A-Box what URI to match with\n    StackInABox.update_uri(uri)\n\n    # Build the regex for the URI and register all HTTP verbs\n    # with Responses\n    regex = re.compile('(http)?s?(://)?{0}:?(\\d+)?/'.format(uri),\n                       re.I)\n    METHODS = [\n        responses.DELETE,\n        responses.GET,\n        responses.HEAD,\n        responses.OPTIONS,\n        responses.PATCH,\n        responses.POST,\n        responses.PUT\n    ]\n    for method in METHODS:\n        responses.add_callback(method,\n                               regex,\n                               callback=responses_callback)", "response": "Registers a handler for a given URI with Responses\n    so that it can be intercepted and handed to Stack - In - A - Box."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncaches the return of the function until the the specified time has elapsed or the arguments change. If timeout is None it will not be considered.", "response": "def cacheOnSameArgs(timeout=None):\n    \"\"\" Caches the return of the function until the the specified time has\n        elapsed or the arguments change.  If timeout is None it will not\n        be considered. \"\"\"\n    if isinstance(timeout, int):\n        timeout = datetime.timedelta(0, timeout)\n\n    def decorator(f):\n        _cache = [None]\n\n        def wrapper(*args, **kwargs):\n            if _cache[0] is not None:\n                cached_ret, dt, cached_args, cached_kwargs = _cache[0]\n                if (timeout is not None and\n                        dt + timeout <= datetime.datetime.now()):\n                    _cache[0] = None\n                if (cached_args, cached_kwargs) != (args, kwargs):\n                    _cache[0] = None\n            if _cache[0] is None:\n                ret = f(*args, **kwargs)\n                _cache[0] = (ret, datetime.datetime.now(), args, kwargs)\n            return _cache[0][0]\n        return wrapper\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions to verify if a file exists in the base directory of the base directory", "response": "def verify_file_exists(file_name, file_location):\n    \"\"\"\n    Function to verify if a file exists\n    Args:\n        file_name: The name of file to check\n        file_location: The location of the file, derive from the os module\n\n    Returns: returns boolean True or False\n\n    \"\"\"\n    return __os.path.isfile(__os.path.join(file_location, file_name))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfunctioning to increase a filename by a number 1", "response": "def file_name_increase(file_name, file_location):\n    \"\"\"\n    Function to increase a filename by a number 1\n    Args:\n        file_name: The name of file to check\n        file_location: The location of the file, derive from the os module\n\n    Returns: returns a good filename.\n\n    \"\"\"\n    add_one = 1\n    file_name_temp = file_name\n    while verify_file_exists(file_name_temp, file_location):\n        try:\n            name, file_extension = file_name.split('.')\n            file_name_temp = '%s-%i.%s' % (name, add_one, file_extension)\n        except Exception as e:\n            LOGGER.critical('Function file_name_increase Error {error} ignoring any errors'.format(error=e))\n            name = file_name\n            file_name_temp = '%s-%i' % (name, add_one)\n        add_one += 1\n    file_name = file_name_temp\n    return file_name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify_directory(directory_name, directory_location, directory_create=False):\n    if not directory_create:\n        return __os.path.exists(__os.path.join(directory_location, directory_name))\n    elif directory_create:\n        good = __os.path.exists(__os.path.join(directory_location, directory_name))\n        if not good:\n            __os.mkdir(__os.path.join(directory_location, directory_name))", "response": "Function to verify if a directory exists in the system"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfunctioning to export a list to a text file", "response": "def list_to_file(orig_list, file_name, file_location):\n    \"\"\"\n    Function to export a list to a text file\n    Args:\n        orig_list: The list you want exported\n        file_name: The name of the exported file\n        file_location: The location of the file, derive from the os module\n\n    Returns: returns the filename info\n\n    \"\"\"\n    file = __os.path.join(file_location, file_name)\n\n    def add_line_break(list_line):\n        \"\"\"\n        Create a line break at the end of a string\n        Args:\n            list_line: string\n\n        Returns: A string with a line break\n\n        \"\"\"\n        list_line = ('%s\\n' % (list_line,))\n        return list_line\n    write_file = open(file, \"a\")\n    for orig_list_line in orig_list:\n        write_file.write(add_line_break(str(orig_list_line)))\n    write_file.close()\n    return file_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions to import a text file to a list", "response": "def file_to_list(file_name, file_location):\n    \"\"\"\n    Function to import a text file to a list\n    Args:\n        file_name: The name of file to be import\n        file_location: The location of the file, derive from the os module\n\n    Returns: returns a list\n\n    \"\"\"\n    file = __os.path.join(file_location, file_name)\n    read_file = open(file, \"r\")\n    temp_list = read_file.read().splitlines()\n    read_file.close()\n    return temp_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions to import a csv as a dictionary", "response": "def csv_to_dict(file_name, file_location):\n    \"\"\"\n    Function to import a csv as a dictionary\n    Args:\n        file_name: The name of the csv file\n        file_location: The location of the file, derive from the os module\n\n    Returns: returns a dictionary\n\n    \"\"\"\n    file = __os.path.join(file_location, file_name)\n    try:\n        csv_read = open(file, \"r\")\n    except Exception as e:\n        LOGGER.critical('Function csv_to_dict Error {error} ignoring any errors'.format(error=e))\n        print('Error {error} ignoring any errors'.format(error=e))\n        csv_read = open(file, \"r\", errors='ignore')\n    data_row = __csv.DictReader(csv_read, dialect=\"excel\")\n    dict_key = 1\n    temp_dict = dict()\n    for row in data_row:\n        temp_dict[dict_key] = row\n        dict_key += 1\n    csv_read.close()\n    return temp_dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dict_to_csv(orig_dict, file_name, field_names_tuple, file_location):\n    file = __os.path.join(file_location, file_name)\n    csv_write = open(file, 'a')\n    writer = __csv.DictWriter(csv_write, fieldnames=field_names_tuple, lineterminator='\\n')\n    headers = dict((n, n) for n in field_names_tuple)\n    writer.writerow(headers)\n    for dict_key, a in list(orig_dict.items()):\n        writer.writerow(orig_dict[dict_key])\n    csv_write.close()\n    return file_name", "response": "Function to export a dictionary to a csv file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction to store objects in a shelve storage file", "response": "def store_object(file_name, save_key, file_location, object_to_store=None):\n    \"\"\"\n    Function to store objects in a shelve\n    Args:\n        file_name: Shelve storage file name\n        save_key: The name of the key to store the item to\n        file_location: The location of the file, derive from the os module\n        object_to_store: The object you want to store\n\n    Returns:\n\n    \"\"\"\n    file = __os.path.join(file_location, file_name)\n    try:\n        shelve_store = __shelve.open(file)\n    except Exception as e:\n        LOGGER.critical('Function store_object Error {error} ignoring any errors'.format(error=e))\n        print('Bad storage dB, rebuilding!!')\n        __os.remove(file)\n        shelve_store = __shelve.open(file)\n    shelve_store[save_key] = object_to_store\n    shelve_store.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef retrieve_object_from_file(file_name, save_key, file_location):\n    shelve_store = None\n    file = __os.path.join(file_location, file_name)\n    try:\n        shelve_store = __shelve.open(file)\n    except Exception as e:\n        LOGGER.critical('Function retrieve_object_from_file Error {error} ignoring any errors'.format(error=e))\n        __sys.exit('Storage dB is not readable, closing App!!')\n    stored_object = shelve_store.get(save_key)\n    shelve_store.close()\n    return stored_object", "response": "Function to retrieve objects from a shelve file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_object_from_file(file_name, save_key, file_location):\n    file = __os.path.join(file_location, file_name)\n    shelve_store = __shelve.open(file)\n    del shelve_store[save_key]\n    shelve_store.close()", "response": "Function to delete objects from a shelve file"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify_key_in_shelve(file_name, save_key, file_location):\n    file = __os.path.join(file_location, file_name)\n    shelve_store = __shelve.open(file)\n    exists = shelve_store.get(save_key)\n    shelve_store.close()\n    if exists:\n        return True\n\n    elif not exists:\n        return False", "response": "Function to check if a key in a shelve file exists in the shelve store"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_keys_from_shelve(file_name, file_location):\n    temp_list = list()\n    file = __os.path.join(file_location, file_name)\n    shelve_store = __shelve.open(file)\n    for key in shelve_store:\n        temp_list.append(key)\n    shelve_store.close()\n    return temp_list", "response": "Function to retreive all keys in a shelve file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving a symbol from a string and replaces it with a different one", "response": "def remove_symbol_add_symbol(string_item, remove_symbol, add_symbol):\n    \"\"\"\n    Remove a symbol from a string, and replace it with a different one\n    Args:\n        string_item: String that you want to replace symbols in\n        remove_symbol: Symbol to remove\n        add_symbol: Symbol to add\n\n    Returns: returns a string with symbols swapped\n\n    \"\"\"\n    string_item = add_symbol.join(string_item.split(remove_symbol))\n    return string_item"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist the files in a specified directory", "response": "def list_files_in_directory(full_directory_path):\n    \"\"\"\n    List the files in a specified directory\n    Args:\n        full_directory_path: The full directory path to check, derive from the os module\n\n    Returns: returns a list of files\n\n    \"\"\"\n    files = list()\n    for file_name in __os.listdir(full_directory_path):\n        if __os.path.isfile(__os.path.join(full_directory_path, file_name)):\n            files.append(file_name)\n    return files"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_directories_in_directory(full_directory_path):\n    directories = list()\n    for directory_name in __os.listdir(full_directory_path):\n        if __os.path.isdir(__os.path.join(full_directory_path, directory_name)):\n            directories.append(directory_name)\n    return directories", "response": "List the directories in a specified directory"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction to split every line in a list and retain spaces for a rejoin", "response": "def split_strings_in_list_retain_spaces(orig_list):\n    \"\"\"\n    Function to split every line in a list, and retain spaces for a rejoin\n    :param orig_list: Original list\n    :return:\n        A List with split lines\n\n    \"\"\"\n    temp_list = list()\n    for line in orig_list:\n        line_split = __re.split(r'(\\s+)', line)\n        temp_list.append(line_split)\n\n    return temp_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef random_line_data(chars_per_line=80):\n    return ''.join(__random.choice(__string.ascii_letters) for x in range(chars_per_line))", "response": "Function to create a random string of a random number of characters per line"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction to create lines of random string data", "response": "def random_data(line_count=1, chars_per_line=80):\n    \"\"\"\n    Function to creates lines of random string data\n    Args:\n        line_count: An integer that says how many lines to return\n        chars_per_line: An integer that says how many characters per line to return\n\n    Returns:\n        A String\n\n    \"\"\"\n    divide_lines = chars_per_line * line_count\n    return '\\n'.join(random_line_data(chars_per_line) for x in range(int(divide_lines / chars_per_line)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions to collect files and zip them into a zip file.", "response": "def collect_and_zip_files(dir_list, output_dir, zip_file_name, file_extension_list=None, file_name_list=None):\n    \"\"\"\n    Function to collect files and make a zip file\n    :param dir_list: A list of directories\n    :param output_dir: The output directory\n    :param zip_file_name: Zip file name\n    :param file_extension_list: A list of extensions of files to find\n    :param file_name_list: A list of file names to find\n    :return:\n        Outputs a zip file\n\n    Note: If no file_extension_list and file_name_list are provided it will zip the entire directory.\n\n    \"\"\"\n    temp_list = list()\n\n    if isinstance(dir_list, list):\n        for dir_name in dir_list:\n            if not __os.path.isdir(dir_name):\n                error = 'Function collect_and_zip_files received an item that is not a directory {}'.format(dir_name)\n                LOGGER.critical(error)\n                raise Exception(error)\n\n    else:\n        error = 'Function collect_and_zip_files expected dir_list to be a list but received a {}'.format(type(dir_list))\n        LOGGER.critical(error)\n        raise TypeError(error)\n\n    if not file_extension_list and not file_name_list:\n        for dir_name in dir_list:\n            temp_files_list = list_files_in_directory(dir_name)\n            for file_name in temp_files_list:\n                temp_list.append(__os.path.join(dir_name, file_name))\n\n    if file_extension_list:\n        if isinstance(file_extension_list, list):\n            for dir_name in dir_list:\n                temp_files_list = list_files_in_directory(dir_name)\n                for file_name in temp_files_list:\n                    garbage, extension = file_name.split('.')\n                    if extension in file_extension_list:\n                        temp_list.append(__os.path.join(dir_name, file_name))\n\n        else:\n            error = 'Function collect_and_zip_files expected file_extension_list to be a ' \\\n                    'list but received a {}'.format(type(file_extension_list))\n            LOGGER.critical(error)\n            raise TypeError(error)\n\n    if file_name_list:\n        if isinstance(file_name_list, list):\n            for dir_name in dir_list:\n                temp_files_list = list_files_in_directory(dir_name)\n                for file_name in temp_files_list:\n                    if file_name in file_name_list:\n                        temp_list.append(__os.path.join(dir_name, file_name))\n\n        else:\n            error = 'Function collect_and_zip_files expected file_name_list to be a list but ' \\\n                    'received a {}'.format(type(file_name_list))\n            LOGGER.critical(error)\n            raise TypeError(error)\n\n    if len(zip_file_name.split('.')) == 2:\n        name, ext = zip_file_name.split('.')\n        if ext != 'zip':\n            LOGGER.warning('Changed the extension of zip_file_name={} to be zip'.format(zip_file_name))\n            zip_file_name = '{}.{}'.format(name, 'zip')\n\n    else:\n        error = 'Function collect_and_zip_files expected zip_file_name to only contain one . ' \\\n                'but received {}'.format(zip_file_name)\n        LOGGER.critical(error)\n        raise NameError(error)\n\n    with __zipfile.ZipFile(__os.path.join(output_dir, zip_file_name), 'a') as the_zip_file:\n        for file in temp_list:\n            the_zip_file.write(file)\n\n    the_zip_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef import_module(module):\n    try:\n        __import__('{0}.service'.format(module))\n    except ImportError:\n        LOGGER.error('No module/service found. Quit.')\n        sys.exit(0)", "response": "Import a module and add it to the entrypoints."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntries to import the models module.", "response": "def import_models(module):\n    \"\"\"\n    | Given a module `service`, try to import its models module.\n\n    :param module: The module's name to import the models.\n    :type module: str\n    :rtype: list\n    :returns: all the models defined.\n    \"\"\"\n    try:\n        module = importlib.import_module('{0}.models'.format(module))\n    except ImportError:\n        return []\n    else:\n        clsmembers = inspect.getmembers(module, lambda member: inspect.isclass(member) and member.__module__ == module.__name__)\n        return [kls for name, kls in clsmembers]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstarting all the registered entrypoints | that have been added to ENTRYPOINTS.", "response": "def start():\n    \"\"\"\n    | Start all the registered entrypoints\n    | that have been added to `ENTRYPOINTS`.\n\n    :rtype: None\n    \"\"\"\n    pool = gevent.threadpool.ThreadPool(len(ENTRYPOINTS))\n    for entrypoint, callback, args, kwargs in ENTRYPOINTS:\n        cname = callback.__name__\n        #1. Retrieve the class which owns the callback\n        for name, klass in inspect.getmembers(sys.modules[callback.__module__], inspect.isclass):\n            if hasattr(klass, cname):\n                service_name = name.lower()\n                break\n        #2.Start the entrypoint\n        callback = getattr(klass(), cname)\n        kwargs.update({'service':service_name, 'callback':callback, 'callback_name': cname})\n        LOGGER.info('Start service %s[%s].', service_name.capitalize(), cname)\n        obj = entrypoint(*args, **kwargs)\n        pool.spawn(obj.start, *args, **kwargs)\n    pool.join()\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a service to the thread s StackInABox instance.", "response": "def register_service(cls, service):\n        \"\"\"Add a service to the thread's StackInABox instance.\n\n        :param service: StackInABoxService instance to add to the test\n\n        For return value and errors see StackInABox.register()\n\n        \"\"\"\n        logger.debug('Registering service {0}'.format(service.name))\n        return local_store.instance.register(service)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef call_into(cls, method, request, uri, headers):\n        logger.debug('Request: {0} - {1}'.format(method, uri))\n        return local_store.instance.call(method,\n                                         request,\n                                         uri,\n                                         headers)", "response": "Make a call into the thread s StackInABox instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hold_onto(cls, name, obj):\n        logger.debug('Holding on {0} of type {1} with id {2}'\n                     .format(name, type(obj), id(obj)))\n        local_store.instance.into_hold(name, obj)", "response": "Add data into the storage area provided by the framework."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting data from the storage area provided by the framework.", "response": "def hold_out(cls, name):\n        \"\"\"Get data from the storage area provided by the framework.\n\n        Note: The data is retrieved from the thread local instance.\n\n        :param name: name of the data to be retrieved\n\n        :returns: The data associated with the specified name.\n\n        For errors see StackInABox.from_hold()\n\n        \"\"\"\n        logger.debug('Retreiving {0} from hold'\n                     .format(name))\n        obj = local_store.instance.from_hold(name)\n        logger.debug('Retrieved {0} of type {1} with id {2} from hold'\n                     .format(name, type(obj), id(obj)))\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_uri(cls, uri):\n        logger.debug('Request: Update URI to {0}'.format(uri))\n        local_store.instance.base_url = uri", "response": "Set the URI of the StackInABox framework."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the URI from a given URL.", "response": "def get_services_url(url, base_url):\n        \"\"\"Get the URI from a given URL.\n\n        :returns: URI within the URL\n\n        \"\"\"\n        length = len(base_url)\n        checks = ['http://', 'https://']\n        for check in checks:\n            if url.startswith(check):\n                length = length + len(check)\n                break\n\n        result = url[length:]\n        logger.debug('{0} from {1} equals {2}'\n                     .format(base_url, url, result))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the Base URL property of the object.", "response": "def base_url(self, value):\n        \"\"\"Set the Base URL property, updating all associated services.\"\"\"\n        logger.debug('StackInABox({0}): Updating URL from {1} to {2}'\n                     .format(self.__id, self.__base_url, value))\n        self.__base_url = value\n        for k, v in six.iteritems(self.services):\n            matcher, service = v\n            service.base_url = StackInABox.__get_service_url(value,\n                                                             service.name)\n            logger.debug('StackInABox({0}): Service {1} has url {2}'\n                         .format(self.__id, service.name, service.base_url))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reset(self):\n        logger.debug('StackInABox({0}): Resetting...'\n                     .format(self.__id))\n        for k, v in six.iteritems(self.services):\n            matcher, service = v\n            logger.debug('StackInABox({0}): Resetting Service {1}'\n                         .format(self.__id, service.name))\n            service.reset()\n\n        self.services = {}\n        self.holds = {}\n\n        logger.debug('StackInABox({0}): Reset Complete'\n                     .format(self.__id))", "response": "Reset the stack in a like - new state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a service to the thread s StackInABox instance.", "response": "def register(self, service):\n        \"\"\"Add a service to the thread's StackInABox instance.\n\n        :param service: StackInABoxService instance to add to the test\n\n        :returns: None\n        :raises: ServiceAlreadyRegisteredError if the service already exists\n\n        \"\"\"\n        if service.name not in self.services.keys():\n            logger.debug('StackInABox({0}): Registering Service {1}'\n                         .format(self.__id, service.name))\n            regex = '^/{0}/'.format(service.name)\n            self.services[service.name] = [\n                re.compile(regex),\n                service\n            ]\n            service.base_url = StackInABox.__get_service_url(self.base_url,\n                                                             service.name)\n            logger.debug('StackInABox({0}): Service {1} has url {2}'\n                         .format(self.__id, service.name, service.base_url))\n        else:\n            raise ServiceAlreadyRegisteredError(\n                'Service {0} is already registered'.format(service.name))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef call(self, method, request, uri, headers):\n        logger.debug('StackInABox({0}): Received call to {1} - {2}'\n                     .format(self.__id, method, uri))\n        service_uri = StackInABox.get_services_url(uri, self.base_url)\n\n        for k, v in six.iteritems(self.services):\n            matcher, service = v\n            logger.debug('StackInABox({0}): Checking if Service {1} handles...'\n                         .format(self.__id, service.name))\n            logger.debug('StackInABox({0}): ...using regex pattern {1} '\n                         'against {2}'\n                         .format(self.__id, matcher.pattern, service_uri))\n            if matcher.match(service_uri):\n                logger.debug('StackInABox({0}): Trying Service {1} handler...'\n                             .format(self.__id, service.name))\n\n                try:\n                    service_caller_uri = service_uri[(len(service.name) + 1):]\n                    return service.request(method,\n                                           request,\n                                           service_caller_uri,\n                                           headers)\n                except Exception as ex:\n                    logger.exception('StackInABox({0}): Service {1} - '\n                                     'Internal Failure'\n                                     .format(self.__id, service.name))\n                    return (596,\n                            headers,\n                            'Service Handler had an error: {0}'.format(ex))\n        return (597, headers, 'Unknown service - {0}'.format(service_uri))", "response": "This function is called by the thread s method handler to get the response from the StackInABox instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef into_hold(self, name, obj):\n        logger.debug('StackInABox({0}): Holding onto {1} of type {2} '\n                     'with id {3}'\n                     .format(self.__id, name, type(obj), id(obj)))\n        self.holds[name] = obj", "response": "Add data into the storage area provided by the framework."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the data associated with the specified name from the storage area provided by the framework.", "response": "def from_hold(self, name):\n        \"\"\"Get data from the storage area provided by the framework.\n\n        Note: The data is retrieved from the thread local instance.\n\n        :param name: name of the data to be retrieved\n\n        :returns: The data associated with the specified name.\n        :raises: Lookup/KeyError error if the name does not match\n                 a value in the storage\n\n        \"\"\"\n        logger.debug('StackInABox({0}): Retreiving {1} from the hold'\n                     .format(self.__id, name))\n        obj = self.holds[name]\n        logger.debug('StackInABox({0}): Retrieved {1} of type {2} with id {3}'\n                     .format(self.__id, name, type(obj), id(obj)))\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main_callback(self, *args, **kwargs):\n        if not self.callback:\n            raise NotImplementedError('Entrypoints must declare `callback`')\n        if not self.settings:\n            raise NotImplementedError('Entrypoints must declare `settings`')\n\n        self.callback.im_self.db = None\n\n        #1. Start all the middlewares\n        with self.debug(*args, **kwargs):\n            with self.database():\n                #2. `Real` callback\n                result = self.callback(*args, **kwargs)#pylint: disable=not-callable\n        return result", "response": "This is the main callback called when an event is received from an entry point. It is called when an event is received from an entry point."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef database(self):\n        #1. Initialize\n        self.callback.im_self.db = sql.setup(self.settings)\n        if self.callback.im_self.db:\n            module = '.'.join(self.callback.im_self.__module__.split('.')[:-1])\n            sql.init(module, self.callback.im_self.db)\n            self.callback.im_self.db.connect()\n        yield\n        #2. Cleanup\n        if self.callback.im_self.db:\n            self.callback.im_self.db.close()", "response": "A context manager that initializes the database if needed."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns true if an element can be read otherwise false", "response": "def canRead(variable):\n    \"\"\"\n    mention if an element can be read.\n\n    :param variable: the element to evaluate.\n    :type variable: Lifepo4weredEnum\n    :return: true when read access is available, otherwise false.\n    :rtype: bool\n    :raises ValueError: if parameter value is not a member of Lifepo4weredEnum.\n    \"\"\"\n    if variable not in variablesEnum:\n        raise ValueError('Use a lifepo4wered enum element as parameter.')\n\n    return lifepo4weredSO.access_lifepo4wered(variable.value, defines.ACCESS_READ)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if the element can be written.", "response": "def canWrite(variable):\n    \"\"\"\n    mention if an element can be written.\n\n    :param variable: the element to evaluate.\n    :type variable: Lifepo4weredEnum\n    :return: true when write access is available, otherwise false\n    :rtype: bool\n    :raises ValueError: if parameter value is not a member of Lifepo4weredEnum\n    \"\"\"\n    if variable not in variablesEnum:\n        raise ValueError('Use a lifepo4wered enum element as parameter.')\n\n    return lifepo4weredSO.access_lifepo4wered(variable.value, defines.ACCESS_WRITE)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread an element from LiFePO4wered.", "response": "def read(variable):\n    \"\"\"\n    read an element from LiFePO4wered.\n\n    :param variable: the element to read.\n    :type variable: Lifepo4weredEnum\n    :return: the value of the element\n    :rtype: int\n    :raises ValueError: if parameter value is not a member of Lifepo4weredEnum\n    \"\"\"\n    if variable not in variablesEnum:\n        raise ValueError('Use a lifepo4wered enum element as read parameter.')\n    \n    if canRead(variable):\n        return lifepo4weredSO.read_lifepo4wered(variable.value)\n    else:\n        raise RuntimeError('You cannot read {0} value, just write it'.format(variable.name))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(variable, value):\n    if variable not in variablesEnum:\n        raise ValueError('Use a lifepo4wered enum element as write element.')\n    \n    if isinstance(value, int) is False:\n        raise TypeError('Use a int as value.')\n\n    if canWrite(variable):\n        return lifepo4weredSO.write_lifepo4wered(variable.value, value)\n    else:\n        raise RuntimeError('You cannot write {0} value, just read it'.format(variable.name))", "response": "Writes an element to LiFePO4wered."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning enforced ascii string \u00e9ko=>ko", "response": "def force_ascii(value):\n    \"\"\"\n        Return enforced ascii string\n        \u00e9ko=>ko\n    \"\"\"\n    if not isinstance(value, (str, unicode)):\n        return unicode(value)\n    if isinstance(value, unicode):\n        return unidecode.unidecode(value)\n    else:\n        return unidecode.unidecode(force_unicode(value))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a string encoded in the provided encoding", "response": "def force_encoding(value, encoding='utf-8'):\n    \"\"\"\n    Return a string encoded in the provided encoding\n    \"\"\"\n    if not isinstance(value, (str, unicode)):\n        value = str(value)\n    if isinstance(value, unicode):\n        value = value.encode(encoding)\n    elif encoding != 'utf-8':\n        value = value.decode('utf-8').encode(encoding)\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef force_unicode(value):\n    if not isinstance(value, (str, unicode)):\n        value = unicode(value)\n    if isinstance(value, str):\n        value = value.decode('utf-8')\n    return value", "response": "return an utf-8 unicode entry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a camel case name to a lowercase name", "response": "def camel_case_to_name(name):\n    \"\"\"\n    Used to convert a classname to a lowercase name\n    \"\"\"\n    def convert_func(val):\n        return \"_\" + val.group(0).lower()\n    return name[0].lower() + re.sub(r'([A-Z])', convert_func, name[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting the given datas to utf - 8 string entries in the given datas", "response": "def to_utf8(datas):\n    \"\"\"\n    Force utf8 string entries in the given datas\n    \"\"\"\n    res = datas\n    if isinstance(datas, dict):\n        res = {}\n        for key, value in datas.items():\n            key = to_utf8(key)\n            value = to_utf8(value)\n            res[key] = value\n\n    elif isinstance(datas, (list, tuple)):\n        res = []\n        for data in datas:\n            res.append(to_utf8(data))\n\n    elif isinstance(datas, unicode):\n        res = datas.encode('utf-8')\n\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list(self, entityid=None):\n\t\tparams = {}\n\t\tif entityid:\n\t\t\tparams['name'] = entityid\n\t\tdata = self._http_req('connections',params=params)\n\t\tentities = data['decoded']['connections']\n\n\t\t# hash key will be string (damned json), so convert to integer\n\t\tentities = {int(k): v for k, v in entities.items()}\n\t\tentities_list = sorted(entities.items(), key=lambda x: x[0])\n\t\tentities = OrderedDict(entities_list)\n\t\treturn entities", "response": "Return the entity with the given entity ID in short form."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the complete entity data of all records that are in the specified state.", "response": "def list_full(self, state):\n\t\t\"\"\"\n\t\tRetrieves the complete entity data of all records that are active and have \n\t\tthe supplied state.\n\t\t\n\t\tStates:\t'prodaccepted': it is in the production environment\n\t\t\t\t'testaccepted': it is in the test environment, used for testing,\n\t\t\t\t\t\t\t\tacceptation or development\n\t\t\t\t\n\t\t\"\"\"\n\t\tentities = self.list()\n\t\tselected = {}\n\t\tfor eid, entity in entities.items():\n\t\t\tif entity['isActive'] and entity['state']==state:\n\t\t\t\tprint(eid)\n\t\t\t\tselected[eid] = self.get(eid)\n\t\treturn selected"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_eids(self):\n\t\tentities = self.list()\n\t\treturn sorted([int(eid) for eid in entities])", "response": "Returns a list of all known EIDs in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_by_entityid(self, entityid):\n\t\tdata = self.list(entityid=entityid)\n\t\tif len(data) == 0:\n\t\t\treturn None\n\n\t\teid = int( next(iter(data)) )\n\t\tentity = self.get(eid)\n\n\t\tself.debug(0x01,entity)\n\t\treturn entity", "response": "Returns the entity with the given entity ID as a dict \n\t"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, eid):\n\t\tdata = self._http_req('connections/%u' % eid)\n\t\tself.debug(0x01, data['decoded'])\n\t\treturn data['decoded']", "response": "Returns a dict with the complete record of the entity with the given eid"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreplaces the record with the supplied dict. Places the supplied note as update message.", "response": "def replace(self, eid, entity, note=None, force=False):\n\t\t\"\"\"\n\t\treplace(int, dict, string, boolean):\n\t\t\n\t\tReplaces the record of the eid with the supplied dict. Places the \n\t\tsupplied note as update message.\n\t\t\"\"\"\n\t\t# we need to unset some fields in the entity, if they exist\n\t\tnewentity = entity\n\t\tfor field in ('createdAtDate','id','isActive','parentRevision','revisionNr','updatedAtDate','updatedByUserName','updatedFromIp'):\n\t\t\tif field in newentity: del newentity[field]\n\n\t\tif note:\n\t\t\tnewentity['revisionNote'] = note\n\t\telse:\n\t\t\tnewentity['revisionNote'] = \"Automatic change by user %s on %s\" % (pwd.getpwuid(os.getuid()).pw_name,platform.node())\n\n\t\tif not force:\n\t\t\tfor field in ('allowedConnections','blockedConnections','disableConsentConnections','arpAttributes','manipulationCode'):\n\t\t\t\tif not field in newentity:\n\t\t\t\t\traise ServiceRegistryError(-1,\"%s MUST be specified, otherwise the API will be silently truncate it\" % field)\n\n\t\tresult = self._http_req('connections/%u' % eid, method='PUT', payload=newentity)\n\t\tstatus = result['status']\n\t\tif not status==201:\n\t\t\traise ServiceRegistryError(status,\"Couldn't write entity %u: %u\" % (eid,status))\n\n\t\tself.debug(0x01,result)\n\t\treturn result['decoded']"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates an entity record with the supplied dict", "response": "def update(self, eid, entity, note=None):\n\t\t\"\"\"\n\t\tupdate(int, dict, string):\n\t\t\n\t\tMerges the supplied dict into the entity record with the supplied eid.\n\t\tPlaces the supplied note as update message.\n\t\t\"\"\"\n\t\t# fetch the current entity\n\t\tnewentity = self.get(eid)\n\t\tfor field in ('createdAtDate', 'id', 'isActive', 'parentRevision', 'revisionNr', 'updatedAtDate', 'updatedByUserName','updatedFromIp'):\n\t\t\tif field in newentity: del newentity[field]\n\n\t\t# replace fields as specified in entity\n\t\tfor field in entity:\n\t\t\tif field=='metadata':\n\t\t\t\tfor mfield in entity['metadata']:\n\t\t\t\t\tnewentity['metadata'][mfield] = entity['metadata'][mfield]\n\t\t\telse:\n\t\t\t\tnewentity[field] = entity[field]\n\n\t\tresult = self.replace(eid,newentity,note=note)\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding the supplied dict as a new entity to the registry.", "response": "def add(self, entity):\n\t\t\"\"\"\n\t\tAdds the supplied dict as a new entity\n\t\t\"\"\"\n\t\tresult = self._http_req('connections', method='POST', payload=entity)\n\t\tstatus = result['status']\n\t\tif not status==201:\n\t\t\traise ServiceRegistryError(status,\"Couldn't add entity\")\n\n\t\tself.debug(0x01,result)\n\t\treturn result['decoded']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a matrix of all entities showing which ones are connected together.", "response": "def connectiontable(self, state='prodaccepted'):\n\t\t\"\"\"\n\t\tReturns a matrix of all entities showing which ones are connected together.\n\t\t\"\"\"\n\t\tentities = self.list_full(state)\n\n\t\t# sort entities\n\t\tidps = OrderedDict()\n\t\tsps  = OrderedDict()\n\t\tfor eid, entity in entities.items():\n\t\t\tif entity['isActive'] and entity['state']==state:\n\t\t\t\tif entity['type']=='saml20-idp':\n\t\t\t\t\tidps[eid] = entity\n\t\t\t\telif entity['type']=='saml20-sp':\n\t\t\t\t\tsps[eid] = entity\n\t\t\t\telse:\n\t\t\t\t\traise(ServiceRegistryError(0,\"unknown type `%s' for eid=%s\" % (entity['type'],entity['id'])))\n\n\t\t# use numpy here for the connection matrix to simplify extraction of rows and columns lateron\n\t\tmax_eid = max(entities.keys())\n\t\t#print(max_eid)\n\t\tconnections = dok_matrix((max_eid+1,max_eid+1), dtype=np.bool_)\n\n\t\tfor idp_eid, idp_entity in idps.items():\n\t\t\t#pprint(idp_entity)\n\t\t\tsps_allowed = set([e['id'] for e in idp_entity['allowedConnections']])\n\t\t\tfor sp_eid, sp_entity in sps.items():\n\t\t\t\tidps_allowed = set([ e['id'] for e in sp_entity['allowedConnections'] ])\n\n\t\t\t\tacl =     ( idp_entity['allowAllEntities'] or (sp_eid  in sps_allowed ) ) \\\n\t\t\t\t      and ( sp_entity[ 'allowAllEntities'] or (idp_eid in idps_allowed) )\n\t\t\t\tconnections[idp_eid,sp_eid] = acl\n\n\t\tself._connections[state] = dict()\n\t\tself._connections[state]['idp'] = idps\n\t\tself._connections[state]['sp' ] = sps\n\t\tself._connections[state]['acl'] = connections\n\n\t\treturn connections"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset a value in this config object without marking any source with the given key as dirty.", "response": "def set(config, key, value, sourceid=\"defaults\"):\n        \"\"\"Sets a value in this config object *without* marking any source\n        dirty, and with exact control of exactly where to set the\n        value. This is mostly useful for low-level trickery with\n        config objects.\n\n        :param config: The configuration object to set values on\n        :param key: The parameter name\n        :param value: The new value\n        :param sourceid: The identifier for the underlying source that the\n                         value should be set on.\n        \"\"\"\n        for source in config._sources:\n            if source.identifier == sourceid:\n                source.set(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a value from the config object or returns a default value if the key does not exist", "response": "def get(config, key, default=None):\n        \"\"\"Gets a value from the config object, or return a default value if\n        the parameter does not exist, like :py:meth:`dict.get` does.\n        \"\"\"\n\n        if hasattr(config, key):\n            return getattr(config, key)\n        else:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dump(config):\n        def _dump(element):\n            if not isinstance(element, config.__class__):\n                return element\n\n            section = dict()\n            for key, subsection in element._subsections.items():\n                section[key] = _dump(subsection)\n            for key in element:\n                section[key] = getattr(element, key)\n            return section\n\n        return _dump(config)", "response": "Dumps the entire content of the config object to a string or file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions to make a heat map based on the values in a grid.", "response": "def heat_map(grid, name, **kwargs):\n    \"\"\"\n    Generic function for making a heat map based on the values in a grid.\n\n    Arguments: grid - the grid of numbers or binary strings to be visualized.\n               name - string indicating what the file storing the image\n                      should be called.\n\n    kwargs:\n               palette - a seaborn palette (list of RGB values) indicating\n                         how to color values. Will be converted to a continuous\n                         colormap if necessary\n               denom   - the maximum value of numbers in the grid (only used\n                         if the grid actually contains numbers). This is used\n                         to normalize values and use the full dynamic range of\n                         the color pallete.\n    \"\"\"\n    denom, palette = get_kwargs(grid, kwargs)\n    if \"mask_zeros\" in kwargs:\n        mask_zeros = kwargs[\"mask_zeros\"]\n    else:\n        mask_zeros = False\n\n    grid = color_grid(grid, palette, denom, mask_zeros)\n    make_imshow_plot(grid, name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmakes an animation overlaying colored circles representing phenotypes over an imshow() plot indicating the resources present in each cell. By default, color is determined using the palettes in the EnvironmentFile object passed as the first parameter. The easiest way to change color palettes is to assign new palettes to environment.task_palette and environment.resource_palette before calling this function. If either the environment or phenotypes grids contain integers greater than 1, you should pass a `denom` keyword argument indicating how to normalize them. Using differnet denoms for the environment and phenotypes is not currently supported (if you need to, you should probably just divide everything by the appropraite denoms before passing them to this funciton). Inputs: environment - an EnvironmentFile object indicatng the distribution of resources and the appropriate palettes to use. phenotypes - a 2d array of numbers or binary strings representing the placement of phenotypes across the environment kwargs: denom - an integer indicating how to normalize numbers in the environment and phenotype grids if neccesary. Outputs: Returns a matplotlib animation object. Saves animation in the file: [environment_file_identifier]_phenotype_overlay.mp4", "response": "def paired_environment_phenotype_movie(environment, phenotypes, **kwargs):\n    \"\"\"\n    Makes an animation overlaying colored circles representing phenotypes over\n    an imshow() plot indicating the resources present in each cell. By default,\n    color is determined using the palettes in the EnvironmentFile object\n    passed as the first parameter. The easiest way to change color palettes\n    is to assign new palettes to environment.task_palette and\n    environment.resource_palette before calling this function. If either the\n    environment or phenotypes grids contain integers greater than 1, you should\n    pass a `denom` keyword argument indicating how to normalize them. Using\n    differnet denoms for the environment and phenotypes is not currently\n    supported (if you need to, you should probably just divide everything by\n    the appropraite denoms before passing them to this funciton).\n\n    Inputs:\n          environment - an EnvironmentFile object indicatng the distribution\n                         of resources and the appropriate palettes to use.\n          phenotypes  - a 2d array of numbers or binary strings representing\n                        the placement of phenotypes across the environment\n\n    kwargs:\n          denom - an integer indicating how to normalize numbers in the\n                  environment and phenotype grids if neccesary.\n    Outputs:\n         Returns a matplotlib animation object.\n         Saves animation in the file:\n            [environment_file_identifier]_phenotype_overlay.mp4\n    \"\"\"\n    denom, palette = get_kwargs(environment, kwargs)\n\n    # Create figure to do plotting\n    fig = plt.figure(figsize=(20, 20))\n\n    # Create list of circles at every place in environment\n    patches = []\n\n    for i in range(len(phenotypes)):\n        for j in range(len(phenotypes[i])):\n            patches.append(plt.Circle((j, i), radius=.3,\n                                      lw=2, ec=\"black\",\n                                      facecolor=None, zorder=2))\n\n    # This will be called to color niches, which are always in background\n\n    def init():\n        plot_world(environment, palette=environment.resource_palette,\n                   denom=denom)\n        for p in patches:\n            fig.gca().add_patch(p)\n        return patches\n\n    # Change colors of circles as appropriate for new time step\n    def animate(n):\n        phen_grid = slice_3d_grid(phenotypes, n)\n        # Recolor circles\n        plot_phens_blits(phen_grid, patches,\n                         palette=environment.task_palette, denom=denom)\n        return patches\n\n    # Do actual animation\n    anim = matplotlib.animation.FuncAnimation(\n        fig, animate, init_func=init,\n        frames=len(phenotypes[0][0]), blit=True, interval=750)\n    print(environment.name)\n    # print(anim.to_html5_video())\n    anim.save(environment.name + \"_phenotype_overlay.mov\",\n              writer=matplotlib.animation.ImageMagickWriter())\n    return anim"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a movie showing the color of the phenotypes over the environment.", "response": "def make_movie(phenotypes, **kwargs):\n    \"\"\"\n    Makes an animation overlaying colored circles representing phenotypes over\n    an imshow() plot indicating the resources present in each cell. By default,\n    color is determined using the palettes in the EnvironmentFile object\n    passed as the first parameter. The easiest way to change color palettes\n    is to assign new palettes to environment.task_palette and\n    environment.resource_palette before calling this function. If either the\n    environment or phenotypes grids contain integers greater than 1, you should\n    pass a `denom` keyword argument indicating how to normalize them. Using\n    differnet denoms for the environment and phenotypes is not currently\n    supported (if you need to, you should probably just divide everything by\n    the appropraite denoms before passing them to this funciton).\n\n    Inputs:\n          phenotypes  - a 2d array of numbers or binary strings representing\n                        the placement of phenotypes across the environment\n\n    kwargs:\n          denom - an integer indicating how to normalize numbers in the\n                  environment and phenotype grids if neccesary.\n    Outputs:\n         Returns a matplotlib animation object.\n         Saves animation in the file:\n            [environment_file_identifier]_phenotype_overlay.mp4\n    \"\"\"\n    denom, palette = get_kwargs(phenotypes, kwargs)\n\n    # Create figure to do plotting\n    fig = plt.figure(figsize=(20, 20))\n\n    # Change colors of circles as appropriate for new time step\n    def animate(n):\n        # print(\"animating\", n)\n        phen_grid = slice_3d_grid(phenotypes, n)\n        # print(phen_grid)\n        grid = color_grid(phen_grid, palette, denom, False)\n        plt.tick_params(labelbottom=\"off\", labeltop=\"off\", labelleft=\"off\",\n                        labelright=\"off\", bottom=\"off\", top=\"off\", left=\"off\",\n                        right=\"off\")\n        plt.imshow(grid, interpolation=\"nearest\", aspect=1, zorder=1)\n        plt.tight_layout()\n\n    # Do actual animation\n    anim = matplotlib.animation.FuncAnimation(\n        fig, animate,\n        frames=len(phenotypes[0][0]), interval=750)\n\n    anim.save(\"movie.mov\")\n    return anim"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plot_phens(phen_grid, **kwargs):\n    denom, palette = get_kwargs(phen_grid, kwargs, True)\n\n    grid = color_grid(phen_grid, palette, denom)\n\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] != -1 and tuple(grid[i][j]) != -1:\n                plt.gca().add_patch(plt.Circle((j, i),\n                                    radius=.3, lw=1, ec=\"black\",\n                                    facecolor=grid[i][j], zorder=2))", "response": "Plots the circles colored according to the values in phen_grid."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots the concentric circles of the phenotypes represented as concentric circles.", "response": "def plot_phens_circles(phen_grid, **kwargs):\n    \"\"\"\n    Plots phenotypes represented as concentric circles. Each circle represents\n    one task that the phenotype can perform, with larger circles representing\n    more complex tasks.\n\n    Arguments: phen_grid - a 2D array of strings representing binary numbers\n\n    kwargs:\n               palette - a seaborn palette (list of RGB values) indicating\n                         how to color values. Will be converted to a continuous\n                         colormap if necessary\n               denom   - the maximum value of numbers in the grid (only used\n                         if the grid actually contains numbers). This is used\n                         to normalize values and use the full dynamic range of\n                         the color pallete.\n\n    TODO: come up with way to represent organisms that don't do any tasks.\n\n    \"\"\"\n    denom, palette = get_kwargs(phen_grid, kwargs, True)\n\n    n_tasks = len(palette)\n    grid = phen_grid\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] != -1 and int(grid[i][j], 2) != -1 and \\\n                                    int(grid[i][j], 2) != 0:\n                first = True\n                b_ind = grid[i][j].find(\"b\")\n                phen = grid[i][j][b_ind+1:]\n                for k in range(len(phen)):\n                    if int(phen[k]) == 1:\n                        plt.gca().add_patch(\n                            plt.Circle(\n                                (j, i), radius=(n_tasks - k)*.05,\n                                lw=.1 if first else 0, ec=\"black\",\n                                facecolor=palette[k], zorder=2+k))\n                        first = False\n\n            elif int(grid[i][j], 2) == 0:\n                plt.gca().add_patch(\n                    plt.Circle(\n                        (j, i), radius=(n_tasks)*.05,\n                        lw=.1, ec=\"black\",\n                        facecolor=\"grey\", zorder=2))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot_phens_blits(phen_grid, patches, **kwargs):\n\n    denom, palette = get_kwargs(phen_grid, kwargs)\n    grid = color_grid(phen_grid, palette, denom)\n\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            curr_patch = patches[i * len(grid[i]) + j]\n            if grid[i][j] == -1:\n                curr_patch.set_visible(False)\n            else:\n                curr_patch.set_facecolor(grid[i][j])\n                curr_patch.set_visible(True)\n\n    return patches", "response": "A version of plot_phens designed to be used in animations. Takes a 2D array of phenotypes and a list of matplotlib patches that are added to the current axes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the world in a heat - map.", "response": "def plot_world(world, **kwargs):\n    \"\"\"\n    Addes a heat-map representing the data in world (an EnvironmentFile object)\n    to the current plot.\n\n    kwargs:\n               palette - a seaborn palette (list of RGB values) indicating\n                         how to color values. Will be converted to a continuous\n                         colormap if necessary\n               denom   - the maximum value of numbers in the grid (only used\n                         if the grid actually contains numbers). This is used\n                         to normalize values and use the full dynamic range of\n                         the color pallete.\n    \"\"\"\n    denom, palette = get_kwargs(world, kwargs, False)\n    world = color_grid(world, palette, denom, True)\n    plt.tick_params(labelbottom=\"off\", labeltop=\"off\", labelleft=\"off\",\n                    labelright=\"off\", bottom=\"off\", top=\"off\",\n                    left=\"off\", right=\"off\")\n    # plt.tight_layout()\n    plt.imshow(world, interpolation=\"none\", zorder=1)\n    axes = plt.gca()\n    axes.autoscale(False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplot the given environment (EnvironmentFile object) and phenotypes (2d array of numbers or binary strings) onto the same image and saves the image based on the name of the environment file. The environment file will be represented by coloring square cells, while the phenotypes are circles overlaid on top. By default, color is determined using the palettes in the EnvironmentFile object passed as the first parameter. The easiest way to change color palettes is to assign new palettes to environment.task_palette and environment.resource_palette before calling this function. If either the environment or phenotypes grids contain integers greater than 1, you should pass a `denom` keyword argument indicating how to normalize them. Using differnet denoms for the environment and phenotypes is not currently supported (if you need to, you should probably just divide everything by the appropraite denoms before passing them to this funciton). Inputs: environment - an EnvironmentFile object indicatng the distribution of resources and the appropriate palettes to use. phenotypes - a 2d array of numbers or binary strings representing the placement of phenotypes across the environment kwargs: denom - an integer indicating how to normalize numbers in the environment and phenotype grids if neccesary.", "response": "def paired_environment_phenotype_grid(environment, phenotypes, **kwargs):\n    \"\"\"\n    Plots the given environment (EnvironmentFile object) and phenotypes\n    (2d array of numbers or binary strings) onto the same image and saves\n    the image based on the name of the environment file. The environment file\n    will be represented by coloring square cells, while the phenotypes are\n    circles overlaid on top.\n\n    By default, color is determined using the palettes in the EnvironmentFile\n    object passed as the first parameter. The easiest way to change color\n    palettes is to assign new palettes to environment.task_palette and\n    environment.resource_palette before calling this function. If either the\n    environment or phenotypes grids contain integers greater than 1, you should\n    pass a `denom` keyword argument indicating how to normalize them. Using\n    differnet denoms for the environment and phenotypes is not currently\n    supported (if you need to, you should probably just divide everything by\n    the appropraite denoms before passing them to this funciton).\n\n    Inputs:\n          environment - an EnvironmentFile object indicatng the distribution\n                         of resources and the appropriate palettes to use.\n          phenotypes  - a 2d array of numbers or binary strings representing\n                        the placement of phenotypes across the environment\n\n    kwargs:\n          denom - an integer indicating how to normalize numbers in the\n                  environment and phenotype grids if neccesary.\n\n    \"\"\"\n\n    denom, palette = get_kwargs(environment, kwargs)\n    print(\"plot world\")\n    plot_world(environment, palette=environment.resource_palette, denom=denom)\n    print(\"plot phens\")\n    plot_phens(phenotypes, palette=environment.task_palette, denom=denom)\n    print(\"save\")\n    plt.savefig(\"phenotype_niches_\" + environment.name + \".png\", dpi=1000)\n    print(\"done\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef paired_environment_phenotype_grid_circles(environment,\n                                              phenotypes, **kwargs):\n    \"\"\"\n    Plots the given environment (EnvironmentFile object) and phenotypes\n    (2d array of binary strings) onto the same image and saves\n    the image based on the name of the environment file. The environment file\n    will be represented by coloring square cells, while the phenotypes are\n    represented as concentric circles indicating the set of tasks the organism\n    at that location can perform.\n\n    By default, color is determined using the palettes in the EnvironmentFile\n    object passed as the first parameter. The easiest way to change color\n    palettes is to assign new palettes to environment.task_palette and\n    environment.resource_palette before calling this function. If either the\n    environment or phenotypes grids contain integers greater than 1, you should\n    pass a `denom` keyword argument indicating how to normalize them. Using\n    differnet denoms for the environment and phenotypes is not currently\n    supported (if you need to, you should probably just divide everything by\n    the appropraite denoms before passing them to this funciton).\n\n    Inputs:\n          environment - an EnvironmentFile object indicatng the distribution\n                         of resources and the appropriate palettes to use.\n          phenotypes  - a 2d array of binary strings representing\n                        the placement of phenotypes across the environment\n\n    kwargs:\n          denom - an integer indicating how to normalize numbers in the\n                  environment and phenotype grids if neccesary.\n\n    \"\"\"\n    denom, palette = get_kwargs(environment, kwargs)\n\n    plot_world(environment, palette=environment.resource_palette, denom=denom)\n    plot_phens_circles(phenotypes, palette=environment.task_palette)\n\n    plt.savefig(\"phenotype_niches_circles\"+environment.name, dpi=1000)\n\n    return plt.gcf()", "response": "Plots the environment file and phenotypes on the same image."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef color_grid(data, palette, denom=9.0, mask_zeros=True):\n    grid = []\n\n    try:\n        # If this isn't numeric, don't bother with this block\n        float(data[0][0])\n\n        # This is continuous data - we need a colormap rather than palette\n        palette = matplotlib.colors.LinearSegmentedColormap.from_list(\n                \"color_grid\", palette)\n        palette.set_bad(alpha=0)\n    except:\n        pass\n\n    for row in range(len(data)):\n        grid.append([])\n        for col in range(len(data[row])):\n\n            try:\n                rgb = color_array_by_value(data[row][col], palette, denom,\n                                           mask_zeros)\n            except:\n                rgb = color_array_by_hue_mix(data[row][col], palette)\n\n            grid[row].append(rgb)\n\n    return grid", "response": "Convert the given data to a 2d array of RGB or RGBA values which can then be visualized as a heat map."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef color_array_by_value(value, palette, denom, mask_zeros):\n    if value == -1:  # sentinel value\n        return -1\n\n    if value == 0 and mask_zeros:  # This value is masked\n        if type(palette) is list:\n            return (1, 1, 1)\n        return (1, 1, 1, 1)\n\n    if type(palette) is list:  # This is a palette\n        return palette[value]\n\n    # This is continuous data so the palette is actually a colormap\n    return palette(float(value)/float(denom))", "response": "Figure out the appropriate RGB or RGBA color for a given numerical\n    value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfiguring out the appropriate color for a binary string value by averaging the colors corresponding the indices of each one that it contains. Makes for visualizations that intuitively show patch overlap.", "response": "def color_array_by_hue_mix(value, palette):\n    \"\"\"\n    Figure out the appropriate color for a binary string value by averaging\n    the colors corresponding the indices of each one that it contains. Makes\n    for visualizations that intuitively show patch overlap.\n    \"\"\"\n    if int(value, 2) > 0:\n\n        # Convert bits to list and reverse order to avoid issues with\n        # differing lengths\n        int_list = [int(i) for i in list(value[2:])]\n        int_list.reverse()\n\n        # since this is a 1D array, we need the zeroth elements\n        # of np.nonzero.\n        locs = np.nonzero(int_list)[0]\n        # print(locs)\n        # print(palette)\n        rgb_vals = [palette[i] for i in locs]\n\n        rgb = [0]*len(rgb_vals[0])  # We don't know if it's rgb or rgba\n        for val in rgb_vals:\n            for index in range(len(val)):\n                rgb[index] += val[index]\n\n        for i in range(len(rgb)):\n            rgb[i] /= len(locs)\n\n        return tuple(rgb)\n\n    if int(value, 2) == 0:\n        return (1, 1, 1) if len(palette[0]) == 3 else (1, 1, 1, 1)\n\n    return -1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a grid of the necessary colors for the task percentages of the task grids.", "response": "def color_percentages(file_list, n_tasks=9, file_name=\"color_percent.png\",\n                      intensification_factor=1.2):\n    \"\"\"\n    Creates an image in which each cell in the avida grid is represented as\n    a square of 9 sub-cells. Each of these 9 sub-cells represents a different\n    task, and is colored such that cooler colors represent more complex tasks.\n    The saturation of each sub-cell indicates the percentage of grids in the\n    given data-set in which the organism in that cell could perform the\n    corresponding task.\n\n    Inputs: file_list - list of names of of avida task grid files to be used\n            in making figure.\n\n            intensification_factor (default 1.2): A number to multiply\n            the percentage of organisms doing a task by in order to increase\n            visibility. This can be useful in cases where a lot of the\n            percentages are too low to be easily visualized.\n\n    Returns: Grid indicating appropriate color values for images.\n    \"\"\"\n    # Load data\n    data = task_percentages(load_grid_data(file_list))\n\n    # Initialize grid\n    grid = [[]] * len(data)*3\n    for i in range(len(grid)):\n        grid[i] = [[]]*len(data[0])*3\n\n    # Color grid\n    for i in range(len(data)):\n        for j in range(len(data[i])):\n            for k in range(3):  # create grid of sub-cells\n                for l in range(3):\n                    if len(data[i][j]) > k*3+l:\n                        # build a color in matplotlib's preferred hsv format\n                        arr = np.zeros((1, 1, 3))\n                        arr[0, 0, 1] = float(data[i][j][k*3 + l]) \\\n                            * intensification_factor  # saturate based on data\n                        arr[0, 0, 0] = (k*3 + l)/9.0  # hue based on task\n                        arr[0, 0, 2] = 1  # value is always 1\n                        rgb = matplotlib.colors.hsv_to_rgb(arr)  # convert rgb\n\n                        grid[i*3+k][j*3+l] = list(rgb[0][0])\n                    else:\n                        grid[i*3+k][j*3+l] = (1, 1, 1, 1)\n\n    return make_imshow_plot(grid, \"colorpercentages\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncolor the task percentages for the 2 - stage experimental task.", "response": "def color_percentages2(file_list):\n    \"\"\"\n    Super experimental\n    \"\"\"\n    data = task_percentages(load_grid_data(file_list))\n\n    grid = [[]] * len(data)\n    for i in range(len(grid)):\n        grid[i] = [[]]*len(data[0])\n\n    for i in range(len(data)):\n        for j in range(len(data[0])):\n            r = sum(data[i][j][:3])/3.0\n            g = sum(data[i][j][3:6])/3.0\n            b = sum(data[i][j][6:])/3.0\n            grid[i][j] = (r, g, b)\n\n    make_imshow_plot(grid, \"colorpercentages2\")\n    return grid"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_imshow_plot(grid, name):\n    plt.tick_params(labelbottom=\"off\", labeltop=\"off\", labelleft=\"off\",\n                    labelright=\"off\", bottom=\"off\", top=\"off\", left=\"off\",\n                    right=\"off\")\n    plt.imshow(grid, interpolation=\"nearest\", aspect=1, zorder=1)\n    plt.tight_layout()\n    plt.savefig(name, dpi=1000, bbox_inches=\"tight\")", "response": "Generates a figure by coloring all grid cells appropriately and saves it into a file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy_file(old, new):\n    oldp = old.get_fullpath()\n    newp = new.get_fullpath()\n    log.info(\"Copying %s to %s\", oldp, newp)\n    new.create_directory()\n    shutil.copy(oldp, newp)", "response": "Copies the old file to the location of the new file\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting the given file", "response": "def delete_file(f):\n    \"\"\"Delete the given file\n\n    :param f: the file to delete\n    :type f: :class:`JB_File`\n    :returns: None\n    :rtype: None\n    :raises: :class:`OSError`\n    \"\"\"\n    fp = f.get_fullpath()\n    log.info(\"Deleting file %s\", fp)\n    os.remove(fp)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_next(cls, task, releasetype, typ, descriptor=None):\n        qs = dj.taskfiles.filter(task=task, releasetype=releasetype, descriptor=descriptor, typ=typ)\n        if qs.exists():\n            ver = qs.aggregate(Max('version'))['version__max']+1\n        else:\n            ver = 1\n        return TaskFileInfo(task=task, version=ver, releasetype=releasetype, typ=typ, descriptor=descriptor)", "response": "Returns a TaskFileInfo that with the next available version and the provided info\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new TaskFileInfo object and return it for the given taskfile", "response": "def create_from_taskfile(self, taskfile):\n        \"\"\"Create a new TaskFileInfo and return it for the given taskfile\n\n        :param taskfile: the taskfile to represent\n        :type taskfile: :class:`jukeboxcore.djadapter.models.TaskFile`\n        :returns: a taskfileinfo\n        :rtype: :class:`TaskFileInfo`\n        :raises: None\n        \"\"\"\n        return TaskFileInfo(task=taskfile.task, version=taskfile.version, releasetype=taskfile.releasetype,\n                            descriptor=taskfile.descriptor, typ=taskfile.typ)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a db entry for this task file info and link it with a optional comment", "response": "def create_db_entry(self, comment=''):\n        \"\"\"Create a db entry for this task file info\n        and link it with a optional comment\n\n        :param comment: a comment for the task file entry\n        :type comment: str\n        :returns: The created TaskFile django instance and the comment. If the comment was empty, None is returned instead\n        :rtype: tuple of :class:`dj.models.TaskFile` and :class:`dj.models.Note`\n        :raises: ValidationError, If the comment could not be created, the TaskFile is deleted and the Exception is propagated.\n        \"\"\"\n        jbfile = JB_File(self)\n        p = jbfile.get_fullpath()\n        user = dj.get_current_user()\n        tf = dj.models.TaskFile(path=p, task=self.task, version=self.version,\n                                       releasetype=self.releasetype, descriptor=self.descriptor,\n                                       typ=self.typ, user=user)\n        tf.full_clean()\n        tf.save()\n        note = None\n        if comment:\n            try:\n                note = dj.models.Note(user=user, parent=tf, content=comment)\n                note.full_clean()\n                note.save()\n            except Exception, e:\n                tf.delete()\n                raise e\n        return tf, note"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the dirattr of obj formatted with the dirfomat specified in the constructor.", "response": "def get_dir(self, obj):\n        \"\"\"Return the dirattr of obj formatted with the dirfomat specified in the constructor.\n        If the attr is None then ``None`` is returned not the string ``\\'None\\'``.\n\n        :param obj: the fileinfo with information.\n        :type obj: :class:`FileInfo`\n        :returns: the directory or None\n        :rtype: str|None\n        :raises: None\n        \"\"\"\n        if self._dirattr is None:\n            return\n        a = attrgetter(self._dirattr)(obj)\n        if a is None:\n            return\n        s = self._dirformat % a\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the chunk attribute of obj formatted with the chunkfomat specified in the constructor .", "response": "def get_chunk(self, obj):\n        \"\"\"Return the chunkattr of obj formatted with the chunkfomat specified in the constructor\n        If the attr is None then ``None`` is returned not the string ``\\'None\\'``.\n\n        :param obj: the fileinfo with information.\n        :type obj: :class:`FileInfo`\n        :returns: the chunk or None\n        :rtype: str|None\n        :raises: None\n        \"\"\"\n        if self._chunkattr is None:\n            return\n        a = attrgetter(self._chunkattr)(obj)\n        if a is None:\n            return\n        s = self._chunkformat % a\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_dir(self, taskinfo):\n        if taskinfo.task.department.assetflag:\n            atname = taskinfo.task.element.atype.name\n            d = os.path.join('assets', atname)\n            return d\n        else:\n            seqname = taskinfo.task.element.sequence.name\n            d = os.path.join('shots', seqname)\n            return d", "response": "Return the path to the asset or shot directory depending on the assetflag of the task of taskinfo."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the file extension of the file with information.", "response": "def get_ext(self, obj=None):\n        \"\"\"Return the file extension\n\n        :param obj: the fileinfo with information. If None, this will use the stored object of JB_File\n        :type obj: :class:`FileInfo`\n        :returns: the file extension\n        :rtype: str\n        :raises: None\n        \"\"\"\n        if obj is None:\n            obj = self._obj\n        return self._extel.get_ext(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_path(self, obj=None):\n        if obj is None:\n            obj = self._obj\n        chunks = []\n        for e in self._elements:\n            d = e.get_dir(obj)\n            if d is not None:\n                chunks.append(d)\n        path = os.path.join(*chunks)\n        return os.path.normpath(path)", "response": "Return the path to the file containing the file s metadata."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_name(self, obj=None, withext=True):\n        if obj is None:\n            obj = self._obj\n        chunks = []\n        for e in self._elements:\n            c = e.get_chunk(obj)\n            if c is not None:\n                chunks.append(c)\n        name = '_'.join(chunks)\n        if withext:\n            name = os.extsep.join([name, self.get_ext(obj)])\n        return name", "response": "Return the name of the file with information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_fullpath(self, withext=True):\n        p = self.get_path(self._obj)\n        n = self.get_name(self._obj, withext)\n        fp = os.path.join(p,n)\n        return os.path.normpath(fp)", "response": "Return the filepath with the filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_directory(self, path=None):\n        if path is None:\n            path = self.get_path()\n        if not os.path.exists(path):\n            os.makedirs(path)", "response": "Create the directory for the given path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntranslate the coordinates *return the coordinates", "response": "def get(self):\n        \"\"\"\n        *translate the coordinates*\n\n        **Return:**\n            - ``ra`` -- the right-ascension of the translated coordinate\n            - ``dec`` -- the declination of the translated coordinate\n        \"\"\"\n        self.log.info('starting the ``get`` method')\n\n        # PRECISION TEST\n        decprecision = len(repr(self.dec).split(\".\")[-1])\n        raprecision = len(repr(self.ra).split(\".\")[-1])\n\n        dec2 = self.dec + self.north\n\n        ra2 = self.ra + \\\n            ((self.east) /\n             (math.cos((self.dec + dec2) * self.DEG_TO_RAD_FACTOR / 2.)))\n\n        # FIX VALUES THAT CROSS RA/DEC LIMITS\n        while ra2 > 360. or ra2 < 0.:\n            while ra2 > 360.:\n                ra2 = ra2 - 360.\n            while ra2 < 0.:\n                ra2 = ra2 + 360.\n        while dec2 > 90. or dec2 < -90.:\n            while dec2 > 90.:\n                dec2 = 180. - dec2\n            while dec2 < -90.:\n                dec2 = -180. - dec2\n\n        ra2 = \"%0.*f\" % (raprecision, ra2)\n        dec2 = \"%0.*f\" % (decprecision, dec2)\n\n        self.log.info('completed the ``get`` method')\n        return ra2, dec2"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dispatch_subcommand(self, parser):\n        '''\n        Note that the way we're doing this is elegant, but dangerous.\n        It doesn't require, but does encourage, us to define no Application#\n        methods beyond those corresponding to the supported subcommands\n        '''\n        # read in the subcommand\n        args = parser.parse_args(sys.argv[1:2])\n\n        # check that the subcommand is good\n        if not hasattr(self, args.subcommand):\n            print('Unrecognized command.')\n            parser.print_help()\n            exit(1)\n\n        self.configs = ConfigurationLoader(DEFAULT_USER_CONFIG_PATH).load()\n\n        # use dispatch pattern to invoke method with same name\n        getattr(self, args.subcommand)()", "response": "This method is called by the application to dispatch the specified subcommand."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef corpus(self):\n        '''Command to add a corpus to the dsrt library'''\n\n        # Initialize the addcorpus subcommand's argparser\n        description = '''The corpus subcommand has a number of subcommands of its own, including:\n            list\\t-\\tlists all available corpora in dsrt's library\n            add\\t-\\tadds a corpus to dsrt's library'''\n\n        parser = argparse.ArgumentParser(description=description)\n        self.init_corpus_args(parser)\n\n        # parse the args we got\n        args = parser.parse_args(sys.argv[2:3])\n\n        corpus_command = 'corpus_' + args.corpus_command\n\n        if not hasattr(self, corpus_command):\n            print('Unrecognized corpus command.')\n            parser.print_help()\n            exit(1)\n\n        getattr(self, corpus_command)()", "response": "The corpus add command to add a corpus to the dsrt s library"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dataset(self):\n        '''Command for manipulating or viewing datasets; has a number of subcommands'''\n\n        # Initialize the addcorpus subcommand's argparser\n        description = '''The dataset subcommand has a number of subcommands of its own, including:\n            list\\t-\\tlists all available datasets in dsrt's library\n            prepare\\t-\\tprocesses a corpus into a dataset and adds the processed dataset to dsrt's library'''\n\n        parser = argparse.ArgumentParser(description=description)\n        self.init_dataset_args(parser)\n\n        # parse the args we got\n        args = parser.parse_args(sys.argv[2:3])\n\n        corpus_command = 'dataset_' + args.dataset_command\n\n        if not hasattr(self, corpus_command):\n            print('Unrecognized dataset command.')\n            parser.print_help()\n            exit(1)\n\n        getattr(self, corpus_command)()", "response": "Command for manipulating or viewing datasets; has a number of subcommands"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dataset_list(self):\n        '''Subcommand of dataset for listing available datasets'''\n\n        # Initialize the prepare subcommand's argparser\n        parser = argparse.ArgumentParser(description='Preprocess a raw dialogue corpus into a dsrt dataset')\n        self.init_dataset_list_args(parser)\n\n        # Parse the args we got\n        args = parser.parse_args(sys.argv[3:])\n\n        print(CLI_DIVIDER  + '\\n')\n        dsrt.application.utils.list_dataset()", "response": "Subcommand of dataset for listing available datasets"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_corpus(self, path, config):\n        '''Load a dialogue corpus; eventually, support pickles and potentially other formats'''\n\n        # use the default dataset if no path is provided\n        # TODO -- change this to use a pre-saved dataset\n        if path == '':\n            path = self.default_path_to_corpus\n\n        self.data = Corpus(path=path, config=self.data_config)", "response": "Load a dialogue corpus ; eventually support pickles and potentially other formats"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef init_dataset_prepare_args(self, parser):\n        '''Only invoked conditionally if subcommand is 'prepare' '''\n        parser.add_argument('-f', '--configuration', dest='config', default=DEFAULT_USER_CONFIG_PATH,\n                            help='the path to the configuration file to use -- ./config.yaml by default')\n        parser.add_argument('-c', '--corpus-name', help='the name of the corpus to process')\n        parser.add_argument('-n', '--dataset-name', help='the name to assign the newly processed dataset')", "response": "Only invoked conditionally if subcommand is prepare"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef executeBatch(cursor, sql,\n                 regex=r\"(?mx) ([^';]* (?:'[^']*'[^';]*)*)\",\n                 comment_regex=r\"(?mx) (?:^\\s*$)|(?:--.*$)\"):\n    \"\"\"\n    Takes a SQL file and executes it as many separate statements.\n\n    TODO: replace regexes with something easier to grok and extend.\n\n    \"\"\"\n    # First, strip comments\n    sql = \"\\n\".join([x.strip().replace(\"%\", \"%%\") for x in re.split(comment_regex, sql) if x.strip()])\n\n    # Stored procedures don't work with the above regex because many of them are\n    # made up multiple sql statements each delimited with a single ;\n    # where the regexes assume each statement delimited by a ; is a complete\n    # statement to send to mysql and execute.\n    #\n    # Here i'm simply checking for the delimiter statements (which seem to be\n    # mysql-only) and then using them as markers to start accumulating statements.\n    # So the first delimiter is the signal to start accumulating\n    # and the second delimiter is the signal to combine them into\n    # single sql compound statement and send it to mysql.\n\n    in_proc = False\n    statements = []\n\n    for st in re.split(regex, sql)[1:][::2]:\n        if st.strip().lower().startswith(\"delimiter\"):\n            in_proc = not in_proc\n            if statements and not in_proc:\n                procedure = \";\".join(statements)\n                statements = []\n                cursor.execute(procedure)\n            # skip the delimiter line\n            continue\n\n        if in_proc:\n            statements.append(st)\n        else:\n            cursor.execute(st)", "response": "Executes a batch of SQL statements."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef howToMigrate(self, fromVersion, toVersion=None):\n        # slice notation [start:end:step]\n        # by adding a step of 1 we make a slice from 0:0 be empty\n        # rather than containing the whole list.\n        if toVersion is not None:\n            return self.migrations[fromVersion:toVersion:1]\n        else:\n            return self.migrations[fromVersion::1]", "response": "Given a starting version and an ending version returns filenames of all the migrations in that range exclusive."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a migration name and version lookup the sql file and run it.", "response": "def runSql(self, migrationName, version):\n        \"\"\"\n        Given a migration name and version lookup the sql file and run it.\n        \"\"\"\n        sys.stdout.write(\"Running migration %s to version %s: ...\"%(migrationName, version))\n        sqlPath = os.path.join(self.migrationDirectory, migrationName)\n        sql = open(sqlPath, \"r\").read()\n        try:\n            if self.session.is_active:\n                print \"session is active\"\n                self.session.commit()\n            self.session.begin()\n            executeBatch(self.session, sql)\n            self.session.add(models.Migration(version, migrationName))\n        except:\n            print \"\\n\"\n            self.session.rollback()\n            raise\n        else:\n            self.session.commit()\n        sys.stdout.write(\"\\r\")\n        sys.stdout.flush()\n        sys.stdout.write(\"Running migration %s to version %s: SUCCESS!\\n\"%(migrationName, version))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_event(self, event):\n\n        if not self.header_written:\n            self._out.write(\"<stream>\")\n            self.header_written = True\n\n        event.write_to(self._out)", "response": "Writes an event object to Splunk."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log(self, severity, message):\n\n        self._err.write(\"%s %s\\n\" % (severity, message))\n        self._err.flush()", "response": "Logs messages about the state of this modular input to Splunk."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a client for the given reactor and thread pool.", "response": "def TxKazooClient(reactor, pool, client):\n    \"\"\"Create a client for txkazoo.\n\n    :param twisted.internet.interfaces.IReactorThreads reactor: The reactor\n        used to interact with the thread pool.\n    :param ThreadPool pool: The thread pool to which blocking calls will be\n        deferred.\n    :param kazoo.client.KazooClient client: The blocking Kazoo client, whose\n        blocking methods will be deferred to the thread pool.\n    :return: An object with a similar interface to the Kazoo client, but\n        returning deferreds for all blocking methods. The actual method calls\n        will be executed in the thread pool.\n    \"\"\"\n    make_thimble = partial(Thimble, reactor, pool)\n\n    wrapper = _RunCallbacksInReactorThreadWrapper(reactor, client)\n    client_thimble = make_thimble(wrapper, _blocking_client_methods)\n\n    def _Lock(path, identifier=None):\n        \"\"\"Return a wrapped :class:`kazoo.recipe.lock.Lock` for this client.\"\"\"\n        lock = client.Lock(path, identifier)\n        return Thimble(reactor, pool, lock, _blocking_lock_methods)\n\n    client_thimble.Lock = _Lock\n    client_thimble.SetPartitioner = partial(_SetPartitionerWrapper,\n                                            reactor, pool, client)\n\n    # Expose these so e.g. recipes can access them from the kzclient\n    client.reactor = reactor\n    client.pool = pool\n    client.kazoo_client = client\n\n    return client_thimble"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_listener(self, listener):\n        internal_listener = partial(self._call_in_reactor_thread, listener)\n        self._internal_listeners[listener] = internal_listener\n        return self._client.add_listener(internal_listener)", "response": "Add a listener to the wrapped client."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_listener(self, listener):\n        internal_listener = self._internal_listeners.pop(listener)\n        return self._client.remove_listener(internal_listener)", "response": "Removes the given listener from the wrapped client."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall the given function with args in the reactor thread.", "response": "def _call_in_reactor_thread(self, f, *args, **kwargs):\n        \"\"\"Call the given function with args in the reactor thread.\"\"\"\n        self._reactor.callFromThread(f, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef callback(self, result, message):\n        self.results.put(result)\n        message.ack()", "response": "This method is called automatically when a message is received."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read_next_timestep(self, ts=None):\r\n\r\n    if self.ts.frame >= self.n_frames-1:\r\n        raise IOError(errno.EIO, 'trying to go over trajectory limit')\r\n    if ts is None:\r\n        ts = self.ts\r\n    ts.frame += 1\r\n\r\n    self.zdock_inst._set_pose_num(ts.frame+1)\r\n    ts._pos = self.zdock_inst.static_mobile_copy_uni.trajectory.ts._pos\r\n\r\n    return ts", "response": "read next timestep into timestep"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_pose_num(self, pose_num):\r\n        current_mobile_coord = self.mobile_origin_coord\r\n\r\n        self.static_mobile_copy_uni.trajectory.ts._pos[self.static_num_atoms:,:] = self.zdock_trans_rot(self.grid_size, self.grid_spacing, self.init_trans, self.zdock_output_data[pose_num-1,0:3].copy(), self.zdock_output_data[pose_num-1,3:6].copy(), current_mobile_coord, self.switch)", "response": "Set the pose number in the static copy."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef viterbi_alignment(es, fs, t, a):\r\n    '''\r\n    return\r\n        dictionary\r\n            e in es -> f in fs\r\n    '''\r\n    max_a = collections.defaultdict(float)\r\n    l_e = len(es)\r\n    l_f = len(fs)\r\n    for (j, e) in enumerate(es, 1):\r\n        current_max = (0, -1)\r\n        for (i, f) in enumerate(fs, 1):\r\n            val = t[(e, f)] * a[(i, j, l_e, l_f)]\r\n            # select the first one among the maximum candidates\r\n            if current_max[1] < val:\r\n                current_max = (i, val)\r\n        max_a[j] = current_max[0]\r\n    return max_a", "response": "Returns the maximum alignment of es and fs in a."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a string that represents the matrix of items in the alphabetical order of the items in the list lst.", "response": "def matrix(\r\n        m, n, lst,\r\n        m_text: list=None,\r\n        n_text: list=None):\r\n    \"\"\"\r\n    m: row\r\n    n: column\r\n    lst: items\r\n\r\n    >>> print(_matrix(2, 3, [(1, 1), (2, 3)]))\r\n    |x| | |\r\n    | | |x|\r\n    \"\"\"\r\n\r\n    fmt = \"\"\r\n    if n_text:\r\n        fmt += \"     {}\\n\".format(\" \".join(n_text))\r\n    for i in range(1, m+1):\r\n        if m_text:\r\n            fmt += \"{:<4.4} \".format(m_text[i-1])\r\n        fmt += \"|\"\r\n        for j in range(1, n+1):\r\n            if (i, j) in lst:\r\n                fmt += \"x|\"\r\n            else:\r\n                fmt += \" |\"\r\n        fmt += \"\\n\"\r\n    return fmt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_matrix(es, fs, t, a):\r\n    '''\r\n    print matrix according to viterbi alignment like\r\n          fs\r\n     -------------\r\n    e|x| | | |\r\n    s| |x| | |\r\n     | | | |x|\r\n     | | |x| |\r\n     -------------\r\n    '''\r\n\r\n    max_a = viterbi_alignment(es, fs, t, a).items()\r\n    m = len(es)\r\n    n = len(fs)\r\n    return matrix(m, n, max_a, es, fs)", "response": "print matrix according to viterbi alignment"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwatches a Kazoo node s children.", "response": "def watch_children(kzclient,\n                   path, func, allow_session_lost=True, send_event=False,\n                   ChildrenWatch=ChildrenWatch):\n    \"\"\"\n    Install a Kazoo :obj:`ChildrenWatch` on the given path.\n\n    The given `func` will be called in the reactor thread when any children are\n    created or deleted, or if the node itself is deleted.\n\n    Returns a Deferred which usually has no result, but may fail with an\n    exception if e.g. the path does not exist.\n    \"\"\"\n    def wrapped_func(*args, **kwargs):\n        return blockingCallFromThread(kzclient.reactor, func, *args, **kwargs)\n\n    return deferToThreadPool(\n        kzclient.reactor,\n        kzclient.pool,\n        lambda: ChildrenWatch(\n            kzclient.kazoo_client,\n            path,\n            func=wrapped_func,\n            allow_session_lost=allow_session_lost,\n            send_event=send_event))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes a token that has no content", "response": "def _make_marker_token(self, type_):\n        \"\"\"Make a token that has no content\"\"\"\n        tok = Token(type_,\n                    '',\n                    self.line,\n                    self.line_num,\n                    self.start,\n                    self.start)\n        return tok"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_nullable_map(value):\n        if value == None:\n            return None\n\n        # Parse JSON\n        try:\n            value = json.loads(value)\n            return RecursiveMapConverter.to_nullable_map(value)\n        except:\n            return None", "response": "Converts the given JSON string into a map object or returns null when conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_map_with_default(value, default_value):\n        result = JsonConverter.to_nullable_map(value)\n        return result if result != None else default_value", "response": "Converts the given JSON string into a map object or returns default value when conversion is not possible."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply(self, resource):\n        if isinstance(resource, Image.Image):\n            return getattr(self, '_' + self.method)(resource)\n        else:\n            raise ValueError('Unsupported resource format: %s' % str(type(resource)))", "response": "Applies the method to the given resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nchange image size by height", "response": "def _heighten(self, resource):\n        \"\"\"\n        Change image size by height\n        :param resource: Image\n        :return: Image\n        \"\"\"\n        original_width, original_height = resource.size\n\n        target_height = self.value\n        target_width = int((float(target_height) / original_height) * original_width)\n\n        resource = resource.resize((target_width, target_height), Image.ANTIALIAS)\n\n        return resource"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nincrease image size :param resource: Image :return: Image", "response": "def _increase(self, resource):\n        \"\"\"\n        Increase image size\n        :param resource: Image\n        :return: Image\n        \"\"\"\n        original_width, original_height = resource.size\n\n        target_width = original_width + self.value\n        target_height = original_height + self.value\n\n        resource = resource.resize((target_width, target_height), Image.ANTIALIAS)\n\n        return resource"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndecreasing image size by value.", "response": "def _decrease(self, resource):\n        \"\"\"\n        Decrease image size\n        :param resource:\n        :return:\n        \"\"\"\n        original_width, original_height = resource.size\n\n        if original_width > self.value and original_height > self.value:\n            target_width = original_width - self.value\n            target_height = original_height - self.value\n\n            resource = resource.resize((target_width, target_height), Image.ANTIALIAS)\n\n            return resource\n        else:\n            raise ValueError('Image dimensions less than or equal to filter value.')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _scale(self, resource):\n        original_width, original_height = resource.size\n\n        target_width = int(round(original_width * self.value))\n        target_height = int(round(original_height * self.value))\n\n        resource_format = resource.format\n        resource = resource.resize((target_width, target_height), Image.ANTIALIAS)\n        resource.format = resource_format\n\n        return resource", "response": "Scale image\n        :param resource: Image\n        :return: Image"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the whole project. Returns True if at least one file has been generated False otherwise.", "response": "def generate_project(self):\n        \"\"\"\n        Generate the whole project. Returns True if at least one\n        file has been generated, False otherwise.\"\"\"\n        # checks needed properties\n        if not self.name or not self.destdir or \\\n               not os.path.isdir(self.destdir):\n            raise ValueError(\"Empty or invalid property values: run with 'help' command\")\n\n        _log(\"Generating project '%s'\" % self.name)\n        _log(\"Destination directory is: '%s'\" % self.destdir)\n\n        top = os.path.join(self.destdir, self.name)\n        src = os.path.join(top, self.src_name)\n        resources = os.path.join(top, self.res_name)\n        utils = os.path.join(src, \"utils\")\n\n        if self.complex:\n            models = os.path.join(src, \"models\")\n            ctrls = os.path.join(src, \"ctrls\")\n            views = os.path.join(src, \"views\")\n        else: models = ctrls = views = src\n\n        res = self.__generate_tree(top, src, resources, models, ctrls, views, utils)\n        res = self.__generate_classes(models, ctrls, views) or res\n        res = self.__mksrc(os.path.join(utils, \"globals.py\"), templates.glob) or res\n\n        if self.complex: self.templ.update({'model_import' : \"from models.application import ApplModel\",\n                                            'ctrl_import' : \"from ctrls.application import ApplCtrl\",\n                                            'view_import' : \"from views.application import ApplView\"})\n        else: self.templ.update({'model_import' : \"from ApplModel import ApplModel\",\n                                 'ctrl_import' : \"from ApplCtrl import ApplCtrl\",\n                                 'view_import' : \"from ApplView import ApplView\"})\n\n        res = self.__mksrc(os.path.join(top, \"%s.py\" % self.name), templates.main) or res\n\n        # builder file\n        if self.builder:\n            res = self.__generate_builder(resources) or res\n\n        if self.dist_gtkmvc3: res = self.__copy_framework(os.path.join(resources, \"external\")) or res\n\n        if not res: _log(\"No actions were taken\")\n        else: _log(\"Done\")\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __generate_tree(self, top, src, resources, models, ctrls, views, utils):\n        res = self.__mkdir(top)\n        for fn in (src, models, ctrls, views, utils): res = self.__mkpkg(fn) or res\n        res = self.__mkdir(resources) or res\n        res = self.__mkdir(os.path.join(resources, \"ui\", \"builder\")) or res\n        res = self.__mkdir(os.path.join(resources, \"ui\", \"styles\")) or res\n        res = self.__mkdir(os.path.join(resources, \"external\")) or res\n        return res", "response": "Creates directories and packages and returns the path to the tree"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main():\n\n    # Quit when interrupted\n    import signal\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    # Arguments:\n    # --separator STRING/REGEX - how to split a row into cells (only relevant for CSV parser)\n    # --flatten - flatten item hashes. {'a':{'b':'c'}} --> {'a_b':'c'}\n    import argparse\n    parser = argparse.ArgumentParser(description='View tabulated data via GUI')\n    parser.add_argument('-p','--parser',type=str, default='autosplit',help='Type of parser to use') #TODO add possible parsers\n    parser.add_argument('--headers',type=str, help='Headers are this comma-delimited names instead of ones supplied in file. Use colons to specify types, like \"colname:int\"')\n    parser.add_argument('--filter',type=str, help='Pre-populate filter box')\n    parser.add_argument('-s', '--separator', help='How to seperate columns. Applies only to some parsers')\n    parser.add_argument('files', nargs='*', help='Files to show. Each file opens a new window')\n    args = parser.parse_args()\n\n    GObject.threads_init()\n\n    default_config = {'format': args.parser}\n    if args.filter:\n        default_config['filter']=args.filter\n    if args.separator:\n        default_config['separator']=args.separator\n    if args.headers:\n        default_config['headers']=map(lambda s: s.strip(),args.headers.split(','))\n    inputs = [ (open(f,'r'),default_config) for f in args.files ]\n    # Add stdin as input, if it's not a tty\n    if not sys.stdin.isatty():\n        inputs.append((sys.stdin, default_config))\n\n    global windows\n    windows = [Window(i[0],i[1]) for i in inputs]\n    for win in windows:\n      win.start_read()\n      win.connect(\"destroy\",window_closed)\n    if windows:\n        Gtk.main()\n    else:\n        print 'No input supplied so no windows are created'", "response": "Entry point for the\n    script."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts from degrees to number.", "response": "def _deg2num(self, lat_deg, lon_deg, zoom, leave_float=False):\n        \"\"\" Taken from http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Python \"\"\"\n        lat_rad = mod_math.radians(lat_deg)\n        n = 2.0 ** zoom\n        xtile = (lon_deg + 180.0) / 360.0 * n\n        ytile = (1.0 - mod_math.log(mod_math.tan(lat_rad) + (1 / mod_math.cos(lat_rad))) / mod_math.pi) / 2.0 * n\n        if not leave_float:\n            xtile = int(xtile)\n            ytile = int(ytile)\n        return TileInfo(xtile, ytile, zoom)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _num2deg(self, tile):\n        n = 2.0 ** tile.zoom\n        lon_deg = tile.x / n * 360.0 - 180.0\n        lat_rad = mod_math.atan(mod_math.sinh(mod_math.pi * (1 - 2 * tile.y / n)))\n        lat_deg = mod_math.degrees(lat_rad)\n        return (lat_deg, lon_deg)", "response": "Convert a number to a latitude and longitude."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the image for a given latitute range and size.", "response": "def get_image(self, latitute_range, longitude_range, width, height, polyline=None, polyline_color=None, \\\n                  polyline_width=None, attribution=None, dots=None):\n        assert len(latitute_range) == 2\n        assert latitute_range[0] < latitute_range[1]\n        assert len(longitude_range) == 2\n        assert longitude_range[0] < longitude_range[1]\n\n        center = ((latitute_range[0] + latitute_range[1]) / 2., (longitude_range[0] + longitude_range[1]) / 2.)\n\n        image_info = self._get_best_zoom_data(center, latitute_range, longitude_range, width, height)\n\n        if not image_info:\n            return None\n\n        stitched = self._stitch_tiles(image_info.tile_1, image_info.tile_2, self.tile_size)\n\n        \"\"\" DEBUG:\n        draw = mod_imagedraw.Draw(stitched) \n        draw.ellipse((image_info.center_x - 2, image_info.center_y - 2, image_info.center_x + 2, image_info.center_y + 2), fill=(0, 0, 0))\n\n        red = (255, 0, 0)\n        draw.ellipse((image_info.widthheight_window_1[0] - 2, image_info.widthheight_window_1[1] - 2, image_info.widthheight_window_1[0] + 2, image_info.widthheight_window_1[1] + 2), fill=red)\n        draw.ellipse((image_info.widthheight_window_2[0] - 2, image_info.widthheight_window_2[1] - 2, image_info.widthheight_window_2[0] + 2, image_info.widthheight_window_2[1] + 2), fill=red)\n        draw.ellipse((image_info.widthheight_window_1[0] - 2, image_info.widthheight_window_2[1] - 2, image_info.widthheight_window_1[0] + 2, image_info.widthheight_window_2[1] + 2), fill=red)\n        draw.ellipse((image_info.widthheight_window_2[0] - 2, image_info.widthheight_window_1[1] - 2, image_info.widthheight_window_2[0] + 2, image_info.widthheight_window_1[1] + 2), fill=red)\n\n        blue = (0, 0, 255)\n        draw.ellipse((image_info.latlon_window_1[0] - 2, image_info.latlon_window_1[1] - 2, image_info.latlon_window_1[0] + 2, image_info.latlon_window_1[1] + 2), fill=blue)\n        draw.ellipse((image_info.latlon_window_2[0] - 2, image_info.latlon_window_2[1] - 2, image_info.latlon_window_2[0] + 2, image_info.latlon_window_2[1] + 2), fill=blue)\n        draw.ellipse((image_info.latlon_window_1[0] - 2, image_info.latlon_window_2[1] - 2, image_info.latlon_window_1[0] + 2, image_info.latlon_window_2[1] + 2), fill=blue)\n        draw.ellipse((image_info.latlon_window_2[0] - 2, image_info.latlon_window_1[1] - 2, image_info.latlon_window_2[0] + 2, image_info.latlon_window_1[1] + 2), fill=blue)\n\n        stitched.show()\n        \"\"\"\n\n        # Draw waypoints/lines:\n        if polyline:\n            self._draw_line(stitched, image_info, polyline, width=polyline_width, \\\n                    color=polyline_color, dots=dots)\n\n        # Crop:\n        cropped = self._crop(stitched, image_info);\n\n        attribution = attribution if attribution != None else '(c) OSM contributors'\n        self._draw_attribution(cropped, attribution, width, height)\n\n        return cropped"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef scp_put(self, src, dst):\n        cmd = [ 'scp',\n                '-B',\n                '-oStrictHostKeyChecking=no',\n                '-oUserKnownHostsFile=/dev/null',\n                '-oLogLevel=ERROR']\n        if self._key is not None:\n            cmd.extend(['-i', self._key])\n        cmd.append(src)\n        remote = ''\n        if self._user is not None:\n            remote += self._user + '@'\n        remote += self._ip + ':' + dst\n        cmd.append(remote)\n        try:\n            # Actually ignore output on success, but capture stderr on failure\n            subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as ex:\n            raise RuntimeError('scp returned exit status %d:\\n%s'\n                    % (ex.returncode, ex.output.strip()))", "response": "Copy src file to dst on local system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_country_by_name(self, country_name: str) -> typing.Optional['Country']:\n        VALID_STR.validate(country_name, 'get_country_by_name', exc=ValueError)\n        if country_name not in self._countries_by_name.keys():\n            for country in self.countries:\n\n                if country.country_name == country_name:\n                    self._countries_by_name[country_name] = country\n                    return country\n            raise ValueError(country_name)\n        else:\n            return self._countries_by_name[country_name]", "response": "Gets a country from its name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_country_by_id(self, country_id: int) -> typing.Optional['Country']:\n        VALID_POSITIVE_INT.validate(country_id, 'get_country_by_id')\n        if country_id not in self._countries_by_id.keys():\n            for country in self.countries:\n\n                if country.country_id == country_id:\n                    self._countries_by_id[country_id] = country\n                    return country\n            raise ValueError(country_id)\n        else:\n            return self._countries_by_id[country_id]", "response": "Gets a country from its name by its id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a group by id", "response": "def get_group_by_id(self, group_id: str) -> typing.Optional['Group']:\n        \"\"\"\n        Gets a group by id\n\n        Args:\n            group_id: group id\n\n        Returns: Group\n        \"\"\"\n        VALID_POSITIVE_INT.validate(group_id, 'get_group_by_id', exc=ValueError)\n        for group in self.groups:\n\n            if group.group_id == group_id:\n                return group\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_clients_groups(self) -> typing.Iterator['Group']:\n        for group in self.groups:\n\n            if group.group_is_client_group:\n                yield group", "response": "Gets all clients groups"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_group_by_name(self, group_name: str) -> typing.Optional['Group']:\n        VALID_STR.validate(group_name, 'get_group_by_name')\n        for group in self.groups:\n\n            if group.group_name == group_name:\n                return group\n        return None", "response": "Gets a group from its name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_unit_by_name(self, unit_name: str) -> typing.Optional['BaseUnit']:\n        VALID_STR.validate(unit_name, 'get_unit_by_name')\n        for unit in self.units:\n\n            if unit.unit_name == unit_name:\n                return unit\n        return None", "response": "Gets a unit from its name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a unit from its ID", "response": "def get_unit_by_id(self, unit_id: str) -> typing.Optional['BaseUnit']:\n        \"\"\"\n        Gets a unit from its ID\n\n        Args:\n            unit_id: unit id\n\n        Returns: Unit\n        \"\"\"\n        VALID_POSITIVE_INT.validate(unit_id, 'get_unit_by_id')\n        for unit in self.units:\n\n            if unit.unit_id == unit_id:\n                return unit\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\niterate over all units in this instance", "response": "def units(self) -> typing.Iterator['BaseUnit']:\n        \"\"\"\n        Iterates over all units\n\n        Returns: generator of Unit\n        \"\"\"\n        for group in self.groups:\n            for unit in group.units:\n\n                yield unit"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef groups(self) -> typing.Iterator['Group']:\n        for country in self.countries:\n            for group in country.groups:\n\n                yield group", "response": "Iterate over all groups in the country."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the next free GroupId that is not already in use.", "response": "def next_group_id(self) -> int:\n        \"\"\"\n        Returns: next free GroupId\n        \"\"\"\n        ids: typing.Set[int] = set()\n        for group in chain(self._blue_coa.groups, self._red_coa.groups):  # type: ignore\n\n            id_ = group.group_id\n            if id_ in ids:\n                raise IndexError(group.group_name)\n            ids.add(id_)\n        return max(ids) + 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the next free Unit ID in the set.", "response": "def next_unit_id(self) -> int:\n        \"\"\"\n        Returns: next free Unit ID\n        \"\"\"\n        ids: typing.Set[int] = set()\n        for unit in chain(self._blue_coa.units, self._red_coa.units):  # type: ignore\n\n            id_ = unit.unit_id\n            if id_ in ids:\n                raise IndexError(unit.unit_name)\n            ids.add(id_)\n        return max(ids) + 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef coalitions(self) -> typing.Iterator['Coalition']:\n        for coalition in [self._blue_coa, self._red_coa]:\n\n            yield coalition", "response": "Returns an iterator over all coalitions in the system."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef countries(self) -> typing.Iterator['Country']:\n        for coalition in self.coalitions:\n            for country in coalition.countries:\n\n                yield country", "response": "Returns an iterator over all countries in the system."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mission_start_date_as_string(self) -> str:\n        return self._start_date_as_string(self.day, self.month, self.year)", "response": "Returns the mission start date as a string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an iterator over all FARPs in the system.", "response": "def farps(self) -> typing.Iterator['Static']:\n        \"\"\"\n        Returns: generator over all FARPs objects\n        \"\"\"\n        for coa in [self._blue_coa, self._red_coa]:\n            if coa is not None:\n                for farp in coa.farps:\n                    yield farp"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bullseye_position(self) -> typing.Tuple[float, float]:\n        return self.bullseye_x, self.bullseye_y", "response": "Returns the bullseye position of the current bullseye."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef countries(self) -> typing.Iterator['Country']:\n        for k in self._section_country:\n            if k not in self._countries.keys():\n                country = Country(self.d, self.l10n, self.coa_color, k)\n                self._countries[k] = country\n                self._countries_by_id[country.country_id] = country\n                self._countries_by_name[country.country_name] = country\n            yield self._countries[k]", "response": "Returns an iterator over all countries in this coalition."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_country_by_name(self, country_name) -> 'Country':\n        VALID_STR.validate(country_name, 'get_country_by_name', exc=ValueError)\n        if country_name not in self._countries_by_name.keys():\n            for country in self.countries:\n\n                if country.country_name == country_name:\n                    return country\n            raise ValueError(country_name)\n        else:\n            return self._countries_by_name[country_name]", "response": "Gets a country in this coalition by its name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_country_by_id(self, country_id) -> 'Country':\n        VALID_POSITIVE_INT.validate(country_id, 'get_country_by_id', exc=ValueError)\n        if country_id not in self._countries_by_id.keys():\n            for country in self.countries:\n\n                if country.country_id == country_id:\n                    return country\n            raise ValueError(country_id)\n        else:\n            return self._countries_by_id[country_id]", "response": "Gets a country in this coalition by its ID."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an iterator over all statics in this coalition.", "response": "def statics(self) -> typing.Iterator['Static']:\n        \"\"\"\n        Returns: generator over all statics in this coalition\n        \"\"\"\n        for country in self.countries:\n\n            for static in country.statics:\n\n                yield static"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef farps(self) -> typing.Iterator['Static']:\n        for static in self.statics:\n\n            if static.static_is_farp:\n                yield static", "response": "Returns an iterator over all FARPs in this coalition."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_groups_from_category(self, category) -> typing.Iterator['Group']:\n        Mission.validator_group_category.validate(category, 'get_groups_from_category')\n        for group in self.groups:\n\n            if group.group_category == category:\n                yield group", "response": "Returns an iterator over all groups in a specific category in this coalition."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an iterator over all units of a specific category in this coalition.", "response": "def get_units_from_category(self, category) -> typing.Iterator['BaseUnit']:\n        \"\"\"\n        Args:\n            category: unit category\n\n        Returns: generator over all units of a specific category in this coalition\n        \"\"\"\n        Mission.validator_group_category.validate(category, 'group category')\n        for unit in self.units:\n\n            if unit.group_category == category:\n                yield unit"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the group with the given ID or None if no such group exists.", "response": "def get_group_by_id(self, group_id) -> typing.Optional['Group']:\n        \"\"\"\n        Args:\n            group_id: group ID\n\n        Returns: Group\n        \"\"\"\n        VALID_POSITIVE_INT.validate(group_id, 'get_group_by_id')\n        for group in self.groups:\n\n            if group.group_id == group_id:\n                return group\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the season code from the given season name.", "response": "def get_season_code_from_name(self, season_name) -> int:\n        \"\"\"\n        Args:\n            season_name: season name\n\n        Returns: season code\n        \"\"\"\n        self.validator_season_name.validate(season_name, 'get_season_code_from_name')\n        return self.seasons_enum[season_name]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an iterator of all groups in this country.", "response": "def groups(self) -> typing.Iterator['Group']:\n        \"\"\"\n        Returns: generator of all groups in this country\n        \"\"\"\n        for group_category in Mission.valid_group_categories:\n            if group_category in self._section_this_country.keys():\n                for group_index in self._section_this_country[group_category]['group']:\n                    if group_index not in self.__groups[group_category]:\n                        self.__groups[group_category][group_index] = Group(self.d, self.l10n, self.coa_color,\n                                                                           self.country_index, group_category,\n                                                                           group_index)\n                    yield self.__groups[group_category][group_index]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef statics(self) -> typing.Iterator['Static']:\n        if 'static' in self._section_this_country.keys():\n            for static_index in self._section_this_country['static']['group']:\n                if static_index not in self.__static:\n                    self.__static[static_index] = Static(self.d, self.l10n, self.coa_color,\n                                                         self.country_index, static_index)\n                yield self.__static[static_index]", "response": "Returns an iterator of all statics in this country."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the group object with the given id or None if no such group exists.", "response": "def get_group_by_id(self, group_id) -> typing.Optional['Group']:\n        \"\"\"\n        Args:\n            group_id: group id\n\n        Returns: Group\n        \"\"\"\n        for group in self.groups:\n\n            if group.group_id == group_id:\n                return group\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef static_position(self) -> typing.Tuple[float, float]:\n        unit = self._section_static['units'][1]\n        return unit['x'], unit['y']", "response": "Returns the x y coordinates of the static section"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef group_route(self) -> 'Group.Route':\n        #  TODO\n        if self.__group_route is None:\n            self.__group_route = Group.Route(self)\n        return self.__group_route", "response": "Returns the route of this group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an iterator over all units of this group", "response": "def units(self) -> typing.Iterator['BaseUnit']:\n        \"\"\"\n        Returns: generator over all units of this group\n        \"\"\"\n        for unit_index in self._section_group['units']:\n            if unit_index not in self.__units.keys():\n                _category = self.units_class_enum[self.group_category]  # type: ignore\n                self.__units[unit_index] = _category(self.d, self.l10n, self.coa_color,\n                                                     self.country_index,\n                                                     self.group_category,\n                                                     self.group_index, unit_index)\n            yield self.__units[unit_index]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the base unit with the given index.", "response": "def get_unit_by_index(self, unit_index) -> typing.Optional['BaseUnit']:\n        \"\"\"\n        Args:\n            unit_index: index of unit\n\n        Returns: a unit of this group\n        \"\"\"\n        if unit_index in self._section_group['units'].keys():\n            if unit_index not in self.__units.keys():\n                _category = self.units_class_enum[self.group_category]  # type: ignore\n                self.__units[unit_index] = _category(self.d, self.l10n, self.coa_color,\n                                                     self.country_index,\n                                                     self.group_category,\n                                                     self.group_index, unit_index)\n            return self.__units[unit_index]\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if this group is a client group.", "response": "def group_is_client_group(self) -> bool:\n        \"\"\"\n        Returns: True if this group is a client group\n        \"\"\"\n        # TODO create test\n        first_unit = self.get_unit_by_index(1)\n        if first_unit:\n            return first_unit.skill == 'Client'\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unit_position(self) -> typing.Tuple[float, float]:\n        return self.unit_pos_x, self.unit_pos_y", "response": "Returns the x and y position of the unit of the current log entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef radio_presets(self) -> typing.Iterator['FlyingUnit.RadioPresets']:\n        raise TypeError('unit #{}: {}'.format(self.unit_id, self.unit_name))", "response": "Returns an iterator over radio presets."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if unit has radio presets.", "response": "def has_radio_presets(self) -> bool:\n        \"\"\"\n        Returns: true if unit has radio presets\n        \"\"\"\n        return all([self.skill == 'Client', self.unit_type in FlyingUnit.RadioPresets.radio_enum.keys()])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef radio_presets(self) -> typing.Iterator['FlyingUnit.RadioPresets']:\n        if self.skill == 'Client' and self.unit_type in FlyingUnit.RadioPresets.radio_enum.keys():\n            for k in self._section_unit['Radio']:\n                yield FlyingUnit.RadioPresets(self, k)\n        else:\n            raise TypeError('unit #{}: {}'.format(self.unit_id, self.unit_name))", "response": "Returns an iterator over the radio presets for this unit."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_radio_by_name(self, radio_name: str) -> 'RadioPresets':\n        if self.has_radio_presets:\n            for k in FlyingUnit.RadioPresets.radio_enum[self.unit_type].keys():\n                if radio_name == FlyingUnit.RadioPresets.radio_enum[self.unit_type][k]['radio_name']:\n                    return FlyingUnit.RadioPresets(self, k)\n            raise TypeError('{} for aircraft: {}'.format(radio_name, self.unit_type))\n        else:\n            raise TypeError('unit #{}: {}'.format(self.unit_id, self.unit_name))", "response": "Returns a radio presets object for the given radio name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_radio_by_number(self, radio_number) -> 'RadioPresets':\n        if self.has_radio_presets:\n            if radio_number in FlyingUnit.RadioPresets.radio_enum[self.unit_type].keys():\n                return FlyingUnit.RadioPresets(self, radio_number)\n            else:\n                raise TypeError(\n                    'radio number {} for aircraft: {}'.format(radio_number, self.unit_type))\n        else:\n            raise TypeError('unit #{}: {}'.format(self.unit_id, self.unit_name))", "response": "Returns a radio presets object for the given radio number."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef compress(data):\n\n    if isinstance(data, bytes):\n        source = data\n    elif isinstance(data, str):\n        source = bytes(data, encoding='utf-8')\n    else:\n        raise RuntimeError(\"Compression is only supported for strings and bytes\")\n\n    return base64.b64encode(gzip.compress(source))", "response": "Compresses a string or bytes using Gzip and returns its Base64 representation"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decompress(data):\n\n    if isinstance(data, bytes):\n        source = data\n    elif isinstance(data, str):\n        source = bytes(data, encoding='utf-8')\n    else:\n        raise RuntimeError(\"Compression is only supported for strings and bytes\")\n\n    return gzip.decompress(base64.b64decode(source))", "response": "Decompress a Base64 bytes or string input and decompresses it using Gzip\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle resource management within an executable file.", "response": "def bundle_dir():\n    \"\"\"Handle resource management within an executable file.\"\"\"\n    if frozen():\n        directory = sys._MEIPASS\n    else:\n        directory = os.path.dirname(os.path.abspath(stack()[1][1]))\n    if os.path.exists(directory):\n        return directory"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resource_path(relative):\n    if hasattr(sys, \"_MEIPASS\"):\n        return os.path.join(sys._MEIPASS, relative)\n    return os.path.join(relative)", "response": "Adjust path for executable use in executable file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_complete(self):\n        return self._group != None and self._type != None \\\n            and self._kind != None and self._name != None and self._version != None", "response": "Checks whether all descriptor fields are set and whether all of them are incomplete."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses colon - separated list of descriptor fields and returns them as a Descriptor.", "response": "def from_string(value):\n        \"\"\"\n        Parses colon-separated list of descriptor fields and returns them as a Descriptor.\n\n        :param value: colon-separated descriptor fields to initialize Descriptor.\n\n        :return: a newly created Descriptor.\n        \"\"\"\n        if value == None or len(value) == 0:\n            return None\n                \n        tokens = value.split(\":\")\n        if len(tokens) != 5:\n            raise ConfigException(\n                None, \"BAD_DESCRIPTOR\", \"Descriptor \" + str(value) + \" is in wrong format\"\n            ).with_details(\"descriptor\", value)\n            \n        return Descriptor(tokens[0].strip(), tokens[1].strip(), tokens[2].strip(), tokens[3].strip(), tokens[4].strip())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_add_url(url):\n    parsed_url = urlparse(url)\n    job_name = None\n    paths = parsed_url.path.strip(\"/\").split(\"/\")\n    for i, path in enumerate(paths):\n        if path == \"job\" and len(paths) > i:\n            job_name = paths[i + 1]\n    if job_name is None:\n        raise ConfigException(\"Unable to parse valid job from {0}\".format(url))\n    return (\n        \"{0}://{1}\".format(parsed_url.scheme, parsed_url.netloc),\n        job_name\n    )", "response": "parse a url into a tuple"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse(self):\n        responses = []\n        for child in self._element:\n            weight = int_attribute(child, 'weight', 1)\n            self._log.debug('Parsing random entry with weight {weight}: {entry}'\n                            .format(weight=weight, entry=child.text))\n\n            # If the random element doesn't contain any tags, just store the text and return\n            if not len(child):\n                responses.append((child.text, weight))\n                continue\n\n            # Otherwise, parse all the available tags\n            responses.append((tuple(self.trigger.agentml.parse_tags(child, self.trigger)), weight))\n        self._responses = tuple(responses)", "response": "Parses the random element and stores the response text and the weight of the tags."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef value(self):\n        choice = weighted_choice(self._responses)\n\n        # If the choice is a tuple, join the elements into a single mapped string\n        if isinstance(choice, tuple):\n            return ''.join(map(str, choice)).strip()\n\n        # Otherwise, return the choice itself as a string\n        return str(choice)", "response": "Fetch a random weighted choice from the response list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post(self, message):\n        return self.connection.post('echo/string', data=dict(message=message))", "response": "Simply test Put a string\n            Simply test Put a string\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef post(self, key='hello', value='world'):\n        return self.connection.post('echo/key', data=dict(key=key,           value=value))", "response": "This method is used to store the value under the key under the server\n            and return the echo dict of the key value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dump(obj, name, path=None, ext=\"dat\", overwrite=True, silent=False):\n    if path and os.path.isfile(path):\n        raise ValueException(\"Specified path is a file.\")\n\n    filename = __get_filename(path, name, ext)\n    \n    if not overwrite and os.path.exists(filename):\n        if not silent:\n            raise ValueException(\"Specified output filename already exists.\")\n        return\n    \n    with open(filename, \"wb\") as f:\n        pickle.dump(obj, f)", "response": "Dumps the object to disk with given name and extension."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(name, path=None, ext=\"dat\", silent=False):\n    filename = __get_filename(path, name, ext)\n\n    if not os.path.exists(filename):\n        if not silent:\n            raise ValueException(\"Specified input filename doesn't exist.\")\n        return None\n\n    with open(filename, \"rb\") as f:\n        return pickle.load(f)", "response": "Loads an object from file with given name and extension."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cli(out_fmt, input, output):\n    _input = StringIO()\n    for l in input:\n        try:\n            _input.write(str(l))\n        except TypeError:\n            _input.write(bytes(l, 'utf-8'))\n    _input = seria.load(_input)\n    _out = (_input.dump(out_fmt))\n    output.write(_out)", "response": "Converts text to a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncopying a file from a stream to a target file.", "response": "def copy_file(stream, target, maxread=-1, buffer_size=2*16):\n    ''' Read from :stream and write to :target until :maxread or EOF. '''\n    size, read = 0, stream.read\n    while 1:\n        to_read = buffer_size if maxread < 0 else min(buffer_size, maxread-size)\n        part = read(to_read)\n        if not part:\n            return size\n        target.write(part)\n        size += len(part)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the form - data from an environ dict and return a 2 - tuple of form - fields and files - fields.", "response": "def parse_form_data(environ, charset='utf8', strict=False, **kw):\n    ''' Parse form data from an environ dict and return a (forms, files) tuple.\n        Both tuple values are dictionaries with the form-field name as a key\n        (unicode) and lists as values (multiple values per key are possible).\n        The forms-dictionary contains form-field values as unicode strings.\n        The files-dictionary contains :class:`MultipartPart` instances, either\n        because the form-field was a file-upload or the value is to big to fit\n        into memory limits.\n\n        :param environ: An WSGI environment dict.\n        :param charset: The charset to use if unsure. (default: utf8)\n        :param strict: If True, raise :exc:`MultipartError` on any parsing\n                       errors. These are silently ignored by default.\n    '''\n\n    forms, files = MultiDict(), MultiDict()\n    try:\n        if environ.get('REQUEST_METHOD', 'GET').upper() not in ('POST', 'PUT'):\n            raise MultipartError(\"Request method other than POST or PUT.\")\n        content_length = int(environ.get('CONTENT_LENGTH', '-1'))\n        content_type = environ.get('CONTENT_TYPE', '')\n        if not content_type:\n            raise MultipartError(\"Missing Content-Type header.\")\n        content_type, options = parse_options_header(content_type)\n        stream = environ.get('wsgi.input') or BytesIO()\n        kw['charset'] = charset = options.get('charset', charset)\n        if content_type == 'multipart/form-data':\n            boundary = options.get('boundary', '')\n            if not boundary:\n                raise MultipartError(\"No boundary for multipart/form-data.\")\n            for part in MultipartParser(stream, boundary, content_length, **kw):\n                if part.filename or not part.is_buffered():\n                    files[part.name] = part\n                else:  # TODO: Big form-fields are in the files dict. really?\n                    forms[part.name] = part.value\n        elif content_type in ('application/x-www-form-urlencoded',\n                              'application/x-url-encoded'):\n            mem_limit = kw.get('mem_limit', 2**20)\n            if content_length > mem_limit:\n                raise MultipartError(\"Request to big. Increase MAXMEM.\")\n            data = stream.read(mem_limit).decode(charset)\n            if stream.read(1):  # These is more that does not fit mem_limit\n                raise MultipartError(\"Request to big. Increase MAXMEM.\")\n            data = parse_qs(data, keep_blank_values=True)\n            for key, values in data.items():\n                for value in values:\n                    forms[key] = value\n        else:\n            raise MultipartError(\"Unsupported content type.\")\n    except MultipartError:\n        if strict:\n            raise\n    return forms, files"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, name, default=None):\n        ''' Return the first part with that name or a default value (None). '''\n        for part in self:\n            if name == part.name:\n                return part\n        return default", "response": "Return the first part with that name or a default value."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate over a binary file - like object line by line.", "response": "def _lineiter(self):\n        ''' Iterate over a binary file-like object line by line. Each line is\n            returned as a (line, line_ending) tuple. If the line does not fit\n            into self.buffer_size, line_ending is empty and the rest of the line\n            is returned with the next iteration.\n        '''\n        read = self.stream.read\n        maxread, maxbuf = self.content_length, self.buffer_size\n        buffer = b''  # buffer for the last (partial) line\n        while 1:\n            data = read(maxbuf if maxread < 0 else min(maxbuf, maxread))\n            maxread -= len(data)\n            lines = (buffer+data).splitlines(True)\n            len_first_line = len(lines[0])\n            # be sure that the first line does not become too big\n            if len_first_line > self.buffer_size:\n                # at the same time don't split a '\\r\\n' accidentally\n                if (len_first_line == self.buffer_size+1 and lines[0].endswith(b'\\r\\n')):\n                    splitpos = self.buffer_size - 1\n                else:\n                    splitpos = self.buffer_size\n                lines[:1] = [lines[0][:splitpos],\n                             lines[0][splitpos:]]\n            if data:\n                buffer = lines[-1]\n                lines = lines[:-1]\n            for line in lines:\n                if line.endswith(b'\\r\\n'):\n                    yield line[:-2], b'\\r\\n'\n                elif line.endswith(b'\\n'):\n                    yield line[:-1], b'\\n'\n                elif line.endswith(b'\\r'):\n                    yield line[:-1], b'\\r'\n                else:\n                    yield line, b''\n            if not data:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef value(self):\n        ''' Data decoded with the specified charset '''\n        pos = self.file.tell()\n        self.file.seek(0)\n        val = self.file.read()\n        self.file.seek(pos)\n        return val.decode(self.charset)", "response": "Data decoded with the specified charset"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset buffer to value of Python Imaging Library image.", "response": "def image(self, image):\n        \"\"\"Set buffer to value of Python Imaging Library image.  The image should\n        be in 1 bit mode and a size equal to the display size.\n        \"\"\"\n        if image.mode != '1':\n            raise ValueError('Image must be in mode 1.')\n        imwidth, imheight = image.size\n        if imwidth != self.width or imheight != self.height:\n            raise ValueError('Image must be same dimensions as display ({0}x{1}).' \\\n                .format(self.width, self.height))\n        print(\"bitmap display: image\")\n        image.save(\"dummydisplay.bmp\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nimport object from string format module e. g. uuliweb. orm or an object return module object and object", "response": "def import_(path):\n    \"\"\"\n    Import string format module, e.g. 'uliweb.orm' or an object\n    return module object and object\n    \"\"\"\n    if isinstance(path, str):\n        v = path.split(':')\n        if len(v) == 1:\n            x = path.rsplit('.', 1)\n            if len(x) == 2:\n                module, func = x\n            else:\n                module, func = x[0], ''\n        else:\n            module, func = v\n        mod = __import__(module)\n        f = mod\n        if func:\n            for x in func.split('.'):\n                f = getattr(f, x)\n    else:\n        f = path\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef collection_index(self):\n\n        indexes = self.options.index\n        #add current directory to indexes\n        indexes.insert(0, os.getcwd())\n        if 'IDO_INDEXES' in os.environ:\n            indexes.extend(os.environ['IDO_INDEXES'].split(';'))\n\n        indexes.append(os.path.join(os.path.dirname(__file__), 'packages').replace('\\\\', '/'))\n        return indexes", "response": "Return a list of the indexes that will be used to index the current package."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef execute(self):\n        # Preprocess options to extract --settings and --pythonpath.\n        # These options could affect the commands that are available, so they\n        # must be processed early.\n        parser = NewOptionParser(prog=self.prog_name,\n                             usage=self.usage_info,\n#                             version=self.get_version(),\n                             formatter = NewFormatter(),\n                             add_help_option = False,\n                             option_list=self.option_list)\n\n        options, args = parser.parse_args(self.argv)\n        self.options = options\n        if len(args) == 0:\n            self.message(\"You should give at least one package name.\", 'error')\n            return\n\n        subcommand = args[0]\n\n        self.handle(args[1:], self.options, self.global_options, subcommand)", "response": "This function takes the command - line arguments and runs the appropriate command."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a temporary directory. A contextmanager that creates and returns a temporary directory, cleaning it up on exit. The force option specifies whether or not the directory is removed recursively. If set to `False` (the default is `True`), only an empty temporary directory will be removed. This is helpful to create temporary directories for things like mountpoints; otherwise a failing unmount would result in all files on the mounted volume to be deleted. :param suffix: Passed on to :func:`tempfile.mkdtemp`. :param prefix: Passed on to :func:`tempfile.mkdtemp`. :param dir: Passed on to :func:`tempfile.mkdtemp`. :param force: If true, recursively removes directory, otherwise just removes if empty. If directory isn't empty and `force` is `False`, :class:`OSError` is raised. :return: Path to the newly created temporary directory.", "response": "def dir(suffix='', prefix='tmp', dir=None, force=True):\n    \"\"\"Create a temporary directory.\n\n    A contextmanager that creates and returns a temporary directory, cleaning\n    it up on exit.\n\n    The force option specifies whether or not the directory is removed\n    recursively. If set to `False` (the default is `True`), only an empty\n    temporary directory will be removed. This is helpful to create temporary\n    directories for things like mountpoints; otherwise a failing unmount would\n    result in all files on the mounted volume to be deleted.\n\n    :param suffix: Passed on to :func:`tempfile.mkdtemp`.\n    :param prefix: Passed on to :func:`tempfile.mkdtemp`.\n    :param dir: Passed on to :func:`tempfile.mkdtemp`.\n    :param force: If true, recursively removes directory, otherwise just\n                  removes if empty. If directory isn't empty and `force` is\n                  `False`, :class:`OSError` is raised.\n    :return: Path to the newly created temporary directory.\n    \"\"\"\n    name = tempfile.mkdtemp(suffix, prefix, dir)\n\n    try:\n        yield name\n    finally:\n        try:\n            if force:\n                shutil.rmtree(name)\n            else:\n                os.rmdir(name)\n        except OSError as e:\n            if e.errno != 2:  # not found\n                raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef file(mode='w+b', suffix='', prefix='tmp', dir=None, ignore_missing=False):\n    # note: bufsize is not supported in Python3, try to prevent problems\n    #       stemming from incorrect api usage\n    if isinstance(suffix, int):\n        raise ValueError('Passed an integer as suffix. Did you want to '\n                         'specify the deprecated parameter `bufsize`?')\n\n    fp = tempfile.NamedTemporaryFile(mode=mode,\n                                     suffix=suffix,\n                                     prefix=prefix,\n                                     dir=dir,\n                                     delete=False)\n    try:\n        yield fp\n    finally:\n        try:\n            os.unlink(fp.name)\n        except OSError as e:\n            # if the file does not exist anymore, ignore\n            if e.errno != ENOENT or ignore_missing is False:\n                raise", "response": "A contextmanager that creates a temporary file and returns a file object with a. name attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unix_socket(sock=None, socket_name='tmp.socket', close=True):\n    sock = sock or socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n\n    with dir() as dtmp:\n        addr = os.path.join(dtmp, socket_name)\n        sock.bind(addr)\n\n        try:\n            yield sock, addr\n        finally:\n            if close:\n                sock.close()", "response": "Create a unix socket and bind it to the filesystem."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload a configuration file ; eventually support dicts. yaml. csv etc.", "response": "def load_config(self, path):\n        '''Load a configuration file; eventually, support dicts, .yaml, .csv, etc.'''\n\n        # if no path was provided, resort to defaults\n        if path == None:\n            print(\"Path to config was null; using defaults.\")\n            return\n\n        if not os.path.exists(path):\n            print(\"[No user config file found at default location; using defaults.]\\n\")\n            return\n\n\n        user_config = None\n\n        # read in the user's configuration file (for now, we hope it's yaml)\n        with open(path) as f:\n            user_config = f.read()\n\n        # load the user's configuration file into a Config object\n        extension = os.path.splitext(path)\n        if extension == 'yaml':\n            user_config = yaml.load(user_config)\n        else:\n            raise Error('Configuration file type \"{}\" not supported'.format(extension))\n\n        # copy the user's preferences into the default configurations\n        self.merge_config(user_config)\n\n        # build the udpated configuration\n        self.configuration = Configuration(self.data_config, self.model_config, self.conversation_config)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmerge the user preferences and the default data model and conversation configurations.", "response": "def merge_config(self, user_config):\n        '''\n        Take a dictionary of user preferences and use them to update the default\n        data, model, and conversation configurations.\n        '''\n\n        # provisioanlly update the default configurations with the user preferences\n        temp_data_config = copy.deepcopy(self.data_config).update(user_config)\n        temp_model_config = copy.deepcopy(self.model_config).update(user_config)\n        temp_conversation_config = copy.deepcopy(self.conversation_config).update(user_config)\n\n        # if the new configurations validate, apply them\n        if validate_data_config(temp_data_config):\n            self.data_config = temp_data_config\n        if validate_model_config(temp_model_config):\n            self.model_config = temp_model_config\n        if validate_conversation_config(temp_conversation_config):\n            self.conversation_config = temp_conversation_config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nextracting user data, either from user session or from database (for each User, an InfoObject is used to store data of a certain kind (e.g., user customization, saved searches, etc.). If for a given user, no InfoObject exists for a given type of user-specific data, the default data is read from the settings and an InfoObject with default settings is created. The function returns a dictionary of form {'customization': <dict with user customization>, 'saved_searches': <dict with saved searches> }", "response": "def get_user_data(self):\n        \"\"\"\n        Extracts user data, either from user session or from\n        database (for each User, an InfoObject is used to\n        store data of a certain kind (e.g., user customization,\n        saved searches, etc.). If for a given user,\n        no InfoObject exists for a given type of user-specific data,\n        the default data is read from the settings and\n        an InfoObject with default settings is created.\n\n        The function returns a dictionary of form\n\n        {'customization': <dict with user customization>,\n         'saved_searches': <dict with saved searches>\n         }\n\n\n        \"\"\"\n\n        # Below, we retrieve user-specific data (user preferences, saved searches, etc.)\n        # We take this data from the session -- if it has already been\n        # loaded in the session. If not, then we load the data into the session first.\n        #\n        # Things are a bit tricky, because users can first be unauthenticated,\n        # then log in, then log off again. This must be reflected in the user data\n        # that is loaded into the session.\n        #\n        # There are four cases if settings exist within session scope:\n        # 1.) unauthenticated user && non-anonymous settings exist in session --> load\n        # 2.) unauthenticated user && anonymous settings --> pass\n        # 3.) authenticated user && non-anonymous settings --> pass\n        # 4.) authenticated user && anonymous settings --> load\n\n        settings = self.request.session.get('customization')\n\n        saved_searches = self.request.session.get('saved_searches')\n        load_new_settings = False\n\n        if settings:\n\n            # case 1.)\n            if (not self.request.user.is_authenticated()) \\\n                and self.request.session.get('customization_for_authenticated'):\n                load_new_settings = True\n\n            # case 4.)\n            elif self.request.user.is_authenticated() \\\n                and not self.request.session.get('customization_for_authenticated'):\n                load_new_settings = True\n\n        else:\n            load_new_settings = True\n\n        if load_new_settings:\n            # Load user settings. If for the current user, no user settings have been\n            # stored, retrieve the default settings and store them (for authenticated users)\n\n            if self.request.user.is_authenticated():\n                user_name = self.request.user.username\n            else:\n                user_name = \"unauthenticated user\"\n\n            self.request.session['customization_for_authenticated']=self.request.user.is_authenticated()\n\n\n\n            settings = UserData.get_user_data(user=self.request.user,data_kind=DINGOS_USER_PREFS_TYPE_NAME)\n\n            if not settings:\n                UserData.store_user_data(user=self.request.user,\n                                         data_kind=DINGOS_USER_PREFS_TYPE_NAME,\n                                         user_data=DINGOS_DEFAULT_USER_PREFS,\n                                         iobject_name= \"User preferences of user '%s'\" % user_name)\n\n                settings = UserData.get_user_data(user=self.request.user,data_kind=DINGOS_USER_PREFS_TYPE_NAME)\n\n\n\n            # Do the same for saved searches\n\n            saved_searches = UserData.get_user_data(user=self.request.user, data_kind=DINGOS_SAVED_SEARCHES_TYPE_NAME)\n            if not saved_searches:\n\n                UserData.store_user_data(user=self.request.user,\n                                         data_kind=DINGOS_SAVED_SEARCHES_TYPE_NAME,\n                                         user_data=DINGOS_DEFAULT_SAVED_SEARCHES,\n                                         iobject_name = \"Saved searches of user '%s'\" % user_name)\n                saved_searches = UserData.get_user_data(user=self.request.user, data_kind=DINGOS_SAVED_SEARCHES_TYPE_NAME)\n\n\n            self.request.session['customization'] = settings\n            self.request.session['saved_searches'] = saved_searches\n\n        return {'customization': settings,\n                'saved_searches' : saved_searches}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef index():\n    # Prepare mappings from configuration.\n    mapping = cfg['UNAPI_FORMAT_MAPPING']\n    names = {mapping[k]: k for k in mapping}\n    # Clean request arguments.\n    identifier = request.values.get('id', type=int)\n    format_ = request.values.get('format')\n    format_ = mapping.get(format_, format_)\n    # Redirect to correct record format.\n    if identifier and format_:\n        return redirect(url_for('record.metadata', recid=identifier,\n                                of=format_))\n\n    formats = [{\n        'name': names[of],\n        'type': values['content_type'],\n        'docs': values.get('url'),\n    } for of, values in iteritems(output_formats) if of in names]\n\n    response = make_response(render_template(\n        'unapi/index.xml', identifier=identifier, formats=formats))\n    response.headers['Content-Type'] = 'application/xml'\n    return response", "response": "Handle the unapi set of pages."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexecutes the tool with given options.", "response": "def execute(options):\n    \"\"\"execute the tool with given options.\"\"\"\n    # Load the key in PKCS 12 format that you downloaded from the Google APIs\n    # Console when you created your Service account.\n    package_name = options['<package>']\n    source_directory = options['<output_dir>']\n\n    if options['upload'] is True:\n        upstream = True\n    else:\n        upstream = False\n\n    sub_tasks = {'images': options['--images'], 'listings': options['--listings'], 'inapp': options['--inapp']}\n    if sub_tasks == {'images': False, 'listings': False, 'inapp': False}:\n        sub_tasks = {'images': True, 'listings': True, 'inapp': True}\n\n    credentials = create_credentials(credentials_file=options['--credentials'],\n                                     service_email=options['--service-email'],\n                                     service_key=options['--key'])\n\n    command = SyncCommand(\n        package_name, source_directory, upstream, credentials, **sub_tasks)\n    command.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating Google credentials object.", "response": "def create_credentials(credentials_file=None,\n                       service_email=None,\n                       service_key=None,\n                       scope='https://www.googleapis.com/auth/androidpublisher'):\n    \"\"\"\n    Create Google credentials object.\n\n    If given credentials_file is None, try to retrieve file path from environment \n    or look up file in homefolder.\n    \"\"\"\n    credentials = None\n    if service_email is None and service_key is None:\n        print(credentials_file)\n        if credentials_file is None:\n            # try load file from env\n            key = 'PLAY_DELIVER_CREDENTIALS'\n            if key in os.environ:\n                credentials_file = os.environ[key]\n\n        if credentials_file is None:\n            # try to find the file in home\n            path = os.path.expanduser('~/.playdeliver/credentials.json')\n            if os.path.exists(path):\n                credentials_file = path\n\n        if credentials_file is not None:\n            credentials = client.GoogleCredentials.from_stream(\n                credentials_file)\n            credentials = credentials.create_scoped(scope)\n        else:\n            sys.exit(\"no credentials\")\n    else:\n        credentials = client.SignedJwtAssertionCredentials(\n            service_email, _load_key(service_key), scope=scope)\n    return credentials"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef good_decorator_accepting_args(decorator):\n    def new_decorator(*f, **k):\n        g = decorator(*f, **k)\n        if 1 == len(f) and isinstance(f[0], types.FunctionType):\n            g.__name__ = f[0].__name__\n            g.__doc__ = f[0].__doc__\n            g.__dict__.update(f[0].__dict__)\n            pass\n        return g\n    \n    new_decorator.__name__ = decorator.__name__\n    new_decorator.__doc__ = decorator.__doc__\n    new_decorator.__dict__.update(decorator.__dict__)\n    # Required for Sphinx' automodule.\n    new_decorator.__module__ = decorator.__module__\n    return new_decorator", "response": "This is a good decorator that accepts a list of arguments and keyword arguments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_ui(self, ):\n        w = QtGui.QWidget(self)\n        w.setLayout(self.central_vbox)\n        self.setCentralWidget(w)\n        releasetypes = [djadapter.RELEASETYPES['work'], djadapter.RELEASETYPES['release'], djadapter.RELEASETYPES['handoff']]\n        self.browser = FileBrowser(self._filetype, releasetypes, self.get_current_file, self)\n        self.central_vbox.insertWidget(0, self.browser)\n\n        self.asset_comment_pte = self.create_comment_edit()\n        self.browser.asset_vbox.addWidget(self.asset_open_pb)\n        self.asset_new_hbox = QtGui.QHBoxLayout()\n        self.asset_new_hbox.addWidget(self.asset_save_pb)\n        self.asset_new_hbox.addWidget(self.asset_descriptor_lb)\n        self.asset_new_hbox.addWidget(self.asset_descriptor_le)\n        self.browser.asset_vbox.addLayout(self.asset_new_hbox)\n        self.browser.asset_vbox.addWidget(self.asset_comment_pte)\n        self.shot_comment_pte = self.create_comment_edit()\n        self.browser.shot_vbox.addWidget(self.shot_open_pb)\n        self.shot_new_hbox = QtGui.QHBoxLayout()\n        self.shot_new_hbox.addWidget(self.shot_save_pb)\n        self.shot_new_hbox.addWidget(self.shot_descriptor_lb)\n        self.shot_new_hbox.addWidget(self.shot_descriptor_le)\n        self.browser.shot_vbox.addLayout(self.shot_new_hbox)\n        self.browser.shot_vbox.addWidget(self.shot_comment_pte)\n\n        ph = \"Enter New Descriptor\"\n        self.asset_descriptor_le.setPlaceholderText(ph)\n        self.shot_descriptor_le.setPlaceholderText(ph)\n\n        self.setup_icons()", "response": "Create the browsers and all necessary ui elements for the tool."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset all icons on buttons", "response": "def setup_icons(self, ):\n        \"\"\"Set all icons on buttons\n\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        folder_icon = get_icon('glyphicons_144_folder_open.png', asicon=True)\n        self.asset_open_pb.setIcon(folder_icon)\n        self.shot_open_pb.setIcon(folder_icon)\n\n        floppy_icon = get_icon('glyphicons_446_floppy_save.png', asicon=True)\n        self.asset_save_pb.setIcon(floppy_icon)\n        self.shot_save_pb.setIcon(floppy_icon)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup_signals(self, ):\n        self.browser.shot_taskfile_sel_changed.connect(self.shot_taskfile_sel_changed)\n        self.browser.asset_taskfile_sel_changed.connect(self.asset_taskfile_sel_changed)\n\n        self.shot_open_pb.clicked.connect(self.shot_open_callback)\n        self.asset_open_pb.clicked.connect(self.asset_open_callback)\n        self.shot_save_pb.clicked.connect(self.shot_save_callback)\n        self.asset_save_pb.clicked.connect(self.asset_save_callback)", "response": "Connect the signals with the slots to make the ui functional\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_descriptor_le(self, lineedit, tf):\n        if tf:\n            descriptor = tf.descriptor\n            lineedit.setText(descriptor)\n        else:\n            lineedit.setText(\"\")", "response": "Update the given line edit to show the descriptor that is stored in the index\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _save_tfi(self, tfi, asset=False):\n        jbfile = JB_File(tfi)\n        self.create_dir(jbfile)\n\n        tf, note = self.create_db_entry(tfi)\n\n        try:\n            js = JukeboxSignals.get()\n            if asset:\n                js.before_save_asset.emit(jbfile, tf)\n                self.save_asset(jbfile, tf)\n                js.after_save_asset.emit(jbfile, tf)\n            else:\n                js.before_save_shot.emit(jbfile, tf)\n                self.save_shot(jbfile, tf)\n                js.after_save_shot.emit(jbfile, tf)\n        except:\n            tf.delete()\n            note.delete()\n            self.statusbar.showMessage('Saving failed!')\n            log.exception(\"Saving failed!\")\n            return\n        self.browser.update_model(tfi)", "response": "Save the information in the given taskfile info\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_dir(self, jbfile):\n        try:\n            jbfile.create_directory()\n        except os.error:\n            self.statusbar.showMessage('Could not create path: %s' % jbfile.get_path())", "response": "Create a directory for the given dirfile and display an error message if it fails."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if the selected task is of a different releasetype and the current file is of a different releasetype.", "response": "def check_selection_for_save(self, task, releasetype, descriptor):\n        \"\"\"Emit warnings if the descriptor is None or the current file\n        is of a different task.\n\n        :param task: the selected task\n        :type task: :class:`djadapter.models.Task`\n        :param releasetype: the releasetype to save (probably work)\n        :type releasetype: str\n        :param descriptor: the descriptor\n        :type descriptor: str\n        :returns: True if check was successfull.\n        :rtype: bool\n        :raises: None\n        \"\"\"\n        if not descriptor:\n            self.statusbar.showMessage(\"Please provide a descriptor!\")\n            return False\n        try:\n            jukedj.validators.alphanum_vld(descriptor)\n        except ValidationError:\n            self.statusbar.showMessage(\"Descriptor contains characters other than alphanumerical ones.\")\n            return False\n        cur = self.get_current_file()\n        if cur and task != cur.task:\n            self.statusbar.showMessage(\"Task is different. Not supported atm!\")\n            return False\n        elif cur and releasetype != cur.releasetype:\n            self.statusbar.showMessage(\"Releasetype is different. Not supported atm!\")\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_db_entry(self, tfi):\n        if tfi.task.department.assetflag:\n            comment = self.asset_comment_pte.toPlainText()\n        else:\n            comment = self.shot_comment_pte.toPlainText()\n        return tfi.create_db_entry(comment)", "response": "Create a db entry for the given taskfile info"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends last file signal on close event", "response": "def closeEvent(self, event):\n        \"\"\"Send last file signal on close event\n\n        :param event: The close event\n        :type event:\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        lf = self.browser.get_current_selection()\n        if lf:\n            self.last_file.emit(lf)\n        return super(GenesisWin, self).close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nuploading listing files in source_dir. folder herachy.", "response": "def upload(client, source_dir):\n    \"\"\"Upload listing files in source_dir. folder herachy.\"\"\"\n    print('')\n    print('upload store listings')\n    print('---------------------')\n    listings_folder = os.path.join(source_dir, 'listings')\n    langfolders = filter(os.path.isdir, list_dir_abspath(listings_folder))\n\n    for language_dir in langfolders:\n        language = os.path.basename(language_dir)\n        with open(os.path.join(language_dir, 'listing.json')) as listings_file:\n            listing = json.load(listings_file)\n        listing_response = client.update(\n            'listings', language=language, body=listing)\n\n        print('  Listing for language %s was updated.' %\n              listing_response['language'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndownload listing files from play and saves them into folder herachy.", "response": "def download(client, target_dir):\n    \"\"\"Download listing files from play and saves them into folder herachy.\"\"\"\n    print('')\n    print('download store listings')\n    print('---------------------')\n    listings = client.list('listings')\n    for listing in listings:\n        path = os.path.join(target_dir, 'listings', listing['language'])\n        mkdir_p(path)\n        with open(os.path.join(path, 'listing.json'), 'w') as outfile:\n            print(\"save listing for {0}\".format(listing['language']))\n            json.dump(\n                listing, outfile, sort_keys=True,\n                indent=4, separators=(',', ': '))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield all the items in the dictionary that match the given keyword arguments.", "response": "def filter(self, **kwargs):\n        '''Assumes all the dict's items are hashable.\n        '''\n        # So we don't return anything more than once.\n        yielded = set()\n\n        dunder = '__'\n        filter_items = set()\n        for k, v in kwargs.items():\n            if dunder in k:\n                k, op = k.split(dunder)\n                try:\n                    handler = getattr(self, 'handle__%s' % op)\n                except AttributeError:\n                    msg = '%s has no %r method to handle operator %r.'\n                    raise NonExistentHandler(msg % (self, handler, op))\n                for dicty in self:\n                    if handler(k, v, dicty):\n                        dicty_id = id(dicty)\n                        if dicty_id not in yielded:\n                            yield dicty\n                            yielded.add(dicty_id)\n            else:\n                filter_items.add((k, v))\n\n        for dicty in self:\n            dicty_items = set(dicty.items())\n            if filter_items.issubset(dicty_items):\n                yield dicty"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncopying the SSH public keys to the given hosts.", "response": "def copy_ssh_keys_to_hosts(self, hosts, known_hosts=DEFAULT_KNOWN_HOSTS, dry=False):\n        \"\"\"\n        Copy the SSH keys to the given hosts.\n\n        :param hosts: the list of `Host` objects to copy the SSH keys to.\n        :param known_hosts: the `known_hosts` file to store the SSH public keys.\n        :param dry: perform a dry run.\n        :raise msshcopyid.errors.CopySSHKeysError:\n        \"\"\"\n        exceptions = []  # list of `CopySSHKeyError`\n        for host in hosts:\n            logger.info('[%s] Copy the SSH public key [%s]...', host.hostname, self.sshcopyid.pub_key)\n            if not dry:\n                try:\n                    self.copy_ssh_keys_to_host(host, known_hosts=known_hosts)\n                except (paramiko.ssh_exception.SSHException, socket.error) as ex:\n                    logger.error(format_error(format_exception(ex)))\n                    logger.debug(traceback.format_exc())\n                    exceptions.append(CopySSHKeyError(host=host, exception=ex))\n\n        if exceptions:\n            raise CopySSHKeysError(exceptions=exceptions)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies the SSH keys to the given host.", "response": "def copy_ssh_keys_to_host(self, host, known_hosts=DEFAULT_KNOWN_HOSTS):\n        \"\"\"\n        Copy the SSH keys to the given host.\n\n        :param host: the `Host` object to copy the SSH keys to.\n        :param known_hosts: the `known_hosts` file to store the SSH public keys.\n        :raise paramiko.ssh_exception.AuthenticationException:\n        \"\"\"\n        password = host.password or self.sshcopyid.default_password\n        try:\n            self.sshcopyid.copy_ssh_keys_to_host(host, password=password, no_add_host=self.args.no_add_host,\n                                                 known_hosts=known_hosts)\n\n        except paramiko.ssh_exception.AuthenticationException:\n            if password:\n                # A password was given, and it is wrong\n                raise\n            else:\n                # Ask for password\n                password = utils.get_password()\n                self.sshcopyid.default_password = password\n\n                # Try to connect again\n                self.sshcopyid.copy_ssh_keys_to_host(host, password=password, no_add_host=self.args.no_add_host,\n                                                     known_hosts=known_hosts)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nunpacking a zipfile using the names in the zip.", "response": "def unpack_zipfile(filename):\n    \"\"\"Unpack a zipfile, using the names in the zip.\"\"\"\n    with open(filename, \"rb\") as fzip:\n        z = zipfile.ZipFile(fzip)\n        for name in z.namelist():\n            print((\"      extracting {}\".format(name)))\n            ensure_dirs(name)\n            z.extract(name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_primary_contributors(self, permitted=True):\n        primary_credits = []\n        credits = self.credits.exclude(role=None).order_by('role')\n        if credits:\n            primary_role = credits[0].role\n            for credit in credits:\n                if credit.role == primary_role:\n                    primary_credits.append(credit)\n\n        contributors = []\n        for credit in primary_credits:\n            contributor = credit.contributor\n            if permitted and contributor.is_permitted:\n                contributors.append(contributor)\n            else:\n                contributors.append(contributor)\n\n        return contributors", "response": "Returns a list of primary contributors with the highest role assigned."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prog_iter(bounded_iterable, delta=0.01, line_size=50):\n    '''Wraps the provided sequence with an iterator that tracks its progress \n    on the console.\n\n        >>> for i in prog_iter(xrange(100)): pass\n        ..................................................\n        ..................................................\n         (0.000331163406372 s)\n         \n    More specifically, the behavior is as follows:\n    \n    - Produces a progress bar on stdout, at ``delta`` increments, where \n      ``delta`` is a percentage (represented as a float from 0.0 to 1.0)\n    - Newline every line_size dots (defaults to 50)\n    - Displays the time the loop took, as in toc() (without interfering with toc)\n    - A prog_iter nested in another prog_iter will not produce any of these\n      side effects. That is, only one progress bar will ever be printing at a time.\n    \n    '''\n    # TODO: Technically, this should have a __len__.\n    global _prog_iterin_loop\n\n    if not _prog_iterin_loop:\n        startTime = _time.time()\n        _prog_iterin_loop = True\n        length = float(len(bounded_iterable))\n        _sys.stdout.write(\".\")\n        dots = 1\n        next = delta\n        for i, item in enumerate(bounded_iterable):\n            if (i + 1) / length >= next:\n                next += delta\n                dots += 1\n                _sys.stdout.write(\".\")\n                if dots % line_size == 0:\n                    _sys.stdout.write(\"\\n\")\n                _sys.stdout.flush()\n            yield item\n        print((\" (\" + str(_time.time() - startTime) + \" s)\"))\n        _prog_iterin_loop = False\n    else:\n        for item in bounded_iterable:\n            yield item", "response": "Wraps the provided sequence with an iterator that tracks its progress \n    on the console."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef include(gset, elem, value=True):\n    add = getattr(gset, 'add', None) # sets\n    if add is None: add = getattr(gset, 'append', None)  # lists\n    if add is not None: add(elem)\n    else: # dicts\n        if not hasattr(gset, '__setitem__'):\n            raise Error(\"gset is not a supported container.\")\n        gset[elem] = value\n    return elem", "response": "Do whatever it takes to make elem in gset."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndo whatever it takes to make each elem in elems.", "response": "def include_many(gset, elems, truth_value=True):\n    \"\"\"Do whatever it takes to make ``elem in gset`` true for each elem in ``elems``.\n    \n    See :func:`include`.\n    \"\"\"\n    extend = getattr(gset, 'extend', None)\n    if extend is not None:\n        extend(elems)\n    elif hasattr(gset, '__setitem__'):\n        gset.update((elem, truth_value) for elem in elems)\n    elif hasattr(gset, 'update'):\n        gset.update(elems)\n    else:\n        raise Error(\"gset is not a supported container.\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_once(gset, elem):\n    remove = getattr(gset, 'remove', None)\n    if remove is not None: remove(elem)\n    else: del gset[elem]\n    return elem", "response": "Remove the element from a set lists or dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_all(gset, elem):\n    n = 0\n    while True:\n        try:\n            remove_once(gset, elem)\n            n = n + 1\n        except RemoveError:\n            return n", "response": "Removes every occurrence of elem from gset. Returns the number of times elem was removed."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_iterable(value, include_maps=False, include_sets=True):\n    if hasattr(value, '__iter__'):\n        if not include_maps and hasattr(value, 'keys'):\n            return False\n        if not include_sets and hasattr(value, 'isdisjoint'):\n            return False\n        return True\n    else:\n        return False", "response": "Returns whether value is iterable."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwraps a single non - iterable value with a tuple or other iterable type.", "response": "def as_iterable(value, wrap_maps=True, wrap_sets=False, itertype=tuple):\n    \"\"\"Wraps a single non-iterable value with a tuple (or other iterable type, \n    if ``itertype`` is provided.)\n    \n        >>> as_iterable(\"abc\")\n        (\"abc\",)\n        >>> as_iterable((\"abc\",))\n        (\"abc\",)\n        \n    Equivalent to::\n    \n        if is_iterable(value, not wrap_maps, not wrap_sets):\n            return value\n        else:\n            return itertype(value)\n            \n    \"\"\"\n    if is_iterable(value, not wrap_maps, not wrap_sets):\n        return value\n    else:\n        return itertype(value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flatten(iterable, check=is_iterable):\n    for value in iterable:\n        if check(value):\n            for flat in flatten(value, check):\n                yield flat\n        else:\n            yield value", "response": "Returns a recursively flattened version of iterable"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ed(fn, iterable, *args, **kwargs):\n    if hasattr(iterable, '__len__'):\n        return iterable.__class__(fn(iterable, *args, **kwargs))\n    else:\n        return tuple(fn(iterable, *args, **kwargs))", "response": "A function that returns a tuple or list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef xflatten(iterable, transform, check=is_iterable):\n    for value in transform(iterable):\n        if check(value):\n            for flat in xflatten(value, transform, check):\n                yield flat\n        else:\n            yield value", "response": "Apply a transform to iterable before flattening at each level."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef flatten_once(iterable, check=is_iterable):\n    for value in iterable:\n        if check(value):\n            for item in value:\n                yield item\n        else:\n            yield value", "response": "Flattens only the first level."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef join(iterable, sep):\n    i = 0\n    for i, item in enumerate(iterable):\n        if i == 0:\n            yield item\n        else:\n            yield sep\n            yield item", "response": "Like str. join but yields an iterable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstop iterating before yielding the specified idx.", "response": "def stop_at(iterable, idx):\n    \"\"\"Stops iterating before yielding the specified idx.\"\"\"\n    for i, item in enumerate(iterable):\n        if i == idx: return\n        yield item"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nyield all pairs drawn from seq1 and seq2.", "response": "def all_pairs(seq1, seq2=None):\n    \"\"\"Yields all pairs drawn from ``seq1`` and ``seq2``.\n\n    If ``seq2`` is ``None``, ``seq2 = seq1``.\n\n        >>> stop_at.ed(all_pairs(xrange(100000), xrange(100000)), 8)\n        ((0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7))\n    \"\"\"\n    if seq2 is None: seq2 = seq1\n    for item1 in seq1:\n        for item2 in seq2:\n            yield (item1, item2)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a pair of sequences of the same length by padding the shorter sequence with item.", "response": "def padded_to_same_length(seq1, seq2, item=0):\n    \"\"\"Return a pair of sequences of the same length by padding the shorter \n    sequence with ``item``.\n\n    The padded sequence is a tuple. The unpadded sequence is returned as-is.\n    \"\"\"\n    len1, len2 = len(seq1), len(seq2)\n    if len1 == len2:\n        return (seq1, seq2)\n    elif len1 < len2:\n        return (cons.ed(seq1, yield_n(len2-len1, item)), seq2)\n    else:\n        return (seq1, cons.ed(seq2, yield_n(len1-len2, item)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_int_like(value):\n    try:\n        if isinstance(value, int): return True\n        return int(value) == value and str(value).isdigit()\n    except:\n        return False", "response": "Returns whether the value can be used as a standard integer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_float_like(value):\n    try:\n        if isinstance(value, float): return True\n        return float(value) == value and not str(value).isdigit()\n    except:\n        return False", "response": "Returns whether the value acts like a standard float."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking the given dictionary symmetric. Values are assumed to be unique.", "response": "def make_symmetric(dict):\n    \"\"\"Makes the given dictionary symmetric. Values are assumed to be unique.\"\"\"\n    for key, value in list(dict.items()):\n        dict[value] = key\n    return dict"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the underlying function that will be called by the () operator.", "response": "def get_fn(callable):\n    \"\"\"Returns the underlying function that will be called by the () operator.\n\n        * For regular functions, returns ``callable``\n        * For bound methods, returns ``callable.im_func``\n        * For unbound methods, returns ``callable.__func__``\n        * For classes, returns ``callable.__init__.__func__``.\n        * For callable objects, returns ``callable.__call__.im_func``.\n\n    \"\"\"\n    if _inspect.isfunction(callable):\n        return callable\n    if _inspect.ismethod(callable):\n        try:\n            return callable.__func__\n        except AttributeError:\n            return callable.__func__\n    if _inspect.isclass(callable):\n        return callable.__init__.__func__\n    if hasattr(callable, '__call__'):\n        return callable.__call__.__func__\n    return callable"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the underlying function or method that will be called by the () operator.", "response": "def get_fn_or_method(callable):\n    \"\"\"Returns the underlying function or method that will be called by the () operator.\n\n        * For regular functions and methods, returns ``callable``\n        * For classes, returns ``callable.__init__``\n        * For callable objects, returns ``callable.__call__``\n\n    \"\"\"\n    if _inspect.isfunction(callable) or _inspect.ismethod(callable):\n        return callable\n    if _inspect.isclass(callable):\n        return callable.__init__\n    return callable.__call__"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fn_kwargs(callable):\n    fn = get_fn(callable)\n    (args, _, _, defaults) = _inspect.getargspec(fn)\n    if defaults is None: return { }\n    return dict(list(zip(reversed(args), reversed(defaults))))", "response": "Returns a dict with the kwargs from the provided function."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the number of explicit non - keyword arguments that the callable can be called with.", "response": "def fn_available_argcount(callable):\n    \"\"\"Returns the number of explicit non-keyword arguments that the callable\n    can be called with.\n\n    Bound methods are called with an implicit first argument, so this takes\n    that into account.\n\n    Excludes *args and **kwargs declarations.\n    \"\"\"\n    fn = get_fn_or_method(callable)\n    if _inspect.isfunction(fn):\n        return fn.__code__.co_argcount\n    else: # method\n        if fn.__self__ is None:\n            return fn.__func__.__code__.co_argcount\n        else:\n            return fn.__func__.__code__.co_argcount - 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fn_minimum_argcount(callable):\n    fn = get_fn(callable)\n    available_argcount = fn_available_argcount(callable)\n    try:\n        return available_argcount - len(fn.__defaults__)\n    except TypeError:\n        return available_argcount", "response": "Returns the minimum number of arguments that must be provided for the call to succeed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the signature of the provided callable as a tuple of strings.", "response": "def fn_signature(callable, \n                 argument_transform=(lambda name: name),\n                 default_transform=(lambda name, value: \"%s=%s\" % \n                                                        (name, repr(value))),\n                 vararg_transform=(lambda name: \"*\" + name),\n                 kwargs_transform=(lambda name: \"**\" + name)):\n    \"\"\"Returns the signature of the provided callable as a tuple of strings.\"\"\"\n    signature = []\n    fn = get_fn(callable)\n    avail_ac = fn_available_argcount(fn)\n    kwargs = fn_kwargs(fn)\n    argnames = fn_argnames(fn)\n    for name in stop_at(argnames, avail_ac):\n        if name in kwargs:\n            signature.append(default_transform(name, kwargs[name]))\n        else:\n            signature.append(argument_transform(name))\n    if fn_has_args(fn):\n        if fn_has_kwargs(fn):\n            signature.append(vararg_transform(argnames[-2]))\n            signature.append(kwargs_transform(argnames[-1]))\n        else:\n            signature.append(vararg_transform(argnames[-1]))\n    elif fn_has_kwargs(fn):\n        signature.append(kwargs_transform(argnames[-1]))\n\n    return signature"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fn_arg_hash_function(fn):\n    fn = get_fn(fn)\n    n_explicit = fn_available_argcount(fn)\n    has_args = fn_has_args(fn)\n    has_kwargs = fn_has_kwargs(fn)\n    default_kwargs = fn_kwargs(fn)\n    for name, value in list(default_kwargs.items()):  \n        # store only hashes of values to prevent memory leaks\n        try: default_kwargs[name] = hash(value)\n        except TypeError: default_kwargs[name] = _unhashable_object\n    explicit_kwarg_args = set(default_kwargs.keys())\n    n_explicit_kwargs = len(explicit_kwarg_args)\n    n_explicit_args = n_explicit - n_explicit_kwargs\n    def _hashes(*args, **kwargs):        \n        # explicit args\n        i = 0\n        n_explicit_args_ = min(len(args), n_explicit_args)\n        while i < n_explicit_args_:\n            #print args[i], 'is an explicit arg.'            \n            yield hash(args[i])\n    \n            i += 1\n    \n        # explicit kwargs\n        for name in explicit_kwarg_args:\n            if len(args) > i:\n                #print args[i], 'is a kwarg without a default'\n                yield hash(args[i])\n                i += 1                \n            else:\n                try:\n                    #print kwargs[name], 'is a kwarg taken from kwargs'\n                    yield hash(kwargs[name])\n                except KeyError:\n                    #print default_kwargs[name], 'is a kwarg taken from defaults'\n                    yield default_kwargs[name]\n    \n        # *args\n        if has_args:\n            #print args[i:], 'is *args'\n            yield hash(args[i:])\n    \n        # **kwargs\n        # NOTE: we're treating the kwargs dicts as hashable even though \n        # technically they aren't... be wary if you define **kwargs and then\n        # depend on its mutable characteristics.\n        if has_kwargs:\n            items = frozenset(item for item in list(kwargs.items())\n                              if item[0] not in explicit_kwarg_args)\n            #print items, 'is **kwargs items'\n            yield hash(items)\n        \n    def hash_(*args, **kwargs):\n        return tuple(_hashes(*args, **kwargs))\n    \n    return hash_", "response": "Returns a hash function which will return the same hashable value if the function is called with the same arguments as the argument \n   ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decorator(d):\n    defaults = d.__defaults__\n    if defaults and defaults[0] is None:\n        # Can be applied as @decorator or @decorator(kwargs) because\n        # first argument is None\n        def decorate(fn=None, **kwargs):\n            if fn is None:\n                return _functools.partial(decorate, **kwargs)\n            else:\n                decorated = d(fn, **kwargs)\n                _functools.update_wrapper(decorated, fn)\n                return decorated\n    else:\n        # Can only be applied as @decorator\n        def decorate(fn):\n            decorated = d(fn)\n            _functools.update_wrapper(decorated, fn)\n            return decorated\n    _functools.update_wrapper(decorate, d)\n    return decorate", "response": "Creates a proper decorator."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncaches the result of the provided function.", "response": "def memoize(fn=None):\n    \"\"\"Caches the result of the provided function.\"\"\"\n    cache = { }\n    arg_hash_fn = fn_arg_hash_function(fn)\n\n    def decorated(*args, **kwargs):\n        try:\n            hash_ = arg_hash_fn(*args, **kwargs)\n        except TypeError:\n            return fn(*args, **kwargs)\n\n        try:\n            return cache[hash_]\n        except KeyError:\n            return_val = fn(*args, **kwargs)\n            cache[hash_] = return_val\n            return return_val\n    _functools.update_wrapper(decorated, fn)\n\n    return decorated"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef safe_setattr(obj, name, value):\n    try:\n        setattr(obj, name, value)\n        return True\n    except AttributeError:\n        return False", "response": "Attempt to setattr but catch AttributeErrors."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef method_call_if_def(obj, attr_name, m_name, default, *args, **kwargs):\n    try:\n        attr = getattr(obj, attr_name)\n    except AttributeError:\n        return default\n    else:\n        return getattr(attr, m_name)(*args, **kwargs)", "response": "Calls the provided method if it is defined."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall the provided callable on the provided attribute of obj if it is defined. If not returns default.", "response": "def call_on_if_def(obj, attr_name, callable, default, *args, **kwargs):\n    \"\"\"Calls the provided callable on the provided attribute of ``obj`` if it is defined.\n\n    If not, returns default.\n    \"\"\"\n    try:\n        attr = getattr(obj, attr_name)\n    except AttributeError:\n        return default\n    else:\n        return callable(attr, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef define_property(obj, name, fget=None, fset=None, fdel=None, doc=None):\n    if hasattr(fget, '__get__'):  # can pass a property declaration too\n        prop = fget\n    else:\n        prop = property(fget, fset, fdel, doc)\n    cls = obj.__class__\n    obj.__class__ = type(cls.__name__, (cls, ), {\n        '__doc__': cls.__doc__,\n        name: prop\n    })", "response": "Defines a @property dynamically for an instance rather than a class."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndefines multiple @properties dynamically for an instance rather than a class.", "response": "def define_properties(obj, props):\n    \"\"\"Defines multiple @properties dynamically for an instance rather than a class.\"\"\"\n    cls = obj.__class__\n    dct = {\n        '__doc__': cls.__doc__\n    }\n\n    for name, defn in list(props.items()):\n        if is_callable(defn):\n            defn = property(defn)\n        elif not hasattr(defn, '__get__'):\n            defn = property(*defn)\n        dct[name] = defn\n\n    obj.__class__ = type(cls.__name__, (cls, ), dct)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef replaceable(decorator):\n    def decorate(fn, *args, **kwargs):\n        parent = decorator(fn, *args, **kwargs)\n        #doc = _add_msg(getattr(parent, '__doc__', None), '*@replaceable*')\n        doc = getattr(parent, '__doc__', None)\n        return _replaceable(parent, doc)\n    return decorate", "response": "A decorator which allows a method to be called even if it is defined as a data descriptor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setonce(decorator):\n    def decorate(fn, *args, **kwargs):\n        parent = decorator(fn, *args, **kwargs)\n        #doc = _add_msg(getattr(parent, '__doc__', None), '*@setonce*')\n        doc = getattr(parent, '__doc__', None)\n        assert hasattr(parent, \"__set__\") # don't use for non-data descriptors!\n        return _setonce(fn.__name__, parent, doc)\n    return decorate", "response": "A decorator which allows to be used at most once."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef autoinit(fn):\n    if fn is None:\n        fn = _empty_init\n\n    if fn_has_args(fn):\n        raise Error(\"*args support is not available in autoinit.\")\n        # its pretty hard to support this, though doable if really needed...\n\n    __defaults = fn_kwargs(fn)\n\n    avail_ac = fn_available_argcount(fn)\n    avail_args = list(fn.__code__.co_varnames[1:avail_ac])\n\n    signature = fn_signature(fn,\n        argument_transform=(lambda name: name),\n        default_transform=(lambda name, _: \"%s=__defaults['%s']\" % (name,name)),\n        vararg_transform=None,\n        kwargs_transform=(lambda _: \"**__kwargs\"))\n    signature[0] = \"self\"\n    \n    call_signature = fn_signature(fn,\n        argument_transform=(lambda name: \"%s=%s\" % (name, name)),\n        default_transform=(lambda name, _: \"%s=%s\" % (name,name)),\n        vararg_transform=None,\n        kwargs_transform=(lambda _: \"**__kwargs\"))\n    call_signature[0] = \"self\"\n\n    if not fn_has_kwargs(fn):\n        signature.append(\"**__kwargs\")\n        call_signature.append(\"**__kwargs\")\n\n    signature = \", \".join(signature)\n    call_signature = \", \".join(call_signature)\n    avail_args = repr(tuple(avail_args))\n    \n    code = '''def __init__(%(signature)s):\n    __cls = self.__class__\n    __mro = tuple(__cls.mro())\n\n    # call up the mro\n    for __base in __mro:\n        if __base is object: continue\n        try:\n            __wrapped_init = __base.__init__.__wrapped_init\n        except AttributeError:\n            # not an autoinit class\n            pass\n        else:\n            # **kwargs signals that the initializer wants to be called\n            if __wrapped_init and fn_has_kwargs(__wrapped_init):\n                __wrapped_init(%(call_signature)s)\n\n    # get defaults from hierarchy\n    __update_kwargs = { }\n    for __base in reversed(__mro):\n        if __base is __cls or __base is object: continue\n        try:\n            __defaults = __base.__init__.__defaults\n        except AttributeError:\n            # not an autoinit class\n            pass\n        else:\n            for __name, __val in __defaults.iteritems():\n                if __val is not Default:\n                    __update_kwargs[__name] = __val\n\n    # get locally passed arguments into __update_kwargs\n    __locals = locals()\n    for __name in %(avail_args)s:\n        __val = __locals[__name]\n        if __val is Default:\n            if __name not in __update_kwargs:\n                raise Error(\"Must specify argument \" + __name)\n        else:\n            __update_kwargs[__name] = __val\n            \n    for __name, __val in __kwargs.iteritems():\n        if __val is Default:\n            if __name not in __update_kwargs:\n                raise Error(\"Must specify argument \" + __name)\n        else:\n            __update_kwargs[__name] = __val\n\n    # set attributes according to kwargs\n    for __name, __val in __update_kwargs.iteritems():\n        if isinstance(__val, _new_initializer):\n            setattr(self, __name, __val())\n        else:\n            setattr(self, __name, __val)\n''' % locals()\n    exec(code, globals(), locals())\n    #\n    # i know, exec -- no other way to get the signature to match it seems\n    # unless i build it out of an abstract syntax tree or something, which \n    # seems excessive. or i could inspect the signature and do stuff dynamically\n    # but that is troublesome and the documentation generators won't like it\n    #\n    # if you want to try to fix it to not use exec but retain the semantics\n    # please do.\n    #\n    # -cyrus\n    \n    init = eval('__init__')\n    init.__wrapped_init = fn #@UndefinedVariable\n    init.__defaults = __defaults #@UndefinedVariable\n    _functools.update_wrapper(init, fn) #@UndefinedVariable\n    return init #@UndefinedVariable", "response": "autoinit generates a new object of the class with the specified name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_senior_subclass(obj, cls, testcls):\n    for base in obj.__class__.mro():\n        if base is cls:\n            return True\n        else:\n            if issubclass(base, testcls):\n                return False", "response": "Determines if the cls is the senior subclass of testcls for obj."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npreventing __init__ from being called if returning a obj copy.", "response": "def _dummy_init(self, *args, **kwargs): #@UnusedVariable\n    \"\"\"Prevents __init__ from being called if returning a obj copy.\"\"\"\n    cls = type(self)\n    old_init = cls._intern__old_init\n    if old_init is _NotDefined:\n        del cls.__init__\n    else:\n        cls.__init__ = old_init\n    del cls._intern__old_init"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef string_escape(string, delimiter='\"'):\n    if isinstance(string, str):\n        escaped = string.encode(\"string-escape\")\n    elif isinstance(string, str):\n        escaped = str(string.encode(\"unicode-escape\"))\n    else:\n        raise Error(\"Unexpected string type.\")\n    return delimiter + escape_quotes(escaped, delimiter) + delimiter", "response": "Turns special characters into escape sequences in the provided string."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a re matching newline + base_indentation.", "response": "def re_line_and_indentation(base_indentation,\n                            modifiers=(True, True)):\n    \"\"\"Returns a re matching newline + base_indentation.\n\n    modifiers is a tuple, (include_first, include_final).\n\n    If include_first, matches indentation at the beginning of the string.\n    If include_final, matches indentation at the end of the string.\n\n    Cached.\n    \"\"\"\n    cache = re_line_and_indentation.cache[modifiers]\n    compiled = cache.get(base_indentation, None)\n    if compiled is None:\n        [prefix, suffix] = re_line_and_indentation.tuple[modifiers]\n        compiled = cache[modifiers] = \\\n            _re.compile(prefix + base_indentation + suffix)\n    return compiled"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreplace base_indentation at beginning of lines with correct_indentation.", "response": "def fix_indentation(code, base_indentation=None, correct_indentation=\"\",\n                    modifiers=(True, True)):\n    \"\"\"Replaces base_indentation at beginning of lines with correct_indentation.\n\n    If base_indentation is None, tries to find it using get_base_indentation.\n    modifiers are passed to re_line_and_indentation. See there for doc.\n    \"\"\"\n    if base_indentation is None:\n        base_indentation = get_base_indentation(code, modifiers[0])\n    return re_line_and_indentation(base_indentation, modifiers).sub(\n        \"\\n\" + correct_indentation, code)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef intern(cls_):\n        cls_.__pool = { }\n        \n        __init__ = cls_.__init__\n        try:\n            __init__.__func__.__hash_function\n        except AttributeError:\n            try:\n                __init__.__func__.__hash_function = \\\n                        fn_arg_hash_function(__init__)\n            except (AttributeError, TypeError): pass\n            \n        # define an override for __new__ which looks in the cache first\n        def __new__(cls, *args, **kwargs):\n            \"\"\"Override used by cypy.intern to cache instances of this class.\"\"\"\n            \n            # check cache\n            __init__ = cls.__init__\n            try:\n                hash_function = __init__.__func__.__hash_function\n            except AttributeError:\n                try:\n                    hash_function = __init__.__func__.__hash_function = \\\n                                  fn_arg_hash_function(__init__)\n                except (AttributeError, TypeError):\n                    hash_function = generic_arg_hash_function\n            \n            try:\n                # look-up object\n                hash = hash_function(None, *args, **kwargs)  # none because self is not created yet\n                obj = cls_.__pool[hash]\n            except (TypeError, KeyError) as e:\n                # if arguments not hashable or object not found, need to \n                # make a new object\n                \n                # restore the original new temporarily, if it existed\n                orig_new = __new__.orig\n                if orig_new is _NotDefined: del cls_.__new__\n                else: cls_.__new__ = orig_new\n                \n                # create new object\n                obj = cls(*args, **kwargs)\n                \n                # put it in ze pool\n                if isinstance(e, KeyError):\n                    cls_.__pool[hash] = obj\n                \n                # re-override __new__\n                cls_.__new__ = __static_new__\n                                \n            # Return the instance but don't call __init__ since it was done \n            # when it was created the first time, see below for how this is \n            # done\n            try: cls.__old_init = cls.__dict__['__init__']\n            except KeyError: cls.__old_init = _NotDefined            \n            cls.__init__ = _dummy_init\n                \n            return obj\n            \n        # save original __new__\n        try: __new__.orig = staticmethod(cls_.__dict__['__new__'])\n        except KeyError: \n            if cls_.__new__ is object.__new__:\n                __new__.orig = _null_new\n            else:\n                __new__.orig = _NotDefined\n        \n        __static_new__ = staticmethod(__new__)\n        cls_.__static_new__ = __static_new__\n        cls_.__new__ = __static_new__\n        return cls_", "response": "Transforms the provided class into an interned class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef name(self):\n        basename = self.basename\n        if basename is None:\n            return None\n        \n        parent = self.Naming_parent\n        if parent is None:\n            return basename\n        else:    \n            return parent.generate_unique_name(basename)", "response": "The unique name of this object relative to the parent."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_unique_name(self, basename):\n        counts = self.__counts\n        try:\n            count = counts[basename]\n            counts[basename] += 1\n        except KeyError:\n            count = 0\n            counts[basename] = 1\n            \n        prefix = self.Naming_prefix\n\n        if count == 0:\n            name = prefix + basename\n        else:\n            name = prefix + basename + \"_\" + str(count)\n            \n        if prefix != \"\" or count != 0:\n            try:\n                count = counts[name]\n                return self.generate_unique_name(name)\n            except KeyError:\n                # wasn't already used so return it\n                counts[name] = 1\n        return name", "response": "Generates a unique name for a child given a base name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_to_parent(self):\n        parent = self.parent\n        if parent is not None:\n            try:\n                children = parent.children\n            except AttributeError: pass\n            else:\n                include(children, self)", "response": "Adds this node to the parent s children collection if it exists."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_from_parent(self):\n        parent = self.parent\n        if parent is not None:\n            try:\n                children = parent.children\n            except AttributeError: pass\n            else:\n                remove_upto_once(children, self)", "response": "Removes this node from the parent s children collection if it exists."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef iter_up(self, include_self=True):\n        if include_self: yield self\n        parent = self.parent\n        while parent is not None:\n            yield parent\n            try:\n                parent = parent.parent\n            except AttributeError:\n                return", "response": "Iterates up the tree to the root."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getrec(self, name, include_self=True, *default):\n        for node in self.iter_up(include_self):\n            try:\n                return getattr(node, name)\n            except AttributeError: pass\n            \n        if default:\n            return default[0]\n        else:\n            raise AttributeError(name)", "response": "Look up an attribute in the path to the root."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall a three - staged hook that is used to trigger the event that the named hook is called.", "response": "def trigger_staged_hook(self, name, *args, **kwargs):\n        \"\"\"Calls a three-staged hook:\n        \n        1. ``\"pre_\"+name``\n        2. ``\"_on_\"+name``\n        3. ``\"post_\"+name``\n        \n        \"\"\"\n        self.trigger_hook(\"pre_\" + name, *args, **kwargs)\n        self.trigger_hook(\"on_\" + name, *args, **kwargs)\n        self.trigger_hook(\"post_\" + name, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _spawn_thread(self, target):\n        t = Thread(target=target)\n        t.daemon = True\n        t.start()\n        return t", "response": "Create a thread and start it"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _thread(self):\n        # Get\n        args, kwargs = self._jobs.get()\n\n        # Stop thread when (None, None) comes in\n        if args is None and kwargs is None:\n            return None  # Wrappers should exit as well\n\n        # Work\n        try:\n            self._results.append(self._worker(*args, **kwargs))\n            return True\n        except Exception as e:\n            self._errors.append(e)\n            return False\n        finally:\n            self._jobs.task_done()\n            with self._jobfinished:\n                self._jobfinished.notify()", "response": "Entry point for the thread."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef first(self, timeout=None):\n        while True:\n            with self._jobfinished:\n                if self._results or not self._jobs.unfinished_tasks:\n                    break\n                self._jobfinished.wait(timeout)\n        return self._results[0] if self._results else None", "response": "Wait for the first successful result to become available\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwait for all current tasks to be finished and return the results and errors.", "response": "def join(self):\n        \"\"\" Wait for all current tasks to be finished \"\"\"\n        self._jobs.join()\n        try:\n            return self._results, self._errors\n        finally:\n            self._clear()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning a command returning its output or None.", "response": "def call(exe, *argv):\n    \"\"\"\n    Run a command, returning its output, or None if it fails.\n    \"\"\"\n    exes = which(exe)\n    if not exes:\n        returnValue(None)\n    stdout, stderr, value = yield getProcessOutputAndValue(\n        exes[0], argv, env=os.environ.copy()\n    )\n    if value:\n        returnValue(None)\n    returnValue(stdout.decode('utf-8').rstrip('\\n'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef choosePinentry():\n    pinentries = []\n    if 'PINENTRY' in os.environ:\n        pinentries.append(Pinentry(os.environ['PINENTRY']))\n    else:\n        mgrd = yield call('launchctl', 'managername')\n        if mgrd == 'Aqua':\n            pinentries.extend([\n                Pinentry(\n                    '/usr/local/MacGPG2/libexec/pinentry-mac.app'\n                    '/Contents/MacOS/pinentry-mac'),\n                Pinentry('pinentry-mac'),\n            ])\n        if 'DISPLAY' in os.environ:\n            pinentries.extend([\n                Pinentry('pinentry-gnome3'),\n                Pinentry('pinentry-x11')\n            ])\n        pinentries.extend([\n            Pinentry('pinentry-curses'),\n            Pinentry('pinentry'),\n        ])\n\n    for pinentry in pinentries:\n        try:\n            pinentry.argv()\n        except (PinentryNotFound, OSError):\n            continue\n        else:\n            return pinentry\n    else:\n        return GetPassAsker()", "response": "Choose a C { pinentry } that can be used for passing to a secret."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall the given C{action} with a secret value. @return: a L{Deferred} that fires with C{action}'s result, or L{NoSecretError} if no secret can be retrieved.", "response": "def secretly(reactor, action, system=None, username=None,\n             prompt=\"Password:\"):\n    \"\"\"\n    Call the given C{action} with a secret value.\n\n    @return: a L{Deferred} that fires with C{action}'s result, or\n        L{NoSecretError} if no secret can be retrieved.\n    \"\"\"\n    if system is None:\n        system = action.__module__\n        if system == '__main__':\n            system = os.path.abspath(sys.argv[0])\n    if username is None:\n        username = getpass.getuser()\n    while True:\n        secret = keyring.get_password(system, username)\n        if secret is not None:\n            break\n        pinentry = yield choosePinentry()\n        keyring.set_password(\n            system, username,\n            (yield pinentry.askForPassword(\n                reactor, prompt, \"Enter Password\",\n                \"Password Prompt for {username}@{system}\"\n                .format(system=system, username=username)))\n        )\n    yield maybeDeferred(action, secret)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef issueCommand(self, command, *args):\n        result = Deferred()\n        self._dq.append(result)\n        self.sendLine(b\" \".join([command] + list(args)))\n        return result", "response": "Issue a given Assuan command and return a Deferred that will fire the response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the current response from the queue.", "response": "def _currentResponse(self, debugInfo):\n        \"\"\"\n        Pull the current response off the queue.\n        \"\"\"\n        bd = b''.join(self._bufferedData)\n        self._bufferedData = []\n        return AssuanResponse(bd, debugInfo)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lineReceived(self, line):\n        if line.startswith(b\"#\"): # ignore it\n            return\n        if line.startswith(b\"OK\"):\n            # if no command issued, then just 'ready'\n            if self._ready:\n                self._dq.pop(0).callback(self._currentResponse(line))\n            else:\n                self._ready = True\n        if line.startswith(b\"D \"):\n            self._bufferedData.append(line[2:].replace(b\"%0A\", b\"\\r\")\n                                      .replace(b\"%0D\", b\"\\n\")\n                                      .replace(b\"%25\", b\"%\"))\n        if line.startswith(b\"ERR\"):\n            self._dq.pop(0).errback(AssuanError(line))", "response": "Process a single line from the ATOML file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_chunks(stream, block_size=2**10):\n    while True:\n        chunk = stream.read(block_size)\n        if not chunk:\n            break\n        yield chunk", "response": "Read a block of size block_size from a byte stream."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding the compressed data from a stream in Python 3.", "response": "def _load_stream_py3(dc, chunks):\n    \"\"\"\n    Given a decompression stream and chunks, yield chunks of\n    decompressed data until the compression window ends.\n    \"\"\"\n    while not dc.eof:\n        res = dc.decompress(dc.unconsumed_tail + next(chunks))\n        yield res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nyielding a stream of compressed data.", "response": "def load_streams(chunks):\n    \"\"\"\n    Given a gzipped stream of data, yield streams of decompressed data.\n    \"\"\"\n    chunks = peekable(chunks)\n    while chunks:\n        if six.PY3:\n            dc = zlib.decompressobj(wbits=zlib.MAX_WBITS | 16)\n        else:\n            dc = zlib.decompressobj(zlib.MAX_WBITS | 16)\n        yield load_stream(dc, chunks)\n        if dc.unused_data:\n            chunks = peekable(itertools.chain((dc.unused_data,), chunks))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives data in chunks yield lines of text", "response": "def lines_from_stream(chunks):\n    \"\"\"\n    Given data in chunks, yield lines of text\n    \"\"\"\n    buf = buffer.DecodingLineBuffer()\n    for chunk in chunks:\n        buf.feed(chunk)\n        # when Python 3, yield from buf\n        for _ in buf:\n            yield _"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef session_registration(uri, session):\n    # log the URI that is used to access the Stack-In-A-Box services\n    logger.debug('Registering Stack-In-A-Box at {0} under Python Requests-Mock'\n                 .format(uri))\n    logger.debug('Session has id {0}'.format(id(session)))\n\n    # tell Stack-In-A-Box what URI to match with\n    StackInABox.update_uri(uri)\n\n    # Create a Python Requests Adapter object for handling the session\n    StackInABox.hold_onto('adapter', requests_mock.Adapter())\n    # Add the Request handler object for the URI\n    StackInABox.hold_out('adapter').add_matcher(RequestMockCallable(uri))\n\n    # Tell the session about the adapter and the URI\n    session.mount('http://{0}'.format(uri), StackInABox.hold_out('adapter'))\n    session.mount('https://{0}'.format(uri), StackInABox.hold_out('adapter'))", "response": "Requests - mock registration with a specific Session."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef requests_request(method, url, **kwargs):\n    session = local_sessions.session\n    response = session.request(method=method, url=url, **kwargs)\n    session.close()\n    return response", "response": "Requests - mock requests. request wrapper."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrequest - mock requests. post wrapper.", "response": "def requests_post(url, data=None, json=None, **kwargs):\n    \"\"\"Requests-mock requests.post wrapper.\"\"\"\n    return requests_request('post', url, data=data, json=json, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_reason_for_status(status_code):\n\n        if status_code in requests.status_codes.codes:\n            return requests.status_codes._codes[status_code][0].replace('_',\n                                                                        ' ')\n        else:\n            return 'Unknown status code - {0}'.format(status_code)", "response": "Lookup the HTTP reason text for a given status code."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef split_status(status):\n\n        # If the status is an integer, then lookup the reason text\n        if isinstance(status, int):\n            return (status, RequestMockCallable.get_reason_for_status(\n                status))\n\n        # otherwise, ensure it is a string and try to split it based on the\n        # standard HTTP status and reason text format\n        elif isinstance(status, str) or isinstance(status, bytes):\n            code, reason = status.split(' ', 1)\n            return (code, reason)\n\n        # otherwise, return with a default reason code\n        else:\n            return (status, 'Unknown')", "response": "Split a status string into a tuple containing the status code and reason text"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrequesting handler interface. :param request: Python requests Request object :param uri: URI of the request", "response": "def handle(self, request, uri):\n        \"\"\"Request handler interface.\n\n        :param request: Python requests Request object\n        :param uri: URI of the request\n        \"\"\"\n\n        # Convert the call over to Stack-In-A-Box\n        method = request.method\n        headers = CaseInsensitiveDict()\n        request_headers = CaseInsensitiveDict()\n        request_headers.update(request.headers)\n        request.headers = request_headers\n        stackinabox_result = StackInABox.call_into(method,\n                                                   request,\n                                                   uri,\n                                                   headers)\n\n        # reformat the result for easier use\n        status_code, output_headers, body = stackinabox_result\n\n        json_data = None\n        text_data = None\n        content_data = None\n        body_data = None\n\n        # if the body is a string-type...\n        if isinstance(body, six.string_types):\n            # Try to convert it to JSON\n            text_data = body\n            try:\n                json_data = json.dumps(text_data)\n                text_data = json_data\n            except Exception:\n                json_data = None\n                text_data = body\n\n        # if the body is binary, then it's the content\n        elif isinstance(body, six.binary_type):\n            content_data = body\n\n        # by default, it's just body data\n        else:\n            # default to body data\n            body_data = body\n\n        # build the Python requests' Response object\n        return requests_mock.response.create_response(\n            request,\n            headers=output_headers,\n            status_code=status_code,\n            body=body_data,\n            json=json_data,\n            text=text_data,\n            content=content_data\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a request to the ChangeTip API to be delivered immediately.", "response": "def send_tip(self, sender, receiver, message, context_uid, meta):\n        \"\"\" Send a request to the ChangeTip API, to be delivered immediately. \"\"\"\n        assert self.channel is not None, \"channel must be defined\"\n\n        # Add extra data to meta\n        meta[\"mention_bot\"] = self.mention_bot()\n\n        data = json.dumps({\n            \"channel\": self.channel,\n            \"sender\": sender,\n            \"receiver\": receiver,\n            \"message\": message,\n            \"context_uid\": context_uid,\n            \"meta\": meta,\n        })\n        response = requests.post(self.get_api_url(\"/tips/\"), data=data, headers={'content-type': 'application/json'})\n        if response.headers.get(\"Content-Type\", None) == \"application/json\":\n            out = response.json()\n            out[\"state\"] = response.reason.lower()\n            return out\n        else:\n            return {\"state\": response.reason.lower(), \"error\": \"%s error submitting tip\" % response.status_code}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_mentions(self, message):\n        mentions = re.findall(re.escape(self.prefix) + '([\\w-]+)', message)\n        mentions_set = set([m.lower() for m in mentions])\n\n        deduped_mentions = []\n        for m in mentions:\n            m = m.lower()\n            if m in mentions_set:\n                mentions_set.remove(m)\n                deduped_mentions.append(m)\n\n        return deduped_mentions", "response": "Return all mentions in a case - insensitive way while preserving the original order\n            Return all mentions in lower case"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef discoverEndpoint(domain, endpoint, content=None, look_in={'name': 'link'}, test_urls=True, validateCerts=True):\n    if test_urls:\n        ronkyuu.URLValidator(message='invalid domain URL')(domain)\n\n    if content:\n        result = {'status':   requests.codes.ok,\n                  'headers':  None,\n                  'content':  content\n                  }\n    else:\n        r = requests.get(domain, verify=validateCerts)\n        result = {'status':   r.status_code,\n                  'headers':  r.headers\n                  }\n        # check for character encodings and use 'correct' data\n        if 'charset' in r.headers.get('content-type', ''):\n            result['content'] = r.text\n        else:\n            result['content'] = r.content\n\n    for key in endpoint:\n        result.update({key: set()})\n    result.update({'domain': domain})\n\n    if result['status'] == requests.codes.ok:\n        if 'link' in r.headers:\n            all_links = r.headers['link'].split(',', 1)\n            for link in all_links:\n                if ';' in link:\n                    href, rel = link.split(';')\n                    url = urlparse(href.strip()[1:-1])\n                    if url.scheme in ('http', 'https') and rel in endpoint:\n                        result[rel].add(url)\n\n        all_links = BeautifulSoup(result['content'], _html_parser, parse_only=SoupStrainer(**look_in)).find_all('link')\n        for link in all_links:\n            rel = link.get('rel', None)[0]\n            if rel in endpoint:\n                href = link.get('href', None)\n                if href:\n                    url = urlparse(href)\n                    if url.scheme == '' or url.netloc == '':\n                        url = urlparse(urljoin(domain, href))\n                    if url.scheme in ('http', 'https'):\n                        result[rel].add(url)\n    return result", "response": "Find the given endpoint for the given domain."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef discoverMicropubEndpoints(domain, content=None, look_in={'name': 'link'}, test_urls=True, validateCerts=True):\n    return discoverEndpoint(domain, ('micropub',), content, look_in, test_urls, validateCerts)", "response": "Find the micropub endpoints for the given domain."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding the token for the given domain.", "response": "def discoverTokenEndpoints(domain, content=None, look_in={'name': 'link'}, test_urls=True, validateCerts=True):\n    \"\"\"Find the token for the given domain.\n    Only scan html element matching all criteria in look_in.\n\n    optionally the content to be scanned can be given as an argument.\n\n    :param domain: the URL of the domain to handle\n    :param content: the content to be scanned for the endpoint\n    :param look_in: dictionary with name, id and class_. only element matching all of these will be scanned\n    :param test_urls: optional flag to test URLs for validation\n    :param validateCerts: optional flag to enforce HTTPS certificates if present\n    :rtype: list of endpoints\n    \"\"\"\n    return discoverEndpoint(domain, ('token_endpoint',), content, look_in, test_urls, validateCerts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the query string for the current language of the base language of the base language.", "response": "def get_query_string(request, new_params=None, remove=None):\n    \"\"\"\n    Given the request, return the query string.\n\n    Parameters can be added or removed as necessary.\n\n    Code snippet taken from Django admin app (views/main.py)\n\n    (c) Copyright Django Software Foundation and individual contributors.\n\n\n    Redistribution and use in source and binary forms, with or without modification,\n    are permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n       this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in the\n       documentation and/or other materials provided with the distribution.\n\n    3. Neither the name of Django nor the names of its contributors may be used\n       to endorse or promote products derived from this software without\n       specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    \"\"\"\n    if new_params is None: new_params = {}\n    if remove is None: remove = []\n    p = dict(request.GET.items())\n    for r in remove:\n        for k in p.keys():\n            if k.startswith(r):\n                del p[k]\n    for k, v in new_params.items():\n        if v is None:\n            if k in p:\n                del p[k]\n        else:\n            p[k] = v\n    return '?%s' % urlencode(p)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _unwrap(value, location=None):\n    if isinstance(value, Node) and location is not None:\n        raise TypeError(\n                'explicit location should only be given for bare values')\n    if isinstance(value, AtomNode):\n        return value.value, value.location\n    if isinstance(value, ListNode):\n        return value.items, value.location\n    if isinstance(value, FormNode):\n        return value.to_list(), value.location\n    if value is None or isinstance(value, (\n            bool, BinInt, BinWord, BinArray, str, Symbol, tuple)):\n        return value, location\n    if isinstance(value, list):\n        return tuple(value), location\n    if isinstance(value, int):\n        return BinInt(value), location\n    raise TypeError(\n            f'{type(value).__name__} is not representable by S-expressions.')", "response": "Unwrap a value into a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef form_node(cls):\n    assert issubclass(cls, FormNode)\n    res = attrs(init=False, slots=True)(cls)\n    res._args = []\n    res._required_args = 0\n    res._rest_arg = None\n    state = _FormArgMode.REQUIRED\n    for field in fields(res):\n        if 'arg_mode' in field.metadata:\n            if state is _FormArgMode.REST:\n                raise RuntimeError('rest argument must be last')\n            if field.metadata['arg_mode'] is _FormArgMode.REQUIRED:\n                if state is _FormArgMode.OPTIONAL:\n                    raise RuntimeError('required arg after optional arg')\n                res._args.append(field)\n                res._required_args += 1\n            elif field.metadata['arg_mode'] is _FormArgMode.OPTIONAL:\n                state = _FormArgMode.OPTIONAL\n                res._args.append(field)\n            elif field.metadata['arg_mode'] is _FormArgMode.REST:\n                state = _FormArgMode.REST\n                res._rest_arg = field\n            else:\n                assert 0\n    return res", "response": "A class decorator to finalize fully derived FormNode subclasses."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndecorating class to intercept matching methods and apply advices on them.", "response": "def intercept(aspects):\n    \"\"\"Decorate class to intercept its matching methods and apply advices on them.\n\n    Advices are the cross-cutting concerns that need to be separated out from the business logic.\n    This decorator applies such advices to the decorated class.\n\n    :arg aspects: mapping of joint-points to dictionary of advices. joint-points are regex\n    patterns to be matched against methods of class. If the pattern matches to name of a method,\n    the advices available for the joint-point are applied to the method. Advices from all matching\n    joint-points are applied to the method. In case of conflicting advices for a joint-point,\n    joint-point exactly matching the name of the method is given preference.\n\n    Following are the identified advices:\n        before: Runs before around before\n        around_before: Runs before the method\n        after_exc: Runs when method encounters exception\n        around_after: Runs after method is successful\n        after_success: Runs after method is successful\n        after_finally: Runs after method is run successfully or unsuccessfully.\n    \"\"\"\n    if not isinstance(aspects, dict):\n        raise TypeError(\"Aspects must be a dictionary of joint-points and advices\")\n\n    def get_matching_advices(name):\n        \"\"\"Get all advices matching method name\"\"\"\n        all_advices = dict()\n        for joint_point, advices in aspects.iteritems():\n            if re.match(joint_point, name):\n                for advice, impl in advices.items():\n                    # Whole word matching regex might have \\b around.\n                    if advice in all_advices and joint_point.strip(r'\\b') != name:\n                        # Give priority to exactly matching method joint-points over wild-card\n                        # joint points.\n                        continue\n                    all_advices[advice] = impl\n        return all_advices\n\n    def apply_advices(advices):\n        \"\"\"Decorating method\"\"\"\n        def decorate(method):  # pylint: disable=C0111\n            @wraps(method)\n            def trivial(self, *arg, **kw):  # pylint: disable=C0111\n                def run_advices(advice, extra_arg=None):\n                    \"\"\"Run all the advices for the joint-point\"\"\"\n                    if advice not in advices:\n                        return\n                    advice_impl = advices[advice]\n                    if not isinstance(advice_impl, (list, tuple, set)):\n                        advice_impl = [advice_impl]\n                    for impl in advice_impl:\n                        impl(self, method, extra_arg, *arg, **kw)\n\n                run_advices('before')\n                run_advices('around_before')\n                try:\n                    if method.__self__ is None:\n                        ret = method(self, *arg, **kw)\n                    else:  # classmethods\n                        ret = method(*arg, **kw)\n                except Exception as e:  # pylint: disable=W0703\n                    run_advices('after_exc', e)\n                    ret = None\n                    raise e\n                else:\n                    run_advices('around_after', ret)\n                    run_advices('after_success', ret)\n                finally:\n                    run_advices('after_finally', ret)\n                return ret\n            return trivial\n        return decorate\n\n    def decorate_class(cls):\n        \"\"\"Decorating class\"\"\"\n        # TODO: handle staticmethods\n        for name, method in inspect.getmembers(cls, inspect.ismethod):\n            if method.__self__ is not None:\n                # TODO: handle classmethods\n                continue\n            if name not in ('__init__',) and name.startswith('__'):\n                continue\n            matching_advices = get_matching_advices(name)\n            if not matching_advices:\n                continue\n            setattr(cls, name, apply_advices(matching_advices)(method))\n        return cls\n    return decorate_class"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef freeze(environ, names, label=None):\n    diff = _get_diff(environ, label)\n    for name in names:\n        diff[name] = environ.get(name)\n    environ[_variable_name(label)] = _dumps(diff)", "response": "Flag the given names to be unfrozen at startup."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget previously frozen key - value pairs.", "response": "def _get_diff(environ, label, pop=False):\n    \"\"\"Get previously frozen key-value pairs.\n\n    :param str label: The name for the frozen environment.\n    :param bool pop: Destroy the freeze after use; only allow application once.\n    :returns: ``dict`` of frozen values.\n\n    \"\"\"\n    if pop:\n        blob = environ.pop(_variable_name(label), None)\n    else:\n        blob = environ.get(_variable_name(label))\n\n    return _loads(blob) if blob else {}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _apply_diff(environ, diff):\n    original = {}\n\n    if diff:\n        for k, v in diff.iteritems():\n\n            if v is None:\n                log.log(5, 'unset %s', k)\n            else:\n                log.log(5, '%s=\"%s\"', k, v)\n\n            original[k] = environ.get(k)\n\n            if original[k] is None:\n                log.log(1, '%s was not set', k)\n            else:\n                log.log(1, '%s was \"%s\"', k, original[k])\n\n            if v is None:\n                environ.pop(k, None)\n            else:\n                environ[k] = v\n    else:\n        log.log(5, 'nothing to apply')\n\n    return original", "response": "Apply a frozen environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unfreeze(label, pop=False, environ=None):\n\n    environ = os.environ if environ is None else environ\n    diff = _get_diff(environ, label, pop=pop)\n    original = _apply_diff(environ, diff)\n    return _refreezer(environ, diff, original)", "response": "Reset the environment to its state before it was frozen."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns current Xresources color theme", "response": "def get_current():\n    \"\"\"return current Xresources color theme\"\"\"\n    global current\n    if exists( SETTINGSFILE ):\n        f = open( SETTINGSFILE ).read()\n        current = re.findall('config[^\\s]+.+', f)[1].split('/')[-1]\n        return current\n    else:\n        return \"** Not Set **\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn list of Xresources color themes", "response": "def get_colors():\n    \"\"\"return list of  available Xresources color themes\"\"\"\n    if exists( THEMEDIR ):\n        contents = os.listdir( THEMEDIR )\n        themes = [theme for theme in contents if '.' not in theme]\n        if len(themes) > 0:\n            themes.sort()\n            return themes\n        else:\n            print \"** No themes in themedir **\"\n            print \"    run:\"\n            print \"        dotcolors (-s | --sync) <limit>\"\n            sys.exit(0)\n    else:\n        print \"** Theme directory not found **\"\n        print \"    run: \"\n        print \"        dotcolors --setup\"\n\n        sys.exit(0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef menu_pages(colors, page=1, print_keys=True, per_page=15):\n\n    c = os.system('clear')\n    length = len(colors)\n    last_page = length / per_page\n    if (last_page * per_page) < length:\n        last_page += 1\n\n    page_display = \"page (%d/%d)\" % (page, last_page)\n    start = per_page * (page - 1)\n    keys = \"\"\"\n(j/k): Next/Previous page, (J/K): Transparency Down/Up\n\n(P/p): set prefix,         (Q/q): Quit\n\nOr simply enter the number of a theme\n    \"\"\"\n\n    print '=' * 30\n    print page_display\n    print '-' * len(page_display)\n\n    for i,v in enumerate(colors[start : start + per_page]):\n        print '%2d) %s' % (i + start + 1, v)\n\n    print '=' * 30\n    print 'Current theme is: %s' % get_current()\n    print 'Transparency: %%%d' % transparency\n    print '=' * 30\n\n    if(print_keys):\n        print keys", "response": "return menu items by page from list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprompt for selection validate input return selection", "response": "def getch_selection(colors, per_page=15):\n    \"\"\"prompt for selection, validate input, return selection\"\"\"\n    global transparency, prefix, current\n    get_transparency()\n    \n    page = 1\n    length = len(colors)\n    last_page = length / per_page\n\n    if (last_page * per_page) < length:\n        last_page += 1\n\n    getch = _Getch()\n\n    valid = False\n    while valid == False:\n        menu_pages(colors, page, True, per_page)\n        sys.stdout.write(\">\")\n        char = getch()\n\n        try:\n            int(char)\n            entry = raw_input_with_default(' Selection: ', char)\n            entry = int(entry)\n            if colors[entry - 1]:\n                valid = True\n\n        except ValueError:\n            pass\n\n        if( char == 'j' ):\n            page += 1\n            if page > last_page:\n                page = last_page\n            menu_pages(colors, page, True, per_page)\n\n\n        if( char == 'k' ):\n            if(page > 1):\n                page -= 1\n            else:\n                page = 1\n            menu_pages(colors, page, True, per_page)\n\n\n        if( char.lower() == 'q' ):\n            c = os.system('clear')\n            sys.exit(0)\n\n        if( char == 'J' ):\n            if transparency > 0:\n                transparency -= 1\n            menu_pages(colors, page, True, per_page)\n\n        if( char == 'K' ):\n            if transparency < 100:\n                transparency += 1\n            menu_pages(colors, page, True, per_page)\n\n        if( char.lower() == 'p' ):\n            prefix = raw_input_with_default(' prefix: ', 'urxvt')\n            \n        if( char == '\\r' ):\n            return current\n\n    return colors[entry - 1]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nformat a theme file", "response": "def format_theme(selection):\n    \"\"\"removes any non-color related lines from theme file\"\"\"\n    global themefile\n\n    text = open(THEMEDIR + '/' + selection).read()\n    if '!dotcolors' in text[:10]:\n        themefile = text\n        return\n\n    lines = ['!dotcolors auto formatted\\n']\n    for line in text.split('\\n'):\n        lline = line.lower()\n        background = 'background' in lline\n        foreground = 'foreground' in lline\n        color = 'color' in lline\n\n        if background:\n            if 'rgb' in line:\n                # rbga: 0000/0000/0000/dddd\n                rgb = line.split(':')[2].replace(' ', '')\n                rgb = rgb_to_hex(rgb)\n                lines.append('*background:\\t%s' % rgb)\n            else:\n                lines.append('\\t#'.join(line \\\n                                        .replace(' ', '') \\\n                                        .replace('\\t', '') \\\n                                        .split('#')))\n\n        if foreground:\n            if 'rgb' in line:\n                # rbga: 0000/0000/0000/dddd\n                rgb = line.split(':')[2].replace(' ', '')\n                rgb = rgb_to_hex(rgb)\n                lines.append('*foreground:\\t%s' % rgb)\n            else:\n                lines.append('\\t#'.join(line \\\n                                        .replace(' ', '') \\\n                                        .replace('\\t', '') \\\n                                        .split('#')))\n\n        if color:\n            if lline[0] != '!':\n                lines.append('\\t#'.join(line \\\n                                        .replace(' ', '') \\\n                                        .replace('\\t', '') \\\n                                        .split('#')))\n    \n    themefile = '\\n'.join(lines) + '\\n'\n    fd, tmpfile = tempfile.mkstemp()\n    if exists( THEMEDIR + '/' + selection ):\n        old = open( THEMEDIR + '/' + selection )\n        new = os.fdopen(fd, 'w')\n        os.write(fd, themefile)\n        old.close()\n        new.close()\n        move( tmpfile, THEMEDIR + '/' + selection )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite transparency as rgba to ~. Xresources", "response": "def write_transparency(selection):\n    \"\"\"writes transparency as rgba to ~/.Xresources\"\"\"\n    global themefile, transparency, prefix\n\n    if themefile == \"\":\n        return\n\n    lines = themefile.split('\\n')\n\n    for line in lines:\n        if 'background' in line.lower():\n            try:\n                background = line.split(':')[1].replace(' ', '')\n                background = background.replace('\\t', '')\n                break\n            except:\n                msg = ('Cannot determine background color from themefile. '\n                       'Defaulting to: #000000')\n                print msg\n                background = '#000000'\n                break\n        else:\n            background = '#000000'\n\n    background = hex_to_rgb(background)\n\n    fd, tmpfile = tempfile.mkstemp()\n    if exists( XRESOURCES ):\n        old = open( XRESOURCES )\n        new = os.fdopen(fd, 'w')\n        for line in old:\n            lline = line.lower()\n\n            if 'depth' in lline:\n                continue\n\n            elif 'rgba' in lline:\n                continue\n\n            elif line == '\\n':\n                continue\n\n            else:\n                os.write(fd, line)\n\n        os.write(fd, '\\n%s.depth:\\t32' % prefix)\n        os.write(fd, '\\n%s.background:\\trgba:%s/%s\\n' %\n                 (prefix, background, decimal_to_alpha(transparency)))\n        old.close()\n        new.close()\n        move( tmpfile, XRESOURCES )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pretty_size(value):\n    exp = int(math.log(value, 1024)) if value > 0 else 0\n    unit = 'bkMGTPEZY'[exp]\n    if exp == 0:\n        return '%d%s' % (value, unit)       # value < 1024, result is always without fractions\n\n    unit_value = value / (1024.0 ** exp)    # value in the relevant units\n    places = int(math.log(unit_value, 10))  # number of digits before decimal point\n    return '%.*f%s' % (2 - places, unit_value, unit)", "response": "Convert a number of bytes into a human - readable string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _on_open(self, _):\n        nick = self._format_nick(self._nick, self._pwd)\n        data = {\"cmd\": \"join\", \"channel\": self._channel, \"nick\": nick}\n        self._send_packet(data)\n        self._thread = True\n        threading.Thread(target=self._ping).start()", "response": "Join the hack. chat channel and starts pinging."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _on_message(self, _, msg):\n        result = json.loads(msg)\n        if result[\"cmd\"] == \"chat\":\n            data = {\"type\": \"message\", \"nick\": result[\"nick\"],\n                    \"text\": result[\"text\"]}\n            if \"trip\" in result:\n                data[\"trip\"] = result[\"trip\"]\n            self._callback(self, data)\n        elif result[\"cmd\"] == \"onlineSet\":\n            self._onlineUsers += result[\"nicks\"]\n        elif result[\"cmd\"] == \"onlineAdd\":\n            self._onlineUsers.append(result[\"nick\"])\n            self._callback(self, {\"type\": \"online add\",\n                                 \"nick\": result[\"nick\"]})\n        elif result[\"cmd\"] == \"onlineRemove\":\n            self._onlineUsers.remove(result[\"nick\"])\n            self._callback(self, {\"type\": \"online remove\",\n                                 \"nick\": result[\"nick\"]})\n        elif result[\"cmd\"] == \"info\" and \" invited \" in result[\"text\"]:\n            if \"You invited \" in result[\"text\"]:\n                name = self._nick\n            else:\n                space = re.search(r\"\\s\", result[\"text\"])\n                name = result[\"text\"][:space.start()]\n            link = re.search(r\"\\?\", result[\"text\"])\n            channel = result[\"text\"][link.end():]\n            self._callback(self, {\"type\": \"invite\", \"nick\": name,\n                                 \"channel\": channel})\n        elif result[\"cmd\"] == \"info\" and \" IPs \" in result[\"text\"]:\n            data = result[\"text\"].split()\n            self._callback(self, {\"type\": \"stats\", \"IPs\": data[0],\n                                 \"channels\": data[4]})\n        elif result[\"cmd\"] == \"info\" and \"Banned \" in result[\"text\"]:\n            nick = result[\"text\"][len(\"Banned \"):]\n            self._callback(self, {\"type\": \"banned\", \"nick\": nick})\n        elif result[\"cmd\"] == \"info\" and \"Unbanned \" in result[\"text\"]:\n            ip = result[\"text\"][len(\"Unbanned \"):]\n            self._callback(self, {\"type\": \"unbanned\", \"ip\": ip})\n        elif (result[\"cmd\"] == \"info\"\n              and \"Server broadcast: \" in result[\"text\"]):\n            txt = result[\"text\"][len(\"Server broadcast: \"):]\n            self._callback(self, {\"type\": \"broadcast\", \"text\": txt})\n        elif result[\"cmd\"] == \"info\":\n            self._callback(self, {\"type\": \"list users\",\n                                 \"text\": result[\"text\"]})\n        elif result[\"cmd\"] == \"warn\":\n            data = {\"type\": \"warn\", \"warning\": result[\"text\"]}\n            if \"Could not find \" in result[\"text\"]:\n                data[\"warning\"] = \"user to ban not found\"\n                data[\"nick\"] = result[\"text\"][len(\"Could not find \"):]\n            self._callback(self, data)", "response": "Sends and receives data to the callback function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\njoin a new channel.", "response": "def join(self, new_channel, nick, pwd=None):\n        \"\"\"Joins a new channel.\n\n        Keyword arguments:\n        new_channel: <str>; the channel to connect to\n        nick: <str>; the nickname to use\n        pwd: <str>; the (optional) password to use\n        \"\"\"\n        self._send_packet({\"cmd\": \"join\", \"channel\": new_channel,\n                           \"nick\": self._format_nick(nick, pwd)})"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending documentation on the item to the callback.", "response": "def get_help(self, is_category, item):\n        \"\"\"Sends documentation on <item> to <callback>.\n\n        This can be used for programmatically accessing documentation.\n\n        Keyword arguments:\n        is_category -- <bool>; Set this to <True> if <item> is for\n                       getting documentation on a permission level and\n                       <False> if <item> is for getting documentation on\n                       a command.\n        item -- <str>; If <is_category> is <True>, this should be one of\n                       <\"core\">, <\"mod\"> or <\"admin\"> to get\n                       documentation on the commands specific to that\n                       permission level. If <is_category> is <False>,\n                       this should be the name of the command to get\n                       documentation on.\n        \"\"\"\n        data = {\"cmd\": \"help\"}\n        if is_category:\n            data[\"category\"] = item\n        else:\n            data[\"command\"] = item\n        self._send_packet(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads images to play store. The function will iterate through source_dir and upload all matching image_types found in folder herachy.", "response": "def upload(client, source_dir):\n    \"\"\"\n    Upload images to play store.\n\n    The function will iterate through source_dir and upload all matching\n    image_types found in folder herachy.\n    \"\"\"\n    print('')\n    print('upload images')\n    print('-------------')\n    base_image_folders = [\n        os.path.join(source_dir, 'images', x) for x in image_types]\n\n    for type_folder in base_image_folders:\n        if os.path.exists(type_folder):\n            image_type = os.path.basename(type_folder)\n            langfolders = filter(os.path.isdir, list_dir_abspath(type_folder))\n            for language_dir in langfolders:\n                language = os.path.basename(language_dir)\n                delete_and_upload_images(\n                    client, image_type, language, type_folder)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting and upload images with given image_type and language.", "response": "def delete_and_upload_images(client, image_type, language, base_dir):\n    \"\"\"\n    Delete and upload images with given image_type and language.\n\n    Function will stage delete and stage upload all\n    found images in matching folders.\n    \"\"\"\n    print('{0} {1}'.format(image_type, language))\n    files_in_dir = os.listdir(os.path.join(base_dir, language))\n    delete_result = client.deleteall(\n        'images', imageType=image_type, language=language)\n\n    deleted = delete_result.get('deleted', list())\n    for deleted_files in deleted:\n        print('  delete image: {0}'.format(deleted_files['id']))\n\n    for image_file in files_in_dir[:8]:\n        image_file_path = os.path.join(base_dir, language, image_file)\n        image_response = client.upload(\n            'images',\n            imageType=image_type,\n            language=language,\n            media_body=image_file_path)\n        print(\"  upload image {0} new id {1}\".format(image_file, image_response['image']['id']))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef download(client, target_dir):\n    print('download image previews')\n    print(\n        \"Warning! Downloaded images are only previews!\"\n        \"They may be to small for upload.\")\n    tree = {}\n    listings = client.list('listings')\n    languages = map(lambda listing: listing['language'], listings)\n\n    parameters = [{'imageType': image_type, 'language': language}\n                  for image_type in image_types for language in languages]\n    tree = {image_type: {language: list()\n                         for language in languages}\n            for image_type in image_types}\n\n    for params in parameters:\n        result = client.list('images', **params)\n        image_type = params['imageType']\n        language = params['language']\n        tree[image_type][language] = map(\n            lambda r: r['url'], result)\n\n    for image_type, language_map in tree.items():\n        for language, files in language_map.items():\n            if len(files) > 0:\n                mkdir_p(\n                    os.path.join(target_dir, 'images', image_type, language))\n            if image_type in single_image_types:\n                if len(files) > 0:\n                    image_url = files[0]\n                    path = os.path.join(\n                        target_dir,\n                        'images',\n                        image_type,\n                        language,\n                        image_type)\n                    load_and_save_image(image_url, path)\n            else:\n                for idx, image_url in enumerate(files):\n                    path = os.path.join(\n                        target_dir,\n                        'images',\n                        image_type,\n                        language,\n                        image_type + '_' + str(idx))\n                    load_and_save_image(image_url, path)", "response": "Download images from play store into folder herachy."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndownloads image from given url and saves it to destination.", "response": "def load_and_save_image(url, destination):\n    \"\"\"Download image from given url and saves it to destination.\"\"\"\n    from urllib2 import Request, urlopen, URLError, HTTPError\n    # create the url and the request\n    req = Request(url)\n\n    # Open the url\n    try:\n        f = urlopen(req)\n        print \"downloading \" + url\n\n        # Open our local file for writing\n\n        local_file = open(destination, \"wb\")\n        # Write to our local file\n        local_file.write(f.read())\n        local_file.close()\n\n        file_type = imghdr.what(destination)\n        local_file = open(destination, \"rb\")\n        data = local_file.read()\n        local_file.close()\n\n        final_file = open(destination + '.' + file_type, \"wb\")\n        final_file.write(data)\n        final_file.close()\n        print('save image preview {0}'.format(destination + '.' + file_type))\n        os.remove(destination)\n\n    # handle errors\n    except HTTPError, e:\n        print \"HTTP Error:\", e.code, url\n    except URLError, e:\n        print \"URL Error:\", e.reason, url"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_qapp():\n    global app\n    app = QtGui.QApplication.instance()\n    if app is None:\n        app = QtGui.QApplication([], QtGui.QApplication.GuiClient)\n    return app", "response": "Returns an instance of QApplication. Creates one if neccessary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload all resources inside this package", "response": "def load_all_resources():\n    \"\"\"Load all resources inside this package\n\n    When compiling qt resources, the compiled python file will register the resource\n    on import.\n\n    .. Warning:: This will simply import all modules inside this package\n    \"\"\"\n    pkgname = resources.__name__\n    for importer, mod_name, _ in pkgutil.iter_modules(resources.__path__):\n        full_mod_name = '%s.%s' % (pkgname, mod_name)\n        if full_mod_name not in sys.modules:\n            module = importer.find_module(mod_name\n                        ).load_module(full_mod_name)\n            log.debug(\"Loaded resource from: %s\", module)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the main. qss and apply it to the application", "response": "def set_main_style(widget):\n    \"\"\"Load the main.qss and apply it to the application\n\n    :param widget: The widget to apply the stylesheet to.\n                   Can also be a QApplication. ``setStylesheet`` is called on the widget.\n    :type widget: :class:`QtGui.QWidget`\n    :returns: None\n    :rtype: None\n    :raises: None\n    \"\"\"\n    load_all_resources()\n    with open(MAIN_STYLESHEET, 'r') as qss:\n        sheet = qss.read()\n    widget.setStyleSheet(sheet)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping the given pointer with shiboken and return the appropriate class", "response": "def wrap(ptr, base=None):\n    \"\"\"Wrap the given pointer with shiboken and return the appropriate QObject\n\n    :returns: if ptr is not None returns a QObject that is cast to the appropriate class\n    :rtype: QObject | None\n    :raises: None\n    \"\"\"\n    if ptr is None:\n        return None\n    ptr = long(ptr) # Ensure type\n    if base is None:\n        qObj = shiboken.wrapInstance(long(ptr), QtCore.QObject)\n        metaObj = qObj.metaObject()\n        cls = metaObj.className()\n        superCls = metaObj.superClass().className()\n        if hasattr(QtGui, cls):\n            base = getattr(QtGui, cls)\n        elif hasattr(QtGui, superCls):\n            base = getattr(QtGui, superCls)\n        else:\n            base = QtGui.QWidget\n    return shiboken.wrapInstance(long(ptr), base)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dt_to_qdatetime(dt):\n    return QtCore.QDateTime(QtCore.QDate(dt.year, dt.month, dt.day),\n                            QtCore.QTime(dt.hour, dt.minute, dt.second))", "response": "Convert a python datetime. datetime object to a QDateTime object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_icon(name, aspix=False, asicon=False):\n    datapath = os.path.join(ICON_PATH, name)\n    icon = pkg_resources.resource_filename('jukeboxcore', datapath)\n    if aspix or asicon:\n        icon = QtGui.QPixmap(icon)\n        if asicon:\n            icon = QtGui.QIcon(icon)\n    return icon", "response": "Return the real file path to the given icon name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn all instances that inherit from JB_Gui", "response": "def allinstances(cls):\n        \"\"\"Return all instances that inherit from JB_Gui\n\n        :returns: all instances that inherit from JB_Gui\n        :rtype: list\n        :raises: None\n        \"\"\"\n        JB_Gui._allinstances = weakref.WeakSet([i for i in cls._allinstances if shiboken.isValid(i)])\n        return list(cls._allinstances)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning all instances of the current class", "response": "def classinstances(cls):\n        \"\"\"Return all instances of the current class\n\n        JB_Gui will not return the instances of subclasses\n        A subclass will only return the instances that have the same\n        type as the subclass. So it won\\'t return instances of further subclasses.\n\n        :returns: all instnaces of the current class\n        :rtype: list\n        :raises: None\n        \"\"\"\n        l = [i for i in cls.allinstances() if type(i) == cls]\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning all instances of this class and subclasses", "response": "def instances(cls):\n        \"\"\"Return all instances of this class and subclasses\n\n        :returns: all instances of the current class and subclasses\n        :rtype: list\n        :raises: None\n        \"\"\"\n        l = [i for i in cls.allinstances() if isinstance(i, cls)]\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the value for the parameter param_name.", "response": "def validate(self, value, param_name, exc=None, logger=None):\n        \"\"\"\n        :param value: value to validate\n        :param param_name: name of the value (for logging purpose)\n        :param exc: exception to raise (default is \"ValidatorError\")\n        :param logger: logger to use (default will be \"Validator.logger\")\n        \"\"\"\n        if exc is not None:\n            self.exc = exc\n\n        if logger is not None:\n            self.logger = logger\n\n        if self.type is not None and not type(value) == self.type:  # pylint: disable=unidiomatic-typecheck\n            self.error(\n                f'invalid type for parameter \"{param_name}\": {type(value)} (value: {value}) -- expected {self.type}'\n            )\n\n        if self.instance is not None and not isinstance(value, self.instance):\n            self.error(\n                f'invalid instance for parameter \"{param_name}\": {type(value)} (value: {value})'\n                f' -- expected {self.instance}'\n            )\n\n        if self.min is not None and value < self.min:\n            self.error(f'invalid value for parameter \"{param_name}\" (under minima of {self.min}): {value}')\n\n        if self.max is not None and value > self.max:\n            self.error(f'invalid value for parameter \"{param_name}\" (over maxima if {self.max}): {value}')\n\n        if self.regex is not None and not re_full_match(self.regex, value):\n            self.error(f'invalid value for parameter \"{param_name}\" (should match: \"{self.regex}\"): {value}')\n\n        if self.in_list is not None and value not in self.in_list:\n            self.error(f'invalid value for parameter \"{param_name}\"; \"{value}\" is not in list: {self.in_list}')\n\n        if self.path_exists and not exists(value):\n            self.error(f'\"{param_name}\" file does not exist: {value}')\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\noutputs error message on own logger. Raises exception if need be.", "response": "def error(self, error_msg):\n        \"\"\"\n        Outputs error message on own logger. Also raises exceptions if need be.\n\n        Args:\n            error_msg: message to output\n\n        \"\"\"\n        if self.logger is not None:\n            self.logger.error(error_msg)\n\n        if self.exc is not None:\n            raise self.exc(error_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef minimize_algorithm_1dim_golden(function, a, b, c, tolerance=DOUBLE_TOL):\n    '''\n    Given a function f, and given a bracketing triplet of abscissas ax, bx, cx\n    (such that bx is between ax and cx, and f(bx) is less than both f(ax) and f(cx)),\n    this routine performs a golden section search for the minimum, isolating it to\n    a fractional precision of about tol. The abscissa of the minimum is returned as xmin,\n    and the minimum function value is returned as Golden, the returned function value.\n    See Press, et al. (1992) \"Numerical recipes in C\", 2nd ed., p.401.\n    '''\n\n    x0 = a\n    x3 = c\n    if abs(c - b) > abs(b - a):\n        x1 = b\n        x2 = b + c * (c - b)\n    else:\n        x2 = b\n        x1 = b - c * (b - a)\n    f1 = function(x1)\n    f2 = function(x2)\n    counter = 0\n    while abs(x3 - x0) - tolerance * (abs(x1) + abs(x2)) > DOUBLE_TOL:\n        \"\"\"print(\"------\")\n        print(\"x0 = \" + str(x0))\n        print(\"x1 = \" + str(x1))\n        print(\"x2 = \" + str(x2))\n        print(\"x3 = \" + str(x3))\n        print(\"f1 = \" + str(f1))\n        print(\"f2 = \" + str(f2))\n        print(\"tolerance * (abs(x1) + abs(x2) = \" + str(tolerance * (abs(x1) + abs(x2))))\n        print(\"abs(x3 - x0) = \" + str(abs(x3 - x0)))\"\"\"\n\n        if f2 < f1:\n            x0 = x1\n            x1 = x2\n            x2 = R * x1 + C * x3\n            f1 = f2\n            f2 = function(x2)\n        else:\n            x3 = x2\n            x2 = x1\n            x1 = R * x2 + C * x0\n            f2 = f1\n            f1 = function(x1)\n        counter = counter + 1\n        if counter > 10000:\n            raise Exception(\"More than 10000 iterations.\")\n    if f1 < f2:\n        return (x1, f1)\n    else:\n        return (x2, f2)", "response": "This routine is used to minimize a 1 - dim golden algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_term_by_name(self, name):\n        term = None\n        func_name = 'get_term_by_name'\n        try:\n            term = self.terms[self._name2id[name]]\n        except KeyError:\n            try:\n                term = self.terms[self._syn2id[name]]\n            except KeyError:\n                pass\n            else:\n                logger.warning(\n                    '%s: GO term name \"%s\" is a synonym for \"%s\".',\n                    func_name, name, term.name)\n\n        if term is None:\n            raise ValueError('%s : GO term name \"%s\" not found!'\n                             % (func_name, name))\n\n        return term", "response": "Get the GO term with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clear_data(self):\n        self.clear_annotation_data()\n        self.terms = {}\n        self._alt_id = {}\n        self._syn2id = {}\n        self._name2id = {}\n        self._flattened = False", "response": "Clear all data associated with the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nclears the annotation data for this object.", "response": "def clear_annotation_data(self):\n        \"\"\"Clear annotation data.\n\n        Parameters\n        ----------\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.genes = set()\n        self.annotations = []\n        self.term_annotations = {}\n        self.gene_annotations = {}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses an OBO file and store information about the GO terms and structures.", "response": "def parse_ontology(self, fn, flatten=True, part_of_cc_only=False):\n        \"\"\" Parse an OBO file and store GO term information.\n\n        This function needs to be called before `parse_annotations`, in order\n        to read in the Gene Ontology terms and structure.\n\n        Parameters\n        ----------\n        fn: str\n            Path of the OBO file.\n        flatten: bool, optional\n            If set to False, do not generate a list of all ancestors and\n            descendants for each GO term. Warning: Without flattining,\n            GOparser cannot propagate GO annotations properly.\n        part_of_cc_only: bool, optional\n            Legacy parameter for backwards compatibility. If set to True,\n            ignore ``part_of`` relations outside the ``celluclar_component``\n            domain.\n\n        Notes\n        -----\n        The function erases all previously parsed data.\n        The function requires the OBO file to end with a line break.\n        \"\"\"\n        self.clear_data()  # clear all old data\n\n        with open(fn) as fh:\n            n = 0\n            while True:\n                try:\n                    nextline = next(fh)\n                except StopIteration:\n                    break\n                if nextline == '[Term]\\n':\n                    n += 1\n                    id_ = next(fh)[4:-1]\n                    # acc = get_acc(id_)\n                    name = next(fh)[6:-1]\n                    self._name2id[name] = id_\n                    domain = next(fh)[11:-1]\n                    def_ = None\n                    is_a = set()\n                    part_of = set()\n                    l = next(fh)\n                    while l != '\\n':\n                        if l.startswith('alt_id:'):\n                            self._alt_id[l[8:-1]] = id_\n                        elif l.startswith('def: '):\n                            idx = l[6:].index('\"')\n                            def_ = l[6:(idx+6)]\n                        elif l.startswith('is_a:'):\n                            is_a.add(l[6:16])\n                        elif l.startswith('synonym:'):\n                            idx = l[10:].index('\"')\n                            if l[(10+idx+2):].startswith(\"EXACT\"):\n                                s = l[10:(10+idx)]\n                                self._syn2id[s] = id_\n                        elif l.startswith('relationship: part_of'):\n                            if part_of_cc_only:\n                                if domain == 'cellular_component':\n                                    part_of.add(l[22:32])\n                            else:\n                                part_of.add(l[22:32])\n                        l = next(fh)\n                    assert def_ is not None\n                    self.terms[id_] = GOTerm(id_, name, domain,\n                                             def_, is_a, part_of)\n\n        logger.info('Parsed %d GO term definitions.', n)\n\n        # store children and parts\n        logger.info('Adding child and part relationships...')\n        for id_, term in self.terms.items():\n            for parent in term.is_a:\n                self.terms[parent].children.add(id_)\n            for whole in term.part_of:\n                self.terms[whole].parts.add(id_)\n\n        if flatten:\n            logger.info('Flattening ancestors...')\n            self._flatten_ancestors()\n            logger.info('Flattening descendants...')\n            self._flatten_descendants()\n            self._flattened = True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _flatten_ancestors(self, include_part_of=True):\n\n        def get_all_ancestors(term):\n            ancestors = set()\n            for id_ in term.is_a:\n                ancestors.add(id_)\n                ancestors.update(get_all_ancestors(self.terms[id_]))\n            if include_part_of:\n                for id_ in term.part_of:\n                    ancestors.add(id_)\n                    ancestors.update(get_all_ancestors(self.terms[id_]))\n            return ancestors\n\n        for term in self.terms.values():\n            term.ancestors = get_all_ancestors(term)", "response": "Determines and stores all ancestors of each GO term."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a GO annotation file and return a dict of the annotations.", "response": "def parse_annotations(\n            self, annotation_file, genes, db_sel='UniProtKB',\n            select_evidence=None, exclude_evidence=None,\n            exclude_ref=None, strip_species=False, ignore_case=False):\n        \"\"\"Parse a GO annotation file (in GAF 2.0 format).\n\n        GO annotation files can be downloaded from the\n        `UniProt-GOA download site`__ or from their `FTP server`__.\n\n        __ goa_download_\n        __ goa_ftp_\n\n        .. _goa_download: http://www.ebi.ac.uk/GOA/downloads\n        .. _goa_ftp: ftp://ftp.ebi.ac.uk/pub/databases/GO/goa/\n\n        Parameters\n        ----------\n        annotation_file: str\n            Path of the annotation file (in GAF 2.0 format).\n        genes: List (tuple, set) of str\n            List of valid gene names.\n        db_sel: str, optional\n            Select only annotations with this ``DB`` (column 1) value.\n            If empty, disable filtering based on the ``DB`` value.\n        select_evidence: list of str, optional\n            Only include annotations with the given evidence codes.\n            It not specified, allow all evidence codes, except for those listed\n            in ``exclude_evidence``.\n        exclude_evidence: list of str, optional\n            Exclude all annotations with any of the given evidence codes.\n            If ``select_evidence`` is specified, this parameter is ignored.\n            If not specified, allow all evidence codes.\n        exclude_ref: list of str, optional\n            Exclude all annotations with the given DB:reference (column 6).\n            Example: ``[\"PMID:2676709\"]``. Note: This filter is currently\n            ignored if an annotation has more than one reference.\n        strip_species: bool, optional\n            Undocumented.\n        ignore_case: bool, optional\n            Undocumented.\n\n        Returns\n        -------\n        None\n        \"\"\"\n\n        assert isinstance(annotation_file, str)\n        assert isinstance(genes, (list, tuple))\n\n        if not self.terms:\n            raise ValueError('You need to first parse an OBO file!')\n\n        if select_evidence is None:\n            select_evidence = []\n\n        if exclude_evidence is None:\n            exclude_evidence = []\n\n        if exclude_ref is None:\n            exclude_ref = []\n\n        # always overwrite all previously parsed annotations\n        self.clear_annotation_data()\n\n        # store genes\n        self.genes = set(genes)  # store the list of genes for later use\n        genes_upper = dict((g.upper(), g) for g in genes)\n        logger.info('Read %d genes.', len(genes))\n\n        # read annotations\n        self.term_annotations = dict((id_, []) for id_ in self.terms)\n        self.gene_annotations = dict((g, []) for g in self.genes)\n        # gene_terms is used for statistics\n        gene_terms = dict((g, set()) for g in self.genes)\n\n        # isoform_pattern = re.compile(r\"UniProtKB:([A-Z][0-9A-Z]{5}-\\d+)\")\n        # gene_pattern = re.compile(r\"[a-zA-Z0-9]+\\.\\d+$\")\n        # pmid_pattern = re.compile(r\"(?:PMID:\\d+|DOI:[^\\s]+)\")\n        # uniprot_pattern = re.compile(r\"UniProtKB:([A-Z][0-9A-Z]{5}(?:-\\d+)?)\")\n\n        unknown_gene_names = Counter()\n        unknown_gene_annotations = 0\n\n        unknown_term_ids = Counter()\n        unknown_term_annotations = 0\n\n        # Parsing!\n        logger.info('Parsing annotations...')\n        n = 0\n        excluded_evidence_annotations = 0\n        excluded_reference_annotations = 0\n        valid_annotations = 0\n        with misc.smart_open_read(annotation_file, mode='rb',\n                                  try_gzip=True) as fh:\n            reader = csv.reader(fh, dialect='excel-tab', encoding='UTF-8')\n            for i, l in enumerate(reader):\n                # gene = None\n\n                if not l:\n                    continue\n                if ((not db_sel) or l[0] == db_sel) and l[3] != 'NOT':\n                    n += 1\n\n                    # test if evidence code is excluded\n                    if (select_evidence and l[6] not in select_evidence) \\\n                            or l[6] in exclude_evidence:\n                        excluded_evidence_annotations += 1\n                        continue\n\n                    # test if reference is excluded\n                    db_ref = []\n                    if l[5]:\n                        db_ref = l[5].split('|')\n                        if len(db_ref) == 1 and db_ref[0] in exclude_ref:\n                            excluded_reference_annotations += 1\n                            continue\n                            \n                    # determine target gene\n                    if not l[2]:\n                        raise Exception('Missing target gene in line %d:\\n%s'\n                                        % (i+1, '\\t'.join(l)))\n\n                    gene = l[2]\n                    # db = l[0]\n                    db_id = l[1]\n                    if strip_species:\n                        try:\n                            gene = gene[:gene.rindex('_')]\n                        except ValueError:\n                            pass\n\n                    term_id = l[4]\n                    evidence = l[6]\n\n                    invalid = False\n\n                    if (ignore_case and gene.upper() not in genes_upper) \\\n                            or ((not ignore_case) and gene not in self.genes):\n                        unknown_gene_annotations += 1\n                        unknown_gene_names[l[2]] += 1\n                        invalid = True\n\n                    if term_id not in self.terms:\n                        unknown_term_annotations += 1\n                        unknown_term_ids[term_id] += 1\n                        invalid = True\n\n                    if not invalid:\n                \n                        valid_annotations += 1\n\n                        # if ignore_case, convert gene to \"original\" name\n                        if ignore_case:\n                            gene = genes_upper[gene.upper()]\n\n                        term = self.terms[term_id]\n\n                        # parse secondary information\n                        # (associated UniProt and PubMed entries)\n                        # pmid = pmid_pattern.search(l[5])\n                        # if pmid is not None: pmid = pmid.group(0)\n                        # uniprot = uniprot_pattern.search(l[7])\n                        # if uniprot is not None: uniprot = uniprot.group(1)\n                        with_ = []\n                        if l[7]:\n                            with_ = l[7].split('|')\n\n                        # generate annotation\n                        ann = GOAnnotation(\n                            gene=gene, term=term,\n                            evidence=evidence, db_id=db_id,\n                            db_ref=db_ref, with_=with_)\n\n                        # add annotation to global list\n                        self.annotations.append(ann)\n\n                        # add annotation under term ID\n                        self.term_annotations[term_id].append(ann)\n\n                        # add annotation under gene\n                        self.gene_annotations[gene].append(ann)\n                        gene_terms[gene].add(term_id)\n\n        # output some statistics\n        if n > 0:\n            logger.info('Parsed %d positive GO annotations '\n                        '(%d = %.1f%% excluded based on evidence type).',\n                        n, excluded_evidence_annotations,\n                        100*(excluded_evidence_annotations/float(n)))\n\n        if unknown_gene_annotations > 0:\n            logger.warning('Warning: %d annotations with %d unkonwn gene '\n                           'names.',\n                           unknown_gene_annotations, len(unknown_gene_names))\n\n        if unknown_term_annotations > 0:\n            logger.warning('Warning: %d annotations with %d unkonwn term IDs.',\n                           unknown_term_annotations, len(unknown_term_ids))\n\n        logger.info('Found a total of %d valid annotations.',\n                    valid_annotations)\n\n        logger.info('%d unique Gene-Term associations.',\n                    sum(len(gene_terms[g]) for g in genes))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a set of all GO terms annotated with a particular gene.", "response": "def get_gene_goterms(self, gene, ancestors=False):\n        \"\"\"Return all GO terms a particular gene is annotated with.\n\n        Parameters\n        ----------\n        gene: str\n            The gene symbol of the gene.\n        ancestors: bool, optional\n            If set to True, also return all ancestor GO terms.\n\n\n        Returns\n        -------\n        set of GOTerm objects\n            The set of GO terms the gene is annotated with.\n\n        Notes\n        -----\n        If a gene is annotated with a particular GO term, it can also be\n        considered annotated with all ancestors of that GO term.\n        \"\"\"\n        annotations = self.gene_annotations[gene]\n        terms = set(ann.term for ann in annotations)\n\n        if ancestors:\n            assert self._flattened\n            ancestor_terms = set()\n            for t in terms:\n                ancestor_terms.update(self.terms[id_] for id_ in t.ancestors)\n            terms |= ancestor_terms\n\n        return frozenset(terms)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_goterm_genes(self, id_, descendants=True):\n\n        # determine which terms to include\n        main_term = self.terms[id_]\n        check_terms = {main_term, }\n\n        if descendants:\n            assert self._flattened\n            check_terms.update([self.terms[id_]\n                                for id_ in main_term.descendants])\n\n        # get annotations of all included terms\n        genes = set()\n        for term in check_terms:\n            genes.update(ann.gene for ann in self.term_annotations[term.id])\n\n        return frozenset(genes)", "response": "Returns all genes annotated with a particular GO term."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the set of annotated genes for each GO term.", "response": "def get_gene_sets(self, min_genes=None, max_genes=None):\n        \"\"\"Return the set of annotated genes for each GO term.\n\n        Parameters\n        ----------\n        min_genes: int, optional\n            Exclude GO terms with fewer than this number of genes.\n        max_genes: int, optional\n            Exclude GO terms with more than this number of genes.\n\n        Returns\n        -------\n        GeneSetCollection\n            A gene set \"database\" with one gene set for each GO term.\n        \"\"\"\n\n        if not self.terms:\n            raise ValueError('You need to first parse both an OBO file and '\n                             'a gene association file!')\n\n        if not self.annotations:\n            raise ValueError('You need to first parse a gene association '\n                             'file!')\n\n        all_term_ids = sorted(self.terms.keys())\n\n        # go over all GO terms and get associated genes\n        logger.info('Obtaining GO term associations...')\n        # n = len(all_term_ids)\n        # term_gene_counts = []\n        # term_ids = []\n\n        term_genes = OrderedDict()\n        geneset_terms = {}\n        gene_sets = []\n        for j, id_ in enumerate(all_term_ids):\n            tg = self.get_goterm_genes(id_)\n            assert isinstance(tg, frozenset)\n            c = len(tg)\n\n            if c == 0:\n                continue\n\n            if (min_genes is not None and c < min_genes) or \\\n                    (max_genes is not None and c > max_genes):\n                # term doesn't meet min/max number of genes criteria\n                continue\n\n            # for finding redundant terms (use set of genes as key)\n            try:\n                geneset_terms[tg].append(id_)\n            except KeyError:\n                geneset_terms[tg] = [id_]\n\n            term_genes[id_] = tg\n\n        selected = len(term_genes)\n        affected = 0\n        excl = 0\n        for id_, tg in term_genes.items():\n\n            # check if there are redundant terms\n            term = self.terms[id_]\n            if len(geneset_terms[tg]) > 1:\n                gt = geneset_terms[tg]\n                affected += 1\n                # check if this term is an ancestor of any of them\n                # if so, exclude it\n                excluded = False\n                for other_id in gt:\n                    if (other_id != id_) and (other_id in term.descendants):\n                        excluded = True\n                        break\n                if excluded:\n                    excl += 1\n                    continue\n\n            # if the term is not redundant with any other term,\n            # or if it isn't the ancestor of any redundant term,\n            # add its gene set to the list\n            name = term.name\n            source = 'GO'\n            coll = term.domain_short\n            desc = term.definition\n            gs = GeneSet(id_, name, tg, source=source,\n                         collection=coll, description=desc)\n            gene_sets.append(gs)\n\n        D = GeneSetCollection(gene_sets)\n        logger.info('# terms selected intially: %d', selected)\n        logger.info('# terms with redundant gene sets: %d', affected)\n        logger.info('# terms excluded due to redundancy: %d', excl)\n        logger.info('# terms retained: %d', D.n)\n\n        return D"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading the headers of a file in file format and place them in the self. meta dictionary.", "response": "def read_meta(self, f):\n        \"\"\"Read the headers of a file in file format and place them in the\n        self.meta dictionary.\n        \"\"\"\n        if not isinstance(f, BacktrackableFile):\n            f = BacktrackableFile(f)\n\n        try:\n            (name, value) = self.read_meta_line(f)\n            while name:\n                name = (name == 'nominal_offset' and 'timestamp_rounding' or\n                        name)\n                name = (name == 'actual_offset' and 'timestamp_offset' or name)\n                method_name = 'get_{}'.format(name)\n                method = getattr(self, method_name, None)\n                if method:\n                    method(name, value)\n                name, value = self.read_meta_line(f)\n                if not name and not value:\n                    break\n        except ParsingError as e:\n            e.args = e.args + (f.line_number,)\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a M and N string.", "response": "def read_minutes_months(self, s):\n        \"\"\"Return a (minutes, months) tuple after parsing a \"M,N\" string.\n        \"\"\"\n        try:\n            (minutes, months) = [int(x.strip()) for x in s.split(',')]\n            return minutes, months\n        except Exception:\n            raise ParsingError(('Value should be \"minutes, months\"'))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nformats a value coming from the database", "response": "def format_value(column_dict, value, key=None):\n    \"\"\"\n    Format a value coming from the database (for example converts datetimes to\n    strings)\n\n    :param column_dict: The column datas collected during inspection\n    :param value: A value coming from the database\n    :param key: The exportation key\n    \"\"\"\n    formatter = column_dict.get('formatter')\n    prop = column_dict['__col__']\n\n    res = value\n\n    if value in ('', None,):\n        res = ''\n\n    elif formatter is not None:\n        res = formatter(value)\n\n    else:\n        if hasattr(prop, \"columns\"):\n            sqla_column = prop.columns[0]\n            column_type = getattr(sqla_column.type, 'impl', sqla_column.type)\n\n            formatter = FORMATTERS_REGISTRY.get_formatter(column_type, key)\n            if formatter is not None:\n                res = formatter(value)\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _is_excluded(self, prop, info_dict):\n        if prop.key in BLACKLISTED_KEYS:\n            return True\n\n        if info_dict.get('exclude', False):\n            return True\n\n        if prop.key in self.excludes:\n            return True\n\n        if self.includes and prop.key not in self.includes:\n            return True\n\n        return False", "response": "Check if the given property should be excluded from the export"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the title configured as in colanderalchemy", "response": "def _get_title(self, prop, main_infos, info_dict):\n        \"\"\"\n        Return the title configured as in colanderalchemy\n        \"\"\"\n        result = main_infos.get('label')\n        if result is None:\n            result = info_dict.get('colanderalchemy', {}).get('title')\n        if result is None:\n            result = prop.key\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the infos configured for this specific prop merging the the different configuration level", "response": "def _get_prop_infos(self, prop):\n        \"\"\"\n        Return the infos configured for this specific prop, merging the\n        different configuration level\n        \"\"\"\n        info_dict = self.get_info_field(prop)\n        main_infos = info_dict.get('export', {}).copy()\n        infos = main_infos.get(self.config_key, {})\n        main_infos['label'] = self._get_title(prop, main_infos, info_dict)\n        main_infos['name'] = prop.key\n        main_infos['key'] = prop.key\n        main_infos.update(infos)\n        main_infos['__col__'] = prop\n        return main_infos"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _collect_headers(self):\n        res = []\n\n        for prop in self.get_sorted_columns():\n\n            main_infos = self._get_prop_infos(prop)\n\n            if self._is_excluded(prop, main_infos):\n                continue\n\n            if isinstance(prop, RelationshipProperty):\n                main_infos = self._collect_relationship(main_infos, prop, res)\n\n                if not main_infos:\n                    # If still no success, we forgot this one\n                    print(\"Maybe there's missing some informations \\\nabout a relationship\")\n                    continue\n            else:\n                main_infos = self._merge_many_to_one_field_from_fkey(\n                    main_infos, prop, res\n                )\n                if not main_infos:\n                    continue\n\n            if isinstance(main_infos, (list, tuple)):\n                # In case _collect_relationship returned a list\n                res.extend(main_infos)\n            else:\n                res.append(main_infos)\n        return res", "response": "Collect headers from the models attribute info col\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncollect a relationship header for a given object.", "response": "def _collect_relationship(self, main_infos, prop, result):\n        \"\"\"\n        collect a relationship header:\n\n        * One To many : if {'export': {'reletad_key': 'remote_attr'}} is\n            provided, we take all the related objects and join their remote\n            attr's value with commas\n            If an index is provided, only the related element of index 'index'\n            is retrieved and it's attr value is returned\n            In case of excel exports, a specific sheet is generated by table\n            (see excel.py for more details)\n\n        * Many To One :\n\n            If a related_key is provided, we remove the associated foreign key\n            from the output (we collect its associated title) and only the given\n            key of the associated object will be exported\n            If no related_key is provided, we use the relationship's title as\n            prefix and for each attribute of the related object, we add a column\n\n        :param dict main_infos: The already collected datas about this column\n        :param obj prop: The property mapper of the relationship\n        :param list result: The actual collected headers\n        :returns: a dict with the datas matching this header\n        \"\"\"\n        # No handling of the uselist relationships for the moment\n        # Maybe with indexes ? ( to see: on row add, append headers on the fly\n        # if needed )\n        if prop.uselist:\n            # One to many\n            pass\n        else:\n            if \"related_key\" in main_infos:\n                self._merge_many_to_one_field(main_infos, prop, result)\n            else:\n                related_field_inspector = BaseSqlaInspector(prop.mapper)\n                main_infos_list = []\n\n                for column in related_field_inspector.get_columns_only():\n                    infos = self._get_prop_infos(column)\n                    if self._is_excluded(column, infos):\n                        continue\n\n                    infos['label'] = u\"%s %s\" % (\n                        main_infos['label'], infos['label']\n                    )\n                    infos['__col__'] = main_infos['__col__']\n                    infos['name'] = \"%s %s\" % (main_infos['name'], column.key)\n                    infos['key'] = main_infos['key']\n                    infos['related_key'] = column.key\n                    main_infos_list.append(infos)\n                return main_infos_list\n\n        return main_infos"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmerge many to one fields.", "response": "def _merge_many_to_one_field(self, main_infos, prop, result):\n        \"\"\"\n        * Find the foreignkey associated to the current relationship\n        * Get its title\n        * Remove this fkey field from the export\n\n        :param dict main_infos: The datas collected about the relationship\n        :param obj prop: The property mapper of the relationship\n        :param list result: The actual collected headers\n        :returns: a title\n        \"\"\"\n        title = None\n        # We first find the related foreignkey to get the good title\n        rel_base = list(prop.local_columns)[0]\n        related_fkey_name = rel_base.name\n        if not main_infos.get('keep_key', False):\n            for val in result:\n                if val['name'] == related_fkey_name:\n                    title = val['label']\n                    main_infos['label'] = title\n                    result.remove(val)\n                    break\n\n        return main_infos"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _merge_many_to_one_field_from_fkey(self, main_infos, prop, result):\n        if prop.columns[0].foreign_keys and prop.key.endswith('_id'):\n            # We have a foreign key, we'll try to merge it with the\n            # associated foreign key\n            rel_name = prop.key[0:-3]\n            for val in result:\n                if val[\"name\"] == rel_name:\n                    val[\"label\"] = main_infos['label']\n                    main_infos = None  # We can forget this field in export\n                    break\n        return main_infos", "response": "This method will find the relationship associated with this fkey and set the title of the column that is associated with the related fkey. If the fkey is not found None is returned."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_row(self, obj):\n        row = {}\n        for column in self.headers:\n\n            value = ''\n\n            if '__col__' in column:\n                if isinstance(column['__col__'], ColumnProperty):\n                    value = self._get_column_cell_val(obj, column)\n\n                elif isinstance(column['__col__'], RelationshipProperty):\n                    value = self._get_relationship_cell_val(obj, column)\n\n            row[column['name']] = value\n\n        self._datas.append(self.format_row(row))", "response": "fill a new row with the given obj\n               instance of the exporter s model\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_formatted_val(self, obj, name, column):\n        attr_path = name.split('.')\n        val = None\n        tmp_val = obj\n        for attr in attr_path:\n            tmp_val = getattr(tmp_val, attr, None)\n            if tmp_val is None:\n                break\n        if tmp_val is not None:\n            val = tmp_val\n\n        return format_value(column, val, self.config_key)", "response": "Get the formatted value of the attribute name from the given object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the value to insert in a relationship cell", "response": "def _get_relationship_cell_val(self, obj, column):\n        \"\"\"\n        Return the value to insert in a relationship cell\n        \"\"\"\n        val = \"\"\n        key = column['key']\n        related_key = column.get('related_key', None)\n\n        related_obj = getattr(obj, key, None)\n\n        if related_obj is None:\n            return \"\"\n\n        if column['__col__'].uselist:  # OneToMany\n            # We know how to retrieve a value from the related objects\n            if related_key is not None:\n                # Only the related object of the given index\n                if column.get('index') is not None:\n                    if len(related_obj) > column['index']:\n                        rel_obj = related_obj[column['index']]\n                        val = self._get_formatted_val(\n                            rel_obj,\n                            related_key,\n                            column,\n                        )\n                # We join all the related objects val\n                else:\n                    _vals = []\n                    for rel_obj in related_obj:\n                        _vals.append(\n                            self._get_formatted_val(\n                                rel_obj,\n                                related_key,\n                                column,\n                            )\n                        )\n                    val = '\\n'.join(_vals)\n        else:  # Many to One\n            if related_key is not None:\n                val = self._get_formatted_val(related_obj, related_key, column)\n\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a value of a column cell", "response": "def _get_column_cell_val(self, obj, column):\n        \"\"\"\n        Return a value of a \"column\" cell\n        \"\"\"\n        name = column['name']\n        return self._get_formatted_val(obj, name, column)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsorts the taskpaper files in the workspace or individual taskpaper files in the workspace", "response": "def sort(self):\n        \"\"\"\n        *sort the workspace or individual taskpaper document via the workflow tags found in the settings file*\n\n        **Usage:**\n\n            To sort all of the taskpaper documents in the workspace via the workflow tag set with the settings file, for example:\n\n            .. code-block:: yaml\n\n                workflowTags: \"@due, @flag, @hold, @next, @someday, @wait\" \n\n            use the ``sort()`` method:\n\n            .. code-block:: python \n\n                ws.sort()\n        \"\"\"\n        self.log.info('starting the ``sort`` method')\n\n        for f in self.taskpaperFiles:\n            self._sort_tp_file(f)\n\n        self.log.info('completed the ``sort`` method')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef archive_done(\n            self):\n        \"\"\"*move done tasks from the document's 'Archive' project into an adjacent markdown tasklog file*\n\n        **Usage:**\n\n            To move the archived tasks within a workspace's taskpaper docs into ``-tasklog.md`` files use the ``archive_done()`` method:\n\n            .. code-block:: python \n\n                ws.archive_done()\n        \"\"\"\n        self.log.info('starting the ``archive_done`` method')\n\n        for f in self.taskpaperFiles:\n            self._archive_tp_file_done_tasks(f)\n\n        self.log.info('completed the ``archive_done`` method')\n        return None", "response": "move done tasks from the document s Archive project into an adjacent markdown tasklog file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a list of all the taskpaper filepaths in the workspace", "response": "def _get_all_taskpaper_files(\n            self):\n        \"\"\"*get a list of all the taskpaper filepaths in the workspace*\n\n        **Return:**\n            - ``taskpaperFiles`` -- a list of paths to all the taskpaper files within the workspace\n        \"\"\"\n        self.log.info('starting the ``_get_all_taskpaper_files`` method')\n\n        if self.workspaceRoot:\n            from fundamentals.files import recursive_directory_listing\n            theseFiles = recursive_directory_listing(\n                log=self.log,\n                baseFolderPath=self.workspaceRoot,\n                whatToList=\"files\"  # all | files | dirs\n            )\n\n            taskpaperFiles = []\n            taskpaperFiles[:] = [f for f in theseFiles if os.path.splitext(f)[\n                1] == \".taskpaper\"]\n        else:\n            taskpaperFiles = [self.taskpaperPath]\n\n        self.log.info('completed the ``_get_all_taskpaper_files`` method')\n        return taskpaperFiles"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _sort_tp_file(\n            self,\n            taskpaperPath):\n        \"\"\"*sort individual taskpaper documents*\n\n        **Key Arguments:**\n            - ``taskpaperPath`` -- path to a taskpaper file\n\n        **Return:**\n            - None\n        \"\"\"\n        self.log.info('starting the ``_sort_tp_file`` method')\n\n        # OPEN TASKPAPER FILE\n\n        self.log.info(\"sorting taskpaper file %(taskpaperPath)s\" % locals())\n        doc = document(taskpaperPath)\n        doc.tidy()\n        doc.sort_tasks(self.settings[\"workflowTags\"])\n        doc.sort_projects(self.settings[\"workflowTags\"])\n        doc.save()\n\n        self.log.info('completed the ``_sort_tp_file`` method')\n        return None", "response": "sort individual taskpaper documents"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _archive_tp_file_done_tasks(\n            self,\n            taskpaperPath):\n        \"\"\"* archive tp file done tasks*\n\n        **Key Arguments:**\n            - ``taskpaperPath`` -- path to a taskpaper file\n\n        **Return:**\n            - None\n        \"\"\"\n        self.log.info('starting the ``_archive_tp_file_done_tasks`` method')\n        self.log.info(\"archiving taskpaper file %(taskpaperPath)s\" % locals())\n        taskLog = {}\n        mdArchiveFile = taskpaperPath.replace(\".taskpaper\", \"-tasklog.md\")\n        exists = os.path.exists(mdArchiveFile)\n        if exists:\n            pathToReadFile = mdArchiveFile\n            try:\n                self.log.debug(\"attempting to open the file %s\" %\n                               (pathToReadFile,))\n                readFile = codecs.open(\n                    pathToReadFile, encoding='utf-8', mode='r')\n                thisData = readFile.read()\n                readFile.close()\n            except IOError, e:\n                message = 'could not open the file %s' % (pathToReadFile,)\n                self.log.critical(message)\n                raise IOError(message)\n            readFile.close()\n            table = False\n            for l in thisData.split(\"\\n\"):\n                l = l.encode(\"utf-8\")\n                if \":---\" in l:\n                    table = True\n                    continue\n                if table == True and len(l) and l[0] == \"|\":\n                    dictt = collections.OrderedDict(sorted({}.items()))\n                    columns = l.split(\"|\")\n\n                    dictt[\"task\"] = columns[1].strip().decode(\"utf-8\")\n                    dictt[\"completed\"] = columns[2].strip().decode(\"utf-8\")\n                    dictt[\"project\"] = columns[3].strip().decode(\"utf-8\")\n                    taskLog[dictt[\"task\"] + dictt[\"completed\"] +\n                            dictt[\"project\"]] = dictt\n\n        doc = document(taskpaperPath)\n        aProject = doc.get_project(\"Archive\")\n        if not aProject:\n            return\n\n        doneTasks = aProject.tagged_tasks(\"@done\")\n\n        for task in doneTasks:\n            dateCompleted = \"\"\n            project = \"\"\n            for t in task.tags:\n                if \"done\" in t:\n                    dateCompleted = t.replace(\"done\", \"\").replace(\n                        \"(\", \"\").replace(\")\", \"\")\n                if \"project(\" in t:\n                    project = t.replace(\"project\", \"\").replace(\n                        \"(\", \"\").replace(\")\", \"\")\n\n            dictt = collections.OrderedDict(sorted({}.items()))\n\n            notes = \"\"\n            if task.notes:\n                for n in task.notes:\n                    if len(notes) and notes[-2:] != \". \":\n                        if notes[-1] == \".\":\n                            notes += \" \"\n                        else:\n                            notes += \". \"\n                    notes += n.title\n            if len(notes):\n                notes = \"<br><br>**NOTES:**<br>\" + \\\n                    \"<br>\".join(textwrap.wrap(\n                        notes, 120, break_long_words=True))\n\n            dictt[\"task\"] = \"<br>\".join(textwrap.wrap(task.title[\n                2:], 120, break_long_words=True)) + notes\n            dictt[\"task\"] = dictt[\"task\"].encode(\"utf-8\")\n            dictt[\"completed\"] = dateCompleted\n            dictt[\"project\"] = project\n\n            # SET ENCODE ERROR RETURN VALUE\n\n            # RECODE INTO ASCII\n            dictt[\"task\"] = dictt[\"task\"].decode(\"utf-8\")\n            dictt[\"completed\"] = dictt[\"completed\"].decode(\"utf-8\")\n            dictt[\"project\"] = dictt[\"project\"].decode(\"utf-8\")\n            taskLog[dictt[\"task\"] + dictt[\"completed\"] +\n                    dictt[\"project\"]] = dictt\n\n        taskLog = taskLog.values()\n\n        taskLog = sorted(taskLog, key=itemgetter('task'), reverse=True)\n        taskLog = sorted(taskLog, key=itemgetter('project'), reverse=True)\n        taskLog = sorted(taskLog, key=itemgetter('completed'), reverse=True)\n\n        dataSet = list_of_dictionaries(\n            log=self.log,\n            listOfDictionaries=taskLog\n        )\n\n        markdownData = dataSet.markdown(filepath=None)\n\n        try:\n            self.log.debug(\"attempting to open the file %s\" % (mdArchiveFile,))\n            writeFile = codecs.open(mdArchiveFile, encoding='utf-8', mode='w')\n        except IOError, e:\n            message = 'could not open the file %s' % (mdArchiveFile,)\n            self.log.critical(message)\n            raise IOError(message)\n\n        writeFile.write(markdownData.decode(\"utf-8\"))\n        writeFile.close()\n\n        aProject.delete()\n\n        doc.save()\n\n        self.log.info('completed the ``_archive_tp_file_done_tasks`` method')\n        return None", "response": "This method is used to archive the tp file done tasks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the conversions object", "response": "def get(self):\n        \"\"\"\n        *get the conversions object*\n\n        **Return:**\n            - ``conversions``\n\n        .. todo::\n\n            - @review: when complete, clean get method\n            - @review: when complete add logging\n        \"\"\"\n        self.log.info('starting the ``get`` method')\n\n        conversions = None\n\n        self.log.info('completed the ``get`` method')\n        return conversions"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a UT datetime to MJD", "response": "def ut_datetime_to_mjd(\n            self,\n            utDatetime):\n        \"\"\"*ut datetime to mjd*\n\n        If the date given has no time associated with it (e.g. ``20160426``), then the datetime assumed is ``20160426 00:00:00.0``.\n\n        Precision should be respected. \n\n        **Key Arguments:**\n            - ``utDatetime`` -- UT datetime. Can accept various formats e.g. ``201604261444``, ``20160426``, ``20160426144444.5452``, ``2016-04-26 14:44:44.234``, ``20160426 14h44m44.432s`` \n\n        **Return:**\n            - ``mjd`` -- the MJD\n\n        .. todo ::\n\n            - replace getMJDFromSqlDate in all code\n\n        **Usage:**\n\n            .. code-block:: python \n\n                from astrocalc.times import conversions\n                converter = conversions(\n                    log=log\n                )\n                mjd = converter.ut_datetime_to_mjd(utDatetime=\"20160426t1446\")\n                print mjd\n\n                # OUT: 57504.6153\n\n                mjd = converter.ut_datetime_to_mjd(utDatetime=\"2016-04-26 14:44:44.234\")\n                print mjd\n\n                # OUT: 57504.61440\n        \"\"\"\n        self.log.info('starting the ``ut_datetime_to_mjd`` method')\n\n        import time\n        import re\n        mjd = None\n\n        # TRIM WHITESPACE FROM AROUND STRING\n        utDatetime = utDatetime.strip()\n\n        # DATETIME REGEX\n        matchObject = re.match(\n            r'^(?P<year>\\d{4})\\D?(?P<month>(0\\d|1[0-2]))\\D?(?P<day>([0-2]\\d|3[0-1])(\\.\\d+)?)(\\D?(?P<hours>([0-1]\\d|2[0-3]))\\D?(?P<minutes>\\d{2})(\\D?(?P<seconds>\\d{2}(\\.\\d*?)?))?)?s?$', utDatetime)\n\n        # RETURN ERROR IF REGEX NOT MATCHED\n        if not matchObject:\n            self.log.error(\n                'UT Datetime is not in a recognised format. Input value was `%(utDatetime)s`' % locals())\n            raise IOError(\n                'UT Datetime is not in a recognised format. Input value was `%(utDatetime)s`' % locals())\n\n        year = matchObject.group(\"year\")\n        month = matchObject.group(\"month\")\n        day = matchObject.group(\"day\")\n        hours = matchObject.group(\"hours\")\n        minutes = matchObject.group(\"minutes\")\n        seconds = matchObject.group(\"seconds\")\n\n        # CLEAN NUMBERS AND SET OUTPUT PRECISION\n        if \".\" in day:\n            fhours = (float(day) - int(float(day))) * 24\n            hours = int(fhours)\n            fminutes = (fhours - hours) * 60\n            minutes = int(fminutes)\n            seconds = fhours - minutes\n            precision = len(repr(day).split(\".\")[-1])\n        elif not hours:\n            hours = \"00\"\n            minutes = \"00\"\n            seconds = \"00\"\n            precision = 1\n        elif not seconds:\n            seconds = \"00\"\n            # PRECISION TO NEAREST MIN i.e. 0.000694444 DAYS\n            precision = 4\n        else:\n            if \".\" not in seconds:\n                precision = 5\n            else:\n                decLen = len(seconds.split(\".\")[-1])\n                precision = 5 + decLen\n\n        # CONVERT VALUES TO FLOAT\n        seconds = float(seconds)\n        year = float(year)\n        month = float(month)\n        day = float(day)\n        hours = float(hours)\n        minutes = float(minutes)\n\n        # DETERMINE EXTRA TIME (SMALLER THAN A SEC)\n        extraTime = 0.\n        if \".\" in repr(seconds):\n            extraTime = float(\".\" + repr(seconds).split(\".\")\n                              [-1]) / (24. * 60. * 60.)\n\n        # CONVERT TO UNIXTIME THEN MJD\n        t = (int(year), int(month), int(day), int(hours),\n             int(minutes), int(seconds), 0, 0, 0)\n        unixtime = int(time.mktime(t))\n        mjd = (unixtime / 86400.0 - 2400000.5 + 2440587.5) + extraTime\n\n        mjd = \"%0.*f\" % (precision, mjd)\n\n        self.log.info('completed the ``ut_datetime_to_mjd`` method')\n        return mjd"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef mjd_to_ut_datetime(\n            self,\n            mjd,\n            sqlDate=False,\n            datetimeObject=False):\n        \"\"\"*mjd to ut datetime*\n\n        Precision should be respected. \n\n        **Key Arguments:**\n            - ``mjd`` -- time in MJD.\n            - ``sqlDate`` -- add a 'T' between date and time instead of space\n            - ``datetimeObject`` -- return a datetime object instead of a string. Default *False*\n\n        .. todo::\n\n            - replace getDateFromMJD in all code\n            - replace getSQLDateFromMJD in all code\n\n        **Return:**\n            - ``utDatetime`` - the UT datetime in string format\n\n        **Usage:**\n\n            .. code-block:: python \n\n                from astrocalc.times import conversions\n                converter = conversions(\n                    log=log\n                )\n                utDate = converter.mjd_to_ut_datetime(\n                    mjd=57504.61577585013\n                )\n                print utDate\n\n                # OUT: 2016-04-26 14:46:43.033\n\n                utDate = converter.mjd_to_ut_datetime(\n                    mjd=57504.61577585013,\n                    sqlDate=True\n                )\n                print utDate\n\n                # OUT: 2016-04-26T14:46:43.033\n        \"\"\"\n        self.log.info('starting the ``mjd_to_ut_datetime`` method')\n\n        from datetime import datetime\n\n        # CONVERT TO UNIXTIME\n        unixtime = (float(mjd) + 2400000.5 - 2440587.5) * 86400.0\n        theDate = datetime.utcfromtimestamp(unixtime)\n\n        if datetimeObject == False:\n            # DETERMINE PRECISION\n            strmjd = repr(mjd)\n            if \".\" not in strmjd:\n                precisionUnit = \"day\"\n                precision = 0\n                utDatetime = theDate.strftime(\"%Y-%m-%d\")\n            else:\n                lenDec = len(strmjd.split(\".\")[-1])\n                if lenDec < 2:\n                    precisionUnit = \"day\"\n                    precision = 0\n                    utDatetime = theDate.strftime(\"%Y-%m-%d\")\n                elif lenDec < 3:\n                    precisionUnit = \"hour\"\n                    precision = 0\n                    utDatetime = theDate.strftime(\"%Y-%m-%d\")\n                elif lenDec < 5:\n                    precisionUnit = \"minute\"\n                    precision = 0\n                    utDatetime = theDate.strftime(\"%Y-%m-%d %H:%M\")\n                else:\n                    precisionUnit = \"second\"\n                    precision = lenDec - 5\n                    if precision > 3:\n                        precision = 3\n                    secs = float(theDate.strftime(\"%S.%f\"))\n                    secs = \"%02.*f\" % (precision, secs)\n                    utDatetime = theDate.strftime(\"%Y-%m-%d %H:%M:\") + secs\n\n            if sqlDate:\n                utDatetime = utDatetime.replace(\" \", \"T\")\n        else:\n            utDatetime = theDate\n\n        self.log.info('completed the ``mjd_to_ut_datetime`` method')\n        return utDatetime", "response": "This method converts a MJD to a UT datetime."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef join(input_files, output_file):\n    '''\n    Join geojsons into one. The spatial reference system of the output file is the same\n        as the one of the last file in the list.\n\n    Args:\n        input_files (list): List of file name strings.\n        output_file (str): Output file name.\n    '''\n\n    # get feature collections\n    final_features = []\n    for file in input_files:\n        with open(file) as f:\n            feat_collection = geojson.load(f)\n            final_features += feat_collection['features']\n\n    feat_collection['features'] = final_features\n\n    # write to output file\n    with open(output_file, 'w') as f:\n        geojson.dump(feat_collection, f)", "response": "Join geojsons into one."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsplits a geojson in two separate files.", "response": "def split(input_file, file_1, file_2, no_in_first_file):\n    '''\n    Split a geojson in two separate files.\n\n    Args:\n        input_file (str): Input filename.\n        file_1 (str): Output file name 1.\n        file_2 (str): Output file name 2.\n        no_features (int): Number of features in input_file to go to file_1.\n        output_file (str): Output file name.\n    '''\n\n    # get feature collection\n    with open(input_file) as f:\n        feat_collection = geojson.load(f)\n\n    features = feat_collection['features']\n    feat_collection_1 = geojson.FeatureCollection(features[0:no_in_first_file])\n    feat_collection_2 = geojson.FeatureCollection(features[no_in_first_file:])\n\n    with open(file_1, 'w') as f:\n        geojson.dump(feat_collection_1, f)\n\n    with open(file_2, 'w') as f:\n        geojson.dump(feat_collection_2, f)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_from(input_file, property_names):\n    '''\n    Reads a geojson and returns a list of value tuples, each value corresponding to a\n        property in property_names.\n\n    Args:\n        input_file (str): File name.\n        property_names: List of strings; each string is a property name.\n\n    Returns:\n        List of value tuples.\n    '''\n\n    # get feature collections\n    with open(input_file) as f:\n        feature_collection = geojson.load(f)\n\n    features = feature_collection['features']\n    values = [tuple([feat['properties'].get(x)\n                     for x in property_names]) for feat in features]\n\n    return values", "response": "Reads a geojson and returns a list of value tuples each value corresponding to a\n        property in property_names."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites property data to polygon_file for all geometries indicated in the filter and creates output file.", "response": "def write_properties_to(data, property_names, input_file, output_file, filter=None):\n    '''\n    Writes property data to polygon_file for all geometries indicated in the filter, and\n        creates output file. The length of data must be equal to the number of geometries\n        in the filter. Existing property values are overwritten.\n\n    Args\n        data (list): List of tuples. Each entry is a tuple of dimension equal to\n            property_names.\n        property_names (list): Property names.\n        input_file (str): Input file name.\n        output_file (str): Output file name.\n        filter (dict): Filter format is {'property_name':[value1,value2,...]}.What this\n            achieves is to write the first entry of data to the properties of the feature\n            with 'property_name'=value1, and so on. This makes sense only if these values\n            are unique. If Filter=None, then data is written to all geometries in the\n            input file.\n    '''\n\n    with open(input_file) as f:\n        feature_collection = geojson.load(f)\n\n    features = feature_collection['features']\n\n    if filter is None:\n        for i, feature in enumerate(features):\n            for j, property_value in enumerate(data[i]):\n                feature['properties'][property_names[j]] = property_value\n    else:\n        filter_name = filter.keys()[0]\n        filter_values = np.array(filter.values()[0])\n        for feature in features:\n            compare_value = feature['properties'][filter_name]\n            ind = np.where(filter_values == compare_value)[0]\n            if len(ind) > 0:\n                for j, property_value in enumerate(data[ind]):\n                    feature['properties'][property_names[j]] = property_value\n\n    feature_collection['features'] = features\n\n    with open(output_file, 'w') as f:\n        geojson.dump(feature_collection, f)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_unique_values(input_file, property_name):\n    '''\n    Find unique values of a given property in a geojson file.\n\n    Args\n        input_file (str): File name.\n        property_name (str): Property name.\n    Returns\n        List of distinct values of property. If property does not exist, it returns None.\n    '''\n\n    with open(input_file) as f:\n        feature_collection = geojson.load(f)\n\n    features = feature_collection['features']\n    values = np.array([feat['properties'].get(property_name)\n                       for feat in features])\n    return np.unique(values)", "response": "Find unique values of a given property in a geojson file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfiltering the features in a file by a property value.", "response": "def filter_by_property(input_file, output_file, property_name, values):\n    '''\n    Create a file containing only features with specified property value(s) from\n        input_file.\n\n    Args\n        input_file (str): File name.\n        output_file (str): Output file name.\n        property_name (str): Name of the feature property to filter by.\n        values (list): Value(s) a feature may have for property_name if it is to be\n            included in output_file.\n    '''\n\n    filtered_feats = []\n    if not output_file.endswith('.geojson'):\n        output_file += '.geojson'\n\n    # Load feature list\n    with open(input_file) as f:\n        feature_collection = geojson.load(f)\n\n    # Filter feats by property_name\n    for feat in feature_collection['features']:\n        if feat['properties'][property_name] in values:\n            filtered_feats.append(feat)\n\n    feature_collection['features'] = filtered_feats\n\n    # Save filtered file\n    with open(output_file, 'wb') as f:\n        geojson.dump(f)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_balanced_geojson(input_file, classes, output_file='balanced.geojson',\n                            samples_per_class=None):\n    '''\n    Create a geojson comprised of balanced classes from the class_name property in\n        input_file. Randomly selects polygons from all classes.\n\n    Args:\n        input_file (str): File name\n        classes (list[str]): Classes in input_file to include in the balanced output file.\n            Must exactly match the 'class_name' property in the features of input_file.\n        output_file (str): Name under which to save the balanced output file. Defualts to\n            balanced.geojson.\n        samples_per_class (int or None): Number of features to select per class in\n            input_file. If None will use the smallest class size. Defaults to None.\n    '''\n\n    if not output_file.endswith('.geojson'):\n        output_file += '.geojson'\n\n    with open(input_file) as f:\n        data = geojson.load(f)\n\n    # Sort classes in separate lists\n    sorted_classes = {clss : [] for clss in classes}\n\n    for feat in data['features']:\n        try:\n            sorted_classes[feat['properties']['class_name']].append(feat)\n        except (KeyError):\n            continue\n\n    # Determine sample size per class\n    if not samples_per_class:\n        smallest_class = min(sorted_classes, key=lambda clss: len(sorted_classes[clss]))\n        samples_per_class = len(sorted_classes[smallest_class])\n\n    # Randomly select features from each class\n    try:\n        samps = [random.sample(feats, samples_per_class) for feats in sorted_classes.values()]\n        final = [feat for sample in samps for feat in sample]\n    except (ValueError):\n        raise Exception('Insufficient features in at least one class. Set ' \\\n                            'samples_per_class to None to use maximum amount of '\\\n                            'features.')\n\n    # Shuffle and save balanced data\n    np.random.shuffle(final)\n    data['features'] = final\n\n    with open(output_file, 'wb') as f:\n        geojson.dump(data, f)", "response": "Create a geojson comprised of balanced classes from the class_name property in input_file. Randomly selects polygons from all classes and saves the resulting balanced file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef launch(self, args, unknown):\n        pm = plugins.PluginManager.get()\n        addon = pm.get_plugin(args.addon)\n        isgui = isinstance(addon, plugins.JB_StandaloneGuiPlugin)\n        if isgui:\n            gui.main.init_gui()\n        print \"Launching %s...\" % args.addon\n        addon.run()\n        if isgui:\n            app = gui.main.get_qapp()\n            sys.exit(app.exec_())", "response": "Launch something according to the provided arguments\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list(self, args, unknown):\n        pm = plugins.PluginManager.get()\n        plugs = pm.get_all_plugins()\n        if not plugs:\n            print \"No standalone addons found!\"\n            return\n        print \"Addons:\"\n        for p in plugs:\n            if isinstance(p, plugins.JB_StandalonePlugin):\n                print \"\\t%s\" % p.__class__.__name__", "response": "List all addons that can be launched by the launch parser."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_manage_parser(self, parser):\n        parser.set_defaults(func=self.manage)\n        parser.add_argument(\"args\", nargs=argparse.REMAINDER,\n                            help=\"arguments for django manage command\")", "response": "Setup the given argument parser for manage command"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute the manage command for django", "response": "def manage(self, namespace, unknown):\n        \"\"\"Execute the manage command for django\n\n        :param namespace: namespace containing args with django manage.py arguments\n        :type namespace: Namespace\n        :param unknown: list of unknown arguments that get passed to the manage.py command\n        :type unknown: list\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        # first argument is usually manage.py. This will also adapt the help messages\n        args = ['jukebox manage']\n        args.extend(namespace.args)\n        args.extend(unknown)\n        from django.core.management import execute_from_command_line\n        execute_from_command_line(args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncompiling qt designer files containing arguments from the launch parser", "response": "def compile_ui(self, namespace, unknown):\n        \"\"\"Compile qt designer files\n\n        :param namespace: namespace containing arguments from the launch parser\n        :type namespace: Namespace\n        :param unknown: list of unknown arguments\n        :type unknown: list\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        uifiles = namespace.uifile\n        for f in uifiles:\n            qtcompile.compile_ui(f.name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_compile_rcc_parser(self, parser):\n        parser.set_defaults(func=self.compile_rcc)\n        parser.add_argument('rccfile',\n                            help='the resource file to compile.\\\n                            The compiled file will be in the jukeboxcore.gui.resources package and ends with _rc.py',\n                            type=argparse.FileType('r'))", "response": "Setup the given argument parser for the compile_rcc command"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompiles qt resource files containing arguments from the launch parser", "response": "def compile_rcc(self, namespace, unknown):\n        \"\"\"Compile qt resource files\n\n        :param namespace: namespace containing arguments from the launch parser\n        :type namespace: Namespace\n        :param unknown: list of unknown arguments\n        :type unknown: list\n        :returns: None\n        :rtype: None\n        :raises: None\n        \"\"\"\n        rccfile = namespace.rccfile.name\n        qtcompile.compile_rcc(rccfile)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts value into array object.", "response": "def to_nullable_array(value):\n        \"\"\"\n        Converts value into array object.\n        Single values are converted into arrays with a single element.\n\n        :param value: the value to convert.\n\n        :return: array object or None when value is None.\n        \"\"\"\n        # Shortcuts\n        if value == None:\n            return None\n        if type(value) == list:\n            return value \n\n        if type(value) in [tuple, set]:\n            return list(value)\n            \n        return [value]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_array_with_default(value, default_value):\n        result = ArrayConverter.to_nullable_array(value)\n        return result if result != None else default_value", "response": "Converts value into array object with specified default value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_to_array(value):\n        if value == None:\n            return []\n        elif type(value) in [list, tuple, set]:\n            return list(value)\n        elif type(value) in [str]:\n            return value.split(',')\n        else:\n            return [value]", "response": "Converts value into array object with empty array as default."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_encoders(self, config=DataConfig()):\n        self.log('info', 'Initializing the encoders ...')\n\n        # create the integer encoder and fit it to our corpus' vocab\n        self.ie = LabelEncoder()\n        self.ie_vocab = self.ie.fit_transform(self.vocab_list)", "response": "Initialize the integer encoder and one - hot encoder"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vectorize_dialogue(self, dialogue, safe=True):\n        if safe:\n            return vectorize_dialogue_safe(dialogue)\n        else:\n            return vectorize_dialogue_unsafe(dialogue)", "response": "Takes in a dialogue and transform it into a sequence of indices."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef vectorize_utterance(self, utterance, safe=True):\n        if safe:\n            return self.vectorize_utterance_safe(utterance)\n        else:\n            return self.vectorize_utterance_unsafe(utterance)", "response": "Takes in a tokenized utterance and transform it into a sequence of indices."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a server socket", "response": "def get_server_sock():\n    \"Get a server socket\"\n    s = _socket.socket()\n    s.setsockopt(_socket.SOL_SOCKET, _socket.SO_REUSEADDR, True)\n    s.setblocking(False)\n    s.bind(('0.0.0.0', _config.server_listen_port))\n    s.listen(5)\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_client_sock(addr):\n    \"Get a client socket\"\n    s = _socket.create_connection(addr)\n    s.setsockopt(_socket.SOL_SOCKET, _socket.SO_REUSEADDR, True)\n    s.setblocking(False)\n    return s", "response": "Get a client socket"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_beacon():\n    \"Get a beacon socket\"\n    s = _socket.socket(_socket.AF_INET, _socket.SOCK_DGRAM)\n    s.setsockopt(_socket.SOL_SOCKET, _socket.SO_REUSEADDR, True)\n    s.setsockopt(_socket.SOL_SOCKET, _socket.SO_BROADCAST, True)\n    return s", "response": "Get a beacon socket"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef message(self):\n        ''' Override this to provide failure message'''\n        name = self.__class__.__name__\n        return \"{0} {1}\".format(humanize(name),\n                                pp(*self.expectedArgs, **self.expectedKwArgs))", "response": "Override this to provide failure message"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the options specified as argument to this command.", "response": "def options(self):\n        \"\"\" Returns the options specified as argument to this command.\n\n        \"\"\"\n        if self._option_view is None:\n            self._option_view = Option.View(self)\n        return self._option_view"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search_results_info(self):\n        if self._search_results_info is not None:\n            return self._search_results_info\n\n        try:\n            info_path = self.input_header['infoPath']\n        except KeyError:\n            return None\n\n        def convert_field(field):\n            return (field[1:] if field[0] == '_' else field).replace('.', '_')\n\n        def convert_value(field, value):\n\n            if field == 'countMap':\n                split = value.split(';')\n                value = dict((key, int(value))\n                             for key, value in zip(split[0::2], split[1::2]))\n            elif field == 'vix_families':\n                value = ElementTree.fromstring(value)\n            elif value == '':\n                value = None\n            else:\n                try:\n                    value = float(value)\n                    if value.is_integer():\n                        value = int(value)\n                except ValueError:\n                    pass\n\n            return value\n\n        with open(info_path, 'rb') as f:\n            from collections import namedtuple\n            import csv\n            reader = csv.reader(f, dialect='splunklib.searchcommands')\n            fields = [convert_field(x) for x in reader.next()]\n            values = [convert_value(f, v) for f, v in zip(fields, reader.next())]\n\n        search_results_info_type = namedtuple('SearchResultsInfo', fields)\n        self._search_results_info = search_results_info_type._make(values)\n\n        return self._search_results_info", "response": "Returns the search results info object for this command invocation or None if it does not exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef service(self):\n        if self._service is not None:\n            return self._service\n\n        info = self.search_results_info\n\n        if info is None:\n            return None\n\n        splunkd = urlsplit(info.splunkd_uri, info.splunkd_protocol, allow_fragments=False)\n\n        self._service = Service(\n            scheme=splunkd.scheme, host=splunkd.hostname, port=splunkd.port, token=info.auth_token, app=info.ppc_app)\n\n        return self._service", "response": "Returns a service object for this command invocation or None if no service object is available."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process(self, args=argv, input_file=stdin, output_file=stdout):\n        self.logger.debug(u'%s arguments: %s', type(self).__name__, args)\n        self._configuration = None\n        self._output_file = output_file\n\n        try:\n            if len(args) >= 2 and args[1] == '__GETINFO__':\n\n                ConfigurationSettings, operation, args, reader = self._prepare(args, input_file=None)\n                self.parser.parse(args, self)\n                self._configuration = ConfigurationSettings(self)\n                writer = splunk_csv.DictWriter(output_file, self, self.configuration.keys(), mv_delimiter=',')\n                writer.writerow(self.configuration.items())\n\n            elif len(args) >= 2 and args[1] == '__EXECUTE__':\n\n                self.input_header.read(input_file)\n                ConfigurationSettings, operation, args, reader = self._prepare(args, input_file)\n                self.parser.parse(args, self)\n                self._configuration = ConfigurationSettings(self)\n\n                if self.show_configuration:\n                    self.messages.append(\n                        'info_message', '%s command configuration settings: %s'\n                        % (self.name, self._configuration))\n\n                writer = splunk_csv.DictWriter(output_file, self)\n                self._execute(operation, reader, writer)\n\n            else:\n\n                file_name = path.basename(args[0])\n                message = (\n                    u'Command {0} appears to be statically configured and static '\n                    u'configuration is unsupported by splunklib.searchcommands. '\n                    u'Please ensure that default/commands.conf contains this '\n                    u'stanza:\\n'\n                    u'[{0}]\\n'\n                    u'filename = {1}\\n'\n                    u'supports_getinfo = true\\n'\n                    u'supports_rawargs = true\\n'\n                    u'outputheader = true'.format(type(self).name, file_name))\n                raise NotImplementedError(message)\n\n        except SystemExit:\n            raise\n\n        except:\n\n            import traceback\n            import sys\n\n            error_type, error_message, error_traceback = sys.exc_info()\n            self.logger.error(traceback.format_exc(error_traceback))\n\n            origin = error_traceback\n\n            while origin.tb_next is not None:\n                origin = origin.tb_next\n\n            filename = origin.tb_frame.f_code.co_filename\n            lineno = origin.tb_lineno\n\n            self.write_error('%s at \"%s\", line %d : %s', error_type.__name__, filename, lineno, error_message)\n\n            exit(1)\n\n        return", "response": "Processes the search results as specified by command arguments."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_contract_allowed(func):\n    @wraps(func)\n    def decorator(*args, **kwargs):\n        contract = kwargs.get('contract')\n        if (contract and current_user.is_authenticated()\n                and not current_user.allowed(contract)):\n            return current_app.login_manager.unauthorized()\n        return func(*args, **kwargs)\n    return decorator", "response": "Decorator to check if Contract is allowed by token\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_cups_allowed(func):\n    @wraps(func)\n    def decorator(*args, **kwargs):\n        cups = kwargs.get('cups')\n        if (cups and current_user.is_authenticated()\n                and not current_user.allowed(cups, 'cups')):\n            return current_app.login_manager.unauthorized()\n        return func(*args, **kwargs)\n    return decorator", "response": "Decorator to check if CUPS is allowed by token\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats a value to fit py3o s context", "response": "def format_py3o_val(value):\n    \"\"\"\n    format a value to fit py3o's context\n\n    * Handle linebreaks\n    \"\"\"\n    value = force_unicode(value)\n    value = escape(value)\n    value = value.replace(u'\\n', u'<text:line-break/>')\n    return Markup(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_compilation_context(instance):\n    context_builder = SqlaContext(instance.__class__)\n    py3o_context = context_builder.compile_obj(instance)\n    return py3o_context", "response": "Returns the compilation context for py3o templating"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompile a template object and return the odt file", "response": "def compile_template(instance, template, additionnal_context=None):\n    \"\"\"\n    Fill the given template with the instance's datas and return the odt file\n\n    For every instance class, common values are also inserted in the context\n    dict (and so can be used) :\n\n        * config values\n\n    :param obj instance: the instance of a model (like Userdatas, Company)\n    :param template: the template object to use\n    :param dict additionnal_context: A dict containing datas we'd like to add to\n    the py3o compilation template\n    :return: a stringIO object filled with the resulting odt's informations\n    \"\"\"\n    py3o_context = get_compilation_context(instance)\n\n    if additionnal_context is not None:\n        py3o_context.update(additionnal_context)\n\n    output_doc = StringIO()\n\n    odt_builder = Template(template, output_doc)\n    odt_builder.render(py3o_context)\n\n    return output_doc"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncollects columns information from a given model.", "response": "def collect_columns(self):\n        \"\"\"\n        Collect columns information from a given model.\n\n        a column info contains\n\n            the py3 informations\n\n                exclude\n\n                    Should the column be excluded from the current context ?\n\n                name\n\n                    the name of the key in the resulting py3o context of the\n                    column\n\n            __col__\n\n                The original column object\n\n            __prop__\n\n                In case of a relationship, the SqlaContext wrapping the given\n                object\n\n        \"\"\"\n        res = []\n        for prop in self.get_sorted_columns():\n\n            info_dict = self.get_info_field(prop)\n            export_infos = info_dict.get('export', {}).copy()\n\n            main_infos = export_infos.get(self.config_key, {}).copy()\n\n            if export_infos.get('exclude'):\n                if main_infos.get('exclude', True):\n                    continue\n\n            infos = export_infos\n            infos.update(main_infos)\n\n            # Si la cl\u00e9 name n'est pas d\u00e9finit on la met au nom de la colonne\n            # par d\u00e9faut\n            infos.setdefault('name', prop.key)\n            infos['__col__'] = prop\n            if isinstance(prop, RelationshipProperty):\n                join = str(prop.primaryjoin)\n                if join in self.rels:\n                    continue\n                else:\n                    self.rels.append(str(join))\n                    infos['__prop__'] = SqlaContext(\n                        prop.mapper,\n                        rels=self.rels[:]\n                    )\n\n            res.append(infos)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_doc(self):\n        res = {}\n        for column in self.columns:\n            if isinstance(column['__col__'], ColumnProperty):\n                key = column['name']\n                label = column['__col__'].columns[0].info.get(\n                    'colanderalchemy', {}\n                ).get('title')\n                if label is None:\n                    continue\n                res[key] = label\n\n            elif isinstance(column['__col__'], RelationshipProperty):\n                # 1- si la relation est directe (une AppOption), on override le\n                # champ avec la valeur (pour \u00e9viter des profondeurs)\n                # 2- si l'objet li\u00e9 est plus complexe, on lui fait son propre\n                # chemin\n                # 3- si la relation est uselist, on fait une liste d'\u00e9l\u00e9ment\n                # li\u00e9s qu'on place dans une cl\u00e9 \"l\" et on place l'\u00e9l\u00e9ment li\u00e9\n                # dans une cl\u00e9 portant le nom de son index\n                key = column['name']\n                label = column['__col__'].info.get(\n                    'colanderalchemy', {}\n                ).get('title')\n                if label is None:\n                    continue\n\n                if column['__col__'].uselist:\n                    subres = column['__prop__'].make_doc()\n\n                    for subkey, value in subres.items():\n                        new_key = u\"%s.first.%s\" % (key, subkey)\n                        res[new_key] = u\"%s - %s (premier \u00e9l\u00e9ment)\" % (\n                            label, value\n                        )\n                        new_key = u\"%s.last.%s\" % (key, subkey)\n                        res[new_key] = u\"%s - %s (dernier \u00e9l\u00e9ment)\" % (\n                            label, value\n                        )\n                else:\n\n                    subres = column['__prop__'].make_doc()\n                    for subkey, value in subres.items():\n                        new_key = u\"%s.%s\" % (key, subkey)\n                        res[new_key] = u\"%s - %s\" % (label, value)\n\n        print(\"------------------ Rendering the docs -------------------\")\n        keys = res.keys()\n        keys.sort()\n        for key in keys:\n            value = res[key]\n\n            print(u\"{0} : py3o.{1}\".format(value, key))\n\n        return res", "response": "Generate the doc for the current context in the form of a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gen_xml_doc(self):\n        res = self.make_doc()\n        var_tag = \"\"\"\n        <text:user-field-decl office:value-type=\"string\"\n        office:string-value=\"%s\" text:name=\"py3o.%s\"/>\"\"\"\n        text_tag = \"\"\"<text:p text:style-name=\"P1\">\n            <text:user-field-get text:name=\"py3o.%s\">%s</text:user-field-get>\n        </text:p>\n        \"\"\"\n        keys = res.keys()\n        keys.sort()\n        texts = \"\"\n        vars = \"\"\n        for key in keys:\n            value = res[key]\n            vars += var_tag % (value, key)\n            texts += text_tag % (key, value)\n        return CONTENT_TMPL % (vars, texts)", "response": "Generate the XML doc of the a\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the formatted value of the attribute of the obj with the column s description dictionnary dictionnary.", "response": "def _get_formatted_val(self, obj, attribute, column):\n        \"\"\"\n        Return the formatted value of the attribute \"attribute\" of the obj \"obj\"\n        regarding the column's description\n\n        :param obj obj: The instance we manage\n        :param str attribute: The string defining the path to access the end\n        attribute we want to manage\n        :param dict column: The column description dictionnary\n        :returns: The associated value\n        \"\"\"\n        attr_path = attribute.split('.')\n        val = None\n        tmp_val = obj\n        for attr in attr_path:\n            tmp_val = getattr(tmp_val, attr, None)\n            if tmp_val is None:\n                break\n        if tmp_val is not None:\n            val = tmp_val\n\n        value = format_value(column, val, self.config_key)\n        return format_py3o_val(value)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_column_value(self, obj, column):\n        return self._get_formatted_val(obj, column['__col__'].key, column)", "response": "Get a single cell s value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_to_many_relationship_value(self, obj, column):\n        related_key = column.get('related_key', None)\n\n        related = getattr(obj, column['__col__'].key)\n        value = {}\n        if related:\n            total = len(related)\n            for index, rel_obj in enumerate(related):\n                if related_key:\n                    compiled_res = self._get_formatted_val(\n                        rel_obj, related_key, column\n                    )\n                else:\n                    compiled_res = column['__prop__'].compile_obj(\n                        rel_obj\n                    )\n                value['item_%d' % index] = compiled_res\n                value[str(index)] = compiled_res\n                value[\"_\" + str(index)] = compiled_res\n\n                if index == 0:\n                    value['first'] = compiled_res\n\n                if index == total - 1:\n                    value['last'] = compiled_res\n\n        return value", "response": "Get the resulting datas for a One To Many relationship"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute datas produced for a many to one relationship between the object and the column description dictionnary.", "response": "def _get_to_one_relationship_value(self, obj, column):\n        \"\"\"\n        Compute datas produced for a many to one relationship\n\n        :param obj obj: The instance we manage\n        :param dict column: The column description dictionnary\n        :returns: The associated value\n        \"\"\"\n        related_key = column.get('related_key', None)\n        related = getattr(obj, column['__col__'].key)\n        if related:\n            if related_key is not None:\n                value = self._get_formatted_val(\n                    related, related_key, column\n                )\n            else:\n                value = column['__prop__'].compile_obj(related)\n        else:\n            value = \"\"\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing datas produced for a given relationship", "response": "def _get_relationship_value(self, obj, column):\n        \"\"\"\n        Compute datas produced for a given relationship\n        \"\"\"\n        if column['__col__'].uselist:\n            value = self._get_to_many_relationship_value(obj, column)\n        else:\n            value = self._get_to_one_relationship_value(obj, column)\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a context based on the given obj", "response": "def compile_obj(self, obj):\n        \"\"\"\n        generate a context based on the given obj\n\n        :param obj: an instance of the model\n        \"\"\"\n        res = {}\n        for column in self.columns:\n            if isinstance(column['__col__'], ColumnProperty):\n                value = self._get_column_value(obj, column)\n\n            elif isinstance(column['__col__'], RelationshipProperty):\n                value = self._get_relationship_value(obj, column)\n\n            res[column['name']] = value\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the call info to a file.", "response": "def write(_filename, _long, enter=True):\n    \"\"\"Write the call info to file\"\"\"\n    def method(*arg, **kw):  # pylint: disable=W0613\n        \"\"\"Reference to the advice in order to facilitate argument support.\"\"\"\n        def get_short(_fname):\n            \"\"\"Get basename of the file. If file is __init__.py, get its directory too\"\"\"\n            dir_path, short_fname = os.path.split(_fname)\n            short_fname = short_fname.replace(\".py\", \"\")\n            if short_fname == \"__init__\":\n                short_fname = \"%s.%s\" % (os.path.basename(dir_path), short_fname)\n            return short_fname\n\n        def get_long(_fname):\n            \"\"\"Get full reference to the file\"\"\"\n            try:\n                return re.findall(r'(ansible.*)\\.py', _fname)[-1].replace(os.sep, \".\")\n            except IndexError:\n                # If ansible is extending some library, ansible won't be present in the path.\n                return get_short(_fname)\n\n        meth_code = arg[1].im_func.func_code\n        fname, lineno, _name = meth_code.co_filename, meth_code.co_firstlineno, meth_code.co_name\n        marker = ENTER_MARKER\n        if not _long:\n            _fname, _rjust = get_short(fname), RJUST_SMALL\n        else:\n            _fname, _rjust = get_long(fname), RJUST_LONG\n        if not enter:\n            try:\n                meth_line_count = len(inspect.getsourcelines(meth_code)[0])\n                lineno += meth_line_count - 1\n            except Exception:  # pylint: disable=W0703\n                # TODO: Find other way to get ending line number for the method\n                # Line number same as start of method.\n                pass\n            marker = EXIT_MARKER\n        with open(_filename, \"a\") as fptr:\n            call_info = \"%s: %s:%s %s%s\\n\" % (\n                _fname.rjust(_rjust),            # filename\n                str(lineno).rjust(4),            # line number\n                (\" %s\" % DEPTH_MARKER) * COUNT,  # Depth\n                marker,                          # Method enter, exit marker\n                _name                            # Method name\n            )\n            fptr.write(call_info)\n    return method"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nentering stem as value for source.", "response": "def _addPub(self, stem, source):\n        \"\"\"Enters stem as value for source.\n        \"\"\"\n        key = re.sub(\"[^A-Za-z0-9&]+\", \" \", source).strip().upper()\n        self.sourceDict[key] = stem\n        self.bibstemWords.setdefault(stem, set()).update(\n            key.lower().split())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading a source from a file into a list of sources", "response": "def _loadTwoPartSource(self, sourceFName, sourceLines):\n        \"\"\"is a helper for _loadOneSource.\n        \"\"\"\n        lineno = 1\n        enterInConfstems = 0\n        if sourceFName.find(\"conferences\")!=-1:\n            enterInConfstems = 1\n        for ln in sourceLines:\n            lineno += 1\n            try:\n                stem, source = ln.split(\"\\t\", 1)\n                stem = stem.strip()[-9:]\n                if not source.strip():\n                    sys.stderr.write(\"sourcematchers.py: warning: skipping entry %s in file %s\\n\"%(ln.strip(),sourceFName))\n                    continue\n                self._addPub(stem, source)\n                if enterInConfstems:\n                    self.confstems[stem] = 1\n            except ValueError:\n                sys.stderr.write(\"sourcematchers.py: %s (%d): skipping source line: %s\"%(sourceFName,lineno,ln))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload one source from sourceLines into self. confstems", "response": "def _loadThreePartSource(self, sourceFName, sourceLines):\n        \"\"\"is a helper for _loadOneSource.\n        \"\"\"\n        lineno = 1\n        for ln in sourceLines:\n            lineno += 1\n            try:\n                stem, pubType, source = ln.split(\"\\t\", 2)\n                stem = stem.strip()[-9:]\n                self._addPub(stem, source)\n                if pubType==\"C\":\n                    self.confstems[stem] = 1\n            except ValueError:\n                sys.stderr.write(\"sourcematchers.py: %s (%d): skipping source line: %s\"%(sourceFName,lineno,ln))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _loadOneSource(self, sourceFName):\n        sourceLines = open(sourceFName).readlines()\n        del sourceLines[0]\n        if len(sourceLines[0].split(\"\\t\"))==2:\n            self._loadTwoPartSource(sourceFName, sourceLines)\n        elif len(sourceLines[0].split(\"\\t\"))==3:\n            self._loadThreePartSource(sourceFName, sourceLines)\n        else:\n            raise Error, \"%s does not appear to be a source authority file\"", "response": "handles one source authority file including format auto - detection."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _loadSources(self):\n        self.confstems = {}\n        self.sourceDict = newtrigdict.Trigdict()\n        for fName in self.authorityFiles:\n            self._loadOneSource(fName)\n        # We want to allow naked bibstems in references, too\n        for stem in self.sourceDict.values():\n            cleanStem = stem.replace(\".\", \"\").upper()\n            self._addPub(stem, cleanStem)", "response": "loads all source files into the trigdict and populates self. confstems with data from self. authorityFiles\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds the long description from a README file located in the same directory as this module.", "response": "def long_description():\n    \"\"\"\n    Build the long description from a README file located in the same directory\n    as this module.\n    \"\"\"\n    base_path = os.path.dirname(os.path.realpath(__file__))\n    with io.open(os.path.join(base_path, 'README.md'), encoding='utf-8') as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints build info about a job", "response": "def get_build_info(api_instance, build_id=None,\n                   keys=DEFAULT_BUILD_KEYS, wait=False):\n    \"\"\" print build info about a job \"\"\"\n    build = (api_instance.get_build(build_id) if build_id\n             else api_instance.get_last_build())\n    output = \"\"\n\n    if wait:\n        build.block_until_complete()\n\n    if 'timestamp' in keys:\n        output += str(build.get_timestamp()) + '\\n'\n\n    if 'console' in keys:\n        output += build.get_console() + '\\n'\n\n    if 'scm' in keys:\n        # https://github.com/salimfadhley/jenkinsapi/pull/250\n        # try/except while this is still occuring\n        try:\n            output += build.get_revision() + '\\n'\n        except IndexError:\n            pass\n\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _filter_names(names):\n    names = [n for n in names\n             if n not in EXCLUDE_NAMES]\n    # This is needed when building a distro from a working\n    # copy (likely a checkout) rather than a pristine export:\n    for pattern in EXCLUDE_PATTERNS:\n        names = [n for n in names\n                 if (not fnmatch.fnmatch(n, pattern))\n                 and (not n.endswith('.py'))]\n    return names", "response": "Given a list of file names return those names that should be copied."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef relative_to(base, relativee):\n    basepath = os.path.abspath(base)\n    relativee = os.path.abspath(relativee)\n    if relativee.startswith(basepath):\n        relative = relativee[len(basepath):]\n        if relative.startswith(os.sep):\n            relative = relative[1:]\n        return os.path.join(base, relative)\n    raise ValueError(\"%s is not a subpath of %s\" % (relativee, basepath))", "response": "Gets relativee relative to basepath."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_packages(dname, pkgname=None, results=None, ignore=None, parent=None):\n    parent = parent or \"\"\n    prefix = []\n    if parent:\n        prefix = [parent]\n    bname = os.path.basename(dname)\n    ignore = ignore or []\n    if bname in ignore:\n        return []\n    if results is None:\n        results = []\n    if pkgname is None:\n        pkgname = []\n    subfiles = os.listdir(dname)\n    abssubfiles = [os.path.join(dname, x) for x in subfiles]\n\n    if '__init__.py' in subfiles:\n        results.append(prefix + pkgname + [bname])\n        for subdir in filter(os.path.isdir, abssubfiles):\n            get_packages(subdir, pkgname=pkgname + [bname],\n                        results=results, ignore=ignore,\n                        parent=parent)\n    res = ['.'.join(result) for result in results]\n    return res", "response": "Get all packages which are under dname."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_data_files(dname, ignore=None, parent=None):\n    parent = parent or \".\"\n    ignore = ignore or []\n    result = []\n    for directory, subdirectories, filenames in os.walk(dname):\n        resultfiles = []\n        for exname in EXCLUDE_NAMES:\n            if exname in subdirectories:\n                subdirectories.remove(exname)\n        for ig in ignore:\n            if ig in subdirectories:\n                subdirectories.remove(ig)\n        for filename in _filter_names(filenames):\n            resultfiles.append(filename)\n        if resultfiles:\n            for filename in resultfiles:\n                file_path = os.path.join(directory, filename)\n                if parent:\n                    file_path = file_path.replace(parent + os.sep, '')\n                result.append(file_path)\n\n    return result", "response": "Get all the data files that should be included in this distutils Project."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _open(self, mode=None):\n        if mode is None:\n            mode = self.mode\n        if self.encoding is None:\n            stream = open(self.baseFilename, mode)\n        else:\n            stream = codecs.open(self.baseFilename, mode, self.encoding)\n        return stream", "response": "Open the current base file with the original mode and encoding."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nacquires thread and file locks. Re - opening log for degraded mode.", "response": "def acquire(self):\n        \"\"\" Acquire thread and file locks.  Re-opening log for 'degraded' mode.\n        \"\"\"\n        # handle thread lock\n        if Handler:\n            # under some tests Handler ends up being null due to instantiation\n            # order\n            Handler.acquire(self)\n\n        # Issue a file lock.  (This is inefficient for multiple active threads\n        # within a single process. But if you're worried about high-performance,\n        # you probably aren't using this log handler.)\n        if self.stream_lock:\n            # If stream_lock=None, then assume close() was called or something\n            # else weird and ignore all file-level locks.\n            if self.stream_lock.closed:\n                # Daemonization can close all open file descriptors, see\n                # https://bugzilla.redhat.com/show_bug.cgi?id=952929\n                # Try opening the lock file again.  Should we warn() here?!?\n                try:\n                    self._open_lockfile()\n                except Exception:\n                    self.handleError(NullLogRecord())\n                    # Don't try to open the stream lock again\n                    self.stream_lock = None\n                    return\n            lock(self.stream_lock, LOCK_EX)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrelease the log file and thread locks.", "response": "def release(self):\n        \"\"\" Release file and thread locks. If in 'degraded' mode, close the\n        stream to reduce contention until the log files can be rotated. \"\"\"\n        try:\n            if self._rotateFailed:\n                self._close()\n        except Exception:\n            self.handleError(NullLogRecord())\n        finally:\n            try:\n                if self.stream_lock and not self.stream_lock.closed:\n                    unlock(self.stream_lock)\n            except Exception:\n                self.handleError(NullLogRecord())\n            finally:\n                # release thread lock\n                if Handler:\n                    Handler.release(self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef close(self):\n        try:\n            self._close()\n            if hasattr(self.stream_lock, 'closed') and \\\n                    not self.stream_lock.closed:\n                self.stream_lock.close()\n        finally:\n            self.stream_lock = None\n            if Handler:\n                Handler.close(self)", "response": "Closes the log stream and stream_lock."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _degrade(self, degrade, msg, *args):\n        self._rotateFailed = degrade\n        del msg, args", "response": "Set degrade mode or not.  Ignore msg."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the length of the current element.", "response": "def _parse_length(self, value, font_relative, callback, *args):\n        '''Parse/calc length, converting to pixels, calls callback(length, *args)\n        when the length is first computed or changes'''\n        if value.endswith('%'):\n            frac = float(value[:-1])/100\n            if font_relative:\n                attrs = self._get_current_attributes()\n                font_size = attrs.font.get_size() / pango.SCALE\n                callback(frac*display_resolution*font_size, *args)\n            else:\n                ## CSS says \"Percentage values: refer to width of the closest\n                ##           block-level ancestor\"\n                ## This is difficult/impossible to implement, so we use\n                ## textview width instead; a reasonable approximation..\n                alloc = self.textview.get_allocation()\n                self.__parse_length_frac_size_allocate(self.textview, alloc,\n                                                       frac, callback, args)\n                self.textview.connect(\"size-allocate\",\n                                      self.__parse_length_frac_size_allocate,\n                                      frac, callback, args)\n\n        elif value.endswith('pt'): # points\n            callback(float(value[:-2])*display_resolution, *args)\n\n        elif value.endswith('em'): # ems, the height of the element's font\n            attrs = self._get_current_attributes()\n            font_size = attrs.font.get_size() / pango.SCALE\n            callback(float(value[:-2])*display_resolution*font_size, *args)\n\n        elif value.endswith('ex'): # x-height, ~ the height of the letter 'x'\n            ## FIXME: figure out how to calculate this correctly\n            ##        for now 'em' size is used as approximation\n            attrs = self._get_current_attributes()\n            font_size = attrs.font.get_size() / pango.SCALE\n            callback(float(value[:-2])*display_resolution*font_size, *args)\n\n        elif value.endswith('px'): # pixels\n            callback(int(value[:-2]), *args)\n\n        else:\n            warnings.warn(\"Unable to parse length value '%s'\" % value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef endpoint(f):\n\n    def check_authentication(self, **kwargs):\n        \"\"\"If the `authentication` variable is defined and not None, the\n           specified method will be run. On True the request will continue\n           otherwise it will fail with a 401 authentication error\"\"\"\n        if getattr(self, 'authentication', None) is None:\n            current_app.logger.debug(\"No authentication method\")\n            return\n\n        a = self.authentication()\n        if not hasattr(a, 'is_authenticated'):\n            current_app.logger.debug(\"No is_authenticated method\")\n            return\n\n        if not a.is_authenticated(**kwargs):\n            msg = getattr(g, 'authentication_error', 'Authentication failed')\n            current_app.logger.warning(\"Authentication failed: {}\".format(msg))\n            return self._make_response(401, msg, abort=True)\n        current_app.logger.debug(\"Authentication successful\")\n\n    def check_authorization(self):\n        \"\"\"If the `authorization` variable is defined and not None, the\n           specified method will be run. On True the request will continue\n           otherwise it will fail with a 403 authorization error\"\"\"\n        current_app.logger.info(\"Checking authentication/authorization\")\n        auth_class = getattr(self, 'authorization',\n                             getattr(self, 'authentication', None))\n        if auth_class is None:\n            current_app.logger.debug(\"No authorization class\")\n            return\n\n        a = auth_class()\n        if not hasattr(a, 'is_authorized'):\n            current_app.logger.debug(\"No is_authorized method\")\n            return\n\n        if not a.is_authorized(record=g._resource_instance):\n            current_app.logger.warning(\"Authorization failed\")\n            return self._make_response(403, \"Authorization failed\", abort=True)\n        current_app.logger.debug(\"Authorization successful\")\n\n    def validate_request(self, **kwargs):\n        \"\"\"Call the validator class and validate the request_data. This method\n           returns True or False. On False, a 400 will be returned with the\n           reasons for the validation error. On True, the operation will\n           continue.\"\"\"\n        current_app.logger.info(\n            \"Checking {} validation\".format(request.method))\n        if getattr(self, 'validation', None) is None:\n            current_app.logger.warning(\"No validation specified\")\n            return\n\n        v = self.validation()\n        method = 'validate_{}'.format(request.method.lower())\n\n        if not hasattr(v, method):\n            current_app.logger.warning(\"No validation method specified\")\n            return\n        errors = getattr(v, method)(**kwargs)\n        current_app.logger.debug(\"Validation errors: {}\".format(errors))\n\n        if errors is not None and len(errors) > 0:\n            current_app.logger.warning(\"Validation errors found\")\n            self._make_response(400, errors, abort=True)\n\n    def load_request_data(self):\n        if request.method in ['GET', 'DELETE']:\n            return\n        current_app.logger.info(\"Saving json payload in memory\")\n        # For now we assume JSON. Later in life we can make this more\n        # payload agnostic\n        try:\n            d = request.data.decode('utf-8')\n            g._rq_data = {} if d.strip() == \"\" else json.loads(d)\n        except ValueError:\n            return self._make_response(400, \"Malformed JSON in request body\",\n                                       abort=True)\n\n        if self.enforce_json_root and g._rq_data != {} and \\\n                list(g._rq_data.keys()) != [self._payload_root()]:\n            msg = \"Invalid JSON root in request body\"\n            current_app.logger.error(msg)\n            current_app.logger.debug(\n                \"Found {}, expecting {}\".format(\n                    list(g._rq_data.keys()), self._payload_root()))\n            return self._make_response(400, msg, abort=True)\n        elif self._payload_root() in list(g._rq_data.keys()):\n                current_app.logger.debug(\"Removing JSON root from rq payload\")\n                g._rq_data = g._rq_data[self._payload_root()]\n        current_app.logger.debug(\"g._rq_data: {}\".format(g._rq_data))\n        return g._rq_data\n\n    @wraps(f)\n    def decorator(self, *args, **kwargs):\n        current_app.logger.info(\"Got {} request\".format(request.method))\n        current_app.logger.info(\"Endpoint: {}\".format(request.url))\n        if request.method not in self.allowed_methods:\n            msg = \"Request method {} is unavailable\".format(request.method)\n            current_app.logger.error(msg)\n            return self._make_response(405, msg, abort=True)\n\n        current_app.logger.info(\"Checking db table/collection is defined\")\n        if self.enforce_payload_collection and self.db_collection is None:\n            msg = \"No DB collection defined\"\n            current_app.logger.error(msg)\n            return make_response(Response(msg, 424))\n\n        if request.method in ['POST', 'PUT', 'PATCH']:\n            load_request_data(self)\n\n        check_authentication(self, **kwargs)\n        if kwargs.get('obj_id', False):\n            kwargs['obj_id'] = self.fiddle_id(kwargs['obj_id'])\n            self._get_instance(**kwargs)\n        else:\n            g._resource_instance = {}\n\n        if request.method in ['POST', 'PUT', 'PATCH']:\n            check_authorization(self)\n            r = self.transform_record(g._rq_data.get(self._payload_root(),\n                                                     g._rq_data))\n            g._saveable_record = dict(self.merge_record_data(\n                r, dict(getattr(g, '_resource_instance', r))))\n            validate_request(self, data=g._saveable_record)\n        else:\n            check_authorization(self)\n            validate_request(self)\n        return f(self, *args, **kwargs)\n    return decorator", "response": "This is a decorator that marks the method as an endpoint. It will check the authentication and authorization variables and call each relevant method in turn."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a backend instance either from the argument or from the settings.", "response": "def get_backend_instance(self, backend: BackendDefinitionType) -> BaseBackend:\n        \"\"\" Returns a backend instance, either from the argument or from the settings.\n\n        :raise ArcaMisconfigured: If the instance is not a subclass of :class:`BaseBackend`\n        \"\"\"\n        if backend is NOT_SET:\n            backend = self.get_setting(\"backend\", \"arca.CurrentEnvironmentBackend\")\n\n        if isinstance(backend, str):\n            backend = load_class(backend)\n\n        if callable(backend):\n            backend = backend()\n\n        if not issubclass(type(backend), BaseBackend):\n            raise ArcaMisconfigured(f\"{type(backend)} is not an subclass of BaseBackend\")\n\n        return backend"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new cache region based on the settings.", "response": "def make_region(self) -> CacheRegion:\n        \"\"\"\n        Returns a :class:`CacheRegion <dogpile.cache.region.CacheRegion>` based on settings.\n\n        * Firstly, a backend is selected.\n          The default is :class:`NullBackend <dogpile.cache.backends.null.NullBackend`.\n        * Secondly, arguments for the backends are generated.\n          The arguments can be passed as a dict to the setting or as a json string.\n          If the arguments aren't a dict or aren't convertible to a dict, :class:`ArcaMisconfigured` is raised.\n        * Lastly, the cache is tested if it works\n\n        All errors can be suppressed by the ``ignore_cache_errors`` setting.\n\n        :raise ModuleNotFoundError: In case dogpile has trouble importing the library needed for a backend.\n        :raise ArcaMisconfigured: In case the cache is misconfigured in any way or the cache doesn't work.\n        \"\"\"\n        arguments = self.get_setting(\"cache_backend_arguments\", None)\n\n        def null_cache():\n            return make_region().configure(\n                \"dogpile.cache.null\"\n            )\n\n        if isinstance(arguments, str) and arguments:\n            try:\n                arguments = json.loads(arguments)\n            except ValueError:\n                if self.ignore_cache_errors:\n                    return null_cache()\n                raise ArcaMisconfigured(\"Cache backend arguments couldn't be converted to a dictionary.\")\n\n        cache_backend = self.get_setting(\"cache_backend\", \"dogpile.cache.null\")\n\n        if cache_backend == \"dogpile.cache.dbm\":\n            # if a file backend is used, create the folder for the file (if it doesn't exist)\n            if isinstance(arguments, dict) and \"filename\" in arguments:\n                Path(arguments[\"filename\"]).parent.mkdir(parents=True, exist_ok=True)\n\n        try:\n            region = make_region().configure(\n                cache_backend,\n                expiration_time=self.get_setting(\"cache_expiration_time\", None),\n                arguments=arguments\n            )\n            region.set(\"last_arca_run\", datetime.now().isoformat())\n        except ModuleNotFoundError:\n            if self.ignore_cache_errors:\n                return null_cache()\n            raise ModuleNotFoundError(\"Cache backend cannot load a required library.\")\n        except Exception:\n            if self.ignore_cache_errors:\n                return null_cache()\n            raise ArcaMisconfigured(\"The provided cache is not working - most likely misconfigured.\")\n\n        return region"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the repository URL - raises ValueError if it is not a valid git repository.", "response": "def validate_repo_url(self, repo: str):\n        \"\"\" Validates repo URL - if it's a valid git URL and if Arca can handle that type of repo URL\n\n        :raise ValueError: If the URL is not valid\n        \"\"\"\n        # that should match valid git repos\n        if not isinstance(repo, str) or not re.match(r\"^(https?|file)://[\\w._\\-/~]*[.git]?/?$\", repo):\n            raise ValueError(f\"{repo} is not a valid http[s] or file:// git repository.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef repo_id(self, repo: str) -> str:\n        if repo.startswith(\"http\"):\n            repo_id = re.sub(r\"https?://(.www)?\", \"\", repo)\n            repo_id = re.sub(r\"\\.git/?$\", \"\", repo_id)\n        else:\n            repo_id = repo.replace(\"file://\", \"\")\n            repo_id = re.sub(r\"\\.git/?$\", \"\", repo_id)\n            if repo_id.startswith(\"~\"):\n                repo_id = str(Path(repo_id).resolve())\n\n        # replaces everything that isn't alphanumeric, a dot or an underscore\n        # to make sure it's a valid folder name and to keep it readable\n        # multiple consecutive invalid characters replaced with a single underscore\n        repo_id = re.sub(r\"[^a-zA-Z0-9._]+\", \"_\", repo_id)\n\n        # and add a hash of the original to make it absolutely unique\n        return repo_id + hashlib.sha256(repo.encode(\"utf-8\")).hexdigest()", "response": "Returns a unique identifier from a repo URL."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_path_to_repo(self, repo: str) -> Path:\n        return Path(self.base_dir) / \"repos\" / self.repo_id(repo)", "response": "Returns a path to the location where all the branches from this repository are stored."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_path_to_repo_and_branch(self, repo: str, branch: str) -> Path:\n        return self.get_path_to_repo(repo).resolve() / branch", "response": "Returns a path to the repository and branch of the current branch."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_hash(self, repo: str, branch: str, git_repo: Repo):\n        if self.single_pull:\n            repo_id = self.repo_id(repo)\n            self._current_hashes[repo_id][branch] = git_repo.head.object.hexsha", "response": "Save the current git hash of the specified repository and branch combination."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef current_git_hash(self, repo: str, branch: str, git_repo: Repo, short: bool=False) -> str:\n        current_hash = self._current_hashes[self.repo_id(repo)].get(branch, git_repo.head.object.hexsha)\n\n        if short:\n            # shortens to minimum 7 characters, however git can make it longer on bigger repos\n            return git_repo.git.rev_parse(current_hash, short=7)\n        else:\n            return current_hash", "response": "Returns the current git hash for the specified branch."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pull_again(self, repo: Optional[str]=None, branch: Optional[str]=None) -> None:\n        if repo is None and branch is None:\n            self._current_hashes = {}\n        elif repo is None:\n            raise ValueError(\"You can't define just the branch to pull again.\")\n        elif branch is None and repo is not None:\n            self._current_hashes.pop(self.repo_id(repo), None)\n        else:\n            repo_id = self.repo_id(repo)\n            try:\n                self._current_hashes[repo_id].pop(branch)\n            except KeyError:\n                pass", "response": "Pulls again all branches from a specified repository."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a repository to use in clone command if there is one to be referenced.", "response": "def get_reference_repository(self, reference: Optional[Path], repo: str) -> Optional[Path]:\n        \"\"\"\n        Returns a repository to use in clone command, if there is one to be referenced.\n        Either provided by the user of generated from already cloned branches (master is preferred).\n\n        :param reference: Path to a local repository provided by the user or None.\n        :param repo: Reference for which remote repository.\n        \"\"\"\n        if reference is not None:\n            return reference.absolute()\n\n        repo_path = self.get_path_to_repo(repo)\n\n        if not repo_path.exists():\n            return None\n\n        master = repo_path / \"master\"\n\n        if master.exists() and master.is_dir():\n            return master\n\n        for existing_branch in repo_path.iterdir():\n            if not existing_branch.is_dir():\n                continue\n\n            return existing_branch.resolve()\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _pull(self, *, repo_path: Path=None, git_repo: Repo=None, repo: str=None, branch: str=None,\n              depth: Optional[int]=None,\n              reference: Optional[Path]=None\n              ) -> Repo:\n        \"\"\"\n        Returns a :class:`Repo <git.repo.base.Repo>` instance, either pulls existing or\n        clones a new copy.\n        \"\"\"\n        if git_repo is not None:\n            try:\n                git_repo.remote().fetch(branch)\n                # equivalent to git reset --hard origin/branch\n                git_repo.head.reset(f\"origin/{branch}\", index=True, working_tree=True)\n            except GitCommandError:\n                raise PullError(\"There was an error pulling the target repository.\")\n            return git_repo\n        else:\n            kwargs: Dict[str, Any] = {}\n\n            if depth is not None:\n                kwargs[\"depth\"] = depth\n\n            reference = self.get_reference_repository(reference, repo)\n\n            if reference is not None:\n                kwargs[\"reference-if-able\"] = str(reference)\n                kwargs[\"dissociate\"] = True\n\n            try:\n                return Repo.clone_from(repo, str(repo_path), branch=branch, **kwargs)\n            except GitCommandError:\n                raise PullError(\"There was an error cloning the target repository.\")", "response": "Pulls existing or clones a new copy."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the files for the given branch.", "response": "def get_files(self, repo: str, branch: str, *,\n                  depth: Optional[int]=1,\n                  reference: Optional[Path]=None\n                  ) -> Tuple[Repo, Path]:\n        \"\"\"\n        Either clones the repository if it's not cloned already or pulls from origin.\n        If ``single_pull`` is enabled, only pulls if the repo/branch combination wasn't pulled again by this instance.\n\n        :param repo: Repo URL\n        :param branch: Branch name\n        :param depth:  See :meth:`run`\n        :param reference: See :meth:`run`\n\n        :return: A :class:`Repo <git.repo.base.Repo>` instance for the repo\n                 and a :class:`Path <pathlib.Path>` to the location where the repo is stored.\n        \"\"\"\n        repo_path = self.get_path_to_repo_and_branch(repo, branch)\n\n        logger.info(\"Repo is stored at %s\", repo_path)\n\n        if repo_path.exists():\n            git_repo = Repo.init(repo_path)\n            repo_id = self.repo_id(repo)\n            if not self.single_pull or self._current_hashes[repo_id].get(branch) is None:\n                logger.info(\"Single pull not enabled, no pull hasn't been done yet or pull forced, pulling\")\n                self._pull(git_repo=git_repo, branch=branch)\n            else:\n                logger.info(\"Single pull enabled and already pulled in this initialization of backend\")\n        else:\n            repo_path.parent.mkdir(exist_ok=True, parents=True)\n            logger.info(\"Initial pull\")\n            git_repo = self._pull(repo_path=repo_path, repo=repo, branch=branch,\n                                  depth=depth,\n                                  reference=reference)\n\n        self.save_hash(repo, branch, git_repo)\n\n        return git_repo, repo_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a git. repo. Repo instance for the branch.", "response": "def get_repo(self, repo: str, branch: str, *,\n                 depth: Optional[int]=1,\n                 reference: Optional[Path]=None\n                 ) -> Repo:\n        \"\"\" Returns a :class:`Repo <git.repo.base.Repo>` instance for the branch.\n\n        See :meth:`run` for arguments descriptions.\n        \"\"\"\n        git_repo, _ = self.get_files(repo, branch, depth=depth, reference=reference)\n\n        return git_repo"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cache_key(self, repo: str, branch: str, task: Task, git_repo: Repo) -> str:\n        return \"{repo}_{branch}_{hash}_{task}\".format(repo=self.repo_id(repo),\n                                                      branch=branch,\n                                                      hash=self.current_git_hash(repo, branch, git_repo),\n                                                      task=task.hash)", "response": "Returns the key used for storing results in cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns the task in the target repository.", "response": "def run(self, repo: str, branch: str, task: Task, *,\n            depth: DepthDefinitionType=1,\n            reference: ReferenceDefinitionType=None\n            ) -> Result:\n        \"\"\" Runs the ``task`` using the configured backend.\n\n        :param repo: Target git repository\n        :param branch: Target git branch\n        :param task: Task which will be run in the target repository\n        :param depth: How many commits back should the repo be cloned in case the target repository isn't cloned yet.\n                      Defaults to 1, must be bigger than 0. No limit will be used if ``None`` is set.\n        :param reference: A path to a repository from which the target repository is forked,\n                          to save bandwidth, `--dissociate` is used if set.\n\n        :return: A :class:`Result` instance with the output of the task.\n\n        :raise PullError: If the repository can't be cloned or pulled\n        :raise BuildError: If the task fails.\n        \"\"\"\n        self.validate_repo_url(repo)\n        depth = self.validate_depth(depth)\n        reference = self.validate_reference(reference)\n\n        logger.info(\"Running Arca task %r for repo '%s' in branch '%s'\", task, repo, branch)\n\n        git_repo, repo_path = self.get_files(repo, branch, depth=depth, reference=reference)\n\n        def create_value():\n            logger.debug(\"Value not in cache, creating.\")\n            return self.backend.run(repo, branch, task, git_repo, repo_path)\n\n        cache_key = self.cache_key(repo, branch, task, git_repo)\n\n        logger.debug(\"Cache key is %s\", cache_key)\n\n        return self.region.get_or_create(\n            cache_key,\n            create_value,\n            should_cache_fn=self.should_cache_fn\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef static_filename(self, repo: str, branch: str, relative_path: Union[str, Path], *,\n                        depth: DepthDefinitionType=1,\n                        reference: ReferenceDefinitionType=None\n                        ) -> Path:\n        \"\"\"\n        Returns an absolute path to where a file from the repo was cloned to.\n\n        :param repo: Repo URL\n        :param branch: Branch name\n        :param relative_path: Relative path to the requested file\n        :param depth: See :meth:`run`\n        :param reference: See :meth:`run`\n\n        :return: Absolute path to the file in the target repository\n\n        :raise FileOutOfRangeError: If the relative path leads out of the repository path\n        :raise FileNotFoundError: If the file doesn't exist in the repository.\n        \"\"\"\n        self.validate_repo_url(repo)\n        depth = self.validate_depth(depth)\n        reference = self.validate_reference(reference)\n\n        if not isinstance(relative_path, Path):\n            relative_path = Path(relative_path)\n\n        _, repo_path = self.get_files(repo, branch, depth=depth, reference=reference)\n\n        result = repo_path / relative_path\n        result = result.resolve()\n\n        if repo_path not in result.parents:\n            raise FileOutOfRangeError(f\"{relative_path} is not inside the repository.\")\n\n        if not result.exists():\n            raise FileNotFoundError(f\"{relative_path} does not exist in the repository.\")\n\n        logger.info(\"Static path for %s is %s\", relative_path, result)\n\n        return result", "response": "Returns an absolute path to the file in the target repository that was cloned to."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the depth to int and validates that the value can be used.", "response": "def validate_depth(self, depth: DepthDefinitionType) -> Optional[int]:\n        \"\"\" Converts the depth to int and validates that the value can be used.\n\n        :raise ValueError: If the provided depth is not valid\n        \"\"\"\n        if depth is not None:\n            try:\n                depth = int(depth)\n            except ValueError:\n                raise ValueError(f\"Depth '{depth}' can't be converted to int.\")\n\n            if depth < 1:\n                raise ValueError(f\"Depth '{depth}' isn't a positive number\")\n\n            return depth\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_reference(self, reference: ReferenceDefinitionType) -> Optional[Path]:\n        if reference is not None:\n            if isinstance(reference, bytes):\n                reference = reference.decode(\"utf-8\")\n            try:\n                return Path(reference)\n            except TypeError:\n                raise ValueError(f\"Can't convert reference path {reference} to a pathlib.Path\")\n\n        return None", "response": "Converts a reference to a pathlib. Path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning all field validators on the data.", "response": "def validate(self, data):\n        \"\"\"\n        Runs all field validators.\n        \"\"\"\n        for v in self.validators:\n            v(self, data)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlisting all different styles entries", "response": "def list_styles(style_name):\n    \"\"\"\n    Just list all different styles entries\n    \"\"\"\n    style = get_style_by_name(style_name)\n\n    keys = list(style)[0][1]\n    Styles = namedtuple(\"Style\", keys)\n\n    existing_styles = {}\n\n    for ttype, ndef in style:\n        s = Styles(**ndef)\n        if s in existing_styles:\n            existing_styles[s].append(ttype)\n        else:\n            existing_styles[s] = [ttype]\n\n    for ndef, ttypes in existing_styles.items():\n        print(ndef)\n        for ttype in sorted(ttypes):\n            print(\"\\t%s\" % str(ttype).split(\"Token.\",1)[1])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decorate(*reversed_views):\n    fns = reversed_views[::-1]\n    view = fns[0]\n    for wrapper in fns[1:]:\n        view = wrapper(view)\n    return view", "response": "Decorate views with nested calls."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets a new value to map element specified by its index.", "response": "def set_as_object(self, *args):\n        \"\"\"\n        Sets a new value to map element specified by its index.\n        When the index is not defined, it resets the entire map value.\n        This method has double purpose because method overrides are not supported in JavaScript.\n\n        :param args: objects to set\n        \"\"\"\n        if len(args) == 1:\n            self.set_as_map(args[0])\n        elif len(args) == 2:\n            self.put(args[0], args[1])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert map element into an AnyValueMap or returns empty AnyValueMap if conversion is not possible.", "response": "def get_as_map(self, key):\n        \"\"\"\n        Converts map element into an AnyValueMap or returns empty AnyValueMap if conversion is not possible.\n\n        :param key: a key of element to get.\n\n        :return: AnyValueMap value of the element or empty AnyValueMap if conversion is not supported.\n        \"\"\"\n        if key == None:\n            map = {}\n            for (k, v) in self.items():\n                map[k] = v\n            return map\n        else:\n            value = self.get(key)\n            return MapConverter.to_map(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_tuples_array(tuples):\n        result = StringValueMap()\n\n        if tuples == None or len(tuples) == 0:\n            return result\n\n        index = 0\n        while index < len(tuples):\n            if index + 1 >= len(tuples):\n                break\n\n            key = StringConverter.to_string(tuples[index])\n            value = StringConverter.to_nullable_string(tuples[index + 1])\n            index += 2\n\n            result.put(key, value)\n\n        return result", "response": "Creates a new StringValueMap from a list of key - value pairs called tuples."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_string(line):\n        result = StringValueMap()\n        \n        if line == None or len(line) == 0:\n            return result\n\n        tokens = str(line).split(';')\n        for token in tokens:\n            if len(token) == 0:\n                continue\n            index = token.find('=')\n            key = token[0:index] if index >= 0 else token\n            value = token[index + 1:] if index >= 0 else None\n            result.put(key, value)\n\n        return result", "response": "Parses semicolon - separated key - value pairs and returns them as a StringValueMap."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_maps(*maps):\n        result = StringValueMap()\n        \n        if maps == None or len(maps) == 0:\n            return result\n\n        for map in maps:\n            for (k, v) in map.items():\n                key = StringConverter.to_string(k)\n                result.put(key, v)\n\n        return result", "response": "Creates an AnyValueMap by merging two or more maps."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(self, hard=False):\n\n        \"\"\"\n        Override the vanilla delete functionality to soft-delete\n        instead. Soft-delete is accomplished by setting the\n        status field to \"deleted\"\n\n        Arguments:\n\n        hard <bool=False> if true, do a hard delete instead, effectively\n        removing the object from the database\n        \"\"\"\n\n        if hard:\n            return models.Model.delete(self)\n        self.status = \"deleted\"\n        self.save()\n        for key in self._handleref.delete_cascade:\n            q = getattr(self, key).all()\n\n            if not hard:\n                # if we are soft deleting only trigger delete on\n                # objects that are not already deleted, as to avoid\n                # unnecessary re-saves and overriding of updated dates\n                q = q.exclude(status=\"deleted\")\n\n            for child in q:\n                child.delete(hard=hard)", "response": "Delete the object from the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_trainer_from_username(self, username, detail=False):\n\t\tparams = {\n\t\t\t'detail': '1' if detail is True else '0',\n\t\t\t'q': username\n\t\t}\n\t\tr = requests.get(api_url+'trainers/', params=params, headers=self.headers)\n\t\tprint(request_status(r))\n\t\ttry:\n\t\t\tr = r.json()[0]\n\t\texcept IndexError:\n\t\t\treturn None\n\t\treturn Trainer(r) if r else None", "response": "Returns a Trainer object from a Trainers username"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget discord. py user objects from memberlist", "response": "def discord_to_users(self, memberlist):\n\t\t\"\"\"\n\t\texpects a list of discord.py user objects\n\t\treturns a list of TrainerDex.py user objects\n\t\t\"\"\"\n\t\t_memberlist = self.get_discord_user(x.id for x in memberlist)\n\t\treturn list(set(x.owner() for x in _memberlist))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a trainer to the database", "response": "def create_trainer(self, username, team, start_date=None, has_cheated=None, last_cheated=None, currently_cheats=None, statistics=True, daily_goal=None, total_goal=None, prefered=True, account=None, verified=False):\n\t\t\"\"\"Add a trainer to the database\"\"\"\n\t\targs = locals()\n\t\turl = api_url+'trainers/'\n\t\tpayload = {\n\t\t\t'username': username,\n\t\t\t'faction': team,\n\t\t\t'statistics': statistics,\n\t\t\t'prefered': prefered,\n\t\t\t'last_modified': maya.now().iso8601(),\n\t\t\t'owner': account,\n\t\t\t'verified': verified\n\t\t}\n\t\t\n\t\tfor i in args:\n\t\t\tif args[i] is not None and i not in ['self', 'username', 'team', 'account', 'start_date']:\n\t\t\t\tpayload[i] = args[i]\n\t\t\telif args[i] is not None and i=='start_date':\n\t\t\t\tpayload[i] = args[i].date().isoformat()\n\t\t\n\t\tr = requests.post(url, data=json.dumps(payload), headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn Trainer(r.json())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates a trainer in a database", "response": "def update_trainer(self, trainer, username=None, start_date=None, has_cheated=None, last_cheated=None, currently_cheats=None, statistics=None, daily_goal=None, total_goal=None, prefered=None):\n\t\t\"\"\"Update parts of a trainer in a database\"\"\"\n\t\targs = locals()\n\t\tif not isinstance(trainer, Trainer):\n\t\t\traise ValueError\n\t\turl = api_url+'trainers/'+str(trainer.id)+'/'\n\t\tpayload = {\n\t\t\t'last_modified': maya.now().iso8601()\n\t\t}\n\t\t\n\t\tfor i in args:\n\t\t\tif args[i] is not None and i not in ['self', 'trainer', 'start_date']:\n\t\t\t\tpayload[i] = args[i]\n\t\t\telif args[i] is not None and i=='start_date':\n\t\t\t\tpayload[i] = args[i].date().isoformat()\n\t\t\n\t\tr = requests.patch(url, data=json.dumps(payload), headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn Trainer(r.json())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an Update object in the database", "response": "def create_update(self, trainer, xp, time_updated=None):\n\t\t\"\"\"Add a Update object to the database\n\t\t\n\t\tArguments:\n\t\ttrainer - expects a int of trainer's id or a trainer object\n\t\txp\n\t\ttime_updated - expects datetime.datetime\n\t\t\n\t\t\"\"\"\n\t\t\n\t\tif isinstance(trainer, Trainer):\n\t\t\ttrainer = trainer.id\n\t\turl = api_url+'trainers/'+str(trainer)+'/updates/'\n\t\tpayload = {'trainer' : int(trainer), 'xp' : int(xp)}\n\t\t\n\t\tif time_updated is None:\n\t\t\tpayload['update_time'] = maya.now().iso8601()\n\t\telse:\n\t\t\tpayload['update_time'] = time_updated.iso8601()\n\t\tif self.identifier:\n\t\t\tpayload['meta_source'] = self.identifier\n\t\t\n\t\tr = requests.post(url, data=json.dumps(payload), headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn Update(r.json())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef import_discord_user(self, uid, user):\n\t\turl = api_url+'users/social/'\n\t\tpayload = {\n\t\t\t'user': int(user),\n\t\t\t'provider': 'discord',\n\t\t\t'uid': str(uid)\n\t\t}\n\t\tprint(json.dumps(payload))\n\t\tr = requests.put(url, data=json.dumps(payload), headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn DiscordUser(r.json())", "response": "Add a discord user to the database if not already present get if is present."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new user object on database returning the User Object", "response": "def create_user(self, username, first_name=None, last_name=None):\n\t\t\"\"\"\n\t\tCreates a new user object on database\n\t\tReturns the User Object. Must be linked to a new trainer soon after\n\t\t\"\"\"\n\t\t\n\t\turl = api_url+'users/'\n\t\tpayload = {\n\t\t\t'username':username\n\t\t}\n\t\tif first_name:\n\t\t\tpayload['first_name'] = first_name\n\t\tif last_name:\n\t\t\tpayload['last_name'] = last_name\n\t\tr = requests.post(url, data=json.dumps(payload), headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn User(r.json())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the Trainer object for the ID", "response": "def get_trainer(self, id_, respect_privacy=True, detail=True):\n\t\t\"\"\"Returns the Trainer object for the ID\"\"\"\n\t\t\n\t\tparameters = {}\n\t\tif respect_privacy is False:\n\t\t\tparameters['statistics'] = 'force'\n\t\tif detail is False:\n\t\t\tparameters['detail'] = 'low'\n\t\t\t\n\t\tr = requests.get(api_url+'trainers/'+str(id_)+'/', headers=self.headers) if respect_privacy is True else requests.get(api_url+'trainers/'+str(id_)+'/', params=parameters, headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn Trainer(r.json())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_detailed_update(self, uid, uuid):\n\t\t\n\t\tr = requests.get(api_url+'users/'+str(uid)+'/update/'+str(uuid)+'/', headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn Update(r.json())", "response": "Returns the update object for the ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_user(self, uid):\n\t\t\n\t\tr = requests.get(api_url+'users/'+str(uid)+'/', headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn User(r.json())", "response": "Returns the User object for the ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the DiscordUsers object for the ID Expects list of string representions discord IDs user IDs or trainer IDs or user IDs Returns DiscordUser objects", "response": "def get_discord_user(self, uid=None, user=None, trainer=None):\n\t\t\"\"\"Returns the DiscordUsers object for the ID\n\t\tExpects list of string representions discord IDs, trainer IDs or user IDs\n\t\tReturns DiscordUser objects\n\t\t\"\"\"\n\t\tuids = ','.join(uid) if uid else None\n\t\tusers =','.join(user) if user else None\n\t\ttrainers = ','.join(trainer) if trainer else None\n\t\tparams = {\n\t\t\t'provider': 'discord',\n\t\t\t'uid': uids,\n\t\t\t'user': users,\n\t\t\t'trainer': trainers\n\t\t}\n\t\tr = requests.get(api_url+'users/social/', params=params, headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\toutput = r.json()\n\t\tresult = []\n\t\tfor x in output:\n\t\t\tresult.append(DiscordUser(x))\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all the users", "response": "def get_all_users(self):\n\t\t\"\"\"Returns all the users\"\"\"\n\t\t\n\t\tr = requests.get(api_url+'users/', headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\toutput = r.json()\n\t\tresult = []\n\t\tfor x in output:\n\t\t\tresult.append(User(x))\n\t\treturn result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a DiscordLeaderboard object for the given guild", "response": "def get_discord_leaderboard(self, guild):\n\t\t\"\"\"\n\t\tExpects: `int` - Discord Guild ID\n\t\tReturns: `trainerdex.DiscordLeaderboard`\n\t\t\"\"\"\n\t\t\n\t\tr = requests.get(api_url+'leaderboard/discord/'+str(guild)+'/', headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn DiscordLeaderboard(r.json())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_worldwide_leaderboard(self):\n\t\t\n\t\tr = requests.get(api_url+'leaderboard/', headers=self.headers)\n\t\tprint(request_status(r))\n\t\tr.raise_for_status()\n\t\treturn WorldwideLeaderboard(r.json())", "response": "Get the world wide leaderboard."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_prop(self, prop, value, ef=None):\n        if ef:\n            # prop should be restricted to n_decoys, an int, the no. of decoys corresponding to a given FPF.\n            # value is restricted to the corresponding enrichment factor and should be a float\n            self.ef[prop] = value\n        else:\n            if prop == 'ensemble':\n                # value is a tuple of strings that gives the ensemble composition\n                self.ensemble = value\n            elif prop == 'auc':\n                # value is a float that gives the auc value\n                self.auc = value", "response": "set the value of a given attribute in the object"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_prop(self, prop, ef=None):\n        if ef:\n            return self.ef[prop]\n        else:\n            if prop == 'auc':\n                return self.auc\n            elif prop == 'ensemble':\n                return self.ensemble", "response": "get a property from the attribute list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef combine(self, path):\n        url = self.base_url\n        if url.endswith('/') and path.startswith('/'):\n            url += path[1:]\n        elif url.endswith('/') or path.startswith('/'):\n            url += path\n        else:\n            url += '/' + path\n        return url", "response": "Returns a combined base url with the given path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a request and updates self. _DOM.", "response": "def update_DOM(self):\n        \"\"\"\n        Makes a request and updates `self._DOM`.\n        Worth using only if you manually change `self.base_url` or `self.path`.\n\n        :return: self\n        :rtype: Url\n        \"\"\"\n        response = self.fetch()\n        self._DOM = html.fromstring(response.text)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch(self):\n        response = self._session.get(self.url, params=self.params)\n        response.raise_for_status()\n        return response", "response": "Makes a request to combined url with self. _params as parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef init_environment():\n    os.environ['DJANGO_SETTINGS_MODULE'] = 'jukeboxcore.djsettings'\n    pluginpath = os.pathsep.join((os.environ.get('JUKEBOX_PLUGIN_PATH', ''), constants.BUILTIN_PLUGIN_PATH))\n    os.environ['JUKEBOX_PLUGIN_PATH'] = pluginpath", "response": "Initialize the environment variables that are important for the pipeline."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef unload_modules():\n    mods = set([])\n    for m in sys.modules:\n        if m.startswith('jukebox'):\n            mods.add(m)\n    pm = PluginManager.get()\n    for p in pm.get_all_plugins():\n        mods.add(p.__module__)\n    for m in mods:\n        del(sys.modules[m])", "response": "Unload all modules of jukebox and all plugins"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_LDAP_connection():\n    server = ldap3.Server('ldap://' + get_optional_env('EPFL_LDAP_SERVER_FOR_SEARCH'))\n    connection = ldap3.Connection(server)\n    connection.open()\n\n    return connection, get_optional_env('EPFL_LDAP_BASE_DN_FOR_SEARCH')", "response": "Return an LDAP connection"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndoing a LDAP search on the base LDAP domain", "response": "def LDAP_search(pattern_search, attribute):\n    \"\"\"\n    Do a LDAP search\n    \"\"\"\n    connection, ldap_base = _get_LDAP_connection()\n\n    connection.search(\n        search_base=ldap_base,\n        search_filter=pattern_search,\n        attributes=[attribute]\n    )\n    return connection.response"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the unit_id exists in the base class.", "response": "def is_unit_exist(unit_id):\n    \"\"\"\n    Return True if the unit 'unid_id' exists.\n    Otherwise return False\n    \"\"\"\n    attribute = 'objectClass'\n    response = LDAP_search(\n        pattern_search=\"(uniqueidentifier={})\".format(unit_id),\n        attribute=attribute\n    )\n    try:\n        unit_exist = 'EPFLorganizationalUnit' in response[0]['attributes'][attribute]\n    except Exception:\n        return False\n\n    return unit_exist"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the unit name to the unit_id", "response": "def get_unit_name(unit_id):\n    \"\"\"\n    Return the unit name to the unit 'unit_id'\n    \"\"\"\n    attribute = 'cn'\n    response = LDAP_search(\n        pattern_search='(uniqueIdentifier={})'.format(unit_id),\n        attribute=attribute\n    )\n    try:\n        unit_name = get_attribute(response, attribute)\n    except Exception:\n        raise EpflLdapException(\"The unit with id '{}' was not found\".format(unit_id))\n\n    return unit_name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_unit_id(unit_name):\n    unit_name = unit_name.lower()\n    attribute = 'uniqueIdentifier'\n    response = LDAP_search(\n        pattern_search='(cn={})'.format(unit_name),\n        attribute=attribute\n    )\n\n    unit_id = \"\"\n    try:\n        for element in response:\n            if 'dn' in element and element['dn'].startswith('ou={},'.format(unit_name)):\n                unit_id = element['attributes'][attribute][0]\n    except Exception:\n        raise EpflLdapException(\"The unit named '{}' was not found\".format(unit_name))\n    finally:\n        if not unit_id:\n            raise EpflLdapException(\"The unit named '{}' was not found\".format(unit_name))\n\n    return unit_id", "response": "Return the unit id to the unit_name"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all units of user username", "response": "def get_units(username):\n    \"\"\"\n    Return all units of user 'username'\n    \"\"\"\n    connection, ldap_base = _get_LDAP_connection()\n\n    # Search the user dn\n    connection.search(\n        search_base=ldap_base,\n        search_filter='(uid={}@*)'.format(username),\n    )\n\n    # For each user dn give me the unit\n    dn_list = [connection.response[index]['dn'] for index in range(len(connection.response))]\n\n    units = []\n    # For each unit search unit information and give me the unit id\n    for dn in dn_list:\n        unit = dn.split(\",ou=\")[1]\n        connection.search(search_base=ldap_base, search_filter='(ou={})'.format(unit), attributes=['uniqueidentifier'])\n        units.append(get_attribute(connection.response, 'uniqueIdentifier'))\n\n    return units"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the username of the user in the specified sciper", "response": "def get_username(sciper):\n    \"\"\"\n    Return username of user\n    \"\"\"\n    attribute = 'uid'\n    response = LDAP_search(\n        pattern_search='(uniqueIdentifier={})'.format(sciper),\n        attribute=attribute\n    )\n    try:\n        username = get_attribute(response, attribute)\n    except Exception:\n        raise EpflLdapException(\"No username corresponds to sciper {}\".format(sciper))\n    return username"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_email(sciper):\n    attribute = 'mail'\n    response = LDAP_search(\n        pattern_search='(uniqueIdentifier={})'.format(sciper),\n        attribute=attribute\n    )\n    try:\n        email = get_attribute(response, attribute)\n    except Exception:\n        raise EpflLdapException(\"No email address corresponds to sciper {}\".format(sciper))\n    return email", "response": "Get the email address of the user"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef with_code(self, code):\n        self.code = code if code != None else 'UNKNOWN'\n        self.name = code\n        return self", "response": "Sets a unique error code. This method returns reference to this exception and does not implement Builder pattern to chain additional calls."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset a parameter for additional error details.", "response": "def with_details(self, key, value):\n        \"\"\"\n        Sets a parameter for additional error details.\n        This details can be used to restore error description in other languages.\n\n        This method returns reference to this exception to implement Builder pattern to chain additional calls.\n\n        :param key: a details parameter name\n\n        :param value: a details parameter name\n\n        :return: this exception object\n        \"\"\"\n        self.details = self.details if self.details != None else {}\n        self.details[key] = value\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping another exception into an application exception object.", "response": "def wrap(self, cause):\n        \"\"\"\n        Wraps another exception into an application exception object.\n\n        If original exception is of ApplicationException type it is returned without changes.\n        Otherwise a new ApplicationException is created and original error is set as its cause.\n\n        :param cause: an original error object\n\n        :return: an original or newly created ApplicationException\n        \"\"\"\n        if isinstance(cause, ApplicationException):\n            return cause\n            \n        self.with_cause(cause)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps another exception into an application exception object.", "response": "def wrap_exception(exception, cause):\n        \"\"\"\n        Wraps another exception into specified application exception object.\n\n        If original exception is of ApplicationException type it is returned without changes.\n        Otherwise the original error is set as a cause to specified ApplicationException object.\n\n        :param exception: an ApplicationException object to wrap the cause\n\n        :param cause: an original error object\n\n        :return: an original or newly created ApplicationException\n        \"\"\"\n        if isinstance(cause, ApplicationException):\n            return cause\n        \n        exception.with_cause(cause)\n        return exception"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef value(self):\n        # Does the variable name have tags to parse?\n        if len(self._element):\n            var = ''.join(map(str, self.trigger.agentml.parse_tags(self._element, self.trigger)))\n        else:\n            var = self._element.text or attribute(self._element, 'name')\n\n        # Is there a default value defined?\n        default = attribute(self._element, 'default')\n\n        try:\n            self._log.debug('Retrieving {type} variable {var}'.format(type=self.type, var=var))\n            if self.type == 'user':\n                return self.trigger.user.get_var(var)\n            else:\n                return self.trigger.agentml.get_var(var)\n        except VarNotDefinedError:\n            # Do we have a default value?\n            if default:\n                self._log.info('{type} variable {var} not set, returning default: {default}'\n                               .format(type=self.type.capitalize(), var=var, default=default))\n\n            self._log.info('{type} variable {var} not set and no default value has been specified'\n                           .format(type=self.type.capitalize(), var=var))\n            return ''", "response": "Returns the current value of a variable in the current agentml file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreopens the file - like object in a safe manner.", "response": "def reopen(self, file_obj):\n        \"\"\"Reopen the file-like object in a safe manner.\"\"\"\n        file_obj.open('U')\n        if sys.version_info[0] <= 2:\n            return file_obj\n        else:\n            return codecs.getreader('utf-8')(file_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef inject(cls, span, obj):\n        opentracing.tracer.inject(span, cls.FORMAT, obj['headers'])", "response": "Injects the span context into a carrier object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _postrun(cls, span, obj, **kwargs):\n        span.set_tag(\"response.status_code\", obj.status_code)\n        span.set_tag(\n            \"response.content_lenght\", len(getattr(obj, 'content', \"\"))\n        )", "response": "Trigger to execute just before closing the span"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef extract_tags(cls, obj):\n        return dict(\n            [(\"request.{}\".format(attr), obj.get(attr, None)) for attr in\n             cls.TAGS]\n        )", "response": "Extract tags from the given object and return a dictionary of tags."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the specified message only if verbose output is enabled.", "response": "def vms(message, level=1):\n    \"\"\"Writes the specified message *only* if verbose output is enabled.\"\"\"\n    if verbose is not None and verbose != False:\n        if isinstance(verbose, bool) or (isinstance(verbose, int) and level <= verbose):\n            std(message)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_bdf(sdmpath, scan, nskip=0, readints=0, writebdfpkl=False, bdfdir=None):\r\n\r\n    assert os.path.exists(sdmpath), 'sdmpath %s does not exist' % sdmpath\r\n    scans, sources = read_metadata(sdmpath, scan, bdfdir=bdfdir)\r\n    assert scans[scan]['bdfstr'], 'bdfstr not defined for scan %d' % scan\r\n    bdffile = scans[scan]['bdfstr']\r\n\r\n    assert os.path.exists(bdffile), 'Could not find bdf for scan %d and bdfstr %s.' % (scan, scans[scan]['bdfstr'])\r\n\r\n    with open(bdffile, 'r') as fp:\r\n        # define bdfpkldir\r\n        if writebdfpkl:\r\n            bdfpkldir = os.path.join(sdmpath, 'bdfpkls')   # make place for bdfpkls, if needed\r\n            if not os.path.exists(bdfpkldir):\r\n                os.makedirs(bdfpkldir)\r\n        else:\r\n            bdfpkldir = ''\r\n\r\n        bdf = BDFData(fp, bdfpkldir=bdfpkldir).parse()\r\n        if readints == 0:\r\n            readints = bdf.n_integrations - nskip\r\n\r\n        logger.info('Reading %d ints starting at int %d' % (readints, nskip))\r\n        data = np.empty( (readints, bdf.n_baselines, bdf.n_channels, len(bdf.crosspols)), dtype='complex64', order='C')\r\n        for i in xrange(readints):\r\n            data[i] = bdf.get_data ('crossData.bin', i+nskip)\r\n#            flag[i] = bdf.get_data ('flags.bin', i+nskip)  # need to get auto+cross parsing right to implement this\r\n\r\n    return data", "response": "Reads given range of integrations from given SDM file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calc_uvw(sdmfile, scan=0, datetime=0, radec=()):\r\n\r\n    # set up CASA tools\r\n    try:\r\n        import casautil\r\n    except ImportError:\r\n        try:\r\n            import pwkit.environments.casa.util as casautil\r\n        except ImportError:\r\n            logger.info('Cannot find pwkit/casautil. No calc_uvw possible.')\r\n            return\r\n\r\n    me = casautil.tools.measures()\r\n    qa = casautil.tools.quanta()\r\n    logger.debug('Accessing CASA libraries with casautil.')\r\n\r\n    assert os.path.exists(os.path.join(sdmfile, 'Station.xml')), 'sdmfile %s has no Station.xml file. Not an SDM?' % sdmfile\r\n\r\n    # get scan info\r\n    scans, sources = read_metadata(sdmfile, scan)\r\n\r\n    # default is to use scan info\r\n    if (datetime == 0) and (len(radec) == 0):\r\n        assert scan != 0, 'scan must be set when using datetime and radec'   # default scan value not valid\r\n\r\n        logger.info('Calculating uvw for first integration of scan %d of source %s' % (scan, scans[scan]['source']))\r\n        datetime = qa.time(qa.quantity(scans[scan]['startmjd'],'d'), form=\"ymd\", prec=8)[0]\r\n        sourcenum = [kk for kk in sources.keys() if sources[kk]['source'] == scans[scan]['source']][0]\r\n        direction = me.direction('J2000', str(np.degrees(sources[sourcenum]['ra']))+'deg', str(np.degrees(sources[sourcenum]['dec']))+'deg')\r\n\r\n    # secondary case is when datetime is also given\r\n    elif (datetime != 0) and (len(radec) == 0):\r\n        assert scan != 0, 'scan must be set when using datetime and radec'   # default scan value not valid\r\n        assert '/' in datetime, 'datetime must be in yyyy/mm/dd/hh:mm:ss.sss format'\r\n\r\n        logger.info('Calculating uvw at %s for scan %d of source %s' % (datetime, scan, scans[scan]['source']))\r\n        sourcenum = [kk for kk in sources.keys() if sources[kk]['source'] == scans[scan]['source']][0]\r\n        direction = me.direction('J2000', str(np.degrees(sources[sourcenum]['ra']))+'deg', str(np.degrees(sources[sourcenum]['dec']))+'deg')\r\n\r\n    else:\r\n        assert '/' in datetime, 'datetime must be in yyyy/mm/dd/hh:mm:ss.sss format'\r\n        assert len(radec) == 2, 'radec must be (ra,dec) tuple in units of degrees'\r\n\r\n        logger.info('Calculating uvw at %s in direction %s' % (datetime, direction))\r\n        logger.info('This mode assumes all antennas used.')\r\n        ra = radec[0]; dec = radec[1]\r\n        direction = me.direction('J2000', str(ra)+'deg', str(dec)+'deg')\r\n\r\n    # define metadata \"frame\" for uvw calculation\r\n    sdm = sdmpy.SDM(sdmfile)\r\n    telescopename = sdm['ExecBlock'][0]['telescopeName'].strip()\r\n    logger.debug('Found observatory name %s' % telescopename)\r\n\r\n    me.doframe(me.observatory(telescopename))\r\n    me.doframe(me.epoch('utc', datetime))\r\n    me.doframe(direction)\r\n\r\n    # read antpos\r\n    if scan != 0:\r\n        configid = [row.configDescriptionId for row in sdm['Main'] if scan == int(row.scanNumber)][0]\r\n        antidlist = [row.antennaId for row in sdm['ConfigDescription'] if configid == row.configDescriptionId][0].split(' ')[2:]\r\n        stationidlist = [ant.stationId for antid in antidlist for ant in sdm['Antenna'] if antid == ant.antennaId]\r\n    else:\r\n        stationidlist = [ant.stationId for ant in sdm['Antenna']]\r\n\r\n    positions = [station.position.strip().split(' ')\r\n                 for station in sdm['Station'] \r\n                 if station.stationId in stationidlist]\r\n    x = [float(positions[i][2]) for i in range(len(positions))]\r\n    y = [float(positions[i][3]) for i in range(len(positions))]\r\n    z = [float(positions[i][4]) for i in range(len(positions))]\r\n    ants = me.position('itrf', qa.quantity(x, 'm'), qa.quantity(y, 'm'), qa.quantity(z, 'm'))\r\n\r\n    # calc bl\r\n    bls = me.asbaseline(ants)\r\n    uvwlist = me.expand(me.touvw(bls)[0])[1]['value']\r\n\r\n    # define new bl order to match sdm binary file bl order\r\n    u = np.empty(len(uvwlist)/3); v = np.empty(len(uvwlist)/3); w = np.empty(len(uvwlist)/3)\r\n    nants = len(ants['m0']['value'])\r\n    ord1 = [i*nants+j for i in range(nants) for j in range(i+1,nants)]\r\n    ord2 = [i*nants+j for j in range(nants) for i in range(j)]\r\n    key=[]\r\n    for new in ord2:\r\n        key.append(ord1.index(new))\r\n    for i in range(len(key)):\r\n        u[i] = uvwlist[3*key[i]]\r\n        v[i] = uvwlist[3*key[i]+1]\r\n        w[i] = uvwlist[3*key[i]+2]\r\n\r\n    return u, v, w", "response": "Calculates and returns uvw in meters for a given SDM time and pointing direction."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_metadata(sdmfile, scan=0, bdfdir=None):\r\n\r\n    sdmfile = sdmfile.rstrip('/')\r\n    assert os.path.exists(sdmfile), 'Could not find sdmfile %s.' % sdmfile\r\n    if bdfdir:\r\n        if not os.path.exists(bdfdir):\r\n            logger.info('bdfdir %s not found' % bdfdir)\r\n            bdfdir = os.path.join(sdmfile, 'ASDMBinary')\r\n    else:\r\n        bdfdir = os.path.join(sdmfile, 'ASDMBinary')\r\n    logger.info('Looking for bdfs in %s' % bdfdir)\r\n    sdmfile = sdmfile.rstrip('/')\r\n    scandict = {}; sourcedict = {}\r\n\r\n    # read Scan.xml into dictionary also and make a list\r\n    sdm = sdmpy.SDM(sdmfile)\r\n    if len(sdm['Scan']) > 1:    # workaround: conversion from MS to SDM tends to make scans into subscans of one large scan\r\n        for i in range(len(sdm['Scan'])):\r\n            row  = sdm['Scan'][i]\r\n            scannum = int(row['scanNumber'])\r\n            if scan in [0, scannum]:\r\n                rowkey = [k for k in row.keys if k.lower() == 'numsubscan'][0]   # need to find key but caps rule changes between ALMA/VLA\r\n                nsubs = int(row[rowkey])\r\n                scanintents = row['scanIntent']\r\n                intentstr = string.join(scanintents.strip().split(' ')[2:], ' ')\r\n                startmjd = float(row['startTime'])*1.0E-9/86400.0           # start and end times in mjd ns\r\n                endmjd = float(row['endTime'])*1.0E-9/86400.0\r\n                try:\r\n                    src = str(row[\"sourceName\"])        # source name\r\n                except:\r\n                    logger.warn('Scan %d has no source name' % (len(scandict)+1))\r\n                finally:\r\n                    scandict[scannum] = {}\r\n                    scandict[scannum]['source'] = src\r\n                    scandict[scannum]['startmjd'] = startmjd\r\n                    scandict[scannum]['endmjd'] = endmjd\r\n                    scandict[scannum]['intent'] = intentstr\r\n                    scandict[scannum]['nsubs'] = nsubs\r\n                    scandict[scannum]['duration'] = endmjd-startmjd\r\n                    scandict[scannum]['nints'] = int(sdm['Main'][i]['numIntegration'])\r\n        \r\n                try:\r\n                    bdfstr = sdm['Main'][i]['dataUID'].replace(':', '_').replace('/', '_')\r\n                except KeyError:\r\n                    bdfstr = sdm['Main'][i]['dataOid'].replace(':', '_').replace('/', '_')\r\n\r\n                scandict[scannum]['bdfstr'] = os.path.join(bdfdir, bdfstr)\r\n\r\n                # clear reference to nonexistent BDFs (either bad or not in standard locations)\r\n                if (not os.path.exists(scandict[scannum]['bdfstr'])) or ('X1' in bdfstr):\r\n                    scandict[scannum]['bdfstr'] = None\r\n                    logger.debug('No bdf found scan %d of %s' % (scannum, sdmfile) )\r\n\r\n                if scandict[scannum]['source'] not in [sourcedict[source]['source'] for source in sourcedict.iterkeys()]:\r\n                    for row in sdm['Field']:\r\n                        src = row['fieldName'].strip()\r\n                        if src == scandict[scannum]['source']:\r\n                            sourcenum = int(row[\"sourceId\"])\r\n                            direction = row[\"referenceDir\"].strip()\r\n                            (ra,dec) = [float(val) for val in direction.strip().split(' ')[3:]]  # skip first two values in string\r\n\r\n                            # original version would add warning if two sources had different ra/dec. this makes one entry for every source\r\n                            sourcedict[sourcenum] = {}\r\n                            sourcedict[sourcenum]['source'] = src\r\n                            sourcedict[sourcenum]['ra'] = ra\r\n                            sourcedict[sourcenum]['dec'] = dec\r\n                            break  # just take first instance, then escape\r\n\r\n    elif ( (len(sdm['Scan']) == 1) and (len(sdm['Subscan']) > 1) ):\r\n        logger.warn('Found only one scan with multiple subscans. Treating subscans as scans.')\r\n        for row in sdm['Subscan']:\r\n            scannum = int(row['subscanNumber'])\r\n            if scan in [0, scannum]:\r\n                startmjd = float(row['startTime'])*1.0E-9/86400.0           # start and end times in mjd ns\r\n                endmjd = float(row['endTime'])*1.0E-9/86400.0\r\n                scanintents = row['subscanIntent']\r\n                if len(scanintents.strip().split(' ')) > 1:\r\n                    intentstr = string.join(scanintents.strip().split(' ')[2:], ' ')\r\n                else:\r\n                    intentstr = scanintents\r\n\r\n                try:\r\n                    src = row[\"fieldName\"].strip()        # source name\r\n                except:\r\n                    logger.warn('Scan %d has no source name' % (len(scandict)+1))\r\n                finally:\r\n                    scandict[scannum] = {}\r\n                    scandict[scannum]['source'] = src\r\n                    scandict[scannum]['intent'] = intentstr\r\n                    scandict[scannum]['startmjd'] = startmjd\r\n                    scandict[scannum]['endmjd'] = endmjd\r\n                    scandict[scannum]['duration'] = endmjd-startmjd\r\n\r\n\r\n\r\n\r\n\r\n            \r\n    return [scandict, sourcedict]", "response": "Parses the SDM file and returns a tuple of lists of scan and source information."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self):\r\n\r\n        if os.path.exists(self.pklname):        # check for pkl with binary info\r\n            logger.info('Found bdf pkl file %s. Loading...' % (self.pklname))\r\n            try:\r\n                with open(self.pklname,'rb') as pkl:\r\n                    (self.mimemsg, self.headxml, self.sizeinfo, self.binarychunks, self.n_integrations, self.n_antennas, self.n_baselines, self.n_basebands, self.n_spws, self.n_channels, self.crosspols) = pickle.load(pkl)\r\n            except:\r\n                logger.warning('Something went wrong. Parsing bdf directly...')\r\n                self._parse()\r\n        else:\r\n            if self.pklname:\r\n                logger.info('Could not find bdf pkl file %s.' % (self.pklname))\r\n            self._parse()\r\n\r\n        self.headsize, self.intsize = self.calc_intsize()\r\n\r\n        return self", "response": "wrapper for original parse function. will read pkl with binary info if available."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the binary blobs and record the locations of the binary blobs. Sets up various data fields in the BDFData object.", "response": "def _parse (self):\r\n        \"\"\"Parse the BDF mime structure and record the locations of the binary\r\n        blobs. Sets up various data fields in the BDFData object.\"\"\"\r\n\r\n        feedparser = FeedParser (Message)\r\n        binarychunks = {}\r\n        sizeinfo = None\r\n        headxml = None\r\n        self.fp.seek (0, 0)\r\n\r\n        while True:\r\n            data = self.fp.readline ()\r\n            if not data:\r\n                break\r\n\r\n            feedparser.feed (data)\r\n\r\n            skip = (data == '\\n' and\r\n                    len (feedparser._msgstack) == 3 and\r\n                    feedparser._msgstack[-1].get_content_type () in ('application/octet-stream',\r\n                                                                     'binary/octet-stream'))\r\n            if skip:\r\n                # We just finished reading the headers for a huge binary blob.\r\n                # Time to remember where the data chunk is and pretend it doesn't\r\n                # exist.\r\n                msg = feedparser._msgstack[-1]\r\n                ident = msg['Content-Location']\r\n                assert ident.endswith ('.bin'), 'confusion #1 in hacky MIME parsing!'\r\n                binarychunks[ident] = self.fp.tell ()\r\n                if sizeinfo is None:\r\n                    headxml, sizeinfo, tagpfx = _extract_size_info (feedparser)\r\n                kind = ident.split ('/')[-1]\r\n                assert kind in sizeinfo, 'no size info for binary chunk kind %s in MIME!' % kind\r\n                self.fp.seek (sizeinfo[kind] + 1, 1) # skip ahead by data chunk size\r\n                sample = self.fp.read (16)\r\n                assert sample.startswith ('--MIME'), 'crap, unexpected chunk size in MIME parsing: %r' % sample\r\n                self.fp.seek (-16, 1) # go back\r\n\r\n            # check that two major kinds of data are read at least once\r\n            if any([k.split('/')[3] == '3' for k in binarychunks.iterkeys()]):\r\n                break\r\n\r\n        if headxml is None:\r\n            raise RuntimeError ('never found any binary data')\r\n\r\n        self.mimemsg = feedparser.close ()\r\n        self.headxml = headxml\r\n        self.sizeinfo = sizeinfo\r\n        self.binarychunks = binarychunks\r\n\r\n        headsize, intsize = self.calc_intsize()\r\n\r\n        # Compute some miscellaneous parameters that we'll need.\r\n#        self.n_integrations = len (self.mimemsg.get_payload ()) - 1\r\n        self.n_integrations = os.stat(self.fp.name).st_size/intsize\r\n        self.n_antennas = int (headxml.find (tagpfx + nanttag).text)\r\n        self.n_baselines = (self.n_antennas * (self.n_antennas - 1)) // 2\r\n\r\n        ds = headxml.find (tagpfx + dstag)\r\n        nbb = 0\r\n        nspw = 0\r\n        nchan = 0\r\n        crosspolstr = None\r\n\r\n        for bb in ds.findall (tagpfx + basebandtag):\r\n            nbb += 1\r\n\r\n            for spw in bb.getchildren ():\r\n                nspw += 1\r\n                nchan += int (spw.get ('numSpectralPoint'))\r\n\r\n                if crosspolstr is None:\r\n                    crosspolstr = spw.get ('crossPolProducts')\r\n                elif spw.get ('crossPolProducts') != crosspolstr:\r\n                    raise Exception ('can only handle spectral windows with identical cross pol products')\r\n\r\n        self.n_basebands = nbb\r\n        self.n_spws = nspw\r\n        self.n_channels = nchan\r\n        self.crosspols = crosspolstr.split ()\r\n        self.n_pols = len(self.crosspols)\r\n\r\n        # if bdf info pkl not present, write it\r\n        if os.path.exists(os.path.dirname(self.pklname)) and self.pklname and (not os.path.exists(self.pklname)):\r\n            logger.info('Writing bdf pkl info to %s...' % (self.pklname))\r\n            with open(self.pklname,'wb') as pkl:\r\n                # Compute some miscellaneous parameters that we'll need.\r\n                pickle.dump( (self.mimemsg, self.headxml, self.sizeinfo, self.binarychunks, self.n_integrations, self.n_antennas, self.n_baselines, self.n_basebands, self.n_spws, self.n_channels, self.crosspols), pkl)\r\n\r\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_data (self, datakind, integnum):\r\n\r\n        if integnum < 0 or integnum >= self.n_integrations:\r\n            raise ValueError ('illegal integration number %d' % integnum)\r\n\r\n        size = self.sizeinfo.get (datakind)\r\n        if size is None:\r\n            raise ValueError ('unrecognized data kind \"%s\"' % datakind)\r\n\r\n        dtype = _datatypes[datakind]\r\n        offset = self.headsize + integnum * self.intsize\r\n        dslice = self.mmdata[offset:offset+size]\r\n        data = np.fromstring (dslice, dtype=dtype)\r\n\r\n        if datakind == 'crossData.bin':\r\n            data = data.reshape ((self.n_baselines, self.n_channels, len (self.crosspols)))\r\n        elif datakind == 'autoData.bin':\r\n            data = data.reshape ((self.n_antennas, self.n_channels, 2))\r\n        elif datakind == 'flags.bin':\r\n            data = data.reshape ((self.n_baselines + self.n_antennas, self.n_channels,\r\n                                  len (self.crosspols)))\r\n\r\n        return data", "response": "Returns a numpy array of the given data kind and an integer number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calc_intsize(self):\r\n\r\n        # assume first cross blob starts after headxml and second is one int of bytes later\r\n        for k in self.binarychunks.iterkeys():\r\n            if int(k.split('/')[3]) == 1 and 'cross' in k.split('/')[-1]:\r\n                headsize = self.binarychunks[k]\r\n                break\r\n        for k in self.binarychunks.iterkeys():\r\n            if int(k.split('/')[3]) == 2 and 'cross' in k.split('/')[-1]:\r\n                intsize = self.binarychunks[k] - headsize\r\n                break\r\n\r\n        return (headsize, intsize)", "response": "Calculates the size of an integration in bytes"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef toString(self):\n        output = \"\"\n\n        if self.childs or self.isOpeningTag():\n            output += self.tagToString()\n\n            for c in self.childs:\n                output += c.toString()\n\n            if self.endtag is not None:\n                output += self.endtag.tagToString()\n\n        elif not self.isEndTag():\n            output += self.tagToString()\n\n        return output", "response": "Returns almost original string representation of the element."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getContent(self):\n        if not self.isTag() and self._element:\n            return self._element\n\n        if not self.childs:\n            return \"\"\n\n        output = \"\"\n        for c in self.childs:\n            if not c.isEndTag():\n                output += c.toString()\n\n        if output.endswith(\"\\n\"):\n            return output.rstrip()\n\n        return output", "response": "Returns the content of the element."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prettify(self, depth=0, separator=\"  \", last=True, pre=False,\n                 inline=False):\n        \"\"\"\n        Same as :meth:`toString`, but returns prettified element with content.\n\n        Note:\n            This method is partially broken, and can sometimes create\n            unexpected results.\n\n        Returns:\n            str: Prettified string.\n        \"\"\"\n        output = \"\"\n\n        if self.getTagName() != \"\" and self.tagToString().strip() == \"\":\n            return \"\"\n\n        # if not inside <pre> and not inline, shift tag to the right\n        if not pre and not inline:\n            output += (depth * separator)\n\n        # for <pre> set 'pre' flag\n        if self.getTagName().lower() == \"pre\" and self.isOpeningTag():\n            pre = True\n            separator = \"\"\n\n        output += self.tagToString()\n\n        # detect if inline - is_inline shows if inline was set by detection, or\n        # as parameter\n        is_inline = inline\n        for c in self.childs:\n            if not (c.isTag() or c.isComment()):\n                if len(c.tagToString().strip()) != 0:\n                    inline = True\n\n        # don't shift if inside container (containers have blank tagname)\n        original_depth = depth\n        if self.getTagName() != \"\":\n            if not pre and not inline:  # inside <pre> doesn't shift tags\n                depth += 1\n                if self.tagToString().strip() != \"\":\n                    output += \"\\n\"\n\n        # prettify childs\n        for e in self.childs:\n            if not e.isEndTag():\n                output += e.prettify(\n                    depth,\n                    last=False,\n                    pre=pre,\n                    inline=inline\n                )\n\n        # endtag\n        if self.endtag is not None:\n            if not pre and not inline:\n                output += ((original_depth) * separator)\n\n            output += self.endtag.tagToString().strip()\n\n            if not is_inline:\n                output += \"\\n\"\n\n        return output", "response": "Returns a string representation of the current element with content."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreplacing value in this element with values from el.", "response": "def replaceWith(self, el):\n        \"\"\"\n        Replace value in this element with values from `el`.\n\n        This useful when you don't want change all references to object.\n\n        Args:\n            el (obj): :class:`HTMLElement` instance.\n        \"\"\"\n        self.childs = el.childs\n        self.params = el.params\n        self.endtag = el.endtag\n        self.openertag = el.openertag\n\n        self._tagname = el.getTagName()\n        self._element = el.tagToString()\n\n        self._istag = el.isTag()\n        self._isendtag = el.isEndTag()\n        self._iscomment = el.isComment()\n        self._isnonpairtag = el.isNonPairTag()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef removeChild(self, child, end_tag_too=True):\n        # if there are multiple childs, remove them\n        if _is_iterable(child):\n            for x in child:\n                self.removeChild(child=x, end_tag_too=end_tag_too)\n            return\n\n        if not self.childs:\n            return\n\n        end_tag = None\n        if end_tag_too:\n            end_tag = child.endtag\n\n        for e in self.childs:\n            if e != child:\n                e.removeChild(child, end_tag_too)\n                continue\n\n            if end_tag_too and end_tag in self.childs:\n                self.childs.remove(end_tag)\n\n            self.childs.remove(e)", "response": "Removes a child element from the element."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_name(self, key):\n        '''Return a name for the given key\n        Argument:\n        key -- Pokemon number id (int)\n        '''\n        try:\n            return self.nameDict[key]\n        except IndexError as e:\n            print 'IndexError {0}: {1}'.format(e.errno, e.strerror)", "response": "Return a name for the given key"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending new list to self. nameDict", "response": "def append_to_list(self, source, start=None, hasIndex=False):\n        '''Appends new list to self.nameDict\n        Argument:\n        source -- source of new name list (filename or list)\n        start  -- starting index of new list\n        hasIndex -- the file is already indexed\n        '''\n        nfy = Numberify()\n        try:\n            if start is None:\n                if type(source) is str:\n                    if hasIndex is True:\n                        newList = self.get_from_indexedFile(source)\n                else:\n                    newList = nfy.numberify_data(source,\n                                                 len(self.nameDict) + 1)\n            else:\n                newList = nfy.numberify_data(source, start)\n            self.nameDict = dict(self.nameDict.items() + newList.items())\n            self.totalCount = len(self.nameDict)\n        except:\n            print 'Unknown error:', exc_info()[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles the previous command.", "response": "def handle_previous(self, command):\n        \"\"\"\n        Method to generate item from a ItemForm. The form must be exposed on form attribute\n        @param command: a command tha expose data through form attributte\n        \"\"\"\n        self.result = command.items\n        self._to_commit = self.result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_dates(raw_table) -> \"list of dates\":\n        dates = []\n        found_first = False\n        for i, dstr in enumerate([raw_table[i][0] for i in range(0, len(raw_table))]):\n            if dstr:\n                if len(dstr.split(\"/\")) == 3:\n                    d = datetime.datetime.strptime(dstr, '%m/%d/%Y')\n                elif len(dstr.split(\"-\")) == 3:\n                    d = datetime.datetime.strptime(dstr, '%Y-%m-%d')\n                else:\n                    # Not necessarily an error, could just be a non-date cell\n                    logging.debug(\"unknown date-format: {}\".format(dstr))\n                    continue\n                dates.append(d)\n                if not found_first:\n                    found_first = True\n                    logging.debug(\"Found first date: '{}' at i: {}\".format(d.isoformat(), i))\n            elif found_first:\n                logging.debug(\"Last date: {}\".format(d))\n                break\n        return dates", "response": "Returns a list of dates from the raw table."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a table with the above typesignature", "response": "def get_main(self) -> 'table[category: str][label: str][date: date]':\n        \"\"\"\n            Returns a table with the above typesignature\n        \"\"\"\n\n        raw_table = self.get_raw_table(\"M\")\n        categories = raw_table[0]\n        labels = raw_table[1]\n        dates = self.get_dates(raw_table)\n\n        def next_cat_col(i):\n            n = 1\n            while True:\n                if i+n > len(categories)-1:\n                    return i\n                if categories[i+n]:\n                    return i+n\n                n += 1\n\n        def get_category_labels(i):\n            end_col = next_cat_col(i)\n            return zip(range(i, end_col), labels[i:end_col])\n\n        def get_label_cells(category, label):\n            ci = categories.index(category)\n            i = labels.index(label, ci)\n            cells = {}\n            for j, d in enumerate(dates):\n                cell = raw_table[j+2][i]\n                if cell and cell != \"#VALUE!\":\n                    cells[d] = cell\n            return cells\n\n        table = {}\n        for i, cat in enumerate(categories):\n            if not cat:\n                continue\n            table[cat] = {}\n            for i, label in get_category_labels(i):\n                table[cat][label] = get_label_cells(cat, label)\n\n        return table"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild the headers as two - tuples.", "response": "def build_headers(self):\n        '''\n        Return the list of headers as two-tuples\n        '''\n        if not 'Content-Type' in self.headers:\n            content_type = self.content_type\n            if self.encoding != DEFAULT_ENCODING:\n                content_type += '; charset=%s' % self.encoding\n            self.headers['Content-Type'] = content_type\n\n        headers = list(self.headers.items())\n        # Append cookies\n        headers += [\n            ('Set-Cookie', cookie.OutputString())\n            for cookie in self.cookies.values()\n        ]\n        return headers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a cookie to the session.", "response": "def add_cookie(self, key, value, **attrs):\n        '''\n        Finer control over cookies.  Allow specifying an Morsel arguments.\n        '''\n        if attrs:\n            c = Morsel()\n            c.set(key, value, **attrs)\n            self.cookies[key] = c\n        else:\n            self.cookies[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nallow custom status messages", "response": "def status(self):\n        '''Allow custom status messages'''\n        message = self.status_message\n        if message is None:\n            message = STATUS[self.status_code]\n        return '%s %s' % (self.status_code, message)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets git identifier taken from Django project.", "response": "def get_git_changeset():\n    \"\"\"Get git identifier; taken from Django project.\"\"\"\n    git_log = Popen(\n        'git log --pretty=format:%ct --quiet -1 HEAD',\n        stdout=PIPE, stderr=PIPE, shell=True, universal_newlines=True)\n    timestamp = git_log.communicate()[0]\n    try:\n        timestamp = datetime.utcfromtimestamp(int(timestamp))\n    except ValueError:\n        return None\n    return timestamp.strftime('%Y%m%d%H%M%S')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_version(version_tuple):\n    if version_tuple[3] == FINAL and version_tuple[4] != 0:\n        raise Exception(\n            'Project version number misconfigured:\\n'\n            '   version may not be final and have segment number.')\n\n    if version_tuple[3] not in (DEV, FINAL) and version_tuple[4] == 0:\n        raise Exception(\n            'Project version number misconfigured:\\n'\n            '   version must have segment number.')\n\n    if version_tuple[3] == DEV:\n        segment_num = get_git_changeset()\n    else:\n        segment_num = str(abs(version_tuple[4]))\n\n    # X.X.X\n    sem_ver = \".\".join([\n        str(abs(int(number)))\n        for number in version_tuple[:3]\n    ])\n\n    if version_tuple[3] != FINAL:\n        if version_tuple[3] in (ALPHA, BETA, RC):\n            sem_ver = \"%s%s%s\" % (sem_ver, version_tuple[3], segment_num)\n        elif version_tuple[3] in (DEV, POST):\n            sem_ver = \"%s%s%s%s\" % (\n                sem_ver, SEPARATOR, version_tuple[3], segment_num)\n        else:\n            raise Exception(\n                'Project version number misconfigured:\\n'\n                '   Unrecognized release type')\n\n    return sem_ver", "response": "Convert 4 - tuple into a PEP 440 compliant string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, name):\n\n        if not isinstance(name, str):\n            raise TypeError(\n                    \"argument 'name' must be a string, not {}\".format(\n                        name.__class__.__name__\n                        )\n                    )\n\n        if not name:\n            raise ValueError(\"argument 'name' cannot be empty\")\n\n        if not name in self.__map:\n            self.__map[name] = IdRangeSet()", "response": "Append a new id range set to the map."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_file(self, id_file):\n\n        lineno = 0\n        for line in id_file:\n            lineno += 1\n            id_data = line.split(':')\n\n            if len(id_data) != 3:\n                raise BadIdFile(\n                        id_file.name, lineno,\n                        'incorrect number of fields'\n                        )\n\n            name = id_data[0]\n            try:\n                first, count = int(id_data[1]), int(id_data[2])\n            except ValueError:\n                raise BadIdFile(\n                        id_file.name, lineno,\n                        'cannot get the id range'\n                        )\n\n            # Append the new range\n            if not name in self.__map:\n                self.__map[name] = IdRangeSet()\n            self.__map[name].append(first, count)", "response": "Read and parse the id data from a file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a string representation of the id map as a string. This string is properly formatted in '/etc / uid or '/ etc / subgid.", "response": "def write_string(self):\n        \"\"\"\n        Return a representation of the id map as a string. This string is\n        properly formatted to be written in '/etc/subuid' or '/etc/subgid'.\n        \"\"\"\n\n        map_as_str = []\n        for name, id_range_set in self.__map.items():\n            for id_range in id_range_set:\n                map_as_str.append(\n                        name + ':' +\n                        str(id_range.first) + ':' +\n                        str(id_range.count) + '\\n'\n                    )\n\n        # Remove trailing newline\n        if len(map_as_str) > 0:\n            map_as_str[-1] = map_as_str[-1][:-1]\n\n        return ''.join(map_as_str)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of names who own subid in their id range set.", "response": "def who_has(self, subid):\n        \"\"\"Return a list of names who own subid in their id range set.\"\"\"\n\n        answer = []\n        for name in self.__map:\n            if subid in self.__map[name] and not name in answer:\n                answer.append(name)\n\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef phantomjs_retrieve(url, data=None):\n    range_limit()\n    print \"pGET\", url\n    process = subprocess.Popen(['phantomjs', PHANTOM_SCRIPT, url], stdout=subprocess.PIPE)\n    out = process.communicate()\n    process.wait()\n    response = out[0].decode('utf-8', 'ignore')\n    status = response[:2]\n    body = response[3:] # After the 'ok ' part.\n    if status == 'ok':\n        return 200, body\n    else:\n        return 404, body", "response": "Retrieve the given URL using PhantomJS."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef urllib_retrieve(url, data=None):\n    range_limit()\n    print \"uGET\", url\n    f = urlopen(url, data)\n    html = f.read().decode('utf-8', 'ignore')\n    return f.getcode(), html", "response": "Retrieve the given URL using Python s built - in urllib.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cache_path_for_url(url):\n    m = hashlib.md5()\n    m.update(url)\n    digest = m.hexdigest()\n    return os.path.join(CACHE_DIRECTORY, '%s.html' % digest)", "response": "Return the path where the URL might be cached."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_url(url, data=None, cached=True, cache_key=None, crawler='urllib'):\n    if cache_key is None:\n        cache_key = url\n    cache_path = cache_path_for_url(cache_key)\n    if cached and os.path.exists(cache_path):\n        with open(cache_path) as f:\n            html = f.read().decode('utf-8')\n    else:\n        if FAIL_IF_NOT_CACHED:\n            raise BaseException(\"URL is not in cache and FAIL_IF_NOT_CACHED is True: %s\" % url)\n        crawler_fn = CRAWLERS[crawler]\n        status, html = crawler_fn(url, data)\n        if status != 200: \n            raise HttpNotFound(url)\n        _ensure_directory(CACHE_DIRECTORY)\n        with open(cache_path, 'w') as f:\n            f.write(html.encode('utf-8'))\n    return html", "response": "Retrieves the HTML code for a given URL."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_intercom_data(self):\n        data = {\n            \"event_name\": self.get_type_display(),  # event type\n            \"created_at\": calendar.timegm(self.created.utctimetuple()),  # date\n            \"metadata\": self.metadata\n        }\n        if self.user:\n            data[\"user_id\"] = self.user.intercom_id\n        return data", "response": "Specify the data sent to Intercom API according to event type"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_lab_text(lab_slug, language):\n    if language == \"English\" or language == \"english\" or language == \"EN\" or language == \"En\":\n        language = \"en\"\n    elif language == \"Italian\" or language == \"italian\" or language == \"IT\" or language == \"It\" or language == \"it\":\n        language = \"it\"\n    else:\n        language = \"en\"\n    wiki = MediaWiki(makeinitaly__foundation_api_url)\n    wiki_response = wiki.call(\n        {'action': 'query',\n         'titles': lab_slug + \"/\" + language,\n         'prop': 'revisions',\n         'rvprop': 'content'})\n\n    #\u00a0If we don't know the pageid...\n    for i in wiki_response[\"query\"][\"pages\"]:\n        if \"revisions\" in wiki_response[\"query\"][\"pages\"][i]:\n            content = wiki_response[\"query\"][\"pages\"][i][\"revisions\"][0][\"*\"]\n        else:\n            content = \"\"\n\n    #\u00a0Clean the resulting string/list\n    newstr01 = content.replace(\"}}\", \"\")\n    newstr02 = newstr01.replace(\"{{\", \"\")\n    result = newstr02.rstrip(\"\\n|\").split(\"\\n|\")\n\n    return result[0]", "response": "Gets text description in English or Italian from a single lab from makeinitaly. foundation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_single_lab(lab_slug):\n    wiki = MediaWiki(makeinitaly__foundation_api_url)\n    wiki_response = wiki.call(\n        {'action': 'query',\n         'titles': lab_slug,\n         'prop': 'revisions',\n         'rvprop': 'content'})\n\n    # If we don't know the pageid...\n    for i in wiki_response[\"query\"][\"pages\"]:\n        content = wiki_response[\"query\"][\"pages\"][i][\"revisions\"][0][\"*\"]\n\n    # Clean the resulting string/list\n    newstr01 = content.replace(\"}}\", \"\")\n    newstr02 = newstr01.replace(\"{{\", \"\")\n    result = newstr02.rstrip(\"\\n|\").split(\"\\n|\")\n    # result.remove(u'FabLab')\n\n    # Transform the data into a Lab object\n    current_lab = MILab()\n\n    # Add existing data\n    for i in result:\n        if \"coordinates=\" in i:\n            value = i.replace(\"coordinates=\", \"\")\n            current_lab.coordinates = value\n            latlong = []\n            if \", \" in value:\n                latlong = value.rstrip(\", \").split(\", \")\n            elif \" , \" in value:\n                latlong = value.rstrip(\" , \").split(\" , \")\n            else:\n                latlong = [\"\", \"\"]\n            current_lab.latitude = latlong[0]\n            current_lab.longitude = latlong[1]\n        elif \"province=\" in i:\n            value = i.replace(\"province=\", \"\")\n            current_lab.province = value.upper()\n        elif \"region=\" in i:\n            value = i.replace(\"region=\", \"\")\n            current_lab.region = value\n        elif \"address=\" in i:\n            value = i.replace(\"address=\", \"\")\n            current_lab.address = value\n        elif \"city=\" in i:\n            value = i.replace(\"city=\", \"\")\n            current_lab.city = value\n        elif \"fablabsio=\" in i:\n            value = i.replace(\"fablabsio=\", \"\")\n            current_lab.fablabsio = value\n        elif \"website=\" in i:\n            value = i.replace(\"website=\", \"\")\n            current_lab.website = value\n        elif \"facebook=\" in i:\n            value = i.replace(\"facebook=\", \"\")\n            current_lab.facebook = value\n        elif \"twitter=\" in i:\n            value = i.replace(\"twitter=\", \"\")\n            current_lab.twitter = value\n        elif \"email=\" in i:\n            value = i.replace(\"email=\", \"\")\n            current_lab.email = value\n        elif \"manager=\" in i:\n            value = i.replace(\"manager=\", \"\")\n            current_lab.manager = value\n        elif \"birthyear=\" in i:\n            value = i.replace(\"birthyear=\", \"\")\n            current_lab.birthyear = value\n\n    current_lab.text_en = get_lab_text(lab_slug=lab_slug, language=\"en\")\n    current_lab.text_it = get_lab_text(lab_slug=lab_slug, language=\"it\")\n\n    return current_lab", "response": "Gets data from a single lab from makeinitaly. foundation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_labs(format):\n\n    labs = []\n\n    # Get the first page of data\n    wiki = MediaWiki(makeinitaly__foundation_api_url)\n    wiki_response = wiki.call(\n        {'action': 'query',\n         'list': 'categorymembers',\n         'cmtitle': 'Category:Italian_FabLabs',\n         'cmlimit': '500'})\n    if \"query-continue\" in wiki_response:\n        nextpage = wiki_response[\n            \"query-continue\"][\"categorymembers\"][\"cmcontinue\"]\n\n    urls = []\n    for i in wiki_response[\"query\"][\"categorymembers\"]:\n        urls.append(i[\"title\"].replace(\" \", \"_\"))\n\n    # Load all the Labs in the first page\n    for i in urls:\n        current_lab = get_single_lab(i)\n        labs.append(current_lab)\n\n    # Load all the Labs from the other pages\n    while \"query-continue\" in wiki_response:\n        wiki = MediaWiki(makeinitaly__foundation_api_url)\n        wiki_response = wiki.call({'action': 'query',\n                                   'list': 'categorymembers',\n                                   'cmtitle': 'Category:Hackerspace',\n                                   'cmlimit': '500',\n                                   \"cmcontinue\": nextpage})\n\n        urls = []\n        for i in wiki_response[\"query\"][\"categorymembers\"]:\n            urls.append(i[\"title\"].replace(\" \", \"_\"))\n\n        # Load all the Labs\n        for i in urls:\n            current_lab = get_single_lab(i, data_format)\n            labs.append(current_lab)\n\n        if \"query-continue\" in wiki_response:\n            nextpage = wiki_response[\n                \"query-continue\"][\"categorymembers\"][\"cmcontinue\"]\n        else:\n            break\n\n    # Transform the list into a dictionary\n    labs_dict = {}\n    for j, k in enumerate(labs):\n        labs_dict[j] = k.__dict__\n\n    # Return a dictiornary / json\n    if format.lower() == \"dict\" or format.lower() == \"json\":\n        output = labs_dict\n    # Return a geojson\n    elif format.lower() == \"geojson\" or format.lower() == \"geo\":\n        labs_list = []\n        for l in labs_dict:\n            single = labs_dict[l].__dict__\n            single_lab = Feature(\n                type=\"Feature\",\n                geometry=Point((single[\"latitude\"], single[\"longitude\"])),\n                properties=single)\n            labs_list.append(single_lab)\n        output = dumps(FeatureCollection(labs_list))\n    # Return a Pandas DataFrame\n    elif format.lower() == \"pandas\" or format.lower() == \"dataframe\":\n        output = {}\n        for j in labs_dict:\n            output[j] = labs_dict[j].__dict__\n        # Transform the dict into a Pandas DataFrame\n        output = pd.DataFrame.from_dict(output)\n        output = output.transpose()\n    # Return an object\n    elif format.lower() == \"object\" or format.lower() == \"obj\":\n        output = labs\n    # Default: return an object\n    else:\n        output = labs\n    # Return a proper json\n    if format.lower() == \"json\":\n        output = json.dumps(labs_dict)\n    return output", "response": "Gets all labs from makeinitaly. foundation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef path_eval(self, obj, keypath):\n        '''Given an object and a mongo-style dotted key path, return the\n        object value referenced by that key path.\n        '''\n        segs = keypath.split('.')\n        this = obj\n        for seg in segs:\n            if isinstance(this, dict):\n                try:\n                    this = this[seg]\n                except KeyError:\n                    raise self.InvalidPath()\n            elif isinstance(this, (list, tuple)):\n                if seg.isdigit():\n                    this = this[int(seg)]\n            else:\n                try:\n                    this = getattr(this, seg)\n                except AttributeError:\n                    raise self.InvalidPath()\n        return this", "response": "Given an object and a mongo - style dotted key path return the the\n        object referenced by that key path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a mongo - style spec and some data or python object check whether the object complies with the spec. Fails eagerly.", "response": "def check(self, spec, data):\n        '''Given a mongo-style spec and some data or python object,\n        check whether the object complies with the spec. Fails eagerly.\n        '''\n        path_eval = self.path_eval\n        for keypath, specvalue in spec.items():\n            if keypath.startswith('$'):\n                optext = keypath\n                checkable = data\n                args = (optext, specvalue, checkable)\n                generator = self.dispatch_operator(*args)\n            else:\n                try:\n                    checkable = path_eval(data, keypath)\n                except self.InvalidPath:\n                    # The spec referenced an item or attribute that\n                    # doesn't exist. Fail!\n                    return False\n                generator = self.dispatch_literal(specvalue, checkable)\n            for result in generator:\n                if not result:\n                    return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\napplying the given normalization to the input data set X.", "response": "def normalize(X, norm):\n  '''Applies the given norm to the input data set\n\n\n  Parameters:\n\n    X (numpy.ndarray): A 3D numpy ndarray in which the rows represent examples\n      while the columns, features of the data set you want to normalize. Every\n      depth corresponds to data for a particular class\n\n    norm (tuple): A tuple containing two 1D numpy ndarrays corresponding to the\n      normalization parameters extracted with :py:func:`estimated_norm` above.\n\n\n   Returns:\n\n     numpy.ndarray: A 3D numpy ndarray with the same dimensions as the input\n       array ``X``, but with its values normalized according to the norm input.\n\n  '''\n\n  return numpy.array([(k - norm[0]) / norm[1] for k in X])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_title(self, obj):\n        search_title = self.get_model_config_value(obj, 'search_title')\n\n        if not search_title:\n            return super().get_title(obj)\n\n        return search_title.format(**obj.__dict__)", "response": "Set search entry title for object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset search entry description for object", "response": "def get_description(self, obj):\n        \"\"\"Set search entry description for object\"\"\"\n        search_description = self.get_model_config_value(obj, 'search_description')\n\n        if not search_description:\n            return super().get_description(obj)\n\n        return search_description.format(**obj.__dict__)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_model_config_value(self, obj, name):\n        config = models_config.get_config(obj)\n        return getattr(config, name)", "response": "Get config value for given model"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconnects a callback to this signal.", "response": "def connect(self, callback, weak=False):\n        \"\"\"\n        Connects a new callback to this signal.\n\n        :param callback: The callback to connect.\n        :param weak: If `True`, only holds a weak reference to the specified\n            callback.\n\n        `callback` will be called whenever `emit` gets called on the `Signal`\n        instance.\n\n        If a weak reference is kept, when the callback gets destroyed, it will\n        be unregistered from the signal automatically. This can help avoiding\n        circular references in user-code.\n\n        .. warning::\n            Beware of bound methods ! Those are generally short-lived and don't\n            play nicely with weak reference.\n\n        .. note::\n            Connecting the same callback twice or more will cause the callback\n            to be called several times per `emit` call.\n\n            You will have to call `disconnect` as many times as the `connect`\n            call was called to unregister a callback completely.\n        \"\"\"\n        if weak:\n            callback = ref(callback, self._callbacks.remove)\n\n        self._callbacks.append(callback)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndisconnects a callback from this signal.", "response": "def disconnect(self, callback):\n        \"\"\"\n        Disconnects a callback from this signal.\n\n        :param callback: The callback to disconnect.\n        :param weak: A flag that must have the same value than the one\n            specified during the call to `connect`.\n\n        .. warning::\n            If the callback is not connected at the time of call, a\n            :class:`ValueError` exception is thrown.\n\n        .. note::\n            You may call `disconnect` from a connected callback.\n        \"\"\"\n        try:\n            self._callbacks.remove(callback)\n        except ValueError:\n            self._callbacks.remove(ref(callback))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nemit the signal. :param args: The arguments. :param kwargs: The keyword arguments. All the connected callbacks will be called synchronously in order of their registration.", "response": "def emit(self, *args, **kwargs):\n        \"\"\"\n        Emit the signal.\n\n        :param args: The arguments.\n        :param kwargs: The keyword arguments.\n\n        All the connected callbacks will be called synchronously in order of\n        their registration.\n        \"\"\"\n        for callback in self.callbacks:\n            callback(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_channel_names(client, e):\n\n        chan = IRCstr(e.channel)\n        names = set([IRCstr(n) for n in e.name_list])\n        client.channels[chan] = SeshetChannel(chan, names)", "response": "Add a new channel to self. channels and initialize its user list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd this user to the user s list and add the channel to this ArcGIS s channel s list of joined ArcGIS channels.", "response": "def join(self, channel):\n        \"\"\"Add this user to the channel's user list and add the channel to this\n        user's list of joined channels.\n        \"\"\"\n        \n        if channel not in self.channels:\n            channel.users.add(self.nick)\n            self.channels.append(channel)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove this user from the channel s user list and remove the channel from this user s list of joined channels.", "response": "def part(self, channel):\n        \"\"\"Remove this user from the channel's user list and remove the channel\n        from this user's list of joined channels.\n        \"\"\"\n        \n        if channel in self.channels:\n            channel.users.remove(self.nick)\n            self.channels.remove(channel)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef quit(self):\n        \n        for c in self.channels:\n            c.users.remove(self.nick)\n        self.channels = []", "response": "Remove this user from all channels and reinitialize the list\n        of joined channels."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates this user s nick in all joined channels.", "response": "def change_nick(self, nick):\n        \"\"\"Update this user's nick in all joined channels.\"\"\"\n        \n        old_nick = self.nick\n        self.nick = IRCstr(nick)\n        \n        for c in self.channels:\n            c.users.remove(old_nick)\n            c.users.add(self.nick)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log_message(self, user, message):\n        \n        if isinstance(user, SeshetUser):\n            user = user.nick\n        elif not isinstance(user, IRCstr):\n            user = IRCstr(user)\n\n        time = datetime.utcnow()\n            \n        self.message_log.append((time, user, message))\n        \n        while len(self.message_log) > self._log_size:\n            del self.message_log[0]", "response": "Log a channel message.\n        \n        This log acts as a sort of cache so that recent activity can be searched\n        by the bot and command modules without querying the database."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log(self, etype, source, msg='', target='', hostmask='', params=''):\n        \n        self.db.event_log.insert(event_type=etype,\n                                 event_time=datetime.utcnow(),\n                                 source=source,\n                                 target=target,\n                                 message=msg,\n                                 host=hostmask,\n                                 params=params,\n                                 )\n        self.db.commit()", "response": "Logs an event in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the set of users that are unique to the given channel.", "response": "def get_unique_users(self, chan):\n        \"\"\"Get the set of users that are unique to the given channel (i.e. not\n        present in any other channel the bot is in).\n        \"\"\"\n        \n        chan = IRCstr(chan)\n        \n        these_users = self.channels[chan].users\n        other_users = set()\n        for c in self.channels.values():\n            if c.name != chan:\n                other_users |= c.users\n        \n        return these_users - other_users"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextend client. SimpleClient. connect with defaults", "response": "def connect(self, *args, **kwargs):\n        \"\"\"Extend `client.SimpleClient.connect()` with defaults\"\"\"\n        defaults = {}\n\n        for i, k in enumerate(('host', 'port', 'channel', 'use_ssl', 'password')):\n            if i < len(args):\n                defaults[k] = args[i]\n            elif k in kwargs:\n                defaults[k] = kwargs[k]\n            else:\n                def_k = 'default_' + k\n                defaults[k] = getattr(self, def_k, None)\n\n        if defaults['use_ssl'] is None:\n            defaults['use_ssl'] = False\n\n        if defaults['host'] is None:\n            raise TypeError(\"missing 1 required positional argument: 'host'\")\n\n        logging.info(\"Connecting to %s:%s and joining channels %s\",\n                     defaults['host'],\n                     defaults['port'],\n                     defaults['channel'],\n                     )\n        client.SimpleClient.connect(self, **defaults)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _log_to_file(self, etype, source, msg='', target='', hostmask='', params=''):\n        today = datetime.utcnow()\n        # TODO: Use self.locale['timezone'] for changing time\n        date = today.strftime(self.locale['date_fmt'])\n        time = today.strftime(self.locale['time_fmt'])\n        datetime_s = today.strftime(self.locale['short_datetime_fmt'])\n        datetime_l = today.strftime(self.locale['long_datetime_fmt'])\n        \n        if target == self.nickname and etype in ('privmsg', 'action'):\n            target = source\n\n        if etype in self.log_formats:\n            file_path = os.path.expanduser(self.log_file.format(**locals()))\n            file_dir = os.path.dirname(file_path)\n            if not os.path.isdir(file_dir):\n                os.makedirs(file_dir)\n\n            line = self.log_formats[etype].format(**locals())\n            with open(file_path, 'a') as log:\n                log.write(line+'\\n')", "response": "Override log to write to file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting the usual traceback information, followed by a listing of all the local variables in each frame.", "response": "def log_fault (exc, message = \"\", level = logging.CRITICAL,\n               traceback = False):\n  \"\"\"Print the usual traceback information, followed by a listing of all\n  the local variables in each frame.\n  \"\"\"\n  tb = sys.exc_info ()[2]\n  stack = _get_stack (tb)\n  LOG.log (level,\n           \"FAULT: %s%s(%s): %s\", (\"%s -- \" % message) if message else \"\",\n           tb.tb_frame.f_code.co_filename,\n           tb.tb_lineno,\n           repr (exc))\n  if traceback or LOG.isEnabledFor (logging.DEBUG):\n    for line in _generate_stackdump (stack):\n      LOG.debug (line)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a string representation of the exception.", "response": "def log_fault_exc_str (exc, # pylint: disable=W0613\n                       message = \"\", level = logging.CRITICAL,\n                       traceback = False):\n  \"\"\"Make a StringIO of the usual traceback information, followed by a\n  listing of all the local variables in each frame.\n  \"\"\"\n  return log_fault_info_str (sys.exc_info (), message = message,\n                             level = level, traceback = traceback)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log_fault_info_str (exc_info, message = \"\", level = logging.CRITICAL,\n                        traceback = False):\n  \"\"\"Make a StringIO of the usual traceback information, followed by a\n  listing of all the local variables in each frame.\n  \"\"\"\n  tb = sys.exc_info ()[2]\n  stack = _get_stack (tb)\n  rc = StringIO ()\n  rc.write (\"%s: FAULT: %s%s(%s): %s\\n\"\n            % (logging.getLevelName (level),\n               (\"%s -- \" % message) if message else \"\",\n               tb.tb_frame.f_code.co_filename,\n               tb.tb_lineno,\n               repr (exc_info[1])))\n  if traceback:\n    for line in _generate_stackdump (stack):\n      rc.write (\"%s\\n\" % line)\n  return rc.getvalue ()", "response": "Return a string representation of the fault info."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister a dependency of data_src -> data_sink by placing appropriate entries in provides_for and depends_on.", "response": "def register_dependency(self, data_src, data_sink):\n        \"\"\" registers a dependency of data_src -> data_sink\n            by placing appropriate entries in provides_for and depends_on\n        \"\"\"\n\n        pdebug(\"registering dependency %s -> %s\" % (data_src, data_sink))\n\n        if (data_src not in self._gettask(data_sink).depends_on):\n            self._gettask(data_sink).depends_on.append(data_src)\n\n        if (data_sink not in self._gettask(data_src).provides_for):\n            self._gettask(data_src).provides_for.append(data_sink)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a task by name resolving any dependencies on the way and resolving any dependencies on the way.", "response": "def build_task(self, name):\n        \"\"\" Builds a task by name, resolving any dependencies on the way \"\"\"\n\n        try:\n            self._gettask(name).value = (\n                self._gettask(name).task.resolve_and_build())\n        except TaskExecutionException as e:\n            perror(e.header, indent=\"+0\")\n            perror(e.message, indent=\"+4\")\n            self._gettask(name).value = e.payload\n        except Exception as e:\n            perror(\"error evaluating target '%s' %s\" %\n                   (name, type(self._gettask(name).task)))\n            perror(traceback.format_exc(e), indent='+4')\n            self._gettask(name).value = None\n\n        self._gettask(name).last_build_time = time.time()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_build_needed(self, data_sink, data_src):\n        return (self._gettask(data_src).last_build_time == 0 or\n                self._gettask(data_src).last_build_time <\n                self._gettask(data_sink).last_build_time)", "response": "returns true if data_src needs to be rebuilt given that data_sink\n            has had a rebuild requested."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify_valid_dependencies(self):\n\n        unobserved_dependencies = set(self.tasks.keys())\n        target_queue = []\n\n        while len(unobserved_dependencies) > 0:\n            target_queue = [unobserved_dependencies.pop()]\n\n            while target_queue is not []:\n                target_queue += unobserved_dependencies", "response": "Checks if the assigned dependencies are valid and if not returns a list of all unobserved dependencies."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deep_dependendants(self, target):\n        direct_dependents = self._gettask(target).provides_for\n\n        return (direct_dependents +\n                reduce(\n                    lambda a, b: a + b,\n                    [self.deep_dependendants(x) for x in direct_dependents],\n                    []))", "response": "Recursively finds the dependents of a given build target."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresolves the build order for interdependent build targets COOKIE Assumes no cyclic dependencies COOKIE", "response": "def resolve_dependency_graph(self, target):\n        \"\"\" resolves the build order for interdependent build targets\n\n            Assumes no cyclic dependencies\n        \"\"\"\n        targets = self.deep_dependendants(target)\n        # print \"deep dependants:\", targets\n        return sorted(targets,\n                      cmp=lambda a, b:\n                          1 if b in self.deep_dependendants(a) else\n                          -1 if a in self.deep_dependendants(b) else\n                          0)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresolving all targets of this dependency and returns the result of self. function on the resulting values", "response": "def resolve(self):\n        \"\"\"Builds all targets of this dependency and returns the result\n           of self.function on the resulting values\n        \"\"\"\n        values = {}\n        for target_name in self.target_names:\n            if self.context.is_build_needed(self.parent, target_name):\n                self.context.build_task(target_name)\n\n            if len(self.keyword_chain) == 0:\n                values[target_name] = self.context.tasks[target_name].value\n            else:\n                values[target_name] = reduce(\n                    lambda task, name: getattr(task, name),\n                    self.keyword_chain,\n                    self.context.tasks[target_name].task)\n        return self.function(**values)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef updateAllKeys(self):\n        for kf, key in zip(self.kf_list, self.sorted_key_list()):\n            kf.update(key, self.dct[key])", "response": "Update times for all keys in the layout."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert hash options into arguments list", "response": "def format_args(options):\n    \"\"\" Convert hash/key options into arguments list \"\"\"\n    args = list()\n\n    for key, value in options.items():\n        # convert foo_bar key into --foo-bar option\n        key = key.replace('_', '-')\n\n        if value is True:\n            # key: True\n            # --key\n            args.append('--{key}'.format(key=key))\n        elif is_sequence(value):\n            # key: ['foo', 'bar']\n            # --key=foo,bar\n            values = [str(val) for val in value]\n            args.append('--{key}={values}'.format(\n                key=key, values=','.join(values)))\n        else:\n            # key: 'foo'\n            # --key=foo\n            args.append('--{key}={value}'.format(key=key, value=value))\n\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint a message with a header.", "response": "def print_with_header(header, message, color, indent=0):\n    \"\"\"\n    Use one of the functions below for printing, not this one.\n    \"\"\"\n    print()\n    padding = ' ' * indent\n    print(padding + color + BOLD + header + ENDC + color + message + ENDC)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extract(fileobj, keywords, comment_tags, options):\n    encoding = options.get('encoding', 'utf-8')\n\n    original_position = fileobj.tell()\n\n    text = fileobj.read().decode(encoding)\n\n    if django.VERSION[:2] >= (1, 9):\n        tokens = Lexer(text).tokenize()\n    else:\n        tokens = Lexer(text, None).tokenize()\n\n    vars = [token.token_type != TOKEN_TEXT for token in tokens]\n\n    could_be_django = any(list(vars))\n\n    if could_be_django:\n        fileobj.seek(original_position)\n        iterator = extract_django(fileobj, keywords, comment_tags, options)\n        for lineno, funcname, message, comments in iterator:\n            yield lineno, funcname, message, comments\n    else:\n        # Underscore template extraction\n        comments = []\n\n        fileobj.seek(original_position)\n\n        for lineno, line in enumerate(fileobj, 1):\n            funcname = None\n\n            stream = TokenStream.from_tuple_iter(tokenize(line, underscore.rules))\n            while not stream.eof:\n                if stream.current.type == 'gettext_begin':\n                    stream.expect('gettext_begin')\n                    funcname = stream.expect('func_name').value\n                    args, kwargs = parse_arguments(stream, 'gettext_end')\n\n                    strings = []\n\n                    for arg, argtype in args:\n                        if argtype == 'func_string_arg':\n                            strings.append(force_text(arg))\n                        else:\n                            strings.append(None)\n\n                    for arg in kwargs:\n                        strings.append(None)\n\n                    if len(strings) == 1:\n                        strings = strings[0]\n                    else:\n                        strings = tuple(strings)\n\n                    yield lineno, funcname, strings, []\n\n                stream.next()", "response": "Extracts translation messages from a Django template file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_radians(cls, lat_radians, long_radians):\n        '''\n        Return a new instance of Point from a pair of coordinates in radians.\n        '''\n        return cls(math.degrees(lat_radians), math.degrees(long_radians))", "response": "Return a new Point instance from a pair of coordinates in radians."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef distance_to(self, point):\n        '''\n        Return the distance between this point and another point in meters.\n\n        :param point: Point to measure distance to\n        :type point: Point\n\n        :returns: The distance to the other point\n        :rtype: float\n        '''\n        angle = math.acos(\n            sin(self.lat_radians) * sin(point.lat_radians) +\n            cos(self.lat_radians) * cos(point.lat_radians) *\n            cos(self.long_radians - point.long_radians)\n        )\n        return angle * EARTH_RADIUS", "response": "Return the distance between this point and another point in meters."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bearing_to(self, point):\n        '''\n        Return the bearing to another point.\n\n        :param point: Point to measure bearing to\n        :type point: Point\n\n        :returns: The bearing to the other point\n        :rtype: Bearing\n        '''\n        delta_long = point.long_radians - self.long_radians\n        y = sin(delta_long) * cos(point.lat_radians)\n        x = (\n            cos(self.lat_radians) * sin(point.lat_radians) -\n            sin(self.lat_radians) * cos(point.lat_radians) * cos(delta_long)\n        )\n        radians = math.atan2(y, x)\n        return Bearing.from_radians(radians)", "response": "Return the bearing to another point."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the cross track distance between this point and the line between two locations.", "response": "def cross_track_distance(self, start_point, end_point):\n        '''\n        Return the cross track distance from this point to the line between two\n        points::\n\n                        * end_point\n                       /\n                      /\n                     /   * this point\n                    /\n                   /\n                  *\n             start_point\n\n\n        :param start_point: First point on the line\n        :type start_point: Point\n        :param end_point: Second point on the line\n        :type end_point: Point\n\n        :returns: The perpendicular distance to the line between ``start_point`` \n                  and ``end_point``, where distance on the right of ``start_point``\n                  is positive and distance on the left is negative \n        :rtype: float\n        '''\n\n        dist = start_point.distance_to(self)\n        bearing_to_end = start_point.bearing_to(end_point).radians\n        bearing_to_point = start_point.bearing_to(self).radians\n        return math.asin(math.sin(dist / EARTH_RADIUS) * \\\n                         math.sin(bearing_to_point - bearing_to_end)) * \\\n                         EARTH_RADIUS"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef relative_point(self, bearing_to_point, distance):\n        '''\n        Return a waypoint at a location described relative to the current point\n\n        :param bearing_to_point: Relative bearing from the current waypoint\n        :type bearing_to_point: Bearing\n        :param distance: Distance from the current waypoint\n        :type distance: float\n        :return: The point described by the parameters\n        '''\n\n        bearing = math.radians(360 - bearing_to_point) \n        rad_distance = (distance / EARTH_RADIUS)\n        lat1 = (self.lat_radians)\n        lon1 = (self.long_radians)\n        lat3 = math.asin(math.sin(lat1) * math.cos(rad_distance) + math.cos(lat1) * math.sin(rad_distance) * math.cos(bearing))\n        lon3 = lon1 + math.atan2(math.sin(bearing) * math.sin(rad_distance) * math.cos(lat1) , math.cos(rad_distance) - math.sin(lat1) * math.sin(lat3))\n\n        return Point(math.degrees(lat3), math.degrees(lon3))", "response": "Return a waypoint at a location described relative to the current point"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new Flask application", "response": "def create_app(settings):\n    \"\"\"Create a new Flask application\"\"\"\n    app = Flask(__name__)\n\n    # Import settings from file\n    for name in dir(settings):\n        value = getattr(settings, name)\n        if not (name.startswith('_') or isinstance(value, ModuleType)\n                or isinstance(value, FunctionType)):\n            app.config[name] = value\n\n    # Bootstrapping\n    if 'INSTALLED_APPS' in app.config:\n        app.installed_apps = app.config.get('INSTALLED_APPS', [])\n\n    # Extensions\n    Funnel(app)\n    Mobility(app)\n\n    # Register blueprints\n    for app_path in app.installed_apps:\n        app.register_blueprint(\n            getattr(__import__('{0}.views'.format(app_path),\n                               fromlist=['blueprint']),\n                    'blueprint'))\n\n    # Register error handlers\n    register_error_handlers(app)\n\n    @app.context_processor\n    def context_processor():\n        return dict(config=app.config)\n\n    @app.teardown_request\n    def teardown_request(exception=None):\n        # Remove the database session if it exists\n        if hasattr(app, 'db_session'):\n            app.db_session.close()\n\n    return app"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse command line arguments.", "response": "def _cmdline(argv=None):\n    \"\"\" Parse command line arguments.\n\n    \"\"\"\n    parser = ArgumentParser()\n    parser.add_argument(\"-c\", \"--config\", action=\"append\",\n            help=\"config file [etc/config.yml]\")\n    parser.add_argument(\"-v\", \"--version\", action=\"version\",\n            version=\"pipsort {:s}\".format(__version__),\n            help=\"print version and exit\")\n    parser.add_argument(\"-w\", \"--warn\", default=\"WARNING\",\n            help=\"logger warning level [WARNING]\")\n    parser.add_argument(\"search_term\", type=str,\n                        help=\"Search term for PyPI\")\n    args = parser.parse_args(argv)\n    if not args.config:\n        args.config = [\"etc/config.yml\"]\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(argv=None):\n    args = _cmdline(argv)\n    config.load(args.config)\n    results = get_package_list(args.search_term)\n    results = sorted(results, key=lambda a: sort_function(a[1]), reverse=True)\n    results_normalized = list()\n    last_result = None\n    for result in results:\n        if result[0] == last_result:\n            continue\n        results_normalized.append(result)\n        last_result = result[0]\n    print('\\n'.join([\"%s    -     %s\" % (_[0], _[1]) for _ in results_normalized]))\n    return 0", "response": "Execute the application CLI."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_permissions(urlpatterns, permissions={}):\n    for pattern in urlpatterns:\n        if isinstance(pattern, urlresolvers.RegexURLPattern):\n            perm = generate_perm_name(pattern.callback)\n            if is_allowed_view(perm) and perm not in permissions:\n                permissions[ACL_CODE_PREFIX + perm] = ACL_NAME_PREFIX + perm\n        elif isinstance(pattern, urlresolvers.RegexURLResolver):\n            generate_permissions(pattern.url_patterns, permissions)\n    return permissions", "response": "Generate names for permissions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_allowed_view(perm):\n\n    # Check if permission is in excluded list\n    for view in ACL_EXCLUDED_VIEWS:\n        module, separator, view_name = view.partition('*')\n        if view and perm.startswith(module):\n            return False\n\n    # Check if permission is in acl list\n    for view in ACL_ALLOWED_VIEWS:\n        module, separator, view_name = view.partition('*')\n        if separator and not module and not view_name:\n            return True\n        elif separator and module and perm.startswith(module):\n            return True\n        elif separator and view_name and perm.endswith(view_name):\n            return True\n        elif not separator and view == perm:\n            return True\n    return False", "response": "Check if permission is in acl list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrefresh the permissions of the current user.", "response": "def refresh_permissions(permissions):\n    \"\"\"Refresh permission:\n       Remove deprecated permissions,\n       Add generated permissions.\"\"\"\n    available_permissions = [x.codename for x in\n                             Permission.objects.filter(\n                                 codename__startswith=ACL_CODE_PREFIX)]\n    active_permissions = permissions.keys()\n\n    perms_to_add = set(active_permissions) - set(available_permissions)\n    perms_to_remove = set(available_permissions) - set(active_permissions)\n\n    # Remove deprecated permissions\n    for codename in perms_to_remove:\n        Permission.objects.filter(codename=codename).delete()\n\n    # Add generated permissions\n    ct = ContentType.objects.get_for_model(model=auth_models.User)\n    for codename in perms_to_add:\n        Permission.objects.get_or_create(codename=codename,\n                                         name=permissions[codename],\n                                         content_type=ct)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the geographic data of a lab in a coherent way for all labs.", "response": "def get_location(query, format, api_key):\n    \"\"\"Get geographic data of a lab in a coherent way for all labs.\"\"\"\n\n    # Play nice with the API...\n    sleep(1)\n    geolocator = OpenCage(api_key=api_key, timeout=10)\n\n    # Variables for storing the data\n    data = {\"city\": None,\n            \"address_1\": None,\n            \"postal_code\": None,\n            \"country\": None,\n            \"county\": None,\n            \"state\": None,\n            \"country_code\": None,\n            \"latitude\": None,\n            \"longitude\": None,\n            \"continent\": None}\n    road = \"\"\n    number = \"\"\n    # Default None values\n    location_data = {\"city\": None,\n                     \"road\": None,\n                     \"house_number\": None,\n                     \"postcode\": None,\n                     \"country\": None,\n                     \"county\": None,\n                     \"state\": None,\n                     \"ISO_3166-1_alpha-2\": None,\n                     \"country_code\": None,\n                     \"lat\": None,\n                     \"lng\": None}\n\n    # Reverse geocoding ... from coordinates to address\n    if format == \"reverse\":\n        # If the query (coordinates) is not empty\n        if query is None or len(query) < 3:\n            pass\n        else:\n            location = geolocator.reverse(query)\n            if location is not None:\n                location_data = location[0].raw[u'components']\n                location_data[\"lat\"] = location[0].raw[u'geometry'][\"lat\"]\n                location_data[\"lng\"] = location[0].raw[u'geometry'][\"lng\"]\n    # Direct geocoding ... from address to coordinates and full address\n    if format == \"direct\":\n        # If the query (address) is not empty\n        if query is None or len(query) < 3:\n            pass\n        else:\n            location = geolocator.geocode(query)\n            if location is not None:\n                location_data = location.raw[u'components']\n                location_data[\"lat\"] = location.raw[u'geometry'][\"lat\"]\n                location_data[\"lng\"] = location.raw[u'geometry'][\"lng\"]\n\n    # Extract the meaningful data\n    for component in location_data:\n        if component == \"town\" or component == \"city\":\n            data[\"city\"] = location_data[component]\n        if component == \"road\":\n            road = location_data[component]\n        if component == \"house_number\":\n            number = location_data[component]\n        if component == \"postcode\":\n            data[\"postal_code\"] = location_data[component]\n        if component == \"country\":\n            data[\"country\"] = location_data[component]\n        if component == \"county\":\n            data[\"county\"] = location_data[component]\n        if component == \"state\":\n            data[\"state\"] = location_data[component]\n        if component == \"ISO_3166-1_alpha-2\":\n            data[\"country_code\"] = location_data[component]\n    # The address need to be reconstructed\n    data[\"address_1\"] = unicode(road) + \" \" + unicode(number)\n    data[\"latitude\"] = location_data[\"lat\"]\n    data[\"longitude\"] = location_data[\"lng\"]\n    # Format the country code to three letters\n    try:\n        country_data = transformations.cca2_to_ccn(data[\"country_code\"])\n        data[\"country_code\"] = transformations.ccn_to_cca3(country_data)\n    except:\n        data[\"country_code\"] = None\n    # Get the continent\n    try:\n        country_data = transformations.cc_to_cn(data[\"country_code\"])\n        data[\"continent\"] = transformations.cn_to_ctn(country_data)\n    except:\n        data[\"continent\"] = None\n\n    # Return the final data\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the given object in the appropriate wrapper class from esc_types. py.", "response": "def esc(self, val):\n        \"\"\"\n        Returns the given object in the appropriate wrapper class from esc_types.py.\n\n        In most cases, you will not need to call this directly.  However, if you are\n        passing a string to the interp method that should be used as an SQL bind value\n        and not raw SQL, you must pass it to this method to avoid a SQL injection\n        vulnerability.  For example:\n\n        >>> sqli = SQLInterp()\n        >>> first_name = 'John'\n\n        The following is wrong!  This could lead to a SQL injection attack.\n\n        >>> sqli.interp(\"SELECT * FROM table WHERE first_name =\", first_name)\n        ('SELECT * FROM table WHERE first_name = John', ())\n\n        This is the correct way.\n\n        >>> sqli.interp(\"SELECT * FROM table WHERE first_name =\", sqli.esc(first_name))\n        ('SELECT * FROM table WHERE first_name = ?', ('John',))\n        \"\"\"\n        if type(val) in self.type_map:\n            return self.type_map[type(val)](val)\n        else:\n            return Esc(val)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove all specified token_attrs that exist in instance. token_attrs .", "response": "def purge_tokens(self, input_token_attrs=None):\n        \"\"\" Removes all specified token_attrs that exist in instance.token_attrs\n        \n        :param token_attrs: list(str), list of string values of tokens to remove.  If None, removes all\n        \"\"\"\n        if input_token_attrs is None:\n            remove_attrs = self.token_attrs\n        else:\n            remove_attrs = [token_attr for token_attr in self.token_attrs if token_attr.token in input_token_attrs]\n\n        self.token_attrs = [token_attr for token_attr in self.token_attrs if token_attr not in remove_attrs]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef api_request(api_base_url='http://localhost:8080/', path='', method='get',\n    data=None, params={}, verify=True, cert=list()):\n    \"\"\"\n    Wrapper function for requests\n\n    :param api_base_url: Base URL for requests\n    :param path: Path to request\n    :param method: HTTP method\n    :param data: Data for post (ignored for GETs)\n    :param params: Dict of key, value query params\n    :param verify: True/False/CA_File_Name to perform SSL Verification of CA Chain\n    :param cert: list of cert and key to use for client authentication\n\n    \"\"\"\n    method = method.lower()\n    headers = {\n        'Accept': 'application/json',\n        'Content-type': 'application/json',\n    }\n    methods = {\n        'get': requests.get,\n        'post': requests.post,\n    }\n    if path[0] != '/':\n        path = '/{0}'.format(path)\n    if params:\n        path += '?{0}'.format(urllib.urlencode(params))\n    url = '{0}{1}'.format(api_base_url, path)\n    resp = methods[method](url, data=json.dumps(data), headers=headers,\n                           verify=verify, cert=cert)\n    return resp", "response": "Wrapper function for requests\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start(self, port):\n        self.application = tornado.web.Application(self.views, \n                template_path=self.templatePath, \n                static_path=self.staticPath)\n        self.application.listen(port)\n        self.ioloop.start()", "response": "\u542f\u52a8\u670d\u52a1\u5668\n        :param port: \u7aef\u53e3\u53f7\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset ssh credentials into config.", "response": "def set_ssh_creds(config, args):\n    \"\"\"\n    Set ssh credentials into config.\n\n    Note that these values might also be set in ~/.bangrc.  If they are\n    specified both in ~/.bangrc and as command-line arguments to ``bang``, then\n    the command-line arguments win.\n\n    \"\"\"\n    creds = config.get(A.DEPLOYER_CREDS, {})\n    creds[A.creds.SSH_USER] = args.user if args.user else creds.get(\n            A.creds.SSH_USER,\n            DEFAULT_SSH_USER,\n            )\n    if args.ask_pass:\n        creds[A.creds.SSH_PASS] = getpass.getpass('SSH Password: ')\n    config[A.DEPLOYER_CREDS] = creds"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_bang(alt_args=None):\n    parser = get_parser()\n    args = parser.parse_args(alt_args)\n\n    source = args.config_specs or get_env_configs()\n    if not source:\n        return\n\n    config = Config.from_config_specs(source)\n\n    if args.playbooks:\n        config[A.PLAYBOOKS] = args.playbooks\n\n    if args.dump_config:\n\n        if args.dump_config in ('yaml', 'yml'):\n            import yaml\n            print yaml.safe_dump(dict(config))\n        elif args.dump_config == 'json':\n            import json\n            print json.dumps(config)\n        else:\n            print config\n        sys.exit()\n\n    set_ssh_creds(config, args)\n\n    annoy(config)\n\n    stack = Stack(config)\n\n    if args.ansible_list:\n        stack.show_inventory(\n                os.isatty(sys.stdout.fileno())\n                )\n        return\n\n    initialize_logging(config)\n    # TODO:  config.validate()\n    if args.deploy:\n        stack.deploy()\n    if args.configure:\n        stack.configure()\n    config.autoinc()", "response": "Runs bang with optional list of strings as command line options."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndo the UNIX double-fork magic, see Stevens' \"Advanced Programming in the UNIX Environment\" for details (ISBN 0201563177) http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16", "response": "def _daemonize(self):\n        \"\"\"\n        do the UNIX double-fork magic, see Stevens' \"Advanced \n        Programming in the UNIX Environment\" for details (ISBN 0201563177)\n        http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16\n        \"\"\"\n        try:\n            pid = os.fork()\n            if pid > 0:\n                sys.exit(0)\n        except OSError, e:\n            sys.stderr.write(\"fork #1 failed: %d (%s)\\n\" %\n                             (e.errno, e.strerror))\n            sys.exit(1)\n\n        os.setsid()\n        os.chdir(\"/\")\n        os.umask(0)\n\n        try:\n            pid = os.fork()\n            if pid > 0:\n                sys.exit(0)\n        except OSError, e:\n            sys.stderr.write(\"fork #2 failed: %d (%s)\\n\" %\n                             (e.errno, e.strerror))\n            sys.exit(1)\n\n        sys.stdout.flush()\n        sys.stderr.flush()\n        if self.stdin:\n            si = file(self.stdin, 'r')\n            os.dup2(si.fileno(), sys.stdin.fileno())\n        if self.stdout:\n            so = file(self.stdout, 'a+')\n            os.dup2(so.fileno(), sys.stdout.fileno())\n        if self.stderr:\n            se = file(self.stderr, 'a+', 0)\n            os.dup2(se.fileno(), sys.stderr.fileno())\n        atexit.register(self.delpid)\n        pid = str(os.getpid())\n        file(self.pidfile, 'w+').write(\"%s\\n\" % pid)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstop the daemon process", "response": "def stop(self):\n        \"\"\"\n        Stop the daemon\n        \"\"\"\n        # Get the pid from the pidfile\n        try:\n            pf = file(self.pidfile, 'r')\n            pid = int(pf.read().strip())\n            pf.close()\n        except IOError:\n            pid = None\n\n        if not pid:\n            message = \"pidfile %s does not exist. Daemon not running?\\n\"\n            sys.stderr.write(message % self.pidfile)\n            return  # not an error in a restart\n        # Try killing the daemon process\n        try:\n            while 1:\n                #os.kill(pid, SIGTERM)\n                os.kill(pid, SIGKILL)\n                time.sleep(0.1)\n        except OSError, err:\n            err = str(err)\n            if err.find(\"No such process\") > 0:\n                if os.path.exists(self.pidfile):\n                    if not self.stdin == '/dev/null':\n                        os.remove(self.stdin)\n\n                    if not self.stdout == '/dev/null':\n                        os.remove(self.stdout)\n\n                    if not self.stderr == '/dev/null':\n                        os.remove(self.stderr)\n                        \n                    os.remove(self.pidfile)\n            else:\n                print str(err)\n                sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef monitor(self, timeout):\n\n        def check(self, timeout):\n            time.sleep(timeout)\n            self.stop()\n        wather = threading.Thread(target=check)\n        wather.setDaemon(True)\n        wather.start()", "response": "Monitor the process until timeout seconds."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hdf5_storable(type_or_storable, *args, **kwargs):\n    '''Registers a `Storable` instance in the global service.'''\n    if not isinstance(type_or_storable, Storable):\n        type_or_storable = default_storable(type_or_storable)\n    hdf5_service.registerStorable(type_or_storable, *args, **kwargs)", "response": "Registers a Storable instance in the global service."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntagging a type as not serializable.", "response": "def hdf5_not_storable(_type, *args, **kwargs):\n    '''Tags a type as not serializable.'''\n    hdf5_service.registerStorable(not_storable(_type), *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compile_and_process(self, in_path):\n\n        out_path = self.path_mapping[in_path]\n        if not self.embed:\n            pdebug(\"[%s::%s] %s -> %s\" % (\n                self.compiler_name,\n                self.name,\n                os.path.relpath(in_path),\n                os.path.relpath(out_path)),\n                groups=[\"build_task\"],\n                autobreak=True)\n        else:\n            pdebug(\"[%s::%s] %s -> <cache>\" % (\n                self.compiler_name,\n                self.name,\n                os.path.relpath(in_path)),\n                groups=[\"build_task\"],\n                autobreak=True)\n\n        compiled_string = self.compile_file(in_path)\n\n        if not self.embed:\n            if compiled_string != \"\":\n                with open(out_path, \"w\") as f:\n                    f.write(compiled_string)\n\n        return compiled_string", "response": "compile a file save it to the ouput file if the inline flag true"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds the scripts and return a string", "response": "def build(self):\n        \"\"\"build the scripts and return a string\"\"\"\n\n        if not self.embed:\n            mkdir_recursive(self.output_directory)\n\n        # get list of script files in build order\n        self.build_order = remove_dups(\n            reduce(lambda a, b: a + glob.glob(b),\n                   self.build_targets,\n                   []))\n        self.build_order_output = [self.out_path_of(t)\n                                   for (t) in self.build_order]\n        self.path_mapping = dict(zip(\n            self.build_order,\n            self.build_order_output))\n\n        self.compiled_scripts = {}\n        exceptions, values = partition(\n            lambda x: isinstance(x, Exception),\n            [self.compile_and_process(target)\n             for target in self.build_order])\n\n        self.compiled_scripts.update(dict(values))\n\n        saneExceptions, insaneExceptions = partition(\n            lambda x: isinstance(x, TaskExecutionException),\n            exceptions)\n\n        if len(insaneExceptions) != 0:\n            raise insaneExceptions[0]\n\n        if len(exceptions) != 0:\n            raise TaskExecutionException(\n                \"Precompiler Errors (%s):\" % type(self).__name__,\n                \"\\n\".join([\n                    x.header + \"\\n    \" +\n                    x.message.replace(\"\\n\", \"\\n    \")\n                    for x in exceptions]))\n\n        return self.collect_output()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate a build based on updated files", "response": "def update_build(self, updated_files):\n        \"\"\" updates a build based on updated files\n            TODO implement this pls\n        \"\"\"\n        for f in updated_files:\n            self.compiled_scripts[f] = self.compile_and_process(f)\n\n        return self.collect_output()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlog of the loss summed over all entries in the cluster.", "response": "def log_loss(actual, predicted):\n    \"\"\"Log of the loss (error) summed over all entries\n\n    The negative of the logarithm of the frequency (probability) of the predicted\n    label given the true binary label for a category.\n\n    Arguments:\n      predicted (np.array of float): 2-D table of probabilities for each\n        category (columns) and each record (rows)\n      actual (np.array of float): True binary labels for each category\n        Should only have a single 1 on each row indicating the one\n        correct category (column)\n\n    Based On:\n        https://www.kaggle.com/wiki/LogarithmicLoss\n        http://scikit-learn.org/stable/modules/model_evaluation.html#log-loss\n    \"\"\"\n\n    predicted, actual = np.array(predicted), np.array(actual)\n\n    small_value = 1e-15\n    predicted[predicted < small_value] = small_value\n    predicted[predicted > 1 - small_value] = 1. - small_value\n    return (-1. / len(actual)) * np.sum(\n        actual * np.log(predicted) + (1. - actual) * np.log(1. - predicted))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_experiments(experiment_ids=None, user_id=None, client_id=None, bucket_if_necessary=True, user_data=None):\n\n    if not client_id:\n        client_id = os.environ.get('BERNOULLI_CLIENT_ID')\n\n    if not client_id:\n        raise Exception(\"client_id is required\")\n\n    if type(experiment_ids) is dict:\n        experiment_ids = ','.join(experiment_ids)\n\n    params = {\n        'clientId': client_id,\n        'experimentIds': experiment_ids,\n        'userId': user_id,\n        'bucketIfNecessary': bucket_if_necessary,\n    }\n\n    if user_data is None:\n        user_data = {}\n\n    try:\n        response = requests.get(BASE_URL, params=dict(params.items() + user_data.items()))\n    except requests.ConnectionError:\n        raise Exception(\"Unable to access service\")\n\n    val = response.json()\n    if val['status'] != 'ok':\n        raise Exception(val['message'])\n\n    return val['value']", "response": "Retrieve the experiments of a user in the order they are part of the user s segment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef record_goal_attained(experiment_id, user_id, client_id = None):\n\n    if not client_id:\n        client_id = os.environ.get('BERNOULLI_CLIENT_ID')\n\n    if not client_id:\n        raise Exception(\"client_id is required\")\n\n    try:\n        response = requests.post(BASE_URL, data={\n            'clientId': client_id,\n            'userId': user_id,\n            'experimentId': experiment_id,\n        })\n    except requests.ConnectionError:\n        raise Exception(\"Unable to access services\")\n\n    val = response.json()\n    if val['status'] != 'ok':\n        raise Exception(val['message'])\n\n    return val['value']", "response": "Record that a user has already been attained for a user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef yaml_dump_hook(cfg, text: bool=False):\n\n    data = cfg.config.dump()\n    if not text:\n        yaml.dump(data, cfg.fd, Dumper=cfg.dumper, default_flow_style=False)\n    else:\n        return yaml.dump(data, Dumper=cfg.dumper, default_flow_style=False)", "response": "Dumps all the data into a YAML file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_user_to_group(self, user, group_name):\n        group, _ = Group.objects.get_or_create(name = group_name)\n        group.user_set.add(user)", "response": "Add a user to a group"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_args(args: List[str]) -> ProjectRunConfig:\n    parser = argparse.ArgumentParser(prog=\"gitlab-get-variables\", description=\"Tool for getting a GitLab project's \"\n                                                                              \"build variables\")\n    add_common_arguments(parser, project=True)\n    arguments = parser.parse_args(args)\n    return ProjectRunConfig(project=arguments.project, url=arguments.url, token=arguments.token, debug=arguments.debug)", "response": "Parses the given CLI arguments to get a run configuration."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a user username force authentication.", "response": "def given_i_am_logged_in(context, username):\r\n    \"\"\"\r\n    :type username: str\r\n    :type context: behave.runner.Context\r\n    \"\"\"\r\n    user = get_user_model().objects.get(username=username)\r\n    context.apiClient.force_authenticate(user=user)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the user exists in the database.", "response": "def basic_set_of_users_exists_in_the_database(context):\r\n    \"\"\"\r\n    :type context: behave.runner.Context\r\n    \"\"\"\r\n    user_model = get_user_model()\r\n    user_model.objects.create(\r\n        username='administrator',\r\n        is_staff=True\r\n    )\r\n    user_model.objects.create(\r\n        username='allowed_user'\r\n    )\r\n    user_model.objects.create(\r\n        username='unallowed_user'\r\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a DjSecret object from command line arguments.", "response": "def _create_djset(args, cls):\n    \"\"\" Return a DjSecret object \"\"\"\n    name = args.get('--name')\n    settings = args.get('--settings')\n    if name:\n        return cls(name=name)\n    elif settings:\n        return cls(name=settings)\n    else:\n        return cls()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a docopt dictionary of arguments", "response": "def _parse_args(args, cls):\n    \"\"\" Parse a docopt dictionary of arguments \"\"\"\n    \n    d = _create_djset(args, cls)\n    \n    key_value_pair = args.get('<key>=<value>')\n    key = args.get('<key>')\n    func = None\n    if args.get('add') and key_value_pair:\n        fargs = tuple(args.get('<key>=<value>').split('='))\n        if fargs[1]:\n            func = d.set\n    elif args.get('remove') and key:\n        func = d.remove\n        fargs = (args.get('<key>'),)\n    kwargs = {'glob': args.get('--global')}\n    if func:\n        return func, fargs, kwargs\n    else:\n        return None, None, None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncommand line function to update and the a config.", "response": "def update_config(configclass: type(Config)):\n    \"\"\"Command line function to update and the a config.\"\"\"\n\n    # we build the real click command inside the function, because it needs to be done\n    # dynamically, depending on the config.\n\n    # we ignore the type errors, keeping the the defaults if needed\n    # everything will be updated anyway\n    config = configclass()  # type: Config\n\n    def print_list(ctx, param, value):\n        # they do like that in the doc (http://click.pocoo.org/6/options/#callbacks-and-eager-options)\n        # so I do the same... but I don't now why.\n        # the only goal is to call __print_list__()\n        if not value or ctx.resilient_parsing:\n            return param\n\n        config.__print_list__()\n\n        ctx.exit()\n\n    def show_conf(ctx, param, value):\n        # see print_list\n        if not value or ctx.resilient_parsing:\n            return param\n\n        config.__show__()\n\n        ctx.exit()\n\n    def reset(ctx, param, value):\n        # see print_list\n        if not value or ctx.resilient_parsing:\n            return param\n\n        click.confirm('Are you sure you want to reset ALL fields to the defaults ? This action is not reversible.', abort=True)\n\n        # that doesn't exist\n        configclass.__config_path__, config_path = '', configclass.__config_path__\n        # So the file won't be opened and only the default will be loaded.\n        config = configclass()\n        # Thus we can save the defaults\n        # To the right place again\n        configclass.__config_path__ = config_path\n        config.__save__()\n\n        ctx.exit()\n\n    def clean(ctx, param, value):\n        # see print_list\n        if not value or ctx.resilient_parsing:\n            return param\n\n        config.__save__()\n        click.echo('Cleaned !')\n\n        ctx.exit()\n\n    @click.command(context_settings={'ignore_unknown_options': True})\n    @click.option('-c', '--clean', is_eager=True, is_flag=True, expose_value=False, callback=clean,\n                  help='Clean the file where the configutation is stored.')\n    @click.option('-l', '--list', is_eager=True, is_flag=True, expose_value=False, callback=print_list,\n                  help='List the availaible configuration fields.')\n    @click.option('--reset', is_flag=True, is_eager=True, expose_value=False, callback=reset,\n                  help='Reset all the fields to their default value.')\n    @click.option('-s', '--show', is_eager=True, is_flag=True, expose_value=False, callback=show_conf,\n                  help='View the configuration.')\n    @click.argument('fields-to-set', nargs=-1, type=click.UNPROCESSED)\n    def command(fields_to_set: 'Tuple[str]'):\n        \"\"\"\n        I manage your configuration.\n\n        If you call me with no argument, you will be able to set each field\n        in an interactive prompt. I can show your configuration with -s,\n        list the available field with -l and set them by --name-of-field=whatever.\n        \"\"\"\n\n        # with a context manager, the config is always saved at the end\n        with config:\n\n            if len(fields_to_set) == 1 and '=' not in fields_to_set[0]:\n                # we want to update a part of the config\n                sub = fields_to_set[0]\n                if sub in config:\n                    if isinstance(config[sub], SubConfig):\n                        # the part is a subconfig\n                        prompt_update_all(config[sub])\n                    else:\n                        # TODO: dynamic prompt for one field\n                        raise click.BadParameter('%s is not a SubConfig of the configuration')\n\n                else:\n                    raise click.BadParameter('%s is not a field of the configuration')\n\n            elif fields_to_set:\n                dct = {}\n                for field in fields_to_set:\n                    field, _, value = field.partition('=')\n                    dct[field] = value\n                # save directly what is passed if something was passed whitout the interactive prompt\n                config.__update__(dct)\n            else:\n                # or update all\n                prompt_update_all(config)\n\n    # this is the real function for the CLI\n    LOGGER.debug('start command')\n    command()\n    LOGGER.debug('end command')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef configureLogger(logFolder, logFile):\n    ''' Start the logger instance and configure it '''\n    # Set debug level\n    logLevel = 'DEBUG'\n    logger = logging.getLogger()\n    logger.setLevel(logLevel)\n\n    # Format\n    formatter = logging.Formatter('%(asctime)s - %(levelname)s | %(name)s -> %(message)s', '%Y-%m-%d %H:%M:%S')\n\n    # Remove default handler to keep only clean one\n    for hdlr in logger.handlers:\n        logger.removeHandler(hdlr)\n\n    # Create missing folder if needed\n    if not os.path.exists(logFolder):\n        os.makedirs(logFolder, 0700)\n\n    #\n    # ----------------------------\n    #   CREATE CONSOLE HANDLER\n    # ----------------------------\n    #\n\n    # Create console handler\n    consoleh = logging.StreamHandler()\n    consoleh.setLevel(logLevel)\n    consoleh.setFormatter(formatter)\n\n    # Set our custom handler\n    logger.addHandler(consoleh)\n\n    #\n    # ----------------------------\n    #   CREATE FILE HANDLER\n    # ----------------------------\n    #\n    fileh = logging.FileHandler(logFile, 'a')\n    fileh.setLevel(logLevel)\n    fileh.setFormatter(formatter)\n\n    # Set our custom handler\n    logger.addHandler(fileh)", "response": "Start the logger instance and configure it"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint any welcome message", "response": "def printWelcomeMessage(msg, place=10):\n    ''' Print any welcome message '''\n    logging.debug('*' * 30)\n    welcome = ' ' * place\n    welcome+= msg\n    logging.debug(welcome)\n\n    logging.debug('*' * 30 + '\\n')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef on_chat(self, data):\n        ''' Transfert a message to everybody '''\n        # XXX: we cannot use on_message as it's 'official' one already used\n        # by sockjsroom to create multiple on_* elements (like on_chat),\n        # so we use on_chat instead of on_message\n\n        # data => message\n        if self.roomId != '-1':\n            self.publishToRoom(self.roomId, 'chat', {\n                'username': self.username,\n                'time': datetime.now(),\n                'message': str(data['message'])\n            })", "response": "Transfert a message to everybody"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a frame to the other end of the connection.", "response": "def send_frame(self, frame):\n        \"\"\"\n        Sends a frame to the other end of the connection.\n        \"\"\"\n\n        # Get the socket\n        sock = self.manager.sock\n\n        if not sock:\n            raise ValueError(\"UDPTendrilManager not running\")\n\n        # Send the packet\n        try:\n            sock.sendto(self._send_streamify(frame), self.remote_addr)\n        except Exception:\n            # We're a best-effort service anyway, so ignore exceptions\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting the Tendril Manager.", "response": "def start(self, acceptor=None, wrapper=None):\n        \"\"\"\n        Starts the TendrilManager.\n\n        :param acceptor: If given, specifies a callable that will be\n                         called with each newly received Tendril;\n                         that callable is responsible for initial\n                         acceptance of the connection and for setting\n                         up the initial state of the connection.  If\n                         not given, no new connections will be\n                         accepted by the TendrilManager.\n        :param wrapper: A callable taking, as its first argument, a\n                        socket.socket object.  The callable must\n                        return a valid proxy for the socket.socket\n                        object, which will subsequently be used to\n                        communicate on the connection.\n\n        For passing extra arguments to the acceptor or the wrapper,\n        see the ``TendrilPartial`` class; for chaining together\n        multiple wrappers, see the ``WrapperChain`` class.\n        \"\"\"\n\n        super(UDPTendrilManager, self).start(acceptor, wrapper)\n\n        # Reset the socket and socket event\n        self._sock = None\n        self._sock_event.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stop(self, *args):\n\n        super(UDPTendrilManager, self).stop(*args)\n\n        # Reset the socket and socket event\n        self._sock = None\n        self._sock_event.clear()", "response": "Stops the TendrilManager.  Requires cooperation from the\n        listener implementation, which must watch the ``running``\n        attribute and ensure that it stops accepting connections\n        should that attribute become False.  Note that some tendril\n        managers will not exit from the listening thread until all\n        connections have been closed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninitiate a connection from the tendril manager s endpoint.", "response": "def connect(self, target, acceptor):\n        \"\"\"\n        Initiate a connection from the tendril manager's endpoint.\n        Once the connection is completed, a UDPTendril object will be\n        created and passed to the given acceptor.\n\n        :param target: The target of the connection attempt.\n        :param acceptor: A callable which will initialize the state of\n                         the new UDPTendril object.\n        \"\"\"\n\n        # Call some common sanity-checks\n        super(UDPTendrilManager, self).connect(target, acceptor, None)\n\n        # Construct the Tendril\n        tend = UDPTendril(self, self.local_addr, target)\n\n        try:\n            # Set up the application\n            tend.application = acceptor(tend)\n        except application.RejectConnection:\n            # The acceptor raised a RejectConnection\n            return None\n\n        # OK, let's track the tendril\n        self._track_tendril(tend)\n\n        # Might as well return the tendril, too\n        return tend"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef listener(self, acceptor, wrapper):\n\n        # OK, set up the socket\n        sock = socket.socket(self.addr_family, socket.SOCK_DGRAM)\n\n        with utils.SocketCloser(sock):\n            # Bind to our endpoint\n            sock.bind(self.endpoint)\n\n            # Get the assigned port number\n            self.local_addr = sock.getsockname()\n\n            # Call any wrappers\n            if wrapper:\n                sock = wrapper(sock)\n\n        # Senders need the socket, too...\n        self._sock = sock\n        self._sock_event.set()\n\n        # OK, now go into the listening loop with an error threshold\n        # of 10\n        closer = utils.SocketCloser(sock, 10,\n                                    ignore=[application.RejectConnection])\n        while True:\n            with closer:\n                data, addr = sock.recvfrom(self.recv_bufsize)\n\n                # Look up the tendril or create a new one\n                try:\n                    tend = self[(self.local_addr, addr)]\n                except KeyError:\n                    if not acceptor:\n                        # Can't accept new connections\n                        continue\n\n                    # Construct a Tendril\n                    tend = UDPTendril(self, self.local_addr, addr)\n\n                    # Set up the application\n                    tend.application = acceptor(tend)\n\n                    # OK, let's track the tendril\n                    self._track_tendril(tend)\n\n                # We now have a tendril; process the received data\n                try:\n                    tend._recv_frameify(data)\n                except Exception as exc:\n                    # Close the Tendril\n                    tend.close()\n\n                    # Notify the application what happened\n                    tend.closed(exc)", "response": "Listen for new connections to the manager s endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlook up an existing LBaaS instance by name.", "response": "def find_lb_by_name(self, name):\n        \"\"\"\n        Look up a LBaaS instance by name (rather than id)\n\n        :attr string name:  The LBaaS name assigned at creation time\n\n        :rtype :class:`dict`\n        \"\"\"\n        log.debug(\"Finding load balancers matching name '%s'\" % name)\n        matching = filter(lambda l: l['name'] == name, self.list_lbs())\n        if len(matching) > 1:\n            raise ValueError(\"Ambiguous; more than one load balancer matched '%s'\" % name)\n        if matching:\n            log.info(\"Found existing load balancer, %s\" % matching[0]['id'])\n            return matching[0]\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new LBaaS instance.", "response": "def create_lb(self, name, protocol='HTTP', port=80, algorithm=None,\n            virtual_ips=[], nodes=[], node_port=None):\n        \"\"\"\n        Create a new LBaaS instance. A name is required. If no nodes\n        are required, the instance ``status`` (after it's built) will be\n        ``ERROR`` until nodes are added. The return dict contains the id\n        and ``virtualIps`` (the external IP).\n\n        :param string name:  The LBaaS name - should be unique\n\n        :param string protocol:  Supported: HTTP, TCP\n\n        :param int port:  The external port. Supported: 80, 443, seemingly\n\n        :param list virtual_ips:  Use an existing IP (allows multiple\n                                  ports per IP)\n\n        :param list nodes:  Nodes addresses to add\n        \"\"\"\n        log.info(\"Creating load balancer '%s'\" % name)\n        protocol = protocol.upper()\n        nodes_to_add = []\n        if nodes:\n            nodes_to_add = map(\n                    lambda n: {'address': n, 'port': str(node_port)}, \n                    nodes\n                    )\n        data = {\n            'name': name,\n            'protocol': protocol,\n            'port': str(port),\n            'nodes': nodes_to_add,\n        }\n        if virtual_ips:\n            data['virtualIps'] = map(lambda i: {'id': i}, virtual_ips)\n        if algorithm:\n            data['algorithm'] = algorithm\n        resp, body = self._request('post', '/loadbalancers', data=data)\n        return body"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_lb_nodes(self, lb_id, nodes):\n        log.info(\"Adding load balancer nodes %s\" % nodes)\n        resp, body = self._request(\n                'post', \n                '/loadbalancers/%s/nodes' % lb_id,\n                data={'nodes': nodes})\n        return body", "response": "Adds nodes to an existing LBaaS instance"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding and remove nodes to match the host addresses and port given, based on existing_nodes. HPCS doesn't allow a load balancer with no backends, so we'll add first, delete after. :param string lb_id: Load balancer id :param :class:`list` of :class:`dict` existing_nodes: Existing nodes :param :class:`list` host_addresses: Node host addresses :param string port: Node port", "response": "def match_lb_nodes(self, lb_id, existing_nodes, host_addresses, host_port):\n        \"\"\"\n        Add and remove nodes to match the host addresses\n        and port given, based on existing_nodes. HPCS doesn't\n        allow a load balancer with no backends, so we'll add\n        first, delete after.\n\n        :param string lb_id: Load balancer id\n\n        :param :class:`list` of :class:`dict` existing_nodes: Existing nodes\n\n        :param :class:`list` host_addresses: Node host addresses\n\n        :param string port: Node port\n        \"\"\"\n        delete_filter = lambda n: \\\n                n['address'] not in host_addresses or \\\n                str(n['port']) != str(host_port)\n\n        delete_nodes = filter(delete_filter, existing_nodes)\n        delete_node_ids = [n['id'] for n in delete_nodes]\n        delete_node_hosts = [n['address'] for n in delete_nodes]\n        \n        current_nodes = set([n['address'] for n in existing_nodes])\n        current_nodes -= set(delete_node_hosts)\n        add_nodes = host_addresses - current_nodes\n        \n        if add_nodes:\n            nodes_to_add = [\n                    {'address': n, 'port': str(host_port)}\n                    for n in add_nodes\n            ]\n            args = (lb_id, nodes_to_add)\n            self.add_lb_nodes(*args)\n\n        if delete_node_ids:\n            args = (lb_id, delete_node_ids)\n            self.remove_lb_nodes(*args)\n        \n        log.info(\"Were %d nodes. Added %d nodes; deleted %d nodes\" % \n                (len(existing_nodes), len(add_nodes), len(delete_nodes)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_lb_nodes(self, lb_id, node_ids):\n        log.info(\"Removing load balancer nodes %s\" % node_ids)\n        for node_id in node_ids:\n            self._request('delete', '/loadbalancers/%s/nodes/%s' % (lb_id, node_id))", "response": "Remove one or more nodes from a load balancer."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the condition of a load balancer node", "response": "def update_lb_node_condition(self, lb_id, node_id, condition):\n        \"\"\"\n        Update node condition - specifically to disable/enable\n\n        :param string lb_id:  Balancer id\n\n        :param string node_id:  Node id\n\n        :param string condition:  ENABLED/DISABLED\n        \"\"\"\n        self._request(\n                'put', \n                '/loadbalancers/%s/nodes/%s' % (lb_id, node_id),\n                data={'condition': condition})"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the currently loaded website.", "response": "def soup(self, *args, **kwargs):\n        \"\"\"Parse the currently loaded website.\n\n        Optionally, SoupStrainer can be used to only parse relevant\n        parts of the page. This can be particularly useful if the website is\n        complex or perfomance is a factor.\n        <https://www.crummy.com/software/BeautifulSoup/bs4/doc/#soupstrainer>\n\n        Args:\n            *args: Optional positional arguments that `SoupStrainer` takes.\n            **kwargs: Optional keyword argument that `SoupStrainer` takes.\n\n        Returns:\n            A `BeautifulSoup` object.\n\n        Raises:\n            NoWebsiteLoadedError: If no website is currently loaded.\n            ParsingError: If the current response isn't supported by `bs4`\n        \"\"\"\n        if self._url is None:\n            raise NoWebsiteLoadedError('website parsing requires a loaded website')\n\n        content_type = self._response.headers.get('Content-Type', '')\n        if not any(markup in content_type for markup in ('html', 'xml')):\n            raise ParsingError('unsupported content type \\'{}\\''.format(content_type))\n\n        strainer = SoupStrainer(*args, **kwargs)\n        return BeautifulSoup(self._response.content, self.parser, parse_only=strainer)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, url, **kwargs):\n        response = self.session.get(url, **kwargs)\n        self._url = response.url\n        self._response = response\n        return response", "response": "Send a GET request to the specified URL and update the browser s _url attribute with the response."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a POST request to the currently loaded website s URL.", "response": "def post(self, **kwargs):\n        \"\"\"Send a POST request to the currently loaded website's URL.\n\n        The browser will automatically fill out the form. If `data` dict has\n        been passed into ``kwargs``, the contained input values will override\n        the automatically filled out values.\n\n        Returns:\n            `Response` object of a successful request.\n\n        Raises:\n            NoWebsiteLoadedError: If no website is currently loaded.\n        \"\"\"\n        if self._url is None:\n            raise NoWebsiteLoadedError('request submission requires a loaded website')\n\n        data = kwargs.get('data', {})\n        for i in self.soup('form').select('input[name]'):\n            if i.get('name') not in data:\n                data[i.get('name')] = i.get('value', '')\n        kwargs['data'] = data\n\n        response = self.session.post(self._url, **kwargs)\n        self._url = response.url\n        self._response = response\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a user - friendly admin how - to section.", "response": "def build_howto(request=None):\n    \"\"\"\n    Searches for \"how_to.md\" files in app directories.\n    Creates user-friendly admin how-to section from apps that have them.\n    \"\"\"\n    how_tos = {}\n\n    for app in settings.INSTALLED_APPS:\n        mod = import_module(app)\n        app_dir = os.path.dirname(mod.__file__)\n        how_to_file = os.path.join(app_dir, 'how_to.md')\n\n        if os.path.exists(how_to_file):\n            contents = open(how_to_file).read()\n            how_tos[app] = markdown.markdown(contents)\n\n    return render(request, 'admin/how-to/index.html', {'how_tos': how_tos})"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_string(cls, string, option=True):\n        return cls(_parse_signature(string, option=option))", "response": "Returns a new signature object based on the given string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef usage(self):\n        return u' '.join(u'<%s>' % pattern.usage for pattern in self.patterns)", "response": "A usage string that describes the signature."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(self, argv):\n        rv = {}\n        for pattern in self.patterns:\n            pattern.apply(rv, argv)\n        return rv", "response": "Parses the given argv and returns a dictionary mapping argument names\n        to the values found in argv."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_record(self, name, record_id):\n        if name in self._cache:\n            if record_id in self._cache[name]:\n                return self._cache[name][record_id]", "response": "Retrieve a record with a given type name and record id."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_records(self, name):\n        if name in self._cache:\n            return self._cache[name].values()\n        else:\n            return []", "response": "Return all the records for the given name in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_record(self, name, record_id, record):\n        if name not in self._cache:\n            self._cache[name] = {}\n        self._cache[name][record_id] = record", "response": "Save a record into the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nkeeps a cache of requests we've already made and use that for generating results if possible. If the user asked for a root prior to this call we can use it to skip a new lookup using `finder`. A top-level lookup will effectively serves as a global cache.", "response": "def make_hone_cache_wrapper(inner_func, maxsize, maxage, finder,\n                            store_partials):\n    \"\"\" Keeps a cache of requests we've already made and use that for\n    generating results if possible.  If the user asked for a root prior\n    to this call we can use it to skip a new lookup using `finder`.  A\n    top-level lookup will effectively serves as a global cache. \"\"\"\n\n    hits = misses = partials = 0\n    cache = TTLMapping(maxsize, maxage)\n\n    def wrapper(*args):\n        nonlocal hits, misses, partials\n        radix = args[-1]\n        # Attempt fast cache hit first.\n        try:\n            r = cache[radix]\n        except KeyError:\n            pass\n        else:\n            hits += 1\n            return r\n        for i in range(len(radix) - 1, -1, -1):\n            partial_radix = radix[:i]\n            try:\n                partial = cache[partial_radix]\n            except KeyError:\n                continue\n            try:\n                r = finder(radix, partial_radix, partial)\n            except:\n                break  # Treat any exception as a miss.\n            partials += 1\n            if store_partials:\n                cache[radix] = r\n            return r\n        misses += 1\n        cache[radix] = r = inner_func(*args)\n        return r\n\n    def cache_info():\n        \"\"\" Emulate lru_cache so this is a low touch replacement. \"\"\"\n        return HoneCacheInfo(hits, misses, maxsize, len(cache), maxage,\n                             partials, finder)\n\n    def cache_clear():\n        \"\"\" Clear cache and stats. \"\"\"\n        nonlocal hits, misses, partials\n        hits = misses = partials = 0\n        cache.clear()\n\n    wrapper.cache_info = cache_info\n    wrapper.cache_clear = cache_clear\n\n    return functools.update_wrapper(wrapper, inner_func)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ttl_cache(maxage, maxsize=128):\n\n    def decorator(inner_func):\n        wrapper = make_ttl_cache_wrapper(inner_func, maxage, maxsize)\n        return functools.update_wrapper(wrapper, inner_func)\n    return decorator", "response": "A time - to - live caching decorator that follows after the style of\n    lru_cache."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_ttl_cache_wrapper(inner_func, maxage, maxsize, typed=False):\n\n    hits = misses = 0\n    cache = TTLMapping(maxsize, maxage)\n\n    def wrapper(*args, **kwargs):\n        nonlocal hits, misses\n        key = functools._make_key(args, kwargs, typed)\n        try:\n            result = cache[key]\n        except KeyError:\n            misses += 1\n            result = cache[key] = inner_func(*args, **kwargs)\n        else:\n            hits += 1\n        return result\n\n    def cache_info():\n        \"\"\" Emulate lru_cache so this is a low touch replacement. \"\"\"\n        return TTLCacheInfo(hits, misses, maxsize, len(cache), maxage)\n\n    def cache_clear():\n        \"\"\" Clear cache and stats. \"\"\"\n        nonlocal hits, misses\n        hits = misses = 0\n        cache.clear()\n\n    wrapper.cache_info = cache_info\n    wrapper.cache_clear = cache_clear\n\n    return functools.update_wrapper(wrapper, inner_func)", "response": "Decorator that returns a new function that will cache the result of the wrapped function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning the requested command. args is either a list of descriptions or a list of strings to filter by", "response": "def run(command, options, args):\n    \"\"\"Run the requested command. args is either a list of descriptions or a list of strings to filter by\"\"\"\n\n    if command == \"backend\":\n        subprocess.call((\"sqlite3\", db_path))\n\n    if command == \"add\":\n        dp = pdt.Calendar()\n        due = mktime(dp.parse(options.due)[0]) if options.due else None\n        print \"added tasks...\"\n        [Task(desc, due).add() for desc in args]\n        return\n\n    filters = args if len(args) else None\n    rows    = Query(filters, options).find()\n    tasks   = [Task(r[\"desc\"], r[\"due\"]) for r in rows]\n\n    if command == \"list\":\n        for t in tasks:\n            print \"\\t *\", t\n\n    if command == \"done\":\n        print \"done with...\"\n        finished_tasks = []\n        for t in tasks: \n            finished = t.done()\n            if finished:\n                finished_tasks.append(t)\n\n        if not finished_tasks:\n            return\n\n        print \"\"\n        print \"finished tasks:\"\n        for t in finished_tasks:\n            print \"\\t X\", t\n    \n    if command == \"remove\":\n        print \"remove...\"\n        removed_tasks = []\n        for t in tasks: \n            removed = t.remove()\n            if removed:\n                removed_tasks.append(t)\n    \n        if not removed_tasks:\n            return\n    \n        print \"\"\n        print \"removed tasks:\"\n        for t in removed_tasks:\n            print \"\\t RM\", t"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisambiguate a command and validate the number of args passed for it", "response": "def match(command, options, args):\n    \"\"\"disambiguate a command (expanding, for eg, lis into list) and validate the number of args passed for it\"\"\"\n    build = \"\"\n    possible = commands\n    for l in command:\n        build += l\n        possible = filter(lambda w: w.startswith(build), possible)\n    \n    if len(possible) == 0:\n        raise ArgError(\"Command invalid: %s\" % command)\n    \n    if len(possible) > 1:\n        raise ArgError(\"Ambiguous command: %s\" % command)\n\n    command = possible.pop()\n\n    if not num_args[command](len(args)):\n        raise ArgError(\"Bad number of args for command %s\" % command)\n\n    return command"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a console handler to the given logger.", "response": "def add_console_logger(logger, level='info'):\n    \"\"\"\n    \u589e\u52a0console\u4f5c\u4e3a\u65e5\u5fd7\u8f93\u5165.\n    \"\"\"\n    logger.setLevel(getattr(logging, level.upper()))\n\n    if not logger.handlers:\n        # Set up color if we are in a tty and curses is installed\n        color = False\n        if curses and sys.stderr.isatty():\n            try:\n                curses.setupterm()\n                if curses.tigetnum(\"colors\") > 0:\n                    color = True\n            except:\n                pass\n        console = logging.StreamHandler()\n        console.setFormatter(_LogFormatter(color=color))\n        logger.addHandler(console)\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mark_read(self):\n        # Obviously remove the exception when Kippt says the support it.\n        raise NotImplementedError(\n            \"The Kippt API does not yet support marking notifications as read.\"\n        )\n\n        data = json.dumps({\"action\": \"mark_seen\"})\n        r = requests.post(\n            \"https://kippt.com/api/notifications\",\n            headers=self.kippt.header,\n            data=data\n        )\n        return (r.json())", "response": "Mark the current user s current user s attributes as read."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _run_program(name, *args, **kwargs):\n    shell = kwargs.get(\"shell\", False)\n\n    return_object = kwargs.get(\"ro\", False)\n    return_object = kwargs.get(\"return_object\", return_object)\n\n    no_return = kwargs.get(\"nr\", False)\n    no_return = kwargs.get(\"no_return\", no_return)\n\n    inp = kwargs.get(\"input\", None)\n\n    args = [name] + list(args)\n    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=shell)\n\n    if not no_return:\n        if inp:\n            stdout, stderr = tuple(x.decode(sys.getdefaultencoding()).strip() for x in p.communicate(inp))\n        else:\n            stdout, stderr = tuple(x.decode(sys.getdefaultencoding()).strip() for x in p.communicate())\n\n\n        if return_object:\n            return CommandOutput(stdout, stderr, p.returncode)\n        else:\n            return stdout", "response": "Runs a program with the arguments of args and returns the output of the process."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_programs():\n    programs = []\n    os.environ['PATH'] += os.pathsep + os.getcwd()\n    for p in os.environ['PATH'].split(os.pathsep):\n        if path.isdir(p):\n            for f in os.listdir(p):\n                if _is_executable(path.join(p, f)):\n                    yield f", "response": "Returns a generator that yields the available executable files"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _underscore_run_program(name, *args, **kwargs):\n    if name in get_programs() or kwargs.get(\"shell\", False):\n        return _run_program(name, *args, **kwargs)\n    else:\n        raise ProgramNotFoundException()", "response": "Runs the given python program name using the underscore - style shell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refresh_listing():\n    for program in get_programs():\n        if re.match(r'^[a-zA-Z_][a-zA-Z_0-9]*$', program) is not None:\n            globals()[program] = partial(_run_program, program)\n\n    globals()[\"_\"] = _underscore_run_program", "response": "Refreshes the list of programs attached to the perform module from\n    the path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload le lemmatiseur localement from file.", "response": "def load(path=None):\n        \"\"\" Compile le lemmatiseur localement\n        \"\"\"\n        if path is None:\n            path = os.path.join(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"data\"))\n            path = os.path.join(path, \"compiled.pickle\")\n        with open(path, \"rb\") as file:\n            return load(file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns de la cha\u00eene a peut subir une assimilation.", "response": "def assims(self, mot):\n        \"\"\" Cherche si la cha\u00eene a peut subir une assimilation, renvoie cette cha\u00eene \u00e9ventuellement assimil\u00e9e.\n\n        :param mot: Mot pour lequel on doit v\u00e9rifier des assimilations\n        :type mot: str\n        :return: Mot assimil\u00e9\n        :rtype: str\n        \"\"\"\n        for replaced, replacement in self._assimsq.items():\n            if mot.startswith(replaced):\n                mot = mot.replace(replaced, replacement)\n                return mot\n        return mot"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lemmatise_multiple(self, string, pos=False, get_lemma_object=False, as_list=True):\n        mots = SPACES.split(string)\n        resultats = [self.lemmatise(mot, pos=pos, get_lemma_object=get_lemma_object) for mot in mots if mot]\n        if as_list:\n            resultats = [list(r) for r in resultats]\n        return resultats", "response": "Lemmatise un list de lista de la list de la POS."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _lemmatise_roman_numerals(self, form, pos=False, get_lemma_object=False):\n        if estRomain(form):\n            _lemma = Lemme(\n                cle=form, graphie_accentuee=form, graphie=form, parent=self, origin=0, pos=\"a\",\n                modele=self.modele(\"inv\")\n            )\n            yield Lemmatiseur.format_result(\n                form=form,\n                lemma=_lemma,\n                with_pos=pos,\n                raw_obj=get_lemma_object\n            )\n\n        if form.upper() != form:\n            yield from self._lemmatise_roman_numerals(form.upper(), pos=pos, get_lemma_object=get_lemma_object)", "response": "Lemmatise un mot f si c est un nombre romain\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _lemmatise_desassims(self, f, *args, **kwargs):\n        forme_assimilee = self.desassims(f)\n        if forme_assimilee != f:\n            for proposal in self._lemmatise(forme_assimilee, *args, **kwargs):\n                yield proposal", "response": "Lemmatise un mot f avec sa d\u00e9sassimilation\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lemmatise(self, f, pos=False, get_lemma_object=False, lower=True):\n        if lower:\n            # We do not run numeral on lower\n            yield from self._lemmatise_roman_numerals(f, pos=pos, get_lemma_object=get_lemma_object)\n\n            # We run on the lower version\n            if f.lower() != f:\n                yield from self.lemmatise(f.lower(), pos=pos, get_lemma_object=get_lemma_object, lower=False)\n\n        f = deramise(f)\n        yield from self._lemmatise(f, pos=pos, get_lemma_object=get_lemma_object)\n        yield from self._lemmatise_assims(f, pos=pos, get_lemma_object=get_lemma_object)\n        yield from self._lemmatise_desassims(f, pos=pos, get_lemma_object=get_lemma_object)\n        yield from self._lemmatise_contractions(f, pos=pos, get_lemma_object=get_lemma_object)\n\n        yield from self._lemmatise_suffixe(f, pos=pos, get_lemma_object=get_lemma_object)", "response": "Lemmatise un mot f"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconnects and login to an FTP server and return ftplib. FTP object.", "response": "def connect(host, port, username, password):\n        \"\"\"Connect and login to an FTP server and return ftplib.FTP object.\"\"\"\n        # Instantiate ftplib client\n        session = ftplib.FTP()\n\n        # Connect to host without auth\n        session.connect(host, port)\n\n        # Authenticate connection\n        session.login(username, password)\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading a remote file on the fto sever to a local directory.", "response": "def get(self, remote, local=None, keep_dir_structure=False):\n        \"\"\"\n        Download a remote file on the fto sever to a local directory.\n\n        :param remote: File path of remote source file\n        :param local: Directory of local destination directory\n        :param keep_dir_structure: If True, replicates the remote files folder structure\n        \"\"\"\n        if local and os.path.isdir(local):\n            os.chdir(local)\n\n        elif keep_dir_structure:\n            # Replicate the remote files folder structure\n            for directory in remote.split(os.sep)[:-1]:\n                if not os.path.isdir(directory):\n                    os.mkdir(directory)\n                os.chdir(directory)\n\n        # Change to the correct directory if remote is a path not just a name\n        if os.sep in remote:\n            directory, file_name = remote.rsplit(os.sep, 1)\n            self.chdir(directory)\n        else:\n            file_name = remote\n\n        # Download the file and get response\n        response = self._retrieve_binary(file_name)\n\n        # Rename downloaded files if local is a file_name string\n        if local and isinstance(local, str):\n            os.rename(file_name, local)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef chdir(self, directory_path, make=False):\n        if os.sep in directory_path:\n            for directory in directory_path.split(os.sep):\n                if make and not self.directory_exists(directory):\n                    try:\n                        self.session.mkd(directory)\n                    except ftplib.error_perm:\n                        # Directory already exists\n                        pass\n                self.session.cwd(directory)\n        else:\n            self.session.cwd(directory_path)", "response": "Change directories and optionally make the directory if it doesn t exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef listdir(self, directory_path=None, hidden_files=False):\n        # Change current directory if a directory path is specified, otherwise use current\n        if directory_path:\n            self.chdir(directory_path)\n\n        # Exclude hidden files\n        if not hidden_files:\n            return [path for path in self.session.nlst() if not path.startswith('.')]\n\n        # Include hidden files\n        else:\n            return self.session.nlst()", "response": "Return a list of files and directories in a given directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the file named filename from the server.", "response": "def delete(self, file_path):\n        \"\"\"Remove the file named filename from the server.\"\"\"\n        if os.sep in file_path:\n            directory, file_name = file_path.rsplit(os.sep, 1)\n            self.chdir(directory)\n            return self.session.delete(file_name)\n\n        else:\n            return self.session.delete(file_path)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef directory_exists(self, directory):\n        file_list = []\n        self.session.retrlines('LIST', file_list.append)\n        return any(f.split()[-1] == directory and f.upper().startswith('D') for f in file_list)", "response": "Check if directory exists in current location"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _retrieve_binary(self, file_name):\n        with open(file_name, 'wb') as f:\n            return self.session.retrbinary('RETR ' + file_name, f.write)", "response": "Retrieve a file in binary transfer mode."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _store_binary(self, local_path, remote):\n        # Destination directory\n        dst_dir = os.path.dirname(remote)\n\n        # Destination file name\n        dst_file = os.path.basename(remote)\n\n        # File upload command\n        dst_cmd = 'STOR {0}'.format(dst_file)\n\n        with open(local_path, 'rb') as local_file:\n            # Change directory if needed\n            if dst_dir != dst_file:\n                self.chdir(dst_dir, make=True)\n\n            # Upload file & return response\n            return self.session.storbinary(dst_cmd, local_file)", "response": "Store a file in binary via ftp."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating password when set", "response": "def clean_new_password2(self):\n        \"\"\"Validate password when set\"\"\"\n        password1 = self.cleaned_data.get('new_password1')\n        password2 = self.cleaned_data.get('new_password2')\n        if password1 or password2:\n            if password1 != password2:\n                raise forms.ValidationError(\n                    self.error_messages['password_mismatch'],\n                    code='password_mismatch',\n                )\n            password_validation.validate_password(password2, self.instance)\n        return password2"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates that the given baton binaries directory contains all of the required binaries.", "response": "def validate_baton_binaries_location(baton_binaries_directory: str) -> Optional[Exception]:\n        \"\"\"\n        Validates that the given directory contains the baton binaries required to use the runner.\n        :param baton_binaries_directory: the directory to check\n        :return: exception that describes the issue else `None` if no issues\n        \"\"\"\n        if os.path.isfile(baton_binaries_directory):\n            return ValueError(\"The given baton binary directory (%s) is not a directory! Be sure to provide the path \"\n                              \"to the directory containing the baton binaries, not the binary named `baton`\")\n\n        for baton_binary in BatonBinary:\n            binary_location = os.path.join(baton_binaries_directory, baton_binary.value)\n            if not (os.path.isfile(binary_location) and os.access(binary_location, os.X_OK)):\n                return ValueError(\"The given baton binary directory (%s) did not contain all of the required binaries \"\n                                  \"with executable permissions (%s)\"\n                                  % (baton_binaries_directory, [name.value for name in BatonBinary]))\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _raise_any_errors_given_in_baton_out(baton_out_as_json: List[Dict]):\n        if not isinstance(baton_out_as_json, list):\n            baton_out_as_json = [baton_out_as_json]\n\n        for baton_item_as_json in baton_out_as_json:\n            if BATON_ERROR_PROPERTY in baton_item_as_json:\n                error = baton_item_as_json[BATON_ERROR_PROPERTY]\n                error_message = error[BATON_ERROR_MESSAGE_KEY]\n                error_code = error[BATON_ERROR_CODE_KEY]\n\n                # Working around baton issue: https://github.com/wtsi-npg/baton/issues/155\n                if error_code == IRODS_ERROR_USER_FILE_DOES_NOT_EXIST or \\\n                        (error_code == IRODS_ERROR_CAT_INVALID_ARGUMENT and \"Failed to modify permissions\" in error_message):\n                    raise FileNotFoundError(error_message)\n                elif error_code == IRODS_ERROR_CATALOG_ALREADY_HAS_ITEM_BY_THAT_NAME \\\n                        or error_code == IRODS_ERROR_CAT_SUCCESS_BUT_WITH_NO_INFO:\n                    raise KeyError(error_message)\n                else:\n                    raise RuntimeError(error_message)", "response": "Raises any errors that baton has expressed in its output."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_baton_query(self, baton_binary: BatonBinary, program_arguments: List[str]=None, input_data: Any=None) \\\n            -> List[Dict]:\n        \"\"\"\n        Runs a baton query.\n        :param baton_binary: the baton binary to use\n        :param program_arguments: arguments to give to the baton binary\n        :param input_data: input data to the baton binary\n        :return: parsed serialization returned by baton\n        \"\"\"\n        if program_arguments is None:\n            program_arguments = []\n\n        baton_binary_location = os.path.join(self._baton_binaries_directory, baton_binary.value)\n        program_arguments = [baton_binary_location] + program_arguments\n\n        _logger.info(\"Running baton command: '%s' with data '%s'\" % (program_arguments, input_data))\n        start_at = time.monotonic()\n        baton_out = self._run_command(program_arguments, input_data=input_data)\n        time_taken_to_run_query = time.monotonic() - start_at\n        _logger.debug(\"baton output (took %s seconds, wall time): %s\" % (time_taken_to_run_query, baton_out))\n\n        if len(baton_out) == 0:\n            return []\n        if len(baton_out) > 0 and baton_out[0] != '[':\n            # If information about multiple files is returned, baton does not return valid JSON - it returns a line\n            # separated list of JSON, where each line corresponds to a different file\n            baton_out = \"[%s]\" % baton_out.replace('\\n', ',')\n\n        baton_out_as_json = json.loads(baton_out)\n        BatonRunner._raise_any_errors_given_in_baton_out(baton_out_as_json)\n\n        return baton_out_as_json", "response": "Runs a baton query."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning a command as a subprocess.", "response": "def _run_command(self, arguments: List[str], input_data: Any=None, output_encoding: str=\"utf-8\") -> str:\n        \"\"\"\n        Run a command as a subprocess.\n\n        Ignores errors given over stderr if there is output on stdout (this is the case where baton has been run\n        correctly and has expressed the error in it's JSON out, which can be handled more appropriately upstream to this\n        method.)\n        :param arguments: the arguments to run\n        :param input_data: the input data to pass to the subprocess\n        :param output_encoding: optional specification of the output encoding to expect\n        :return: the process' standard out\n        \"\"\"\n        process = subprocess.Popen(arguments, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)\n\n        if isinstance(input_data, List):\n            for to_write in input_data:\n                to_write_as_json = json.dumps(to_write)\n                process.stdin.write(str.encode(to_write_as_json))\n            input_data = None\n        else:\n            input_data = str.encode(json.dumps(input_data))\n\n        timeout_in_seconds = self.timeout_queries_after.total_seconds() if self.timeout_queries_after is not None \\\n            else None\n        out, error = process.communicate(input=input_data, timeout=timeout_in_seconds)\n        if len(out) == 0 and len(error) > 0:\n            raise RuntimeError(error)\n\n        return out.decode(output_encoding).rstrip()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addresses(self, fields=None):\n\n        if fields is None:\n            fields = ','.join(DEFAULT_ADDRESS_FIELDS)\n\n        if getattr(self, '_addresses', None) is None:\n            self._addresses = self._client._query_api(\n                'addresses/',\n                postcode=self.normalised,\n                fields=fields)\n        return self._addresses", "response": "Returns a list of addresses associated with the postcode."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_random_string(template_dict, key='start'):\n\n    data = template_dict.get(key)\n\n    #if isinstance(data, list):\n    result = random.choice(data)\n    #else:\n        #result = random.choice(data.values())\n\n    for match in token_regex.findall(result):\n        word = generate_random_string(template_dict, match) or match\n        result = result.replace('{{{0}}}'.format(match), word)\n\n    return result", "response": "Generates a random excuse from a simple template dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates random BOFH themed technical excuses!", "response": "def bofh_excuse(how_many=1):\n    \"\"\"Generate random BOFH themed technical excuses!\n\n    Args:\n        how_many: Number of excuses to generate. (Default: 1)\n\n    Returns:\n        A list of BOFH excuses.\n    \"\"\"\n\n    excuse_path = os.path.join(os.path.dirname(__file__), 'bofh_excuses.json')\n    with open(excuse_path, 'r') as _f:\n        excuse_dict = json.load(_f)\n\n    return [generate_random_string(excuse_dict) for _ in range(int(how_many))]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_process(daemon, name, callback, *callbackParams):\n    bp = Process(daemon=daemon, name=name, target=callback, args=callbackParams)\n    return bp", "response": "\u521b\u5efa\u8fdb\u7a0b\n    :param daemon: True\u4e3b\u8fdb\u7a0b\u5173\u95ed\u800c\u5173\u95ed, False\u4e3b\u8fdb\u7a0b\u5fc5\u987b\u7b49\u5f85\u5b50\u8fdb\u7a0b\u7ed3\u675f\n    :param name: \u8fdb\u7a0b\u540d\u79f0\n    :param callback: \u56de\u8c03\u51fd\u6570\n    :param callbackParams: \u56de\u8c03\u51fd\u6570\u53c2\u6570\n    :return: \u8fd4\u56de\u4e00\u4e2a\u8fdb\u7a0b\u5bf9\u8c61"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_args(argv=None):\n    parser = ArgumentParser()\n    parser.add_argument('--replay-file', dest=\"replay_file\", type=str, required=True)\n\n    options = parser.parse_args(argv)\n    return options", "response": "Parse command line options."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the current set of waypoints active from boatd.", "response": "def get_current_waypoints(boatd=None):\n    '''\n    Get the current set of waypoints active from boatd.\n\n    :returns: The current waypoints\n    :rtype: List of Points\n    '''\n\n    if boatd is None:\n        boatd = Boatd()\n\n    content = boatd.get('/waypoints')\n    return [Point(*coords) for coords in content.get('waypoints')]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_home_position(boatd=None):\n    '''\n    Get the current home position from boatd.\n\n    :returns: The configured home position\n    :rtype: Points\n    '''\n\n    if boatd is None:\n        boatd = Boatd()\n\n    content = boatd.get('/waypoints')\n    home = content.get('home', None)\n    if home is not None:\n        lat, lon = home\n        return Point(lat, lon)\n    else:\n        return None", "response": "Get the current home position from boatd."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the result of a GET request to endpoint on boatd", "response": "def get(self, endpoint):\n        '''Return the result of a GET request to `endpoint` on boatd'''\n        json_body = urlopen(self.url(endpoint)).read().decode('utf-8')\n        return json.loads(json_body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nissues a POST request to the specified endpoint and return the result.", "response": "def post(self, content, endpoint=''):\n        '''\n        Issue a POST request with `content` as the body to `endpoint` and\n        return the result.\n        '''\n        url = self.url(endpoint)\n        post_content = json.dumps(content).encode('utf-8')\n        headers = {'Content-Type': 'application/json'}\n        request = Request(url, post_content, headers)\n\n        response = urlopen(request)\n\n        return json.loads(response.read().decode('utf-8'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the direction of the wind in degrees.", "response": "def wind(self):\n        '''\n        Return the direction of the wind in degrees.\n\n        :returns: wind object containing direction bearing and speed\n        :rtype: Wind\n        '''\n        content = self._cached_boat.get('wind')\n        return Wind(\n            Bearing(content.get('absolute')),\n            content.get('speed'),\n            Bearing(content.get('apparent'))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the current position of the boat.", "response": "def position(self):\n        '''\n        Return the current position of the boat.\n\n        :returns: current position\n        :rtype: Point\n        '''\n        content = self._cached_boat\n        lat, lon = content.get('position')\n        return Point(lat, lon)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the angle of the rudder to be angle degrees.", "response": "def set_rudder(self, angle):\n        '''\n        Set the angle of the rudder to be `angle` degrees.\n\n        :param angle: rudder angle\n        :type angle: float between -90 and 90\n        '''\n        angle = float(angle)\n        request = self.boatd.post({'value': float(angle)}, '/rudder')\n        return request.get('result')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_sail(self, angle):\n        '''\n        Set the angle of the sail to `angle` degrees\n\n        :param angle: sail angle\n        :type angle: float between -90 and 90\n        '''\n        angle = float(angle)\n        request = self.boatd.post({'value': float(angle)}, '/sail')\n        return request.get('result')", "response": "Set the angle of the sail to angle degrees\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self, name):\n        '''\n        End the current behaviour and run a named behaviour.\n\n        :param name: the name of the behaviour to run\n        :type name: str\n        '''\n        d = self.boatd.post({'active': name}, endpoint='/behaviours')\n        current = d.get('active')\n        if current is not None:\n            return 'started {}'.format(current)\n        else:\n            return 'no behaviour running'", "response": "Start the current behaviour and run a named behaviour."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _translators(attr, kwargs):\n\n    # Add translators to a function or class\n    def decorator(func):\n        # Make sure we have the attribute\n        try:\n            xlators = getattr(func, attr)\n        except AttributeError:\n            xlators = {}\n            setattr(func, attr, xlators)\n\n        xlators.update(kwargs)\n        return func\n    return decorator", "response": "Decorator which associates a set of translators with a given method."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters a short name for one or more content types.", "response": "def register_types(name, *types):\n    \"\"\"\n    Register a short name for one or more content types.\n    \"\"\"\n\n    type_names.setdefault(name, set())\n    for t in types:\n        # Redirecting the type\n        if t in media_types:\n            type_names[media_types[t]].discard(t)\n\n        # Save the mapping\n        media_types[t] = name\n        type_names[name].add(t)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretrieve a set of all recognized content types for this locale.", "response": "def get_types(self):\n        \"\"\"\n        Retrieve a set of all recognized content types for this\n        translator object.\n        \"\"\"\n\n        # Convert translators into a set of content types\n        content_types = set()\n        for name in self.translators:\n            content_types |= type_names[name]\n\n        return content_types"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def get_search_page(self, term: str):\n        # Uses the BASEURL and also builds link for the page we want using the term given\n        params = {'s': term, 'post_type': 'seriesplan'}\n        async with self.session.get(self.BASEURL, params=params) as response:\n            # If the response is 200 OK\n            if response.status == 200:\n                search = BeautifulSoup(await response.text(), 'lxml')\n                # Return the link that we need\n                return search.find('a', class_='w-blog-entry-link').get('href')\n            else:\n                # Raise an error with the response status\n                raise aiohttp.ClientResponseError(response.status)", "response": "Get the first link from the search term and then the link we want to parse from."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget aliases from parse info.", "response": "def _get_aliases(parse_info):\n        \"\"\"get aliases from parse info.\n\n        :param parse_info: Parsed info from html soup.\n        \"\"\"\n        return [\n            div.string.strip()\n            for div in parse_info.find('div', id='editassociated')\n            if div.string is not None\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_related_series(parse_info):\n        seriesother_tags = [x for x in parse_info.select('h5.seriesother')]\n        sibling_tag = [x for x in seriesother_tags if x.text == 'Related Series'][0]\n        siblings_tag = list(sibling_tag.next_siblings)\n\n        # filter valid tag\n        # valid tag is all tag before following tag\n        # <h5 class=\"seriesother\">Recommendations</h5>\n        valid_tag = []\n        keypoint_found = False\n        for x in siblings_tag:\n            # change keypoint if condition match\n            if x.name == 'h5' and x.attrs['class'] == ['seriesother']:\n                    keypoint_found = True\n\n            if not keypoint_found and x.strip is not None:\n                if x.strip():\n                    valid_tag.append(x)\n            elif not keypoint_found:\n                valid_tag.append(x)\n\n        # only one item found and it is 'N/A\n        if len(valid_tag) == 1:\n            if valid_tag[0].strip() == 'N/A':\n                return None\n\n        # items are combination between bs4 and text\n        # merge and return them as list of text\n        if len(valid_tag) % 2 == 0:\n            zipped_list = zip(valid_tag[::2], valid_tag[1::2])\n            result = []\n            for x in zipped_list:\n                result.append('{} {}'.format(x[0].text, x[1]))\n            return result\n\n        raise ValueError(\"Valid tag isn't recognizeable.\\n{}\".format(\"\\n\".join(valid_tag)))", "response": "get related_series from parse info."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def get_first_search_result(self, term: str):\n        # Uses the other method in the class\n        # to search the search page for the actual page that we want\n        to_parse = await self.get_search_page(term)\n\n        async with self.session.get(to_parse) as response:\n            # If the response is OK\n            if response.status == 200:\n                # The information to parse\n                parse_info = BeautifulSoup(await response.text(), 'lxml')\n                # Artists,\n                # defined up here so we can account for if it is None, e.g. for web novels ect\n                artists = parse_info.find('a', class_='genre', id='artiststag')\n                # English publisher,\n                # defined here so we can account for it if None,\n                # e.g. for works unlicensed in English\n                english_publisher = parse_info.find('a', class_='genre', id='myepub')\n                # Publisher,\n                # defined here so we can account for it if it's None, e.g. not published\n                publisher = parse_info.find('a', class_='genre', id='myopub')\n                # Accounting for if Artists/English Publisher/Publisher is None\n                if artists is not None:\n                    artists = artists.string\n                if english_publisher is not None:\n                    try:\n                        english_publisher = english_publisher.children.string\n                    except AttributeError:\n                        # english publisher's children tag is not string.\n                        english_publisher = list(english_publisher.children)\n                        if len(english_publisher) == 1:\n                            english_publisher = english_publisher[0]\n                if publisher is not None:\n                    publisher = publisher.string\n\n                # The data to return to the user, in a dictionary\n                no_img_found_url = 'http://www.novelupdates.com/img/noimagefound.jpg'\n                data = {'title': self._get_title(parse_info=parse_info),\n                        'cover': (\n                            None\n                            if parse_info.find('img').get('src') == no_img_found_url\n                            else parse_info.find('img').get('src')\n                        ),\n                        'type': parse_info.find('a', class_='genre type').string,\n                        'genre': (\n                            [\n                                x.string\n                                for x in list(\n                                    parse_info.find_all('div', id='seriesgenre')[0].children\n                                )\n                                if len(x.string.strip()) > 0\n                            ]\n                        ),\n                        'tags': (\n                            [\n                                x.string\n                                for x in list(\n                                    parse_info.find_all('div', id='showtags')[0].children\n                                )\n                                if len(x.string.strip()) > 0\n                            ]\n                        ),\n                        'language': parse_info.find('a', class_='genre lang').string,\n                        'authors': list(\n                            set([x.string for x in parse_info.find_all('a', id='authtag')])\n                        ),\n                        'artists': artists,\n                        'year': parse_info.find('div', id='edityear').string.strip(),\n                        'novel_status': self._get_novel_status(parse_info=parse_info),\n                        'licensed': (\n                            True\n                            if parse_info.find('div', id='showlicensed').string.strip() == 'Yes'\n                            else False\n                        ),\n                        'completely_translated': (\n                            True\n                            if len(\n                                list(parse_info.find('div', id='showtranslated').descendants)\n                            ) > 1\n                            else False\n                        ),\n                        'publisher': publisher,\n                        'english_publisher': english_publisher,\n                        'description': (\n                            ' '.join(\n                                [\n                                    x.string.strip()\n                                    for x in list(\n                                        parse_info.find('div', id='editdescription').children\n                                    )\n                                    if x.string.strip()\n                                ]\n                            )\n                        ),\n                        'aliases': self._get_aliases(parse_info=parse_info),\n                        'link': to_parse,\n                        'related_series': self._get_related_series(parse_info=parse_info)}\n                # Returning the dictionary with all of the information\n                # from novelupdates that we parsed\n                return data\n            else:\n                # Raise an error with the response status\n                raise aiohttp.ClientResponseError(response.status)", "response": "This function will parse the search page for the term and return the first search result."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_output(self, state):\n        if state:\n            self.instr.write('OUTP ON')\n        else:\n            self.instr.write('OUTP OFF')", "response": "Sets whether the function generator is outputting a voltage."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the func generator to frequency modulation with external modulation.", "response": "def set_fm_ext(self, freq, amplitude, peak_freq_dev=None,\n                   output_state=True):\n        \"\"\"Sets the func generator to frequency modulation with external modulation.\n        freq is the carrier frequency in Hz.\"\"\"\n\n        if peak_freq_dev is None:\n            peak_freq_dev = freq\n        commands = ['FUNC SIN',  # set to output sine functions\n                    'FM:STAT ON',\n                    'FREQ {0}'.format(freq),\n                    'FM:SOUR EXT',\n                    # 'FM:FREQ {0}'.format(freq),\n                    'FM:DEV {0}'.format(peak_freq_dev),\n                    'VOLT {0}'.format(amplitude),\n                    'VOLT:OFFS 0']   # set to frequency modulation\n        if output_state is True:\n            commands.append('OUTP ON')\n        else:\n            commands.append('OUTP OFF')\n        command_string = '\\n'.join(commands)\n        print_string = '\\n\\t' + command_string.replace('\\n', '\\n\\t')\n        logging.info(print_string)\n        self.instr.write(command_string)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_burst(self, freq, amplitude, period, output_state=True):\n\n        ncyc = int(period*freq)\n        commands = ['FUNC SIN',\n                    'BURS:STAT ON',\n                    'BURS:MODE TRIG',  # external trigger\n                    'TRIG:SOUR EXT',\n                    'TRIG:SLOP POS',\n                    'FREQ {0}'.format(freq),\n                    'VOLT {0}'.format(amplitude),\n                    'VOLT:OFFS 0',\n                    'BURS:NCYC {0}'.format(ncyc)]\n        if output_state is True:\n            commands.append('OUTP ON')\n        else:\n            commands.append('OUTP OFF')\n\n        command_string = '\\n'.join(commands)\n        print_string = '\\n\\t' + command_string.replace('\\n', '\\n\\t')\n        logging.info(print_string)\n        self.instr.write(command_string)", "response": "Sets the func generator to burst mode with external trigerring."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprogram the function generator to output the arbitrary waveform.", "response": "def set_arbitrary(self, freq, low_volt, high_volt, output_state=True):\n        \"\"\"Programs the function generator to output the arbitrary waveform.\"\"\"\n        commands = ['FUNC USER',\n                    'BURS:STAT OFF',\n                    'SWE:STAT OFF',\n                    'FM:STAT OFF',\n                    'FREQ {0}'.format(freq),\n                    'VOLT:HIGH {0}'.format(high_volt),\n                    'VOLT:LOW {0}'.format(low_volt),\n                    ]\n        if output_state is True:\n            commands.append('OUTP ON')\n        else:\n            commands.append('OUTP OFF')\n\n        command_string = '\\n'.join(commands)\n        print_string = '\\n\\t' + command_string.replace('\\n', '\\n\\t')\n        logging.info(print_string)\n        self.instr.write(command_string)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_continuous(self, freq, amplitude, offset, output_state=True):\n        commands = ['MODL 0',       #disable any modulation\n                    'FREQ {0}'.format(freq)\n                    ]\n\n        if freq > 4.05e9:\n            commands.append('AMPH {0}'.format(amplitude)) #set rear RF doubler amplitude\n            if offset > 0.0:\n                print('HIGH FREQUENCY OUTPUT IS AC ONLY')\n            if output_state is True:\n                commands.append('ENBH 1') #enable output\n            else:\n                commands.append('ENBH 0')\n        elif freq < 62.5e6:\n            commands.extend(['AMPL {0}'.format(amplitude), 'OFSL {0}'.format(offset)]) #set front BNC amplitude\n            if output_state is True:\n                commands.append('ENBL 1') #enable output\n            else:\n                commands.append('ENBL 0')\n\n        command_string = '\\n'.join(commands)\n        print_string = '\\n\\t' + command_string.replace('\\n', '\\n\\t')\n        logging.info(print_string)\n        self.instr.write(command_string)", "response": "Programs the Stanford MW function generator to output a continuous sine wave."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_freqsweep_ext(self, amplitude, sweep_low_end, sweep_high_end, offset=0.0, output_state=True):\n\n        sweep_deviation = round(abs(sweep_low_end - sweep_high_end)/2.0,6)\n        freq = sweep_low_end + sweep_deviation\n        commands = ['TYPE 3', #set to sweep\n                    'SFNC 5',  #external modulation\n                    'FREQ {0}'.format(freq),\n                    'SDEV {0}'.format(sweep_deviation),\n                    'MODL 1'   #enable modulation\n                    ]\n        if freq > 4.05e9:\n            commands.append('AMPH {0}'.format(amplitude)) #set rear RF doubler amplitude\n            if offset > 0.0:\n                print('HIGH FREQUENCY OUTPUT IS AC ONLY')\n            if output_state is True:\n                commands.append('ENBH 1') #enable output\n            else:\n                commands.append('ENBH 0')\n        elif freq < 62.5e6:\n            commands.extend(['AMPL {0}'.format(amplitude), 'OFSL {0}'.format(offset)]) #set front BNC amplitude\n            if output_state is True:\n                commands.append('ENBL 1') #enable output\n            else:\n                commands.append('ENBL 0')\n\n        command_string = '\\n'.join(commands)\n        print_string = '\\n\\t' + command_string.replace('\\n', '\\n\\t')\n        logging.info(print_string)\n        self.instr.write(command_string)", "response": "Sets the Stanford MW function generator to freq modulation with external modulation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_output(self, state):\n        freq = float(self.instr.query('FREQ?'))\n        if freq > 4.05e9:\n            if state:\n                self.instr.write('ENBH 1') #enable output\n            else:\n                self.instr.write('ENBH 0')\n        elif freq < 62.5e6:\n            if state:\n                self.instr.write('ENBL 1') #enable output\n            else:\n                self.instr.write('ENBL 0')", "response": "Sets whether the function generator is outputting a voltage."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef disable_all(self, disable):\n        commands = ['ENBH 0', #disable high freq. rear output\n                    'ENBL 0', #disable low freq. front bnc\n                    'MODL 0'   #disable modulation\n                    ]\n        command_string = '\\n'.join(commands)\n        print_string = '\\n\\t' + command_string.replace('\\n', '\\n\\t')\n        logging.info(print_string)\n        if disable:\n            self.instr.write(command_string)", "response": "Disables all modulation and outputs of the Standford MW func. generator"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_output(self, state, channel=2):\n        if state:\n            self.instr.write(':OUTP{0} ON'.format(channel))\n        else:\n            self.instr.write(':OUTP{0} OFF'.format(channel))", "response": "Sets whether the function generator is outputting a voltage."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_continuous(self, freq, amplitude, offset, phase, channel=2):\n        commands = [':SOUR{0}:APPL:SIN '.format(channel),\n                    '{0},'.format(freq),\n                    '{0},'.format(amplitude),\n                    '{0},'.format(offset),\n                    '{0}'.format(phase),\n                    ]\n\n        command_string = ''.join(commands)\n        logging.info(command_string)\n        self.instr.write(command_string)", "response": "Programs the function generator to output a continuous sine wave."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef haversine(lng1, lat1, lng2, lat2):\n    # Convert coordinates to floats.\n    lng1, lat1, lng2, lat2 = map(float, [lng1, lat1, lng2, lat2])\n\n    # Convert to radians from degrees\n    lng1, lat1, lng2, lat2 = map(math.radians, [lng1, lat1, lng2, lat2])\n\n    # Compute distance\n    dlng = lng2 - lng1\n    dlat = lat2 - lat1\n    a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlng/2)**2\n    c = 2 * math.asin(math.sqrt(a))\n    km = 6367 * c\n    return km", "response": "Compute km by geo - coordinates\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calc_distance(lng1, lat1, lng2, lat2):\n    ra = 6378.140  # \u8d64\u9053\u534a\u5f84 (km)\n    rb = 6356.755  # \u6781\u534a\u5f84 (km)\n    flatten = (ra - rb) / ra  # \u5730\u7403\u6241\u7387\n    rad_lat_1 = math.radians(lat1)\n    rad_lng_1 = math.radians(lng1)\n    rad_lat_2 = math.radians(lat2)\n    rad_lng_2 = math.radians(lng2)\n    p1 = math.atan(rb / ra * math.tan(rad_lat_1))\n    p2 = math.atan(rb / ra * math.tan(rad_lat_2))\n    xx = math.acos(math.sin(p1) * math.sin(p2) + math.cos(p1) * math.cos(p2) * math.cos(rad_lng_1 - rad_lng_2))\n    c1 = (math.sin(xx) - xx) * (math.sin(p1) + math.sin(p2)) ** 2 / math.cos(xx / 2) ** 2\n    c2 = (math.sin(xx) + xx) * (math.sin(p1) - math.sin(p2)) ** 2 / math.sin(xx / 2) ** 2\n    dr = flatten / 8 * (c1 - c2)\n    distance = ra * (xx + dr)\n    return distance", "response": "Calculate distance between two points in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse pip - style requirements files.", "response": "def parse_requires(__fname: str) -> List[str]:\n    \"\"\"Parse ``pip``-style requirements files.\n\n    This is a *very* na\u00efve parser, but very few packages make use of the more\n    advanced features.  Support for other features will be added only when\n    packages in the wild depend on them.\n\n    Args:\n        __fname: Base file to pass\n    Returns:\n        Parsed dependencies\n    \"\"\"\n    deps = []\n    with open(__fname) as req_file:\n        entries = [s.split('#')[0].strip() for s in req_file.readlines()]\n        for dep in entries:\n            if not dep:\n                continue\n            elif dep.startswith('-r '):\n                include = dep.split()[1]\n                if '/' not in include:\n                    include = path.join(path.dirname(__fname), include)\n                deps.extend(parse_requires(include))\n                continue\n            elif ';' in dep:\n                dep, marker = [s.strip() for s in dep.split(';')]\n                # Support for other markers will be added when they\u2019re actually\n                # found in the wild\n                match = re.fullmatch(r\"\"\"\n                        (?:python_version)  # Supported markers\n                        \\s*\n                        (?:<=?|==|>=?)  # Supported comparisons\n                        \\s*\n                        (?P<quote>(?:'|\"))(?:[\\d\\.]+)(?P=quote)  # Test\n                    \"\"\", marker, re.VERBOSE)\n                if not match:\n                    raise ValueError('Invalid marker {!r}'.format(marker))\n                env = {\n                    '__builtins__': {},\n                    'python_version': '{}.{}'.format(*version_info[:2]),\n                }\n                if not eval(marker, env):  # pylint: disable=eval-used\n                    continue\n            deps.append(dep)\n    return deps"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating an email message object which implements the email. message. Message interface and which has the files to be shared by the user.", "response": "def create_email(filepaths, collection_name):\n    \"\"\"Create an email message object which implements the\n    email.message.Message interface and which has the files to be shared\n    attached to it.\n\n    \"\"\"\n    outer = MIMEMultipart()\n    outer.preamble = 'Here are some files for you'\n\n    def add_file_to_outer(path):\n        if not os.path.isfile(path):\n            return\n\n        # Guess the content type based on the file's extension.  Encoding\n        # will be ignored, although we should check for simple things like\n        # gzip'd or compressed files.\n        ctype, encoding = mimetypes.guess_type(path)\n        if ctype is None or encoding is not None:\n            # No guess could be made, or the file is encoded (compressed), so\n            # use a generic bag-of-bits type.\n            ctype = 'application/octet-stream'\n        maintype, subtype = ctype.split('/', 1)\n\n        if maintype == 'image':\n            fp = open(path, 'rb')\n            msg = MIMEImage(fp.read(), _subtype=subtype)\n            fp.close()\n        elif maintype == 'audio':\n            fp = open(path, 'rb')\n            msg = MIMEAudio(fp.read(), _subtype=subtype)\n            fp.close()\n        elif maintype == 'text':\n            # We do this to catch cases where text files have\n            # an encoding we can't guess correctly.\n            try:\n                fp = open(path, 'r')\n                msg = MIMEText(fp.read(), _subtype=subtype)\n                fp.close()\n            except UnicodeDecodeError:\n                fp = open(path, 'rb')\n                msg = MIMEBase(maintype, subtype)\n                msg.set_payload(fp.read())\n                encoders.encode_base64(msg)\n                fp.close()\n        else:\n            fp = open(path, 'rb')\n            msg = MIMEBase(maintype, subtype)\n            msg.set_payload(fp.read())\n            fp.close()\n            # Encode the payload using Base64\n            encoders.encode_base64(msg)\n\n        # Set the filename parameter\n        msg.add_header('Content-Disposition', 'attachment',\n                filename=os.path.basename(path))\n        outer.attach(msg)\n\n    outer.attach(MIMEText(\"Here are some files I've thrown at you.\"))\n    \n    for path in filepaths:\n        add_file_to_outer(path)\n\n    return outer"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning only the first time SimpleSteem() is instantiated. Prompts user for the values that are then written to config. py", "response": "def setup (self):\n        ''' Runs only the first time SimpleSteem() \n        is instantiated. Prompts user for the values\n        that are then written to config.py\n        '''\n        mainaccount = self.add_quotes(self.enter_config_value(\"mainaccount\", 'ned'))\n        keys = self.enter_config_value(\"keys\", '[]')\n        nodes = self.enter_config_value(\"nodes\", \n                '[\"https://steemd.minnowsupportproject.org\",'\n                + '\"https://rpc.buildteam.io\",'\n                + '\"https://rpc.curiesteem.com\",'\n                + '\"https://gtg.steem.house:8090\",'\n                + '\"https://rpc.steemliberator.com\",'\n                + '\"https://rpc.steemviz.com\",'\n                + '\"https://steemd.privex.io\"]')\n        client_id = self.add_quotes(self.enter_config_value(\"client_id\"))\n        client_secret = self.add_quotes(self.enter_config_value(\"client_secret\"))\n        callback_url = self.add_quotes(self.enter_config_value(\"callback_url\"))\n        permissions = self.add_quotes(self.enter_config_value(\"permissions\", \"login,offline,vote\"))\n        logpath = self.add_quotes(self.enter_config_value(\"logpath\", \"\"))\n        screenmode = self.add_quotes(self.enter_config_value(\"screenmode\", \"quiet\"))\n        self.make(mainaccount=mainaccount, keys=keys, nodes=nodes, client_id=client_id, \n            client_secret=client_secret, callback_url=callback_url, permissions=permissions,\n            logpath=logpath, screenmode=screenmode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates the as variable and value pairs", "response": "def make(self, **kwargs):\n        ''' takes the arguments and writes them as \n        variable / value pairs to config.py\n        '''\n        configpath = os.path.dirname(os.path.abspath(__file__)) + \"/config.py\"\n        print (\"Writing to \" + configpath)\n        with open(configpath, 'w+') as fh:\n            try:\n                fh.write(\"#!/usr/bin/python3\\n\\n\")\n            except Exception as e:\n                print(e)\n            else:\n                for key, value in kwargs.items():\n                    fh.write(key + ' = ' + value + \"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprompt user for a value for a key and returns it.", "response": "def enter_config_value(self, key, default=\"\"):\n        ''' Prompts user for a value\n        '''\n        value = input('Please enter a value for ' + key + ': ')\n        if value:\n            return value\n        else:\n            return default"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef colored(text, color=None, on_color=None, attrs=None):\n    if os.getenv('ANSI_COLORS_DISABLED') is None:\n        fmt_str = '\\033[1;%dm%s'\n        if color is not None:\n            text = fmt_str % (colors[color], text)\n\n        if on_color is not None:\n            text = fmt_str % (highlights[on_color], text)\n\n        if attrs is not None:\n            for attr in attrs:\n                text = fmt_str % (attributes[attr], text)\n\n        reset = '\\033[1;m'\n        text += reset\n\n    return text", "response": "Colorize text.\n\n    Available text colors:\n        red, green, yellow, blue, magenta, cyan, white.\n\n    Available text highlights:\n        on_red, on_green, on_yellow, on_blue, on_magenta, on_cyan, on_white.\n\n    Available attributes:\n        bold, dark, underline, blink, reverse, concealed.\n\n    Example:\n        colored('Hello, World!', 'red', 'on_grey', ['blue', 'blink'])\n        colored('Hello, World!', 'green')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef combine_dicts(*args, **kwargs):\n    dicts = [arg for arg in args if isinstance(arg, dict)]\n    dicts.append(kwargs)\n    super_dict = collections.defaultdict(dict)\n\n    for d in dicts:\n        for k, v in iteritems(d):\n            if k:\n                super_dict[k] = v\n    return dict(super_dict)", "response": "Combines all arguments and kwargs into a final dict that is then compiled into a final dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch a dictionary for all keys containing the search string and returns a filtered dictionary of only those keys that contain the search string.", "response": "def get_keys_containing(search_string, input_dict, default=None, first_found=True):\n    \"\"\" Searches a dictionary for all keys containing the search string (as long as the keys are not functions) and\n        returns a filtered dictionary of only those keys\n    \n    :param search_string: str, string we are looking for\n    :param input_dict: dict, dictionary to search through\n    :param default: object, if we find nothing, return this as the default\n    :param first_found: bool, return the first found key\n    :return: dict, dictionary filled with any matching keys\n    \"\"\"\n    output = {}\n    for k, v in iteritems(input_dict):\n        if search_string in k and not callable(k):\n            output[k] = v\n\n    if first_found:\n        try:\n            output = output[next(iter(output))]\n        except StopIteration:\n            pass\n    return output or default"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a list of sets of keys that match the given key in the given dictionary.", "response": "def gen_dict_key_matches(key, dictionary, _path=None, full_path=False):\n    \"\"\" Generates a list of sets of (path, value) where path is a list of keys to access the given value in the given\n        nested dictionary\n\n    :param key: object, given dictionary key we are looking for\n    :param dictionary: dict, query dictionary\n    :param _path: list(str), internal use for the current path to output in case of match.\n    :param full_path: bool, return value or (path, value))\n    :return: Generator[object] or Generator[(list(str), object)], generator of (path, value) or just value\n    \"\"\"\n    if _path is None:\n        _path = []\n    for k, v in iteritems(dictionary):\n        _path.append(k)\n        if k == key:\n            yield (_path, v) if full_path else v\n        elif isinstance(v, dict):\n            for result in gen_dict_key_matches(key, v, _path):\n                yield result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef flatten(it):\n    for x in it:\n        if isinstance(x, collections.Iterable) and not isinstance(x, str):\n            for y in flatten(x):\n                yield y\n        else:\n            yield x", "response": "Flattens any iterable\nAttributeNames and returns a generator of the flattened values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning introspection on the given binary.", "response": "def _run_introspection(self, runtime='', whitelist=[], verbose=False):\n    \"\"\" Figure out which objects are opened by a test binary and are matched by the white list. \n\n    :param runtime: The binary to run. \n    :type runtime: str\n    :param whitelist: A list of regular expressions describing acceptable library names\n    :type whitelist: [str]    \n    \"\"\"\n    found_objects = set()\n    try:\n      # Retrieve list of successfully opened objects\n      strace = subprocess.Popen(['strace', runtime], stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n      (_, stderr) = strace.communicate()\n      opened_objects = set()\n      for line in stderr.split('\\n'):\n        if 'open' in line and 'ENOENT' not in line:\n          start = line.index('\"')\n          end = line.index('\"', start + 1)\n          opened_objects.add(line[start + 1:end])\n\n      # filter opened objects through white list.\n      for obj in opened_objects:\n        for wl in whitelist:\n          m = re.match('.*' + wl + '[\\..*]?', obj)\n          if m:\n            found_objects.add(obj)\n            if verbose:\n              print('Found whitelisted {} at path {}'.format(wl, obj))\n            continue\n    except Exception as e:\n      print e\n\n    return found_objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninjects the configuration of the neccesary libraries into the list of options.", "response": "def inject_config(self, config, from_args):\n    \"\"\"\n    :param config:\n    :type config: list\n    :param from_args:\n    :type from_args: dict\n    \"\"\"\n    # First get required values from labelStore\n    runtime = self._get_runtime()\n    whitelist = self._get_whitelist()\n    #Run introspection on the libraries to retrieve list of libraries to link\n    found_libraries = self._run_introspection(runtime, whitelist, verbose=True)\n    container_path_set=set()\n    for library in found_libraries:\n\n      #disallow duplicate library targets\n      cpath = self.__get_container_path(library)\n      if cpath in container_path_set:\n        continue\n      container_path_set.add(cpath)\n\n      config.append('--volume={0}:{1}'.format(library, cpath))\n    \n    config.extend(['-e', 'LD_LIBRARY_PATH={0}'.format(_container_lib_location)])\n    config.extend(['-e', 'LIBGL_DRIVERS_PATH={0}'.format(_container_lib_location)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a boolean indicating if the code is executed inside softimage.", "response": "def inside_softimage():\n    \"\"\"Returns a boolean indicating if the code is executed inside softimage.\"\"\"\n    try:\n        import maya\n        return False\n    except ImportError:\n        pass\n    try:\n        from win32com.client import Dispatch as disp\n        disp('XSI.Application')\n        return True\n    except:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds new menu item to menu.", "response": "def add_item(self, path, name, icon=None, url=None, order=None, permission=None, active_regex=None):\n        \"\"\"\n        Add new menu item to menu\n\n        :param path: Path of menu\n        :param name: Display name\n        :param icon: CSS icon\n        :param url: link to page\n        :param order: Sort order\n        :param permission:\n        :return:\n        \"\"\"\n        if self.root_item is None:\n            self.root_item = MenuItem('ROOT', 'ROOT')\n\n        root_item = self.root_item\n        current_path = ''\n        for node in path.split('/')[:-1]:\n            if not node:\n                continue\n\n            current_path = '/' + '{}/{}'.format(current_path, node).strip('/')\n            new_root = root_item.child_by_code(node)\n            if not new_root:  # Create menu item if not exists\n                new_root = MenuItem(current_path, name=str(node).capitalize())\n                root_item.add_child(new_root)\n            root_item = new_root\n\n        new_item = MenuItem(path, name, icon, url, order, permission, active_regex)\n\n        current_item = root_item.child_by_code(path.split('/')[-1])\n        if current_item:\n            current_item.merge(new_item)\n        else:\n            root_item.add_child(new_item)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef merge(self, item):\n        self.name = item.name\n\n        if item.icon:\n            self.icon = item.icon\n\n        if item.url:\n            self.url = item.url\n\n        if item.order:\n            self.order = item.order\n\n        if item.permission:\n            self.permission = item.permission", "response": "Merge menu item data into this object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding child to menu item", "response": "def add_child(self, item):\n        \"\"\"Add child to menu item\"\"\"\n        item.depth = self.depth + 1\n        self.childs.append(item)\n        self.childs = sorted(self.childs, key=lambda item: item.order if item.order else 999)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget child MenuItem by its last path code", "response": "def child_by_code(self, code):\n        \"\"\"\n        Get child MenuItem by its last path code\n\n        :param code:\n        :return: MenuItem or None\n        \"\"\"\n        for child in self.childs:\n            if child.path.split('/')[-1] == code:\n                return child\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_active(self, path):\n        if self.url == '/' and self.url == path:\n            return True\n        elif self.url == '/':\n            return False\n\n        if self.url and path.startswith(self.url):\n            return True\n\n        if self.active_regex and re.compile(self.active_regex).match(path):\n            return True\n\n        for child in self.childs:\n            if child.is_active(path):\n                return True\n        return False", "response": "Check if given path is active for current item"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_tabs(self, model_alias, object):\n        model_alias = self.get_model_alias(model_alias)\n        for item in self.tabs[model_alias]:\n            if item.display_filter(object):\n                yield item", "response": "Get all active tabs for given object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a tab for given object and tab code", "response": "def get_tab(self, model_alias, object, tab_code):\n        \"\"\"\n        Get tab for given object and tab code\n\n        :param model_alias:\n        :param object: Object used to render tab\n        :param tab_code: Tab code to use\n        :return:\n        \"\"\"\n        model_alias = self.get_model_alias(model_alias)\n        for item in self.tabs[model_alias]:\n            if item.code == tab_code and item.display_filter(object):\n                return item\n        raise Exception('Given tab does not exits or is filtered')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(self, model_alias, code='general', name=None, order=None, display_filter=None):\n        model_alias = self.get_model_alias(model_alias)\n\n        def wrapper(create_layout):\n            item = TabItem(\n                code=code,\n                create_layout=create_layout,\n                name=name,\n                order=order,\n                display_filter=display_filter\n            )\n\n            if item in self.tabs[model_alias]:\n                raise Exception(\"Tab {} already registered for model {}\".format(code, model_alias))\n\n            self.tabs[model_alias].append(item)\n            self.tabs[model_alias] = sorted(self.tabs[model_alias], key=lambda item: item.order if item.order else 999)\n\n            return create_layout\n        return wrapper", "response": "Register new tab with the model."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_update(self, model_alias, code):\n        model_alias = self.get_model_alias(model_alias)\n\n        def wrapper(update_layout):\n            for item in self.tabs[model_alias]:\n                if item.code == code:\n                    item.layout_updates.append(update_layout)\n            return update_layout\n        return wrapper", "response": "Register update function for a specific tab."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the given tab with given code name order and display_filter.", "response": "def update(self, model_alias, code='general', name=None, order=None, display_filter=None):\n        \"\"\"\n        Update given tab\n\n        :param model_alias:\n        :param code:\n        :param name:\n        :param order:\n        :param display_filter:\n        :return:\n        \"\"\"\n        model_alias = self.get_model_alias(model_alias)\n        for item in self.tabs[model_alias]:\n            if item.code != code:\n                continue\n            if name:\n                item.name = name\n            if order:\n                item.order = order\n            if display_filter:\n                item.display_filter = display_filter\n            break\n        self.tabs[model_alias] = sorted(self.tabs[model_alias], key=lambda item: item.code if item.code else 999)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting model alias if class then convert to alias string", "response": "def get_model_alias(self, model_alias):\n        \"\"\"Get model alias if class then convert to alias string\"\"\"\n        from trionyx.models import BaseModel\n        if inspect.isclass(model_alias) and issubclass(model_alias, BaseModel):\n            config = models_config.get_config(model_alias)\n            return '{}.{}'.format(config.app_label, config.model_name)\n        return model_alias"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving back tab name by code", "response": "def name(self):\n        \"\"\"Give back tab name if is set else generate name by code\"\"\"\n        if self._name:\n            return self._name\n        return self.code.replace('_', ' ').capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets complete layout for given object", "response": "def get_layout(self, object):\n        \"\"\"Get complete layout for given object\"\"\"\n        layout = self.create_layout(object)\n        if isinstance(layout, Component):\n            layout = Layout(layout)\n\n        if isinstance(layout, list):\n            layout = Layout(*layout)\n\n        for update_layout in self.layout_updates:\n            update_layout(layout, object)\n        layout.set_object(object)\n        return layout"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_from_str(name_and_zone: str):\n        if _NAME_ZONE_SEGREGATOR not in name_and_zone:\n            raise ValueError(\"User's zone not set\")\n        name, zone = name_and_zone.split(_NAME_ZONE_SEGREGATOR)\n        if len(name) == 0:\n            raise ValueError(\"User's name cannot be blank\")\n        if len(zone) == 0:\n            raise ValueError(\"User's zone cannot be blank\")\n        return User(name, zone)", "response": "Factory method for creating a user from a string in the form name#zone."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the access controls associated to this entity.", "response": "def access_controls(self, access_controls: Optional[Iterable[AccessControl]]):\n        \"\"\"\n        Sets the access controls associated to this entity.\n        :param access_controls: the access controls (immutable) or `None`\n        \"\"\"\n        if access_controls is not None:\n            access_controls = set(access_controls)\n        self._access_controls = access_controls"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprompting a file name with autocompletion", "response": "def prompt_file(prompt, default=None):\n    \"\"\"Prompt a file name with autocompletion\"\"\"\n\n    def complete(text: str, state):\n        text = text.replace('~', HOME)\n\n        sugg = (glob.glob(text + '*') + [None])[state]\n\n        if sugg is None:\n            return\n\n        sugg = sugg.replace(HOME, '~')\n        sugg = sugg.replace('\\\\', '/')\n\n        if os.path.isdir(sugg) and not sugg.endswith('/'):\n            sugg += '/'\n\n        return sugg\n\n    readline.set_completer_delims(' \\t\\n;')\n    readline.parse_and_bind(\"tab: complete\")\n    readline.set_completer(complete)\n\n    if default is not None:\n        r = input('%s [%r]: ' % (prompt, default))\n    else:\n        r = input('%s: ' % prompt)\n\n    r = r or default\n\n    # remove the autocompletion before quitting for future input()\n    readline.parse_and_bind('tab: self-insert')\n\n    return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isprime(n):\n    n = abs(int(n))\n\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if not n & 1:\n        return False\n\n    # \u5728\u4e00\u822c\u9886\u57df, \u5bf9\u6b63\u6574\u6570n, \u5982\u679c\u75282 \u5230 sqrt(n) \u4e4b\u95f4\u6240\u6709\u6574\u6570\u53bb\u9664, \u5747\u65e0\u6cd5\u6574\u9664, \u5219n\u4e3a\u8d28\u6570.\n    for x in range(3, int(n ** 0.5)+1, 2):\n        if n % x == 0:\n            return False\n\n    return True", "response": "Check the number is prime value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an application context on the server", "response": "def create(self):\n        \"\"\"Create an application context on the server\"\"\"\n\n        self.before_create()\n\n        puts(green('Creating app context'))\n        tdir = os.path.dirname(__file__)\n\n        # Ensure the app context user exists\n        user_ensure(self.user, home='/home/' + self.user)\n        dir_ensure('/home/%s/.ssh' % self.user)\n\n        t = '/home/%s/.ssh/authorized_keys'\n        app_authorized_keys = t % env.user\n        ctx_authorized_keys = t % self.user\n\n        # Ensure the app user has the same authorized_keys as the admin user\n        if file_exists(app_authorized_keys) and \\\n           not file_exists(ctx_authorized_keys):\n            sudo('cp %s %s' % (app_authorized_keys, ctx_authorized_keys))\n            file_attribs(ctx_authorized_keys, mode=755,\n                         owner=self.user, group=self.user)\n\n        # Actions to be performed with the app context user\n        with settings(user=self.user):\n            # Make sure the dot files exist\n            # This is mostly necessary for virtualenvwrapper to work properly\n            for f in ['bashrc', 'bash_profile', 'profile']:\n                lfn = os.path.join(tdir, 'templates', '%s.tmpl' % f)\n                contents = file_local_read(lfn) % self.__dict__\n                rfn = '/home/%s/.%s' % (self.user, f)\n                file_ensure(rfn, owner=self.user, group=self.user)\n                file_update(rfn, lambda _: contents)\n\n            # Make sure the sites folder exists\n            dir_ensure('/home/%s/sites' % self.user)\n\n            # Make sure the app's required folders exist\n            for d in [self.root_dir, self.releases_dir, self.etc_dir,\n                      self.log_dir, self.run_dir, self.shared_dir]:\n                dir_ensure(d)\n\n            # Create the virtualenv\n            run('mkvirtualenv ' + self.name)\n\n        self.after_create()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nuploading an application bundle to the server for a given context", "response": "def upload_release(self):\n        \"\"\"Upload an application bundle to the server for a given context\"\"\"\n        self.before_upload_release()\n\n        with settings(user=self.user):\n            with app_bundle():\n                local_bundle = env.local_bundle\n                env.bundle = '/tmp/' + os.path.basename(local_bundle)\n                file_upload(env.bundle, local_bundle)\n\n            # Extract the bundle into a release folder\n            current_release_link = self.releases_dir + '/current'\n            previous_release_link = self.releases_dir + '/previous'\n            release_dir = self.releases_dir + '/' + env.release\n\n            dir_ensure(release_dir)\n            with cd(release_dir):\n                run('tar -xvf ' + env.bundle)\n\n            # Delete the remote bundle\n            run('rm ' + env.bundle)\n\n            # Remove previous release link\n            if file_exists(previous_release_link):\n                run('rm ' + previous_release_link)\n\n            # Move current to previous\n            if file_exists(current_release_link):\n                run('mv %s %s' % (current_release_link, previous_release_link))\n\n            # Link the current release\n            file_link(release_dir, self.releases_dir + \"/current\")\n\n            # Install app dependencies\n            with cd(current_release_link):\n                with prefix('workon ' + self.name):\n                    run('pip install -r requirements.txt')\n\n        self.after_upload_release()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _print_breakdown(cls, savedir, fname, data):\n        if not os.path.exists(savedir):\n            os.makedirs(savedir)\n\n        with open(os.path.join(savedir, fname), 'w') as fout:\n            fout.write(data)", "response": "Function to print model fixtures into generated file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_json_breakdown(cls, fname):\n        if not os.path.exists(fname):\n            raise RuntimeError\n\n        with open(fname, 'r') as data_file:\n            return cls.fixup_from_json(data_file.read())", "response": "Read json file to get fixture data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_refraction(line, lines):\n    split_line = line.split()\n\n    energy = float(split_line[0])\n    ref_ind_xx = float(split_line[1])\n    ref_ind_zz = float(split_line[2])\n    extinct_xx = float(split_line[3])\n    extinct_zz = float(split_line[4])\n\n    return {\"energy\": energy, \"ref_ind_xx\": ref_ind_xx, \"ref_ind_zz\": ref_ind_zz, \"extinct_xx\": extinct_xx,\n            \"extinct_zz\": extinct_zz}", "response": "Parse Energy [eV]  ref_ind_xx    ref_ind_zz    extinct_xx    extinct_zz"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nexecute a query and return the result.", "response": "def execute(self, fetchcommand, sql, params=None):\n\t\t\"\"\" where 'fetchcommand' is either 'fetchone' or 'fetchall' \"\"\"\n\n\t\tcur = self.conn.cursor()\n\t\tif params:\n\t\t\tif not type(params).__name__ == 'tuple':\n\t\t\t\traise ValueError('the params argument needs to be a tuple')\n\t\t\t\treturn None\n\t\t\tcur.execute(sql, params)\n\t\telse:\n\t\t\tcur.execute(sql)\n\n\t\tself.conn.commit()\n\n\t\tif not fetchcommand or fetchcommand == 'none':\n\t\t\treturn\n\n\t\tif fetchcommand == 'last' or fetchcommand == 'lastid':\n\t\t\tlastdata = cur.fetchall()\n\t\t\tself.conn.commit()\n\t\t\treturn lastdata\n\n\t\tm = insertion_pattern.match(sql)\n\t\t\"\"\"\n\t\t TODO: This is a BUG - need to also check tail of query for RETURNING\n\t\t\"\"\"\n\t\tif m:\n\t\t\t\"\"\" lastid = cursor.fetchone()['lastval'] \"\"\"\n\t\t\tlastdata = cur.fetchone()\n\t\t\tself.conn.commit()\n\t\t\treturn lastdata\n\n\t\tif fetchcommand == 'fetchone' or fetchcommand == 'one':\n\t\t\treturn cur.fetchone()\n\t\telif fetchcommand == 'fetchall' or fetchcommand == 'all':\n\t\t\treturn cur.fetchall()\n\t\telse:\n\t\t\tmsg = \"expecting <fetchcommand> argument to be either 'fetchone'|'one'|'fetchall|all'\"\n\t\t\traise ValueError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cp_parents(files, target_dir: Union[str, Path]):\n# %% make list if it's a string\n    if isinstance(files, (str, Path)):\n        files = [files]\n# %% cleanup user\n    # relative path or absolute path is fine\n    files = (Path(f).expanduser() for f in files)\n    target_dir = Path(target_dir).expanduser()\n# %% work\n    for f in files:\n        # to make it work like cp --parents, copying absolute paths if specified\n        newpath = target_dir / f.parent\n        newpath.mkdir(parents=True, exist_ok=True)\n        shutil.copy2(f, newpath)", "response": "This function copies the specified files into the specified target_dir."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_plot_params(theme=None):\n    \n    # set solarized color progression no matter what\n    mpl.rcParams['axes.color_cycle'] = ('268bd2, dc322f, 859900, ' +\n                                       'b58900, d33682, 2aa198, ' +\n                                       'cb4b16, 002b36')\n    \n    \n    # non-color options are independent as well\n    mpl.rcParams['figure.figsize'] = 11, 8  # figure size in inches\n    mpl.rcParams['lines.linewidth'] = 2.0     # line width in points\n    mpl.rcParams['axes.grid'] = 'True'   # display grid or not\n    \n    mpl.rcParams['font.size'] = 18.0\n    mpl.rcParams['axes.titlesize'] = 18   # fontsize of the axes title\n    mpl.rcParams['axes.labelsize'] = 18  # fontsize of the x any y labels\n    mpl.rcParams['legend.fontsize'] = 18\n    \n    mpl.rcParams['figure.edgecolor'] = 'None'  # figure edgecolor\n    mpl.rcParams['savefig.edgecolor'] = 'None'  # figure edgecolor saving\n\n    # color by theme\n    if theme == 'dark':\n        mpl.rcParams['text.color'] = \"bbbbbb\"\n        mpl.rcParams['axes.facecolor'] = '333333'\n        mpl.rcParams['axes.edgecolor'] = '999999'   # axes edge color\n        mpl.rcParams['axes.labelcolor'] = 'bbbbbb'\n        mpl.rcParams['xtick.color'] = 'bbbbbb'  # color of the tick labels\n        mpl.rcParams['ytick.color'] = 'bbbbbb'  # color of the tick labels\n        mpl.rcParams['grid.color'] = 'bbbbbb'  # grid color\n        mpl.rcParams['figure.facecolor'] = '333333'  # figure facecolor\n        mpl.rcParams['savefig.facecolor'] = '333333'  # figure facecolor saving\n        \n    elif theme == 'white':\n        mpl.rcParams['text.color'] = \"111111\"\n        mpl.rcParams['axes.facecolor'] = 'ffffff'\n        mpl.rcParams['axes.edgecolor'] = '111111'   # axes edge color\n        mpl.rcParams['axes.labelcolor'] = '111111'\n        mpl.rcParams['xtick.color'] = '111111'  # color of the tick labels\n        mpl.rcParams['ytick.color'] = '111111'  # color of the tick labels\n        mpl.rcParams['grid.color'] = '111111'  # grid color\n        mpl.rcParams['figure.facecolor'] = 'ffffff'  # figure facecolor\n        mpl.rcParams['savefig.facecolor'] = 'ffffff'  # figure facecolor saving   \n        \n    else:\n        mpl.rcParams['text.color'] = \"777777\"\n        mpl.rcParams['axes.facecolor'] = 'f7f7f5'\n        mpl.rcParams['axes.edgecolor'] = '111111'   # axes edge color\n        mpl.rcParams['axes.labelcolor'] = '777777'\n        mpl.rcParams['xtick.color'] = '777777'  # color of the tick labels\n        mpl.rcParams['ytick.color'] = '777777'  # color of the tick labels\n        mpl.rcParams['grid.color'] = '777777'  # grid color\n        mpl.rcParams['figure.facecolor'] = 'f7f7f5'  # figure facecolor\n        mpl.rcParams['savefig.facecolor'] = 'f7f7f5'", "response": "set plot parameters for the current RC file and the current session"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef abort(status_code: int,\n          ID: str=None,\n          exception: str=\"\",\n          message: str=None):\n    \"\"\"\u6839\u636e\u72b6\u6001\u7801\u521b\u5efa\u4e00\u4e2a\u5f02\u5e38.\n\n    Parameters:\n        status_code (int): - \u9519\u8bef\u7684\u72b6\u6001\u7801\n        ID (str): - \u4efb\u52a1\u7684ID\u53f7,\u901a\u5e38\u662f\u4e00\u4e2auuid,\u9ed8\u8ba4\u4e3aNone,\u670d\u52a1\u9519\u8bef\u4e0d\u9700\u8981ID,\u65b9\u6cd5\u8c03\u7528\u9519\u8bef\u9700\u8981ID\n        exception (): - \u9519\u8bef\u7684\u5f02\u5e38\u6808\u4fe1\u606f,\u9ed8\u8ba4\u4e3aNone,\u670d\u52a1\u9519\u8bef\u4e0d\u9700\u8981,\u65b9\u6cd5\u8c03\u7528\u9519\u8bef\u53ef\u4ee5\u9700\u8981\n        message (str): - \u9519\u8bef\u4fe1\u606f\n\n    Return:\n        (MprpcException): - \u6307\u5b9a\u9519\u8bef\u7801\u5bf9\u5e94\u7684mprpc\u6807\u51c6\u5f02\u5e38\n\n    \"\"\"\n    if message is None:\n        message = STATUS_CODES.get(status_code)\n        # These are stored as bytes in the STATUS_CODES dict\n    mprpc_exception = _mprpc_exceptions.get(status_code, MprpcException)\n    if issubclass(mprpc_exception, MethodError) or (\n            mprpc_exception is MethodError):\n        return mprpc_exception(\n            message=message,\n            ID=ID,\n            exception=exception,\n            status_code=status_code)\n\n    return mprpc_exception(\n        message=message,\n        status_code=status_code)", "response": "Abort a new Mprpc exception."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handle(self, *args, **options):\n        try:\n            admin = User.objects.get(username='admin')\n        except User.DoesNotExist:\n            admin = User(\n                username='admin',\n                first_name='admin',\n                last_name='admin',\n                email='admin@localhost.localdomain',\n                is_staff=True,\n                is_active=True,\n                is_superuser=True,\n            )\n        admin.set_password('admin')\n        admin.save()", "response": "Load a default admin user"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupload batterystats to the Zenobase API.", "response": "def upload_batterystats(filename, username, password, bucket_name=BUCKET_NAME, bucket_desc=BUCKET_DESC):\n    \"\"\"\n        Works with CSVs generated by the Android app 'Battery Log' (https://play.google.com/store/apps/details?id=kr.hwangti.batterylog)\n    \"\"\"\n\n    zapi = pyzenobase.ZenobaseAPI(username, password)\n    bucket = zapi.create_or_get_bucket(bucket_name, description=bucket_desc)\n    bucket_id = bucket[\"@id\"]\n\n    events = []\n    with open(filename, newline=\"\") as f:\n        reader = csv.reader(f)\n        header = next(reader)\n        for row in reader:\n            events.append({header[i]: row[i] for i in range(len(header))})\n\n    print(\"Read {} events\".format(len(events)))\n    for event in events:\n        # Transform data\n        event[\"timestamp\"] = pyzenobase.fmt_datetime(datetime.strptime(event.pop(\"datetime\"), \"%Y-%m-%d %H:%M:%S\"), timezone=\"Europe/Stockholm\")\n        event[\"tag\"] = event.pop(\"status\")\n        event[\"percentage\"] = float(event.pop(\"level\"))\n        event[\"temperature\"] = {\"@value\": float(event.pop(\"temperature\")), \"unit\": \"C\"}\n        event.pop(\"voltage\")\n\n    print(\"Checking that events are valid...\")\n    events = [pyzenobase.ZenobaseEvent(event) for event in events]\n    print(\"Uploading...\")\n    zapi.create_events(bucket_id, events)\n    zapi.close()\n    print(\"Done!\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert input to a byte string.", "response": "def to_bytes(x, blocksize=0):\n    \"\"\"\n    Converts input to a byte string.\n    Typically used in PyCrypto as an argument (e.g., key, iv)\n\n    :param x: string (does nothing), bytearray, array with numbers\n    :return:\n    \"\"\"\n    if isinstance(x, bytearray):\n        return left_zero_pad(bytes(x), blocksize)\n    elif isinstance(x, basestring):\n        return left_zero_pad(x, blocksize)\n    elif isinstance(x, (list, tuple)):\n        return left_zero_pad(bytes(bytearray(x)), blocksize)\n    elif isinstance(x, (long, int)):\n        return long_to_bytes(x, blocksize)\n    else:\n        raise ValueError('Unknown input argument type')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert input to a long number.", "response": "def to_long(x):\n    \"\"\"\n    Converts input to a long number (arbitrary precision python long)\n    :param x:\n    :return:\n    \"\"\"\n    if isinstance(x, long):\n        return x\n    elif isinstance(x, int):\n        return long(x)\n    else:\n        return bytes_to_long(to_bytes(x))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert input to the hex string", "response": "def to_hex(x):\n    \"\"\"\n    Converts input to the hex string\n    :param x:\n    :return:\n    \"\"\"\n    if isinstance(x, bytearray):\n        x = bytes(x)\n    elif isinstance(x, (list, tuple)):\n        x = bytes(bytearray(x))\n    if isinstance(x, basestring):\n        return base64.b16encode(x).decode('ascii')\n    else:\n        raise ValueError('Unknown input argument type')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nleaves padding with zero bytes to a given block size.", "response": "def left_zero_pad(s, blocksize):\n    \"\"\"\n    Left padding with zero bytes to a given block size\n\n    :param s:\n    :param blocksize:\n    :return:\n    \"\"\"\n    if blocksize > 0 and len(s) % blocksize:\n        s = (blocksize - len(s) % blocksize) * b('\\000') + s\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef bytes_replace(byte_str, start_idx, stop_idx, replacement):\n    return byte_str[:start_idx] + replacement + byte_str[stop_idx:]", "response": "Replaces given portion of the byte string with the replacement."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a byte array and passes it to the function fction.", "response": "def bytes_transform(byte_str, start_idx, stop_idx, fction):\n    \"\"\"\n    Takes portion of the byte array and passes it to the function for transformation.\n    Result is replaced in the byte string, new one is created.\n    :param byte_str:\n    :param start_idx:\n    :param stop_idx:\n    :param fction:\n    :return:\n    \"\"\"\n    return bytes_replace(byte_str, start_idx, stop_idx, fction(byte_str[start_idx:stop_idx]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cbc_mac(key, data):\n    engine = AES.new(key, AES.MODE_CBC, get_zero_vector(16))\n    return engine.encrypt(data)[-16:]", "response": "AES - 256 - CBC - MAC on the data used in ProcessData."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rsa_enc(data, modulus, exponent):\n    modulus = to_long(modulus)\n    exponent = to_long(exponent)\n    data = to_long(data)\n\n    return long_to_bytes(pow(data, exponent, modulus), long_byte_size(modulus))", "response": "Simple RAW RSA encryption method returns byte string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _is_bot(user_agent):\n    bot_list = [\n                'http://www.baidu.com/search/spider.html',\n                'python-requests',\n                'http://ltx71.com/',\n                'http://drupal.org/',\n                'www.sogou.com',\n                'http://search.msn.com/msnbot.htm',\n                'semantic-visions.com crawler',\n               ]\n    for bot in bot_list:\n        if re.search(re.escape(bot), user_agent):\n            return True\n    return False", "response": "Check if user_agent is a known bot."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if file ending is considered as download.", "response": "def _is_download(ending):\n    \"\"\"Check if file ending is considered as download.\"\"\"\n    list = [\n            'PDF',\n            'DOC',\n            'TXT',\n            'PPT',\n            'XLSX',\n            'MP3',\n            'SVG',\n            '7Z',\n            'HTML',\n            'TEX',\n            'MPP',\n            'ODT',\n            'RAR',\n            'ZIP',\n            'TAR',\n            'EPUB',\n           ]\n    list_regex = [\n                  'PDF'\n                 ]\n    if ending in list:\n        return True\n    for file_type in list_regex:\n        if re.search(re.escape(file_type), ending):\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fetch(self, year, week, overwrite=False):\n        self.config['overwrite_files'] = overwrite\n        time_start = time.time()\n        self._fetch_pageviews(self.storage, year, week, ip_users=False)\n        self._fetch_downloads(self.storage, year, week, ip_users=False)\n        # CDS has no user_agent before this date 1433400000:\n        self._fetch_pageviews(self.storage, year, week, ip_users=True)\n        self._fetch_downloads(self.storage, year, week, ip_users=True)\n        logger.info('Fetch %s-%s in %s seconds.', year, week,\n                    time.time() - time_start)", "response": "Fetch PageViews and Downloads from Elasticsearch."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _fetch_pageviews(self, storage, year, week, ip_users=False):\n        prefix = 'Pageviews'\n        if ip_users:\n            query_add = \"AND !(bot:True) AND (id_user:0)\"\n            prefix += '_IP'\n        else:\n            query_add = \"AND !(bot:True) AND !(id_user:0)\"\n        store = self.storage.get(prefix, year, week)\n        if not self.config['overwrite_files'] and store.does_file_exist():\n            logger.debug(\"File already exist, skip: {}-{}\".format(year, week))\n            return\n\n        store.open('overwrite')\n\n        time_from, time_to = get_week_dates(year, week, as_timestamp=True)\n        es_type = \"events.pageviews\"\n        es_query = self.ES_QUERY % {'timestamp_start': time_from * 1000,\n                                    'timestamp_end': time_to * 1000,\n                                    'event_name': es_type,\n                                    'query_add': query_add}\n\n        logger.info(\"{}: {} - {}\".format(es_type, time_from, time_to))\n        for hit in self._fetch_elasticsearch(es_query):\n            item = {}\n            try:\n                item['user'] = hit['_source'].get('id_user')\n                if ip_users:\n                    assert 0 == item['user']\n                else:\n                    assert 0 != item['user']\n                assert es_type == hit['_type']\n\n                item['timestamp'] = float(hit['_source']['@timestamp']) / 1000\n\n                if ip_users:\n                    item['ip'] = str(hit['_source'].get('client_host'))\n                    user_agent = str(hit['_source'].get('user_agent'))\n                    if user_agent is None or user_agent == 'None':\n                        continue\n                    elif _is_bot(user_agent):\n                        continue\n                    item['user_agent'] = user_agent\n                item['recid'] = int(hit['_source'].get('id_bibrec'))\n\n            except UnicodeEncodeError as e:\n                # TODO: Error logging.\n                # print(e)\n                continue\n\n            # Save entry\n            store.add_hit(item)\n        store.close()\n        # Delete File if no hits were added.\n        if store.number_of_hits == 0:\n            store.delete()", "response": "Fetch PageViews from Elasticsearch."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _fetch_elasticsearch(self, es_query):\n        # TODO: Show error if index is not found.\n        scanResp = self._esd.search(index=self.config['es_index'],\n                                    body=es_query, size=2000,\n                                    search_type=\"scan\", scroll=\"10000\",\n                                    timeout=900, request_timeout=900)\n        resp = dict(scanResp)\n        resp.pop('_scroll_id')\n        logger.debug(resp)\n        scroll_hits = scanResp['hits']['total']\n        scrollTime = scanResp['took']\n        scrollId = scanResp['_scroll_id']\n        # Check for shard errors\n        if scanResp['_shards']['failed'] > 0:\n            logger.warn(\"Failing shards, check ES\")\n        retry_count = 0\n        number_of_retrys = 5\n        hit_count = 0\n\n        while True:\n            try:\n                response = self._esd.scroll(scroll_id=scrollId, scroll=\"10000\",\n                                            request_timeout=900)\n                if response['_scroll_id'] != scrollId:\n                    scrollId = response['_scroll_id']\n                if scanResp['_shards']['failed'] > 0:\n                    print(\"Failing shards, check ES\")\n                # No more hits\n                if len(response[\"hits\"][\"hits\"]) == 0:\n                    break\n            except esd_exceptions.ConnectionTimeout:\n                logger.warning(\"ES exceptions: Connection Timeout\")\n                if retry_count >= number_of_retrys:\n                    raise esd_exceptions.ConnectionTimeout()\n\n                retry_count += 1\n                continue\n\n            except StopIteration:\n                break\n\n            except Exception as e:\n                # TODO: Logging\n                logging.exception(\"ES exception\", exc_info=True)\n                print(\"EXCEPTION\")\n                print(e)\n                break\n\n            for hit in response[\"hits\"][\"hits\"]:\n                yield hit\n                hit_count += 1\n\n        if hit_count > scroll_hits:\n            # More hits as expected, happens sometimes.\n            logger.info('More hits as expected %s/%s', hit_count, scroll_hits)\n        elif hit_count < scroll_hits:\n            # Less hits as expected, something went wrong.\n            logger.warn('Less hits as expected %s/%s', hit_count, scroll_hits)\n        logger.info('%s Hits', hit_count)", "response": "Fetch data from Elasticsearch."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndumps some of the items in the specified queues.", "response": "def dump_queue(self, *names):\n        \"\"\"Debug-log some of the queues.\n\n        ``names`` may include any of \"worker\", \"available\", \"priorities\",\n        \"expiration\", \"workers\", or \"reservations_ITEM\" filling in some\n        specific item.\n\n        \"\"\"\n        conn = redis.StrictRedis(connection_pool=self.pool)\n        for name in names:\n            if name == 'worker':\n                logger.debug('last worker: ' + conn.get(self._key_worker()))\n            elif name == 'available':\n                logger.debug('available: ' +\n                             str(conn.zrevrange(self._key_available(), 0, -1,\n                                                withscores=True)))\n            elif name == 'priorities':\n                logger.debug('priorities: ' +\n                             str(conn.hgetall(self._key_priorities())))\n            elif name == 'expiration':\n                logger.debug('expiration: ' +\n                             str(conn.zrevrange(self._key_expiration(), 0, -1,\n                                                withscores=True)))\n            elif name == 'workers':\n                logger.debug('workers: ' +\n                             str(conn.hgetall(self._key_workers())))\n            elif name.startswith('reservations_'):\n                item = name[len('reservations_'):]\n                logger.debug('reservations for ' + item + ': ' +\n                             str(conn.smembers(self._key_reservations(item))))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef worker_id(self):\n        if self._worker_id is not None: return self._worker_id\n        return self._get_worker_id(self._conn())", "response": "A unique identifier for this queue instance and the items it owns."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the worker ID using a preestablished connection.", "response": "def _get_worker_id(self, conn):\n        \"\"\"Get the worker ID, using a preestablished connection.\"\"\"\n        if self._worker_id is None:\n            self._worker_id = conn.incr(self._key_worker())\n        return self._worker_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an item to the internal state.", "response": "def add_item(self, item, priority):\n        \"\"\"Add ``item`` to this queue.\n\n        It will have the specified ``priority`` (highest priority runs\n        first).  If it is already in the queue, fail if it is checked\n        out or reserved, or change its priority to ``priority``\n        otherwise.\n\n        \"\"\"\n        conn = self._conn()\n        self._run_expiration(conn)\n        script = conn.register_script(\"\"\"\n        if (redis.call(\"hexists\", KEYS[2], ARGV[1]) ~= 0) and\n           not(redis.call(\"zscore\", KEYS[1], ARGV[1]))\n        then\n            return -1\n        end\n        redis.call(\"zadd\", KEYS[1], ARGV[2], ARGV[1])\n        redis.call(\"hset\", KEYS[2], ARGV[1], ARGV[2])\n        return 0\n        \"\"\")\n        result = script(keys=[self._key_available(), self._key_priorities()],\n                        args=[item, priority])\n        if result == -1:\n            raise ItemInUseError(item)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the highest - priority item out of this queue.", "response": "def check_out_item(self, expiration):\n        \"\"\"Get the highest-priority item out of this queue.\n\n        Returns the item, or None if no items are available.  The item\n        must be either ``return_item()`` or ``renew_item()`` before\n        ``expiration`` seconds pass, or it will become available to\n        future callers.  The item will be marked as being owned by\n        ``worker_id``.\n\n        \"\"\"\n        conn = redis.StrictRedis(connection_pool=self.pool)\n        self._run_expiration(conn)\n        expiration += time.time()\n        script = conn.register_script(\"\"\"\n        local item = redis.call(\"zrevrange\", KEYS[1], 0, 0)\n        if #item == 0 then return nil end\n        item = item[1]\n        redis.call(\"zrem\", KEYS[1], item)\n        redis.call(\"zadd\", KEYS[2], ARGV[1], item)\n        redis.call(\"hset\", KEYS[3], \"i\" .. item, \"w\" .. ARGV[2])\n        redis.call(\"hset\", KEYS[3], \"w\" .. ARGV[2], \"i\" .. item)\n        return item\n        \"\"\")\n        result = script(keys=[self._key_available(), self._key_expiration(),\n                              self._key_workers()],\n                        args=[expiration, self._get_worker_id(conn)])\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the expiration time for item.", "response": "def renew_item(self, item, expiration):\n        \"\"\"Update the expiration time for ``item``.\n\n        The item will remain checked out for ``expiration`` seconds\n        beyond the current time.  This queue instance must have\n        already checked out ``item``, and this method can fail if\n        ``item`` is already overdue.\n\n        \"\"\"\n        conn = self._conn()\n        self._run_expiration(conn)\n        expiration += time.time()\n        script = conn.register_script(\"\"\"\n        -- already expired?\n        if redis.call(\"hget\", KEYS[2], \"i\" .. ARGV[1]) ~= \"w\" .. ARGV[3]\n        then return -1 end\n\n        -- otherwise just update the expiration\n        redis.call(\"zadd\", KEYS[1], ARGV[2], ARGV[1])\n        return 0\n        \"\"\")\n        result = script(keys=[self._key_expiration(), self._key_workers()],\n                        args=[item, expiration, self._get_worker_id(conn)])\n        if result == -1:\n            raise LostLease(item)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncompleting work on an item from the check_out_item method.", "response": "def return_item(self, item, priority):\n        \"\"\"Complete work on an item from ``check_out_item()``.\n\n        If this instance no longer owns ``item``, raise ``LostLease``.\n        If ``priority`` is None, the item is removed from the queue;\n        otherwise it is re-added with the specified priority.  Any\n        locked items associated with this item are unlocked.\n\n        \"\"\"\n        conn = redis.StrictRedis(connection_pool=self.pool)\n        self._run_expiration(conn)\n        script = conn.register_script(\"\"\"\n        -- expired?\n        if redis.call(\"hget\", KEYS[4], \"i\" .. ARGV[1]) ~= \"w\" .. ARGV[3]\n        then return -1 end\n\n        -- will no longer expire\n        redis.call(\"zrem\", KEYS[2], ARGV[1])\n        -- update priority, readd to available list\n        if ARGV[2] == \"None\"\n        then\n          redis.call(\"hdel\", KEYS[3], ARGV[1])\n        else\n          redis.call(\"hset\", KEYS[3], ARGV[1], ARGV[2])\n          redis.call(\"zadd\", KEYS[1], ARGV[2], ARGV[1])\n        end\n        -- release all reservations\n        local reservations = redis.call(\"smembers\", KEYS[5])\n        for i = 1, #reservations do\n          local item = reservations[i]\n          local pri = redis.call(\"hget\", KEYS[3], item)\n          redis.call(\"zadd\", KEYS[1], pri, item)\n        end\n        -- clear out workers\n        redis.call(\"hdel\", KEYS[4], \"i\" .. ARGV[1])\n        redis.call(\"hdel\", KEYS[4], \"w\" .. ARGV[3])\n        \n        return 0\n        \"\"\")\n        # work around python -> redis -> lua marshaling\n        if priority is None: priority = \"None\"\n        result = script(keys=[self._key_available(), self._key_expiration(),\n                              self._key_priorities(), self._key_workers(),\n                              self._key_reservations(item)],\n                        args=[item, priority, self._get_worker_id(conn)])\n        if result == -1: raise LostLease(item)\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reserve_items(self, parent_item, *items):\n        conn = redis.StrictRedis(connection_pool=self.pool)\n        self._run_expiration(conn)\n        script = conn.register_script(\"\"\"\n        -- expired?\n        if redis.call(\"hget\", KEYS[2], \"i\" .. ARGV[1]) ~= \"w\" .. ARGV[2]\n        then return -1 end\n\n        -- loop through each item\n        local result = {}\n        for i = 3, #ARGV do\n          local item = ARGV[i]\n          -- item must be available to reserve\n          if redis.call(\"zscore\", KEYS[1], item) then\n            redis.call(\"zrem\", KEYS[1], item)\n            redis.call(\"sadd\", KEYS[3], item)\n            result[#result + 1] = item\n          end\n        end\n        return result\n        \"\"\")\n        result = script(keys=[self._key_available(), self._key_workers(),\n                              self._key_reservations(parent_item)],\n                        args=([parent_item, self._get_worker_id(conn)] +\n                              list(items)))\n        if result == -1:\n            raise LostLease(parent_item)\n        return result", "response": "Reserve a set of items until a parent item is returned."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _run_expiration(self, conn):\n        # The logic here is sufficiently complicated, and we need\n        # enough random keys (Redis documentation strongly encourages\n        # not constructing key names in scripts) that we'll need to\n        # do this in multiple steps.  This means that, when we do\n        # go in and actually expire things, we need to first check\n        # that they're still running.\n\n        # Get, and clear out, the list of expiring items\n        now = time.time()\n        script = conn.register_script(\"\"\"\n        local result = redis.call(\"zrangebyscore\", KEYS[1], 0, ARGV[1])\n        redis.call(\"zremrangebyscore\", KEYS[1], 0, ARGV[1])\n        return result\n        \"\"\")\n        expiring = script(keys=[self._key_expiration()], args=[time.time()])\n        \n        # Manually expire each item one by one\n        script = conn.register_script(\"\"\"\n        -- item may have fallen out of the worker list, if someone finished\n        -- at just the very last possible moment (phew!)\n        local wworker = redis.call(\"hget\", KEYS[3], \"i\" .. ARGV[1])\n        if not wworker then return end\n\n        -- we want to return item, plus everything it's reserved\n        local to_return = redis.call(\"smembers\", KEYS[4])\n        to_return[#to_return + 1] = ARGV[1]\n        for i = 1, #to_return do\n          local pri = redis.call(\"hget\", KEYS[2], to_return[i])\n          redis.call(\"zadd\", KEYS[1], pri, to_return[i])\n        end\n        -- already removed from expiration list\n        -- remove from worker list too\n        redis.call(\"hdel\", KEYS[3], \"i\" .. ARGV[1])\n        redis.call(\"hdel\", KEYS[3], wworker)\n        \"\"\")\n        for item in expiring:\n            script(keys=[self._key_available(), self._key_priorities(),\n                         self._key_workers(), self._key_reservations(item)],\n                   args=[item])", "response": "Run the expiration check on the redis server and return any items that have expired."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pager_redirect(desc, *, pagercmd=None, istty=None, file=None,\n                   substitutions=None):\n    \"\"\" Redirect output to file/stdout to a pager process.  Care is taken to\n    restore the controlling tty stdio files to their original state. \"\"\"\n    global _pager_active\n    if file is None:\n        file = sys.stdout\n    if not pagercmd or not file.isatty() or _pager_active:\n        yield\n        return\n    subs = {\"desc\": desc}\n    if substitutions is not None:\n        subs.update(substitutions)\n    pagercmd = pagercmd.format(**subs)\n    with tty_restoration():\n        p = pager_process(pagercmd)\n        if istty is None:\n            p.stdin.isatty = file.isatty\n        else:\n            p.stdin.isatty = lambda: istty\n        stdout_save = sys.stdout\n        sys.stdout = p.stdin\n        _pager_active = True\n        try:\n            yield\n        finally:\n            _pager_active = False\n            sys.stdout = stdout_save\n            try:\n                p.stdin.close()\n            except BrokenPipeError:\n                pass\n            while p.poll() is None:\n                try:\n                    p.wait()\n                except KeyboardInterrupt:\n                    pass", "response": "Redirect output to file or stdout to a pager process."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cleanup_sweep_threads():\n    '''\n    Not used. Keeping this function in case we decide not to use\n    daemonized threads and it becomes necessary to clean up the\n    running threads upon exit.\n    '''\n\n    for dict_name, obj in globals().items():\n        if isinstance(obj, (TimedDict,)):\n            logging.info(\n                'Stopping thread for TimedDict {dict_name}'.format(\n                    dict_name=dict_name))\n            obj.stop_sweep()", "response": "This function is used to clean up the daemonized threads."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the expiration time for a key.", "response": "def set_expiration(self, key, ignore_missing=False,\n            additional_seconds=None, seconds=None):\n        '''\n        Alters the expiration time for a key. If the key is not\n        present, then raise an Exception unless `ignore_missing`\n        is set to `True`.\n\n        Args:\n            key: The key whose expiration we are changing.\n            ignore_missing (bool): If set, then return silently\n                if the key does not exist. Default is `False`.\n            additional_seonds (int): Add this many seconds to the\n                current expiration time.\n            seconds (int): Expire the key this many seconds from now.\n        '''\n        if key not in self.time_dict and ignore_missing:\n            return\n        elif key not in self.time_dict and not ignore_missing:\n            raise Exception('Key missing from `TimedDict` and '\n                '`ignore_missing` is False.')\n        if additional_seconds is not None:\n            self.time_dict[key] += additional_seconds\n        elif seconds is not None:\n            self.time_dict[key] = time.time() + seconds"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexpires the key delete the value and call the callback function if one is specified.", "response": "def expire_key(self, key):\n        '''\n        Expire the key, delete the value, and call the callback function\n        if one is specified.\n\n        Args:\n            key: The ``TimedDict`` key\n        '''\n        value = self.base_dict[key]\n        del self[key]\n        if self.callback is not None:\n            self.callback(\n                key, value, *self.callback_args, **self.callback_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _save_stdin(self, stdin):\n\t\tself.temp_dir = TemporaryDirectory()\n\t\tfile_path = os.path.join(self.temp_dir.name, 'dataset')\n\n\t\ttry:\n\t\t\twith open(file_path, 'w') as f:\n\t\t\t\tfor line in stdin:\n\t\t\t\t\tf.write(line)\n\t\texcept TypeError:\n\t\t\tself.temp_dir.cleanup()\n\t\t\traise ValueError('Could not read stdin')\n\n\t\treturn file_path", "response": "Save the given stdin to a file within that dir."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _open(self, file_path=None):\n\t\tif file_path is None:\n\t\t\tfile_path = self.file_path\n\n\t\tif not os.path.exists(file_path):\n\t\t\traise ValueError('Could not find file: {}'.format(file_path))\n\n\t\ttry:\n\t\t\tf = open(file_path, encoding='utf-8', newline='')\n\t\texcept OSError as err:\n\t\t\tself.log.error(str(err))\n\t\t\traise ValueError('Could not open file: {}'.format(file_path))\n\n\t\treturn f", "response": "Opens the file specified by the given path. Raises ValueError if there is a problem with opening or reading the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_dialect(self):\n\t\tif self.is_single_col:\n\t\t\treturn None\n\n\t\tif self.delimiter and self.quotechar:\n\t\t\treturn Dialect(self.delimiter, self.quotechar,\n\t\t\t\t\t\tTrue if self.escapechar is None else False,\n\t\t\t\t\t\tself.escapechar)\n\n\t\text = os.path.basename(self.file_path).rsplit('.', maxsplit=1)\n\t\text = ext[1].lower() if len(ext) > 1 else None\n\n\t\tif ext in TSV_EXTENSIONS:\n\t\t\tself.delimiter = '\\t'\n\t\t\tself.quotechar = '\"'\n\n\t\telse:\n\t\t\tf = self._open()\n\t\t\tlines = f.read().splitlines()\n\t\t\tf.close()\n\n\t\t\tif lines:\n\t\t\t\tdialect = self._determine_dialect(lines)\n\t\t\telse:\n\t\t\t\tdialect = None\n\n\t\t\tif dialect is None:\n\t\t\t\tself.is_single_col = True\n\t\t\telse:\n\t\t\t\tself.delimiter = dialect.delimiter\n\t\t\t\tself.quotechar = dialect.quotechar\n\t\t\t\tself.escapechar = dialect.escapechar\n\n\t\treturn self.get_dialect()", "response": "Returns a Dialect named tuple or None if the file comprises a single column of data. Raises ValueError if the file comprises a single column of data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining the most likely Dialect for a given list of lines.", "response": "def _determine_dialect(self, lines):\n\t\t\"\"\"\n\t\tExpects a non-empty [] of strings; these would normally be the first\n\t\tfew lines of a csv file. Returns the most likely Dialect named tuple or\n\t\tNone if the data seems to form a single column.\n\n\t\tEnsures that using the returned dialect, all the lines given will have\n\t\tthe same number of columns.\n\n\t\tHelper for the get_dialect method.\n\t\t\"\"\"\n\t\tpermuts = [(quotechar, escapechar)\n\t\t\t\tfor quotechar in CSV_QUOTECHARS\n\t\t\t\tfor escapechar in CSV_ESCAPECHARS]\n\n\t\tfor delim in CSV_DELIMITERS:\n\t\t\tcounts = [line.count(delim) for line in lines]\n\n\t\t\tif min(counts) == 0:\n\t\t\t\tcontinue\n\n\t\t\tfor quotechar, escapechar in permuts:\n\t\t\t\tdoublequote = True if escapechar is None else False\n\n\t\t\t\treader = csv.reader(lines, delimiter=delim, quotechar=quotechar,\n\t\t\t\t\t\t\t\tdoublequote=doublequote, escapechar=escapechar)\n\n\t\t\t\ttry:\n\t\t\t\t\tassert len(set([len(line) for line in reader])) == 1\n\t\t\t\texcept AssertionError:\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcontinue  # no suitable quoting found\n\n\t\t\tbreak  # found it!\n\n\t\telse:\n\t\t\treturn None\n\n\t\treturn Dialect(delim, quotechar, doublequote, escapechar)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_csv_reader(self, f, dialect):\n\t\treader = csv.reader(f,\n\t\t\t\t\tdelimiter = dialect.delimiter,\n\t\t\t\t\tquotechar = dialect.quotechar,\n\t\t\t\t\tdoublequote = dialect.doublequote,\n\t\t\t\t\tescapechar = dialect.escapechar)\n\n\t\tif self.has_header:\n\t\t\theader = next(reader)\n\t\t\tif not isinstance(self.ipa_col, int):\n\t\t\t\tself.ipa_col = self._infer_ipa_col(header)\n\n\t\telse:\n\t\t\tif not isinstance(self.ipa_col, int):\n\t\t\t\tif not self.ipa_col:\n\t\t\t\t\traise ValueError('Cannot infer IPA column without header')\n\n\t\t\t\ttry:\n\t\t\t\t\tself.ipa_col = int(self.ipa_col)\n\t\t\t\texcept ValueError:\n\t\t\t\t\traise ValueError('Cannot find column: {}'.format(self.ipa_col))\n\n\t\treturn reader", "response": "Returns a csv. reader for the given file handler and csv Dialect named\n\ttuple."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninfers the column name of the IPA data based on the header. Raises ValueError if the header is not a string.", "response": "def _infer_ipa_col(self, header):\n\t\t\"\"\"\n\t\tReturns the column (as index) containing the IPA data based on the\n\t\theader (the first line of the data file). Raises ValueError otherwise.\n\n\t\tIf self.ipa_col is a string, it is assumed to be the column's name or\n\t\tindex. Otherwise, several common IPA column names are tried.\n\t\t\"\"\"\n\t\tif self.ipa_col and isinstance(self.ipa_col, str):\n\t\t\tif self.ipa_col in header:\n\t\t\t\treturn header.index(self.ipa_col)\n\n\t\t\ttry:\n\t\t\t\tipa_col = int(self.ipa_col)\n\t\t\texcept ValueError: pass\n\t\t\telse:\n\t\t\t\treturn ipa_col\n\n\t\t\traise ValueError('Could not find column: {}'.format(self.ipa_col))\n\n\t\tpot = []\n\n\t\tfor index, col_name in enumerate(header):\n\t\t\tcol_name = col_name.lower()\n\t\t\tfor name in IPA_COL_NAMES:\n\t\t\t\tif col_name.startswith(name):\n\t\t\t\t\tpot.append(index)\n\n\t\tif len(pot) == 0:\n\t\t\traise ValueError('Could not find an IPA column')\n\t\telif len(pot) > 1:\n\t\t\traise ValueError('Could not decide which is the IPA column')\n\n\t\treturn pot[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _gen_csv_data(self, f, dialect):\n\t\treader = self._get_csv_reader(f, dialect)\n\n\t\tfor line in reader:\n\t\t\ttry:\n\t\t\t\tdatum = line[self.ipa_col]\n\t\t\texcept IndexError:\n\t\t\t\tmes = 'Could not find IPA data on line: {}'.format(line)\n\t\t\t\traise ValueError(mes)\n\n\t\t\tyield datum, reader.line_num", "response": "Generator method for IPA data."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _gen_txt_data(self, f):\n\t\treader = iter(f)\n\n\t\tfor line_num, line in enumerate(reader):\n\t\t\tif line_num == 0 and self.has_header:\n\t\t\t\tcontinue\n\n\t\t\tdatum = line.rstrip('\\r\\n')\n\n\t\t\tyield datum, line_num+1", "response": "Generator for the txt data."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setup(self, *args, **kwargs):\n\n        #BWCOMPAT\n        if kwargs.get('topics'):\n            if kwargs.get('publishers'):\n                kwargs['publishers'] = kwargs.get('publishers', []) + kwargs.get('topics', [])\n            else:\n                kwargs['publishers'] = kwargs.get('topics', [])\n            if kwargs.get('subscribers'):\n                kwargs['subscribers'] = kwargs.get('subscribers', []) + kwargs.get('topics', [])\n            else:\n                kwargs['subscribers'] = kwargs.get('topics', [])\n        kwargs.pop('topics')\n\n        # We can now import RosInterface and setup will be done ( we re in another process ).\n        # TODO : context to make it cleaner (maybe use zmp.Node context ?)\n        if isinstance(self.interface_class, tuple):\n            m = None\n            class_name = self.interface_class[-1]  # last element is always the class_name\n            if len(self.interface_class) >= 3:\n                # load the relative module, will raise ImportError if module cannot be loaded\n                m = importlib.import_module(self.interface_class[1], self.interface_class[0])\n            elif len(self.interface_class) == 2:\n                # load the relative module, will raise ImportError if module cannot be loaded\n                m = importlib.import_module(self.interface_class[0])\n            # get the class, will raise AttributeError if class cannot be found\n            self.interface_class = getattr(m, class_name)\n\n        if not (\n                # TODO : we should pre check all the used members are present...\n                hasattr(self.interface_class, 'services')\n                # TODO : etc.\n        ):\n            raise PyrosException(\"The interface class is missing some members to be used as an interface. Aborting Setup. {interface_class}\".format(**locals()))\n\n        self.interface = self.interface_class(*args, **kwargs)\n        return self.interface", "response": "Dynamically set the interface to expose the services topics and params whose names are passed as args\nAttributeNames"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef child_context(self, *args, **kwargs):\n\n        # Now we can extract config values\n        expected_args = {\n            'services': [],\n            'topics': [],  # bwcompat\n            'subscribers': [],\n            'publishers': [],\n            'params': [],\n            # TODO : all of them !\n        }\n\n        ifargs = {\n            arg: self.config_handler.config.get(arg.upper(), default) for arg, default in expected_args.items()\n        }\n\n        # overriding with kwargs\n        ifargs.update(kwargs)\n\n        # storing passed args in config in case of reset\n\n        # calling setup on child context enter call\n        if self.interface is None:\n            #for BW compat\n            # TODO : change API to use the child_context from pyzmp coprocess\n            self.setup(*args, **ifargs)\n\n        with super(PyrosBase, self).child_context(*args, **kwargs) as cctxt:\n            yield cctxt", "response": "A child_context method that returns a new context object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef shutdown(self, join=True, timeout=None):\n        if self.interface is not None:\n            self.interface.stop()\n\n        return super(PyrosBase, self).shutdown(join, timeout=timeout)", "response": "Clean shutdown of the node."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, timedelta, *args, **kwargs):\n\n        # TODO move time management somewhere else...\n        self.last_update += timedelta\n        # if shutdown we want to bypass the update_interval check\n        # if shutting_down:\n        #     self.interface.update(shutting_down=shutting_down)\n        #     return 0  # return 0 as success since we arrived here without exception\n        # else\n        if self.last_update > self.update_interval:\n            self.last_update = 0\n            self.interface.update()", "response": "Update the internal state of the internal state of the internal state of the internal state of the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate over a generator looking for things that match.", "response": "def _findAll(self, name, attrs, text, limit, generator, **kwargs):\n        \"Iterates over a generator looking for things that match.\"\n\n        if isinstance(name, SoupStrainer):\n            strainer = name\n        # (Possibly) special case some findAll*(...) searches\n        elif text is None and not limit and not attrs and not kwargs:\n            # findAll*(True)\n            if name is True:\n                return [element for element in generator()\n                        if isinstance(element, Tag)]\n            # findAll*('tag-name')\n            elif isinstance(name, basestring):\n                return [element for element in generator()\n                        if isinstance(element, Tag) and\n                        element.name == name]\n            else:\n                strainer = SoupStrainer(name, attrs, text, **kwargs)\n        # Build a SoupStrainer\n        else:\n            strainer = SoupStrainer(name, attrs, text, **kwargs)\n        results = ResultSet(strainer)\n        g = generator()\n        while True:\n            try:\n                i = g.next()\n            except StopIteration:\n                break\n            if i:\n                found = strainer.search(i)\n                if found:\n                    results.append(found)\n                    if limit and len(results) >= limit:\n                        break\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef decompose(self):\n        self.extract()\n        if len(self.contents) == 0:\n            return\n        current = self.contents[0]\n        while current is not None:\n            next = current.next\n            if isinstance(current, Tag):\n                del current.contents[:]\n            current.parent = None\n            current.previous = None\n            current.previousSibling = None\n            current.next = None\n            current.nextSibling = None\n            current = next", "response": "Recursively destroys the contents of this tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _smartPop(self, name):\n\n        \"\"\"We need to pop up to the previous tag of this type, unless\n        one of this tag's nesting reset triggers comes between this\n        tag and the previous tag of this type, OR unless this tag is a\n        generic nesting trigger and another generic nesting trigger\n        comes between this tag and the previous tag of this type.\n\n        Examples:\n         <p>Foo<b>Bar *<p>* should pop to 'p', not 'b'.\n         <p>Foo<table>Bar *<p>* should pop to 'table', not 'p'.\n         <p>Foo<table><tr>Bar *<p>* should pop to 'tr', not 'p'.\n\n         <li><ul><li> *<li>* should pop to 'ul', not the first 'li'.\n         <tr><table><tr> *<tr>* should pop to 'table', not the first 'tr'\n         <td><tr><td> *<td>* should pop to 'tr', not the first 'td'\n        \"\"\"\n\n        nestingResetTriggers = self.NESTABLE_TAGS.get(name)\n        isNestable = nestingResetTriggers != None\n        isResetNesting = self.RESET_NESTING_TAGS.has_key(name)\n        popTo = None\n        inclusive = True\n        for i in range(len(self.tagStack)-1, 0, -1):\n            p = self.tagStack[i]\n            if (not p or p.name == name) and not isNestable:\n                #Non-nestable tags get popped to the top or to their\n                #last occurance.\n                popTo = name\n                break\n            if (nestingResetTriggers is not None\n                and p.name in nestingResetTriggers) \\\n                or (nestingResetTriggers is None and isResetNesting\n                    and self.RESET_NESTING_TAGS.has_key(p.name)):\n\n                #If we encounter one of the nesting reset triggers\n                #peculiar to this tag, or we encounter another tag\n                #that causes nesting to reset, pop up to but not\n                #including that tag.\n                popTo = p.name\n                inclusive = False\n                break\n            p = p.parent\n        if popTo:\n            self._popToTag(popTo, inclusive)", "response": "This method takes a tag name and returns the previous tag of this type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging a MS smart quote character to an XML or HTML object.", "response": "def _subMSChar(self, orig):\n        \"\"\"Changes a MS smart quote character to an XML or HTML\n        entity.\"\"\"\n        sub = self.MS_CHARS.get(orig)\n        if isinstance(sub, tuple):\n            if self.smartQuotesTo == 'xml':\n                sub = '&#x%s;' % sub[1]\n            else:\n                sub = '&%s;' % sub[0]\n        return sub"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the contents of an environment file and returns a dictionary of the values.", "response": "def read_file_values(env_file, fail_silently=True):\n    \"\"\"\n    Borrowed from Honcho.\n    \"\"\"\n    env_data = {}\n    try:\n        with open(env_file) as f:\n            content = f.read()\n    except IOError:\n        if fail_silently:\n            logging.error(\"Could not read file '{0}'\".format(env_file))\n            return env_data\n        raise\n\n    for line in content.splitlines():\n        m1 = re.match(r'\\A([A-Za-z_0-9]+)=(.*)\\Z', line)\n        if m1:\n            key, val = m1.group(1), m1.group(2)\n\n            m2 = re.match(r\"\\A'(.*)'\\Z\", val)\n            if m2:\n                val = m2.group(1)\n\n            m3 = re.match(r'\\A\"(.*)\"\\Z', val)\n            if m3:\n                val = re.sub(r'\\\\(.)', r'\\1', m3.group(1))\n\n            env_data[key] = val\n\n    return env_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_suffix(path):\n    suffix = os.path.basename(path).split(\".\")[-1]\n\n    if \"/\" in suffix:\n        raise UserWarning(\"Filename can't contain '/' in suffix (%s)!\" % path)\n\n    return suffix", "response": "Return suffix from path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_message(self, msg):\n        if self not in clients:\n            return\n\n        try:\n            payload = json_decode(msg)\n        except ValueError:\n            # unable to decode so we cannot handle the message\n            return\n\n        if 'close' in payload:\n            self.close()\n            return\n\n        for verb, args in payload.items():\n            self.group.action(verb, args)", "response": "Accept a message that was published process and forward\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting the input data stream input to output and returns the output stream.", "response": "def prettify(input, output, strict=True, indentString='  ', color=False,\n             encoding=DEFAULT_ENCODING):\n  '''\n  Converts the input data stream `input` (which must be a file input\n  like object) to `output` (which must be a file output like object)\n  by parsing the stream as XML and outputting \"prettified\"\n  XML. Prettification involves the following aspects:\n\n  * Collapsing ignorable whitespace.\n  * Indenting nodes by `indentString`.\n  * Colorizing the output to more easily identify elements if\n    `color` is True or a color specification (see below).\n  * Normalizing attribute rendering.\n    TODO: that should include canonical ordering of attributes...\n\n  :Parameters:\n\n  strict : bool, default: true, optional\n    If the input stream cannot be parsed by python's xml.dom.minidom,\n    then if `strict` is True (the default), an exception is raised. If\n    `strict` is False, then the input data is streamed to `output`\n    as-is.\n\n  indentString : str, default: '  ', optional\n    The indentation to add to the output stream when entering into a\n    sub-element. Note that this indentation is only added if it will\n    remain \"ignorable whitespace\" according to the XML specification.\n\n  color : bool, default: false, optional\n    Whether or not to add *terminfo* terminal colorization sequences\n    to add XML syntax highlighting, including element names, attribute\n    names, and other XML syntax characters.\n\n  encoding : str, default: 'UTF-8', optional\n    Specify the encoding to use when rendering the XML. By default, it\n    uses ``\"UTF-8\"``.\n\n  :Returns:\n\n  True\n    the input stream was successfully converted.\n\n  False\n    a parsing error occurred and `strict` was False.\n\n  Exception\n    other errors (such as IOErrors) occurred.\n  '''\n  data = input.read()\n  try:\n    dom = xml.dom.minidom.parseString(data)\n  except Exception:\n    if strict:\n      raise\n    output.write(data)\n    return False\n  removeIgnorableWhitespace(dom)\n  indentXml(dom, dom.documentElement, indentString)\n  if color:\n    return colorizeXml(dom, output, encoding=encoding, colorspec=color)\n  xout = dom.toxml(encoding=encoding) + b'\\n'\n  output.write(re.sub(b'^(<\\\\?xml[^>]+?>)', b'\\\\1\\n', xout))\n  return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a Token class based upon the function arguments in the closure.", "response": "def _tokenFactory(authenticated):\n  '''\n  Build a Token class, based upon the function arguments in the closure,\n  and return an instantiation of it. This allows us return an object\n  with truly read-only properties :) These 'hoops' suggest that this is\n  probably 'unpythonic', but what can you do?!\n\n  n.b., This shouldn't be invoked directly.\n  '''\n\n  if not authenticated:\n    weAreGood = False\n    authenticated = { 'data': None, 'expiration': None }\n\n  else:\n    weAreGood = True\n\n  class Token(object):\n    def __dir__(self):\n      ''' Class members '''\n      return ['valid'] + authenticated.keys()\n\n    def __getattribute__(self, name):\n      ''' Fake attributes '''\n      if name == 'valid':\n        if weAreGood:\n          return datetime.now() <= authenticated['expiration']\n\n        else:\n          return False\n\n      if name in authenticated:\n        return authenticated[name]\n\n      else:\n        # No such attribute\n        raise AttributeError('Object has no attribute \\'%s\\'' % name)\n\n    def __setattr__(self, value, name):\n      ''' We can't set any attribute values '''\n      raise AttributeError('Cannot set read-only attribute')\n\n  return Token()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_encoding(binary):\n\n    try:\n        from chardet import detect\n    except ImportError:\n        LOGGER.error(\"Please install the 'chardet' module\")\n        sys.exit(1)\n\n    encoding = detect(binary).get('encoding')\n\n    return 'iso-8859-1' if encoding == 'CP949' else encoding", "response": "Return the encoding type of the given binary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrequesting a single character input from the user.", "response": "def getch():\n    \"\"\"Request a single character input from the user.\"\"\"\n\n    if sys.platform in ['darwin', 'linux']:\n        import termios\n        import tty\n        file_descriptor = sys.stdin.fileno()\n        settings = termios.tcgetattr(file_descriptor)\n        try:\n            tty.setraw(file_descriptor)\n            return sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(file_descriptor, termios.TCSADRAIN, settings)\n    elif sys.platform in ['cygwin', 'win32']:\n        import msvcrt\n        return msvcrt.getwch()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ismatch(text, pattern):\n\n    if hasattr(pattern, 'search'):\n        return pattern.search(text) is not None\n    else:\n        return pattern in text if Config.options.case_sensitive \\\n            else pattern.lower() in text.lower()", "response": "Test whether text contains string or matches regex."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing command - line arguments.", "response": "def parse(args):\n    \"\"\"Parse command-line arguments. Arguments may consist of any\n    combination of directories, files, and options.\"\"\"\n\n    import argparse\n\n    parser = argparse.ArgumentParser(\n        add_help=False,\n        description=\"Remove spam and advertising from subtitle files.\",\n        usage=\"%(prog)s [OPTION]... TARGET...\")\n    parser.add_argument(\n        \"-a\", \"--aeidon\",\n        action=\"store_true\",\n        dest=\"aeidon\",\n        help=\"use python3-aeidon to process subtitles\")\n    parser.add_argument(\n        \"-f\", \"--file\",\n        action=\"append\",\n        dest=\"pattern_files\",\n        help=\"obtain matches from FILE\")\n    parser.add_argument(\n        \"--fix\",\n        action=\"store_true\",\n        dest=\"fix\",\n        help=\"repair potentially damaged subtitle files with aeidon\")\n    parser.add_argument(\n        \"-g\", \"--gui\",\n        action=\"store_true\",\n        dest=\"gui\",\n        help=\"indicate use from a GUI\")\n    parser.add_argument(\n        \"-h\", \"--help\",\n        action=\"help\",\n        help=argparse.SUPPRESS)\n    parser.add_argument(\n        \"-r\", \"--regex\",\n        action=\"store_true\",\n        dest=\"regex\",\n        help=\"perform regex matching\")\n    parser.add_argument(\n        \"-s\", \"--case-sensitive\",\n        action=\"store_true\",\n        default=False,\n        dest=\"case_sensitive\",\n        help=\"match case-sensitively\")\n    parser.add_argument(\n        \"-y\", \"--yes\",\n        action=\"store_true\",\n        dest=\"autoyes\",\n        help=\"automatic yes to prompts\")\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version='%(prog)s ' + __version__)\n    parser.add_argument(\n        dest=\"targets\",\n        help=argparse.SUPPRESS,\n        nargs=\"*\")\n\n    options = parser.parse_args(args)\n    arguments = options.targets\n\n    return options, arguments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pattern_logic_aeidon():\n\n    if Config.options.pattern_files:\n        return prep_patterns(Config.options.pattern_files)\n    elif Config.options.regex:\n        return Config.REGEX\n    else:\n        return Config.TERMS", "response": "Return patterns to be used for searching subtitles via aeidon."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning patterns to be used for searching srt subtitles.", "response": "def pattern_logic_srt():\n    \"\"\"Return patterns to be used for searching srt subtitles.\"\"\"\n\n    if Config.options.pattern_files and Config.options.regex:\n        return prep_regex(prep_patterns(Config.options.pattern_files))\n    elif Config.options.pattern_files:\n        return prep_patterns(Config.options.pattern_files)\n    elif Config.options.regex:\n        return prep_regex(Config.REGEX)\n    else:\n        return Config.TERMS"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse paths and returns a list of filenames.", "response": "def prep_files(paths, extensions):\n    \"\"\"Parses `paths` (which may consist of files and/or directories).\n    Removes duplicates, sorts, and returns verified srt files.\"\"\"\n\n    from batchpath import GeneratePaths\n\n    filenames = GeneratePaths().files(paths, os.W_OK, extensions, 0, True)\n\n    if filenames:\n        return filenames\n    else:\n        LOGGER.error('No valid targets were specified')\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading pattern files passed via options and return list of patterns.", "response": "def prep_patterns(filenames):\n    \"\"\"Load pattern files passed via options and return list of patterns.\"\"\"\n\n    patterns = []\n\n    for filename in filenames:\n        try:\n            with open(filename) as file:\n                patterns += [l.rstrip('\\n') for l in file]\n        except:  # pylint: disable=W0702\n            LOGGER.error(\"Unable to load pattern file '%s'\" % filename)\n            sys.exit(1)\n\n    if patterns:\n        # return a set to eliminate duplicates\n        return set(patterns)\n    else:\n        LOGGER.error('No terms were loaded')\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisplaying information about obtaining the aeidon module.", "response": "def prerequisites():\n    \"\"\"Display information about obtaining the aeidon module.\"\"\"\n\n    url = \"http://home.gna.org/gaupol/download.html\"\n    debian = \"sudo apt-get install python3-aeidon\"\n    other = \"python3 setup.py --user --without-gaupol clean install\"\n\n    LOGGER.error(\n        \"The aeidon module is missing!\\n\\n\"\n        \"Try '{0}' or the appropriate command for your package manager.\\n\\n\"\n        \"You can also download the tarball for gaupol (which includes \"\n        \"aeidon) at {1}. After downloading, unpack and run '{2}'.\"\n        .format(debian, url, other))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_elements(target, indices):\n\n    copied = list(target)\n\n    for index in reversed(indices):\n        del copied[index]\n    return copied", "response": "Remove multiple elements from a list and return result."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start_aeidon():\n\n    extensions = ['ass', 'srt', 'ssa', 'sub']\n    Config.filenames = prep_files(Config.args, extensions)\n\n    Config.patterns = pattern_logic_aeidon()\n\n    for filename in Config.filenames:\n        AeidonProject(filename)", "response": "Prepare filenames and patterns then process subtitles with aeidon."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprepares filenames and patterns then process srt subtitles.", "response": "def start_srt():\n    \"\"\"Prepare filenames and patterns then process srt subtitles.\"\"\"\n\n    extensions = ['srt']\n    Config.filenames = prep_files(Config.args, extensions)\n\n    Config.patterns = pattern_logic_srt()\n\n    for filename in Config.filenames:\n        SrtProject(filename)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreplace characters or strings within subtitle file.", "response": "def fixchars(self):\n        \"\"\"Replace characters or strings within subtitle file.\"\"\"\n        for key in Config.CHARFIXES:\n            self.project.set_search_string(key)\n            self.project.set_search_replacement(Config.CHARFIXES[key])\n            self.project.replace_all()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nopening the subtitle file into an Aeidon project.", "response": "def open(self):\n        \"\"\"Open the subtitle file into an Aeidon project.\"\"\"\n        try:\n            self.project.open_main(self.filename)\n        except UnicodeDecodeError:\n            with open(self.filename, 'rb') as openfile:\n                encoding = get_encoding(openfile.read())\n\n            try:\n                self.project.open_main(self.filename, encoding)\n            except UnicodeDecodeError:\n                LOGGER.error(\"'%s' encountered a fatal encoding error\",\n                             self.filename)\n                sys.exit(1)\n            except:  # pylint: disable=W0702\n                open_error(self.filename)\n\n        except:  # pylint: disable=W0702\n            open_error(self.filename)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsearching srt in project for cells matching list of terms.", "response": "def search(self):\n        \"\"\"Search srt in project for cells matching list of terms.\"\"\"\n\n        matches = []\n        for pattern in Config.patterns:\n            matches += self.termfinder(pattern)\n\n        return sorted(set(matches), key=int)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsearch srt in project for cells matching term.", "response": "def termfinder(self, pattern):\n        \"\"\"Search srt in project for cells matching term.\"\"\"\n\n        if Config.options.regex:\n            flags = re.M | re.S | \\\n                (0 if Config.options.case_sensitive else re.I)\n            self.project.set_search_regex(\n                pattern, flags=flags)\n        else:\n            self.project.set_search_string(\n                pattern, ignore_case=not Config.options.case_sensitive)\n\n        matches = []\n\n        while True:\n            try:\n                if matches:\n                    last = matches[-1]\n                    new = self.project.find_next(last + 1)[0]\n                    if new != last and new > last:\n                        matches.append(new)\n                    else:\n                        break\n                else:\n                    matches.append(self.project.find_next()[0])\n            except StopIteration:\n                break\n\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fixchars(self, text):\n        keys = ''.join(Config.CHARFIXES.keys())\n        values = ''.join(Config.CHARFIXES.values())\n        fixed = text.translate(str.maketrans(keys, values))\n        if fixed != text:\n            self.modified = True\n        return fixed", "response": "Find and replace problematic characters."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nopens the subtitle file ( detect encoding if necessary ).", "response": "def open(self):\n        \"\"\"Open the subtitle file (detect encoding if necessary).\"\"\"\n        with open(self.filename, 'rb') as file_open:\n            binary = file_open.read()\n\n        try:\n            return binary.decode()\n        except UnicodeDecodeError:\n            encoding = get_encoding(binary)\n            try:\n                return binary.decode(encoding)\n            except LookupError:\n                return binary.decode(errors='ignore')\n            except:  # pylint: disable=W0702\n                open_error(self.filename)\n        except:  # pylint: disable=W0702\n            open_error(self.filename)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prompt(self, matches):\n\n        if Config.options.autoyes:\n            return matches\n\n        deletions = []\n\n        for match in matches:\n            os.system('clear')\n            print(self.cells[match])\n            print('----------------------------------------')\n            print(\"Delete cell %s of '%s'?\" % (str(match + 1), self.filename))\n            response = getch().lower()\n            if response == 'y':\n                os.system('clear')\n                deletions.append(match)\n            elif response == 'n':\n                os.system('clear')\n            else:\n                if deletions or self.modified:\n                    LOGGER.warning(\"Not saving changes made to '%s'\",\n                                   self.filename)\n                sys.exit(0)\n\n        return deletions", "response": "Prompt user to remove cells from subtitle file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self):\n\n        # re-number cells\n        self.cells = list(self.renumber())\n\n        # add a newline to the last line if necessary\n        if not self.cells[-1].endswith('\\n'):\n            self.cells[-1] += '\\n'\n\n        # save the rejoined the list of cells\n        with open(self.filename, 'w') as file_open:\n            file_open.write('\\n\\n'.join(self.cells))", "response": "Format and save cells."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of cells to be removed.", "response": "def search(self):\n        \"\"\"Return list of cells to be removed.\"\"\"\n\n        matches = []\n        for index, cell in enumerate(self.cells):\n            for pattern in Config.patterns:\n                if ismatch(cell, pattern):\n                    matches.append(index)\n                    break\n\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsplits text into a list of cells.", "response": "def split(self, text):\n        \"\"\"Split text into a list of cells.\"\"\"\n\n        import re\n        if re.search('\\n\\n', text):\n            return text.split('\\n\\n')\n        elif re.search('\\r\\n\\r\\n', text):\n            return text.split('\\r\\n\\r\\n')\n        else:\n            LOGGER.error(\"'%s' does not appear to be a 'srt' subtitle file\",\n                         self.filename)\n            sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, **kw): # NOQA\n    cls = cls or JSONEncoder\n    kwargs = {\n        \"obj\": obj,\n        \"skipkeys\": skipkeys,\n        \"ensure_ascii\": ensure_ascii,\n        \"check_circular\": check_circular,\n        \"allow_nan\": allow_nan,\n        \"cls\": cls,\n        \"indent\": indent,\n        \"separators\": separators,\n        \"default\": default,\n    }\n    kwargs.update(kw)\n\n    return json.dumps(**kwargs)", "response": "Serialize obj to a JSON formatted string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dict of year month and number of daily calls.", "response": "def _active_keys_by_month(ignore_internal_keys, monthly_minimum, cached=True):\n    \"\"\"\n    Returns a dict of (year, month) -> active_keys. The dict will contain a key\n    for each month observed in the data.\n    \"\"\"\n\n    cache_key = '_active_keys_by_month({0!r},{1!r})[{date!s}]'.format(ignore_internal_keys,\n                                                                      monthly_minimum,\n                                                                      date=datetime.date.today())\n    if cached == True:\n        result = cache.get(cache_key)\n        if result is not None:\n            return result\n\n    keys_issued_period = _keys_issued_date_range()\n\n    # We first do a (date, key) aggregation for the number of daily calls.\n    # We would do monthly aggregation here if we were using a newer version\n    # of django with ORM month accessors. This rolls up the per-method reports.\n    calls_by_key = Report.objects\n    if ignore_internal_keys:\n        calls_by_key = exclude_internal_key_reports(calls_by_key)\n    calls_by_key = (calls_by_key.values('date', 'key__key', 'key__email')\n                                .annotate(calls=Sum('calls'))\n                                .order_by('-calls'))\n\n    # Aggregate the daily aggregates into monthly aggregates (still on a per-key\n    # basis). This facilitates filtering keys by monthly usage.\n    grp_by = lambda r: (r['date'].year, r['date'].month, r['key__key'])\n    def sum_calls(grp, records):\n        return {'calls': sum([r['calls'] for r in records])}\n    calls_per_key_monthly = generic_aggregation(calls_by_key,\n                                                key=grp_by,\n                                                agg_func=sum_calls)\n    calls_per_key_monthly1 = ((grp, agg)\n                              for (grp, agg) in calls_per_key_monthly.iteritems()\n                              if agg['calls'] >= monthly_minimum)\n\n    # Now aggregate the (year, month, key) into the size of (year, month) groups.\n    grp_by_month = lambda ((year, month, key), agg): (year, month)\n    active_keys_per_month = generic_aggregation(calls_per_key_monthly1,\n                                                key=grp_by_month,\n                                                agg_func=lambda grp, records: len(records))\n    cache.set(cache_key, active_keys_per_month, timeout=(60 * 60 * 25))\n    return active_keys_per_month"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist API keys. Compatible with jQuery DataTables.", "response": "def keys(request):\n    \"\"\"Lists API keys. Compatible with jQuery DataTables.\"\"\"\n    iDisplayStart = parse_int_param(request, 'iDisplayStart')\n    iDisplayLength = parse_int_param(request, 'iDisplayLength')\n    sEcho = parse_int_param(request, 'sEcho')\n    iSortCol_0 = parse_int_param(request, 'iSortCol_0')\n    sSortDir_0 = request.GET.get('sSortDir_0', 'asc')\n    sSearch = request.GET.get('sSearch')\n\n    columns = ['key', 'email', 'calls', 'latest_call', 'issued_on']\n    qry = Key.objects\n    if sSearch not in (None, ''):\n        qry = qry.filter(Q(key__icontains=sSearch)\n                         | Q(email__icontains=sSearch)\n                         | Q(name__icontains=sSearch)\n                         | Q(org_name__icontains=sSearch)\n                         | Q(org_url__icontains=sSearch))\n    qry = qry.values('key', 'email', 'issued_on').annotate(calls=Sum('reports__calls'),\n                                                           latest_call=Max('reports__date'))\n    qry = qry.filter(calls__isnull=False)\n    qry = exclude_internal_keys(qry)\n    # TODO: Add multi-column sorting\n    if iSortCol_0 not in (None, ''):\n        sort_col_field = columns[iSortCol_0]\n        sort_spec = '{dir}{col}'.format(dir='-' if sSortDir_0 == 'desc' else '',\n                                        col=sort_col_field)\n        qry = qry.order_by(sort_spec)\n\n    result = {\n        'iTotalRecords': Key.objects.count(),\n        'iTotalDisplayRecords': qry.count(),\n        'sEcho': sEcho,\n        'aaData': [[k['key'],\n                    '<a href=\"{0}\">{1}</a>'.format(reverse('key_analytics', args=(k['key'], )), k['email']),\n                    k['calls'],\n                    k['latest_call'].isoformat(),\n                    k['issued_on'].date().isoformat()]\n                   for k in qry[iDisplayStart:iDisplayStart+iDisplayLength]]\n    }\n    return HttpResponse(content=json.dumps(result), status=200, content_type='application/json')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef flatten_all(list_of_list):\n    for i in list_of_list:\n        if hasattr(i, \"__iter__\"):\n            for j in flatten_all(i):\n                yield j\n        else:\n            yield i", "response": "Flatten arbitrary depth of nesting. Good for unknown nesting structure\n    iterable object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef running_windows(iterable, size):\n    fifo = collections.deque(maxlen=size)\n    for i in iterable:\n        fifo.append(i)\n        if len(fifo) == size:\n            yield list(fifo)", "response": "Generate n - size running windows."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a list return right hand cycle direction slice from start to end.", "response": "def cycle_slice(sliceable, start, end):\n    \"\"\"Given a list, return right hand cycle direction slice from start to end.\n\n    Usage::\n\n        >>> array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        >>> cycle_slice(array, 4, 7) # from array[4] to array[7]\n        [4, 5, 6, 7]\n\n        >>> cycle_slice(array, 8, 2) # from array[8] to array[2]\n        [8, 9, 0, 1, 2]\n    \"\"\"\n    if type(sliceable) != list:\n        sliceable = list(sliceable)\n\n    if end >= start:\n        return sliceable[start:end+1]\n    else:\n        return sliceable[start:] + sliceable[:end+1]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the distance between x y by means of a n - length cycle.", "response": "def cycle_dist(x, y, n):\n    \"\"\"Find Distance between x, y by means of a n-length cycle.\n\n    Example:\n\n        cycle_dist(1, 23, 24) = 2\n        cycle_dist(5, 13, 24) = 8\n        cycle_dist(0.0, 2.4, 1.0) = 0.4\n        cycle_dist(0.0, 2.6, 1.0) = 0.4\n    \"\"\"\n    dist = abs(x - y) % n\n    if dist >= 0.5 * n:\n        dist = n - dist\n    return dist"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nshift an array to the left.", "response": "def shift_to_the_left(array, dist, pad=True, trim=True):\n    \"\"\"Shift array to the left.\n\n    :param array: An iterable object.\n    :type array: iterable object\n    :param dist: how far you want to shift\n    :type disk: int\n    :param pad: pad array[-1] to the right.\n    :type pad: boolean (default True)\n    :param trim: trim the first ``#dist`` items.\n    :type trim: boolean (default True)\n\n    Usage::\n\n        >>> array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        >>> shift_to_the_left(self.iterable_list, 1, pad=True, trim=True)\n        [1, 2, 3, 4, 5, 6, 7, 8, 9, 9]\n\n        >>> shift_to_the_left(self.iterable_list, 1, pad=True, trim=False)\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9]\n\n        >>> shift_to_the_left(self.iterable_list, 1, pad=False, trim=True)\n        [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n        >>> shift_to_the_left(self.iterable_list, 1, pad=True, trim=True)\n        Warning, with pad=False and trim=False, no change applied.\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \"\"\"\n    if dist < 0:\n        raise ValueError(\"Shift distance has to greater or equal than 0.\")\n\n    if pad:\n        if trim:\n            new_array = array[dist:] + [array[-1]] * dist\n        else:\n            new_array = array + [array[-1]] * dist\n    else:\n        if trim:\n            new_array = array[dist:]\n        else:\n            print(\"Warning, with pad=False and trim=False, no change applied.\")\n            new_array = list(array)\n    return new_array"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef count_generator(generator, memory_efficient=True):\n    if memory_efficient:\n        counter = 0\n        for _ in generator:\n            counter += 1\n        return counter\n    else:\n        return len(list(generator))", "response": "Count the number of items in a generator."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a field key or name return it s field key.", "response": "def get_field_key(self, key, using_name=True):\n        \"\"\"Given a field key or name, return it's field key.\n        \"\"\"\n        try:\n            if using_name:\n                return self.f_name[key].key\n            else:\n                return self.f[key].key\n        except KeyError:\n            raise ValueError(\"'%s' are not found!\" % key)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive an object key or name return it s object key.", "response": "def get_object_key(self, key, using_name=True):\n        \"\"\"Given a object key or name, return it's object key.\n        \"\"\"\n        try:\n            if using_name:\n                return self.o_name[key].key\n            else:\n                return self.o[key].key\n        except KeyError:\n            raise ValueError(\"'%s' are not found!\" % key)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a folder and everything inside to zip archive.", "response": "def zip_a_folder(src, dst):\n    \"\"\"Add a folder and everything inside to zip archive.\n\n    Example::\n\n        |---paper\n            |--- algorithm.pdf\n            |--- images\n                |--- 1.jpg\n\n        zip_a_folder(\"paper\", \"paper.zip\")\n\n        paper.zip\n            |---paper\n                |--- algorithm.pdf\n                |--- images\n                    |--- 1.jpg\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u5c06\u6574\u4e2a\u6587\u4ef6\u5939\u6dfb\u52a0\u5230\u538b\u7f29\u5305, \u5305\u62ec\u6839\u76ee\u5f55\u672c\u8eab\u3002\n    \"\"\"\n    src, dst = os.path.abspath(src), os.path.abspath(dst)\n    cwd = os.getcwd()\n    todo = list()\n\n    dirname, basename = os.path.split(src)\n    os.chdir(dirname)\n    for dirname, _, fnamelist in os.walk(basename):\n        for fname in fnamelist:\n            newname = os.path.join(dirname, fname)\n            todo.append(newname)\n\n    with ZipFile(dst, \"w\") as f:\n        for newname in todo:\n            f.write(newname)\n\n    os.chdir(cwd)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef zip_many_files(list_of_abspath, dst):\n    base_dir = os.getcwd()\n\n    with ZipFile(dst, \"w\") as f:\n        for abspath in list_of_abspath:\n            dirname, basename = os.path.split(abspath)\n            os.chdir(dirname)\n            f.write(basename)\n\n    os.chdir(base_dir)", "response": "Add many files to a zip archive."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting binary content to gzip file.", "response": "def write_gzip(content, abspath):\n    \"\"\"Write binary content to gzip file.\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u5c06\u4e8c\u8fdb\u5236\u5185\u5bb9\u538b\u7f29\u540e\u7f16\u7801\u5199\u5165gzip\u538b\u7f29\u6587\u4ef6\u3002\n    \"\"\"\n    with gzip.open(abspath, \"wb\") as f:\n        f.write(content)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iter_bases(bases):\n\n        sequences = ([list(inspect.getmro(base)) for base in bases] +\n                     [list(bases)])\n\n        # Loop over sequences\n        while True:\n            sequences = [seq for seq in sequences if seq]\n            if not sequences:\n                return\n\n            # Select a good head\n            for seq in sequences:\n                head = seq[0]\n\n                tails = [seq for seq in sequences if head in seq[1:]]\n                if not tails:\n                    break\n            else:\n                raise TypeError('Cannot create a consistent method '\n                                'resolution order (MRO) for bases %s' %\n                                ', '.join([base.__name__ for base in bases]))\n\n            # Yield this base class\n            yield head\n\n            # Remove base class from all the other sequences\n            for seq in sequences:\n                if seq[0] == head:\n                    del seq[0]", "response": "Iterates over the base classes in turn."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms inheritance of dictionaries.", "response": "def inherit_dict(base, namespace, attr_name,\n                     inherit=lambda k, v: True):\n        \"\"\"\n        Perform inheritance of dictionaries.  Returns a list of key\n        and value pairs for values that were inherited, for\n        post-processing.\n\n        :param base: The base class being considered; see\n                     ``iter_bases()``.\n        :param namespace: The dictionary of the new class being built.\n        :param attr_name: The name of the attribute containing the\n                          dictionary to be inherited.\n        :param inherit: Filtering function to determine if a given\n                        item should be inherited.  If ``False`` or\n                        ``None``, item will not be added, but will be\n                        included in the returned items.  If a\n                        function, the function will be called with the\n                        key and value, and the item will be added and\n                        included in the items list only if the\n                        function returns ``True``.  By default, all\n                        items are added and included in the items\n                        list.\n        \"\"\"\n\n        items = []\n\n        # Get the dicts to compare\n        base_dict = getattr(base, attr_name, {})\n        new_dict = namespace.setdefault(attr_name, {})\n        for key, value in base_dict.items():\n            # Skip keys that have been overridden or that we shouldn't\n            # inherit\n            if key in new_dict or (inherit and not inherit(key, value)):\n                continue\n\n            # Inherit the key\n            if inherit:\n                new_dict[key] = value\n\n            # Save the item for post-processing\n            items.append((key, value))\n\n        return items"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef inherit_set(base, namespace, attr_name,\n                    inherit=lambda i: True):\n        \"\"\"\n        Perform inheritance of sets.  Returns a list of items that\n        were inherited, for post-processing.\n\n        :param base: The base class being considered; see\n                     ``iter_bases()``.\n        :param namespace: The dictionary of the new class being built.\n        :param attr_name: The name of the attribute containing the set\n                          to be inherited.\n        :param inherit: Filtering function to determine if a given\n                        item should be inherited.  If ``False`` or\n                        ``None``, item will not be added, but will be\n                        included in the returned items.  If a\n                        function, the function will be called with the\n                        item, and the item will be added and included\n                        in the items list only if the function returns\n                        ``True``.  By default, all items are added and\n                        included in the items list.\n        \"\"\"\n\n        items = []\n\n        # Get the sets to compare\n        base_set = getattr(base, attr_name, set())\n        new_set = namespace.setdefault(attr_name, set())\n        for item in base_set:\n            # Skip items that have been overridden or that we\n            # shouldn't inherit\n            if item in new_set or (inherit and not inherit(item)):\n                continue\n\n            # Inherit the item\n            if inherit:\n                new_set.add(item)\n\n            items.append(item)\n\n        return items", "response": "Perform inheritance of sets."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef call(self, input_data=None, *args, **kwargs):\n        self.build_request(input_data)\n        self.caller = RequestCall(self.request)\n        self.exception = None\n\n        try:\n            self.caller.call()\n            self.response = self.caller.response\n            self.decrypt_result()\n            return self.decrypted\n\n        except Exception as e:\n            self.exception = e\n            logger.info(\"Exception throw %s\", e)\n        pass", "response": "Calls the request and returns the decrypted result."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_request(self, input_data=None, *args, **kwargs):\n        if input_data is not None:\n            self.input_data = input_data\n        if self.input_data is None:\n            raise ValueError('Input data is None')\n        if self.uo is None:\n            raise ValueError('UO is None')\n\n        self.request = RequestHolder()\n        self.request.nonce = get_random_vector(EBConsts.FRESHNESS_NONCE_LEN)\n        self.request.api_object = EBUtils.build_api_object(self.uo)\n        self.request.endpoint = self.uo.resolve_endpoint()\n        self.request.configuration = self.configuration\n        self.request.api_method = EBConsts.REQUEST_PROCESS_DATA\n\n        # Build plaintext plain_buffer\n        plain_buffer = \\\n            to_bytes(31, 1) + to_bytes(self.uo.uo_id, 4) + \\\n            to_bytes(self.request.nonce, EBConsts.FRESHNESS_NONCE_LEN) + to_bytes(self.input_data)\n\n        plain_buffer = PKCS7.pad(plain_buffer)\n\n        # Encrypt-then-mac\n        ciphertext = aes_enc(self.uo.enc_key, plain_buffer)\n        mac = cbc_mac(self.uo.mac_key, ciphertext)\n\n        # Result request body\n        self.request.body = {\n            \"data\": \"Packet0_%s_0000%s\" % (EBUtils.get_request_type(self.uo), to_hex(ciphertext + mac))}\n        return self.request", "response": "Builds the request for the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decrypt_result(self, *args, **kwargs):\n        if self.response is None:\n            raise ValueError('Empty response')\n        if self.response.response is None \\\n                or 'result' not in self.response.response \\\n                or self.response.response['result'] is None:\n            raise ValueError('No result data')\n\n        res_hex = self.response.response['result']\n\n        # Strip out the plaintext part\n        plain_length = bytes_to_long(from_hex(res_hex[0:4]))\n        if plain_length > 0:\n            res_hex = res_hex[4 + plain_length:]\n        else:\n            res_hex = res_hex[4:]\n\n        # Optionally strip trailing _... string\n        idx_trail = res_hex.find('_')\n        if idx_trail != -1:\n            res_hex = res_hex[0:idx_trail]\n\n        # Decode hex coding\n        res_bytes = from_hex(res_hex)\n\n        # Crypto stuff - check the length & padding\n        if len(res_bytes) < 16:\n            raise InvalidResponse('Result too short')\n\n        mac_given = res_bytes[-16:]\n        res_bytes = res_bytes[:-16]\n\n        # Check the MAC\n        mac_computed = cbc_mac(self.uo.mac_key, res_bytes)\n        if not str_equals(mac_given, mac_computed):\n            raise CryptoError('MAC invalid')\n\n        # Decrypt\n        decrypted = aes_dec(self.uo.enc_key, res_bytes)\n        if len(decrypted) < 1 + 4 + 8 or decrypted[0:1] != bchr(0xf1):\n            raise InvalidResponse('Invalid format')\n\n        self.resp_object_id = bytes_to_long(decrypted[1:5])\n        self.resp_nonce = EBUtils.demangle_nonce(decrypted[5:5 + EBConsts.FRESHNESS_NONCE_LEN])\n        self.decrypted = decrypted[5 + EBConsts.FRESHNESS_NONCE_LEN:]\n        self.decrypted = PKCS7.unpad(self.decrypted)\n        return self.response", "response": "Decrypts ProcessData result with comm keys\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, cls, rid):\n        self.validate_record_type(cls)\n        rows = self.db.select(cls, where={ID: rid}, limit=1)\n        if not rows:\n            raise KeyError('No {} record with id {}'.format(cls, rid))\n        return rows[0]", "response": "Return record of given type with key rid"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create(self, cls, record, user='undefined'):\n        self.validate_record(cls, record)\n        record[CREATION_DATE] = record[UPDATE_DATE] = self.nowstr()\n        record[CREATOR] = record[UPDATER] = user\n        try:\n            return self.db.insert(cls, record)\n        except (psycopg2.IntegrityError, psycopg2.ProgrammingError,\n                psycopg2.DataError) as error:\n            logging.warning(\"{} {}: {}\".format(\n                error.__class__.__name__,\n                psycopg2.errorcodes.lookup(error.pgcode), error.pgerror))\n            if error.pgcode == psycopg2.errorcodes.UNIQUE_VIOLATION:\n                raise KeyError('There is already a record for {}/{}'.format(\n                    cls, record[ID]))\n            elif error.pgcode == psycopg2.errorcodes.UNDEFINED_COLUMN:\n                raise ValueError('Undefined field')\n            else:\n                raise ValueError('Bad record ({})'.format(\n                    psycopg2.errorcodes.lookup(error.pgcode)))", "response": "Create a new record in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, cls, rid, partialrecord, user='undefined'):\n        self.validate_partial_record(cls, partialrecord)\n        partialrecord[UPDATE_DATE] = self.nowstr()\n        partialrecord[UPDATER] = user\n        try:\n            updatecount = self.db.update(cls, partialrecord, where={ID: rid})\n            if updatecount < 1:\n                raise KeyError('No such record')\n        except (psycopg2.IntegrityError, psycopg2.ProgrammingError,\n                psycopg2.DataError) as error:\n            if error.pgcode == psycopg2.errorcodes.UNIQUE_VIOLATION:\n                raise KeyError('There is already a record for {}/{}'.format(\n                    cls, partialrecord[ID]))\n            elif error.pgcode == psycopg2.errorcodes.UNDEFINED_COLUMN:\n                raise ValueError('Undefined field')\n            else:\n                raise ValueError('Bad update ({})'.format(\n                    psycopg2.errorcodes.lookup(error.pgcode)))", "response": "Update a record in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of matching records.", "response": "def list(self, cls, criteria=None):\n        \"\"\"\n        Return list of matching records. criteria is a dict of {field: value}\n\n        >>> s = teststore()\n        >>> s.list('tstoretest')\n        []\n        \"\"\"\n        self.validate_criteria(cls, criteria)\n        return self.db.select(cls, where=criteria)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self, cls, rid, user='undefined'):\n        self.validate_record_type(cls)\n        deletedcount = self.db.delete(cls, {ID: rid})\n        if deletedcount < 1:\n            raise KeyError('No record {}/{}'.format(cls, rid))", "response": "Delete a record by id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate_record_type(self, cls):\n        if self.record_types and cls not in self.record_types:\n            raise ValueError('Unsupported record type \"' + cls + '\"')", "response": "Validate given record is acceptable."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_record(self, cls, content_type, strdata):\n        self.validate_record_type(cls)\n        parsedrecord = self.deserialize(content_type, strdata)\n        return self.post_process_record(cls, parsedrecord)", "response": "Returns a record from serialized string representation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef serialize(self, cls, record):\n        return json.dumps(record, cls=self.encoder)", "response": "Serialize the record to JSON. cls unused in this implementation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef when_i_send_the_request(context, method):\r\n    data = context.apiRequestData\r\n    context.apiRequest = context.apiClient.generic(\r\n        method,\r\n        data['url'],\r\n        data=json.dumps(data['params']),\r\n        content_type=data['content-type'],\r\n        format=data['format'],\r\n    )", "response": "Called when the client wants to send the request."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef then_the_return_value_for_is(context, key, value):\r\n    assert key in context.apiRequest.data\r\n    assert str(context.apiRequest.data[key]) == str(value)", "response": "Ensures that the value for key is value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the element with the given key exists in the given line.", "response": "def then_then_returned_element_have_a_key(context, line, key, value):\r\n    \"\"\"\r\n    :type line: str\r\n    :type key: str\r\n    :type value: str\r\n    :type context: behave.runner.Context\r\n    \"\"\"\r\n    line = int(line)\r\n    data = context.apiRequest.data\r\n    assert 0 <= line < len(data)\r\n    row = data[line]\r\n    assert key in row\r\n    assert row[key] == value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nassert that the return element does not have a key", "response": "def then_the_return_element_have_no_key(context, line, key):\r\n    \"\"\"\r\n    :param context: behave.runner.Context\r\n    :param line: str\r\n    :param key: str\r\n    \"\"\"\r\n    line = int(line)\r\n    data = context.apiRequest.data\r\n    assert 0 <= line < len(data)\r\n    assert key not in data[line]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _reset(self, framer):\n\n        # Do nothing if we're already properly initialized\n        if id(framer) == self._framer_id:\n            return\n\n        # Reset the state\n        self._other = {}\n\n        # Initialize the state and save the framer ID\n        framer.init_state(self)\n        self._framer_id = id(framer)", "response": "Reset the state of the internal state of the internal state of the framer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef frameify(self, state, data):\n\n        try:\n            yield state.recv_buf + data\n        except FrameSwitch:\n            pass\n        finally:\n            state.recv_buf = ''", "response": "Yield the data as a single frame."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef frameify(self, state, data):\n\n        # If we've pulled in all the chunk data, buffer the data\n        if state.chunk_remaining <= 0:\n            state.recv_buf += data\n            return\n\n        # Pull in any partially-processed data\n        data = state.recv_buf + data\n\n        # Determine how much belongs to the chunk\n        if len(data) <= state.chunk_remaining:\n            chunk = data\n            data = ''\n        else:\n            # Pull out only what's part of the chunk\n            chunk = data[:state.chunk_remaining]\n            data = data[state.chunk_remaining:]\n\n        # Update the state\n        state.recv_buf = data\n        state.chunk_remaining -= len(chunk)\n\n        # Yield the chunk\n        try:\n            yield chunk\n        except FrameSwitch:\n            pass", "response": "Yields the data as a single frame and buffer the rest."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsplitting data into a sequence of lines.", "response": "def frameify(self, state, data):\n        \"\"\"Split data into a sequence of lines.\"\"\"\n\n        # Pull in any partially-processed data\n        data = state.recv_buf + data\n\n        # Loop over the data\n        while data:\n            line, sep, rest = data.partition('\\n')\n\n            # Did we have a whole line?\n            if sep != '\\n':\n                break\n\n            # OK, update the data...\n            data = rest\n\n            # Now, strip off carriage return, if there is one\n            if self.carriage_return and line[-1] == '\\r':\n                line = line[:-1]\n\n            # Yield the line\n            try:\n                yield line\n            except FrameSwitch:\n                break\n\n        # Put any remaining data back into the buffer\n        state.recv_buf = data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef frameify(self, state, data):\n\n        # Pull in any partially-processed data\n        data = state.recv_buf + data\n\n        # Loop over the data\n        while data:\n            if state.frame_len is None:\n                # Try to grab a frame length from the data\n                if len(data) < self.fmt.size:\n                    # Not enough data; try back later\n                    break\n\n                # Extract the length\n                state.frame_len = self.fmt.unpack(data[:self.fmt.size])[0]\n                data = data[self.fmt.size:]\n\n            # Now that we have the frame length, extract the frame\n            if len(data) < state.frame_len:\n                # Not enough data; try back later\n                break\n\n            # OK, we have a full frame...\n            frame = data[:state.frame_len]\n            data = data[state.frame_len:]\n            state.frame_len = None\n\n            # Yield the frame\n            try:\n                yield frame\n            except FrameSwitch:\n                break\n\n        # Put any remaining data back into the buffer\n        state.recv_buf = data", "response": "Split data into a sequence of frames."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef streamify(self, state, frame):\n\n        return '%s%s' % (self.fmt.pack(len(frame)), frame)", "response": "Prepare frame for output as a length / frame stream."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef frameify(self, state, data):\n\n        # Pull in any partially-processed data\n        data = state.recv_buf + data\n\n        # Loop over the data\n        while data:\n            if not state.frame_start:\n                try:\n                    idx = data.index(self.prefix + self.begin)\n                except ValueError:\n                    # Can't find the start of a frame...\n                    break\n\n                # Advance data to the beginning of the frame (just\n                # after the marker)\n                data = data[idx + len(self.prefix) + 1:]\n                state.frame_start = True\n\n            # Now that data is sitting at the frame start, let's find\n            # the frame ending\n            try:\n                idx = data.index(self.prefix + self.end)\n            except ValueError:\n                # Can't find the end of the frame...\n                break\n\n            # OK, extract the frame and advance the data\n            frame = data[:idx]\n            data = data[idx + len(self.prefix) + 1:]\n            state.frame_start = (self.begin == self.end)\n\n            # Now we need to unstuff the frame\n            frame = self.prefix.join(frame.split(self.prefix + self.nop))\n\n            # Yield the frame\n            try:\n                yield frame\n            except FrameSwitch:\n                break\n\n        # Put any remaining data back into the buffer\n        state.recv_buf = data", "response": "Split data into a sequence of frames."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef streamify(self, state, frame):\n\n        # Split the frame apart for stuffing...\n        pieces = frame.split(self.prefix)\n\n        return '%s%s%s%s%s' % (self.prefix, self.begin,\n                               (self.prefix + self.nop).join(pieces),\n                               self.prefix, self.end)", "response": "Prepare the frame for output as a byte - stuffed stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_tab(cls):\n\n        if not cls._tabs['dec_cobs']:\n            # Compute the COBS table for decoding\n            cls._tabs['dec_cobs']['\\xff'] = (255, '')\n            cls._tabs['dec_cobs'].update(dict((chr(l), (l, '\\0'))\n                                              for l in range(1, 255)))\n\n            # Compute the COBS table for encoding\n            cls._tabs['enc_cobs'] = [(255, '\\xff'),\n                                     dict((l, chr(l))\n                                          for l in range(1, 255)),\n                                     ]\n\n        return cls._tabs['dec_cobs'], cls._tabs['enc_cobs']", "response": "Generate and return the COBS table."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate and return the COBS ZPE table.", "response": "def _get_tab_zpe(cls):\n        \"\"\"Generate and return the COBS ZPE table.\"\"\"\n\n        if not cls._tabs['dec_cobs_zpe']:\n            # Compute the COBS ZPE table for decoding\n            cls._tabs['dec_cobs_zpe']['\\xe0'] = (224, '')\n            cls._tabs['dec_cobs_zpe'].update(dict((chr(l), (l, '\\0'))\n                                                  for l in range(1, 224)))\n            cls._tabs['dec_cobs_zpe'].update(dict((chr(l), (l - 224, '\\0\\0'))\n                                                  for l in range(225, 256)))\n\n            # Compute the COBS ZPE table for encoding\n            cls._tabs['enc_cobs_zpe'] = [(224, '\\xe0'),\n                                         dict((l, chr(l))\n                                              for l in range(1, 224)),\n                                         dict((l - 224, chr(l))\n                                              for l in range(225, 256))\n                                         ]\n\n        return cls._tabs['dec_cobs_zpe'], cls._tabs['enc_cobs_zpe']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _decode(frame, tab):\n\n        blocks = []\n\n        # Decode each block\n        while frame:\n            length, endseq = tab[frame[0]]\n            blocks.extend([frame[1:length], endseq])\n            frame = frame[length:]\n\n        # Remove one (and only one) trailing '\\0' as necessary\n        if blocks and len(blocks[-1]) > 0:\n            blocks[-1] = blocks[-1][:-1]\n\n        # Return the decoded plaintext\n        return ''.join(blocks)", "response": "Decode a frame with the help of the table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsplit data into a sequence of frames.", "response": "def frameify(self, state, data):\n        \"\"\"Split data into a sequence of frames.\"\"\"\n\n        # Pull in any partially-processed data\n        data = state.recv_buf + data\n\n        # Loop over the data\n        while data:\n            frame, sep, rest = data.partition('\\0')\n\n            # Did we have a whole frame?\n            if sep != '\\0':\n                break\n\n            # OK, update the data...\n            data = rest\n\n            # Now, decode the frame and yield it\n            try:\n                yield self._decode(frame, self._tables[0])\n            except FrameSwitch:\n                break\n\n        # Put any remaining data back into the buffer\n        state.recv_buf = data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npreparing the frame for output as a COBS - encoded stream.", "response": "def streamify(self, state, frame):\n        \"\"\"Prepare frame for output as a COBS-encoded stream.\"\"\"\n\n        # Get the encoding table\n        enc_tab = self._tables[1][:]\n\n        # Need the special un-trailed block length and code\n        untrail_len, untrail_code = enc_tab.pop(0)\n\n        # Set up a repository to receive the encoded blocks\n        result = []\n\n        # Break the frame into blocks\n        blocks = frame.split('\\0')\n\n        # Now, walk the block list; done carefully because we need\n        # look-ahead in some cases\n        skip = False\n        for i in range(len(blocks)):\n            # Skip handled blocks\n            if skip:\n                skip = False\n                continue\n\n            blk = blocks[i]\n\n            # Encode un-trailed blocks\n            while len(blk) >= untrail_len - 1:\n                result.append(untrail_code + blk[:untrail_len - 1])\n                blk = blk[untrail_len - 1:]\n\n            # Do we care about look-ahead?\n            if (len(enc_tab) > 1 and i + 1 < len(blocks) and\n                    blocks[i + 1] == '' and len(blk) <= 30):\n                # Use the second encoder table\n                tab = enc_tab[1]\n\n                # Skip the following empty block\n                skip = True\n            else:\n                # Use the regular encoder table\n                tab = enc_tab[0]\n\n            # Encode the block\n            result.append(tab[len(blk) + 1] + blk)\n\n        # Stitch together the result blocks\n        return ''.join(result) + '\\0'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_conf(self, keys=[]):\n        confs = self.app.config.get('WAFFLE_CONFS', {})\n        if not keys:\n            keys = confs.keys()\n\n        result = {}\n\n        for key in keys:\n            # Some things cannot be changed...\n            if key.startswith('WAFFLE_'):\n                continue\n\n            # No arbitrary keys\n            if key not in confs.keys():\n                continue\n\n            stored_conf = self.configstore.get(key)\n\n            if not stored_conf:\n                # Store new record in database\n                value = confs[key].get('default', '')\n                stored_conf = self.configstore.put(key, util.serialize(value))\n                self.configstore.commit()\n\n            else:\n                # Get stored value\n                value = util.deserialize(stored_conf.get_value())\n\n            result[stored_conf.get_key()] = value\n\n        return result", "response": "Parse the configuration values from the database."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate database values and application configuration.", "response": "def update_db(self, new_values):\n        \"\"\"Update database values and application configuration.\n\n        The provided keys must be defined in the ``WAFFLE_CONFS`` setting.\n\n        Arguments:\n            new_values (dict): dict of configuration variables and their values\n                The dict has the following structure:\n\n                {\n                    'MY_CONFIG_VAR'  : <CONFIG_VAL>,\n                    'MY_CONFIG_VAR1' : <CONFIG_VAL1>\n                }\n        \"\"\"\n        confs = self.app.config.get('WAFFLE_CONFS', {})\n        to_update = {}\n\n        for key in new_values.keys():\n            # Some things cannot be changed...\n            if key.startswith('WAFFLE_'):\n                continue\n\n            # No arbitrary keys\n            if key not in confs.keys():\n                continue\n\n            value = new_values[key]\n            self.configstore.put(key, util.serialize(value))\n            self.configstore.commit()\n\n            to_update[key] = value\n\n        # Update config\n        if not to_update:\n            return\n\n        self.app.config.update(to_update)\n\n        # Notify other processes\n        if self.app.config.get('WAFFLE_MULTIPROC', False):\n            self.notify(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the configuration values from database.", "response": "def update_conf(self):\n        \"\"\"Update configuration values from database.\n\n        This method should be called when there is an update notification.\n        \"\"\"\n        parsed = self.parse_conf()\n\n        if not parsed:\n            return None\n\n        # Update app config\n        self.app.config.update(parsed)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_app(self, app, configstore):\n        if not hasattr(app, 'extensions'):\n            app.extensions = {}\n\n        self.state = _WaffleState(app, configstore)\n        app.extensions['waffleconf'] = self.state", "response": "Initialize the extension for the given application and store."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isolcss(prefix, css):\n    try:\n        # Attempt full strict parse, raise exception on failure.\n        all(True for m in matchiter(selrule_or_atom_re, css))\n    except ValueError as e:\n        logger.warning(\"Strict parse failed at char {}\".format(e.args[0]))\n        splits = matchiter(selrule_or_any_re, css)\n    else:\n        splits = matchiter(selrule_or_atom_re, css)\n\n    css = []\n\n    for m in splits:\n        if not m.groupdict()['sels']:\n            css.extend(m.group(0))\n            continue\n\n        sels = matchall(sel_re, m.group('sels'))\n\n        # This should never happen because sel_re is a subpattern\n        # of the original match.\n        assert sels, \"Failed to split selectors: {!r}\".format(m.group('sels'))\n\n        for sel in sels:\n            atoms = matchall(atom_re, sel)\n            if '&' in atoms:\n                sel = ''.join((prefix if a == '&' else a) for a in atoms)\n            else:\n                sel = '%s %s' % (prefix, sel)\n            css.append(sel)\n        css.append(m.group('ruleset'))\n\n    return ''.join(css)", "response": "Returns a css string with all selectors prefixed by prefix or replacing \"&\" as SASS and LESS both do."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef decrypt_file(filename, set_env=True, override_env=False):\n    data = json.load(open(filename))\n\n    results = {}\n\n    for key, v in data.iteritems():\n        v_decrypt = decrypt_secret(v)\n\n        results[key] = v_decrypt\n        if set_env:\n            if key in os.environ and not override_env:\n                break\n            os.environ[str(key)] = v_decrypt\n\n    return results", "response": "Decrypts a JSON file containing encrypted secrets."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef decrypt_or_cache(filename, **kwargs):\n    clear_fname = enc_to_clear_filename(filename)\n    if clear_fname:\n        return json.load(open(clear_fname))\n\n    return decrypt_file(filename, **kwargs)", "response": "Attempts to load a local version of decrypted secrets before making external api calls."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef touch(self, mode=0o666, exist_ok=True):\n        if exist_ok:\n            # First try to bump modification time\n            # Implementation note: GNU touch uses the UTIME_NOW option of\n            # the utimensat() / futimens() functions.\n            try:\n                os.utime(self, None)\n            except OSError:\n                # Avoid exception chaining\n                pass\n            else:\n                return\n        flags = os.O_CREAT | os.O_WRONLY\n        if not exist_ok:\n            flags |= os.O_EXCL\n        fd = os.open(self, flags, mode)\n        os.close(fd)", "response": "Create this file with the given access mode if it doesn t exist."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of files that match pat.", "response": "def glob(self, pat):\n        \"\"\"`pat` can be an extended glob pattern, e.g. `'**/*.less'`\n           This code handles negations similarly to node.js' minimatch, i.e.\n           a leading `!` will negate the entire pattern.\n        \"\"\"\n        r = \"\"\n        negate = int(pat.startswith('!'))\n        i = negate\n\n        while i < len(pat):\n            if pat[i:i + 3] == '**/':\n                r += \"(?:.*/)?\"\n                i += 3\n            elif pat[i] == \"*\":\n                r += \"[^/]*\"\n                i += 1\n            elif pat[i] == \".\":\n                r += \"[.]\"\n                i += 1\n            elif pat[i] == \"?\":\n                r += \".\"\n                i += 1\n            else:\n                r += pat[i]\n                i += 1\n        r += r'\\Z(?ms)'\n        # print '\\n\\npat', pat\n        # print 'regex:', r\n        # print [s.relpath(self).replace('\\\\', '/') for s in self]\n        rx = re.compile(r)\n\n        def match(d):\n            m = rx.match(d)\n            return not m if negate else m\n\n        return [s for s in self if match(s.relpath(self).replace('\\\\', '/'))]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning all direct descendands of directory self for which filterfn returns True.", "response": "def list(self, filterfn=lambda x: True):\n        \"\"\"Return all direct descendands of directory `self` for which\n           `filterfn` returns True.\n        \"\"\"\n        return [self / p for p in self.listdir() if filterfn(self / p)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rm(self, fname=None):\n        if fname is not None:\n            return (self / fname).rm()\n        try:\n            self.remove()\n        except OSError:\n            pass", "response": "Remove a file from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchunking one big list into few small lists.", "response": "def chunked(l, n):\n    \"\"\"Chunk one big list into few small lists.\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef login(self, username, passwd_hash, webapi_key, country_code=1):\n        self.client = Client(self.webapi_url)\n        self.ArrayOfLong = self.client.get_type('ns0:ArrayOfLong')  # this should be done by zeep...\n        ver_key = self.client.service.doQuerySysStatus(1, 1, webapi_key)['verKey']\n        return self.client.service.doLoginEnc(username, passwd_hash,\n                                              country_code, webapi_key,\n                                              ver_key)['sessionHandlePart']", "response": "Log in. Returns token."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nretrieve all bids in given auction.", "response": "def getBids(self, auction_id):\n        \"\"\"Retrieve all bids in given auction.\"\"\"\n        bids = {}\n        rc = self.__ask__('doGetBidItem2', itemId=auction_id)\n        if rc:\n            for i in rc:\n                i = i['bidsArray']\n                bids[long(i['item'][1])] = {\n                    'price': Decimal(i['item'][6]),\n                    'quantity': int(i['item'][5]),\n                    'date_buy': i['item'][7]\n                }\n        return bids"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of orders details.", "response": "def getOrders(self, auction_ids):\n        \"\"\"Return orders details.\"\"\"\n        orders = {}\n        # chunk list (only 25 auction_ids per request)\n        for chunk in chunked(auction_ids, 25):\n            # auctions = [{'item': auction_id} for auction_id in chunk]  # TODO?: is it needed?\n            auctions = self.ArrayOfLong(chunk)\n            rc = self.__ask__('doGetPostBuyData', itemsArray=auctions)\n            for auction in rc:\n                orders_auction = []\n                bids = self.getBids(auction['itemId'])\n                # get orders details\n                # for i in auction.get('usersPostBuyData', ()):\n                if not auction['usersPostBuyData']:  # empty\n                    continue\n                for i in auction['usersPostBuyData']['item']:\n                    i = i['userData']\n                    if i['userId'] not in bids:  # temporary(?) webapi bug fix\n                        continue\n                    orders_auction.append({\n                        'allegro_aid': auction['itemId'],\n                        'allegro_uid': i['userId'],\n                        'allegro_login': magicDecode(i['userLogin']),\n                        'name': magicDecode(i['userFirstName']),\n                        'surname': magicDecode(i['userLastName']),\n                        'company': magicDecode(i['userCompany']),\n                        'postcode': magicDecode(i['userPostcode']),\n                        'city': magicDecode(i['userCity']),\n                        'address': magicDecode(i['userAddress']),\n                        'email': magicDecode(i['userEmail']),\n                        'phone': i['userPhone'],\n                        'price': bids[i['userId']]['price'],\n                        'quantity': bids[i['userId']]['quantity'],\n                        'date_buy': bids[i['userId']]['date_buy']\n                    })\n                orders[auction['itemId']] = orders_auction\n        return orders"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getTotalPaid(self, auction_id, buyer_id):\n        # TODO: it has to be better way to check payments.\n        date_end = long(time.time())\n        date_start = date_end - 60 * 60 * 24 * 90\n        rc = self.__ask__('doGetMyIncomingPayments',\n                          buyerId=buyer_id,\n                          itemId=auction_id,\n                          transRecvDateFrom=date_start,\n                          transRecvDateTo=date_end,\n                          transPageLimit=25,  # notneeded | TODO: can be more than 25 payments\n                          transOffset=0)\n        paid = 0\n        for t in (rc or []):\n            # t = t['item']\n            if t['payTransStatus'] == u'Zako\u0144czona' and t['payTransIncomplete'] == 0:\n                if t['payTransItId'] == 0:  # wplata laczna\n                    for td in t['payTransDetails']['item']:\n                        if td['payTransDetailsItId'] == auction_id:\n                            paid += Decimal(str(td['payTransDetailsPrice']))\n                else:  # wplata pojedyncza\n                    paid += Decimal(str(t['payTransAmount']))\n        return paid", "response": "Return total paid from buyer on single auction."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning all journal events from start.", "response": "def getJournalDeals(self, start=None):\n        \"\"\"Return all journal events from start.\"\"\"\n        # 1 - utworzenie aktu zakupowego (deala), 2 - utworzenie formularza pozakupowego (karta platnosci), 3 - anulowanie formularza pozakupowego (karta platnosci), 4 - zako\u0144czenie (op\u0142acenie) transakcji przez PzA\n        if start is not None:\n            self.last_event_id = start\n        events = []\n        while self.getJournalDealsInfo(self.last_event_id) > 0:\n            rc = self.__ask__('doGetSiteJournalDeals', journalStart=self.last_event_id)\n            for i in rc:\n                events.append({\n                    'allegro_did': i['dealId'],\n                    'deal_status': i['dealEventType'],\n                    'transaction_id': i['dealTransactionId'],\n                    'time': i['dealEventTime'],\n                    'event_id': i['dealEventId'],\n                    'allegro_aid': i['dealItemId'],\n                    'allegro_uid': i['dealBuyerId'],\n                    # 'seller_id': i['dealSellerId '],\n                    'quantity': i['dealQuantity']\n                })\n            self.last_event_id = rc[-1]['dealEventId']\n        return events"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all waiting feedbacks from buyers.", "response": "def getWaitingFeedbacks(self):\n        \"\"\"Return all waiting feedbacks from buyers.\"\"\"\n        # TODO: return sorted dictionary (negative/positive/neutral)\n        feedbacks = []\n        offset = 0\n        amount = self.__ask__('doGetWaitingFeedbacksCount')\n        while amount > 0:\n            rc = self.__ask__('doGetWaitingFeedbacks',\n                              offset=offset, packageSize=200)\n            feedbacks.extend(rc['feWaitList'])\n            amount -= 200\n            offset += 1\n        return feedbacks"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef import_class(class_path):\n    splitted = class_path.split('.')\n    mod_path = '.'.join(splitted[:-1])\n    class_name = splitted[-1]\n    # import may throw ImportError\n    class_mod = __import__(mod_path, {}, {}, [class_name])\n    try:\n        cls = getattr(class_mod, class_name)\n    except AttributeError:\n        raise ImportError(\"Couldn't import %r\" % class_path)\n    return cls", "response": "Imports the class from the given path."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls the given shell command. Output will not be displayed. Returns the status code.", "response": "def silent(cmd, **kwargs):\n    \"\"\"Calls the given shell command. Output will not be displayed. Returns the\n    status code.\n\n    **Examples**:\n    ::\n        auxly.shell.silent(\"ls\")\n    \"\"\"\n    return call(cmd, shell=True, stdout=NULL, stderr=NULL, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef has(cmd):\n    helps = [\"--help\", \"-h\", \"--version\"]\n    if \"nt\" == os.name:\n        helps.insert(0, \"/?\")\n    fakecmd = \"fakecmd\"\n    cmderr = strerr(fakecmd).replace(fakecmd, cmd)\n    for h in helps:\n        hcmd = \"%s %s\" % (cmd, h)\n        if 0 == silent(hcmd):\n            return True\n        if len(listout(hcmd)) > 0:\n            return True\n        if strerr(hcmd) != cmderr:\n            return True\n    return False", "response": "Returns True if the give shell command is available."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates through the lines of a stderr stream for the given shell command.", "response": "def iterstd(cmd, std=\"out\", **kwargs):\n    \"\"\"Iterates through the lines of a stderr/stdout stream for the given shell\n    command.\"\"\"\n    def _readline():\n        while True:\n            line = getattr(proc, \"std\"+std).readline()\n            if line != b\"\":\n                yield line.rstrip().decode(\"UTF-8\", \"replace\")\n            else:\n                break\n    kwargs['shell'] = True\n    kwargs['stdout'] = subprocess.PIPE\n    kwargs['stderr'] = subprocess.PIPE\n    if sys.version_info >= (3,0):\n        with subprocess.Popen(cmd, **kwargs) as proc:\n            for line in _readline(): yield line\n    else:\n        proc = subprocess.Popen(cmd, **kwargs)\n        for line in _readline(): yield line\n        proc.kill()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse an RFC822 date string into a tuple of datetime objects.", "response": "def _parse_date_rfc822(dateString):\r\n    '''Parse an RFC822, RFC1123, RFC2822, or asctime-style date'''\r\n    data = dateString.split()\r\n    if data[0][-1] in (',', '.') or data[0].lower() in rfc822._daynames:\r\n        del data[0]\r\n    if len(data) == 4:\r\n        s = data[3]\r\n        i = s.find('+')\r\n        if i > 0:\r\n            data[3:] = [s[:i], s[i+1:]]\r\n        else:\r\n            data.append('')\r\n        dateString = \" \".join(data)\r\n    if len(data) < 5:\r\n        dateString += ' 00:00:00 GMT'\r\n    return rfc822.parsedate_tz(dateString)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _buildTime(self, source, quantity, modifier, units):\r\n        if _debug:\r\n            print '_buildTime: [%s][%s][%s]' % (quantity, modifier, units)\r\n\r\n        if source is None:\r\n            source = time.localtime()\r\n\r\n        if quantity is None:\r\n            quantity = ''\r\n        else:\r\n            quantity = quantity.strip()\r\n\r\n        if len(quantity) == 0:\r\n            qty = 1\r\n        else:\r\n            try:\r\n                qty = int(quantity)\r\n            except ValueError:\r\n                qty = 0\r\n\r\n        if modifier in self.ptc.Modifiers:\r\n            qty = qty * self.ptc.Modifiers[modifier]\r\n\r\n            if units is None or units == '':\r\n                units = 'dy'\r\n\r\n        # plurals are handled by regex's (could be a bug tho)\r\n\r\n        (yr, mth, dy, hr, mn, sec, _, _, _) = source\r\n\r\n        start  = datetime.datetime(yr, mth, dy, hr, mn, sec)\r\n        target = start\r\n\r\n        if units.startswith('y'):\r\n            target        = self.inc(start, year=qty)\r\n            self.dateFlag = 1\r\n        elif units.endswith('th') or units.endswith('ths'):\r\n            target        = self.inc(start, month=qty)\r\n            self.dateFlag = 1\r\n        else:\r\n            if units.startswith('d'):\r\n                target        = start + datetime.timedelta(days=qty)\r\n                self.dateFlag = 1\r\n            elif units.startswith('h'):\r\n                target        = start + datetime.timedelta(hours=qty)\r\n                self.timeFlag = 2\r\n            elif units.startswith('m'):\r\n                target        = start + datetime.timedelta(minutes=qty)\r\n                self.timeFlag = 2\r\n            elif units.startswith('s'):\r\n                target        = start + datetime.timedelta(seconds=qty)\r\n                self.timeFlag = 2\r\n            elif units.startswith('w'):\r\n                target        = start + datetime.timedelta(weeks=qty)\r\n                self.dateFlag = 1\r\n\r\n        return target.timetuple()", "response": "Build a time from a source time and a quantity and a modifier and units."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parseDate(self, dateString):\r\n        yr, mth, dy, hr, mn, sec, wd, yd, isdst = time.localtime()\r\n\r\n        # values pulled from regex's will be stored here and later\r\n        # assigned to mth, dy, yr based on information from the locale\r\n        # -1 is used as the marker value because we want zero values\r\n        # to be passed thru so they can be flagged as errors later\r\n        v1 = -1\r\n        v2 = -1\r\n        v3 = -1\r\n\r\n        s = dateString\r\n        m = self.ptc.CRE_DATE2.search(s)\r\n        if m is not None:\r\n            index = m.start()\r\n            v1    = int(s[:index])\r\n            s     = s[index + 1:]\r\n\r\n        m = self.ptc.CRE_DATE2.search(s)\r\n        if m is not None:\r\n            index = m.start()\r\n            v2    = int(s[:index])\r\n            v3    = int(s[index + 1:])\r\n        else:\r\n            v2 = int(s.strip())\r\n\r\n        v = [ v1, v2, v3 ]\r\n        d = { 'm': mth, 'd': dy, 'y': yr }\r\n\r\n        for i in range(0, 3):\r\n            n = v[i]\r\n            c = self.ptc.dp_order[i]\r\n            if n >= 0:\r\n                d[c] = n\r\n\r\n        # if the year is not specified and the date has already\r\n        # passed, increment the year\r\n        if v3 == -1 and ((mth > d['m']) or (mth == d['m'] and dy > d['d'])):\r\n            yr = d['y'] + 1\r\n        else:\r\n            yr  = d['y']\r\n\r\n        mth = d['m']\r\n        dy  = d['d']\r\n\r\n        # birthday epoch constraint\r\n        if yr < self.ptc.BirthdayEpoch:\r\n            yr += 2000\r\n        elif yr < 100:\r\n            yr += 1900\r\n\r\n        if _debug:\r\n            print 'parseDate: ', yr, mth, dy, self.ptc.daysInMonth(mth, yr)\r\n\r\n        if (mth > 0 and mth <= 12) and \\\r\n           (dy > 0 and dy <= self.ptc.daysInMonth(mth, yr)):\r\n            sourceTime = (yr, mth, dy, hr, mn, sec, wd, yd, isdst)\r\n        else:\r\n            self.dateFlag = 0\r\n            self.timeFlag = 0\r\n            sourceTime    = time.localtime() # return current time if date\r\n                                             # string is invalid\r\n\r\n        return sourceTime", "response": "Parse short - form date strings::\r\n            05. 28 2006 or 04. 21"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses long - form date strings and return a time object.", "response": "def parseDateText(self, dateString):\r\n        \"\"\"\r\n        Parse long-form date strings::\r\n\r\n            'May 31st, 2006'\r\n            'Jan 1st'\r\n            'July 2006'\r\n\r\n        @type  dateString: string\r\n        @param dateString: text to convert to a datetime\r\n\r\n        @rtype:  struct_time\r\n        @return: calculated C{struct_time} value of dateString\r\n        \"\"\"\r\n        yr, mth, dy, hr, mn, sec, wd, yd, isdst = time.localtime()\r\n\r\n        currentMth = mth\r\n        currentDy  = dy\r\n\r\n        s   = dateString.lower()\r\n        m   = self.ptc.CRE_DATE3.search(s)\r\n        mth = m.group('mthname')\r\n        mth = self.ptc.MonthOffsets[mth]\r\n\r\n        if m.group('day') !=  None:\r\n            dy = int(m.group('day'))\r\n        else:\r\n            dy = 1\r\n\r\n        if m.group('year') !=  None:\r\n            yr = int(m.group('year'))\r\n\r\n            # birthday epoch constraint\r\n            if yr < self.ptc.BirthdayEpoch:\r\n                yr += 2000\r\n            elif yr < 100:\r\n                yr += 1900\r\n\r\n        elif (mth < currentMth) or (mth == currentMth and dy < currentDy):\r\n            # if that day and month have already passed in this year,\r\n            # then increment the year by 1\r\n            yr += 1\r\n\r\n        if dy > 0 and dy <= self.ptc.daysInMonth(mth, yr):\r\n            sourceTime = (yr, mth, dy, hr, mn, sec, wd, yd, isdst)\r\n        else:\r\n            # Return current time if date string is invalid\r\n            self.dateFlag = 0\r\n            self.timeFlag = 0\r\n            sourceTime    = time.localtime()\r\n\r\n        return sourceTime"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef evalRanges(self, datetimeString, sourceTime=None):\r\n        startTime = ''\r\n        endTime   = ''\r\n        startDate = ''\r\n        endDate   = ''\r\n        rangeFlag = 0\r\n\r\n        s = datetimeString.strip().lower()\r\n\r\n        if self.ptc.rangeSep in s:\r\n            s = s.replace(self.ptc.rangeSep, ' %s ' % self.ptc.rangeSep)\r\n            s = s.replace('  ', ' ')\r\n\r\n        m = self.ptc.CRE_TIMERNG1.search(s)\r\n        if m is not None:\r\n            rangeFlag = 1\r\n        else:\r\n            m = self.ptc.CRE_TIMERNG2.search(s)\r\n            if m is not None:\r\n                rangeFlag = 2\r\n            else:\r\n                m = self.ptc.CRE_TIMERNG4.search(s)\r\n                if m is not None:\r\n                    rangeFlag = 7\r\n                else:\r\n                    m = self.ptc.CRE_TIMERNG3.search(s)\r\n                    if m is not None:\r\n                        rangeFlag = 3\r\n                    else:\r\n                        m = self.ptc.CRE_DATERNG1.search(s)\r\n                        if m is not None:\r\n                            rangeFlag = 4\r\n                        else:\r\n                            m = self.ptc.CRE_DATERNG2.search(s)\r\n                            if m is not None:\r\n                                rangeFlag = 5\r\n                            else:\r\n                                m = self.ptc.CRE_DATERNG3.search(s)\r\n                                if m is not None:\r\n                                    rangeFlag = 6\r\n\r\n        if _debug:\r\n            print 'evalRanges: rangeFlag =', rangeFlag, '[%s]' % s\r\n\r\n        if m is not None:\r\n            if (m.group() != s):\r\n                # capture remaining string\r\n                parseStr = m.group()\r\n                chunk1   = s[:m.start()]\r\n                chunk2   = s[m.end():]\r\n                s        = '%s %s' % (chunk1, chunk2)\r\n                flag     = 1\r\n\r\n                sourceTime, flag = self.parse(s, sourceTime)\r\n\r\n                if flag == 0:\r\n                    sourceTime = None\r\n            else:\r\n                parseStr = s\r\n\r\n        if rangeFlag == 1:\r\n            m                = re.search(self.ptc.rangeSep, parseStr)\r\n            startTime, sflag = self.parse((parseStr[:m.start()]),       sourceTime)\r\n            endTime, eflag   = self.parse((parseStr[(m.start() + 1):]), sourceTime)\r\n\r\n            if (eflag != 0)  and (sflag != 0):\r\n                return (startTime, endTime, 2)\r\n\r\n        elif rangeFlag == 2:\r\n            m                = re.search(self.ptc.rangeSep, parseStr)\r\n            startTime, sflag = self.parse((parseStr[:m.start()]),       sourceTime)\r\n            endTime, eflag   = self.parse((parseStr[(m.start() + 1):]), sourceTime)\r\n\r\n            if (eflag != 0)  and (sflag != 0):\r\n                return (startTime, endTime, 2)\r\n\r\n        elif rangeFlag == 3 or rangeFlag == 7:\r\n            m = re.search(self.ptc.rangeSep, parseStr)\r\n            # capturing the meridian from the end time\r\n            if self.ptc.usesMeridian:\r\n                ampm = re.search(self.ptc.am[0], parseStr)\r\n\r\n                # appending the meridian to the start time\r\n                if ampm is not None:\r\n                    startTime, sflag = self.parse((parseStr[:m.start()] + self.ptc.meridian[0]), sourceTime)\r\n                else:\r\n                    startTime, sflag = self.parse((parseStr[:m.start()] + self.ptc.meridian[1]), sourceTime)\r\n            else:\r\n                startTime, sflag = self.parse((parseStr[:m.start()]), sourceTime)\r\n\r\n            endTime, eflag = self.parse(parseStr[(m.start() + 1):], sourceTime)\r\n\r\n            if (eflag != 0)  and (sflag != 0):\r\n                return (startTime, endTime, 2)\r\n\r\n        elif rangeFlag == 4:\r\n            m                = re.search(self.ptc.rangeSep, parseStr)\r\n            startDate, sflag = self.parse((parseStr[:m.start()]),       sourceTime)\r\n            endDate, eflag   = self.parse((parseStr[(m.start() + 1):]), sourceTime)\r\n\r\n            if (eflag != 0)  and (sflag != 0):\r\n                return (startDate, endDate, 1)\r\n\r\n        elif rangeFlag == 5:\r\n            m       = re.search(self.ptc.rangeSep, parseStr)\r\n            endDate = parseStr[(m.start() + 1):]\r\n\r\n            # capturing the year from the end date\r\n            date    = self.ptc.CRE_DATE3.search(endDate)\r\n            endYear = date.group('year')\r\n\r\n            # appending the year to the start date if the start date\r\n            # does not have year information and the end date does.\r\n            # eg : \"Aug 21 - Sep 4, 2007\"\r\n            if endYear is not None:\r\n                startDate = (parseStr[:m.start()]).strip()\r\n                date      = self.ptc.CRE_DATE3.search(startDate)\r\n                startYear = date.group('year')\r\n\r\n                if startYear is None:\r\n                    startDate = startDate + ', ' + endYear\r\n            else:\r\n                startDate = parseStr[:m.start()]\r\n\r\n            startDate, sflag = self.parse(startDate, sourceTime)\r\n            endDate, eflag   = self.parse(endDate, sourceTime)\r\n\r\n            if (eflag != 0)  and (sflag != 0):\r\n                return (startDate, endDate, 1)\r\n\r\n        elif rangeFlag == 6:\r\n            m = re.search(self.ptc.rangeSep, parseStr)\r\n\r\n            startDate = parseStr[:m.start()]\r\n\r\n            # capturing the month from the start date\r\n            mth = self.ptc.CRE_DATE3.search(startDate)\r\n            mth = mth.group('mthname')\r\n\r\n            # appending the month name to the end date\r\n            endDate = mth + parseStr[(m.start() + 1):]\r\n\r\n            startDate, sflag = self.parse(startDate, sourceTime)\r\n            endDate, eflag   = self.parse(endDate, sourceTime)\r\n\r\n            if (eflag != 0)  and (sflag != 0):\r\n                return (startDate, endDate, 1)\r\n        else:\r\n            # if range is not found\r\n            sourceTime = time.localtime()\r\n\r\n            return (sourceTime, sourceTime, 0)", "response": "Evaluate the text and determine if\r\n        it represents a date or time range."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _CalculateDOWDelta(self, wd, wkdy, offset, style, currentDayStyle):\r\n        if offset == 1:\r\n            # modifier is indicating future week eg: \"next\".\r\n            # DOW is calculated as DOW of next week\r\n            diff = 7 - wd + wkdy\r\n\r\n        elif offset == -1:\r\n            # modifier is indicating past week eg: \"last\",\"previous\"\r\n            # DOW is calculated as DOW of previous week\r\n            diff = wkdy - wd - 7\r\n\r\n        elif offset == 0:\r\n            # modifier is indiacting current week eg: \"this\"\r\n            # DOW is calculated as DOW of this week\r\n            diff = wkdy - wd\r\n\r\n        elif offset == 2:\r\n            # no modifier is present.\r\n            # i.e. string to be parsed is just DOW\r\n            if style == 1:\r\n                # next occurance of the DOW is calculated\r\n                if currentDayStyle == True:\r\n                    if wkdy >= wd:\r\n                        diff = wkdy - wd\r\n                    else:\r\n                        diff = 7 - wd + wkdy\r\n                else:\r\n                    if wkdy > wd:\r\n                        diff = wkdy - wd\r\n                    else:\r\n                        diff = 7 - wd + wkdy\r\n\r\n            elif style == -1:\r\n                # last occurance of the DOW is calculated\r\n                if currentDayStyle == True:\r\n                    if wkdy <= wd:\r\n                        diff = wkdy - wd\r\n                    else:\r\n                        diff = wkdy - wd - 7\r\n                else:\r\n                    if wkdy < wd:\r\n                        diff = wkdy - wd\r\n                    else:\r\n                        diff = wkdy - wd - 7\r\n            else:\r\n                # occurance of the DOW in the current week is calculated\r\n                diff = wkdy - wd\r\n\r\n        if _debug:\r\n            print \"wd %s, wkdy %s, offset %d, style %d\\n\" % (wd, wkdy, offset, style)\r\n\r\n        return diff", "response": "Calculates the delta between the current and the given day - of - week values."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _evalModifier(self, modifier, chunk1, chunk2, sourceTime):\r\n        offset = self.ptc.Modifiers[modifier]\r\n\r\n        if sourceTime is not None:\r\n            (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = sourceTime\r\n        else:\r\n            (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = time.localtime()\r\n\r\n        # capture the units after the modifier and the remaining\r\n        # string after the unit\r\n        m = self.ptc.CRE_REMAINING.search(chunk2)\r\n        if m is not None:\r\n            index  = m.start() + 1\r\n            unit   = chunk2[:m.start()]\r\n            chunk2 = chunk2[index:]\r\n        else:\r\n            unit   = chunk2\r\n            chunk2 = ''\r\n\r\n        flag = False\r\n\r\n        if unit == 'month' or \\\r\n           unit == 'mth' or \\\r\n           unit == 'm':\r\n            if offset == 0:\r\n                dy         = self.ptc.daysInMonth(mth, yr)\r\n                sourceTime = (yr, mth, dy, 9, 0, 0, wd, yd, isdst)\r\n            elif offset == 2:\r\n                # if day is the last day of the month, calculate the last day\r\n                # of the next month\r\n                if dy == self.ptc.daysInMonth(mth, yr):\r\n                    dy = self.ptc.daysInMonth(mth + 1, yr)\r\n\r\n                start      = datetime.datetime(yr, mth, dy, 9, 0, 0)\r\n                target     = self.inc(start, month=1)\r\n                sourceTime = target.timetuple()\r\n            else:\r\n                start      = datetime.datetime(yr, mth, 1, 9, 0, 0)\r\n                target     = self.inc(start, month=offset)\r\n                sourceTime = target.timetuple()\r\n\r\n            flag = True\r\n            self.dateFlag = 1\r\n\r\n        if unit == 'week' or \\\r\n             unit == 'wk' or \\\r\n             unit == 'w':\r\n            if offset == 0:\r\n                start      = datetime.datetime(yr, mth, dy, 17, 0, 0)\r\n                target     = start + datetime.timedelta(days=(4 - wd))\r\n                sourceTime = target.timetuple()\r\n            elif offset == 2:\r\n                start      = datetime.datetime(yr, mth, dy, 9, 0, 0)\r\n                target     = start + datetime.timedelta(days=7)\r\n                sourceTime = target.timetuple()\r\n            else:\r\n                return self._evalModifier(modifier, chunk1, \"monday \" + chunk2, sourceTime)\r\n\r\n            flag          = True\r\n            self.dateFlag = 1\r\n\r\n        if unit == 'day' or \\\r\n            unit == 'dy' or \\\r\n            unit == 'd':\r\n            if offset == 0:\r\n                sourceTime    = (yr, mth, dy, 17, 0, 0, wd, yd, isdst)\r\n                self.timeFlag = 2\r\n            elif offset == 2:\r\n                start      = datetime.datetime(yr, mth, dy, hr, mn, sec)\r\n                target     = start + datetime.timedelta(days=1)\r\n                sourceTime = target.timetuple()\r\n            else:\r\n                start      = datetime.datetime(yr, mth, dy, 9, 0, 0)\r\n                target     = start + datetime.timedelta(days=offset)\r\n                sourceTime = target.timetuple()\r\n\r\n            flag          = True\r\n            self.dateFlag = 1\r\n\r\n        if unit == 'hour' or \\\r\n           unit == 'hr':\r\n            if offset == 0:\r\n                sourceTime = (yr, mth, dy, hr, 0, 0, wd, yd, isdst)\r\n            else:\r\n                start      = datetime.datetime(yr, mth, dy, hr, 0, 0)\r\n                target     = start + datetime.timedelta(hours=offset)\r\n                sourceTime = target.timetuple()\r\n\r\n            flag          = True\r\n            self.timeFlag = 2\r\n\r\n        if unit == 'year' or \\\r\n             unit == 'yr' or \\\r\n             unit == 'y':\r\n            if offset == 0:\r\n                sourceTime = (yr, 12, 31, hr, mn, sec, wd, yd, isdst)\r\n            elif offset == 2:\r\n                sourceTime = (yr + 1, mth, dy, hr, mn, sec, wd, yd, isdst)\r\n            else:\r\n                sourceTime = (yr + offset, 1, 1, 9, 0, 0, wd, yd, isdst)\r\n\r\n            flag          = True\r\n            self.dateFlag = 1\r\n\r\n        if flag == False:\r\n            m = self.ptc.CRE_WEEKDAY.match(unit)\r\n            if m is not None:\r\n                wkdy          = m.group()\r\n                self.dateFlag = 1\r\n\r\n                if modifier == 'eod':\r\n                    # Calculate the  upcoming weekday\r\n                    self.modifierFlag = False\r\n                    (sourceTime, _)   = self.parse(wkdy, sourceTime)\r\n                    sources           = self.ptc.buildSources(sourceTime)\r\n                    self.timeFlag     = 2\r\n\r\n                    if modifier in sources:\r\n                        sourceTime = sources[modifier]\r\n\r\n                else:\r\n                    wkdy       = self.ptc.WeekdayOffsets[wkdy]\r\n                    diff       = self._CalculateDOWDelta(wd, wkdy, offset,\r\n                                                         self.ptc.DOWParseStyle,\r\n                                                         self.ptc.CurrentDOWParseStyle)\r\n                    start      = datetime.datetime(yr, mth, dy, 9, 0, 0)\r\n                    target     = start + datetime.timedelta(days=diff)\r\n                    sourceTime = target.timetuple()\r\n\r\n                flag          = True\r\n                self.dateFlag = 1\r\n\r\n        if not flag:\r\n            m = self.ptc.CRE_TIME.match(unit)\r\n            if m is not None:\r\n                self.modifierFlag = False\r\n                (yr, mth, dy, hr, mn, sec, wd, yd, isdst), _ = self.parse(unit)\r\n\r\n                start      = datetime.datetime(yr, mth, dy, hr, mn, sec)\r\n                target     = start + datetime.timedelta(days=offset)\r\n                sourceTime = target.timetuple()\r\n                flag       = True\r\n            else:\r\n                self.modifierFlag = False\r\n\r\n                # check if the remaining text is parsable and if so,\r\n                # use it as the base time for the modifier source time\r\n                t, flag2 = self.parse('%s %s' % (chunk1, unit), sourceTime)\r\n\r\n                if flag2 != 0:\r\n                    sourceTime = t\r\n\r\n                sources = self.ptc.buildSources(sourceTime)\r\n\r\n                if modifier in sources:\r\n                    sourceTime    = sources[modifier]\r\n                    flag          = True\r\n                    self.timeFlag = 2\r\n\r\n        # if the word after next is a number, the string is more than likely\r\n        # to be \"next 4 hrs\" which we will have to combine the units with the\r\n        # rest of the string\r\n        if not flag:\r\n            if offset < 0:\r\n                # if offset is negative, the unit has to be made negative\r\n                unit = '-%s' % unit\r\n\r\n            chunk2 = '%s %s' % (unit, chunk2)\r\n\r\n        self.modifierFlag = False\r\n\r\n        #return '%s %s' % (chunk1, chunk2), sourceTime\r\n        return '%s' % chunk2, sourceTime", "response": "Evaluate the modifier string and following text and return the modified time."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nevaluate the modifier string and following text and return the modified sourceTime .", "response": "def _evalModifier2(self, modifier, chunk1 , chunk2, sourceTime):\r\n        \"\"\"\r\n        Evaluate the C{modifier} string and following text (passed in\r\n        as C{chunk1} and C{chunk2}) and if they match any known modifiers\r\n        calculate the delta and apply it to C{sourceTime}.\r\n\r\n        @type  modifier:   string\r\n        @param modifier:   modifier text to apply to C{sourceTime}\r\n        @type  chunk1:     string\r\n        @param chunk1:     first text chunk that followed modifier (if any)\r\n        @type  chunk2:     string\r\n        @param chunk2:     second text chunk that followed modifier (if any)\r\n        @type  sourceTime: struct_time\r\n        @param sourceTime: C{struct_time} value to use as the base\r\n\r\n        @rtype:  tuple\r\n        @return: tuple of: remaining text and the modified sourceTime\r\n        \"\"\"\r\n        offset = self.ptc.Modifiers[modifier]\r\n        digit  = r'\\d+'\r\n\r\n        self.modifier2Flag = False\r\n\r\n        # If the string after the negative modifier starts with digits,\r\n        # then it is likely that the string is similar to ' before 3 days'\r\n        # or 'evening prior to 3 days'.\r\n        # In this case, the total time is calculated by subtracting '3 days'\r\n        # from the current date.\r\n        # So, we have to identify the quantity and negate it before parsing\r\n        # the string.\r\n        # This is not required for strings not starting with digits since the\r\n        # string is enough to calculate the sourceTime\r\n        if chunk2 != '':\r\n            if offset < 0:\r\n                m = re.match(digit, chunk2.strip())\r\n                if m is not None:\r\n                    qty    = int(m.group()) * -1\r\n                    chunk2 = chunk2[m.end():]\r\n                    chunk2 = '%d%s' % (qty, chunk2)\r\n\r\n            sourceTime, flag1 = self.parse(chunk2, sourceTime)\r\n            if flag1 == 0:\r\n                flag1 = True\r\n            else:\r\n                flag1 = False\r\n            flag2 = False\r\n        else:\r\n            flag1 = False\r\n\r\n        if chunk1 != '':\r\n            if offset < 0:\r\n                m = re.search(digit, chunk1.strip())\r\n                if m is not None:\r\n                    qty    = int(m.group()) * -1\r\n                    chunk1 = chunk1[m.end():]\r\n                    chunk1 = '%d%s' % (qty, chunk1)\r\n\r\n            tempDateFlag       = self.dateFlag\r\n            tempTimeFlag       = self.timeFlag\r\n            sourceTime2, flag2 = self.parse(chunk1, sourceTime)\r\n        else:\r\n            return sourceTime, (flag1 and flag2)\r\n\r\n        # if chunk1 is not a datetime and chunk2 is then do not use datetime\r\n        # value returned by parsing chunk1\r\n        if not (flag1 == False and flag2 == 0):\r\n            sourceTime = sourceTime2\r\n        else:\r\n            self.timeFlag = tempTimeFlag\r\n            self.dateFlag = tempDateFlag\r\n\r\n        return sourceTime, (flag1 and flag2)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _evalString(self, datetimeString, sourceTime=None):\r\n        s   = datetimeString.strip()\r\n        now = time.localtime()\r\n\r\n        # Given string date is a RFC822 date\r\n        if sourceTime is None:\r\n            sourceTime = _parse_date_rfc822(s)\r\n\r\n            if sourceTime is not None:\r\n                (yr, mth, dy, hr, mn, sec, wd, yd, isdst, _) = sourceTime\r\n                self.dateFlag = 1\r\n\r\n                if (hr != 0) and (mn != 0) and (sec != 0):\r\n                    self.timeFlag = 2\r\n\r\n                sourceTime = (yr, mth, dy, hr, mn, sec, wd, yd, isdst)\r\n\r\n        # Given string date is a W3CDTF date\r\n        if sourceTime is None:\r\n            sourceTime = _parse_date_w3dtf(s)\r\n\r\n            if sourceTime is not None:\r\n                self.dateFlag = 1\r\n                self.timeFlag = 2\r\n\r\n        if sourceTime is None:\r\n            s = s.lower()\r\n\r\n        # Given string is in the format HH:MM(:SS)(am/pm)\r\n        if self.meridianFlag:\r\n            if sourceTime is None:\r\n                (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = now\r\n            else:\r\n                (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = sourceTime\r\n\r\n            m = self.ptc.CRE_TIMEHMS2.search(s)\r\n            if m is not None:\r\n                dt = s[:m.start('meridian')].strip()\r\n                if len(dt) <= 2:\r\n                    hr  = int(dt)\r\n                    mn  = 0\r\n                    sec = 0\r\n                else:\r\n                    hr, mn, sec = _extract_time(m)\r\n\r\n                if hr == 24:\r\n                    hr = 0\r\n\r\n                sourceTime = (yr, mth, dy, hr, mn, sec, wd, yd, isdst)\r\n                meridian   = m.group('meridian').lower()\r\n\r\n                  # if 'am' found and hour is 12 - force hour to 0 (midnight)\r\n                if (meridian in self.ptc.am) and hr == 12:\r\n                    sourceTime = (yr, mth, dy, 0, mn, sec, wd, yd, isdst)\r\n\r\n                  # if 'pm' found and hour < 12, add 12 to shift to evening\r\n                if (meridian in self.ptc.pm) and hr < 12:\r\n                    sourceTime = (yr, mth, dy, hr + 12, mn, sec, wd, yd, isdst)\r\n\r\n              # invalid time\r\n            if hr > 24 or mn > 59 or sec > 59:\r\n                sourceTime    = now\r\n                self.dateFlag = 0\r\n                self.timeFlag = 0\r\n\r\n            self.meridianFlag = False\r\n\r\n          # Given string is in the format HH:MM(:SS)\r\n        if self.timeStdFlag:\r\n            if sourceTime is None:\r\n                (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = now\r\n            else:\r\n                (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = sourceTime\r\n\r\n            m = self.ptc.CRE_TIMEHMS.search(s)\r\n            if m is not None:\r\n                hr, mn, sec = _extract_time(m)\r\n            if hr == 24:\r\n                hr = 0\r\n\r\n            if hr > 24 or mn > 59 or sec > 59:\r\n                # invalid time\r\n                sourceTime    = now\r\n                self.dateFlag = 0\r\n                self.timeFlag = 0\r\n            else:\r\n                sourceTime = (yr, mth, dy, hr, mn, sec, wd, yd, isdst)\r\n\r\n            self.timeStdFlag = False\r\n\r\n        # Given string is in the format 07/21/2006\r\n        if self.dateStdFlag:\r\n            sourceTime       = self.parseDate(s)\r\n            self.dateStdFlag = False\r\n\r\n        # Given string is in the format  \"May 23rd, 2005\"\r\n        if self.dateStrFlag:\r\n            sourceTime       = self.parseDateText(s)\r\n            self.dateStrFlag = False\r\n\r\n        # Given string is a weekday\r\n        if self.weekdyFlag:\r\n            (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = now\r\n\r\n            start = datetime.datetime(yr, mth, dy, hr, mn, sec)\r\n            wkdy  = self.ptc.WeekdayOffsets[s]\r\n\r\n            if wkdy > wd:\r\n                qty = self._CalculateDOWDelta(wd, wkdy, 2,\r\n                                              self.ptc.DOWParseStyle,\r\n                                              self.ptc.CurrentDOWParseStyle)\r\n            else:\r\n                qty = self._CalculateDOWDelta(wd, wkdy, 2,\r\n                                              self.ptc.DOWParseStyle,\r\n                                              self.ptc.CurrentDOWParseStyle)\r\n\r\n            target = start + datetime.timedelta(days=qty)\r\n            wd     = wkdy\r\n\r\n            sourceTime      = target.timetuple()\r\n            self.weekdyFlag = False\r\n\r\n        # Given string is a natural language time string like\r\n        # lunch, midnight, etc\r\n        if self.timeStrFlag:\r\n            if s in self.ptc.re_values['now']:\r\n                sourceTime = now\r\n            else:\r\n                sources = self.ptc.buildSources(sourceTime)\r\n\r\n                if s in sources:\r\n                    sourceTime = sources[s]\r\n                else:\r\n                    sourceTime    = now\r\n                    self.dateFlag = 0\r\n                    self.timeFlag = 0\r\n\r\n            self.timeStrFlag = False\r\n\r\n        # Given string is a natural language date string like today, tomorrow..\r\n        if self.dayStrFlag:\r\n            if sourceTime is None:\r\n                sourceTime = now\r\n\r\n            (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = sourceTime\r\n\r\n            if s in self.ptc.dayOffsets:\r\n                offset = self.ptc.dayOffsets[s]\r\n            else:\r\n                offset = 0\r\n\r\n            start      = datetime.datetime(yr, mth, dy, 9, 0, 0)\r\n            target     = start + datetime.timedelta(days=offset)\r\n            sourceTime = target.timetuple()\r\n\r\n            self.dayStrFlag = False\r\n\r\n        # Given string is a time string with units like \"5 hrs 30 min\"\r\n        if self.unitsFlag:\r\n            modifier = ''  # TODO\r\n\r\n            if sourceTime is None:\r\n                sourceTime = now\r\n\r\n            m = self.ptc.CRE_UNITS.search(s)\r\n            if m is not None:\r\n                units    = m.group('units')\r\n                quantity = s[:m.start('units')]\r\n\r\n            sourceTime     = self._buildTime(sourceTime, quantity, modifier, units)\r\n            self.unitsFlag = False\r\n\r\n        # Given string is a time string with single char units like \"5 h 30 m\"\r\n        if self.qunitsFlag:\r\n            modifier = ''  # TODO\r\n\r\n            if sourceTime is None:\r\n                sourceTime = now\r\n\r\n            m = self.ptc.CRE_QUNITS.search(s)\r\n            if m is not None:\r\n                units    = m.group('qunits')\r\n                quantity = s[:m.start('qunits')]\r\n\r\n            sourceTime      = self._buildTime(sourceTime, quantity, modifier, units)\r\n            self.qunitsFlag = False\r\n\r\n          # Given string does not match anything\r\n        if sourceTime is None:\r\n            sourceTime    = now\r\n            self.dateFlag = 0\r\n            self.timeFlag = 0\r\n\r\n        return sourceTime", "response": "Parse a string and return the datetime based on the flags set by the parse method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a string containing a date and time string into a tuple of modified and time values.", "response": "def parse(self, datetimeString, sourceTime=None):\r\n        \"\"\"\r\n        Splits the given C{datetimeString} into tokens, finds the regex\r\n        patterns that match and then calculates a C{struct_time} value from\r\n        the chunks.\r\n\r\n        If C{sourceTime} is given then the C{struct_time} value will be\r\n        calculated from that value, otherwise from the current date/time.\r\n\r\n        If the C{datetimeString} is parsed and date/time value found then\r\n        the second item of the returned tuple will be a flag to let you know\r\n        what kind of C{struct_time} value is being returned::\r\n\r\n            0 = not parsed at all\r\n            1 = parsed as a C{date}\r\n            2 = parsed as a C{time}\r\n            3 = parsed as a C{datetime}\r\n\r\n        @type  datetimeString: string\r\n        @param datetimeString: date/time text to evaluate\r\n        @type  sourceTime:     struct_time\r\n        @param sourceTime:     C{struct_time} value to use as the base\r\n\r\n        @rtype:  tuple\r\n        @return: tuple of: modified C{sourceTime} and the result flag\r\n        \"\"\"\r\n\r\n        if sourceTime:\r\n            if isinstance(sourceTime, datetime.datetime):\r\n                if _debug:\r\n                    print 'coercing datetime to timetuple'\r\n                sourceTime = sourceTime.timetuple()\r\n            else:\r\n                if not isinstance(sourceTime, time.struct_time) and \\\r\n                   not isinstance(sourceTime, tuple):\r\n                    raise Exception('sourceTime is not a struct_time')\r\n\r\n        s         = datetimeString.strip().lower()\r\n        parseStr  = ''\r\n        totalTime = sourceTime\r\n\r\n        if s == '' :\r\n            if sourceTime is not None:\r\n                return (sourceTime, self.dateFlag + self.timeFlag)\r\n            else:\r\n                return (time.localtime(), 0)\r\n\r\n        self.timeFlag = 0\r\n        self.dateFlag = 0\r\n\r\n        while len(s) > 0:\r\n            flag   = False\r\n            chunk1 = ''\r\n            chunk2 = ''\r\n\r\n            if _debug:\r\n                print 'parse (top of loop): [%s][%s]' % (s, parseStr)\r\n\r\n            if parseStr == '':\r\n                # Modifier like next\\prev..\r\n                m = self.ptc.CRE_MODIFIER.search(s)\r\n                if m is not None:\r\n                    self.modifierFlag = True\r\n                    if (m.group('modifier') != s):\r\n                        # capture remaining string\r\n                        parseStr = m.group('modifier')\r\n                        chunk1   = s[:m.start('modifier')].strip()\r\n                        chunk2   = s[m.end('modifier'):].strip()\r\n                        flag     = True\r\n                    else:\r\n                        parseStr = s\r\n\r\n            if parseStr == '':\r\n                # Modifier like from\\after\\prior..\r\n                m = self.ptc.CRE_MODIFIER2.search(s)\r\n                if m is not None:\r\n                    self.modifier2Flag = True\r\n                    if (m.group('modifier') != s):\r\n                        # capture remaining string\r\n                        parseStr = m.group('modifier')\r\n                        chunk1   = s[:m.start('modifier')].strip()\r\n                        chunk2   = s[m.end('modifier'):].strip()\r\n                        flag     = True\r\n                    else:\r\n                        parseStr = s\r\n\r\n            if parseStr == '':\r\n                valid_date = False\r\n                for match in self.ptc.CRE_DATE3.finditer(s):\r\n                    # to prevent \"HH:MM(:SS) time strings\" expressions from triggering\r\n                    # this regex, we checks if the month field exists in the searched \r\n                    # expression, if it doesn't exist, the date field is not valid\r\n                    if match.group('mthname'):\r\n                        m = self.ptc.CRE_DATE3.search(s, match.start())\r\n                        valid_date = True\r\n                        break\r\n\r\n                # String date format\r\n                if valid_date:\r\n                    self.dateStrFlag = True\r\n                    self.dateFlag    = 1\r\n                    if (m.group('date') != s):\r\n                        # capture remaining string\r\n                        parseStr = m.group('date')\r\n                        chunk1   = s[:m.start('date')]\r\n                        chunk2   = s[m.end('date'):]\r\n                        s        = '%s %s' % (chunk1, chunk2)\r\n                        flag     = True\r\n                    else:\r\n                        parseStr = s\r\n\r\n            if parseStr == '':\r\n                # Standard date format\r\n                m = self.ptc.CRE_DATE.search(s)\r\n                if m is not None:\r\n                    self.dateStdFlag = True\r\n                    self.dateFlag    = 1\r\n                    if (m.group('date') != s):\r\n                        # capture remaining string\r\n                        parseStr = m.group('date')\r\n                        chunk1   = s[:m.start('date')]\r\n                        chunk2   = s[m.end('date'):]\r\n                        s        = '%s %s' % (chunk1, chunk2)\r\n                        flag     = True\r\n                    else:\r\n                        parseStr = s\r\n\r\n            if parseStr == '':\r\n                # Natural language day strings\r\n                m = self.ptc.CRE_DAY.search(s)\r\n                if m is not None:\r\n                    self.dayStrFlag = True\r\n                    self.dateFlag   = 1\r\n                    if (m.group('day') != s):\r\n                        # capture remaining string\r\n                        parseStr = m.group('day')\r\n                        chunk1   = s[:m.start('day')]\r\n                        chunk2   = s[m.end('day'):]\r\n                        s        = '%s %s' % (chunk1, chunk2)\r\n                        flag     = True\r\n                    else:\r\n                        parseStr = s\r\n\r\n            if parseStr == '':\r\n                # Quantity + Units\r\n                m = self.ptc.CRE_UNITS.search(s)\r\n                if m is not None:\r\n                    self.unitsFlag = True\r\n                    if (m.group('qty') != s):\r\n                        # capture remaining string\r\n                        parseStr = m.group('qty')\r\n                        chunk1   = s[:m.start('qty')].strip()\r\n                        chunk2   = s[m.end('qty'):].strip()\r\n\r\n                        if chunk1[-1:] == '-':\r\n                            parseStr = '-%s' % parseStr\r\n                            chunk1   = chunk1[:-1]\r\n\r\n                        s    = '%s %s' % (chunk1, chunk2)\r\n                        flag = True\r\n                    else:\r\n                        parseStr = s\r\n\r\n            if parseStr == '':\r\n                # Quantity + Units\r\n                m = self.ptc.CRE_QUNITS.search(s)\r\n                if m is not None:\r\n                    self.qunitsFlag = True\r\n\r\n                    if (m.group('qty') != s):\r\n                        # capture remaining string\r\n                        parseStr = m.group('qty')\r\n                        chunk1   = s[:m.start('qty')].strip()\r\n                        chunk2   = s[m.end('qty'):].strip()\r\n\r\n                        if chunk1[-1:] == '-':\r\n                            parseStr = '-%s' % parseStr\r\n                            chunk1   = chunk1[:-1]\r\n\r\n                        s    = '%s %s' % (chunk1, chunk2)\r\n                        flag = True\r\n                    else:\r\n                        parseStr = s \r\n\r\n            if parseStr == '':\r\n                # Weekday\r\n                m = self.ptc.CRE_WEEKDAY.search(s)\r\n                if m is not None:\r\n                    gv = m.group('weekday')\r\n                    if s not in self.ptc.dayOffsets:\r\n                        self.weekdyFlag = True\r\n                        self.dateFlag   = 1\r\n                        if (gv != s):\r\n                            # capture remaining string\r\n                            parseStr = gv\r\n                            chunk1   = s[:m.start('weekday')]\r\n                            chunk2   = s[m.end('weekday'):]\r\n                            s        = '%s %s' % (chunk1, chunk2)\r\n                            flag     = True\r\n                        else:\r\n                            parseStr = s\r\n\r\n            if parseStr == '':\r\n                # Natural language time strings\r\n                m = self.ptc.CRE_TIME.search(s)\r\n                if m is not None:\r\n                    self.timeStrFlag = True\r\n                    self.timeFlag    = 2\r\n                    if (m.group('time') != s):\r\n                        # capture remaining string\r\n                        parseStr = m.group('time')\r\n                        chunk1   = s[:m.start('time')]\r\n                        chunk2   = s[m.end('time'):]\r\n                        s        = '%s %s' % (chunk1, chunk2)\r\n                        flag     = True\r\n                    else:\r\n                        parseStr = s\r\n\r\n            if parseStr == '':\r\n                # HH:MM(:SS) am/pm time strings\r\n                m = self.ptc.CRE_TIMEHMS2.search(s)\r\n                if m is not None:\r\n                    self.meridianFlag = True\r\n                    self.timeFlag     = 2\r\n                    if m.group('minutes') is not None:\r\n                        if m.group('seconds') is not None:\r\n                            parseStr = '%s:%s:%s %s' % (m.group('hours'),\r\n                                                        m.group('minutes'),\r\n                                                        m.group('seconds'),\r\n                                                        m.group('meridian'))\r\n                        else:\r\n                            parseStr = '%s:%s %s' % (m.group('hours'),\r\n                                                     m.group('minutes'),\r\n                                                     m.group('meridian'))\r\n                    else:\r\n                        parseStr = '%s %s' % (m.group('hours'),\r\n                                              m.group('meridian'))\r\n\r\n                    chunk1 = s[:m.start('hours')]\r\n                    chunk2 = s[m.end('meridian'):]\r\n\r\n                    s    = '%s %s' % (chunk1, chunk2)\r\n                    flag = True\r\n\r\n            if parseStr == '':\r\n                # HH:MM(:SS) time strings\r\n                m = self.ptc.CRE_TIMEHMS.search(s)\r\n                if m is not None:\r\n                    self.timeStdFlag = True\r\n                    self.timeFlag    = 2\r\n                    if m.group('seconds') is not None:\r\n                        parseStr = '%s:%s:%s' % (m.group('hours'),\r\n                                                 m.group('minutes'),\r\n                                                 m.group('seconds'))\r\n                        chunk1   = s[:m.start('hours')]\r\n                        chunk2   = s[m.end('seconds'):]\r\n                    else:\r\n                        parseStr = '%s:%s' % (m.group('hours'),\r\n                                              m.group('minutes'))\r\n                        chunk1   = s[:m.start('hours')]\r\n                        chunk2   = s[m.end('minutes'):]\r\n\r\n                    s    = '%s %s' % (chunk1, chunk2)\r\n                    flag = True\r\n\r\n            # if string does not match any regex, empty string to\r\n            # come out of the while loop\r\n            if not flag:\r\n                s = ''\r\n\r\n            if _debug:\r\n                print 'parse (bottom) [%s][%s][%s][%s]' % (s, parseStr, chunk1, chunk2)\r\n                print 'weekday %s, dateStd %s, dateStr %s, time %s, timeStr %s, meridian %s' % \\\r\n                       (self.weekdyFlag, self.dateStdFlag, self.dateStrFlag, self.timeStdFlag, self.timeStrFlag, self.meridianFlag)\r\n                print 'dayStr %s, modifier %s, modifier2 %s, units %s, qunits %s' % \\\r\n                       (self.dayStrFlag, self.modifierFlag, self.modifier2Flag, self.unitsFlag, self.qunitsFlag)\r\n\r\n            # evaluate the matched string\r\n            if parseStr != '':\r\n                if self.modifierFlag == True:\r\n                    t, totalTime = self._evalModifier(parseStr, chunk1, chunk2, totalTime)\r\n                    # t is the unparsed part of the chunks.\r\n                    # If it is not date/time, return current\r\n                    # totalTime as it is; else return the output\r\n                    # after parsing t.\r\n                    if (t != '') and (t != None):\r\n                        tempDateFlag       = self.dateFlag\r\n                        tempTimeFlag       = self.timeFlag\r\n                        (totalTime2, flag) = self.parse(t, totalTime)\r\n\r\n                        if flag == 0 and totalTime is not None:\r\n                            self.timeFlag = tempTimeFlag\r\n                            self.dateFlag = tempDateFlag\r\n\r\n                            return (totalTime, self.dateFlag + self.timeFlag)\r\n                        else:\r\n                            return (totalTime2, self.dateFlag + self.timeFlag)\r\n\r\n                elif self.modifier2Flag == True:\r\n                    totalTime, invalidFlag = self._evalModifier2(parseStr, chunk1, chunk2, totalTime)\r\n\r\n                    if invalidFlag == True:\r\n                        self.dateFlag = 0\r\n                        self.timeFlag = 0\r\n\r\n                else:\r\n                    totalTime = self._evalString(parseStr, totalTime)\r\n                    parseStr  = ''\r\n\r\n        # String is not parsed at all\r\n        if totalTime is None or totalTime == sourceTime:\r\n            totalTime     = time.localtime()\r\n            self.dateFlag = 0\r\n            self.timeFlag = 0\r\n\r\n        return (totalTime, self.dateFlag + self.timeFlag)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new date in the given month and year.", "response": "def inc(self, source, month=None, year=None):\r\n        \"\"\"\r\n        Takes the given C{source} date, or current date if none is\r\n        passed, and increments it according to the values passed in\r\n        by month and/or year.\r\n\r\n        This routine is needed because Python's C{timedelta()} function\r\n        does not allow for month or year increments.\r\n\r\n        @type  source: struct_time\r\n        @param source: C{struct_time} value to increment\r\n        @type  month:  integer\r\n        @param month:  optional number of months to increment\r\n        @type  year:   integer\r\n        @param year:   optional number of years to increment\r\n\r\n        @rtype:  datetime\r\n        @return: C{source} incremented by the number of months and/or years\r\n        \"\"\"\r\n        yr  = source.year\r\n        mth = source.month\r\n        dy  = source.day\r\n\r\n        if year:\r\n            try:\r\n                yi = int(year)\r\n            except ValueError:\r\n                yi = 0\r\n\r\n            yr += yi\r\n\r\n        if month:\r\n            try:\r\n                mi = int(month)\r\n            except ValueError:\r\n                mi = 0\r\n\r\n            m = abs(mi)\r\n            y = m / 12      # how many years are in month increment\r\n            m = m % 12      # get remaining months\r\n\r\n            if mi < 0:\r\n                mth = mth - m           # sub months from start month\r\n                if mth < 1:             # cross start-of-year?\r\n                    y   -= 1            #   yes - decrement year\r\n                    mth += 12           #         and fix month\r\n            else:\r\n                mth = mth + m           # add months to start month\r\n                if mth > 12:            # cross end-of-year?\r\n                    y   += 1            #   yes - increment year\r\n                    mth -= 12           #         and fix month\r\n\r\n            yr += y\r\n\r\n            # if the day ends up past the last day of\r\n            # the new month, set it to the last day\r\n            if dy > self.ptc.daysInMonth(mth, yr):\r\n                dy = self.ptc.daysInMonth(mth, yr)\r\n\r\n        d = source.replace(year=yr, month=mth, day=dy)\r\n\r\n        return source + (d - source)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef csvpretty(csvfile: csvfile=sys.stdin):\n    shellish.tabulate(csv.reader(csvfile))", "response": "Pretty print a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_key(self, path, geometry, filters, options):\n        seed = u' '.join([\n            str(path),\n            str(geometry),\n            str(filters),\n            str(options),\n        ]).encode('utf8')\n        return md5(seed).hexdigest()", "response": "Generates the thumbnail s key from the arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the source image file descriptor.", "response": "def get_source(self, path_or_url):\n        \"\"\"Returns the source image file descriptor.\n\n        path_or_url:\n            Path to the source image as an absolute path, a path relative\n            to `self.base_path` or a URL beginning with `http[s]`\n\n        \"\"\"\n        if path_or_url.startswith(('http://', 'https://')):\n            try:\n                return urlopen(path_or_url)\n            except IOError:\n                return None\n\n        fullpath = path_or_url\n        if not os.path.isabs(path_or_url):\n            fullpath = os.path.join(self.base_path, path_or_url)\n        try:\n            return io.open(fullpath, 'rb')\n        except IOError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the stored thumbnail if exists.", "response": "def get_thumb(self, path, key, format):\n        \"\"\"Get the stored thumbnail if exists.\n\n        path:\n            path of the source image\n        key:\n            key of the thumbnail\n        format:\n            thumbnail's file extension\n        \"\"\"\n        thumbpath = self.get_thumbpath(path, key, format)\n        fullpath = os.path.join(self.out_path, thumbpath)\n        if os.path.isfile(fullpath):\n            url = self.get_url(thumbpath)\n            return Thumb(url, key)\n        return Thumb()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the relative path of the thumbnail.", "response": "def get_thumbpath(self, path, key, format):\n        \"\"\"Return the relative path of the thumbnail.\n\n        path:\n            path of the source image\n        key:\n            key of the thumbnail\n        format:\n            thumbnail file extension\n        \"\"\"\n        relpath = os.path.dirname(path)\n        thumbsdir = self.get_thumbsdir(path)\n        name, _ = os.path.splitext(os.path.basename(path))\n        name = '{}.{}.{}'.format(name, key, format.lower())\n        return os.path.join(relpath, thumbsdir, name)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_thumbsdir(self, path):\n        # Thumbsdir could be a callable\n        # In that case, the path is built on the fly, based on the source path\n        thumbsdir = self.thumbsdir\n        if callable(self.thumbsdir):\n            thumbsdir = self.thumbsdir(path)\n        return thumbsdir", "response": "Returns the path of the thumbs directory for the source image"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self, path, key, format, data):\n        thumbpath = self.get_thumbpath(path, key, format)\n        fullpath = os.path.join(self.out_path, thumbpath)\n        self.save_thumb(fullpath, data)\n        url = self.get_url(thumbpath)\n        thumb = Thumb(url, key, fullpath)\n        return thumb", "response": "Save a newly generated thumbnail."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_handler(cls, level, fmt, colorful, **kwargs):\n    global g_logger\n \n    if isinstance(level, str):\n        level = getattr(logging, level.upper(), logging.DEBUG)\n \n    handler = cls(**kwargs)\n    handler.setLevel(level)\n \n    if colorful:\n        formatter = ColoredFormatter(fmt, datefmt='%Y-%m-%d %H:%M:%S')\n    else:\n        formatter = logging.Formatter(fmt, datefmt='%Y-%m-%d %H:%M:%S')\n \n    handler.setFormatter(formatter)\n    g_logger.addHandler(handler)\n \n    return handler", "response": "Add a configured handler to the global logger."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_filehandler(level, fmt, filename, mode, backup_count, limit, when):\n    kwargs = {}\n \n    # If the filename is not set, use the default filename\n    if filename is None:\n        filename = getattr(sys.modules['__main__'], '__file__', 'log.py')\n        filename = os.path.basename(filename.replace('.py', '.log'))\n        filename = os.path.join('/tmp', filename)\n\n    if not os.path.exists(os.path.dirname(filename)):\n        os.mkdir(os.path.dirname(filename))\n\n    kwargs['filename'] = filename\n \n    # Choose the filehandler based on the passed arguments\n    if backup_count == 0:  # Use FileHandler\n        cls = logging.FileHandler\n        kwargs['mode'] = mode\n    elif when is None:  # Use RotatingFileHandler\n        cls = logging.handlers.RotatingFileHandler\n        kwargs['maxBytes'] = limit\n        kwargs['backupCount'] = backup_count\n        kwargs['mode'] = mode\n    else:  # Use TimedRotatingFileHandler\n        cls = logging.handlers.TimedRotatingFileHandler\n        kwargs['when'] = when\n        kwargs['interval'] = limit\n        kwargs['backupCount'] = backup_count\n \n    return add_handler(cls, level, fmt, False, **kwargs)", "response": "Add a file handler to the global logger."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef init_logger(name=None):\n    global g_logger\n \n    if g_logger is None:\n        g_logger = logging.getLogger(name=name)\n    else:\n        logging.shutdown()\n        g_logger.handlers = []\n \n    g_logger.setLevel(logging.DEBUG)", "response": "Reload the global logger."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_logger(name=None, filename=None, mode='a', level='NOTSET:NOTSET',\n               fmt=\n               '%(asctime)s %(filename)s:%(lineno)d [PID:%(process)-5d THD:%(thread)-5d %(levelname)-7s] %(message)s',\n               # fmt='[%(levelname)s] %(asctime)s %(message)s',\n               backup_count=5, limit=20480, when=None, with_filehandler=True):\n    \"\"\"Configure the global logger.\"\"\"\n    level = level.split(':')\n \n    if len(level) == 1:  # Both set to the same level\n        s_level = f_level = level[0]\n    else:\n        s_level = level[0]  # StreamHandler log level\n        f_level = level[1]  # FileHandler log level\n \n    init_logger(name=name)\n    add_streamhandler(s_level, fmt)\n    if with_filehandler:\n        add_filehandler(f_level, fmt, filename, mode, backup_count, limit, when)\n \n    # Import the common log functions for convenient\n    import_log_funcs()", "response": "Configure the global logger."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef import_log_funcs():\n    global g_logger\n \n    curr_mod = sys.modules[__name__]\n\n    for func_name in _logging_funcs:\n        func = getattr(g_logger, func_name)\n        setattr(curr_mod, func_name, func)", "response": "Import the common log functions from the global logger to the module."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef powerupIndirector(interface):\n    def decorator(cls):\n        zi.implementer(iaxiom.IPowerupIndirector)(cls)\n        cls.powerupInterfaces = [interface]\n        cls.indirect = _indirect\n        return cls\n\n    return decorator", "response": "A class decorator that provides a powerup indirector from a single interface to a single\n    in - memory implementation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlint the given dataset and returns a string containing all the issues found in the dataset.", "response": "def lint(self, dataset=None, col=None, no_header=False,\n\t\t\t\tignore_nfd=False, ignore_ws=False, linewise=False, no_lines=False):\n\t\t\"\"\"\n\t\tReturns a string containing all the issues found in the dataset\n\t\tdefined by the given file path.\n\t\t\"\"\"\n\t\treader = Reader(dataset, has_header=not no_header, ipa_col=col)\n\n\t\trecog = Recogniser()\n\t\tnorm = Normaliser(nfc_chars=recog.get_nfc_chars())\n\n\t\tfor ipa_string, line_num in reader.gen_ipa_data():\n\t\t\tipa_string = norm.normalise(ipa_string, line_num)\n\t\t\trecog.recognise(ipa_string, line_num)\n\n\t\trep = Reporter()\n\t\tnorm.report(rep, ignore_nfd, ignore_ws)\n\t\trecog.report(rep)\n\n\t\treturn rep.get_report(linewise, no_lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_rune_links(html: str) -> dict:\n    soup = BeautifulSoup(html, 'lxml')\n\n    # Champs with only a single runepage\n    single_page_raw = soup.find_all('li', class_='champion')\n    single_page = {re.split('\\W+', x.a.div.div['style'])[-3].lower():\n                       [x.a['href']] for x in single_page_raw if x.a is not None}\n\n    # Champs with two (or more) runepages\n    double_page_raw = soup.find_all('div', class_='champion-modal-open')\n    # This is JSON data which just needs to be decoded\n    double_page_decode = [json.loads(x['data-loadouts']) for x in double_page_raw]\n    # This lowers the champ name in the structure, \n    # and pulls out the champ links, after it's been decoded\n    double_page = {re.sub('[^A-Za-z0-9]+', '', x[0]['champion'].lower()):\n                       [x[0]['link'], x[1]['link']] for x in double_page_decode}\n\n    # Combine the two dicts\n    champs_combined = {**single_page, **double_page}\n\n    return champs_combined", "response": "A function which parses the main Runeforge website into nested rune_links."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_string(regex, s):\n    m = re.search(regex, s)\n    if m is None:\n        return None\n    return m.groups()[0]", "response": "Find a string using a given regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_number(regex, s):\n    result = find_string(regex, s)\n    if result is None:\n        return None\n    return int(result)", "response": "Find a number using a given regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the first number in the string we encounter.", "response": "def parse_first_number(s):\n    \"\"\"Parse the first number in the string we encounter.\n    \n    s - The string to parse.\n    \n        parse_first_number('123')\n        >>> 123\n        parse_first_number('   12 meters')\n        >>> 12\n        parse_first_number('area: 156 meters')\n        >>> 156\n        parse_first_number(' 1 2 3')\n        >> 1\n        parse_first_number('    ')\n        >> None\n\n    Returns an integer or None if no number could be found.\n    \"\"\"\n    m = re.match('\\s*.*?(\\d+)', s)\n    if m is None: return None\n    return int(m.groups(1)[0])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clean_text(s):\n    SPACES_RE = re.compile(r'\\s+')\n    SPECIAL_CHARS_RE = re.compile(r'[^\\w\\s\\.\\-\\(\\)]')\n    s = SPACES_RE.sub(' ', s)\n    s = s.strip()\n    s = SPECIAL_CHARS_RE.sub('', s)\n    return s", "response": "Removes all cruft from the text."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_immoweb_link(url):\n    IMMOWEB_ID_RE = re.compile(r'.*?IdBien=([0-9]+).*?')\n    return IMMOWEB_ID_RE.match(url).groups()[0]", "response": "Parses an Immoweb estate detail URL and returns the Immoweb estate id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_number(d, key, regex, s):\n    result = find_number(regex, s)\n    if result is not None:\n        d[key] = result", "response": "Find a number using a given regular expression."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a dict representing a Factual filter matching any of the categories.", "response": "def make_category_filter(categories, blank=True):\n\t'''\n\tGenerates a dict representing a Factual filter matching any of the categories\n\tpassed. \n\n\tThe resulting filter uses $bw \"begins with\" operators to return all matching\n\tsubcategories. Because of this, passing a top level category removes the need\n\tto pass any of its subcategories. \n\n\tConversely, specifying subcategories will not restrict results as expected\n\tif a prefix of those subcategories is also provided. For example:\n\t\tmake_category_filter([\"Food & Beverage\", \"Food & Beverage > Cheese\"])\n\tis the same as \n\t\tmake_category_filter([\"Food & Beverage\"])\n\t\n\tTo minimize the size of the filters sent to Factual, make_category_filters \n\tidentifies redundant subcategories and removes them. \n\n\tNote that because of this prefix matching, queries may return rows from unwanted\n\tsubcategories. It may be necessary for you to filter out these records after \n\tthe Factual request. \n\n\tSpecify blank=True to include items without a category set.\n\t'''\n\tcategories = [category.strip() for category in categories]\n\n\t# find shortest prefixes\n\tcategories.sort()\n\tredundant_categories = set()\n\tprefix_candidate = None\n\tfor category in categories:\n\t\tif prefix_candidate != None \\\n\t\t\tand category.find(prefix_candidate) == 0:\n\t\t\t# prefix_candidate is a prefix of the current category, \n\t\t\t# so we can skip the current category\n\t\t\tredundant_categories.add(category)\n\t\telse:\n\t\t\tprefix_candidate = category\n\tcategories = [category for category in categories if category not in redundant_categories]\n\n\tfilters = [ops.bw_(\"category\", category) for category in categories]\n\tif blank:\n\t\tfilters.append(ops.blank_(\"category\"))\n\treturn ops.or_(*filters)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads a Bioquali - like graph description file into a TermSet object.", "response": "def readGraph(filename):\n    p = graph_parser.Parser()\n    \"\"\"\n    input: string, name of a file containing a Bioquali-like graph description\n    output: asp.TermSet, with atoms matching the contents of the input file\n\n    Parses a Bioquali-like graph description, and returns\n    a TermSet object.\n    Written using original Bioquali\n    \"\"\"\n\n    accu = TermSet()\n    file = open(filename,'r')\n    s = file.readline()\n    while s!=\"\":\n        try:\n            accu = p.parse(s)\n        except EOFError:\n            break\n        s = file.readline()\n\n    return accu"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self, action):\n        deployer = self.__class__.__name__\n        log.info('Running %s...' % deployer)\n        try:\n            if action == 'deploy':\n                self.deploy()\n            elif action == 'inventory':\n                self.inventory()\n        except BangError as e:\n            log.error(e)\n            raise\n        log.info('%s complete.' % deployer)", "response": "Runs through the phases defined by action."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a value to a type that can be used in a table.", "response": "def convert_type(self, value, spec):\n        \"\"\" Some well-educated format guessing. \"\"\"\n        data_type = spec.get('type', 'string').lower().strip()\n        if data_type in ['bool', 'boolean']:\n            return value.lower() in BOOL_TRUISH\n        elif data_type in ['int', 'integer']:\n            try:\n                return int(value)\n            except (ValueError, TypeError):\n                return None\n        elif data_type in ['float', 'decimal', 'real']:\n            try:\n                return float(value)\n            except (ValueError, TypeError):\n                return None\n        elif data_type in ['date', 'datetime', 'timestamp']:\n            if 'format' in spec:\n                format_list = self._get_date_format_list(spec.get('format'))\n                if format_list is None:\n                    raise MappingException(\n                        '%s format mapping is not valid: %r' %\n                        (spec.get('column'), spec.get('format'))\n                    )\n                for format, precision in format_list:\n                    try:\n                        return {'value': datetime.strptime(value, format),\n                                'value_precision': precision}\n                    except (ValueError, TypeError):\n                        pass\n                return None\n            else:\n                try:\n                    return parser.parse(value)\n                except (ValueError, TypeError):\n                    return None\n        elif data_type == 'file':\n            try:\n                return self._get_file(value)\n            except:\n                raise\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_value(self, spec, row):\n        column = spec.get('column')\n        default = spec.get('default')\n        if column is None:\n            if default is not None:\n                return self.convert_type(default, spec)\n            return\n        value = row.get(column)\n        if is_empty(value):\n            if default is not None:\n                return self.convert_type(default, spec)\n            return None\n        return self.convert_type(value, spec)", "response": "Returns the value or a dict with a value entry plus extra fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_source(self, spec, row):\n        value = self.get_value({'column': spec.get('source_url_column')}, row)\n        if value is not None:\n            return value\n        return spec.get('source_url')", "response": "Get the source URL for a given column in a given row."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self, data):\n        objs = {}\n        for mapper in self.entities:\n            objs[mapper.name] = mapper.load(self.loader, data)\n\n        for mapper in self.relations:\n            objs[mapper.name] = mapper.load(self.loader, data, objs)", "response": "Load a single row of data and convert it into entities and relations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_v3(vec1, m):\n    if type(m) in NUMERIC_TYPES:\n        return Vec3(vec1.x + m, vec1.y + m, vec1.z + m)\n    else:\n        return Vec3(vec1.x + m.x, vec1.y + m.y, vec1.z + m.z)", "response": "Return a new Vec3 containing the sum of our x y and z and arg.\n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef translate_v3(vec, amount):\n\n    return Vec3(vec.x+amount, vec.y+amount, vec.z+amount)", "response": "Return a new Vec3 that is translated version of vec."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scale_v3(vec, amount):\n\n    return Vec3(vec.x*amount, vec.y*amount, vec.z*amount)", "response": "Return a new Vec3 that is a scaled version of vec."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dot_v3(v, w):\n\n    return sum([x * y for x, y in zip(v, w)])", "response": "Return the dotproduct of two vectors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the signed length of the projection of vector v on vector w.", "response": "def projection_as_vec_v3(v, w):\n    \"\"\"Return the signed length of the projection of vector v on vector w.\n\n    Returns the full vector result of projection_v3().\n    \"\"\"\n    proj_len = projection_v3(v, w)\n    return scale_v3(v, proj_len)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives a point and a line segment return the vector from the point to the closest point on the segment.", "response": "def point_to_line(point, segment_start, segment_end):\n    \"\"\"Given a point and a line segment, return the vector from the point to\n    the closest point on the segment.\n    \"\"\"\n    # TODO: Needs unittests.\n\n    segment_vec = segment_end - segment_start\n    # t is distance along line\n    t = -(segment_start - point).dot(segment_vec) / (\n          segment_vec.length_squared())\n\n    closest_point = segment_start + scale_v3(segment_vec, t)\n    return point - closest_point"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cross_v3(vec_a, vec_b):\n\n    return Vec3(vec_a.y * vec_b.z - vec_a.z * vec_b.y,\n                vec_a.z * vec_b.x - vec_a.x * vec_b.z,\n                vec_a.x * vec_b.y - vec_a.y * vec_b.x)", "response": "Return the crossproduct between vec_a and vec_b."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrotate v around norm_vec by angle_rad.", "response": "def rotate_around_vector_v3(v, angle_rad, norm_vec):\n    \"\"\" rotate v around norm_vec by angle_rad.\"\"\"\n    cos_val = math.cos(angle_rad)\n    sin_val = math.sin(angle_rad)\n    ## (v * cosVal) +\n    ## ((normVec * v) * (1.0 - cosVal)) * normVec +\n    ## (v ^ normVec) * sinVal)\n    #line1: scaleV3(v,cosVal)\n    #line2: dotV3( scaleV3( dotV3(normVec,v), 1.0-cosVal), normVec)\n    #line3: scaleV3( crossV3( v,normVec), sinVal)\n    #a = scaleV3(v,cosVal)\n    #b = scaleV3( normVec, dotV3(normVec,v) * (1.0-cosVal))\n    #c = scaleV3( crossV3( v,normVec), sinVal)\n    return add_v3(\n        add_v3(scale_v3(v, cos_val),\n               scale_v3(norm_vec, dot_v3(norm_vec, v) * (1.0 - cos_val))),\n        scale_v3(cross_v3(v, norm_vec), sin_val)\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ave_list_v3(vec_list):\n\n    vec = Vec3(0, 0, 0)\n    for v in vec_list:\n        vec += v\n    num_vecs = float(len(vec_list))\n    vec = Vec3(vec.x / num_vecs, vec.y / num_vecs, vec.z / num_vecs)\n    return vec", "response": "Return the average vector of a list of vectors."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _float_almost_equal(float1, float2, places=7):\n\n    if round(abs(float2 - float1), places) == 0:\n        return True\n\n    return False", "response": "Return True if two numbers are equal up to the\n    specified number of places after the decimal point."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef almost_equal(self, v2, places=7):\n\n        try:\n            return (\n                len(self) == len(v2) and\n                _float_almost_equal(self.x, v2.x, places) and\n                _float_almost_equal(self.y, v2.y, places) and\n                _float_almost_equal(self.z, v2.z, places))\n        except:\n            return False", "response": "When comparing for equality compare floats up to\n            a limited precision specified by places."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the dotproduct between self and another vector.", "response": "def dot(self, w):\n        \"\"\"Return the dotproduct between self and another vector.\"\"\"\n\n        return sum([x * y for x, y in zip(self, w)])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the crossproduct between self and vec.", "response": "def cross(self, vec):\n        \"\"\"Return the crossproduct between self and vec.\"\"\"\n\n        return Vec3(self.y * vec.z - self.z * vec.y,\n                    self.z * vec.x - self.x * vec.z,\n                    self.x * vec.y - self.y * vec.x)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n        return self", "response": "Set x y z components. Also return self."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nnegatives value of all components.", "response": "def neg(self):\n        \"\"\"Negative value of all components.\"\"\"\n        self.x = -self.x\n        self.y = -self.y\n        self.z = -self.z"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncopies a file to the repository", "response": "def put(self, source, rel_path, metadata=None):\n        '''Copy a file to the repository\n\n        Args:\n            source: Absolute path to the source file, or a file-like object\n            rel_path: path relative to the root of the repository\n\n        '''\n\n        # This case should probably be deprecated.\n        if not isinstance(rel_path, basestring):\n            rel_path = rel_path.cache_key\n\n        sink = self.put_stream(rel_path, metadata=metadata)\n\n        try:\n            copy_file_or_flo(source, sink)\n        except (KeyboardInterrupt, SystemExit):\n            path_ = self.path(rel_path)\n            if os.path.exists(path_):\n                os.remove(path_)\n            raise\n\n        sink.close()\n\n        return os.path.join(self.cache_dir, rel_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef put_stream(self, rel_path, metadata=None, cb=None):\n        from io import IOBase\n\n        if not isinstance(rel_path, basestring):\n            rel_path = rel_path.cache_key\n\n        repo_path = os.path.join(self.cache_dir, rel_path.strip(\"/\"))\n\n        if not os.path.isdir(os.path.dirname(repo_path)):\n            os.makedirs(os.path.dirname(repo_path))\n\n        if os.path.exists(repo_path):\n            os.remove(repo_path)\n\n        sink = open(repo_path, 'wb')\n\n        upstream = self.upstream\n\n        class flo(IOBase):\n\n            '''This File-Like-Object class ensures that the file is also\n            sent to the upstream after it is stored in the FSCache. '''\n\n            def __init__(self, sink, upstream, repo_path, rel_path):\n\n                self._sink = sink\n                self._upstream = upstream\n                self._repo_path = repo_path\n                self._rel_path = rel_path\n\n            @property\n            def rel_path(self):\n                return self._rel_path\n\n            def write(self, str_):\n                self._sink.write(str_)\n\n            def close(self):\n                if not self._sink.closed:\n                    # print \"Closing put_stream.flo {}\n                    # is_closed={}!\".format(self._repo_path, self._sink.closed)\n\n                    self._sink.close()\n\n                    if self._upstream and not self._upstream.readonly and not self._upstream.usreadonly:\n                        self._upstream.put(\n                            self._repo_path,\n                            self._rel_path,\n                            metadata=metadata)\n\n            def __enter__(self): # Can be used as a context!\n                return self\n\n            def __exit__(self, type_, value, traceback):\n                if type_:\n                    return False\n\n                self.close()\n\n        self.put_metadata(rel_path, metadata)\n\n        return flo(sink, upstream, repo_path, rel_path)", "response": "return a file object to write into the cache. The caller is responsibile for closing the stream\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, rel_path, cb=None):\n        '''Return the file path referenced but rel_path, or None if\n        it can't be found. If an upstream is declared, it will try to get the file\n        from the upstream before declaring failure.\n        '''\n        import shutil\n\n        global_logger.debug(\"FC {} get looking for {}\".format(self.repo_id,rel_path))\n\n        path = os.path.join(self.cache_dir, rel_path)\n\n        # If is already exists in the repo, just return it.\n        if os.path.exists(path):\n\n            if not os.path.isfile(path):\n                raise ValueError(\"Path does not point to a file\")\n\n            global_logger.debug( \"FC {} get {} found \".format(self.repo_id,path))\n            return path\n\n        if not self.upstream:\n            # If we don't have an upstream, then we are done.\n            return None\n\n        stream = self.upstream.get_stream(rel_path, cb=cb)\n\n        if not stream:\n            global_logger.debug(\n                \"FC {} get not found in upstream ()\".format(\n                    self.repo_id,\n                    rel_path))\n            return None\n\n        # Got a stream from upstream, so put the file in this cache.\n        dirname = os.path.dirname(path)\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n\n        try:\n            with open(path, 'w') as f:\n                #shutil.copyfileobj(stream, f)\n                copy_file_or_flo(stream, f, cb=cb)\n        except:\n            os.remove(path)\n            raise\n\n        try:\n            stream.close()\n        except AttributeError:\n            pass  # HTTPResponse objects don't have close()\n\n        if not os.path.exists(path):\n            raise Exception(\"Failed to copy upstream data to {} \".format(path))\n\n        global_logger.debug(\n            \"FC {} got return from upstream {}\".format(\n                self.repo_id,\n                rel_path))\n        return path", "response": "Return the file path referenced but rel_path or None if it can t be found."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a list of all of the files in the repository", "response": "def list(self, path=None, with_metadata=False, include_partitions=False):\n        '''get a list of all of the files in the repository'''\n        from os import walk\n        import json\n\n        l = {}\n\n        if not path:\n            start_path = self.cache_dir\n        else:\n            start_path = os.path.join(self.cache_dir, path)\n\n        for root, dirs, files in os.walk(start_path):\n\n            root = root.replace(self.cache_dir, '', 1).strip('/')\n\n            if root.startswith('meta') or root.startswith('_'):\n                continue\n\n            if not include_partitions and root.count('/') > 0:\n                continue  # partition files\n\n            for f in files:\n                rel_path = os.path.join(root, f)\n                d = self.metadata(rel_path) if with_metadata else {}\n\n                if d and 'identity' in d:\n                    d['identity'] = json.loads(d['identity'])\n\n                d['caches'] = [self.repo_id]\n\n                l[rel_path] = d\n\n        if self.upstream:\n            for k, v in self.upstream.list(path, with_metadata, include_partitions).items():\n                upstreams = (l[k]['caches'] if k in l else []) + \\\n                    v.get('caches', self.upstream.repo_id)\n\n                l[k] = v\n                l[k]['caches'] = upstreams\n\n        return l"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes the file from the cache and from the upstream", "response": "def remove(self, rel_path, propagate=False):\n        '''Delete the file from the cache, and from the upstream'''\n        repo_path = os.path.join(self.cache_dir, rel_path)\n\n        if os.path.exists(repo_path):\n            os.remove(repo_path)\n\n        if self.upstream and propagate:\n            self.upstream.remove(rel_path, propagate)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the size of all of the files referenced in the database", "response": "def size(self):\n        '''Return the size of all of the files referenced in the database'''\n        c = self.database.cursor()\n        r = c.execute(\"SELECT sum(size) FROM files\")\n\n        try:\n            size = int(r.fetchone()[0])\n        except TypeError:\n            size = 0\n\n        return size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfree up the given amount of bytes of space left.", "response": "def _free_up_space(self, size, this_rel_path=None):\n        '''If there are not size bytes of space left, delete files\n        until there is\n\n        Args:\n            size: size of the current file\n            this_rel_path: rel_pat to the current file, so we don't delete it.\n\n        '''\n\n        # Amount of space we are over ( bytes ) for next put\n        space = self.size + size - self.maxsize\n\n        if space <= 0:\n            return\n\n        removes = []\n\n        for row in self.database.execute(\"SELECT path, size, time FROM files ORDER BY time ASC\"):\n\n            if space > 0:\n                removes.append(row[0])\n                space -= row[1]\n            else:\n                break\n\n        for rel_path in removes:\n            if rel_path != this_rel_path:\n                global_logger.debug(\"Deleting {}\".format(rel_path))\n                self.remove(rel_path)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verify(self):\n        '''Check that the database accurately describes the state of the repository'''\n\n        c = self.database.cursor()\n        non_exist = set()\n\n        no_db_entry = set(os.listdir(self.cache_dir))\n        try:\n            no_db_entry.remove('file_database.db')\n            no_db_entry.remove('file_database.db-journal')\n        except:\n            pass\n\n        for row in c.execute(\"SELECT path FROM files\"):\n            path = row[0]\n\n            repo_path = os.path.join(self.cache_dir, path)\n\n            if os.path.exists(repo_path):\n                no_db_entry.remove(path)\n            else:\n                non_exist.add(path)\n\n        if len(non_exist) > 0:\n            raise Exception(\n                \"Found {} records in db for files that don't exist: {}\" .format(\n                    len(non_exist),\n                    ','.join(non_exist)))\n\n        if len(no_db_entry) > 0:\n            raise Exception(\"Found {} files that don't have db entries: {}\"\n                            .format(len(no_db_entry), ','.join(no_db_entry)))", "response": "Check that the database accurately describes the state of the repository"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, rel_path, cb=None):\n        '''Return the file path referenced but rel_path, or None if\n        it can't be found. If an upstream is declared, it will try to get the file\n        from the upstream before declaring failure.\n        '''\n        import shutil\n\n        global_logger.debug(\n            \"LC {} get looking for {}\".format(\n                self.repo_id,\n                rel_path))\n\n        path = os.path.join(self.cache_dir, rel_path)\n\n        # If is already exists in the repo, just return it.\n        if os.path.exists(path):\n\n            if not os.path.isfile(path):\n                raise ValueError(\"Path does not point to a file\")\n\n            global_logger.debug(\n                \"LC {} get {} found \".format(\n                    self.repo_id,\n                    path))\n            return path\n\n        if not self.upstream:\n            # If we don't have an upstream, then we are done.\n            return None\n\n        stream = self.upstream.get_stream(rel_path, cb=cb)\n\n        if not stream:\n            global_logger.debug(\n                \"LC {} get not found in upstream ()\".format(\n                    self.repo_id,\n                    rel_path))\n            return None\n\n        # Got a stream from upstream, so put the file in this cache.\n        dirname = os.path.dirname(path)\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n\n        # Copy the file from the lower cache into this cache.\n        with open(path, 'w') as f:\n            shutil.copyfileobj(stream, f)\n\n        # Since we've added a file, must keep track of the sizes.\n        size = os.path.getsize(path)\n        self._free_up_space(size, this_rel_path=rel_path)\n        self.add_record(rel_path, size)\n\n        stream.close()\n\n        if not os.path.exists(path):\n            raise Exception(\"Failed to copy upstream data to {} \".format(path))\n\n        global_logger.debug(\n            \"LC {} got return from upstream {} -> {} \".format(self.repo_id, rel_path, path))\n        return path", "response": "Get the file path referenced but rel_path."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npass the query to the upstream if it exists", "response": "def find(self, query):\n        '''Passes the query to the upstream, if it exists'''\n        if self.upstream:\n            return self.upstream.find(query)\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the file from the cache and from the upstream", "response": "def remove(self, rel_path, propagate=False):\n        '''Delete the file from the cache, and from the upstream'''\n        repo_path = os.path.join(self.cache_dir, rel_path)\n\n        c = self.database.cursor()\n        c.execute(\"DELETE FROM  files WHERE path = ?\", (rel_path,))\n\n        if os.path.exists(repo_path):\n            os.remove(repo_path)\n\n        self.database.commit()\n\n        if self.upstream and propagate:\n            self.upstream.remove(rel_path, propagate)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a list of all of the files in the repository", "response": "def list(self, path=None, with_metadata=False):\n        '''get a list of all of the files in the repository'''\n\n        path = path.strip('/') if path else ''\n\n        if self.upstream:\n            return self.upstream.list(path, with_metadata=with_metadata)\n        else:\n            raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find(self, query):\n        '''Passes the query to the upstream, if it exists'''\n        if not self.upstream:\n            raise Exception(\"CompressionCache must have an upstream\")\n\n        return self.upstream.find(query)", "response": "Passes the query to the upstream and returns the result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting the file from the cache and from the upstream", "response": "def remove(self, rel_path, propagate=False):\n        '''Delete the file from the cache, and from the upstream'''\n\n        if not self.upstream:\n            raise Exception(\"CompressionCache must have an upstream\")\n\n        # Must always propagate, since this is really just a filter.\n        self.upstream.remove(self._rename(rel_path), propagate)\n\n        # In case someone called get()\n        uc_rel_path = os.path.join('uncompressed', rel_path)\n\n        self.upstream.remove(uc_rel_path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list(self, path=None, with_metadata=False, include_partitions=False):\n        '''get a list of all of the files in the repository'''\n        l = self.upstream.list(\n            path,\n            with_metadata=with_metadata,\n            include_partitions=include_partitions)\n\n        lp = {}\n        for k, v in l.items():\n            lp[k.replace('.gz', '')] = v\n\n        return lp", "response": "get a list of all of the files in the repository"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreacts to given message.", "response": "def reactToAMQPMessage(message, send_back):\n    \"\"\"\n    React to given (AMQP) message. `message` is expected to be\n    :py:func:`collections.namedtuple` structure from :mod:`.structures` filled\n    with all necessary data.\n\n    Args:\n        message (object): One of the request objects defined in\n                          :mod:`.structures`.\n        send_back (fn reference): Reference to function for responding. This is\n                  useful for progress monitoring for example. Function takes\n                  one parameter, which may be response structure/namedtuple, or\n                  string or whatever would be normally returned.\n\n    Returns:\n        object: Response class from :mod:`.structures`.\n\n    Raises:\n        ValueError: if bad type of `message` structure is given.\n    \"\"\"\n    if _instanceof(message, ExportRequest):\n        tmp_folder = ltp.create_ltp_package(\n            aleph_record=message.aleph_record,\n            book_id=message.book_uuid,\n            urn_nbn=message.urn_nbn,\n            ebook_fn=message.filename,\n            url=message.url,\n            data=base64.b64decode(message.b64_data)\n        )\n\n        # remove directory from export dir, if already there\n        out_dir = os.path.join(\n            settings.EXPORT_DIR,\n            os.path.basename(message.book_uuid)\n        )\n\n        if os.path.exists(out_dir):\n            shutil.rmtree(out_dir)\n\n        shutil.move(tmp_folder, settings.EXPORT_PREFIX + out_dir)\n        return True\n\n    elif _instanceof(message, TrackingRequest):\n        uuid = message.book_uuid\n\n        status = [\n            item.replace(uuid, \"\").replace(\"/\", \"\")\n            for item in os.listdir(settings.EXPORT_DIR)\n            if uuid in item\n        ]\n\n        if not status:\n            raise ValueError(\"UUID %s not found!\" % uuid)\n\n        status = status[0]\n\n        success = [\"ok\", \"success\", \"done\"]\n        success = sum(([x, x + \"_\"] for x in success), [])  # add _ to the end\n\n        return TrackingResponse(\n            book_id=uuid,\n            exported=status.lower() in success,\n            error=status,\n        )\n\n    raise ValueError(\n        \"Unknown type of request: '\" + str(type(message)) + \"'!\"\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef format_fit(text, width=None, align='<', suffix=\"...\"):\n\n    if width==None:\n        width = get_terminal_size().columns\n\n    if len(text)>width:\n        if len(suffix)>width:\n            return suffix[len(suffix)-width:]\n        else:\n            return text[:width-len(suffix)]+suffix\n    else:\n        return \"{{:{}{{w}}}}\".format(align).format(text,w=width)", "response": "Fits a piece of text to width characters by truncating too long text and padding too short text with spaces."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nformats a string from time given in seconds.", "response": "def format_time(seconds):\n    \"\"\"\n    Formats a string from time given in seconds. For large times\n    (``abs(seconds) >= 60``) the format is::\n\n        dd:hh:mm:ss\n\n    For small times (``abs(seconds) < 60``), the result is given in 3\n    significant figures, with units given in seconds and a suitable SI-prefix.\n    \"\"\"\n\n    if not isinstance(seconds, (int, float)):\n        return str(seconds)\n\n    if math.isnan(seconds):\n        return \"-\"\n\n    if abs(seconds)<60:\n        return format_time_small(seconds)\n    else:\n        return format_time_large(seconds)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef format_time_small(seconds):\n\n    if not isinstance(seconds, (int, float)):\n        return str(seconds)\n\n    if math.isnan(seconds):\n        return \"-\"\n\n    if abs(seconds)<1:\n        milliseconds = 1000*seconds\n        if abs(milliseconds)<1:\n            microseconds = 1000*milliseconds\n            if abs(microseconds)<1:\n                nanoseconds = 1000*microseconds\n                if abs(nanoseconds)<0.5:\n                    return \"0\"\n                else:\n                    return \"{:.0f}ns\".format(nanoseconds)\n            elif abs(microseconds)<10:\n                return \"{:.2f}us\".format(microseconds)\n            elif abs(microseconds)<100:\n                return \"{:.1f}us\".format(microseconds)\n            else:\n                return \"{:.0f}us\".format(microseconds)\n        elif abs(milliseconds)<10:\n            return \"{:.2f}ms\".format(milliseconds)\n        elif abs(milliseconds)<100:\n            return \"{:.1f}ms\".format(milliseconds)\n        else:\n            return \"{:.0f}ms\".format(milliseconds)\n    elif abs(seconds)<10:\n            return \"{:.2f}s\".format(seconds)\n    elif abs(seconds)<100:\n        return \"{:.1f}s\".format(seconds)\n    else:\n        return \"{:.0f}s\".format(seconds)", "response": "Returns a string that is a small time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting the time in large format.", "response": "def format_time_large(seconds):\n    \"\"\"\n    Same as format_time() but always uses the format dd:hh:mm:ss.\n    \"\"\"\n\n    if not isinstance(seconds, (int, float)):\n        return str(seconds)\n\n    if math.isnan(seconds):\n        return \"-\"\n\n    seconds = int(round(seconds))\n    if abs(seconds)<60:\n        return \"{:d}\".format(seconds)\n    else:\n        minutes = int(seconds/60)\n        seconds %= 60\n        if abs(minutes)<60:\n            return \"{:d}:{:02d}\".format(minutes,seconds)\n        else:\n            hours = int(minutes/60)\n            minutes %= 60\n            if abs(hours)<24:\n                return \"{:d}:{:02d}:{:02d}\".format(hours,minutes,seconds)\n            else:\n                days = int(hours/24)\n                hours %= 24\n                return \"{:d}:{:02d}:{:02d}:{:02d}\".format(\n                    days,hours,minutes,seconds)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_table(table,\n                 align='<',\n                 format='{:.3g}',\n                 colwidth=None,\n                 maxwidth=None,\n                 spacing=2,\n                 truncate=0,\n                 suffix=\"...\"\n                ):\n    \"\"\"\n    Formats a table represented as an iterable of iterable into a nice big string\n    suitable for printing.\n\n    Parameters:\n    -----------\n    align : string or list of strings\n\n            Alignment of cell contents. Each character in a string specifies\n            the alignment of one column.\n\n            * ``<`` - Left aligned (default)\n            * ``^`` - Centered\n            * ``>`` - Right aligned\n\n            The last alignment is repeated for unspecified columns.\n\n            If it's a list of strings, each string specifies the alignment of\n            one row. The last string is used repeatedly for unspecified rows.\n\n    format : string/function, or (nested) list of string/function\n\n             Formats the contents of the cells using the specified function(s)\n             or format string(s).\n\n             If it's a list of strings/functions each entry specifies formatting\n             for one column, the last entry being used repeatedly for\n             unspecified columns.\n\n             If it's a list of lists, each sub-list specifies one row, the last\n             sub-list being used repeatedly for unspecified rows.\n\n    colwidth : int, list of ints or None\n\n               The width of each column. The last width is used repeatedly for\n               unspecified columns. If ``None`` the width is fitted to the\n               contents.\n\n    maxwidth : int or None\n\n               The maximum width of the table. Defaults to terminal width minus\n               1 if ``None``. If the table would be wider than ``maxwidth`` one\n               of the columns is truncated.\n\n    spacing : int\n\n              The spacing between columns\n\n    truncate : int\n\n               Which column to truncate if table width would exceed ``maxwidth``.\n\n    Beware that no columns can have zero or negative width. If for instance\n    'maxwidth' is 80 and 'colwidth' is [10, 30, 30, 30] with spacing 2 the total\n    width will initially be 10+2+30+2+30+2+30=106. That's 26 characters too\n    much, so a width of 26 will be removed from the truncated column. If\n    'truncate' is 0, column 0 will have a width of -16 which is not permitted.\n    \"\"\"\n\n    table = list(deepcopy(table))\n\n    if not isinstance(align, list):\n        align = [align]\n\n    if not isinstance(format, list):\n        format = [format]\n\n    if not isinstance(format[0], list):\n        format = [format]\n\n    num_cols = len(table[0])\n    if len(set([len(row) for row in table]))>1:\n        raise ValueError(\"All rows must have the same number of columns\")\n\n    for i in range(len(table)):\n        table[i] = list(table[i])\n        colformat = format[min(i,len(format)-1)]\n        for j, cell in enumerate(table[i]):\n            f = colformat[min(j,len(colformat)-1)]\n            if isinstance(f, str):\n                fun = lambda x: f.format(x)\n            else:\n                fun = f\n            try:\n                table[i][j] = fun(cell)\n            except:\n                table[i][j] = str(cell)\n\n    if colwidth==None:\n        cellwidth = [[len(cell) for cell in row] for row in table]\n        colwidth = list(map(max, zip(*cellwidth)))\n\n    elif not isinstance(colwidth, list):\n        colwidth = [colwidth]\n\n\n    colwidth.extend([colwidth[-1]]*(num_cols-len(colwidth)))\n\n    if maxwidth==None:\n        maxwidth = get_terminal_size().columns-1\n\n    width = sum(colwidth)+spacing*(num_cols-1)\n    if width>maxwidth:\n        colwidth[truncate] -= (width-maxwidth)\n\n    for j, cw in enumerate(colwidth):\n        if cw<1:\n            raise RuntimeError(\"Column {} in format_table() has width {}. \"\n                               \"Make sure all columns have width >0. \"\n                               \"Read docstring for further details.\"\n                               .format(j,cw)\n                              )\n\n    s = ''\n    for i, row in enumerate(table):\n        if i != 0: s += \"\\n\"\n        colalign = align[min(i,len(align)-1)]\n        colformat = format[min(i,len(format)-1)]\n        for j, col in enumerate(row):\n            a = colalign[min(j,len(colalign)-1)]\n            f = colformat[min(j,len(colformat)-1)]\n            w = colwidth[j]\n            if j!=0: s+= ' '*spacing\n            s += format_fit(format_time(col), w, a, suffix)\n\n    return s", "response": "Formats a table in nice big string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_action_list(self, page=1):\n        kw = {}\n        if page:\n            kw['inum'] = page\n        actions, _ = self._call('getactionlist', **kw)\n        result_list = []\n        for action in actions:\n            result_list.append(ActionInList.object_from_api(action))\n        return result_list", "response": "\u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u043f\u0438\u0441\u043a\u0430 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u043d\u0430 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0441\u043f\u0438\u0441\u043a\u0430 \u0441\u043e\u0431\u044b\u0442\u0438\u0439"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_action_by_id(self, action_id):\n        parsed_json, raw_json = self._call('getactionbyid', element_id=action_id)\n        action = Action.object_from_api(parsed_json, raw_json)\n        return action", "response": "Get an action by its ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an iterator over all actions in the cache.", "response": "def all_actions(self):\n        \"\"\" \u0413\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0449\u0438\u0439 \u0432\u0441\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f\n        \"\"\"\n        count = self.get_count_action()\n        page = 1\n        while True:  # \u043d\u0435 \u0446\u0438\u043a\u043b for, \u043f\u043e\u0442\u043e\u043c\u0443 \u043a\u0430\u043a \u043d\u0435 \u0443\u0432\u0435\u0440\u0435\u043d, \u0447\u0442\u043e \u0432\u0441\u0451 \u043d\u043e\u0440\u043c \u0431\u0443\u0434\u0435\u0442 \u0441 API\n            actions = self.get_action_list(page=page)\n            for action in actions:\n                yield action\n            page += 1\n            if len(actions) < options.ACTIONS_ON_PAGE or page > math.ceil(count / options.ACTIONS_ON_PAGE):\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a proxy for an actor.", "response": "def create_proxy(self, this, message):\n        \"\"\"Create proxy for an actor.\n\n        `message` has the form::\n\n            {'tag': 'create_proxy',\n             'actor': ...,\n             'customer': ...\n            }\n\n        \"\"\"\n        actor = message['actor']\n        proxy = self._create_proxy(this, actor)\n        message['customer'] << proxy"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_dataframes(symbols=(\"sne\", \"goog\", \"tsla\"), source='yahoo', refresh=False):\n    symbols = util.make_symbols(list(symbols))\n    if refresh:\n        symbols_to_refresh = symbols\n    else:\n        symbols_to_refresh = [sym for sym in symbols if not Equity.objects.filter(symbol=sym).exists()]\n    source = source.lower().strip()\n    if source in ('yahoo', 'google'):\n        source += '_finance'\n    if source[:3] == 'fed':\n        source = 'federal_reserve_economic_data'\n    ccpanda = ccp.ConcurrentPandas()\n    # set the data source\n    getattr(ccpanda, \"set_source_\" + source)()\n    if symbols_to_refresh:\n        # tell concurrent pandas which keys/symbols to retrieve\n        ccpanda.insert_keys(symbols_to_refresh)\n        # start concurrentpandas threads\n        ccpanda.consume_keys_asynchronous_threads()\n        # FIXME: is there a better/faster iterator to use like `ccpanda.output_map` attribute?\n        pseudodict = ccpanda.return_map()\n    else:\n        pseudodict = {}\n    table = {}\n    for sym in symbols:\n        e, created = None, False\n        if not sym in symbols_to_refresh:\n            e, created = Equity.objects.get_or_create(symbol=sym)\n        if created or not e or not e.time_series or sym in symbols_to_refresh:\n            e, created = Equity.objects.get_or_create(\n                symbol=sym,\n                name=sym,  # FIXME: use data source to find equity name!\n                time_series=pseudodict[sym].to_json(),\n                )\n        table[sym] = pd.io.json.read_json(path_or_buf=e.time_series, orient='columns', typ='frame', convert_dates=True)\n    return table", "response": "Return a dictionary of dataframes for each symbol requested."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves the prices of a list of equities as a DataFrame", "response": "def price_dataframe(symbols=('sne',),\n    start=datetime.datetime(2008, 1, 1),\n    end=datetime.datetime(2009, 12, 31),\n    price_type='actual_close',\n    cleaner=util.clean_dataframe,\n    ):\n    \"\"\"Retrieve the prices of a list of equities as a DataFrame (columns = symbols)\n\n    Arguments:\n      symbols (list of str): Ticker symbols like \"GOOG\", \"AAPL\", etc\n        e.g. [\"AAPL\", \" slv \", GLD\", \"GOOG\", \"$SPX\", \"XOM\", \"msft\"]\n      start (datetime): The date at the start of the period being analyzed.\n      end (datetime): The date at the end of the period being analyzed.\n        Yahoo data stops at 2013/1/1\n    \"\"\"\n    if isinstance(price_type, basestring):\n        price_type = [price_type]\n    start = nlp.util.normalize_date(start or datetime.date(2008, 1, 1))\n    end = nlp.util.normalize_date(end or datetime.date(2009, 12, 31))\n    symbols = util.make_symbols(symbols)\n    df = get_dataframes(symbols)\n    # t = du.getNYSEdays(start, end, datetime.timedelta(hours=16))\n    # df = clean_dataframes(dataobj.get_data(t, symbols, price_type))\n    if not df or len(df) > 1:\n        return cleaner(df)\n    else:\n        return cleaner(df[0])"}
